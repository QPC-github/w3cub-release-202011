
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>tensorflow&#58;&#58;ops&#58;&#58;Where - TensorFlow C++ 2.4 - W3cubDocs</title>
  
  <meta name="description" content=" #include &#60;array_ops.h&#62; ">
  <meta name="keywords" content="tensorflow, ops, where, c++, tensorflow_cpp~2.4">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow_cpp~2.4/class/tensorflow/ops/where.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/tensorflow_cpp~2.4.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow_cpp~2.4/" class="_nav-link" title="" style="margin-left:0;">TensorFlow C++ 2.4</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<devsite-mathjax config="TeX-AMS-MML_SVG"></devsite-mathjax>  <h1 id="tensorflow::ops::where" data-text="tensorflow::ops::Where">tensorflow::ops::Where</h1> <p><code translate="no" dir="ltr">#include &lt;array_ops.h&gt;</code></p> <p>Reshapes a quantized tensor as per the Reshape op. </p> <h2 id="summary" data-text="Summary">Summary</h2> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">
  
  
        Arguments:
    * scope: A Scope object
    * shape: Defines the shape of the output tensor.
    * input_min: The minimum value of the input.
    * input_max: The maximum value of the input.
  
  
        Returns:
    * `Output` output
    * `Output` output_min: This value is copied from input_min.
    * `Output` output_max: This value is copied from input_max. */
class QuantizedReshape {
 public:
  QuantizedReshape(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input shape, tensorflow::Input input_min,
                 tensorflow::Input input_max);
  
  
    Operation operation;
  tensorflow::Output output;
  tensorflow::Output output_min;
  tensorflow::Output output_max;
};
  
  
    /** Returns the rank of a tensor.
  
  
        This operation returns an integer representing the rank of `input`.
  
  
        For example:
  
  
    
    't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
  
  
    shape of tensor 't' is [2, 2, 3]
  
  rank(t) ==&gt; 3 
  
        **Note**: The rank of a tensor is not the same as the rank of a matrix. The rank
    of a tensor is the number of indices required to uniquely select each element
    of the tensor. Rank is also known as "order", "degree", or "ndims."
  
  
        Arguments:
    * scope: A Scope object
  
  
        Returns:
    * `Output`: The output tensor. */
class Rank {
 public:
  Rank(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Reshapes a tensor.
  
  
        Given `tensor`, this operation returns a tensor that has the same values
    as `tensor` with shape `shape`.
  
  
        If one component of 1-D tensor `shape` is the special value -1, the size of that
    dimension is computed so that the total size remains constant.  In particular, a
    `shape` of `[-1]` flattens into 1-D.  At most one component of `shape` may be
    unknown.
  
  
        The `shape` must be 1-D and the operation returns a tensor with shape
    `shape` filled with the values of `tensor`. In this case, the number of elements
    implied by `shape` must be the same as the number of elements in `tensor`.
  
  
        It is an error if `shape` is not 1-D.
  
  
        For example:
  
  
    
    tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]
  
  
    tensor 't' has shape [9]
  
  reshape(t, [3, 3]) ==&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
  
    tensor 't' is [[[1, 1], [2, 2]],
  
  
    [[3, 3], [4, 4]]]
  
  
    tensor 't' has shape [2, 2, 2]
  
  reshape(t, [2, 4]) ==&gt; [[1, 1, 2, 2], [3, 3, 4, 4]]
  
    tensor 't' is [[[1, 1, 1],
  
  
    [2, 2, 2]],
  
  
    [[3, 3, 3],
  
  
    [4, 4, 4]],
  
  
    [[5, 5, 5],
  
  
    [6, 6, 6]]]
  
  
    tensor 't' has shape [3, 2, 3]
  
  
    pass '[-1]' to flatten 't'
  
  reshape(t, [-1]) ==&gt; [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]
  
    -1 can also be used to infer the shape
  
  
    -1 is inferred to be 9:
  
  reshape(t, [2, -1]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5, 6, 6, 6]] -1 is inferred to be 2:
  reshape(t, [-1, 9]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5, 6, 6, 6]] -1 is inferred to be 3:
  reshape(t, [ 2, -1, 3]) ==&gt; [[[1, 1, 1], [2, 2, 2], [3, 3, 3]], [[4, 4, 4], [5, 5, 5], [6, 6, 6]]]
  
    tensor 't' is [7]
  
  
    shape [] reshapes to a scalar
  
  reshape(t, []) ==&gt; 7 
  
        Arguments:
    * scope: A Scope object
    * shape: Defines the shape of the output tensor.
  
  
        Returns:
    * `Output`: The output tensor. */
class Reshape {
 public:
  Reshape(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
        tensorflow::Input shape);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Assign `value` to the sliced l-value reference of `ref`.
  
  
        The values of `value` are assigned to the positions in the variable
    `ref` that are selected by the slice parameters. The slice parameters
    `begin, `end`, `strides`, etc. work exactly as in `StridedSlice`.
  
  
        NOTE this op currently does not support broadcasting and so `value`'s
    shape must be exactly the shape produced by the slice of `ref`.
  
  
        Arguments:
    * scope: A Scope object
  
  
        Returns:
    * the created `Operation` */
class ResourceStridedSliceAssign {
 public:
  /// Optional attribute setters for ResourceStridedSliceAssign
  struct Attrs {
    /// Defaults to 0
    TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
      Attrs ret = *this;
      ret.begin_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
      Attrs ret = *this;
      ret.end_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
      Attrs ret = *this;
      ret.ellipsis_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
      Attrs ret = *this;
      ret.new_axis_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
      Attrs ret = *this;
      ret.shrink_axis_mask_ = x;
      return ret;
    }
  
  
        int64 begin_mask_ = 0;
    int64 end_mask_ = 0;
    int64 ellipsis_mask_ = 0;
    int64 new_axis_mask_ = 0;
    int64 shrink_axis_mask_ = 0;
  };
  ResourceStridedSliceAssign(const tensorflow::Scope&amp; scope,
                           tensorflow::Input ref, tensorflow::Input begin,
                           tensorflow::Input end, tensorflow::Input
                           strides, tensorflow::Input value);
  ResourceStridedSliceAssign(const tensorflow::Scope&amp; scope,
                           tensorflow::Input ref, tensorflow::Input begin,
                           tensorflow::Input end, tensorflow::Input
                           strides, tensorflow::Input value, const
                           ResourceStridedSliceAssign::Attrs&amp; attrs);
  operator ::tensorflow::Operation() const { return operation; }
  
  
      static Attrs BeginMask(int64 x) {
    return Attrs().BeginMask(x);
  }
  static Attrs EndMask(int64 x) {
    return Attrs().EndMask(x);
  }
  static Attrs EllipsisMask(int64 x) {
    return Attrs().EllipsisMask(x);
  }
  static Attrs NewAxisMask(int64 x) {
    return Attrs().NewAxisMask(x);
  }
  static Attrs ShrinkAxisMask(int64 x) {
    return Attrs().ShrinkAxisMask(x);
  }
  
  
    Operation operation;
};
  
  
    /** Reverses variable length slices.
  
  
        This op first slices `input` along the dimension `batch_dim`, and for each
    slice `i`, reverses the first `seq_lengths[i]` elements along
    the dimension `seq_dim`.
  
  
        The elements of `seq_lengths` must obey `seq_lengths[i] &lt;= input.dims[seq_dim]`,
    and `seq_lengths` must be a vector of length `input.dims[batch_dim]`.
  
  
        The output slice `i` along dimension `batch_dim` is then given by input
    slice `i`, with the first `seq_lengths[i]` slices along dimension
    `seq_dim` reversed.
  
  
        For example:
  
  
    
    Given this:
  
  batch_dim = 0 seq_dim = 1 input.dims = (4, 8, ...) seq_lengths = [7, 2, 3, 5]
  
    then slices of input are reversed on seq_dim, but only up to seq_lengths:
  
  output[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...] output[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...] output[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...] output[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]
  
    while entries past seq_lens are copied through:
  
  output[0, 7:, :, ...] = input[0, 7:, :, ...] output[1, 2:, :, ...] = input[1, 2:, :, ...] output[2, 3:, :, ...] = input[2, 3:, :, ...] output[3, 2:, :, ...] = input[3, 2:, :, ...] 
  
        In contrast, if:
  
  
    
    Given this:
  
  batch_dim = 2 seq_dim = 0 input.dims = (8, ?, 4, ...) seq_lengths = [7, 2, 3, 5]
  
    then slices of input are reversed on seq_dim, but only up to seq_lengths:
  
  output[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...] output[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...] output[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...] output[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]
  
    while entries past seq_lens are copied through:
  
  output[7:, :, 0, :, ...] = input[7:, :, 0, :, ...] output[2:, :, 1, :, ...] = input[2:, :, 1, :, ...] output[3:, :, 2, :, ...] = input[3:, :, 2, :, ...] output[2:, :, 3, :, ...] = input[2:, :, 3, :, ...] 
  
        Arguments:
    * scope: A Scope object
    * input: The input to reverse.
    * seq_lengths: 1-D with length `input.dims(batch_dim)` and
    `max(seq_lengths) &lt;= input.dims(seq_dim)`
    * seq_dim: The dimension which is partially reversed.
  
  
        Optional attributes (see `Attrs`):
    * batch_dim: The dimension along which reversal is performed.
  
  
        Returns:
    * `Output`: The partially reversed input. It has the same shape as `input`. */
class ReverseSequence {
 public:
  /// Optional attribute setters for ReverseSequence
  struct Attrs {
    /** The dimension along which reversal is performed.
  
  
            Defaults to 0 */
    TF_MUST_USE_RESULT Attrs BatchDim(int64 x) {
      Attrs ret = *this;
      ret.batch_dim_ = x;
      return ret;
    }
  
  
        int64 batch_dim_ = 0;
  };
  ReverseSequence(const tensorflow::Scope&amp; scope, tensorflow::Input input,
                tensorflow::Input seq_lengths, int64 seq_dim);
  ReverseSequence(const tensorflow::Scope&amp; scope, tensorflow::Input input,
                tensorflow::Input seq_lengths, int64 seq_dim, const
                ReverseSequence::Attrs&amp; attrs);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
      static Attrs BatchDim(int64 x) {
    return Attrs().BatchDim(x);
  }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Reverses specific dimensions of a tensor.
  
  
        NOTE `tf.reverse` has now changed behavior in preparation for 1.0.
    `tf.reverse_v2` is currently an alias that will be deprecated before TF 1.0.
  
  
        Given a `tensor`, and a `int32` tensor `axis` representing the set of
    dimensions of `tensor` to reverse. This operation reverses each dimension
    `i` for which there exists `j` s.t. `axis[j] == i`.
  
  
        `tensor` can have up to 8 dimensions. The number of dimensions specified
    in `axis` may be 0 or more entries. If an index is specified more than
    once, a InvalidArgument error is raised.
  
  
        For example:
  
  
    
    tensor 't' is [[[[ 0, 1, 2, 3],
  
  
    [ 4, 5, 6, 7],
  
  
    [ 8, 9, 10, 11]],
  
  
    [[12, 13, 14, 15],
  
  
    [16, 17, 18, 19],
  
  
    [20, 21, 22, 23]]]]
  
  
    tensor 't' shape is [1, 2, 3, 4]
  
  
    'dims' is [3] or 'dims' is [-1]
  
  reverse(t, dims) ==&gt; [[[[ 3, 2, 1, 0], [ 7, 6, 5, 4], [ 11, 10, 9, 8]], [[15, 14, 13, 12], [19, 18, 17, 16], [23, 22, 21, 20]]]]
  
    'dims' is '[1]' (or 'dims' is '[-3]')
  
  reverse(t, dims) ==&gt; [[[[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23] [[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]]]
  
    'dims' is '[2]' (or 'dims' is '[-2]')
  
  reverse(t, dims) ==&gt; [[[[8, 9, 10, 11], [4, 5, 6, 7], [0, 1, 2, 3]] [[20, 21, 22, 23], [16, 17, 18, 19], [12, 13, 14, 15]]]] 
  
        Arguments:
    * scope: A Scope object
    * tensor: Up to 8-D.
    * axis: 1-D. The indices of the dimensions to reverse. Must be in the range
    `[-rank(tensor), rank(tensor))`.
  
  
        Returns:
    * `Output`: The same shape as `tensor`. */
class Reverse {
 public:
  Reverse(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
        tensorflow::Input axis);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Scatter `updates` into a new tensor according to `indices`.
  
  
        Creates a new tensor by applying sparse `updates` to individual values or
    slices within a tensor (initially zero for numeric, empty for string) of
    the given `shape` according to indices.  This operator is the inverse of the
    `tf.gather_nd` operator which extracts values or slices from a given tensor.
  
  
        This operation is similar to tensor_scatter_add, except that the tensor is
    zero-initialized. Calling `tf.scatter_nd(indices, values, shape)` is identical
    to `tensor_scatter_add(tf.zeros(shape, values.dtype), indices, values)`
  
  
        If `indices` contains duplicates, then their updates are accumulated (summed).
  
  
        **WARNING**: The order in which updates are applied is nondeterministic, so the
    output will be nondeterministic if `indices` contains duplicates -- because
    of some numerical approximation issues, numbers summed in different order
    may yield different results.
  
  
        `indices` is an integer tensor containing indices into a new tensor of shape
    `shape`.  The last dimension of `indices` can be at most the rank of `shape`:
  
  
            indices.shape[-1] &lt;= shape.rank
  
  
        The last dimension of `indices` corresponds to indices into elements
    (if `indices.shape[-1] = shape.rank`) or slices
    (if `indices.shape[-1] &lt; shape.rank`) along dimension `indices.shape[-1]` of
    `shape`.  `updates` is a tensor with shape
  
  
            indices.shape[:-1] + shape[indices.shape[-1]:]
  
  
        The simplest form of scatter is to insert individual elements in a tensor by
    index. For example, say we want to insert 4 scattered elements in a rank-1
    tensor with 8 elements.
  
  
    
  
  
        In Python, this scatter operation would look like this:
  
  python indices = tf.constant([[4], [3], [1], [7]]) updates = tf.constant([9, 10, 11, 12]) shape = tf.constant([8]) scatter = tf.scatter_nd(indices, updates, shape) print(scatter) 
  
        The resulting tensor would look like this:
  
  
            [0, 11, 0, 10, 9, 0, 0, 12]
  
  
        We can also, insert entire slices of a higher rank tensor all at once. For
    example, if we wanted to insert two slices in the first dimension of a
    rank-3 tensor with two matrices of new values.
  
  
    
  
  
        In Python, this scatter operation would look like this:
  
  python indices = tf.constant([[0], [2]]) updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]], [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]]]) shape = tf.constant([4, 4, 4]) scatter = tf.scatter_nd(indices, updates, shape) print(scatter) 
  
        The resulting tensor would look like this:
  
  
            [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
         [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
         [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
         [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]]
  
  
        Note that on CPU, if an out of bound index is found, an error is returned.
    On GPU, if an out of bound index is found, the index is ignored.
  
  
        Arguments:
    * scope: A Scope object
    * indices: Index tensor.
    * updates: Updates to scatter into output.
    * shape: 1-D. The shape of the resulting tensor.
  
  
        Returns:
    * `Output`: A new tensor with the given shape and updates applied according
    to the indices. */
class ScatterNd {
 public:
  ScatterNd(const tensorflow::Scope&amp; scope, tensorflow::Input indices,
          tensorflow::Input updates, tensorflow::Input shape);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Applies sparse addition to `input` using individual values or slices
  
  
        from `updates` according to indices `indices`.  The updates are non-aliasing:
    `input` is only modified in-place if no other operations will use it.
    Otherwise, a copy of `input` is made.  This operation has a gradient with
    respect to both `input` and `updates`.
  
  
        `input` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.
  
  
        `indices` must be integer tensor, containing indices into `input`.
    It must be shape \([d_0, ..., d_{Q-2}, K]\) where `0 &lt; K &lt;= P`.
  
  
        The innermost dimension of `indices` (with length `K`) corresponds to
    indices into elements (if `K = P`) or `(P-K)`-dimensional slices
    (if `K &lt; P`) along the `K`th dimension of `input`.
  
  
        `updates` is `Tensor` of rank `Q-1+P-K` with shape:
  
  
        

 $$[d_0, ..., d_{Q-2}, input.shape[K], ..., input.shape[P-1]].$$ 


  
  
        For example, say we want to add 4 scattered elements to a rank-1 tensor to 8
    elements. In Python, that addition would look like this:
  
  
            input = tf.constant([1, 2, 3, 4, 5, 6, 7, 8])
        indices = tf.constant([[4], [3], [1], [7]])
        updates = tf.constant([9, 10, 11, 12])
        output = tf.scatter_nd_non_aliasing_add(input, indices, updates)
        with tf.Session() as sess:
          print(sess.run(output))
  
  
        The resulting value `output` would look like this:
  
  
            [1, 13, 3, 14, 14, 6, 7, 20]
  
  
        See `tf.scatter_nd` for more details about how to make updates to slices.
  
  
        Arguments:
    * scope: A Scope object
    * input: A Tensor.
    * indices: A Tensor. Must be one of the following types: `int32`, `int64`.
    A tensor of indices into `input`.
    * updates: A Tensor. Must have the same type as ref. A tensor of updated values
    to add to `input`.
  
  
        Returns:
    * `Output`: A `Tensor` with the same shape as `input`, containing values of `input`
    updated with `updates`. */
class ScatterNdNonAliasingAdd {
 public:
  ScatterNdNonAliasingAdd(const tensorflow::Scope&amp; scope, tensorflow::Input
                        input, tensorflow::Input indices, tensorflow::Input
                        updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Returns the shape of a tensor.
  
  
        This operation returns a 1-D integer tensor representing the shape of `input`.
  
  
        For example:
  
  
    
    't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
  
  shape(t) ==&gt; [2, 2, 3] 
  
        Arguments:
    * scope: A Scope object
  
  
        Returns:
    * `Output`: The output tensor. */
class Shape {
 public:
  /// Optional attribute setters for Shape
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutType(DataType x) {
      Attrs ret = *this;
      ret.out_type_ = x;
      return ret;
    }
  
  
        DataType out_type_ = DT_INT32;
  };
  Shape(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
  Shape(const tensorflow::Scope&amp; scope, tensorflow::Input input, const
      Shape::Attrs&amp; attrs);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
      static Attrs OutType(DataType x) {
    return Attrs().OutType(x);
  }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Returns shape of tensors.
  
  
        This operation returns N 1-D integer tensors representing shape of `input[i]s`.
  
  
        Arguments:
    * scope: A Scope object
  
  
        Returns:
    * `OutputList`: The output tensor. */
class ShapeN {
 public:
  /// Optional attribute setters for ShapeN
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutType(DataType x) {
      Attrs ret = *this;
      ret.out_type_ = x;
      return ret;
    }
  
  
        DataType out_type_ = DT_INT32;
  };
  ShapeN(const ::tensorflow::Scope&amp; scope, ::tensorflow::InputList input);
  ShapeN(const tensorflow::Scope&amp; scope, tensorflow::InputList input, const
       ShapeN::Attrs&amp; attrs);
  tensorflow::Output operator[](size_t index) const { return output[index]; }
  
  
      static Attrs OutType(DataType x) {
    return Attrs().OutType(x);
  }
  
  
    Operation operation;
  ::tensorflow::OutputList output;
};
  
  
    /** Returns the size of a tensor.
  
  
        This operation returns an integer representing the number of elements in
    `input`.
  
  
        For example:
  
  
    
    't' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]
  
  size(t) ==&gt; 12 
  
        Arguments:
    * scope: A Scope object
  
  
        Returns:
    * `Output`: The output tensor. */
class Size {
 public:
  /// Optional attribute setters for Size
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutType(DataType x) {
      Attrs ret = *this;
      ret.out_type_ = x;
      return ret;
    }
  
  
        DataType out_type_ = DT_INT32;
  };
  Size(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
  Size(const tensorflow::Scope&amp; scope, tensorflow::Input input, const
     Size::Attrs&amp; attrs);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
      static Attrs OutType(DataType x) {
    return Attrs().OutType(x);
  }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Return a slice from 'input'.
  
  
        The output tensor is a tensor with dimensions described by 'size'
    whose values are extracted from 'input' starting at the offsets in
    'begin'.
  
  
        *Requirements*:
      0 &lt;= begin[i] &lt;= begin[i] + size[i] &lt;= Di  for i in [0, n)
  
  
        Arguments:
    * scope: A Scope object
    * begin: begin[i] specifies the offset into the 'i'th dimension of
    'input' to slice from.
    * size: size[i] specifies the number of elements of the 'i'th dimension
    of 'input' to slice. If size[i] is -1, all remaining elements in dimension
    i are included in the slice (i.e. this is equivalent to setting
    size[i] = input.dim_size(i) - begin[i]).
  
  
        Returns:
    * `Output`: The output tensor. */
class Slice {
 public:
  Slice(const tensorflow::Scope&amp; scope, tensorflow::Input input,
      tensorflow::Input begin, tensorflow::Input size);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Returns a copy of the input tensor.
  
  
        Arguments:
    * scope: A Scope object
  
  
        Returns:
    * `Output`: The output tensor. */
class Snapshot {
 public:
  Snapshot(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** SpaceToBatch for 4-D tensors of type T.
  
  
        This is a legacy version of the more general SpaceToBatchND.
  
  
        Zero-pads and then rearranges (permutes) blocks of spatial data into batch.
    More specifically, this op outputs a copy of the input tensor where values from
    the `height` and `width` dimensions are moved to the `batch` dimension. After
    the zero-padding, both `height` and `width` of the input must be divisible by the
    block size.
  
  
        Arguments:
    * scope: A Scope object
    * input: 4-D with shape `[batch, height, width, depth]`.
    * paddings: 2-D tensor of non-negative integers with shape `[2, 2]`. It specifies
      the padding of the input with zeros across the spatial dimensions as follows:
  
  
              paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]
  
  
          The effective spatial dimensions of the zero-padded input tensor will be:
  
  
              height_pad = pad_top + height + pad_bottom
          width_pad = pad_left + width + pad_right
  
  
        The attr `block_size` must be greater than one. It indicates the block size.
  
  
          * Non-overlapping blocks of size `block_size x block size` in the height and
        width dimensions are rearranged into the batch dimension at each location.
      * The batch of the output tensor is `batch * block_size * block_size`.
      * Both height_pad and width_pad must be divisible by block_size.
  
  
        The shape of the output will be:
  
  
            [batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
         depth]
  
  
        Some examples:
  
  
        (1) For the following input of shape `[1, 2, 2, 1]` and block_size of 2:
  
   x = [[[[1], [2]], [[3], [4]]]] 
  
        The output tensor has shape `[4, 1, 1, 1]` and value:
  
   [[[[1]]], [[[2]]], [[[3]]], [[[4]]]] 
  
        (2) For the following input of shape `[1, 2, 2, 3]` and block_size of 2:
  
   x = [[[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]] 
  
        The output tensor has shape `[4, 1, 1, 3]` and value:
  
   [[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]] 
  
        (3) For the following input of shape `[1, 4, 4, 1]` and block_size of 2:
  
   x = [[[[1], [2], [3], [4]], [[5], [6], [7], [8]], [[9], [10], [11], [12]], [[13], [14], [15], [16]]]] 
  
        The output tensor has shape `[4, 2, 2, 1]` and value:
  
   x = [[[[1], [3]], [[9], [11]]], [[[2], [4]], [[10], [12]]], [[[5], [7]], [[13], [15]]], [[[6], [8]], [[14], [16]]]] 
  
        (4) For the following input of shape `[2, 2, 4, 1]` and block_size of 2:
  
   x = [[[[1], [2], [3], [4]], [[5], [6], [7], [8]]], [[[9], [10], [11], [12]], [[13], [14], [15], [16]]]] 
  
        The output tensor has shape `[8, 1, 2, 1]` and value:
  
   x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]], [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]] 
  
        Among others, this operation is useful for reducing atrous convolution into
    regular convolution.
  
  
        Returns:
    * `Output`: The output tensor. */
class SpaceToBatch {
 public:
  SpaceToBatch(const tensorflow::Scope&amp; scope, tensorflow::Input input,
             tensorflow::Input paddings, int64 block_size);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** SpaceToBatch for N-D tensors of type T.
  
  
        This operation divides "spatial" dimensions `[1, ..., M]` of the input into a
    grid of blocks of shape `block_shape`, and interleaves these blocks with the
    "batch" dimension (0) such that in the output, the spatial dimensions
    `[1, ..., M]` correspond to the position within the grid, and the batch
    dimension combines both the position within a spatial block and the original
    batch position.  Prior to division into blocks, the spatial dimensions of the
    input are optionally zero padded according to `paddings`.  See below for a
    precise description.
  
  
        Arguments:
    * scope: A Scope object
    * input: N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`,
    where spatial_shape has `M` dimensions.
    * block_shape: 1-D with shape `[M]`, all values must be &gt;= 1.
    * paddings: 2-D with shape `[M, 2]`, all values must be &gt;= 0.
      `paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension
      `i + 1`, which corresponds to spatial dimension `i`.  It is required that
      `block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.
  
  
        This operation is equivalent to the following steps:
  
  
        1. Zero-pad the start and end of dimensions `[1, ..., M]` of the
       input according to `paddings` to produce `padded` of shape `padded_shape`.
  
  
        2. Reshape `padded` to `reshaped_padded` of shape:
  
  
             [batch] +
         [padded_shape[1] / block_shape[0],
           block_shape[0],
          ...,
          padded_shape[M] / block_shape[M-1],
          block_shape[M-1]] +
         remaining_shape
  
  
        3. Permute dimensions of `reshaped_padded` to produce
       `permuted_reshaped_padded` of shape:
  
  
             block_shape +
         [batch] +
         [padded_shape[1] / block_shape[0],
          ...,
          padded_shape[M] / block_shape[M-1]] +
         remaining_shape
  
  
        4. Reshape `permuted_reshaped_padded` to flatten `block_shape` into the batch
       dimension, producing an output tensor of shape:
  
  
             [batch * prod(block_shape)] +
         [padded_shape[1] / block_shape[0],
          ...,
          padded_shape[M] / block_shape[M-1]] +
         remaining_shape
  
  
        Some examples:
  
  
        (1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and
        `paddings = [[0, 0], [0, 0]]`:
  
   x = [[[[1], [2]], [[3], [4]]]] 
  
        The output tensor has shape `[4, 1, 1, 1]` and value:
  
   [[[[1]]], [[[2]]], [[[3]]], [[[4]]]] 
  
        (2) For the following input of shape `[1, 2, 2, 3]`, `block_shape = [2, 2]`, and
        `paddings = [[0, 0], [0, 0]]`:
  
   x = [[[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]] 
  
        The output tensor has shape `[4, 1, 1, 3]` and value:
  
   [[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]] 
  
        (3) For the following input of shape `[1, 4, 4, 1]`, `block_shape = [2, 2]`, and
        `paddings = [[0, 0], [0, 0]]`:
  
   x = [[[[1], [2], [3], [4]], [[5], [6], [7], [8]], [[9], [10], [11], [12]], [[13], [14], [15], [16]]]] 
  
        The output tensor has shape `[4, 2, 2, 1]` and value:
  
   x = [[[[1], [3]], [[9], [11]]], [[[2], [4]], [[10], [12]]], [[[5], [7]], [[13], [15]]], [[[6], [8]], [[14], [16]]]] 
  
        (4) For the following input of shape `[2, 2, 4, 1]`, block_shape = `[2, 2]`, and
        paddings = `[[0, 0], [2, 0]]`:
  
   x = [[[[1], [2], [3], [4]], [[5], [6], [7], [8]]], [[[9], [10], [11], [12]], [[13], [14], [15], [16]]]] 
  
        The output tensor has shape `[8, 1, 3, 1]` and value:
  
   x = [[[[0], [1], [3]]], [[[0], [9], [11]]], [[[0], [2], [4]]], [[[0], [10], [12]]], [[[0], [5], [7]]], [[[0], [13], [15]]], [[[0], [6], [8]]], [[[0], [14], [16]]]] 
  
        Among others, this operation is useful for reducing atrous convolution into
    regular convolution.
  
  
        Returns:
    * `Output`: The output tensor. */
class SpaceToBatchND {
 public:
  SpaceToBatchND(const tensorflow::Scope&amp; scope, tensorflow::Input input,
               tensorflow::Input block_shape, tensorflow::Input paddings);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** SpaceToDepth for tensors of type T.
  
  
        Rearranges blocks of spatial data, into depth. More specifically,
    this op outputs a copy of the input tensor where values from the `height`
    and `width` dimensions are moved to the `depth` dimension.
    The attr `block_size` indicates the input block size.
  
  
          * Non-overlapping blocks of size `block_size x block size` are rearranged
        into depth at each location.
      * The depth of the output tensor is `block_size * block_size * input_depth`.
      * The Y, X coordinates within each block of the input become the high order
        component of the output channel index.
      * The input tensor's height and width must be divisible by block_size.
  
  
        The `data_format` attr specifies the layout of the input and output tensors
    with the following options:
      "NHWC": `[ batch, height, width, channels ]`
      "NCHW": `[ batch, channels, height, width ]`
      "NCHW_VECT_C":
          `qint8 [ batch, channels / 4, height, width, 4 ]`
  
  
        It is useful to consider the operation as transforming a 6-D Tensor.
    e.g. for data_format = NHWC,
         Each element in the input tensor can be specified via 6 coordinates,
         ordered by decreasing memory layout significance as:
         n,oY,bY,oX,bX,iC  (where n=batch index, oX, oY means X or Y coordinates
                            within the output image, bX, bY means coordinates
                            within the input block, iC means input channels).
         The output would be a transpose to the following layout:
         n,oY,oX,bY,bX,iC
  
  
        This operation is useful for resizing the activations between convolutions
    (but keeping all data), e.g. instead of pooling. It is also useful for training
    purely convolutional models.
  
  
        For example, given an input of shape `[1, 2, 2, 1]`, data_format = "NHWC" and
    block_size = 2:
  
   x = [[[[1], [2]], [[3], [4]]]] 
  
        This operation will output a tensor of shape `[1, 1, 1, 4]`:
  
   [[[[1, 2, 3, 4]]]] 
  
        Here, the input has a batch of 1 and each batch element has shape `[2, 2, 1]`,
    the corresponding output will have a single element (i.e. width and height are
    both 1) and will have a depth of 4 channels (1 * block_size * block_size).
    The output element shape is `[1, 1, 4]`.
  
  
        For an input tensor with larger depth, here of shape `[1, 2, 2, 3]`, e.g.
  
   x = [[[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]] 
  
        This operation, for block_size of 2, will return the following tensor of shape
    `[1, 1, 1, 12]`
  
   [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]] 
  
        Similarly, for the following input of shape `[1 4 4 1]`, and a block size of 2:
  
   x = [[[[1], [2], [5], [6]], [[3], [4], [7], [8]], [[9], [10], [13], [14]], [[11], [12], [15], [16]]]] 
  
        the operator will return the following tensor of shape `[1 2 2 4]`:
  
   x = [[[[1, 2, 3, 4], [5, 6, 7, 8]], [[9, 10, 11, 12], [13, 14, 15, 16]]]] 
  
        Arguments:
    * scope: A Scope object
    * block_size: The size of the spatial block.
  
  
        Returns:
    * `Output`: The output tensor. */
class SpaceToDepth {
 public:
  /// Optional attribute setters for SpaceToDepth
  struct Attrs {
    /// Defaults to "NHWC"
    TF_MUST_USE_RESULT Attrs DataFormat(StringPiece x) {
      Attrs ret = *this;
      ret.data_format_ = x;
      return ret;
    }
  
  
        StringPiece data_format_ = "NHWC";
  };
  SpaceToDepth(const tensorflow::Scope&amp; scope, tensorflow::Input input, int64
             block_size);
  SpaceToDepth(const tensorflow::Scope&amp; scope, tensorflow::Input input, int64
             block_size, const SpaceToDepth::Attrs&amp; attrs);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
      static Attrs DataFormat(StringPiece x) {
    return Attrs().DataFormat(x);
  }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Splits a tensor into `num_split` tensors along one dimension.
  
  
        Arguments:
    * scope: A Scope object
    * axis: 0-D.  The dimension along which to split.  Must be in the range
    `[-rank(value), rank(value))`.
    * value: The tensor to split.
    * num_split: The number of ways to split.  Must evenly divide
    `value.shape[split_dim]`.
  
  
        Returns:
    * `OutputList`: They are identically shaped tensors, whose shape matches that of `value`
    except along `axis`, where their sizes are
    `values.shape[split_dim] / num_split`. */
class Split {
 public:
  Split(const tensorflow::Scope&amp; scope, tensorflow::Input axis,
      tensorflow::Input value, int64 num_split);
  tensorflow::Output operator[](size_t index) const { return output[index]; }
  
  
    Operation operation;
  ::tensorflow::OutputList output;
};
  
  
    /** Splits a tensor into `num_split` tensors along one dimension.
  
  
        Arguments:
    * scope: A Scope object
    * value: The tensor to split.
    * size_splits: list containing the sizes of each output tensor along the split
    dimension. Must sum to the dimension of value along split_dim.
    Can contain one -1 indicating that dimension is to be inferred.
    * axis: 0-D.  The dimension along which to split.  Must be in the range
    `[-rank(value), rank(value))`.
  
  
        Returns:
    * `OutputList`: Tensors whose shape matches that of `value`
    except along `axis`, where their sizes are
    `size_splits[i]`. */
class SplitV {
 public:
  SplitV(const tensorflow::Scope&amp; scope, tensorflow::Input value,
       tensorflow::Input size_splits, tensorflow::Input axis, int64
       num_split);
  tensorflow::Output operator[](size_t index) const { return output[index]; }
  
  
    Operation operation;
  ::tensorflow::OutputList output;
};
  
  
    /** Removes dimensions of size 1 from the shape of a tensor.
  
  
        Given a tensor `input`, this operation returns a tensor of the same type with
    all dimensions of size 1 removed. If you don't want to remove all size 1
    dimensions, you can remove specific size 1 dimensions by specifying
    `axis`.
  
  
        For example:
  
  
    
    't' is a tensor of shape [1, 2, 1, 3, 1, 1]
  
  shape(squeeze(t)) ==&gt; [2, 3] 
  
        Or, to remove specific size 1 dimensions:
  
  
    
    't' is a tensor of shape [1, 2, 1, 3, 1, 1]
  
  shape(squeeze(t, [2, 4])) ==&gt; [1, 2, 3, 1] 
  
        Arguments:
    * scope: A Scope object
    * input: The `input` to squeeze.
  
  
        Optional attributes (see `Attrs`):
    * axis: If specified, only squeezes the dimensions listed. The dimension
    index starts at 0. It is an error to squeeze a dimension that is not 1. Must
    be in the range `[-rank(input), rank(input))`.
  
  
        Returns:
    * `Output`: Contains the same data as `input`, but has one or more dimensions of
    size 1 removed. */
class Squeeze {
 public:
  /// Optional attribute setters for Squeeze
  struct Attrs {
    /** If specified, only squeezes the dimensions listed. The dimension
        index starts at 0. It is an error to squeeze a dimension that is not 1. Must
        be in the range `[-rank(input), rank(input))`.
  
  
            Defaults to [] */
    TF_MUST_USE_RESULT Attrs Axis(const gtl::ArraySlice&amp; x) {
      Attrs ret = *this;
      ret.axis_ = x;
      return ret;
    }
  
  
        gtl::ArraySlice axis_ = {};
  };
  Squeeze(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
  Squeeze(const tensorflow::Scope&amp; scope, tensorflow::Input input, const
        Squeeze::Attrs&amp; attrs);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
      static Attrs Axis(const gtl::ArraySlice&amp; x) {
    return Attrs().Axis(x);
  }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Stops gradient computation.
  
  
        When executed in a graph, this op outputs its input tensor as-is.
  
  
        When building ops to compute gradients, this op prevents the contribution of
    its inputs to be taken into account.  Normally, the gradient generator adds ops
    to a graph to compute the derivatives of a specified 'loss' by recursively
    finding out inputs that contributed to its computation.  If you insert this op
    in the graph it inputs are masked from the gradient generator.  They are not
    taken into account for computing gradients.
  
  
        This is useful any time you want to compute a value with TensorFlow but need
    to pretend that the value was a constant. Some examples include:
  
  
        *  The *EM* algorithm where the *M-step* should not involve backpropagation
       through the output of the *E-step*.
    *  Contrastive divergence training of Boltzmann machines where, when
       differentiating the energy function, the training must not backpropagate
       through the graph that generated the samples from the model.
    *  Adversarial training, where no backprop should happen through the adversarial
       example generation process.
  
  
        Arguments:
    * scope: A Scope object
  
  
        Returns:
    * `Output`: The output tensor. */
class StopGradient {
 public:
  StopGradient(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Return a strided slice from `input`.
  
  
        Note, most python users will want to use the Python `Tensor.__getitem__`
    or `Variable.__getitem__` rather than this op directly.
  
  
        The goal of this op is to produce a new tensor with a subset of
    the elements from the `n` dimensional `input` tensor. The subset is chosen using
    a sequence of `m` sparse range specifications encoded into the arguments
    of this function. Note, in some cases
    `m` could be equal to `n`, but this need not be the case. Each
    range specification entry can be one of the following:
  
  
    </pre>
<ul><li>An ellipsis (...). Ellipses are used to imply zero or more dimensions of full-dimension selection and are produced using `ellipsis_mask`. For example, `foo[...]` is the identity slice.</li></ul> 

<ul><li>A new axis. This is used to insert a new shape=1 dimension and is produced using `new_axis_mask`. For example, `foo[:, ...]` where `foo` is shape `(3, 4)` produces a `(1, 3, 4)` tensor.</li></ul> 

<ul><li>A range `begin:end:stride`. This is used to specify how much to choose from a given dimension. `stride` can be any integer but 0. `begin` is an integer which represents the index of the first value to select while `end` represents the index of the last value to select. The number of values selected in each dimension is `end - begin` if `stride &gt; 0` and `begin - end` if `stride &lt; 0`. `begin` and `end` can be negative where `-1` is the last element, `-2` is the second to last. `begin_mask` controls whether to replace the explicitly given `begin` with an implicit effective value of `0` if `stride &gt; 0` and `-1` if `stride &lt; 0`. `end_mask` is analogous but produces the number required to create the largest open interval. For example, given a shape `(3,)` tensor `foo[:]`, the effective `begin` and `end` are `0` and `3`. Do not assume this is equivalent to `foo[0:-1]` which has an effective `begin` and `end` of `0` and `2`. Another example is `foo[-2::-1]` which reverses the first dimension of a tensor while dropping the last two (in the original order elements). For example `foo = [1,2,3,4]; foo[-2::-1]` is `[4,3]`.</li></ul> 

<ul><li>A single index. This is used to keep only elements that have a given index. For example (`foo[2, :]` on a shape `(5,6)` tensor produces a shape `(6,)` tensor. This is encoded in `begin` and `end` and `shrink_axis_mask`.</li></ul> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Each conceptual range specification is encoded in the op's argument. This
encoding is best understand by considering a non-trivial example. In
particular,
`foo[1, 2:4, None, ..., :-3:-1, :]` will be encoded as</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp"> begin = [1, 2, x, x, 0, x] # x denotes don't care (usually 0) end = [2, 4, x, x, -3, x] strides = [1, 1, x, x, -1, 1] begin_mask = 1&lt;&lt;4 | 1&lt;&lt;5 = 48 end_mask = 1&lt;&lt;5 = 32 ellipsis_mask = 1&lt;&lt;3 = 8 new_axis_mask = 1&lt;&lt;2 = 4 shrink_axis_mask = 1&lt;&lt;0 = 1 
  
        In this case if foo.shape is (5, 5, 5, 5, 5, 5) the final shape of
    the slice becomes (2, 1, 5, 5, 2, 5).
    Let us walk step by step through each argument specification.
  
  
        1.  The first argument in the example slice is turned into begin = 1 and
    end = begin + 1 = 2. To disambiguate from the original spec 2:4 we
    also set the appropriate bit in shrink_axis_mask.
  
  
        2. 2:4 is contributes 2, 4, 1 to begin, end, and stride. All masks have
    zero bits contributed.
  
  
        3. None is a synonym for tf.newaxis. This means insert a dimension of size 1
    dimension in the final shape. Dummy values are contributed to begin,
    end and stride, while the new_axis_mask bit is set.
  
  
        4. ... grab the full ranges from as many dimensions as needed to
    fully specify a slice for every dimension of the input shape.
  
  
        5. :-3:-1 shows the use of negative indices. A negative index i associated
    with a dimension that has shape s is converted to a positive index
    s + i. So -1 becomes s-1 (i.e. the last element). This conversion
    is done internally so begin, end and strides receive x, -3, and -1.
    The appropriate begin_mask bit is set to indicate the start range is the
    full range (ignoring the x).
  
  
        6. : indicates that the entire contents of the corresponding dimension
    is selected. This is equivalent to :: or 0::1. begin, end, and strides
    receive 0, 0, and 1, respectively. The appropriate bits in begin_mask and
    end_mask are also set.
  
  
    Requirements:
      0 != strides[i] for i in [0, m)ellipsis_mask must be a power of two (only one ellipsis)
  
  
        Arguments:
    * scope: A Scope object
    * begin: begin[k] specifies the offset into the kth range specification.
    The exact dimension this corresponds to will be determined by context.
    Out-of-bounds values will be silently clamped. If the kth bit of
    begin_mask then begin[k] is ignored and the full range of the
    appropriate dimension is used instead. Negative values causes indexing
    to start from the highest element e.g. If foo==[1,2,3] then foo[-1]==3.
    * end: end[i] is like begin with the exception that end_mask is
    used to determine full ranges.
    * strides: strides[i] specifies the increment in the ith specification
    after extracting a given element. Negative indices will reverse
    the original order. Out or range values are
    clamped to [0,dim[i]) if slice[i]&gt;0 or [-1,dim[i]-1] if slice[i] &lt; 0
  
  
        Optional attributes (see Attrs):
    * begin_mask: a bitmask where a bit i being 1 means to ignore the begin
    value and instead use the largest interval possible. At runtime
    begin[i] will be replaced with [0, n-1) if stride[i] &gt; 0 or
    [-1, n-1] if stride[i] &lt; 0
    * end_mask: analogous to begin_mask
    * ellipsis_mask: a bitmask where bit i being 1 means the ith
    position is actually an ellipsis. One bit at most can be 1.
    If ellipsis_mask == 0, then an implicit ellipsis mask of 1 &lt;&lt; (m+1)
    is provided. This means that foo[3:5] == foo[3:5, ...]. An ellipsis
    implicitly creates as many range specifications as necessary to fully
    specify the sliced range for every dimension. For example for a 4-dimensional
    tensor foo the slice foo[2, ..., 5:8] implies foo[2, :, :, 5:8].
    * new_axis_mask: a bitmask where bit i being 1 means the ith
    specification creates a new shape 1 dimension. For example
    foo[:4, tf.newaxis, :2] would produce a shape (4, 1, 2) tensor.
    * shrink_axis_mask: a bitmask where bit i implies that the ith
    specification should shrink the dimensionality. begin and end
    must imply a slice of size 1 in the dimension. For example in
    python one might do foo[:, 3, :] which would result in
    shrink_axis_mask being 2.
  
  
        Returns:
    * Output: The output tensor. */
class StridedSlice {
 public:
  /// Optional attribute setters for StridedSlice
  struct Attrs {
    /** a bitmask where a bit i being 1 means to ignore the begin
        value and instead use the largest interval possible. At runtime
        begin[i] will be replaced with [0, n-1) if stride[i] &gt; 0 or
        [-1, n-1] if stride[i] &lt; 0
  
  
            Defaults to 0 */
    TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
      Attrs ret = *this;
      ret.begin_mask_ = x;
      return ret;
    }
  
  
        /** analogous to begin_mask
  
  
            Defaults to 0 */
    TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
      Attrs ret = *this;
      ret.end_mask_ = x;
      return ret;
    }
  
  
        /** a bitmask where bit i being 1 means the ith
        position is actually an ellipsis. One bit at most can be 1.
        If ellipsis_mask == 0, then an implicit ellipsis mask of 1 &lt;&lt; (m+1)
        is provided. This means that foo[3:5] == foo[3:5, ...]. An ellipsis
        implicitly creates as many range specifications as necessary to fully
        specify the sliced range for every dimension. For example for a 4-dimensional
        tensor foo the slice foo[2, ..., 5:8] implies foo[2, :, :, 5:8].
  
  
            Defaults to 0 */
    TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
      Attrs ret = *this;
      ret.ellipsis_mask_ = x;
      return ret;
    }
  
  
        /** a bitmask where bit i being 1 means the ith
        specification creates a new shape 1 dimension. For example
        foo[:4, tf.newaxis, :2] would produce a shape (4, 1, 2) tensor.
  
  
            Defaults to 0 */
    TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
      Attrs ret = *this;
      ret.new_axis_mask_ = x;
      return ret;
    }
  
  
        /** a bitmask where bit i implies that the ith
        specification should shrink the dimensionality. begin and end
        must imply a slice of size 1 in the dimension. For example in
        python one might do foo[:, 3, :] which would result in
        shrink_axis_mask being 2.
  
  
            Defaults to 0 */
    TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
      Attrs ret = *this;
      ret.shrink_axis_mask_ = x;
      return ret;
    }
  
  
        int64 begin_mask_ = 0;
    int64 end_mask_ = 0;
    int64 ellipsis_mask_ = 0;
    int64 new_axis_mask_ = 0;
    int64 shrink_axis_mask_ = 0;
  };
  StridedSlice(const tensorflow::Scope&amp; scope, tensorflow::Input input,
             tensorflow::Input begin, tensorflow::Input end,
             tensorflow::Input strides);
  StridedSlice(const tensorflow::Scope&amp; scope, tensorflow::Input input,
             tensorflow::Input begin, tensorflow::Input end,
             tensorflow::Input strides, const StridedSlice::Attrs&amp; attrs);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
      static Attrs BeginMask(int64 x) {
    return Attrs().BeginMask(x);
  }
  static Attrs EndMask(int64 x) {
    return Attrs().EndMask(x);
  }
  static Attrs EllipsisMask(int64 x) {
    return Attrs().EllipsisMask(x);
  }
  static Attrs NewAxisMask(int64 x) {
    return Attrs().NewAxisMask(x);
  }
  static Attrs ShrinkAxisMask(int64 x) {
    return Attrs().ShrinkAxisMask(x);
  }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Assignvalue to the sliced l-value reference of ref.
  
  
        The values of value are assigned to the positions in the variable
    ref that are selected by the slice parameters. The slice parameters
    begin, end, strides, etc. work exactly as in StridedSlice.
  
  
        NOTE this op currently does not support broadcasting and so value's
    shape must be exactly the shape produced by the slice of ref.
  
  
        Arguments:
    * scope: A Scope object
  
  
        Returns:
    * Output: The output_ref tensor. */
class StridedSliceAssign {
 public:
  /// Optional attribute setters for StridedSliceAssign
  struct Attrs {
    /// Defaults to 0
    TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
      Attrs ret = *this;
      ret.begin_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
      Attrs ret = *this;
      ret.end_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
      Attrs ret = *this;
      ret.ellipsis_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
      Attrs ret = *this;
      ret.new_axis_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
      Attrs ret = *this;
      ret.shrink_axis_mask_ = x;
      return ret;
    }
  
  
        int64 begin_mask_ = 0;
    int64 end_mask_ = 0;
    int64 ellipsis_mask_ = 0;
    int64 new_axis_mask_ = 0;
    int64 shrink_axis_mask_ = 0;
  };
  StridedSliceAssign(const tensorflow::Scope&amp; scope, tensorflow::Input ref,
                   tensorflow::Input begin, tensorflow::Input end,
                   tensorflow::Input strides, tensorflow::Input value);
  StridedSliceAssign(const tensorflow::Scope&amp; scope, tensorflow::Input ref,
                   tensorflow::Input begin, tensorflow::Input end,
                   tensorflow::Input strides, tensorflow::Input value,
                   const StridedSliceAssign::Attrs&amp; attrs);
  operator ::tensorflow::Output() const { return output_ref; }
  operator ::tensorflow::Input() const { return output_ref; }
  ::tensorflow::Node* node() const { return output_ref.node(); }
  
  
      static Attrs BeginMask(int64 x) {
    return Attrs().BeginMask(x);
  }
  static Attrs EndMask(int64 x) {
    return Attrs().EndMask(x);
  }
  static Attrs EllipsisMask(int64 x) {
    return Attrs().EllipsisMask(x);
  }
  static Attrs NewAxisMask(int64 x) {
    return Attrs().NewAxisMask(x);
  }
  static Attrs ShrinkAxisMask(int64 x) {
    return Attrs().ShrinkAxisMask(x);
  }
  
  
    Operation operation;
  tensorflow::Output output_ref;
};
  
  
    /** Returns the gradient of StridedSlice.
  
  
        Since StridedSlice cuts out pieces of its input which is size
    shape, its gradient will have the same shape (which is passed here
    as shape). The gradient will be zero in any element that the slice
    does not select.
  
  
        Arguments are the same as StridedSliceGrad with the exception that
    dy is the input gradient to be propagated and shape is the
    shape of StridedSlice's input.
  
  
        Arguments:
    * scope: A Scope object
  
  
        Returns:
    * Output: The output tensor. */
class StridedSliceGrad {
 public:
  /// Optional attribute setters for StridedSliceGrad
  struct Attrs {
    /// Defaults to 0
    TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
      Attrs ret = *this;
      ret.begin_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
      Attrs ret = *this;
      ret.end_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
      Attrs ret = *this;
      ret.ellipsis_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
      Attrs ret = *this;
      ret.new_axis_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
      Attrs ret = *this;
      ret.shrink_axis_mask_ = x;
      return ret;
    }
  
  
        int64 begin_mask_ = 0;
    int64 end_mask_ = 0;
    int64 ellipsis_mask_ = 0;
    int64 new_axis_mask_ = 0;
    int64 shrink_axis_mask_ = 0;
  };
  StridedSliceGrad(const tensorflow::Scope&amp; scope, tensorflow::Input shape,
                 tensorflow::Input begin, tensorflow::Input end,
                 tensorflow::Input strides, tensorflow::Input dy);
  StridedSliceGrad(const tensorflow::Scope&amp; scope, tensorflow::Input shape,
                 tensorflow::Input begin, tensorflow::Input end,
                 tensorflow::Input strides, tensorflow::Input dy, const
                 StridedSliceGrad::Attrs&amp; attrs);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
      static Attrs BeginMask(int64 x) {
    return Attrs().BeginMask(x);
  }
  static Attrs EndMask(int64 x) {
    return Attrs().EndMask(x);
  }
  static Attrs EllipsisMask(int64 x) {
    return Attrs().EllipsisMask(x);
  }
  static Attrs NewAxisMask(int64 x) {
    return Attrs().NewAxisMask(x);
  }
  static Attrs ShrinkAxisMask(int64 x) {
    return Attrs().ShrinkAxisMask(x);
  }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Adds sparse updates to an existing tensor according to indices.
  
  
        This operation creates a new tensor by adding sparse updates to the passed
    in tensor.
    This operation is very similar to tf.scatter_nd_add, except that the updates
    are added onto an existing tensor (as opposed to a variable). If the memory
    for the existing tensor cannot be re-used, a copy is made and updated.
  
  
    indices is an integer tensor containing indices into a new tensor of shape
    tensor.shape.  The last dimension of indices can be at most the rank of
    tensor.shape:
  
  
            indices.shape[-1] &lt;= tensor.shape.rank
  
  
        The last dimension of indices corresponds to indices into elements
    (if indices.shape[-1] = tensor.shape.rank) or slices
    (if indices.shape[-1] &lt; tensor.shape.rank) along dimension
    indices.shape[-1] of tensor.shape.  updates is a tensor with shape
  
  
            indices.shape[:-1] + tensor.shape[indices.shape[-1]:]
  
  
        The simplest form of tensor_scatter_add is to add individual elements to a
    tensor by index. For example, say we want to add 4 elements in a rank-1
    tensor with 8 elements.
  
  
        In Python, this scatter add operation would look like this:
  
  python indices = tf.constant([[4], [3], [1], [7]]) updates = tf.constant([9, 10, 11, 12]) tensor = tf.ones([8], dtype=tf.int32) updated = tf.tensor_scatter_nd_add(tensor, indices, updates) print(updated) 
  
        The resulting tensor would look like this:
  
  
            [1, 12, 1, 11, 10, 1, 1, 13]
  
  
        We can also, insert entire slices of a higher rank tensor all at once. For
    example, if we wanted to insert two slices in the first dimension of a
    rank-3 tensor with two matrices of new values.
  
  
        In Python, this scatter add operation would look like this:
  
  python indices = tf.constant([[0], [2]]) updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]], [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]]]) tensor = tf.ones([4, 4, 4],dtype=tf.int32) updated = tf.tensor_scatter_nd_add(tensor, indices, updates) print(updated) 
  
        The resulting tensor would look like this:
  
  
            [[[6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8], [9, 9, 9, 9]],
         [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],
         [[6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8], [9, 9, 9, 9]],
         [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]
  
  
        Note that on CPU, if an out of bound index is found, an error is returned.
    On GPU, if an out of bound index is found, the index is ignored.
  
  
        Arguments:
    * scope: A Scope object
    * tensor: Tensor to copy/update.
    * indices: Index tensor.
    * updates: Updates to scatter into output.
  
  
        Returns:
    * `Output`: A new tensor copied from tensor and updates added according to the indices. */
class TensorScatterAdd {
 public:
  TensorScatterAdd(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input indices, tensorflow::Input updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** TODO: add doc.
  
  
        Arguments:
    * scope: A Scope object
    * tensor: Tensor to update.
    * indices: Index tensor.
    * updates: Updates to scatter into output.
  
  
        Returns:
    * `Output`: A new tensor copied from tensor whose values are element-wise maximum between tensor and updates according to the indices. */
class TensorScatterMax {
 public:
  TensorScatterMax(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input indices, tensorflow::Input updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** TODO: add doc.
  
  
        Arguments:
    * scope: A Scope object
    * tensor: Tensor to update.
    * indices: Index tensor.
    * updates: Updates to scatter into output.
  
  
        Returns:
    * `Output`: A new tensor copied from tensor whose values are element-wise minimum between tensor and updates according to the indices. */
class TensorScatterMin {
 public:
  TensorScatterMin(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input indices, tensorflow::Input updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Subtracts sparse `updates` from an existing tensor according to `indices`.
  
  
        This operation creates a new tensor by subtracting sparse `updates` from the
    passed in `tensor`.
    This operation is very similar to `tf.scatter_nd_sub`, except that the updates
    are subtracted from an existing tensor (as opposed to a variable). If the memory
    for the existing tensor cannot be re-used, a copy is made and updated.
  
  
        `indices` is an integer tensor containing indices into a new tensor of shape
    `shape`.  The last dimension of `indices` can be at most the rank of `shape`:
  
  
            indices.shape[-1] &lt;= shape.rank
  
  
        The last dimension of `indices` corresponds to indices into elements
    (if `indices.shape[-1] = shape.rank`) or slices
    (if `indices.shape[-1] &lt; shape.rank`) along dimension `indices.shape[-1]` of
    `shape`.  `updates` is a tensor with shape
  
  
            indices.shape[:-1] + shape[indices.shape[-1]:]
  
  
        The simplest form of tensor_scatter_sub is to subtract individual elements
    from a tensor by index. For example, say we want to insert 4 scattered elements
    in a rank-1 tensor with 8 elements.
  
  
        In Python, this scatter subtract operation would look like this:
  
  python indices = tf.constant([[4], [3], [1], [7]]) updates = tf.constant([9, 10, 11, 12]) tensor = tf.ones([8], dtype=tf.int32) updated = tf.tensor_scatter_nd_sub(tensor, indices, updates) print(updated) 
  
        The resulting tensor would look like this:
  
  
            [1, -10, 1, -9, -8, 1, 1, -11]
  
  
        We can also, insert entire slices of a higher rank tensor all at once. For
    example, if we wanted to insert two slices in the first dimension of a
    rank-3 tensor with two matrices of new values.
  
  
        In Python, this scatter add operation would look like this:
  
  python indices = tf.constant([[0], [2]]) updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]], [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]]]) tensor = tf.ones([4, 4, 4],dtype=tf.int32) updated = tf.tensor_scatter_nd_sub(tensor, indices, updates) print(updated) 
  
        The resulting tensor would look like this:
  
  
            [[[-4, -4, -4, -4], [-5, -5, -5, -5], [-6, -6, -6, -6], [-7, -7, -7, -7]],
         [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],
         [[-4, -4, -4, -4], [-5, -5, -5, -5], [-6, -6, -6, -6], [-7, -7, -7, -7]],
         [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]
  
  
        Note that on CPU, if an out of bound index is found, an error is returned.
    On GPU, if an out of bound index is found, the index is ignored.
  
  
        Arguments:
    * scope: A Scope object
    * tensor: Tensor to copy/update.
    * indices: Index tensor.
    * updates: Updates to scatter into output.
  
  
        Returns:
    * `Output`: A new tensor copied from tensor and updates subtracted according to the indices. */
class TensorScatterSub {
 public:
  TensorScatterSub(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input indices, tensorflow::Input updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Scatter `updates` into an existing tensor according to `indices`.
  
  
        This operation creates a new tensor by applying sparse `updates` to the passed
    in `tensor`.
    This operation is very similar to `tf.scatter_nd`, except that the updates are
    scattered onto an existing tensor (as opposed to a zero-tensor). If the memory
    for the existing tensor cannot be re-used, a copy is made and updated.
  
  
        If `indices` contains duplicates, then we pick the last update for the index.
  
  
        If an out of bound index is found on CPU, an error is returned.
  
  
        **WARNING**: There are some GPU specific semantics for this operation.</pre>
<ul>
<li>If an out of bound index is found, the index is ignored.</li>
<li>The order in which updates are applied is nondeterministic, so the output will be nondeterministic if `indices` contains duplicates.</li>
</ul> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">`indices` is an integer tensor containing indices into a new tensor of shape
`shape`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">* `indices` must have at least 2 axes: `(num_updates, index_depth)`.
* The last axis of `indices` is how deep to index into `tensor` so  this index
  depth must be less than the rank of `tensor`: `indices.shape[-1] &lt;= tensor.ndim`</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">if `indices.shape[-1] = tensor.rank` this Op indexes and updates scalar elements.
if `indices.shape[-1] &lt; tensor.rank` it indexes and updates slices of the input
`tensor`.</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Each `update` has a rank of `tensor.rank - indices.shape[-1]`.
The overall shape of `updates` is:</pre> 
<pre class="prettyprint" translate="no" dir="ltr" data-language="cpp"> indices.shape[:-1] + tensor.shape[indices.shape[-1]:] 
  
        For usage examples see the python [tf.tensor_scatter_nd_update](
    https://www.tensorflow.org/api_docs/python/tf/tensor_scatter_nd_update) function
  
  
        Arguments:
    * scope: A Scope object
    * tensor: Tensor to copy/update.
    * indices: Index tensor.
    * updates: Updates to scatter into output.
  
  
        Returns:
    * `Output`: A new tensor with the given shape and updates applied according
    to the indices. */
class TensorScatterUpdate {
 public:
  TensorScatterUpdate(const tensorflow::Scope&amp; scope, tensorflow::Input
                    tensor, tensorflow::Input indices, tensorflow::Input
                    updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Assign `value` to the sliced l-value reference of `input`.
  
  
        The values of `value` are assigned to the positions in the tensor `input` that
    are selected by the slice parameters. The slice parameters `begin` `end`
    `strides` etc. work exactly as in `StridedSlice`.
  
  
        NOTE this op currently does not support broadcasting and so `value`'s shape
    must be exactly the shape produced by the slice of `input`.
  
  
        Arguments:
    * scope: A Scope object
  
  
        Returns:
    * `Output`: The output tensor. */
class TensorStridedSliceUpdate {
 public:
  /// Optional attribute setters for TensorStridedSliceUpdate
  struct Attrs {
    /// Defaults to 0
    TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
      Attrs ret = *this;
      ret.begin_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
      Attrs ret = *this;
      ret.end_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
      Attrs ret = *this;
      ret.ellipsis_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
      Attrs ret = *this;
      ret.new_axis_mask_ = x;
      return ret;
    }
  
  
        /// Defaults to 0
    TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
      Attrs ret = *this;
      ret.shrink_axis_mask_ = x;
      return ret;
    }
  
  
        int64 begin_mask_ = 0;
    int64 end_mask_ = 0;
    int64 ellipsis_mask_ = 0;
    int64 new_axis_mask_ = 0;
    int64 shrink_axis_mask_ = 0;
  };
  TensorStridedSliceUpdate(const tensorflow::Scope&amp; scope, tensorflow::Input
                         input, tensorflow::Input begin, tensorflow::Input
                         end, tensorflow::Input strides, tensorflow::Input
                         value);
  TensorStridedSliceUpdate(const tensorflow::Scope&amp; scope, tensorflow::Input
                         input, tensorflow::Input begin, tensorflow::Input
                         end, tensorflow::Input strides, tensorflow::Input
                         value, const TensorStridedSliceUpdate::Attrs&amp; attrs);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
      static Attrs BeginMask(int64 x) {
    return Attrs().BeginMask(x);
  }
  static Attrs EndMask(int64 x) {
    return Attrs().EndMask(x);
  }
  static Attrs EllipsisMask(int64 x) {
    return Attrs().EllipsisMask(x);
  }
  static Attrs NewAxisMask(int64 x) {
    return Attrs().NewAxisMask(x);
  }
  static Attrs ShrinkAxisMask(int64 x) {
    return Attrs().ShrinkAxisMask(x);
  }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Constructs a tensor by tiling a given tensor.
  
  
        This operation creates a new tensor by replicating `input` `multiples` times.
    The output tensor's i'th dimension has `input.dims(i) * multiples[i]` elements,
    and the values of `input` are replicated `multiples[i]` times along the 'i'th
    dimension. For example, tiling `[a b c d]` by `[2]` produces
    `[a b c d a b c d]`.
  
  
        &gt;&gt;&gt; a = tf.constant([[1,2,3],[4,5,6]], tf.int32)
    &gt;&gt;&gt; b = tf.constant([1,2], tf.int32)
    &gt;&gt;&gt; tf.tile(a, b)
    
    &gt;&gt;&gt; c = tf.constant([2,1], tf.int32)
    &gt;&gt;&gt; tf.tile(a, c)
    
    &gt;&gt;&gt; d = tf.constant([2,2], tf.int32)
    &gt;&gt;&gt; tf.tile(a, d)
    
  
  
        Arguments:
    * scope: A Scope object
    * input: 1-D or higher.
    * multiples: 1-D. Length must be the same as the number of dimensions in `input`
  
  
        Returns:
    * `Output`: The output tensor. */
class Tile {
 public:
  Tile(const tensorflow::Scope&amp; scope, tensorflow::Input input,
     tensorflow::Input multiples);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Shuffle dimensions of x according to a permutation.
  
  
        The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:
      `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`
  
  
        Arguments:
    * scope: A Scope object
  
  
        Returns:
    * `Output`: The y tensor. */
class Transpose {
 public:
  Transpose(const tensorflow::Scope&amp; scope, tensorflow::Input x,
          tensorflow::Input perm);
  operator ::tensorflow::Output() const { return y; }
  operator ::tensorflow::Input() const { return y; }
  ::tensorflow::Node* node() const { return y.node(); }
  
  
    Operation operation;
  tensorflow::Output y;
};
  
  
    /** Finds unique elements in a 1-D tensor.
  
  
        This operation returns a tensor `y` containing all of the unique elements of `x`
    sorted in the same order that they occur in `x`; `x` does not need to be sorted.
    This operation also returns a tensor `idx` the same size as `x` that contains
    the index of each value of `x` in the unique output `y`. In other words:
  
  
        `y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`
  
  
        Examples:
  
  
    
    tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]
  
  y, idx = unique(x) y ==&gt; [1, 2, 4, 7, 8] idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4] 
  
    
    tensor 'x' is [4, 5, 1, 2, 3, 3, 4, 5]
  
  y, idx = unique(x) y ==&gt; [4, 5, 1, 2, 3] idx ==&gt; [0, 1, 2, 3, 4, 4, 0, 1] 
  
        Arguments:
    * scope: A Scope object
    * x: 1-D.
  
  
        Returns:
    * `Output` y: 1-D.
    * `Output` idx: 1-D. */
class Unique {
 public:
  /// Optional attribute setters for Unique
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutIdx(DataType x) {
      Attrs ret = *this;
      ret.out_idx_ = x;
      return ret;
    }
  
  
        DataType out_idx_ = DT_INT32;
  };
  Unique(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input x);
  Unique(const tensorflow::Scope&amp; scope, tensorflow::Input x, const
       Unique::Attrs&amp; attrs);
  
  
      static Attrs OutIdx(DataType x) {
    return Attrs().OutIdx(x);
  }
  
  
    Operation operation;
  tensorflow::Output y;
  tensorflow::Output idx;
};
  
  
    /** Finds unique elements along an axis of a tensor.
  
  
        This operation either returns a tensor `y` containing unique elements
    along the `axis` of a tensor. The returned unique elements is sorted
    in the same order as they occur along `axis` in `x`.
    This operation also returns a tensor `idx` that is the same size as
    the number of the elements in `x` along the `axis` dimension. It
    contains the index in the unique output `y`.
    In other words, for an `1-D` tensor `x` with `axis = None:
  
  
        `y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`
  
  
        For example:
  
  
    
    tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]
  
  y, idx = unique(x) y ==&gt; [1, 2, 4, 7, 8] idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4] 
  
        For an `2-D` tensor `x` with `axis = 0`:
  
  
    
    tensor 'x' is [[1, 0, 0],
  
  
    [1, 0, 0],
  
  
    [2, 0, 0]]
  
  y, idx = unique(x, axis=0) y ==&gt; [[1, 0, 0], [2, 0, 0]] idx ==&gt; [0, 0, 1] 
  
        For an `2-D` tensor `x` with `axis = 1`:
  
  
    
    tensor 'x' is [[1, 0, 0],
  
  
    [1, 0, 0],
  
  
    [2, 0, 0]]
  
  y, idx = unique(x, axis=1) y ==&gt; [[1, 0], [1, 0], [2, 0]] idx ==&gt; [0, 1, 1] 
  
        Arguments:
    * scope: A Scope object
    * x: A `Tensor`.
    * axis: A `Tensor` of type `int32` (default: None). The axis of the Tensor to
    find the unique elements.
  
  
        Returns:
    * `Output` y: A `Tensor`. Unique elements along the `axis` of `Tensor` x.
    * `Output` idx: A 1-D Tensor. Has the same type as x that contains the index of each
    value of x in the output y. */
class UniqueV2 {
 public:
  /// Optional attribute setters for UniqueV2
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutIdx(DataType x) {
      Attrs ret = *this;
      ret.out_idx_ = x;
      return ret;
    }
  
  
        DataType out_idx_ = DT_INT32;
  };
  UniqueV2(const tensorflow::Scope&amp; scope, tensorflow::Input x,
         tensorflow::Input axis);
  UniqueV2(const tensorflow::Scope&amp; scope, tensorflow::Input x,
         tensorflow::Input axis, const UniqueV2::Attrs&amp; attrs);
  
  
      static Attrs OutIdx(DataType x) {
    return Attrs().OutIdx(x);
  }
  
  
    Operation operation;
  tensorflow::Output y;
  tensorflow::Output idx;
};
  
  
    /** Finds unique elements in a 1-D tensor.
  
  
        This operation returns a tensor `y` containing all of the unique elements of `x`
    sorted in the same order that they occur in `x`. This operation also returns a
    tensor `idx` the same size as `x` that contains the index of each value of `x`
    in the unique output `y`. Finally, it returns a third tensor `count` that
    contains the count of each element of `y` in `x`. In other words:
  
  
        `y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`
  
  
        For example:
  
  
    
    tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]
  
  y, idx, count = unique_with_counts(x) y ==&gt; [1, 2, 4, 7, 8] idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4] count ==&gt; [2, 1, 3, 1, 2] 
  
        Arguments:
    * scope: A Scope object
    * x: 1-D.
  
  
        Returns:
    * `Output` y: 1-D.
    * `Output` idx: 1-D.
    * `Output` count: 1-D. */
class UniqueWithCounts {
 public:
  /// Optional attribute setters for UniqueWithCounts
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutIdx(DataType x) {
      Attrs ret = *this;
      ret.out_idx_ = x;
      return ret;
    }
  
  
        DataType out_idx_ = DT_INT32;
  };
  UniqueWithCounts(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input x);
  UniqueWithCounts(const tensorflow::Scope&amp; scope, tensorflow::Input x, const
                 UniqueWithCounts::Attrs&amp; attrs);
  
  
      static Attrs OutIdx(DataType x) {
    return Attrs().OutIdx(x);
  }
  
  
    Operation operation;
  tensorflow::Output y;
  tensorflow::Output idx;
  tensorflow::Output count;
};
  
  
    /** Finds unique elements along an axis of a tensor.
  
  
        This operation either returns a tensor `y` containing unique elements
    along the `axis` of a tensor. The returned unique elements is sorted
    in the same order as they occur along `axis` in `x`.
    This operation also returns a tensor `idx` and a tensor `count`
    that are the same size as the number of the elements in `x` along the
    `axis` dimension. The `idx` contains the index in the unique output `y`
    and the `count` contains the count in the unique output `y`.
    In other words, for an `1-D` tensor `x` with `axis = None:
  
  
        `y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`
  
  
        For example:
  
  
    
    tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]
  
  y, idx, count = unique_with_counts(x) y ==&gt; [1, 2, 4, 7, 8] idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4] count ==&gt; [2, 1, 3, 1, 2] 
  
        For an `2-D` tensor `x` with `axis = 0`:
  
  
    
    tensor 'x' is [[1, 0, 0],
  
  
    [1, 0, 0],
  
  
    [2, 0, 0]]
  
  y, idx, count = unique_with_counts(x, axis=0) y ==&gt; [[1, 0, 0], [2, 0, 0]] idx ==&gt; [0, 0, 1] count ==&gt; [2, 1] 
  
        For an `2-D` tensor `x` with `axis = 1`:
  
  
    
    tensor 'x' is [[1, 0, 0],
  
  
    [1, 0, 0],
  
  
    [2, 0, 0]]
  
  y, idx, count = unique_with_counts(x, axis=1) y ==&gt; [[1, 0], [1, 0], [2, 0]] idx ==&gt; [0, 1, 1] count ==&gt; [1, 2] 
  
        Arguments:
    * scope: A Scope object
    * x: A `Tensor`.
    * axis: A `Tensor` of type `int32` (default: None). The axis of the Tensor to
    find the unique elements.
  
  
        Returns:
    * `Output` y: A `Tensor`. Unique elements along the `axis` of `Tensor` x.
    * `Output` idx: A 1-D Tensor. Has the same type as x that contains the index of each
    value of x in the output y.
    * `Output` count: A 1-D Tensor. The count of each value of x in the output y. */
class UniqueWithCountsV2 {
 public:
  /// Optional attribute setters for UniqueWithCountsV2
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutIdx(DataType x) {
      Attrs ret = *this;
      ret.out_idx_ = x;
      return ret;
    }
  
  
        DataType out_idx_ = DT_INT32;
  };
  UniqueWithCountsV2(const tensorflow::Scope&amp; scope, tensorflow::Input x,
                   tensorflow::Input axis);
  UniqueWithCountsV2(const tensorflow::Scope&amp; scope, tensorflow::Input x,
                   tensorflow::Input axis, const UniqueWithCountsV2::Attrs&amp;
                   attrs);
  
  
      static Attrs OutIdx(DataType x) {
    return Attrs().OutIdx(x);
  }
  
  
    Operation operation;
  tensorflow::Output y;
  tensorflow::Output idx;
  tensorflow::Output count;
};
  
  
    /** Unpacks a given dimension of a rank-`R` tensor into `num` rank-`(R-1)` tensors.
  
  
        Unpacks `num` tensors from `value` by chipping it along the `axis` dimension.
    For example, given a tensor of shape `(A, B, C, D)`;
  
  
        If `axis == 0` then the i'th tensor in `output` is the slice `value[i, :, :, :]`
      and each tensor in `output` will have shape `(B, C, D)`. (Note that the
      dimension unpacked along is gone, unlike `split`).
  
  
        If `axis == 1` then the i'th tensor in `output` is the slice `value[:, i, :, :]`
      and each tensor in `output` will have shape `(A, C, D)`.
    Etc.
  
  
        This is the opposite of `pack`.
  
  
        Arguments:
    * scope: A Scope object
    * value: 1-D or higher, with `axis` dimension size equal to `num`.
  
  
        Optional attributes (see `Attrs`):
    * axis: Dimension along which to unpack.  Negative values wrap around, so the
    valid range is `[-R, R)`.
  
  
        Returns:
    * `OutputList`: The list of tensors unpacked from `value`. */
class Unstack {
 public:
  /// Optional attribute setters for Unstack
  struct Attrs {
    /** Dimension along which to unpack.  Negative values wrap around, so the
        valid range is `[-R, R)`.
  
  
            Defaults to 0 */
    TF_MUST_USE_RESULT Attrs Axis(int64 x) {
      Attrs ret = *this;
      ret.axis_ = x;
      return ret;
    }
  
  
        int64 axis_ = 0;
  };
  Unstack(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input value, int64 num);
  Unstack(const tensorflow::Scope&amp; scope, tensorflow::Input value, int64 num,
        const Unstack::Attrs&amp; attrs);
  tensorflow::Output operator[](size_t index) const { return output[index]; }
  
  
      static Attrs Axis(int64 x) {
    return Attrs().Axis(x);
  }
  
  
    Operation operation;
  ::tensorflow::OutputList output;
};
  
  
    /** Converts an array of flat indices into a tuple of coordinate arrays.
  
  
        Example:
  
   y = tf.unravel_index(indices=[2, 5, 7], dims=[3, 3]) 'dims' represent a hypothetical (3, 3) tensor of indices:
  
    [[0, 1, 2],
  
  
    [3, 4, 5],
  
  
    [6, 7, 8]]
  
  
    For each entry from 'indices', this operation returns
  
  
    its coordinates (marked with '*'), such as
  
  
    2 ==&gt; (0, 2)
  
  
    5 ==&gt; (1, 2)
  
  
    7 ==&gt; (2, 1)
  
  y ==&gt; [[0, 1, 2], [2, 2, 1]] 
  
        (numpy)
    Equivalent to np.unravel_index
    
  
  
        Arguments:
    * scope: A Scope object
    * indices: An 0-D or 1-D `int` Tensor whose elements are indices into the
    flattened version of an array of dimensions dims.
    * dims: An 1-D `int` Tensor. The shape of the array to use for unraveling
    indices.
  
  
        Returns:
    * `Output`: An 2-D (or 1-D if indices is 0-D) tensor where each row has the
    same shape as the indices array. */
class UnravelIndex {
 public:
  UnravelIndex(const tensorflow::Scope&amp; scope, tensorflow::Input indices,
             tensorflow::Input dims);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }
  
  
    Operation operation;
  tensorflow::Output output;
};
  
  
    /** Returns locations of nonzero / true values in a tensor.
  
  
        This operation returns the coordinates of true elements in `condition`. The
    coordinates are returned in a 2-D tensor where the first dimension (rows)
    represents the number of true elements, and the second dimension (columns)
    represents the coordinates of the true elements. Keep in mind, the shape of
    the output tensor can vary depending on how many true values there are in
    `condition`. Indices are output in row-major order.
  
  
        For example:
  
  
    
    'input' tensor is [[True, False]
  
  
    [True, False]]
  
  
    'input' has two true values, so output has two coordinates.
  
  
    'input' has rank of 2, so coordinates have two indices.
  
  where(input) ==&gt; [[0, 0], [1, 0]]
  
    condition tensor is [[[True, False]
  
  
    [True, False]]
  
  
    [[False, True]
  
  
    [False, True]]
  
  
    [[False, False]
  
  
    [False, True]]]
  
  
    'input' has 5 true values, so output has 5 coordinates.
  
  
    'input' has rank of 3, so coordinates have three indices.
  
  where(input) ==&gt; [[0, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 1], [2, 1, 1]]
  
    condition tensor is [[[1.5, 0.0]
  
  
    [-0.5, 0.0]]
  
  
    [[0.0, 0.25]
  
  
    [0.0, 0.75]]
  
  
    [[0.0, 0.0]
  
  
    [0.0, 0.01]]]
  
  
    'input' has 5 nonzero values, so output has 5 coordinates.
  
  
    'input' has rank of 3, so coordinates have three indices.
  
  where(input) ==&gt; [[0, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 1], [2, 1, 1]]
  
    condition tensor is [[[1.5 + 0.0j, 0.0 + 0.0j]
  
  
    [0.0 + 0.5j, 0.0 + 0.0j]]
  
  
    [[0.0 + 0.0j, 0.25 + 1.5j]
  
  
    [0.0 + 0.0j, 0.75 + 0.0j]]
  
  
    [[0.0 + 0.0j, 0.0 + 0.0j]
  
  
    [0.0 + 0.0j, 0.01 + 0.0j]]]
  
  
    'input' has 5 nonzero magnitude values, so output has 5 coordinates.
  
  
    'input' has rank of 3, so coordinates have three indices.
  
  where(input) ==&gt; [[0, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 1], [2, 1, 1]] ```
  Arguments:</pre>
<ul> <li>scope: A <a href="../scope#classtensorflow_1_1_scope">Scope</a> object</li> </ul> <p>Returns:</p>
<ul> <li>
<code translate="no" dir="ltr"><a href="../output#classtensorflow_1_1_output">Output</a></code>: The index tensor. </li> </ul> <table class="constructors responsive"> <tr> <th colspan="2"> Constructors and Destructors </th> </tr> <tr> <td colspan="2"> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1a3e4c07125f4b04d6f3a0f99a616273de">Where</a>(const ::<a href="../scope#classtensorflow_1_1_scope">tensorflow::Scope</a> &amp; scope, ::<a href="../input#classtensorflow_1_1_input">tensorflow::Input</a> condition)</code> <br> </td> </tr> </table> <table class="properties responsive"> <tr> <th colspan="2"> Public attributes </th> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1aa3b91b7d267d5cee38568a7d1f97647d">index</a></code> </td> <td> <div> <code translate="no" dir="ltr">::<a href="../output#classtensorflow_1_1_output">tensorflow::Output</a></code> </div> </td> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1ad713509ff4e38a2f5241d9b2cee7b296">operation</a></code> </td> <td> <div> <code translate="no" dir="ltr"><a href="../operation#classtensorflow_1_1_operation">Operation</a></code> </div> </td> </tr> </table> <table class="methods responsive"> <tr> <th colspan="2"> Public functions </th> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1a76eb69d2e854554e8ae583dba19f1df4">node</a>() const </code> </td> <td> <div> <code translate="no" dir="ltr">::tensorflow::Node *</code> </div> </td> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1a80da544c59726a48be37767fb8fe3c91">operator::tensorflow::Input</a>() const </code> </td> <td>  </td> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1a5662e0fc5b2303a6072fb9aba2cec345">operator::tensorflow::Output</a>() const </code> </td> <td>  </td> </tr> </table> <h2 id="public-attributes_1" data-text="Public attributes">Public attributes</h2> <div id="classtensorflow_1_1ops_1_1_where_1aa3b91b7d267d5cee38568a7d1f97647d"> <h3 id="index" data-text="index">index</h3> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">::tensorflow::Output index</pre>  </div> <div id="classtensorflow_1_1ops_1_1_where_1ad713509ff4e38a2f5241d9b2cee7b296"> <h3 id="operation" data-text="operation">operation</h3> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">Operation operation</pre>  </div> <h2 id="public-functions_1" data-text="Public functions">Public functions</h2> <div id="classtensorflow_1_1ops_1_1_where_1a3e4c07125f4b04d6f3a0f99a616273de"> <h3 id="where" data-text="Where">Where</h3> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp"> Where(
  const ::tensorflow::Scope &amp; scope,
  ::tensorflow::Input condition
)</pre>  </div> <div id="classtensorflow_1_1ops_1_1_where_1a76eb69d2e854554e8ae583dba19f1df4"> <h3 id="node" data-text="node">node</h3> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">::tensorflow::Node * node() const </pre>  </div> <div id="classtensorflow_1_1ops_1_1_where_1a80da544c59726a48be37767fb8fe3c91"> <h3 id="operator::tensorflow::input" data-text="operator::tensorflow::Input">operator::tensorflow::Input</h3> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">operator::tensorflow::Input() const </pre>  </div> <div id="classtensorflow_1_1ops_1_1_where_1a5662e0fc5b2303a6072fb9aba2cec345"> <h3 id="operator::tensorflow::output" data-text="operator::tensorflow::Output">operator::tensorflow::Output</h3> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">operator::tensorflow::Output() const </pre>  </div>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    © 2020 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.4/api_docs/cc/class/tensorflow/ops/where" class="_attribution-link">https://www.tensorflow.org/versions/r2.4/api_docs/cc/class/tensorflow/ops/where</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
