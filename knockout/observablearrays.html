
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Observable Arrays - Knockout.js - W3cubDocs</title>
  
  <meta name="description" content="If you want to detect and respond to changes on one object, you’d use observables. If you want to detect and respond to changes of a collection of &hellip;">
  <meta name="keywords" content="observable, arrays, knockout, js">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/knockout/observablearrays.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/knockout.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/knockout/" class="_nav-link" title="" style="margin-left:0;">Knockout.js</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _knockout">
				
				
<h1>Observable Arrays</h1> <p>If you want to detect and respond to changes on one object, you’d use <a href="observables">observables</a>. If you want to detect and respond to changes of a <em>collection of things</em>, use an observableArray. This is useful in many scenarios where you’re displaying or editing multiple values and need repeated sections of UI to appear and disappear as items are added and removed.</p> <h3 id="example">Example</h3> <pre class="highlight" data-language="javascript">var myObservableArray = ko.observableArray();    // Initially an empty array
myObservableArray.push('Some value');            // Adds the value and notifies observers
</pre>  <p>To see how you can bind the observableArray to a UI and let the user modify it, see <a href="http://knockoutjs.com/examples/simpleList.html">the simple list example</a>.</p> <h3 id="key-point-an-observablearray-tracks-which-objects-are-in-the-array-not-the-state-of-those-objects">Key point: An observableArray tracks which objects are <em>in</em> the array, <em>not</em> the state of those objects</h3> <p>Simply putting an object into an observableArray doesn’t make all of that object’s properties themselves observable. Of course, you can make those properties observable if you wish, but that’s an independent choice. An observableArray just tracks which objects it holds, and notifies listeners when objects are added or removed.</p> <h2 id="prepopulating-an-observablearray">Prepopulating an observableArray</h2> <p>If you want your observable array <strong>not</strong> to start empty, but to contain some initial items, pass those items as an array to the constructor. For example,</p> <pre class="highlight" data-language="javascript">// This observable array initially contains three objects
var anotherObservableArray = ko.observableArray([
    { name: "Bungle", type: "Bear" },
    { name: "George", type: "Hippo" },
    { name: "Zippy", type: "Unknown" }
]);
</pre>  <h2 id="reading-information-from-an-observablearray">Reading information from an observableArray</h2> <p>Behind the scenes, an observableArray is actually an <a href="observables">observable</a> whose value is an array (plus, observableArray adds some additional features described below). So, you can get the underlying JavaScript array by invoking the observableArray as a function with no parameters, just like any other observable. Then you can read information from that underlying array. For example,</p> <pre class="highlight" data-language="javascript">alert('The length of the array is ' + myObservableArray().length);
alert('The first element is ' + myObservableArray()[0]);
</pre>  <p>Technically you can use any of the native JavaScript array functions to operate on that underlying array, but normally there’s a better alternative. KO’s observableArray has equivalent functions of its own, and they’re more useful because:</p> <ol> <li>They work on all targeted browsers. (For example, the native JavaScript indexOf function doesn’t work on IE 8 or earlier, but KO’s indexOf works everywhere.)</li> <li>For functions that modify the contents of the array, such as push and splice, KO’s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated.</li> <li>The syntax is more convenient. To call KO’s push method, just write myObservableArray.push(...). This is slightly nicer than calling the underlying array’s push method by writing myObservableArray().push(...).</li> </ol> <p>The rest of this page describes observableArray’s functions for reading and writing array information.</p> <h3 id="indexof">indexOf</h3> <p>The indexOf function returns the index of the first array item that equals your parameter. For example, myObservableArray.indexOf('Blah') will return the zero-based index of the first array entry that equals Blah, or the value -1 if no matching value was found.</p> <h3 id="slice">slice</h3> <p>The slice function is the observableArray equivalent of the native JavaScript slice function (i.e., it returns the entries of your array from a given start index up to a given end index). Calling myObservableArray.slice(...) is equivalent to calling the same method on the underlying array (i.e., myObservableArray().slice(...)).</p> <h2 id="manipulating-an-observablearray">Manipulating an observableArray</h2> <p>observableArray exposes a familiar set of functions for modifying the contents of the array and notifying listeners.</p> <h3 id="pop-push-shift-unshift-reverse-sort-splice">pop, push, shift, unshift, reverse, sort, splice</h3> <p>All of these functions are equivalent to running the native JavaScript array functions on the underlying array, and then notifying listeners about the change:</p> <ul> <li>push( value ) — Adds a new item to the end of array.</li> <li>pop() — Removes the last value from the array and returns it.</li> <li>unshift( value ) — Inserts a new item at the beginning of the array.</li> <li>shift() — Removes the first value from the array and returns it.</li> <li>reverse() — Reverses the order of the array and returns the observableArray (not the underlying array).</li> <li>sort() — Sorts the array contents and returns the observableArray. <ul> <li>The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. Your function should accept any two objects from the array and return a negative value if the first argument is smaller, a positive value is the second is smaller, or zero to treat them as equal. For example, to sort an array of ‘person’ objects by last name, you could write myObservableArray.sort(function (left, right) { return left.lastName == right.lastName ? 0 : (left.lastName &lt; right.lastName ? -1 : 1) })</li> </ul> </li> <li>splice() — Removes and returns a given number of elements starting from a given index. For example, myObservableArray.splice(1, 3) removes three elements starting from index position 1 (i.e., the 2nd, 3rd, and 4th elements) and returns them as an array.</li> </ul> <p>For more details about these observableArray functions, see the equivalent documentation of the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2">standard JavaScript array functions</a>.</p> <h3 id="remove-and-removeall">remove and removeAll</h3> <p>observableArray adds some more useful methods that aren’t found on JavaScript arrays by default:</p> <ul> <li>remove( someItem ) — Removes all values that equal someItem and returns them as an array.</li> <li>remove( function (item) { return item.age &lt; 18; } ) — Removes all values whose age property is less than 18, and returns them as an array.</li> <li>removeAll( ['Chad', 132, undefined] ) — Removes all values that equal 'Chad', 123, or undefined and returns them as an array.</li> <li>removeAll() — Removes all values and returns them as an array.</li> </ul> <h3 id="destroy-and-destroyall">destroy and destroyAll (Note: Usually relevant to Ruby on Rails developers only)</h3> <p>The destroy and destroyAll functions are mainly intended as a convenience for developers using Ruby on Rails:</p> <ul> <li>destroy( someItem ) — Finds any objects in the array that equal someItem and gives them a special property called _destroy with value true.</li> <li>destroy( function (someItem) { return someItem.age &lt; 18; } ) — Finds any objects in the array whose age property is less than 18, and gives those objects a special property called _destroy with value true.</li> <li>destroyAll( ['Chad', 132, undefined] ) — Finds any objects in the array that equal 'Chad', 123, or undefined and gives them a special property called _destroy with value true.</li> <li>destroyAll() — Gives a special property called _destroy with value true to all objects in the array.</li> </ul> <p>So, what’s this _destroy thing all about? It’s only really interesting to Rails developers. The convention in Rails is that, when you pass into an action a JSON object graph, the framework can automatically convert it to an ActiveRecord object graph and then save it to your database. It knows which of the objects are already in your database, and issues the correct INSERT or UPDATE statements. To tell the framework to DELETE a record, you just mark it with _destroy set to true.</p> <p>Note that when KO renders a foreach binding, it automatically hides any objects marked with _destroy equal to true. So, you can have some kind of “delete” button that invokes the destroy(someItem) method on the array, and this will immediately cause the specified item to vanish from the visible UI. Later, when you submit the JSON object graph to Rails, that item will also be deleted from the database (while the other array items will be inserted or updated as usual).</p> <h2 id="delaying-andor-suppressing-change-notifications">Delaying and/or suppressing change notifications</h2> <p>Normally, an observableArray notifies its subscribers immediately, as soon as it’s changed. But if an observableArray is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying change notifications. This is accomplished using the <a href="ratelimit-observable">rateLimit extender</a> like this:</p> <pre class="highlight" data-language="javascript">// Ensure it notifies about changes no more than once per 50-millisecond period
myViewModel.myObservableArray.extend({ rateLimit: 50 });
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>
    <a href="http://knockoutjs.com/documentation/observableArrays.html" class="_attribution-link">http://knockoutjs.com/documentation/observableArrays.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
