
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Relationships - Ember.js - W3cubDocs</title>
  
  <meta name="description" content=" Ember Data includes several built-in relationship types to help you define how your models relate to each other. ">
  <meta name="keywords" content="relationships, ember, js">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ember/models/relationships.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/ember.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ember/" class="_nav-link" title="" style="margin-left:0;">Ember.js</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _ember">
				
				
<h1> Relationships  </h1>  <p>Ember Data includes several built-in relationship types to help you define how your models relate to each other.</p> <h2 class="anchorable-toc" id="toc_one-to-one">One-to-One</h2> <p>To declare a one-to-one relationship between two models, use <code>DS.belongsTo</code>:</p> <div class="pre-title"><code>app/models/user.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  profile: DS.belongsTo('profile')
});
</pre>
<div class="pre-title"><code>app/models/profile.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  user: DS.belongsTo('user')
});
</pre>
<h2 class="anchorable-toc" id="toc_one-to-many">One-to-Many</h2> <p>To declare a one-to-many relationship between two models, use <code>DS.belongsTo</code> in combination with <code>DS.hasMany</code>, like this:</p> <div class="pre-title"><code>app/models/blog-post.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  comments: DS.hasMany('comment')
});
</pre>
<div class="pre-title"><code>app/models/comment.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  blogPost: DS.belongsTo('blog-post')
});
</pre>
<h2 class="anchorable-toc" id="toc_many-to-many">Many-to-Many</h2> <p>To declare a many-to-many relationship between two models, use <code>DS.hasMany</code>:</p> <div class="pre-title"><code>app/models/blog-post.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  tags: DS.hasMany('tag')
});
</pre>
<div class="pre-title"><code>app/models/tag.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  blogPosts: DS.hasMany('blog-post')
});
</pre>
<h2 class="anchorable-toc" id="toc_explicit-inverses">Explicit Inverses</h2> <p>Ember Data will do its best to discover which relationships map to one another. In the one-to-many code above, for example, Ember Data can figure out that changing the <code>comments</code> relationship should update the <code>blogPost</code> relationship on the inverse because <code>blogPost</code> is the only relationship to that model.</p> <p>However, sometimes you may have multiple <code>belongsTo</code>/<code>hasMany</code>s for the same type. You can specify which property on the related model is the inverse using <code>DS.belongsTo</code> or <code>DS.hasMany</code>'s <code>inverse</code> option. Relationships without an inverse can be indicated as such by including <code>{ inverse: null }</code>.</p> <div class="pre-title"><code>app/models/comment.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  onePost: DS.belongsTo('blog-post', { inverse: null }),
  twoPost: DS.belongsTo('blog-post'),
  redPost: DS.belongsTo('blog-post'),
  bluePost: DS.belongsTo('blog-post')
});
</pre>
<div class="pre-title"><code>app/models/blog-post.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  comments: DS.hasMany('comment', {
    inverse: 'redPost'
  })
});
</pre>
<h2 class="anchorable-toc" id="toc_reflexive-relations">Reflexive Relations</h2> <p>When you want to define a reflexive relation (a model that has a relationship to itself), you must explicitly define the inverse relationship. If there is no inverse relationship then you can set the inverse to <code>null</code>.</p> <p>Here's an example of a one-to-many reflexive relationship:</p> <div class="pre-title"><code>app/models/folder.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  children: DS.hasMany('folder', { inverse: 'parent' }),
  parent: DS.belongsTo('folder', { inverse: 'children' })
});
</pre> <p>Here's an example of a one-to-one reflexive relationship:</p> <div class="pre-title"><code>app/models/user.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  name: DS.attr('string'),
  bestFriend: DS.belongsTo('user', { inverse: 'bestFriend' }),
});
</pre> <p>You can also define a reflexive relationship that doesn't have an inverse:</p> <div class="pre-title"><code>app/models/folder.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  parent: DS.belongsTo('folder', { inverse: null })
});
</pre>
<h2 class="anchorable-toc" id="toc_polymorphism">Polymorphism</h2> <p>Polymorphism is a powerful concept which allows a developer to abstract common functionality into a base class. Consider the following example: a user with multiple payment methods. They could have a linked PayPal account, and a couple credit cards on file.</p> <p>Note that, for polymorphism to work, Ember Data expects a "type" declaration polymorphic type via the reserved <code>type</code> property on the model. Confused? See the API response below.</p> <p>First, let's look at the model definitions:</p> <div class="pre-title"><code>app/models/user.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  paymentMethods: DS.hasMany('payment-method', { polymorphic: true })
});
</pre>
<div class="pre-title"><code>app/models/payment-method.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  user: DS.belongsTo('user', { inverse: 'paymentMethods' }),
});
</pre>
<div class="pre-title"><code>app/models/payment-method-cc.js</code></div>
<pre class="highlight javascript " data-language="javascript">import PaymentMethod from './payment-method';
import Ember from 'ember';

export default PaymentMethod.extend({
  obfuscatedIdentifier: Ember.computed('last4', function () {
    return `**** **** **** ${this.get('last4')}`;
  })
});
</pre>
<div class="pre-title"><code>app/models/payment-method-paypal.js</code></div>
<pre class="highlight javascript " data-language="javascript">import PaymentMethod from './payment-method'
import DS from 'ember-data';
import Ember from 'ember';

export default PaymentMethod.extend({
  linkedEmail: DS.attr(),

  obfuscatedIdentifier: Ember.computed('linkedEmail', function () {
    let last5 = this.get('linkedEmail').split('').reverse().slice(0, 5).reverse().join('');

    return `••••${last5}`;
  })
});
</pre> <p>And our API might setup these relationships like so:</p> <pre class="highlight json " data-language="js">{
    "data": {
        "id": "8675309",
        "type": "user",
        "attributes": {
            "name": "Anfanie Farmeo"
        },
        "relationships": {
            "payment-methods": {
                "data": [{
                    "id": "1",
                    "type": "PaymentMethodPaypal"
                }, {
                    "id": "2",
                    "type": "PaymentMethodCc"
                }, {
                    "id": "3",
                    "type": "PaymentMethodApplePay"
                }]
            }
        }
    },
    "included": [{
        "id": "1",
        "type": "PaymentMethodPaypal",
        "attributes": {
            "linked-email": "ryan@gosling.io"
        }
    }, {
        "id": "2",
        "type": "PaymentMethodCc",
        "attributes": {
            "last4": "1335"
        }
    }, {
        "id": "3",
        "type": "PaymentMethodApplePay",
        "attributes": {
            "last4": "5513"
        }
    }]
}
</pre>
<h2 class="anchorable-toc" id="toc_readonly-nested-data">Readonly Nested Data</h2> <p>Some models may have properties that are deeply nested objects of readonly data. The naïve solution would be to define models for each nested object and use <code>hasMany</code> and <code>belongsTo</code> to recreate the nested relationship. However, since readonly data will never need to be updated and saved this often results in the creation of a great deal of code for very little benefit. An alternate approach is to define these relationships using an attribute with no transform (<code>DS.attr()</code>). This makes it easy to access readonly values in computed properties and templates without the overhead of defining extraneous models.</p> <h2 class="anchorable-toc" id="toc_creating-records">Creating Records</h2> <p>Let's assume that we have a <code>blog-post</code> and a <code>comment</code> model, which are related to each other as follows:</p> <div class="pre-title"><code>app/models/blog-post.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  comments: DS.hasMany('comment')
});
</pre>
<div class="pre-title"><code>app/models/comment.js</code></div>
<pre class="highlight javascript " data-language="javascript">import DS from 'ember-data';

export default DS.Model.extend({
  blogPost: DS.belongsTo('blog-post')
});
</pre> <p>When a user comments on a blogPost, we need to create a relationship between the two records. We can simply set the <code>belongsTo</code> relationship in our new comment:</p> <pre class="highlight javascript " data-language="javascript">let blogPost = this.get('store').peekRecord('blog-post', 1);
let comment = this.get('store').createRecord('comment', {
  blogPost: blogPost
});
comment.save();
</pre> <p>This will create a new <code>comment</code> record and save it to the server. Ember Data will also update the blogPost to include our newly created comment in its <code>comments</code> relationship.</p> <p>We could have also linked the two records together by updating the blogPost's <code>hasMany</code> relationship:</p> <pre class="highlight javascript " data-language="javascript">let blogPost = this.get('store').peekRecord('blog-post', 1);
let comment = this.get('store').createRecord('comment', {
});
blogPost.get('comments').pushObject(comment);
comment.save().then(function () {
  blogPost.save();
});
</pre> <p>In this case the new comment's <code>belongsTo</code> relationship will be set to the parent blogPost.</p> <p>Although <code>createRecord</code> is fairly straightforward, the only thing to watch out for is that you cannot assign a promise as a relationship, currently.</p> <p>For example, if you want to set the <code>author</code> property of a blogPost, this would <strong>not</strong> work if the <code>user</code> with id isn't already loaded into the store:</p> <pre class="highlight js " data-language="js">this.get('store').createRecord('blog-post', {
  title: 'Rails is Omakase',
  body: 'Lorem ipsum',
  author: this.get('store').findRecord('user', 1)
});
</pre> <p>However, you can easily set the relationship after the promise has fulfilled:</p> <pre class="highlight js " data-language="js">let blogPost = this.get('store').createRecord('blog-post', {
  title: 'Rails is Omakase',
  body: 'Lorem ipsum'
});

this.get('store').findRecord('user', 1).then(function(user) {
  blogPost.set('author', user);
});
</pre>
<h2 class="anchorable-toc" id="toc_retrieving-related-records">Retrieving Related Records</h2> <p>When you request data from the server for a model that has relationships with one or more others, you may want to retrieve records corresponding to those related models at the same time. For example, when retrieving a blog post, you may need to access the comments associated with the post as well. The <a href="http://jsonapi.org/format/#fetching-includes">JSON API specification allows</a> servers to accept a query parameter with the key <code>include</code> as a request to include those related records in the response returned to the client. The value of the parameter should be a comma-separated list of names of the relationships required.</p> <p>If you are using an adapter that supports JSON API, such as Ember's default <a href="http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html"><code>JSONAPIAdapter</code></a>, you can easily add the <code>include</code> parameter to the server requests created by the <code>findRecord()</code>, <code>findAll()</code>, <code>query()</code> and <code>queryRecord()</code> methods.</p> <p><code>findRecord()</code> and <code>findAll()</code> each take an <code>options</code> argument in which you can specify the <code>include</code> parameter. For example, given a <code>post</code> model that has a <code>hasMany</code> relationship with a <code>comment</code> model, when retrieving a specific post we can have the server also return that post's comments as follows:</p> <div class="pre-title"><code>app/routes/post.js</code></div>
<pre class="highlight javascript " data-language="javascript">export default Ember.Route.extend({
  model(params) {
   return this.store.findRecord('post', params.post_id, {include: 'comments'});
  }
});
</pre> <p>The post's comments would then be available in your template as <code>model.comments</code>.</p> <p>Nested relationships can be specified in the <code>include</code> parameter as a dot-separated sequence of relationship names. So to request both the post's comments and the authors of those comments the request would look like this:</p> <div class="pre-title"><code>app/routes/post.js</code></div>
<pre class="highlight javascript " data-language="javascript">export default Ember.Route.extend({
  model(params) {
   return this.store.findRecord('post', params.post_id, {include: 'comments,comments.author'});
  }
});
</pre> <p>The <code>query()</code> and <code>queryRecord()</code> methods each take a <code>query</code> argument that is serialized directly into the URL query string and the <code>include</code> parameter may form part of that argument. For example:</p> <div class="pre-title"><code>app/routes/adele.js</code></div>
<pre class="highlight javascript " data-language="javascript">export default Ember.Route.extend({
  model() {
    // GET to /artists?filter[name]=Adele&amp;include=albums
    this.store.query('artist', {
      filter: {name: 'Adele'},
      include: 'albums'
    }).then(function(artists) {
      return artists.get('firstObject');
    });
  }
});
</pre>
<h2 class="anchorable-toc" id="toc_updating-existing-records">Updating Existing Records</h2> <p>Sometimes we want to set relationships on already existing records. We can simply set a <code>belongsTo</code> relationship:</p> <pre class="highlight javascript " data-language="javascript">let blogPost = this.get('store').peekRecord('blog-post', 1);
let comment = this.get('store').peekRecord('comment', 1);
comment.set('blogPost', blogPost);
comment.save();
</pre> <p>Alternatively, we could update the <code>hasMany</code> relationship by pushing a record into the relationship:</p> <pre class="highlight javascript " data-language="javascript">let blogPost = this.get('store').peekRecord('blog-post', 1);
let comment = this.get('store').peekRecord('comment', 1);
blogPost.get('comments').pushObject(comment);
blogPost.save();
</pre>
<h2 class="anchorable-toc" id="toc_removing-relationships">Removing Relationships</h2> <p>To remove a <code>belongsTo</code> relationship, we can set it to <code>null</code>, which will also remove it from the <code>hasMany</code> side:</p> <pre class="highlight javascript " data-language="javascript">let comment = this.get('store').peekRecord('comment', 1);
comment.set('blogPost', null);
comment.save();
</pre> <p>It is also possible to remove a record from a <code>hasMany</code> relationship:</p> <pre class="highlight javascript " data-language="javascript">let blogPost = this.get('store').peekRecord('blog-post', 1);
let comment = this.get('store').peekRecord('comment', 1);
blogPost.get('comments').removeObject(comment);
blogPost.save();
</pre> <p>As in the earlier examples, the comment's <code>belongsTo</code> relationship will also be cleared by Ember Data.</p> <h2 class="anchorable-toc" id="toc_relationships-as-promises">Relationships as Promises</h2> <p>While working with relationships it is important to remember that they return promises.</p> <p>For example, if we were to work on a blogPost's asynchronous comments, we would have to wait until the promise has fulfilled:</p> <pre class="highlight javascript " data-language="javascript">let blogPost = this.get('store').peekRecord('blog-post', 1);

blogPost.get('comments').then((comments) =&gt; {
  // now we can work with the comments
});
</pre> <p>The same applies to <code>belongsTo</code> relationships:</p> <pre class="highlight javascript " data-language="javascript">let comment = this.get('store').peekRecord('comment', 1);

comment.get('blogPost').then((blogPost) =&gt; {
  // the blogPost is available here
});
</pre> <p>Handlebars templates will automatically be updated to reflect a resolved promise. We can display a list of comments in a blogPost like so:</p> <pre class="highlight handlebars " data-language="html">&lt;ul&gt;
  {{#each blogPost.comments as |comment|}}
    &lt;li&gt;{{comment.id}}&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;
</pre> <p>Ember Data will query the server for the appropriate records and re-render the template once the data is received.</p> <div class="_attribution">
  <p class="_attribution-p">
    © 2017 Yehuda Katz, Tom Dale and Ember.js contributors<br>Licensed under the MIT License.<br>
    <a href="https://guides.emberjs.com/v2.15.0/models/relationships" class="_attribution-link">https://guides.emberjs.com/v2.15.0/models/relationships</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
