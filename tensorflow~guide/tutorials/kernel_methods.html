
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Improving Linear Models Using Explicit Kernel Methods - TensorFlow Guide - W3cubDocs</title>
  
  <meta name="description" content="In this tutorial, we demonstrate how combining (explicit) kernel methods with linear models can drastically increase the latters&#39; quality of &hellip;">
  <meta name="keywords" content="improving, linear, models, using, explicit, kernel, methods, tensorflow, guide, tensorflow~guide">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow~guide/tutorials/kernel_methods.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/tensorflow~guide.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~guide/" class="_nav-link" title="" style="margin-left:0;">TensorFlow Guide</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<h1 itemprop="name" class="devsite-page-title"> Improving Linear Models Using Explicit Kernel Methods </h1>     <blockquote class="note">
<strong>Note:</strong><span> This document uses a deprecated version of <a href="https://www.tensorflow.org/api_docs/python/tf/estimator"><code>tf.estimator</code></a>, which has a <a href="https://www.tensorflow.org/api_docs/python/tf/contrib/learn/Estimator">different interface</a>. It also uses other <code>contrib</code> methods whose <a href="../programmers_guide/version_compat#not_covered">API may not be stable</a>.</span>
</blockquote> <p>In this tutorial, we demonstrate how combining (explicit) kernel methods with linear models can drastically increase the latters' quality of predictions without significantly increasing training and inference times. Unlike dual kernel methods, explicit (primal) kernel methods scale well with the size of the training dataset both in terms of training/inference times and in terms of memory requirements.</p> <p><strong>Intended audience:</strong> Even though we provide a high-level overview of concepts related to explicit kernel methods, this tutorial primarily targets readers who already have at least basic knowledge of kernel methods and Support Vector Machines (SVMs). If you are new to kernel methods, refer to either of the following sources for an introduction:</p> <ul> <li>If you have a strong mathematical background: <a href="https://arxiv.org/pdf/math/0701907.pdf">Kernel Methods in Machine Learning</a>
</li> <li><a href="https://en.wikipedia.org/wiki/Kernel_method">Kernel method wikipedia page</a></li> </ul> <p>Currently, TensorFlow supports explicit kernel mappings for dense features only; TensorFlow will provide support for sparse features at a later release.</p> <p>This tutorial uses <a href="https://www.github.com/tensorflow/tensorflow/blob/r1.8/tensorflow/contrib/learn/python/learn">tf.contrib.learn</a> (TensorFlow's high-level Machine Learning API) Estimators for our ML models. If you are not familiar with this API, <a href="../get_started/estimator">tf.estimator Quickstart</a> is a good place to start. We will use the MNIST dataset. The tutorial consists of the following steps:</p> <ul> <li>Load and prepare MNIST data for classification.</li> <li>Construct a simple linear model, train it, and evaluate it on the eval data.</li> <li>Replace the linear model with a kernelized linear model, re-train, and re-evaluate.</li> </ul> <h2 id="load_and_prepare_mnist_data_for_classification">Load and prepare MNIST data for classification</h2> <p>Run the following utility command to load the MNIST dataset:</p> <pre class="prettyprint lang-python" data-language="python">data = tf.contrib.learn.datasets.mnist.load_mnist()
</pre> <p>The preceding method loads the entire MNIST dataset (containing 70K samples) and splits it into train, validation, and test data with 55K, 5K, and 10K samples respectively. Each split contains one numpy array for images (with shape [sample_size, 784]) and one for labels (with shape [sample_size, 1]). In this tutorial, we only use the train and validation splits to train and evaluate our models respectively.</p> <p>In order to feed data to a <code>tf.contrib.learn Estimator</code>, it is helpful to convert it to Tensors. For this, we will use an <code>input function</code> which adds Ops to the TensorFlow graph that, when executed, create mini-batches of Tensors to be used downstream. For more background on input functions, check <a href="../get_started/premade_estimators#create_input_functions">this section on input functions</a>. In this example, we will use the <a href="https://www.tensorflow.org/api_docs/python/tf/train/shuffle_batch"><code>tf.train.shuffle_batch</code></a> Op which, besides converting numpy arrays to Tensors, allows us to specify the batch_size and whether to randomize the input every time the input_fn Ops are executed (randomization typically expedites convergence during training). The full code for loading and preparing the data is shown in the snippet below. In this example, we use mini-batches of size 256 for training and the entire sample (5K entries) for evaluation. Feel free to experiment with different batch sizes.</p> <pre class="prettyprint lang-python" data-language="python">import numpy as np
import tensorflow as tf

def get_input_fn(dataset_split, batch_size, capacity=10000, min_after_dequeue=3000):

  def _input_fn():
    images_batch, labels_batch = tf.train.shuffle_batch(
        tensors=[dataset_split.images, dataset_split.labels.astype(np.int32)],
        batch_size=batch_size,
        capacity=capacity,
        min_after_dequeue=min_after_dequeue,
        enqueue_many=True,
        num_threads=4)
    features_map = {'images': images_batch}
    return features_map, labels_batch

  return _input_fn

data = tf.contrib.learn.datasets.mnist.load_mnist()

train_input_fn = get_input_fn(data.train, batch_size=256)
eval_input_fn = get_input_fn(data.validation, batch_size=5000)

</pre> <h2 id="training_a_simple_linear_model">Training a simple linear model</h2> <p>We can now train a linear model over the MNIST dataset. We will use the <a href="https://www.tensorflow.org/api_docs/python/tf/contrib/learn/LinearClassifier"><code>tf.contrib.learn.LinearClassifier</code></a> estimator with 10 classes representing the 10 digits. The input features form a 784-dimensional dense vector which can be specified as follows:</p> <pre class="prettyprint lang-python" data-language="python">image_column = tf.contrib.layers.real_valued_column('images', dimension=784)
</pre> <p>The full code for constructing, training and evaluating a LinearClassifier estimator is as follows:</p> <pre class="prettyprint lang-python" data-language="python">import time

# Specify the feature(s) to be used by the estimator.
image_column = tf.contrib.layers.real_valued_column('images', dimension=784)
estimator = tf.contrib.learn.LinearClassifier(feature_columns=[image_column], n_classes=10)

# Train.
start = time.time()
estimator.fit(input_fn=train_input_fn, steps=2000)
end = time.time()
print('Elapsed time: {} seconds'.format(end - start))

# Evaluate and report metrics.
eval_metrics = estimator.evaluate(input_fn=eval_input_fn, steps=1)
print(eval_metrics)
</pre> <p>The following table summarizes the results on the eval data.</p> <table> <thead> <tr> <th align="left">metric</th> <th>value</th> </tr> </thead> <tbody> <tr> <td align="left">loss</td> <td>0.25 to 0.30</td> </tr> <tr> <td align="left">accuracy</td> <td>92.5%</td> </tr> <tr> <td align="left">training time</td> <td>~25 seconds on my machine</td> </tr> </tbody> </table> <blockquote class="note">
<strong>Note:</strong><span> Metrics will vary depending on various factors.</span>
</blockquote> <p>In addition to experimenting with the (training) batch size and the number of training steps, there are a couple other parameters that can be tuned as well. For instance, you can change the optimization method used to minimize the loss by explicitly selecting another optimizer from the collection of <a href="https://www.github.com/tensorflow/tensorflow/blob/r1.8/tensorflow/python/training">available optimizers</a>. As an example, the following code constructs a LinearClassifier estimator that uses the Follow-The-Regularized-Leader (FTRL) optimization strategy with a specific learning rate and L2-regularization.</p> <pre class="prettyprint lang-python" data-language="python">optimizer = tf.train.FtrlOptimizer(learning_rate=5.0, l2_regularization_strength=1.0)
estimator = tf.contrib.learn.LinearClassifier(
    feature_columns=[image_column], n_classes=10, optimizer=optimizer)
</pre> <p>Regardless of the values of the parameters, the maximum accuracy a linear model can achieve on this dataset caps at around <strong>93%</strong>.</p> <h2 id="using_explicit_kernel_mappings_with_the_linear_model">Using explicit kernel mappings with the linear model.</h2> <p>The relatively high error (~7%) of the linear model over MNIST indicates that the input data is not linearly separable. We will use explicit kernel mappings to reduce the classification error.</p> <p><strong>Intuition:</strong> The high-level idea is to use a non-linear map to transform the input space to another feature space (of possibly higher dimension) where the (transformed) features are (almost) linearly separable and then apply a linear model on the mapped features. This is shown in the following figure:</p> <div style="text-align:center"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZYAAADYCAMAAAD/AzUMAAADAFBMVEX////8/PysrKyGhob+//9zc3P+/v63t7c4dh3/AADm5ubi4+OxsbGkpKR2dnaPj4/IyMivr68AAAH6+vp/f39aWlq2trbU1NTp6eltbW3c3Nv29vby8vKFhYX09PRra2q1tbW0tLR8e3upqan39/jv7+/t7e38/PtiY2FnaGdycnK9vb2JiYk7ciNvcG9+fn5QYElLZD+np6cAAgvY2NiDg4LR0dHNzs77//+Xl5dAbiu/wMCurq35+fnBwsL///6enp6BgYB3eHdFaTWgoKDl5eWVlJTExcQJAwLr6+tWX1ISExSOjo5lZWXe3t6ampmhoaIFChElJCP7AQE6OTn8+OgbGxv/+tppaWh1dXT///qLi4xfX1/0BQXo5+f1/f+SkpKwsLBycHCbm5wTBQK2JiZMIhJyYWAaDQW7u7urLCw1NTQvMDAqCwIEDiD67dpuV1b//PPh4eFyUlB6eXkrKirf39/KyspMTEs+PkBGRkZdY1q5ubgAARnCICB2S0vmyqgEEDE9KRh/RESPOzvT09M8FgPv+P348OPHklfrCgrKGxvRFxfZs4yhMTFpXFwsHRH978nb8fyaNTUMFyZjRSNZLR3jDg58v+GOaEcNIDyymYBRUlMiFQzL6fg9XoMcJTAvT3RiIgEXMk08SVhNXG4CBCxZS0GTrMClxuBMQTh7bGciOlv6/f+HPz/aExOx1+y75frS0tLB2OluRROXu9rp8/kKOHmJsOEuO0pShrSl1e+ORxq0zN2bzORBirXZ6PJtl7tjV1Ds2LsAFkjQ+f/l+f+FrtEvYZ6O0vf22qq5dEPj7vjw4s1PcpUdLT2jZC6MdWAeS2qMXzXlsXZ+QR1iOx9ONRx/Vy9Vj9DTxK6rwNHMpHRttuH55LwjVIZemcLgwJXProJZaoDL4O9Bd6XX3uNwUTlyos/Xy7wlP218mLFrJwINKFNgib24p5RWfaT39PHS7v26hld4h5Wcdk7r5d/dx6tofJGot8CriGLe0sKagW6Zi39cZWvFsZ8mukQOAAAgAElEQVR42uycW2wa2RnHOSYeZBsMhuBhBgwGc7ETy0jUmCKMAygYIwx2JnQUYkKxvV7LhkaOPWBArl01tpombrbaVIq6ok0vD5XqbbYXaduH9qWVun1J24dqVamtVltVynafqm23fagqFV9wbC6JYQbmpJ3/gy8Dnsv3O//zfd/4DDze/4Su//PiX279u69P8vY5HidYZPrXd7/xk/c/L5V+5dHrHBdovPL+l2/++qPfSt+cejrx3utcPOAQcuf3V/729vWfSj849+Tdm+9wAYFEn/vMGz/gFbD8iXf9i9JffZILCBS69OeJD395iOXS76Q//jQXETj0Rw4LjBn/S698+6NDLLf+Ln2PK8Ug0S9evfnO9w6wPHn3sx9w8YBEn/p44s0fOQtY7nz8yodf5+IBi548lf7mH9+SPno68cb3uTkMIi5f/drEhPQTgW/+jCuPoUr7f/3Pq9JHf+CqMMg6/UsHKZ8TdH7hsMCoWxwWzi2czppd7ni/wEUBPp3jOhZOnDi9lAKqGD7i2xidjvMpLJrPhROJcDaTlwcxj3tyWuuQ7IRiKhPCBappUktEM63yTDZJkGQqnMtHNR5r3CUSXbZP9uhaNf3yTKLwCpHIZuQeuyPNBazBUoV8XW55ikxmM1Eq3uJL600mcCAEKfii8AU5/NVkkhnxsZbx8/JcgVBSrpu+OGzg4sd8IQyA13IhlyCJPGVxDCucZ57qQrYNkVmeIJI5zLWjBwg3rTElWchhj6aI3IDdYag3qgC3DGVSZHbossTPkaGd2J0qHz+fIMORWZsR0HScAV0al6eIbOus0Qm42Naf29dncgEir+s2MrjTdF8wGcj29Ho5MnUMbZMKHcykiGALqmKcNt7tDhPhfmFMz6GpSUYtlSRz5jF9w7C3i7BkIB+36blgnzFiKtydTWWm1v2NHcum0EY/kcqPxvRcDfBiKOh8jszHO5oTKlXftRSBzXLF2fMLL2N3NJl0+4zNC5Meb8kQ4cGQkot+NSihmTDRLzQ0e+gCmy5JDmxwYCrWR2gkEY7jajbmE9NqXyaVE8W4wqwUiiBK5qdV7J2AbD1ChMUKjsSJNB+z5FJRh5HdxKvHqVRiZlXG8TiU0pIjIzYTBMkNNxNJdwdHZL9GFWRSGApJVyfzWpMp8+r/fY4Bkn4yKDHBc0JIRw+RtF4WNU9L0N1oMNk0hHwdssrU5JUHAuGh802RWSPvhK3O8E8S+SXo2gUEvebWBKK2dDOSTEwXjMCFxSBMhoUqHnRUJEMulV6SI3PxhleGSMjMX2qNwXT5HXLSCuHyBwTViNWFb4rxQKq30TlPQenad2DCYoin+ncgLHgQCeY6dLB+Jkxiq0hDvaLjtyMoRFhQORFXw9jYopj46Lxk8+PTRNbXyNRKUTGEBw8W1TQh9wIETq8Ub8qBpSWQlpPnGxU0BKcGC1TgwWIIki4DAqlXTtcgRnEgjzbmVI0ezz4VWLAAbbJRV0rbKxpX6Q1sBM2QFmcDDoZ7BhUHx4IDi16UwtqhvOGA7AzFT3gFAYcVSWEiszPehyN+ynNIBQ4ssaHULJx3nA68ctLVjt6j3G8NRBQM23s/rxSrH/axIOl8YgxOKmBkbvxUXgGi+NFPymlSzigXRKGjYgg0WIAtkYN0AX2pV05i4fHGEjmcQS4hin9MhX0swJfMhOBcYwJsF+wlS/qBRfzsZzSRYWx1DBLTmZ9RYR2LbJSI+iH1yrpmvrS7BZbJE78Nh/NMdfynvMI6FiAkNH5YvdJqN5QnAO+pQjmZZ2QlNOI1m9tPhoFdLEBLuNUvj1fKNZJgxOvp015hGQuQEJiKB6tXps7wqBgYIcy0i0jQYXa3n54y2MSCrCejRki9YtNMqSt2fKX/BrOQQkDbKz0lVFjFgifyCkjzynrrfEWvgG5xyRalNTVG71irZmspFTaxtGdyq9B6xV45r4CuntJNzkyY1oOxq+VeYROLM5LCIfWK5IKrSqTBrLWM4XCWRoIEaXMFKixi6SUtL5tXCq8J3eUbfWRX3QfroKwVqLCGBdlJ6JSQemXOVXX0I2Pz5RtNmnCdVT4SqugV9rDI8mE4P6oAGanulardS8pViK2s9orMS7ljFSdylrCAOOGDk4pv6HLNmQKIEzhP2eev2Ss6fmUqbGEZTk6aoKSyoxmv1StqJc+fmuSN9deKs72aV9jCgkRSSji9gr3gcRp0tLzCta7rzdlYdqi2uhLBdYPVqNSLBSi8dPTDQI+XCakZ90r8BcNlw1O+zUJYReT5K/zaDhajzFWp1Iule6CThi4kCayTviLB8SZ7hcdbqoBFFp0gA1cmXLV5harulXqxAOt8erV+zZK0/ryokc5Zpr3yQvtVwoLYCKlUemWjloMpPLrnUKkTCx4ZodOgR7OMtPc7QUaXtUuudTokL9I8VmlrpIAl0CI5uxzFlUdMYkG0Hjr34/XkNCNxtJxndE3QpLx+kVLpRL6WPxh6/ohC63mQQsWndd9EmBxmIoz6SDej62X4LfXvrjCNEbWM65ae57+hLrd4g3TiCrA8I6McvTDMgwULsEuzCDDJTIBFLEIznRsn6cRlRm4UiPj65mNReav0lJmgzWLtFM/GELawmKwiOi36xQAjD7oZ3UJe87FIqsQTEQQXtxc2l7eodcAOFqRQh9G5fGuCkfsuaDDGApaxKr28ybK1e7Wtre3G8uIZitRGYAFaD63uOipnJFNbrEo2sMxVfhP62r22A119YFaxgkXNF9G6/FyECSz6Ti2ACIto++ohlraHazgrWLxBtM4Ld6oNKieSFDPRTO5EmK3DzoYFudiqqvQuMLh8RKXt7u0lVrBozfWtIgL4vHtINyUJWBjAAkQ9zmZhAYbjaQlvxWb6fOmyElBmPcZy43FFLKqTn+bYACzOHktds4dJu7e9sLv5YCWgZQCL0azlNQUL0t5H7e25l/ZbAiRtDg4MDGiGKPtS2qg8+XbXiUmszMaI2sHf29O5jj/OtwFY6qzDgG9lc//Mr+5+x8VAUkCD3qZgAetztxfu3Vvecqd5PL/ZMysQaC32ns5gdE7cIuk4rilHVnaPsCxHylK+YmZteXN34THmAI3CUqjDKndxiNrvVaiqRlwxt3A0nu6tMJAVRHx1U7Dgc8t3DzywzfcrZiJ9lkmtQCDoFbaI4pQGK9hmLOTff7TS6dp666BAXliUlO5GPf744dFraKOwKKvUYcA209qPDTqqzfgjW3eLk+92C+0QKiktaAqWweLkdGPLMoi1CKYGCn45klZk5xds4xGPSmLA71p5sHlvYVuzVLoX4Fh7eLSP+z2qBmGpUoepXYv3d+/uLq+NV6kHurZvFJPisph2SEciOK8ZWGKLxbmpbaEfEwlOYTmwzahoUodhGOXasJjn9nTz6bKdOO33i/t4uDjcICy9Fesw0L112E69dXu6csy1z7Dcp728AlissqZgQYsDvTD3/rxApYClS1CqbqFonB8J9lMz85IKq1/U1GZxH1fXxhqDRV+5DsOx4qF3F22Vx/fa8ST2eJRuBA26bl5TsAyvPMPyWvcBllFBJe3bRkwd2MYX8p/6yHG1eeEYy4qvMVj+y9zZ9CTufXGcQmh1hAECUy1PpRSVYgVseAiKpjAjBgNCwgbiQwBjiKzIYJyFRBc4G53IgoUv4p9o4kuYV/YvAhWdFlpo6+/umOio93PPud9z7rn3WEsvnMFvc6gP59txTnNJl4bK/rozc6oylF1QBou9ds+6Xn9v+vEUBvGPV7PxZt0pU+TtRY7tWFduJwbovpo5ncrtPOuiuN8RAKK1s54bO75vzHwhRKUnncpgAXPtge99/GuABAzYhVUYs/GjRIA2WtM9AQRGhxvU8a3BJgsWj4NThwGVJxZL95RbjAHnyFP9un7bwWaeUptbByiDRXWS7N7198yLCreB5Gn1v3Aq+piDMRtLGVt09sTzq80dd9FLeQQyz7kkaGwMN/TjmxZPEA+cqA8Djnxo9hmNlg5UCmEBd8lm96ze7QT6Wz2mdo3Ov97daN40ijEOz+bCdIxI65mN/jzceTo7e7jRhGQKJ+EAd6Ft2l3vby6Fs+oYtw/YpRBQAJUwK4WF2V7WyG+EJTeY+HxydMunifaf58c/Dx2SZ8eBTUxsU/US3m9ZpNxakSkn5uHLh4HW7EPP2O/qHaPsd4mWL1oq5bCAu74LHQwPQRTxt0mn0HrfSTw3Uvy7DbPd6A1uf9aboIwH/V5mEmOxan/zrWBjqX1b77aLW9tyU1FZs5cKYklrtGr4zT5GsWiGeqBQL2ITpECc2W38XsQSa/1clRgLoBtzguXcojOxNSXuc+cPncphWXb4RwPId1hQNiB5buqF6DRX32wclCFgByTDYnaMPZcElekW7AzoAMWwOGlED49M7A+UevvQYYOau5sYJGy44vqco/rtKBxbuzTzNiIVheVk6nNJKUe0JM+DSlxYPDRB8U8xwVrLY/MHJGLAGjQT8GcJjdp4YJ/1kh4IW2R9NUdYD1tGh60qhWVbh57C/LPr7hbYzEVFHBZfz2xiGj/hS+TWFmxmYPpXLGwOSkYvtRA9P48IeJbHnmypFMICYNncuNmlO9dDH+aAxGIZRqOM2XiRQ5Pxp3O6F5JAazUkGxTnubbTvqm5X1Yn/hbEpUJYgB3E4PowofHYiADAyObZcaFw/KftU0+JZbDbaPzFUoLe2nUOGviKwYJpZXu60JxqXh+/hj0Tr6zoD53KYAH3iMw/HiyPvpNc5eLNbbd9lIhD02MZHA7Qr2ZTNv36uS0KC5CYpT4MNI/xT8BO888gSVCbkFexBzBQESzAi9ahgyZgceE5jaOsx6BZsbwaH2M24SpSCtN7W9UFoSawNIMOs+/paMzIu8zT7qGmKXTL4xMrUZ9crTo+YLFqwxyzrUf10OyDG8sgXcOYDXJ0lBHYLAV0JaZ9ZQpYdFwFN4JXhwc8S2CBGJ6RzV9bVsbrsDCgBBZw1+I2QVxY8vJi6ZtN+eiIFBaZOzVT67Df3o31ubm59Q2Ux0NZ/7Inys/asdbglEuHfcCSTiS5qEBxg1p+LIzG+5YU5hTAEDJtVcOSe2Pudaxv8CyBn9k3awmMjY2s6KUCWMCVjA+H5BuTsOjcXoGXU0GsOq33WNtfnxtwuTJyfsVKoj6s+7mNmT9Fh73DYisjFPR5WDDNkU+gEgMD096XXKUHxsKMIHc6C9hp3BcGSmxstaQ9gYHyY7HleXcQl0ms6oIwDBaHBSujeaECOZ19mfLP3U69YdnQc5sckG/UH+cLzw+18eXukequSnYsqzhB86VccLdIJaYnA27NKSYCC5witiICsYDYOx0GpNdiZKwlqIE9oA6yWPbPeb7DtndRazZrFuvqJ+mwNyzmcyLGmwijUFoMlEq40+7WnxoXOCwUi4smsFWh4aSTfKfDou6b7tnDjdYoZJZ+XW0OqGwS/KHPcmRnJ2Qfz9mThFRyYwF3iikXJA0WLHzTq4cvPD/540Ljlh9FyiM4yg+NKiDgV61+V5gvHJ/VtgTYiycW7O/5m0F8tuSvFT2QGwsQITL8VCAKEYEFTjWeh3eRwrAgLDBF5EQkX1z+EbtYvngYCKc6IuS1hbQl+H19bv37/uGMh5cUaZcZC7jo0+jGzLQ6KeJgxaVlq4+va3FBWHC/YVl4qhJ04yOf9tjqeyE30np3LCpJ1Iu6z22zyahlCwzKiwW8RAJjpRaMuURg8bKF5Y8NWgiWOOJwiugNtlQcvWtEsWXehW5OWPolbY1aZ+7IFkHk02F9LLuWZFy68MT1l8Vy1zwVgMXkDiyISOyDuvDouxU/RqrvUyrFBqPDQHmxrFz4dLCEWN5qMP7UqMlYdBeltJjeYB902FabraF8MimHZbsEq2TFspyaGNxjtAhrgsNsxdJDFZuc2Cf9w3ovYVhCxXfPru9mr9nbBSFZSSx/sSukwxgsegMan2QraiQmAgte7VcwH5958xMFskuDhsT1BoO174StOX7TF36PN7R84R0IhlKJr+HThUHpBUiRsvZ60fj5g/vpsEBQPtu+f7y7v+0YsElY4FTxXFxvMNCtfu/UPfraw/3z/UPnVMY3pu2D24ideH9NrFhaslrmxbdDamLCKy4OC2RyINks6sYnJl/gcnZHZG+wL8jHNLPHGK41OomtGZ5dASf0LwZ0zfv+/dxGtPeVYASR923gCy+BfHWcxjEXLB0WyKXW63Fs8lk+XaRGPJIQLIwO44jiVpdmqTY2v+zgreg4WwuxF7HOXk/GQH1YXkXBbPkR3JBk1raBxvnMRpeSIuP/LxaaUI8eaAjBYielrg8Dl+jsfjDodVgB/txou/B245D5+ataSG4sTDjpOQmt5UooUtLk4jpMQrE8FguMI+8f9heCRfrKrCV/sH+KnI3yJtJSbOJi/ikO9m7NHsiPZRj8GvHMVy8aMNBqlxJYKCT23h8JweJKStxV2XM6yF3ObST5CipGbrMzWADZddjHEgvnSaiV0iKIVpNTj5iNqOSLQCywqRT+kFoUgAUIqCVWwYvedfYABubd0Fgndtwwyq/DOGuQgd09ivQdoZYMPTgw0YVPJcdiSiY+JpUEYFmoRiTeWtb2344rc3zCIfS/6+G9PzfzO0aKaeWx9MjYTxahTM9sHDnchFWQstRYMEvpUnzLNlCXkDqbHn87rvye4XVNcPN6KJCZT/qE6lOwDITjwU6eRI5QN5k9dEmLBXP4Fqdo2WYncakThHsj1pLnnQtbpXZ7dl9/qrYYQQ/4Wp+JpRdm2U+scFl7lK2+mg0sERYsg0Y5HjWZiOVA+gp5K7rJVihtjQtd8qQlQ315/RbE+rlYBnDs5CnFmA0SyNBxWAIsrnJxj+PHTsaCSd9azYwHNwf1fJqxDnLVuewE+jn9Q9t/AYsKXLYB9qUQZkj6kSp5isexmbC4ckSL6xx9IhbAgk/RiuwXthYao6o95P7rKXLwq0BLXEnI7sNEPubutG7pNajXnzDkK1NjgelinFPyTMRyqX0Ru7WkqeLV/r43fGnm9wXnPuLK68+lBc5EhFhRHovdulX59XNkddnSEWP0t5X5F3Ov11Lanl7EAwhKlEiaiuvG5tI4scD5Yp578U7CAmIWsVGc/dUU5jY30OiY/zcd2ot8EVwHQyVApbGAB5mrYHDf+4MV5h48Rfr9fvcCs1hRZuTNKkAdtvi9BkfWi1wEEmUMgnMO8jCj7pV7MeP/7F1vTBvnGb/DcK7A4OSc4Jx92PyxORsbYxuDg40N2EDAwfz5kMQGRICgFH8IaTLkTMIfEiSS7EM1UpFpSUb+LGRJqiBVzTKNStG2tGurLW2aVVu07MO2dFO7VdWEuqn9sFV7z8bns32GO2rOfLjfl8Tc+XzP83uf5/097/vee8XgD5K8Zkk5My1WrDNDDt+IFtyYx9EhruL4kmOvOlulBlET4Z0Wu95SCxKtw1zSHZ/NCNpwEuA02Z6iXlsRuSTj1D5nqFtVbR9qKAnogkOtdXoMw/rF4jETplbXjYlLpWp1INAHikZMr8bAH8R9Qc+02gQ0WJNaLXGDaMFtit6wFiFfuFY4sgcmayWxZ33XhfVcR6IKMUpmmbM1o6wwbbkOS6Wlm3rMwNwaTTSaMZN93bxSbTO07/L7a4BIk5AD+lXWYmu5uDSvvfVIHwgfyahUKiX37GndVTmtx0Cs6PWVHnKNhB0QqZbAED5qqikht4IPG3XrSyFIUsf5laXU+nxQK2ZnpxG4eEjDMy1IOWWGIxBdCjrSs+ESUoTQaOXNQ9OY3iNtrRorzbSmqQKUkOKx6cpCpZJcokWoQAhqEIgIy+VyGwHJxP5W+7qeg9s46zADrYRvyM7kZXWbGOKZFhntMQNfbINJtqID7paHWqd1gWBZU15pxi6/oqwgwzIIeB8W2qA5K4Jyrkl9LhEtFml2ouVNHnRYCi0qozfx9EceDHNrXwiswRubjZVqfaW0vYrpQQpTg8nG7FmZGwttEApIBeccBnUEEn1LVXYcZm0g+KbFdYQeLbB7dBMNg9gzZ+jz6NQe0ZHmVFp0encGl28cKxAuyuOsgAiJb40XS0F2ZkhkBSGEb1qQUKJvUSvc6sjmGgYCE3hj1ZAnEKgbbU/MRJfWDWfoqGT71BsbW5Ssw5AoNqxbGqK81Fr0OzhZkPHiihoedFiaEqujlFi/fdxKcLhf6igVeiPyUNO4DvMY2yWlpaWguB/2ZNguD7CyceJPHtOHO0r7RO2GDdfoa8SeYZ8P6+FUtSh3VA31jM3BjDpMxj8tUDhodtTWko8ZjAwxvEmx2t0+1FQaZvauprG4Z7RKnuxgrd06VOLH2jr7m/zBsgyxojew0BQNdB0Gu6fNFq/F1ybfSJzBHY3OHQoVl8wz0jdjtljM+mY8RzosfReLjs7dPlDl76yGO9LkOdJb5gO+MBcYmLYd1fbpSGP87ZrUdVwdcnGTye9vsjLSgrjZxAqkKJHTWfF5Y6O+ujez7hKtJza77/CNptk5x4sOYxqqxBt39CoZ26BNH9tpwOtjUE3VZbEBcod5FGesO+Uqxk0RyX6FTbavqEuMpiPhmrhktDRke7rSVRXvYB2+tC1IrSJXjmiJmm1lMFZljOs0L8P4Q17cmNqZDCmJca9K2I0Z2FgKdBjtShKqTKydsWfZI3tKHFSt05OSMVxBXnRYpve3BJsY5KR9hqrN0osATYAqebzT7GmRudXsDC3S01oCQnuM25ztF0CFhykzHdOpa3OCvOgwRlqQ7gYjk3CJ0Ga9h9KM0VFtzKHTsKWFbaxAUAU9WSEiGi3NWfaIIjEy4EjZAYkvHcZIi7JzlLG8l9AGmHal9TuJUHLMaFnSwqK2j9eFDUn1lTWRxHyGLHskMTKQNo7Gx7xkRlrgMLNbdyQ8b+lPky/6hDEmlkmMfawk6zAIsVOx6VVn+xFGVY+FGrBJ2Zdcru/OHS0Z5bzJu84uNpQeeMncyo4WgnWsQLCkLikxKlvX1kU4fOXZftYIsQW8tTH1nfoeumKjJje0IHiI6uxhpbZaRSv04dDaDhC1ZgZFYMO8awtIpukJWYNX4y6EiRbYaWIbK5BKlPJmNVw643U4HJZh6xYsBnZjZnBxr3lXymi3yxNBckMLPkotDFZFpMEao3VP4rhyp85C3q9PxFBTwadMMWOCtHRDNPbVje9qlTPssU+4TSHWQ25JOix6LZWzEtNjIvtWNF/i5KgpEPD0a1MCcc7TC+WEFryTejtvWOSzRL1My1eyRpFJj3kijLuhwCf7avTqmmJarsetJI9eiz/69pokWggQK+xVTQXDHBbcrdi6ilt1sijt7mCrUZYTWojmYHw+RNVmXkuwgaQ+FVess27HFe6gpyWiYi3rOWYicDItnGIFcpXlwVDOUV0XgnJCCyxXIPE+liraLZ2bTd+9/rhG8OpHkmjhFispOixXsAVGckMLLSgS85SO8c3uKhsxUxsQmvfRaYFBrHBgBegw2TagpbhHkwNaXHM0OTiSGBh6afdmdyFoou90R6OFjBUuE2xpOiwncE2LEf5pgSPjNJ1RGEzQMrNZWmhT0GYaLRxjhUGH5QSNnjDEOy2aCEaf0VX1JJJYwWbr6BBjEpM5MQO3Dry8QZt7VuAqI8E7LXBIH6G3YFhMdfnmvs2m1CI11eWrq+O0wKC259ZTaMqat4MOqzRAvNOCNDqTTSekseGNWkvBpqsD2DDjjc2b6ciH2aO0cI8VoMNsuWcFUgQK+aeFYQSsyWfxei1mz7eYldVU6MgZd7PeqVkrJ8lY4Ti/B0sqt0GwQP1SJc+0EL0MaQqB7U0NbaMR2beRH3CRVdRmzCtE1gZfZE61k6uPNaKqbcCKprIU4ZkWW7AxgzLNwjy5DI/3lIAW7rFCbhi2HXSY3VME8UuLwtTOS0NAmv1qJ/dfErdVwzmHrEpE8EpLsGd8uEzKC4LDBu7rRmCRrqYg5xjXOXkNzlM7j/Q07+QJm1mkAtsl2wERnOesKdMgkAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAADeQW2Llszy3BRFWJ8QdscWeOP7TqZ+zpeWDp38RKCFx4vf1P9xqWhbY0jL4ZdcvBErIYNl6Wk78w/mY5amDv0UFWniKFnhVezh/EMeXCVyLa0DctMi0SmRVq1Utkx9WtefIWBrUavciWkCLllrs3uLCwUkwOIqs4nvBB1wWizpYCQ6sbeXQAivJ/0cPIOQXlMs58iQwEZbh0fuSUfcatQGP3hOBqxDyXkmDWlxaDbFK3WwLodJS1kX/nkRLwhGDqzjswmm241qaVyinsHFEtG85dPSLfU/n0amlPx2GWl49du1fz7rqn3wOomjwI/SPe8FZF4795NcXzqIA8Xg58fzTRbT+yde/hKADPz7jvDSJLnxyn/yp81den0TR65/c3xv70AUOPAQHBp9/ZxEdWLnzOD8ntBw6+o776SK6cO3qcdLSD/9Guvj5y/Nd6MDSnXMQdPrsPyMXJ9Dr/wYGQd9D37oy2wVu9ly0S/3vbBd6/ev7UNQg4Jp7d2i0IF+9EnUEuOChH7xTfgn8xq2o7Qeu3AaOAMbHvvf6BDjwEBw48VXUEZ//jAUtZ57tX/nuYtcXd0laDs4/wV5ZHPjw3fw1WlpIWg787w/ovbK7sa/lnz46sPLNo0X02muAloHZ/bfGZ7vu3c+HDlyaWFjSgRv63VWo5filif1L35/tuvlG/okX8wMr/tvgqudyRMuZ2f0roMXc+pT8p/590AD/Cm5p+NFs18J7y4CWg/PXv3l5fuDGa/mAlieLKyW3Jxd+Bc66cLHr+o8eRY2ADvxncmpp9+zBSYqW/N+cJR0xX3/jNUDLFHBEEDjiIQJOBbbrbi+i967mQ+cvTUwt6cA17iKDL2YHnuhIRzzemBb05oNl6IOL6N9JWtAboMmcPjr12TI9WpL6lmVjBGEAAAdxSURBVJaP0LcOkyedeQBoQS8/AFf6GP3zuy2vTl5+Axw/PTv1HkR8OXET0Hj+Y/T9w2+fJW0cfPtZ/Wd7c0MLevnuMvTiGHr5/+1bTUwbRxSeSitfrErV5tLSqqe2SFWlHpZGPrTZXqos4tAa2UFypfqQFd0KsOW0aeJIVm0OYA5IJrJRMCWGQsK/BCUhDQRkAgVCgAhIwAJK+A+E8BMgJEB++t6sDeYvBKTISZS5eL2zOzPv++a99z0PlKl0qaKtnBi7ObTBniHcTgZaAD/wjHRuRg+0cHOVxDScZSuDfYaII8rwkSq6ASdjl7BGi+k6NwYG1ccijOks7aYDpia4cQvXx6onVHy/OA2T05kGkiwTyYSv77YMMrvTMohxJoW9reL94+kWxNuVwd6ygRboqKosBcFwqBVoQVNgBUnuat3D4im8jvFxdUR7gZuAL3x90aPGBbYZ3QQWiEaGhJYqMHGgh6sCg4yx6mvE+GQEQ5nipnSpFWixNeE/PPZL4OYp7DRscWLqgnesYBXmm4EeWyHcGINBFC1JAVp4UwY39tE7JByUE9KCPPMDSefLCQCBBmu7uJlS7S0O8SUtJ9srAWM9nVW427grLZZa/HKTvYS0yMBZs6ZHd/QW0i+p8xaXvTSI/mWopvHzgoF6woGlE18/SQRa0hIM5XTt8MwtNucLbMVSbnloaKFIprnONwHI2ntACyZie8Qv398RKC3oLIBcYkMZ0DJGXbpfyGkcFt2PcOFfJXKDaemWi5uUmO6myMlAMBDEztfK3ex/6AkmGYgZ/UCircz/vNbHdlIgOtBhd6WlOogWD9LItzgaKnb0FmJfiRbZqOxzNZ9gykeLeK1PXVeqW+2Iiz5y5IgItLSItn8DqKSz6ii5YYwOBS248xRpLtvFAC28fTb/OKw1iqW03KWbEZ0CaKF1M5MqlsynCJx/4VGDAG+NHCvWc4tpJZECAWoJUj7VBborgFp4W4dGBmJGD1CO+r3L6FoDIrt6d1rKNtNCcKydvQXC8GwxZFBnU4AW2AiWOpU1kb3x9Mujh+9soWXukNxOVIbGW+jOC6YFcoAh7/Mfl/ulHWiBVFJyOkUoWfav3Au0FG6iBZGmQBia9MG0gCbibjz97ejhrg20EKOLa/cP917y3mjpnMexU6VL3oC3tIibaAlfCtOTA5GTPshGEMSuYfli7Db8Y+/iPOMfK0gM0pKWZMCwTOyPF71XaGgnjP3vcX3oaAn2Fh0k0YuflhJdv0hpyS3HFGJNmq4AWppxsXwK60keFmkHMUVEVMZ0W5roBlwLYjwAkUzCI1d9Qs7pmHQ5F2jvcWf4LtZT8SEIMh8NYnJ00z5eVEJ6wuEU2oPPA2I7WuiW0GYIoGWvg4iCJaWwm2iJcRlwIh7e0EPKr0LiU6Xcs8YLFppfrJhbIARTLTCUcKM8RaDWgZAIVcrf7C26FbHztGwopcWASQduguTHlI/YdHMTDGisOtyZKDoBAdBYcO1Y8xajz4lM6UAqAC3sGNirG5Ia5k335DhTnwQYmHyyFrBKDWf72QYcW5fyvJTPbEcLm9unDFuRUIEMS86psIhMh4C0LLCdB71+XfhAKOlTftfr4qoYEMjOqfFjzxLVg6V2H5szHrnUC0VXFVEMJ9imxpW9KETburmcGmVYZpa6qfQV8ZZhyV3wfmTEA4mdRlpYd9+xsEzJWatCgQyLXc0Q73qJdkWwFYwrJ7sF4AvkbnuEstclrCuxBTa3RqmcdHFzyUCLsw6A6FFXlUIgy6mI/AkfndPzQwnQAe+px/TGdDanT/l7psMyqNqbtzgd6niH4G5CJeljuWiH2hMLtJAhkVU3+8eCGkcdFyexnlGsW+LF7HgRCyTdkIPNPqWRSu5ACQSFrsRlx0mcx0t0D3tYQ1y0oJ4LVTm5Nbf4WIP5lMP5QRbsX2tSVLQ6Plpw1pVile/OcsZBJViowrpGRCNYLJbDUxNZuHbHrucWqDbV8XFZXM5ZSKBcvJAdJ3Lt4IVD8OTJIin3qtjeSEyZCTIQowx52A3IHQcgnldO2jPyCpmYPy5TsTakGaO55XBHkfnRKCp0hT0zX5NX8FlXXiPsDLiekwOiQmfPvKrRnCuoZLDKPzObrznXl8yAMFntMMPtVqvGg9FvsqNIfojoluBt80hNcoh+fPn1Mu48I5pL+Ptd5mpQYmjbYoU2w1yLuaXmcZF5pOIb+uNL82SxJm8K9T/P3+/92az5s8CLCz/QRh9aMNcGwo3CPkuBaEWBbCkIAEHC64sRCK81HzYlD7AEgAhH5MwjfS8EBM/7T8UCKZ/wG096VLT+CDo/YwKvAS3Xgo+I6G3okKdltp8oVI1htpjA4D1M+WsdQIsKrOXltdIPxn/wRQ8NeUXQMIo1iwIpn1HIhvObINswLdkbDmu0vPD55kZayD7mDH1jttKyD4/00/JSznj2SgvZjpbXrr1xtCjeBFpefW9pe3d5b2LJ9OyH+dfeW4yzy+tlRP23NfsRJgCE9xXaaeT1b5D2g/+YhVHscxDytr1tb9tLbf8DiUq8uqn7fekAAAAASUVORK5CYII="> </div> <h3 id="technical_details">Technical details</h3> <p>In this example we will use <strong>Random Fourier Features</strong>, introduced in the <a href="https://people.eecs.berkeley.edu/~brecht/papers/07.rah.rec.nips.pdf">"Random Features for Large-Scale Kernel Machines"</a> paper by Rahimi and Recht, to map the input data. Random Fourier Features map a vector \(\mathbf{x} \in \mathbb{R}^d\) to \(\mathbf{x'} \in \mathbb{R}^D\) via the following mapping:</p> <div> $$ RFFM(\cdot): \mathbb{R}^d \to \mathbb{R}^D, \quad RFFM(\mathbf{x}) = \cos(\mathbf{\Omega} \cdot \mathbf{x}+ \mathbf{b}) $$</div> <p>where \(\mathbf{\Omega} \in \mathbb{R}^{D \times d}\), \(\mathbf{x} \in \mathbb{R}^d,\) \(\mathbf{b} \in \mathbb{R}^D\) and the cosine is applied element-wise.</p> <p>In this example, the entries of \(\mathbf{\Omega}\) and \(\mathbf{b}\) are sampled from distributions such that the mapping satisfies the following property:</p> <div> $$ RFFM(\mathbf{x})^T \cdot RFFM(\mathbf{y}) \approx e^{-\frac{\|\mathbf{x} - \mathbf{y}\|^2}{2 \sigma^2}} $$</div> <p>The right-hand-side quantity of the expression above is known as the RBF (or Gaussian) kernel function. This function is one of the most-widely used kernel functions in Machine Learning and implicitly measures similarity in a different, much higher dimensional space than the original one. See <a href="https://en.wikipedia.org/wiki/Radial_basis_function_kernel">Radial basis function kernel</a> for more details.</p> <h3 id="kernel_classifier">Kernel classifier</h3> <p><a href="https://www.tensorflow.org/api_docs/python/tf/contrib/kernel_methods/KernelLinearClassifier"><code>tf.contrib.kernel_methods.KernelLinearClassifier</code></a> is a pre-packaged <a href="https://www.tensorflow.org/api_docs/python/tf/contrib/learn"><code>tf.contrib.learn</code></a> estimator that combines the power of explicit kernel mappings with linear models. Its constructor is almost identical to that of the LinearClassifier estimator with the additional option to specify a list of explicit kernel mappings to be applied to each feature the classifier uses. The following code snippet demonstrates how to replace LinearClassifier with KernelLinearClassifier.</p> <pre class="prettyprint lang-python" data-language="python"># Specify the feature(s) to be used by the estimator. This is identical to the
# code used for the LinearClassifier.
image_column = tf.contrib.layers.real_valued_column('images', dimension=784)
optimizer = tf.train.FtrlOptimizer(
   learning_rate=50.0, l2_regularization_strength=0.001)

kernel_mapper = tf.contrib.kernel_methods.RandomFourierFeatureMapper(
  input_dim=784, output_dim=2000, stddev=5.0, name='rffm')
kernel_mappers = {image_column: [kernel_mapper]}
estimator = tf.contrib.kernel_methods.KernelLinearClassifier(
   n_classes=10, optimizer=optimizer, kernel_mappers=kernel_mappers)

# Train.
start = time.time()
estimator.fit(input_fn=train_input_fn, steps=2000)
end = time.time()
print('Elapsed time: {} seconds'.format(end - start))

# Evaluate and report metrics.
eval_metrics = estimator.evaluate(input_fn=eval_input_fn, steps=1)
print(eval_metrics)
</pre> <p>The only additional parameter passed to <code>KernelLinearClassifier</code> is a dictionary from feature_columns to a list of kernel mappings to be applied to the corresponding feature column. The following lines instruct the classifier to first map the initial 784-dimensional images to 2000-dimensional vectors using random Fourier features and then learn a linear model on the transformed vectors:</p> <pre class="prettyprint lang-python" data-language="python">kernel_mapper = tf.contrib.kernel_methods.RandomFourierFeatureMapper(
  input_dim=784, output_dim=2000, stddev=5.0, name='rffm')
kernel_mappers = {image_column: [kernel_mapper]}
estimator = tf.contrib.kernel_methods.KernelLinearClassifier(
   n_classes=10, optimizer=optimizer, kernel_mappers=kernel_mappers)
</pre> <p>Notice the <code>stddev</code> parameter. This is the standard deviation (\(\sigma\)) of the approximated RBF kernel and controls the similarity measure used in classification. <code>stddev</code> is typically determined via hyperparameter tuning.</p> <p>The results of running the preceding code are summarized in the following table. We can further increase the accuracy by increasing the output dimension of the mapping and tuning the standard deviation.</p> <table> <thead> <tr> <th align="left">metric</th> <th>value</th> </tr> </thead> <tbody> <tr> <td align="left">loss</td> <td>0.10</td> </tr> <tr> <td align="left">accuracy</td> <td>97%</td> </tr> <tr> <td align="left">training time</td> <td>~35 seconds on my machine</td> </tr> </tbody> </table> <h3 id="stddev">stddev</h3> <p>The classification quality is very sensitive to the value of stddev. The following table shows the accuracy of the classifier on the eval data for different values of stddev. The optimal value is stddev=5.0. Notice how too small or too high stddev values can dramatically decrease the accuracy of the classification.</p> <table> <thead> <tr> <th align="left">stddev</th> <th>eval accuracy</th> </tr> </thead> <tbody> <tr> <td align="left">1.0</td> <td>0.1362</td> </tr> <tr> <td align="left">2.0</td> <td>0.4764</td> </tr> <tr> <td align="left">4.0</td> <td>0.9654</td> </tr> <tr> <td align="left">5.0</td> <td>0.9766</td> </tr> <tr> <td align="left">8.0</td> <td>0.9714</td> </tr> <tr> <td align="left">16.0</td> <td>0.8878</td> </tr> </tbody> </table> <h3 id="output_dimension">Output dimension</h3> <p>Intuitively, the larger the output dimension of the mapping, the closer the inner product of two mapped vectors approximates the kernel, which typically translates to better classification accuracy. Another way to think about this is that the output dimension equals the number of weights of the linear model; the larger this dimension, the larger the "degrees of freedom" of the model. However, after a certain threshold, higher output dimensions increase the accuracy by very little, while making training take more time. This is shown in the following two Figures which depict the eval accuracy as a function of the output dimension and the training time, respectively.</p> <p><img alt="image" src="data:image/png;base64,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"> <img alt="image" src="data:image/png;base64,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"></p> <h2 id="summary">Summary</h2> <p>Explicit kernel mappings combine the predictive power of nonlinear models with the scalability of linear models. Unlike traditional dual kernel methods, explicit kernel methods can scale to millions or hundreds of millions of samples. When using explicit kernel mappings, consider the following tips:</p> <ul> <li>Random Fourier Features can be particularly effective for datasets with dense features.</li> <li>The parameters of the kernel mapping are often data-dependent. Model quality can be very sensitive to these parameters. Use hyperparameter tuning to find the optimal values.</li> <li>If you have multiple numerical features, concatenate them into a single multi-dimensional feature and apply the kernel mapping to the concatenated vector.</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2018 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/tutorials/kernel_methods" class="_attribution-link">https://www.tensorflow.org/tutorials/kernel_methods</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
