
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>xml.etree.ElementTree - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" New in version 2.5. ">
  <meta name="keywords" content="xml, etree, elementtree, —, api, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/xml.etree.elementtree.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/python~2.7.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="xml-etree-elementtree-the-elementtree-xml-api"> xml.etree.ElementTree — The ElementTree XML API</h1> <div class="versionadded" id="module-xml.etree.ElementTree"> <p><span class="versionmodified added">New in version 2.5.</span></p> </div> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/2.7/Lib/xml/etree/ElementTree.py">Lib/xml/etree/ElementTree.py</a></p>  <p>The <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> type is a flexible container object, designed to store hierarchical data structures in memory. The type can be described as a cross between a list and a dictionary.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The <a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code>xml.etree.ElementTree</code></a> module is not secure against maliciously constructed data. If you need to parse untrusted or unauthenticated data see <a class="reference internal" href="xml#xml-vulnerabilities"><span class="std std-ref">XML vulnerabilities</span></a>.</p> </div> <p>Each element has a number of properties associated with it:</p> <ul class="simple"> <li>a tag which is a string identifying what kind of data this element represents (the element type, in other words).</li> <li>a number of attributes, stored in a Python dictionary.</li> <li>a text string.</li> <li>an optional tail string.</li> <li>a number of child elements, stored in a Python sequence</li> </ul> <p>To create an element instance, use the <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> constructor or the <a class="reference internal" href="#xml.etree.ElementTree.SubElement" title="xml.etree.ElementTree.SubElement"><code>SubElement()</code></a> factory function.</p> <p>The <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code>ElementTree</code></a> class can be used to wrap an element structure, and convert it from and to XML.</p> <p>A C implementation of this API is available as <code>xml.etree.cElementTree</code>.</p> <p>See <a class="reference external" href="http://effbot.org/zone/element-index.htm">http://effbot.org/zone/element-index.htm</a> for tutorials and links to other docs. Fredrik Lundh’s page is also the location of the development version of the xml.etree.ElementTree.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>The ElementTree API is updated to 1.3. For more information, see <a class="reference external" href="http://effbot.org/zone/elementtree-13-intro.htm">Introducing ElementTree 1.3</a>.</p> </div>  <h2 id="tutorial">1. Tutorial</h2> <p>This is a short tutorial for using <a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code>xml.etree.ElementTree</code></a> (<code>ET</code> in short). The goal is to demonstrate some of the building blocks and basic concepts of the module.</p>  <h3 id="xml-tree-and-elements">1.1. XML tree and elements</h3> <p>XML is an inherently hierarchical data format, and the most natural way to represent it is with a tree. <code>ET</code> has two classes for this purpose - <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code>ElementTree</code></a> represents the whole XML document as a tree, and <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> represents a single node in this tree. Interactions with the whole document (reading and writing to/from files) are usually done on the <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code>ElementTree</code></a> level. Interactions with a single XML element and its sub-elements are done on the <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> level.</p>   <h3 id="elementtree-parsing-xml">1.2. Parsing XML</h3> <p id="parsing-xml">We’ll be using the following XML document as the sample data for this section:</p> <pre data-language="xml">&lt;?xml version="1.0"?&gt;
&lt;data&gt;
    &lt;country name="Liechtenstein"&gt;
        &lt;rank&gt;1&lt;/rank&gt;
        &lt;year&gt;2008&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;neighbor name="Austria" direction="E"/&gt;
        &lt;neighbor name="Switzerland" direction="W"/&gt;
    &lt;/country&gt;
    &lt;country name="Singapore"&gt;
        &lt;rank&gt;4&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
        &lt;neighbor name="Malaysia" direction="N"/&gt;
    &lt;/country&gt;
    &lt;country name="Panama"&gt;
        &lt;rank&gt;68&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;13600&lt;/gdppc&gt;
        &lt;neighbor name="Costa Rica" direction="W"/&gt;
        &lt;neighbor name="Colombia" direction="E"/&gt;
    &lt;/country&gt;
&lt;/data&gt;
</pre> <p>We have a number of ways to import the data. Reading the file from disk:</p> <pre data-language="python">import xml.etree.ElementTree as ET
tree = ET.parse('country_data.xml')
root = tree.getroot()
</pre> <p>Reading the data from a string:</p> <pre data-language="python">root = ET.fromstring(country_data_as_string)
</pre> <p><a class="reference internal" href="#xml.etree.ElementTree.fromstring" title="xml.etree.ElementTree.fromstring"><code>fromstring()</code></a> parses XML from a string directly into an <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a>, which is the root element of the parsed tree. Other parsing functions may create an <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code>ElementTree</code></a>. Check the documentation to be sure.</p> <p>As an <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a>, <code>root</code> has a tag and a dictionary of attributes:</p> <pre data-language="python">&gt;&gt;&gt; root.tag
'data'
&gt;&gt;&gt; root.attrib
{}
</pre> <p>It also has children nodes over which we can iterate:</p> <pre data-language="python">&gt;&gt;&gt; for child in root:
...     print child.tag, child.attrib
...
country {'name': 'Liechtenstein'}
country {'name': 'Singapore'}
country {'name': 'Panama'}
</pre> <p>Children are nested, and we can access specific child nodes by index:</p> <pre data-language="python">&gt;&gt;&gt; root[0][1].text
'2008'
</pre>   <h3 id="finding-interesting-elements">1.3. Finding interesting elements</h3> <p><a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> has some useful methods that help iterate recursively over all the sub-tree below it (its children, their children, and so on). For example, <a class="reference internal" href="#xml.etree.ElementTree.Element.iter" title="xml.etree.ElementTree.Element.iter"><code>Element.iter()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; for neighbor in root.iter('neighbor'):
...     print neighbor.attrib
...
{'name': 'Austria', 'direction': 'E'}
{'name': 'Switzerland', 'direction': 'W'}
{'name': 'Malaysia', 'direction': 'N'}
{'name': 'Costa Rica', 'direction': 'W'}
{'name': 'Colombia', 'direction': 'E'}
</pre> <p><a class="reference internal" href="#xml.etree.ElementTree.Element.findall" title="xml.etree.ElementTree.Element.findall"><code>Element.findall()</code></a> finds only elements with a tag which are direct children of the current element. <a class="reference internal" href="#xml.etree.ElementTree.Element.find" title="xml.etree.ElementTree.Element.find"><code>Element.find()</code></a> finds the <em>first</em> child with a particular tag, and <a class="reference internal" href="#xml.etree.ElementTree.Element.text" title="xml.etree.ElementTree.Element.text"><code>Element.text</code></a> accesses the element’s text content. <a class="reference internal" href="#xml.etree.ElementTree.Element.get" title="xml.etree.ElementTree.Element.get"><code>Element.get()</code></a> accesses the element’s attributes:</p> <pre data-language="python">&gt;&gt;&gt; for country in root.findall('country'):
...     rank = country.find('rank').text
...     name = country.get('name')
...     print name, rank
...
Liechtenstein 1
Singapore 4
Panama 68
</pre> <p>More sophisticated specification of which elements to look for is possible by using <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">XPath</span></a>.</p>   <h3 id="modifying-an-xml-file">1.4. Modifying an XML File</h3> <p><a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code>ElementTree</code></a> provides a simple way to build XML documents and write them to files. The <a class="reference internal" href="#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code>ElementTree.write()</code></a> method serves this purpose.</p> <p>Once created, an <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> object may be manipulated by directly changing its fields (such as <a class="reference internal" href="#xml.etree.ElementTree.Element.text" title="xml.etree.ElementTree.Element.text"><code>Element.text</code></a>), adding and modifying attributes (<a class="reference internal" href="#xml.etree.ElementTree.Element.set" title="xml.etree.ElementTree.Element.set"><code>Element.set()</code></a> method), as well as adding new children (for example with <a class="reference internal" href="#xml.etree.ElementTree.Element.append" title="xml.etree.ElementTree.Element.append"><code>Element.append()</code></a>).</p> <p>Let’s say we want to add one to each country’s rank, and add an <code>updated</code> attribute to the rank element:</p> <pre data-language="python">&gt;&gt;&gt; for rank in root.iter('rank'):
...     new_rank = int(rank.text) + 1
...     rank.text = str(new_rank)
...     rank.set('updated', 'yes')
...
&gt;&gt;&gt; tree.write('output.xml')
</pre> <p>Our XML now looks like this:</p> <pre data-language="xml">&lt;?xml version="1.0"?&gt;
&lt;data&gt;
    &lt;country name="Liechtenstein"&gt;
        &lt;rank updated="yes"&gt;2&lt;/rank&gt;
        &lt;year&gt;2008&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;neighbor name="Austria" direction="E"/&gt;
        &lt;neighbor name="Switzerland" direction="W"/&gt;
    &lt;/country&gt;
    &lt;country name="Singapore"&gt;
        &lt;rank updated="yes"&gt;5&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
        &lt;neighbor name="Malaysia" direction="N"/&gt;
    &lt;/country&gt;
    &lt;country name="Panama"&gt;
        &lt;rank updated="yes"&gt;69&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;13600&lt;/gdppc&gt;
        &lt;neighbor name="Costa Rica" direction="W"/&gt;
        &lt;neighbor name="Colombia" direction="E"/&gt;
    &lt;/country&gt;
&lt;/data&gt;
</pre> <p>We can remove elements using <a class="reference internal" href="#xml.etree.ElementTree.Element.remove" title="xml.etree.ElementTree.Element.remove"><code>Element.remove()</code></a>. Let’s say we want to remove all countries with a rank higher than 50:</p> <pre data-language="python">&gt;&gt;&gt; for country in root.findall('country'):
...     rank = int(country.find('rank').text)
...     if rank &gt; 50:
...         root.remove(country)
...
&gt;&gt;&gt; tree.write('output.xml')
</pre> <p>Our XML now looks like this:</p> <pre data-language="xml">&lt;?xml version="1.0"?&gt;
&lt;data&gt;
    &lt;country name="Liechtenstein"&gt;
        &lt;rank updated="yes"&gt;2&lt;/rank&gt;
        &lt;year&gt;2008&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;neighbor name="Austria" direction="E"/&gt;
        &lt;neighbor name="Switzerland" direction="W"/&gt;
    &lt;/country&gt;
    &lt;country name="Singapore"&gt;
        &lt;rank updated="yes"&gt;5&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
        &lt;neighbor name="Malaysia" direction="N"/&gt;
    &lt;/country&gt;
&lt;/data&gt;
</pre>   <h3 id="building-xml-documents">1.5. Building XML documents</h3> <p>The <a class="reference internal" href="#xml.etree.ElementTree.SubElement" title="xml.etree.ElementTree.SubElement"><code>SubElement()</code></a> function also provides a convenient way to create new sub-elements for a given element:</p> <pre data-language="python">&gt;&gt;&gt; a = ET.Element('a')
&gt;&gt;&gt; b = ET.SubElement(a, 'b')
&gt;&gt;&gt; c = ET.SubElement(a, 'c')
&gt;&gt;&gt; d = ET.SubElement(c, 'd')
&gt;&gt;&gt; ET.dump(a)
&lt;a&gt;&lt;b /&gt;&lt;c&gt;&lt;d /&gt;&lt;/c&gt;&lt;/a&gt;
</pre>   <h3 id="parsing-xml-with-namespaces">1.6. Parsing XML with Namespaces</h3> <p>If the XML input has <a class="reference external" href="https://en.wikipedia.org/wiki/XML_namespace">namespaces</a>, tags and attributes with prefixes in the form <code>prefix:sometag</code> get expanded to <code>{uri}sometag</code> where the <em>prefix</em> is replaced by the full <em>URI</em>. Also, if there is a <a class="reference external" href="https://www.w3.org/TR/xml-names/#defaulting">default namespace</a>, that full URI gets prepended to all of the non-prefixed tags.</p> <p>Here is an XML example that incorporates two namespaces, one with the prefix “fictional” and the other serving as the default namespace:</p> <pre data-language="xml">&lt;?xml version="1.0"?&gt;
&lt;actors xmlns:fictional="http://characters.example.com"
        xmlns="http://people.example.com"&gt;
    &lt;actor&gt;
        &lt;name&gt;John Cleese&lt;/name&gt;
        &lt;fictional:character&gt;Lancelot&lt;/fictional:character&gt;
        &lt;fictional:character&gt;Archie Leach&lt;/fictional:character&gt;
    &lt;/actor&gt;
    &lt;actor&gt;
        &lt;name&gt;Eric Idle&lt;/name&gt;
        &lt;fictional:character&gt;Sir Robin&lt;/fictional:character&gt;
        &lt;fictional:character&gt;Gunther&lt;/fictional:character&gt;
        &lt;fictional:character&gt;Commander Clement&lt;/fictional:character&gt;
    &lt;/actor&gt;
&lt;/actors&gt;
</pre> <p>One way to search and explore this XML example is to manually add the URI to every tag or attribute in the xpath of a <a class="reference internal" href="#xml.etree.ElementTree.Element.find" title="xml.etree.ElementTree.Element.find"><code>find()</code></a> or <a class="reference internal" href="#xml.etree.ElementTree.Element.findall" title="xml.etree.ElementTree.Element.findall"><code>findall()</code></a>:</p> <pre data-language="python">root = fromstring(xml_text)
for actor in root.findall('{http://people.example.com}actor'):
    name = actor.find('{http://people.example.com}name')
    print name.text
    for char in actor.findall('{http://characters.example.com}character'):
        print ' |--&gt;', char.text
</pre> <p>A better way to search the namespaced XML example is to create a dictionary with your own prefixes and use those in the search functions:</p> <pre data-language="python">ns = {'real_person': 'http://people.example.com',
      'role': 'http://characters.example.com'}

for actor in root.findall('real_person:actor', ns):
    name = actor.find('real_person:name', ns)
    print name.text
    for char in actor.findall('role:character', ns):
        print ' |--&gt;', char.text
</pre> <p>These two approaches both output:</p> <pre data-language="python">John Cleese
 |--&gt; Lancelot
 |--&gt; Archie Leach
Eric Idle
 |--&gt; Sir Robin
 |--&gt; Gunther
 |--&gt; Commander Clement
</pre>   <h3 id="additional-resources">1.7. Additional resources</h3> <p>See <a class="reference external" href="http://effbot.org/zone/element-index.htm">http://effbot.org/zone/element-index.htm</a> for tutorials and links to other docs.</p>    <h2 id="elementtree-xpath">2. XPath support</h2> <p id="xpath-support">This module provides limited support for <a class="reference external" href="https://www.w3.org/TR/xpath">XPath expressions</a> for locating elements in a tree. The goal is to support a small subset of the abbreviated syntax; a full XPath engine is outside the scope of the module.</p>  <h3 id="example">2.1. Example</h3> <p>Here’s an example that demonstrates some of the XPath capabilities of the module. We’ll be using the <code>countrydata</code> XML document from the <a class="reference internal" href="#elementtree-parsing-xml"><span class="std std-ref">Parsing XML</span></a> section:</p> <pre data-language="python">import xml.etree.ElementTree as ET

root = ET.fromstring(countrydata)

# Top-level elements
root.findall(".")

# All 'neighbor' grand-children of 'country' children of the top-level
# elements
root.findall("./country/neighbor")

# Nodes with name='Singapore' that have a 'year' child
root.findall(".//year/..[@name='Singapore']")

# 'year' nodes that are children of nodes with name='Singapore'
root.findall(".//*[@name='Singapore']/year")

# All 'neighbor' nodes that are the second child of their parent
root.findall(".//neighbor[2]")
</pre>   <h3 id="supported-xpath-syntax">2.2. Supported XPath syntax</h3> <table class="docutils align-center">  <thead> <tr>
<th class="head"><p>Syntax</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p><code>tag</code></p></td> <td><p>Selects all child elements with the given tag. For example, <code>spam</code> selects all child elements named <code>spam</code>, and <code>spam/egg</code> selects all grandchildren named <code>egg</code> in all children named <code>spam</code>.</p></td> </tr> <tr>
<td><p><code>*</code></p></td> <td><p>Selects all child elements. For example, <code>*/egg</code> selects all grandchildren named <code>egg</code>.</p></td> </tr> <tr>
<td><p><code>.</code></p></td> <td><p>Selects the current node. This is mostly useful at the beginning of the path, to indicate that it’s a relative path.</p></td> </tr> <tr>
<td><p><code>//</code></p></td> <td><p>Selects all subelements, on all levels beneath the current element. For example, <code>.//egg</code> selects all <code>egg</code> elements in the entire tree.</p></td> </tr> <tr>
<td><p><code>..</code></p></td> <td><p>Selects the parent element.</p></td> </tr> <tr>
<td><p><code>[@attrib]</code></p></td> <td><p>Selects all elements that have the given attribute.</p></td> </tr> <tr>
<td><p><code>[@attrib='value']</code></p></td> <td><p>Selects all elements for which the given attribute has the given value. The value cannot contain quotes.</p></td> </tr> <tr>
<td><p><code>[tag]</code></p></td> <td><p>Selects all elements that have a child named <code>tag</code>. Only immediate children are supported.</p></td> </tr> <tr>
<td><p><code>[tag='text']</code></p></td> <td><p>Selects all elements that have a child named <code>tag</code> whose complete text content, including descendants, equals the given <code>text</code>.</p></td> </tr> <tr>
<td><p><code>[position]</code></p></td> <td><p>Selects all elements that are located at the given position. The position can be either an integer (1 is the first position), the expression <code>last()</code> (for the last position), or a position relative to the last position (e.g. <code>last()-1</code>).</p></td> </tr>  </table> <p>Predicates (expressions within square brackets) must be preceded by a tag name, an asterisk, or another predicate. <code>position</code> predicates must be preceded by a tag name.</p>    <h2 id="reference">3. Reference</h2>  <h3 id="elementtree-functions">3.1. Functions</h3> <dl class="function" id="functions"> <dt id="xml.etree.ElementTree.Comment">
<code>xml.etree.ElementTree.Comment(text=None)</code> </dt> <dd>
<p>Comment element factory. This factory function creates a special element that will be serialized as an XML comment by the standard serializer. The comment string can be either a bytestring or a Unicode string. <em>text</em> is a string containing the comment string. Returns an element instance representing a comment.</p> </dd>
</dl> <dl class="function"> <dt id="xml.etree.ElementTree.dump">
<code>xml.etree.ElementTree.dump(elem)</code> </dt> <dd>
<p>Writes an element tree or element structure to sys.stdout. This function should be used for debugging only.</p> <p>The exact output format is implementation dependent. In this version, it’s written as an ordinary XML file.</p> <p><em>elem</em> is an element tree or an individual element.</p> </dd>
</dl> <dl class="function"> <dt id="xml.etree.ElementTree.fromstring">
<code>xml.etree.ElementTree.fromstring(text)</code> </dt> <dd>
<p>Parses an XML section from a string constant. Same as <a class="reference internal" href="#xml.etree.ElementTree.XML" title="xml.etree.ElementTree.XML"><code>XML()</code></a>. <em>text</em> is a string containing XML data. Returns an <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> instance.</p> </dd>
</dl> <dl class="function"> <dt id="xml.etree.ElementTree.fromstringlist">
<code>xml.etree.ElementTree.fromstringlist(sequence, parser=None)</code> </dt> <dd>
<p>Parses an XML document from a sequence of string fragments. <em>sequence</em> is a list or other sequence containing XML data fragments. <em>parser</em> is an optional parser instance. If not given, the standard <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code>XMLParser</code></a> parser is used. Returns an <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> instance.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="xml.etree.ElementTree.iselement">
<code>xml.etree.ElementTree.iselement(element)</code> </dt> <dd>
<p>Checks if an object appears to be a valid element object. <em>element</em> is an element instance. Returns a true value if this is an element object.</p> </dd>
</dl> <dl class="function"> <dt id="xml.etree.ElementTree.iterparse">
<code>xml.etree.ElementTree.iterparse(source, events=None, parser=None)</code> </dt> <dd>
<p>Parses an XML section into an element tree incrementally, and reports what’s going on to the user. <em>source</em> is a filename or file object containing XML data. <em>events</em> is a list of events to report back. If omitted, only “end” events are reported. <em>parser</em> is an optional parser instance. If not given, the standard <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code>XMLParser</code></a> parser is used. <em>parser</em> is not supported by <code>cElementTree</code>. Returns an <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> providing <code>(event, elem)</code> pairs.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="#xml.etree.ElementTree.iterparse" title="xml.etree.ElementTree.iterparse"><code>iterparse()</code></a> only guarantees that it has seen the “&gt;” character of a starting tag when it emits a “start” event, so the attributes are defined, but the contents of the text and tail attributes are undefined at that point. The same applies to the element children; they may or may not be present.</p> <p>If you need a fully populated element, look for “end” events instead.</p> </div> </dd>
</dl> <dl class="function"> <dt id="xml.etree.ElementTree.parse">
<code>xml.etree.ElementTree.parse(source, parser=None)</code> </dt> <dd>
<p>Parses an XML section into an element tree. <em>source</em> is a filename or file object containing XML data. <em>parser</em> is an optional parser instance. If not given, the standard <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code>XMLParser</code></a> parser is used. Returns an <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code>ElementTree</code></a> instance.</p> </dd>
</dl> <dl class="function"> <dt id="xml.etree.ElementTree.ProcessingInstruction">
<code>xml.etree.ElementTree.ProcessingInstruction(target, text=None)</code> </dt> <dd>
<p>PI element factory. This factory function creates a special element that will be serialized as an XML processing instruction. <em>target</em> is a string containing the PI target. <em>text</em> is a string containing the PI contents, if given. Returns an element instance, representing a processing instruction.</p> </dd>
</dl> <dl class="function"> <dt id="xml.etree.ElementTree.register_namespace">
<code>xml.etree.ElementTree.register_namespace(prefix, uri)</code> </dt> <dd>
<p>Registers a namespace prefix. The registry is global, and any existing mapping for either the given prefix or the namespace URI will be removed. <em>prefix</em> is a namespace prefix. <em>uri</em> is a namespace uri. Tags and attributes in this namespace will be serialized with the given prefix, if at all possible.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="xml.etree.ElementTree.SubElement">
<code>xml.etree.ElementTree.SubElement(parent, tag, attrib={}, **extra)</code> </dt> <dd>
<p>Subelement factory. This function creates an element instance, and appends it to an existing element.</p> <p>The element name, attribute names, and attribute values can be either bytestrings or Unicode strings. <em>parent</em> is the parent element. <em>tag</em> is the subelement name. <em>attrib</em> is an optional dictionary, containing element attributes. <em>extra</em> contains additional attributes, given as keyword arguments. Returns an element instance.</p> </dd>
</dl> <dl class="function"> <dt id="xml.etree.ElementTree.tostring">
<code>xml.etree.ElementTree.tostring(element, encoding="us-ascii", method="xml")</code> </dt> <dd>
<p>Generates a string representation of an XML element, including all subelements. <em>element</em> is an <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> instance. <em>encoding</em> <a class="footnote-reference brackets" href="#id5" id="id1">1</a> is the output encoding (default is US-ASCII). <em>method</em> is either <code>"xml"</code>, <code>"html"</code> or <code>"text"</code> (default is <code>"xml"</code>). Returns an encoded string containing the XML data.</p> </dd>
</dl> <dl class="function"> <dt id="xml.etree.ElementTree.tostringlist">
<code>xml.etree.ElementTree.tostringlist(element, encoding="us-ascii", method="xml")</code> </dt> <dd>
<p>Generates a string representation of an XML element, including all subelements. <em>element</em> is an <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> instance. <em>encoding</em> <a class="footnote-reference brackets" href="#id5" id="id2">1</a> is the output encoding (default is US-ASCII). <em>method</em> is either <code>"xml"</code>, <code>"html"</code> or <code>"text"</code> (default is <code>"xml"</code>). Returns a list of encoded strings containing the XML data. It does not guarantee any specific sequence, except that <code>"".join(tostringlist(element)) ==
tostring(element)</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="xml.etree.ElementTree.XML">
<code>xml.etree.ElementTree.XML(text, parser=None)</code> </dt> <dd>
<p>Parses an XML section from a string constant. This function can be used to embed “XML literals” in Python code. <em>text</em> is a string containing XML data. <em>parser</em> is an optional parser instance. If not given, the standard <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code>XMLParser</code></a> parser is used. Returns an <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> instance.</p> </dd>
</dl> <dl class="function"> <dt id="xml.etree.ElementTree.XMLID">
<code>xml.etree.ElementTree.XMLID(text, parser=None)</code> </dt> <dd>
<p>Parses an XML section from a string constant, and also returns a dictionary which maps from element id:s to elements. <em>text</em> is a string containing XML data. <em>parser</em> is an optional parser instance. If not given, the standard <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code>XMLParser</code></a> parser is used. Returns a tuple containing an <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> instance and a dictionary.</p> </dd>
</dl>   <h3 id="elementtree-element-objects">3.2. Element Objects</h3> <dl class="class" id="element-objects"> <dt id="xml.etree.ElementTree.Element">
<code>class xml.etree.ElementTree.Element(tag, attrib={}, **extra)</code> </dt> <dd>
<p>Element class. This class defines the Element interface, and provides a reference implementation of this interface.</p> <p>The element name, attribute names, and attribute values can be either bytestrings or Unicode strings. <em>tag</em> is the element name. <em>attrib</em> is an optional dictionary, containing element attributes. <em>extra</em> contains additional attributes, given as keyword arguments.</p> <dl class="attribute"> <dt id="xml.etree.ElementTree.Element.tag">
<code>tag</code> </dt> <dd>
<p>A string identifying what kind of data this element represents (the element type, in other words).</p> </dd>
</dl> <dl class="attribute"> <dt id="xml.etree.ElementTree.Element.text">
<code>text</code> </dt> <dt id="xml.etree.ElementTree.Element.tail">
<code>tail</code> </dt> <dd>
<p>These attributes can be used to hold additional data associated with the element. Their values are usually strings but may be any application-specific object. If the element is created from an XML file, the <em>text</em> attribute holds either the text between the element’s start tag and its first child or end tag, or <code>None</code>, and the <em>tail</em> attribute holds either the text between the element’s end tag and the next tag, or <code>None</code>. For the XML data</p> <pre data-language="xml">&lt;a&gt;&lt;b&gt;1&lt;c&gt;2&lt;d/&gt;3&lt;/c&gt;&lt;/b&gt;4&lt;/a&gt;
</pre> <p>the <em>a</em> element has <code>None</code> for both <em>text</em> and <em>tail</em> attributes, the <em>b</em> element has <em>text</em> <code>"1"</code> and <em>tail</em> <code>"4"</code>, the <em>c</em> element has <em>text</em> <code>"2"</code> and <em>tail</em> <code>None</code>, and the <em>d</em> element has <em>text</em> <code>None</code> and <em>tail</em> <code>"3"</code>.</p> <p>To collect the inner text of an element, see <a class="reference internal" href="#xml.etree.ElementTree.Element.itertext" title="xml.etree.ElementTree.Element.itertext"><code>itertext()</code></a>, for example <code>"".join(element.itertext())</code>.</p> <p>Applications may store arbitrary objects in these attributes.</p> </dd>
</dl> <dl class="attribute"> <dt id="xml.etree.ElementTree.Element.attrib">
<code>attrib</code> </dt> <dd>
<p>A dictionary containing the element’s attributes. Note that while the <em>attrib</em> value is always a real mutable Python dictionary, an ElementTree implementation may choose to use another internal representation, and create the dictionary only if someone asks for it. To take advantage of such implementations, use the dictionary methods below whenever possible.</p> </dd>
</dl> <p>The following dictionary-like methods work on the element attributes.</p> <dl class="method"> <dt id="xml.etree.ElementTree.Element.clear">
<code>clear()</code> </dt> <dd>
<p>Resets an element. This function removes all subelements, clears all attributes, and sets the text and tail attributes to <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.get">
<code>get(key, default=None)</code> </dt> <dd>
<p>Gets the element attribute named <em>key</em>.</p> <p>Returns the attribute value, or <em>default</em> if the attribute was not found.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.items">
<code>items()</code> </dt> <dd>
<p>Returns the element attributes as a sequence of (name, value) pairs. The attributes are returned in an arbitrary order.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.keys">
<code>keys()</code> </dt> <dd>
<p>Returns the elements attribute names as a list. The names are returned in an arbitrary order.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.set">
<code>set(key, value)</code> </dt> <dd>
<p>Set the attribute <em>key</em> on the element to <em>value</em>.</p> </dd>
</dl> <p>The following methods work on the element’s children (subelements).</p> <dl class="method"> <dt id="xml.etree.ElementTree.Element.append">
<code>append(subelement)</code> </dt> <dd>
<p>Adds the element <em>subelement</em> to the end of this elements internal list of subelements.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.extend">
<code>extend(subelements)</code> </dt> <dd>
<p>Appends <em>subelements</em> from a sequence object with zero or more elements. Raises <a class="reference internal" href="exceptions#exceptions.AssertionError" title="exceptions.AssertionError"><code>AssertionError</code></a> if a subelement is not a valid object.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.find">
<code>find(match)</code> </dt> <dd>
<p>Finds the first subelement matching <em>match</em>. <em>match</em> may be a tag name or path. Returns an element instance or <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.findall">
<code>findall(match)</code> </dt> <dd>
<p>Finds all matching subelements, by tag name or path. Returns a list containing all matching elements in document order.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.findtext">
<code>findtext(match, default=None)</code> </dt> <dd>
<p>Finds text for the first subelement matching <em>match</em>. <em>match</em> may be a tag name or path. Returns the text content of the first matching element, or <em>default</em> if no element was found. Note that if the matching element has no text content an empty string is returned.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.getchildren">
<code>getchildren()</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 2.7: </span>Use <code>list(elem)</code> or iteration.</p> </div> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.getiterator">
<code>getiterator(tag=None)</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 2.7: </span>Use method <a class="reference internal" href="#xml.etree.ElementTree.Element.iter" title="xml.etree.ElementTree.Element.iter"><code>Element.iter()</code></a> instead.</p> </div> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.insert">
<code>insert(index, element)</code> </dt> <dd>
<p>Inserts a subelement at the given position in this element.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.iter">
<code>iter(tag=None)</code> </dt> <dd>
<p>Creates a tree <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> with the current element as the root. The iterator iterates over this element and all elements below it, in document (depth first) order. If <em>tag</em> is not <code>None</code> or <code>'*'</code>, only elements whose tag equals <em>tag</em> are returned from the iterator. If the tree structure is modified during iteration, the result is undefined.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.iterfind">
<code>iterfind(match)</code> </dt> <dd>
<p>Finds all matching subelements, by tag name or path. Returns an iterable yielding all matching elements in document order.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.itertext">
<code>itertext()</code> </dt> <dd>
<p>Creates a text iterator. The iterator loops over this element and all subelements, in document order, and returns all inner text.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.makeelement">
<code>makeelement(tag, attrib)</code> </dt> <dd>
<p>Creates a new element object of the same type as this element. Do not call this method, use the <a class="reference internal" href="#xml.etree.ElementTree.SubElement" title="xml.etree.ElementTree.SubElement"><code>SubElement()</code></a> factory function instead.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.Element.remove">
<code>remove(subelement)</code> </dt> <dd>
<p>Removes <em>subelement</em> from the element. Unlike the find* methods this method compares elements based on the instance identity, not on tag value or contents.</p> </dd>
</dl> <p><a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> objects also support the following sequence type methods for working with subelements: <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__delitem__" title="object.__delitem__"><code>__delitem__()</code></a>, <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a>, <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code>__setitem__()</code></a>, <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__len__" title="object.__len__"><code>__len__()</code></a>.</p> <p>Caution: Elements with no subelements will test as <code>False</code>. This behavior will change in future versions. Use specific <code>len(elem)</code> or <code>elem is
None</code> test instead.</p> <pre data-language="python">element = root.find('foo')

if not element:  # careful!
    print "element not found, or element has no subelements"

if element is None:
    print "element not found"
</pre> </dd>
</dl>   <h3 id="elementtree-elementtree-objects">3.3. ElementTree Objects</h3> <dl class="class" id="elementtree-objects"> <dt id="xml.etree.ElementTree.ElementTree">
<code>class xml.etree.ElementTree.ElementTree(element=None, file=None)</code> </dt> <dd>
<p>ElementTree wrapper class. This class represents an entire element hierarchy, and adds some extra support for serialization to and from standard XML.</p> <p><em>element</em> is the root element. The tree is initialized with the contents of the XML <em>file</em> if given.</p> <dl class="method"> <dt id="xml.etree.ElementTree.ElementTree._setroot">
<code>_setroot(element)</code> </dt> <dd>
<p>Replaces the root element for this tree. This discards the current contents of the tree, and replaces it with the given element. Use with care. <em>element</em> is an element instance.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.ElementTree.find">
<code>find(match)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#xml.etree.ElementTree.Element.find" title="xml.etree.ElementTree.Element.find"><code>Element.find()</code></a>, starting at the root of the tree.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.ElementTree.findall">
<code>findall(match)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#xml.etree.ElementTree.Element.findall" title="xml.etree.ElementTree.Element.findall"><code>Element.findall()</code></a>, starting at the root of the tree.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.ElementTree.findtext">
<code>findtext(match, default=None)</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#xml.etree.ElementTree.Element.findtext" title="xml.etree.ElementTree.Element.findtext"><code>Element.findtext()</code></a>, starting at the root of the tree.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.ElementTree.getiterator">
<code>getiterator(tag=None)</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 2.7: </span>Use method <a class="reference internal" href="#xml.etree.ElementTree.ElementTree.iter" title="xml.etree.ElementTree.ElementTree.iter"><code>ElementTree.iter()</code></a> instead.</p> </div> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.ElementTree.getroot">
<code>getroot()</code> </dt> <dd>
<p>Returns the root element for this tree.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.ElementTree.iter">
<code>iter(tag=None)</code> </dt> <dd>
<p>Creates and returns a tree iterator for the root element. The iterator loops over all elements in this tree, in section order. <em>tag</em> is the tag to look for (default is to return all elements).</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.ElementTree.iterfind">
<code>iterfind(match)</code> </dt> <dd>
<p>Finds all matching subelements, by tag name or path. Same as getroot().iterfind(match). Returns an iterable yielding all matching elements in document order.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.ElementTree.parse">
<code>parse(source, parser=None)</code> </dt> <dd>
<p>Loads an external XML section into this element tree. <em>source</em> is a file name or file object. <em>parser</em> is an optional parser instance. If not given, the standard XMLParser parser is used. Returns the section root element.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.ElementTree.write">
<code>write(file, encoding="us-ascii", xml_declaration=None, default_namespace=None, method="xml")</code> </dt> <dd>
<p>Writes the element tree to a file, as XML. <em>file</em> is a file name, or a file object opened for writing. <em>encoding</em> <a class="footnote-reference brackets" href="#id5" id="id3">1</a> is the output encoding (default is US-ASCII). <em>xml_declaration</em> controls if an XML declaration should be added to the file. Use <code>False</code> for never, <code>True</code> for always, <code>None</code> for only if not US-ASCII or UTF-8 (default is <code>None</code>). <em>default_namespace</em> sets the default XML namespace (for “xmlns”). <em>method</em> is either <code>"xml"</code>, <code>"html"</code> or <code>"text"</code> (default is <code>"xml"</code>). Returns an encoded string.</p> </dd>
</dl> </dd>
</dl> <p>This is the XML file that is going to be manipulated:</p> <pre data-language="python">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Example page&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;Moved to &lt;a href="http://example.org/"&gt;example.org&lt;/a&gt;
        or &lt;a href="http://example.com/"&gt;example.com&lt;/a&gt;.&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre> <p>Example of changing the attribute “target” of every link in first paragraph:</p> <pre data-language="python">&gt;&gt;&gt; from xml.etree.ElementTree import ElementTree
&gt;&gt;&gt; tree = ElementTree()
&gt;&gt;&gt; tree.parse("index.xhtml")
&lt;Element 'html' at 0xb77e6fac&gt;
&gt;&gt;&gt; p = tree.find("body/p")     # Finds first occurrence of tag p in body
&gt;&gt;&gt; p
&lt;Element 'p' at 0xb77ec26c&gt;
&gt;&gt;&gt; links = list(p.iter("a"))   # Returns list of all links
&gt;&gt;&gt; links
[&lt;Element 'a' at 0xb77ec2ac&gt;, &lt;Element 'a' at 0xb77ec1cc&gt;]
&gt;&gt;&gt; for i in links:             # Iterates through all found links
...     i.attrib["target"] = "blank"
...
&gt;&gt;&gt; tree.write("output.xhtml")
</pre>   <h3 id="elementtree-qname-objects">3.4. QName Objects</h3> <dl class="class" id="qname-objects"> <dt id="xml.etree.ElementTree.QName">
<code>class xml.etree.ElementTree.QName(text_or_uri, tag=None)</code> </dt> <dd>
<p>QName wrapper. This can be used to wrap a QName attribute value, in order to get proper namespace handling on output. <em>text_or_uri</em> is a string containing the QName value, in the form {uri}local, or, if the tag argument is given, the URI part of a QName. If <em>tag</em> is given, the first argument is interpreted as a URI, and this argument is interpreted as a local name. <a class="reference internal" href="#xml.etree.ElementTree.QName" title="xml.etree.ElementTree.QName"><code>QName</code></a> instances are opaque.</p> </dd>
</dl>   <h3 id="elementtree-treebuilder-objects">3.5. TreeBuilder Objects</h3> <dl class="class" id="treebuilder-objects"> <dt id="xml.etree.ElementTree.TreeBuilder">
<code>class xml.etree.ElementTree.TreeBuilder(element_factory=None)</code> </dt> <dd>
<p>Generic element structure builder. This builder converts a sequence of start, data, and end method calls to a well-formed element structure. You can use this class to build an element structure using a custom XML parser, or a parser for some other XML-like format. The <em>element_factory</em> is called to create new <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> instances when given.</p> <dl class="method"> <dt id="xml.etree.ElementTree.TreeBuilder.close">
<code>close()</code> </dt> <dd>
<p>Flushes the builder buffers, and returns the toplevel document element. Returns an <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> instance.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.TreeBuilder.data">
<code>data(data)</code> </dt> <dd>
<p>Adds text to the current element. <em>data</em> is a string. This should be either a bytestring, or a Unicode string.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.TreeBuilder.end">
<code>end(tag)</code> </dt> <dd>
<p>Closes the current element. <em>tag</em> is the element name. Returns the closed element.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.TreeBuilder.start">
<code>start(tag, attrs)</code> </dt> <dd>
<p>Opens a new element. <em>tag</em> is the element name. <em>attrs</em> is a dictionary containing element attributes. Returns the opened element.</p> </dd>
</dl> <p>In addition, a custom <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code>TreeBuilder</code></a> object can provide the following method:</p> <dl class="method"> <dt id="xml.etree.ElementTree.TreeBuilder.doctype">
<code>doctype(name, pubid, system)</code> </dt> <dd>
<p>Handles a doctype declaration. <em>name</em> is the doctype name. <em>pubid</em> is the public identifier. <em>system</em> is the system identifier. This method does not exist on the default <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code>TreeBuilder</code></a> class.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> </dd>
</dl>   <h3 id="elementtree-xmlparser-objects">3.6. XMLParser Objects</h3> <dl class="class" id="xmlparser-objects"> <dt id="xml.etree.ElementTree.XMLParser">
<code>class xml.etree.ElementTree.XMLParser(html=0, target=None, encoding=None)</code> </dt> <dd>
<p><a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code>Element</code></a> structure builder for XML source data, based on the expat parser. <em>html</em> are predefined HTML entities. This flag is not supported by the current implementation. <em>target</em> is the target object. If omitted, the builder uses an instance of the standard TreeBuilder class. <em>encoding</em> <a class="footnote-reference brackets" href="#id5" id="id4">1</a> is optional. If given, the value overrides the encoding specified in the XML file.</p> <dl class="method"> <dt id="xml.etree.ElementTree.XMLParser.close">
<code>close()</code> </dt> <dd>
<p>Finishes feeding data to the parser. Returns an element structure.</p> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.XMLParser.doctype">
<code>doctype(name, pubid, system)</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 2.7: </span>Define the <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder.doctype" title="xml.etree.ElementTree.TreeBuilder.doctype"><code>TreeBuilder.doctype()</code></a> method on a custom TreeBuilder target.</p> </div> </dd>
</dl> <dl class="method"> <dt id="xml.etree.ElementTree.XMLParser.feed">
<code>feed(data)</code> </dt> <dd>
<p>Feeds data to the parser. <em>data</em> is encoded data.</p> </dd>
</dl> </dd>
</dl> <p><a class="reference internal" href="#xml.etree.ElementTree.XMLParser.feed" title="xml.etree.ElementTree.XMLParser.feed"><code>XMLParser.feed()</code></a> calls <em>target</em>’s <code>start()</code> method for each opening tag, its <code>end()</code> method for each closing tag, and data is processed by method <code>data()</code>. <a class="reference internal" href="#xml.etree.ElementTree.XMLParser.close" title="xml.etree.ElementTree.XMLParser.close"><code>XMLParser.close()</code></a> calls <em>target</em>’s method <code>close()</code>. <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code>XMLParser</code></a> can be used not only for building a tree structure. This is an example of counting the maximum depth of an XML file:</p> <pre data-language="python">&gt;&gt;&gt; from xml.etree.ElementTree import XMLParser
&gt;&gt;&gt; class MaxDepth:                     # The target object of the parser
...     maxDepth = 0
...     depth = 0
...     def start(self, tag, attrib):   # Called for each opening tag.
...         self.depth += 1
...         if self.depth &gt; self.maxDepth:
...             self.maxDepth = self.depth
...     def end(self, tag):             # Called for each closing tag.
...         self.depth -= 1
...     def data(self, data):
...         pass            # We do not need to do anything with data.
...     def close(self):    # Called when all data has been parsed.
...         return self.maxDepth
...
&gt;&gt;&gt; target = MaxDepth()
&gt;&gt;&gt; parser = XMLParser(target=target)
&gt;&gt;&gt; exampleXml = """
... &lt;a&gt;
...   &lt;b&gt;
...   &lt;/b&gt;
...   &lt;b&gt;
...     &lt;c&gt;
...       &lt;d&gt;
...       &lt;/d&gt;
...     &lt;/c&gt;
...   &lt;/b&gt;
... &lt;/a&gt;"""
&gt;&gt;&gt; parser.feed(exampleXml)
&gt;&gt;&gt; parser.close()
4
</pre> <h4 class="rubric">Footnotes</h4> <dl class="footnote brackets"> <dt class="label" id="id5">
<code>1(1,2,3,4)</code> </dt> <dd>
<p>The encoding string included in XML output should conform to the appropriate standards. For example, “UTF-8” is valid, but “UTF8” is not. See <a class="reference external" href="https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl">https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl</a> and <a class="reference external" href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">https://www.iana.org/assignments/character-sets/character-sets.xhtml</a>.</p> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/xml.etree.elementtree.html" class="_attribution-link">https://docs.python.org/2.7/library/xml.etree.elementtree.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
