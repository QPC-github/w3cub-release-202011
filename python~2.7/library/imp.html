
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Imp - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" This module provides an interface to the mechanisms used to implement the import statement. It defines the following constants and functions&#58; ">
  <meta name="keywords" content="imp, —, access, import, internals, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/imp.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/python~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="imp-access-the-import-internals"> imp — Access the import internals</h1> <p id="module-imp">This module provides an interface to the mechanisms used to implement the <a class="reference internal" href="https://docs.python.org/2.7/reference/simple_stmts.html#import"><code>import</code></a> statement. It defines the following constants and functions:</p> <dl class="function"> <dt id="imp.get_magic">
<code>imp.get_magic()</code> </dt> <dd>
<p id="index-1">Return the magic string value used to recognize byte-compiled code files (<code>.pyc</code> files). (This value may be different for each Python version.)</p> </dd>
</dl> <dl class="function"> <dt id="imp.get_suffixes">
<code>imp.get_suffixes()</code> </dt> <dd>
<p>Return a list of 3-element tuples, each describing a particular type of module. Each triple has the form <code>(suffix, mode, type)</code>, where <em>suffix</em> is a string to be appended to the module name to form the filename to search for, <em>mode</em> is the mode string to pass to the built-in <a class="reference internal" href="functions#open" title="open"><code>open()</code></a> function to open the file (this can be <code>'r'</code> for text files or <code>'rb'</code> for binary files), and <em>type</em> is the file type, which has one of the values <a class="reference internal" href="#imp.PY_SOURCE" title="imp.PY_SOURCE"><code>PY_SOURCE</code></a>, <a class="reference internal" href="#imp.PY_COMPILED" title="imp.PY_COMPILED"><code>PY_COMPILED</code></a>, or <a class="reference internal" href="#imp.C_EXTENSION" title="imp.C_EXTENSION"><code>C_EXTENSION</code></a>, described below.</p> </dd>
</dl> <dl class="function"> <dt id="imp.find_module">
<code>imp.find_module(name[, path])</code> </dt> <dd>
<p>Try to find the module <em>name</em>. If <em>path</em> is omitted or <code>None</code>, the list of directory names given by <code>sys.path</code> is searched, but first a few special places are searched: the function tries to find a built-in module with the given name (<a class="reference internal" href="#imp.C_BUILTIN" title="imp.C_BUILTIN"><code>C_BUILTIN</code></a>), then a frozen module (<a class="reference internal" href="#imp.PY_FROZEN" title="imp.PY_FROZEN"><code>PY_FROZEN</code></a>), and on some systems some other places are looked in as well (on Windows, it looks in the registry which may point to a specific file).</p> <p>Otherwise, <em>path</em> must be a list of directory names; each directory is searched for files with any of the suffixes returned by <a class="reference internal" href="#imp.get_suffixes" title="imp.get_suffixes"><code>get_suffixes()</code></a> above. Invalid names in the list are silently ignored (but all list items must be strings).</p> <p>If search is successful, the return value is a 3-element tuple <code>(file,
pathname, description)</code>:</p> <p><em>file</em> is an open file object positioned at the beginning, <em>pathname</em> is the pathname of the file found, and <em>description</em> is a 3-element tuple as contained in the list returned by <a class="reference internal" href="#imp.get_suffixes" title="imp.get_suffixes"><code>get_suffixes()</code></a> describing the kind of module found.</p> <p>If the module does not live in a file, the returned <em>file</em> is <code>None</code>, <em>pathname</em> is the empty string, and the <em>description</em> tuple contains empty strings for its suffix and mode; the module type is indicated as given in parentheses above. If the search is unsuccessful, <a class="reference internal" href="exceptions#exceptions.ImportError" title="exceptions.ImportError"><code>ImportError</code></a> is raised. Other exceptions indicate problems with the arguments or environment.</p> <p>If the module is a package, <em>file</em> is <code>None</code>, <em>pathname</em> is the package path and the last item in the <em>description</em> tuple is <a class="reference internal" href="#imp.PKG_DIRECTORY" title="imp.PKG_DIRECTORY"><code>PKG_DIRECTORY</code></a>.</p> <p>This function does not handle hierarchical module names (names containing dots). In order to find <em>P.M</em>, that is, submodule <em>M</em> of package <em>P</em>, use <a class="reference internal" href="#imp.find_module" title="imp.find_module"><code>find_module()</code></a> and <a class="reference internal" href="#imp.load_module" title="imp.load_module"><code>load_module()</code></a> to find and load package <em>P</em>, and then use <a class="reference internal" href="#imp.find_module" title="imp.find_module"><code>find_module()</code></a> with the <em>path</em> argument set to <code>P.__path__</code>. When <em>P</em> itself has a dotted name, apply this recipe recursively.</p> </dd>
</dl> <dl class="function"> <dt id="imp.load_module">
<code>imp.load_module(name, file, pathname, description)</code> </dt> <dd>
<p id="index-2">Load a module that was previously found by <a class="reference internal" href="#imp.find_module" title="imp.find_module"><code>find_module()</code></a> (or by an otherwise conducted search yielding compatible results). This function does more than importing the module: if the module was already imported, it is equivalent to a <a class="reference internal" href="functions#reload" title="reload"><code>reload()</code></a>! The <em>name</em> argument indicates the full module name (including the package name, if this is a submodule of a package). The <em>file</em> argument is an open file, and <em>pathname</em> is the corresponding file name; these can be <code>None</code> and <code>''</code>, respectively, when the module is a package or not being loaded from a file. The <em>description</em> argument is a tuple, as would be returned by <a class="reference internal" href="#imp.get_suffixes" title="imp.get_suffixes"><code>get_suffixes()</code></a>, describing what kind of module must be loaded.</p> <p>If the load is successful, the return value is the module object; otherwise, an exception (usually <a class="reference internal" href="exceptions#exceptions.ImportError" title="exceptions.ImportError"><code>ImportError</code></a>) is raised.</p> <p><strong>Important:</strong> the caller is responsible for closing the <em>file</em> argument, if it was not <code>None</code>, even when an exception is raised. This is best done using a <a class="reference internal" href="https://docs.python.org/2.7/reference/compound_stmts.html#try"><code>try</code></a> … <a class="reference internal" href="https://docs.python.org/2.7/reference/compound_stmts.html#finally"><code>finally</code></a> statement.</p> </dd>
</dl> <dl class="function"> <dt id="imp.new_module">
<code>imp.new_module(name)</code> </dt> <dd>
<p>Return a new empty module object called <em>name</em>. This object is <em>not</em> inserted in <code>sys.modules</code>.</p> </dd>
</dl> <dl class="function"> <dt id="imp.lock_held">
<code>imp.lock_held()</code> </dt> <dd>
<p>Return <code>True</code> if the import lock is currently held, else <code>False</code>. On platforms without threads, always return <code>False</code>.</p> <p>On platforms with threads, a thread executing an import holds an internal lock until the import is complete. This lock blocks other threads from doing an import until the original import completes, which in turn prevents other threads from seeing incomplete module objects constructed by the original thread while in the process of completing its import (and the imports, if any, triggered by that).</p> </dd>
</dl> <dl class="function"> <dt id="imp.acquire_lock">
<code>imp.acquire_lock()</code> </dt> <dd>
<p>Acquire the interpreter’s import lock for the current thread. This lock should be used by import hooks to ensure thread-safety when importing modules.</p> <p>Once a thread has acquired the import lock, the same thread may acquire it again without blocking; the thread must release it once for each time it has acquired it.</p> <p>On platforms without threads, this function does nothing.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="imp.release_lock">
<code>imp.release_lock()</code> </dt> <dd>
<p>Release the interpreter’s import lock. On platforms without threads, this function does nothing.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </dd>
</dl> <p>The following constants with integer values, defined in this module, are used to indicate the search result of <a class="reference internal" href="#imp.find_module" title="imp.find_module"><code>find_module()</code></a>.</p> <dl class="data"> <dt id="imp.PY_SOURCE">
<code>imp.PY_SOURCE</code> </dt> <dd>
<p>The module was found as a source file.</p> </dd>
</dl> <dl class="data"> <dt id="imp.PY_COMPILED">
<code>imp.PY_COMPILED</code> </dt> <dd>
<p>The module was found as a compiled code object file.</p> </dd>
</dl> <dl class="data"> <dt id="imp.C_EXTENSION">
<code>imp.C_EXTENSION</code> </dt> <dd>
<p>The module was found as dynamically loadable shared library.</p> </dd>
</dl> <dl class="data"> <dt id="imp.PKG_DIRECTORY">
<code>imp.PKG_DIRECTORY</code> </dt> <dd>
<p>The module was found as a package directory.</p> </dd>
</dl> <dl class="data"> <dt id="imp.C_BUILTIN">
<code>imp.C_BUILTIN</code> </dt> <dd>
<p>The module was found as a built-in module.</p> </dd>
</dl> <dl class="data"> <dt id="imp.PY_FROZEN">
<code>imp.PY_FROZEN</code> </dt> <dd>
<p>The module was found as a frozen module (see <a class="reference internal" href="#imp.init_frozen" title="imp.init_frozen"><code>init_frozen()</code></a>).</p> </dd>
</dl> <p>The following constant and functions are obsolete; their functionality is available through <a class="reference internal" href="#imp.find_module" title="imp.find_module"><code>find_module()</code></a> or <a class="reference internal" href="#imp.load_module" title="imp.load_module"><code>load_module()</code></a>. They are kept around for backward compatibility:</p> <dl class="data"> <dt id="imp.SEARCH_ERROR">
<code>imp.SEARCH_ERROR</code> </dt> <dd>
<p>Unused.</p> </dd>
</dl> <dl class="function"> <dt id="imp.init_builtin">
<code>imp.init_builtin(name)</code> </dt> <dd>
<p>Initialize the built-in module called <em>name</em> and return its module object along with storing it in <code>sys.modules</code>. If the module was already initialized, it will be initialized <em>again</em>. Re-initialization involves the copying of the built-in module’s <code>__dict__</code> from the cached module over the module’s entry in <code>sys.modules</code>. If there is no built-in module called <em>name</em>, <code>None</code> is returned.</p> </dd>
</dl> <dl class="function"> <dt id="imp.init_frozen">
<code>imp.init_frozen(name)</code> </dt> <dd>
<p>Initialize the frozen module called <em>name</em> and return its module object. If the module was already initialized, it will be initialized <em>again</em>. If there is no frozen module called <em>name</em>, <code>None</code> is returned. (Frozen modules are modules written in Python whose compiled byte-code object is incorporated into a custom-built Python interpreter by Python’s <strong class="program">freeze</strong> utility. See <code>Tools/freeze/</code> for now.)</p> </dd>
</dl> <dl class="function"> <dt id="imp.is_builtin">
<code>imp.is_builtin(name)</code> </dt> <dd>
<p>Return <code>1</code> if there is a built-in module called <em>name</em> which can be initialized again. Return <code>-1</code> if there is a built-in module called <em>name</em> which cannot be initialized again (see <a class="reference internal" href="#imp.init_builtin" title="imp.init_builtin"><code>init_builtin()</code></a>). Return <code>0</code> if there is no built-in module called <em>name</em>.</p> </dd>
</dl> <dl class="function"> <dt id="imp.is_frozen">
<code>imp.is_frozen(name)</code> </dt> <dd>
<p>Return <code>True</code> if there is a frozen module (see <a class="reference internal" href="#imp.init_frozen" title="imp.init_frozen"><code>init_frozen()</code></a>) called <em>name</em>, or <code>False</code> if there is no such module.</p> </dd>
</dl> <dl class="function"> <dt id="imp.load_compiled">
<code>imp.load_compiled(name, pathname[, file])</code> </dt> <dd>
<p id="index-3">Load and initialize a module implemented as a byte-compiled code file and return its module object. If the module was already initialized, it will be initialized <em>again</em>. The <em>name</em> argument is used to create or access a module object. The <em>pathname</em> argument points to the byte-compiled code file. The <em>file</em> argument is the byte-compiled code file, open for reading in binary mode, from the beginning. It must currently be a real file object, not a user-defined class emulating a file.</p> </dd>
</dl> <dl class="function"> <dt id="imp.load_dynamic">
<code>imp.load_dynamic(name, pathname[, file])</code> </dt> <dd>
<p>Load and initialize a module implemented as a dynamically loadable shared library and return its module object. If the module was already initialized, it will be initialized <em>again</em>. Re-initialization involves copying the <code>__dict__</code> attribute of the cached instance of the module over the value used in the module cached in <code>sys.modules</code>. The <em>pathname</em> argument must point to the shared library. The <em>name</em> argument is used to construct the name of the initialization function: an external C function called <code>initname()</code> in the shared library is called. The optional <em>file</em> argument is ignored. (Note: using shared libraries is highly system dependent, and not all systems support it.)</p> <div class="impl-detail compound"> <p><strong>CPython implementation detail:</strong> The import internals identify extension modules by filename, so doing <code>foo = load_dynamic("foo", "mod.so")</code> and <code>bar = load_dynamic("bar", "mod.so")</code> will result in both foo and bar referring to the same module, regardless of whether or not <code>mod.so</code> exports an <code>initbar</code> function. On systems which support them, symlinks can be used to import multiple modules from the same shared library, as each reference to the module will use a different file name.</p> </div> </dd>
</dl> <dl class="function"> <dt id="imp.load_source">
<code>imp.load_source(name, pathname[, file])</code> </dt> <dd>
<p>Load and initialize a module implemented as a Python source file and return its module object. If the module was already initialized, it will be initialized <em>again</em>. The <em>name</em> argument is used to create or access a module object. The <em>pathname</em> argument points to the source file. The <em>file</em> argument is the source file, open for reading as text, from the beginning. It must currently be a real file object, not a user-defined class emulating a file. Note that if a properly matching byte-compiled file (with suffix <code>.pyc</code> or <code>.pyo</code>) exists, it will be used instead of parsing the given source file.</p> </dd>
</dl> <dl class="class"> <dt id="imp.NullImporter">
<code>class imp.NullImporter(path_string)</code> </dt> <dd>
<p>The <a class="reference internal" href="#imp.NullImporter" title="imp.NullImporter"><code>NullImporter</code></a> type is a <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" id="index-4"><strong>PEP 302</strong></a> import hook that handles non-directory path strings by failing to find any modules. Calling this type with an existing directory or empty string raises <a class="reference internal" href="exceptions#exceptions.ImportError" title="exceptions.ImportError"><code>ImportError</code></a>. Otherwise, a <a class="reference internal" href="#imp.NullImporter" title="imp.NullImporter"><code>NullImporter</code></a> instance is returned.</p> <p>Python adds instances of this type to <code>sys.path_importer_cache</code> for any path entries that are not directories and are not handled by any other path hooks on <code>sys.path_hooks</code>. Instances have only one method:</p> <dl class="method"> <dt id="imp.NullImporter.find_module">
<code>find_module(fullname[, path])</code> </dt> <dd>
<p>This method always returns <code>None</code>, indicating that the requested module could not be found.</p> </dd>
</dl> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.5.</span></p> </div> </dd>
</dl>  <h2 id="examples-imp">1. Examples</h2> <p id="examples">The following function emulates what was the standard import statement up to Python 1.4 (no hierarchical module names). (This <em>implementation</em> wouldn’t work in that version, since <a class="reference internal" href="#imp.find_module" title="imp.find_module"><code>find_module()</code></a> has been extended and <a class="reference internal" href="#imp.load_module" title="imp.load_module"><code>load_module()</code></a> has been added in 1.4.)</p> <pre data-language="python">import imp
import sys

def __import__(name, globals=None, locals=None, fromlist=None):
    # Fast path: see if the module has already been imported.
    try:
        return sys.modules[name]
    except KeyError:
        pass

    # If any of the following calls raises an exception,
    # there's a problem we can't handle -- let the caller handle it.

    fp, pathname, description = imp.find_module(name)

    try:
        return imp.load_module(name, fp, pathname, description)
    finally:
        # Since we may exit via an exception, close fp explicitly.
        if fp:
            fp.close()
</pre> <p id="index-5">A more complete example that implements hierarchical module names and includes a <a class="reference internal" href="functions#reload" title="reload"><code>reload()</code></a> function can be found in the module <code>knee</code>. The <code>knee</code> module can be found in <code>Demo/imputil/</code> in the Python source distribution.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/imp.html" class="_attribution-link">https://docs.python.org/2.7/library/imp.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
