
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Shlex - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" New in version 1.5.2. ">
  <meta name="keywords" content="shlex, —, simple, lexical, analysis, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/shlex.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/python~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="shlex-simple-lexical-analysis"> shlex — Simple lexical analysis</h1> <div class="versionadded" id="module-shlex"> <p><span class="versionmodified added">New in version 1.5.2.</span></p> </div> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/2.7/Lib/shlex.py">Lib/shlex.py</a></p>  <p>The <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> class makes it easy to write lexical analyzers for simple syntaxes resembling that of the Unix shell. This will often be useful for writing minilanguages, (for example, in run control files for Python applications) or for parsing quoted strings.</p> <p>Prior to Python 2.7.3, this module did not support Unicode input.</p> <p>The <a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code>shlex</code></a> module defines the following functions:</p> <dl class="function"> <dt id="shlex.split">
<code>shlex.split(s[, comments[, posix]])</code> </dt> <dd>
<p>Split the string <em>s</em> using shell-like syntax. If <em>comments</em> is <a class="reference internal" href="constants#False" title="False"><code>False</code></a> (the default), the parsing of comments in the given string will be disabled (setting the <a class="reference internal" href="#shlex.shlex.commenters" title="shlex.shlex.commenters"><code>commenters</code></a> attribute of the <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance to the empty string). This function operates in POSIX mode by default, but uses non-POSIX mode if the <em>posix</em> argument is false.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span>Added the <em>posix</em> parameter.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Since the <a class="reference internal" href="#shlex.split" title="shlex.split"><code>split()</code></a> function instantiates a <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance, passing <code>None</code> for <em>s</em> will read the string to split from standard input.</p> </div> </dd>
</dl> <p>The <a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code>shlex</code></a> module defines the following class:</p> <dl class="class"> <dt id="shlex.shlex">
<code>class shlex.shlex([instream[, infile[, posix]]])</code> </dt> <dd>
<p>A <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance or subclass instance is a lexical analyzer object. The initialization argument, if present, specifies where to read characters from. It must be a file-/stream-like object with <a class="reference internal" href="io#io.TextIOBase.read" title="io.TextIOBase.read"><code>read()</code></a> and <a class="reference internal" href="io#io.TextIOBase.readline" title="io.TextIOBase.readline"><code>readline()</code></a> methods, or a string (strings are accepted since Python 2.3). If no argument is given, input will be taken from <code>sys.stdin</code>. The second optional argument is a filename string, which sets the initial value of the <a class="reference internal" href="#shlex.shlex.infile" title="shlex.shlex.infile"><code>infile</code></a> attribute. If the <em>instream</em> argument is omitted or equal to <code>sys.stdin</code>, this second argument defaults to “stdin”. The <em>posix</em> argument was introduced in Python 2.3, and defines the operational mode. When <em>posix</em> is not true (default), the <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance will operate in compatibility mode. When operating in POSIX mode, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> will try to be as close as possible to the POSIX shell parsing rules.</p> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="configparser#module-ConfigParser" title="ConfigParser: Configuration file parser."><code>ConfigParser</code></a>
</dt>
<dd>
<p>Parser for configuration files similar to the Windows <code>.ini</code> files.</p> </dd> </dl> </div>  <h2 id="id1">1. shlex Objects</h2> <p id="shlex-objects">A <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance has the following methods:</p> <dl class="method"> <dt id="shlex.shlex.get_token">
<code>shlex.get_token()</code> </dt> <dd>
<p>Return a token. If tokens have been stacked using <a class="reference internal" href="#shlex.shlex.push_token" title="shlex.shlex.push_token"><code>push_token()</code></a>, pop a token off the stack. Otherwise, read one from the input stream. If reading encounters an immediate end-of-file, <a class="reference internal" href="#shlex.shlex.eof" title="shlex.shlex.eof"><code>eof</code></a> is returned (the empty string (<code>''</code>) in non-POSIX mode, and <code>None</code> in POSIX mode).</p> </dd>
</dl> <dl class="method"> <dt id="shlex.shlex.push_token">
<code>shlex.push_token(str)</code> </dt> <dd>
<p>Push the argument onto the token stack.</p> </dd>
</dl> <dl class="method"> <dt id="shlex.shlex.read_token">
<code>shlex.read_token()</code> </dt> <dd>
<p>Read a raw token. Ignore the pushback stack, and do not interpret source requests. (This is not ordinarily a useful entry point, and is documented here only for the sake of completeness.)</p> </dd>
</dl> <dl class="method"> <dt id="shlex.shlex.sourcehook">
<code>shlex.sourcehook(filename)</code> </dt> <dd>
<p>When <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> detects a source request (see <a class="reference internal" href="#shlex.shlex.source" title="shlex.shlex.source"><code>source</code></a> below) this method is given the following token as argument, and expected to return a tuple consisting of a filename and an open file-like object.</p> <p>Normally, this method first strips any quotes off the argument. If the result is an absolute pathname, or there was no previous source request in effect, or the previous source was a stream (such as <code>sys.stdin</code>), the result is left alone. Otherwise, if the result is a relative pathname, the directory part of the name of the file immediately before it on the source inclusion stack is prepended (this behavior is like the way the C preprocessor handles <code>#include
"file.h"</code>).</p> <p>The result of the manipulations is treated as a filename, and returned as the first component of the tuple, with <a class="reference internal" href="functions#open" title="open"><code>open()</code></a> called on it to yield the second component. (Note: this is the reverse of the order of arguments in instance initialization!)</p> <p>This hook is exposed so that you can use it to implement directory search paths, addition of file extensions, and other namespace hacks. There is no corresponding ‘close’ hook, but a shlex instance will call the <a class="reference internal" href="io#io.IOBase.close" title="io.IOBase.close"><code>close()</code></a> method of the sourced input stream when it returns EOF.</p> <p>For more explicit control of source stacking, use the <a class="reference internal" href="#shlex.shlex.push_source" title="shlex.shlex.push_source"><code>push_source()</code></a> and <a class="reference internal" href="#shlex.shlex.pop_source" title="shlex.shlex.pop_source"><code>pop_source()</code></a> methods.</p> </dd>
</dl> <dl class="method"> <dt id="shlex.shlex.push_source">
<code>shlex.push_source(stream[, filename])</code> </dt> <dd>
<p>Push an input source stream onto the input stack. If the filename argument is specified it will later be available for use in error messages. This is the same method used internally by the <a class="reference internal" href="#shlex.shlex.sourcehook" title="shlex.shlex.sourcehook"><code>sourcehook()</code></a> method.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.1.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="shlex.shlex.pop_source">
<code>shlex.pop_source()</code> </dt> <dd>
<p>Pop the last-pushed input source from the input stack. This is the same method used internally when the lexer reaches EOF on a stacked input stream.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.1.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="shlex.shlex.error_leader">
<code>shlex.error_leader([file[, line]])</code> </dt> <dd>
<p>This method generates an error message leader in the format of a Unix C compiler error label; the format is <code>'"%s", line %d: '</code>, where the <code>%s</code> is replaced with the name of the current source file and the <code>%d</code> with the current input line number (the optional arguments can be used to override these).</p> <p>This convenience is provided to encourage <a class="reference internal" href="#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code>shlex</code></a> users to generate error messages in the standard, parseable format understood by Emacs and other Unix tools.</p> </dd>
</dl> <p>Instances of <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> subclasses have some public instance variables which either control lexical analysis or can be used for debugging:</p> <dl class="attribute"> <dt id="shlex.shlex.commenters">
<code>shlex.commenters</code> </dt> <dd>
<p>The string of characters that are recognized as comment beginners. All characters from the comment beginner to end of line are ignored. Includes just <code>'#'</code> by default.</p> </dd>
</dl> <dl class="attribute"> <dt id="shlex.shlex.wordchars">
<code>shlex.wordchars</code> </dt> <dd>
<p>The string of characters that will accumulate into multi-character tokens. By default, includes all ASCII alphanumerics and underscore.</p> </dd>
</dl> <dl class="attribute"> <dt id="shlex.shlex.whitespace">
<code>shlex.whitespace</code> </dt> <dd>
<p>Characters that will be considered whitespace and skipped. Whitespace bounds tokens. By default, includes space, tab, linefeed and carriage-return.</p> </dd>
</dl> <dl class="attribute"> <dt id="shlex.shlex.escape">
<code>shlex.escape</code> </dt> <dd>
<p>Characters that will be considered as escape. This will be only used in POSIX mode, and includes just <code>'\'</code> by default.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </dd>
</dl> <dl class="attribute"> <dt id="shlex.shlex.quotes">
<code>shlex.quotes</code> </dt> <dd>
<p>Characters that will be considered string quotes. The token accumulates until the same quote is encountered again (thus, different quote types protect each other as in the shell.) By default, includes ASCII single and double quotes.</p> </dd>
</dl> <dl class="attribute"> <dt id="shlex.shlex.escapedquotes">
<code>shlex.escapedquotes</code> </dt> <dd>
<p>Characters in <a class="reference internal" href="#shlex.shlex.quotes" title="shlex.shlex.quotes"><code>quotes</code></a> that will interpret escape characters defined in <a class="reference internal" href="#shlex.shlex.escape" title="shlex.shlex.escape"><code>escape</code></a>. This is only used in POSIX mode, and includes just <code>'"'</code> by default.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </dd>
</dl> <dl class="attribute"> <dt id="shlex.shlex.whitespace_split">
<code>shlex.whitespace_split</code> </dt> <dd>
<p>If <code>True</code>, tokens will only be split in whitespaces. This is useful, for example, for parsing command lines with <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a>, getting tokens in a similar way to shell arguments.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </dd>
</dl> <dl class="attribute"> <dt id="shlex.shlex.infile">
<code>shlex.infile</code> </dt> <dd>
<p>The name of the current input file, as initially set at class instantiation time or stacked by later source requests. It may be useful to examine this when constructing error messages.</p> </dd>
</dl> <dl class="attribute"> <dt id="shlex.shlex.instream">
<code>shlex.instream</code> </dt> <dd>
<p>The input stream from which this <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance is reading characters.</p> </dd>
</dl> <dl class="attribute"> <dt id="shlex.shlex.source">
<code>shlex.source</code> </dt> <dd>
<p>This attribute is <code>None</code> by default. If you assign a string to it, that string will be recognized as a lexical-level inclusion request similar to the <code>source</code> keyword in various shells. That is, the immediately following token will be opened as a filename and input will be taken from that stream until EOF, at which point the <a class="reference internal" href="io#io.IOBase.close" title="io.IOBase.close"><code>close()</code></a> method of that stream will be called and the input source will again become the original input stream. Source requests may be stacked any number of levels deep.</p> </dd>
</dl> <dl class="attribute"> <dt id="shlex.shlex.debug">
<code>shlex.debug</code> </dt> <dd>
<p>If this attribute is numeric and <code>1</code> or more, a <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> instance will print verbose progress output on its behavior. If you need to use this, you can read the module source code to learn the details.</p> </dd>
</dl> <dl class="attribute"> <dt id="shlex.shlex.lineno">
<code>shlex.lineno</code> </dt> <dd>
<p>Source line number (count of newlines seen so far plus one).</p> </dd>
</dl> <dl class="attribute"> <dt id="shlex.shlex.token">
<code>shlex.token</code> </dt> <dd>
<p>The token buffer. It may be useful to examine this when catching exceptions.</p> </dd>
</dl> <dl class="attribute"> <dt id="shlex.shlex.eof">
<code>shlex.eof</code> </dt> <dd>
<p>Token used to determine end of file. This will be set to the empty string (<code>''</code>), in non-POSIX mode, and to <code>None</code> in POSIX mode.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </dd>
</dl>   <h2 id="shlex-parsing-rules">2. Parsing Rules</h2> <p id="parsing-rules">When operating in non-POSIX mode, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> will try to obey to the following rules.</p> <ul class="simple"> <li>Quote characters are not recognized within words (<code>Do"Not"Separate</code> is parsed as the single word <code>Do"Not"Separate</code>);</li> <li>Escape characters are not recognized;</li> <li>Enclosing characters in quotes preserve the literal value of all characters within the quotes;</li> <li>Closing quotes separate words (<code>"Do"Separate</code> is parsed as <code>"Do"</code> and <code>Separate</code>);</li> <li>If <a class="reference internal" href="#shlex.shlex.whitespace_split" title="shlex.shlex.whitespace_split"><code>whitespace_split</code></a> is <code>False</code>, any character not declared to be a word character, whitespace, or a quote will be returned as a single-character token. If it is <code>True</code>, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> will only split words in whitespaces;</li> <li>EOF is signaled with an empty string (<code>''</code>);</li> <li>It’s not possible to parse empty strings, even if quoted.</li> </ul> <p>When operating in POSIX mode, <a class="reference internal" href="#shlex.shlex" title="shlex.shlex"><code>shlex</code></a> will try to obey to the following parsing rules.</p> <ul class="simple"> <li>Quotes are stripped out, and do not separate words (<code>"Do"Not"Separate"</code> is parsed as the single word <code>DoNotSeparate</code>);</li> <li>Non-quoted escape characters (e.g. <code>'\'</code>) preserve the literal value of the next character that follows;</li> <li>Enclosing characters in quotes which are not part of <a class="reference internal" href="#shlex.shlex.escapedquotes" title="shlex.shlex.escapedquotes"><code>escapedquotes</code></a> (e.g. <code>"'"</code>) preserve the literal value of all characters within the quotes;</li> <li>Enclosing characters in quotes which are part of <a class="reference internal" href="#shlex.shlex.escapedquotes" title="shlex.shlex.escapedquotes"><code>escapedquotes</code></a> (e.g. <code>'"'</code>) preserves the literal value of all characters within the quotes, with the exception of the characters mentioned in <a class="reference internal" href="#shlex.shlex.escape" title="shlex.shlex.escape"><code>escape</code></a>. The escape characters retain its special meaning only when followed by the quote in use, or the escape character itself. Otherwise the escape character will be considered a normal character.</li> <li>EOF is signaled with a <a class="reference internal" href="constants#None" title="None"><code>None</code></a> value;</li> <li>Quoted empty strings (<code>''</code>) are allowed;</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/shlex.html" class="_attribution-link">https://docs.python.org/2.7/library/shlex.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
