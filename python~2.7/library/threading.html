
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Threading - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" Source code&#58; Lib&#47;threading.py ">
  <meta name="keywords" content="threading, —, higher-level, interface, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/threading.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/python~2.7.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="threading-higher-level-threading-interface"> threading — Higher-level threading interface</h1> <p id="module-threading"><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/2.7/Lib/threading.py">Lib/threading.py</a></p>  <p>This module constructs higher-level threading interfaces on top of the lower level <a class="reference internal" href="thread#module-thread" title="thread: Create multiple threads of control within one interpreter."><code>thread</code></a> module. See also the <a class="reference internal" href="mutex#module-mutex" title="mutex: Lock and queue for mutual exclusion. (deprecated)"><code>mutex</code></a> and <a class="reference internal" href="queue#module-Queue" title="Queue: A synchronized queue class."><code>Queue</code></a> modules.</p> <p>The <a class="reference internal" href="dummy_threading#module-dummy_threading" title="dummy_threading: Drop-in replacement for the threading module."><code>dummy_threading</code></a> module is provided for situations where <a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><code>threading</code></a> cannot be used because <a class="reference internal" href="thread#module-thread" title="thread: Create multiple threads of control within one interpreter."><code>thread</code></a> is missing.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Starting with Python 2.6, this module provides <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0008" id="index-0"><strong>PEP 8</strong></a> compliant aliases and properties to replace the <code>camelCase</code> names that were inspired by Java’s threading API. This updated API is compatible with that of the <a class="reference internal" href="multiprocessing#module-multiprocessing" title='multiprocessing: Process-based "threading" interface.'><code>multiprocessing</code></a> module. However, no schedule has been set for the deprecation of the <code>camelCase</code> names and they remain fully supported in both Python 2.x and 3.x.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Starting with Python 2.5, several Thread methods raise <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a> instead of <a class="reference internal" href="exceptions#exceptions.AssertionError" title="exceptions.AssertionError"><code>AssertionError</code></a> if called erroneously.</p> </div> <div class="impl-detail compound"> <p><strong>CPython implementation detail:</strong> In CPython, due to the <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-global-interpreter-lock"><span class="xref std std-term">Global Interpreter Lock</span></a>, only one thread can execute Python code at once (even though certain performance-oriented libraries might overcome this limitation). If you want your application to make better use of the computational resources of multi-core machines, you are advised to use <a class="reference internal" href="multiprocessing#module-multiprocessing" title='multiprocessing: Process-based "threading" interface.'><code>multiprocessing</code></a>. However, threading is still an appropriate model if you want to run multiple I/O-bound tasks simultaneously.</p> </div> <p>This module defines the following functions and objects:</p> <dl class="function"> <dt id="threading.active_count">
<code>threading.active_count()</code> </dt> <dt id="threading.activeCount">
<code>threading.activeCount()</code> </dt> <dd>
<p>Return the number of <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code>Thread</code></a> objects currently alive. The returned count is equal to the length of the list returned by <a class="reference internal" href="#threading.enumerate" title="threading.enumerate"><code>enumerate()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span>Added <code>active_count()</code> spelling.</p> </div> </dd>
</dl> <dl class="function"> <dt>
<code>threading.Condition()</code> </dt> <dd>
<p>A factory function that returns a new condition variable object. A condition variable allows one or more threads to wait until they are notified by another thread.</p> <p>See <a class="reference internal" href="#condition-objects"><span class="std std-ref">Condition Objects</span></a>.</p> </dd>
</dl> <dl class="function"> <dt id="threading.current_thread">
<code>threading.current_thread()</code> </dt> <dt id="threading.currentThread">
<code>threading.currentThread()</code> </dt> <dd>
<p>Return the current <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code>Thread</code></a> object, corresponding to the caller’s thread of control. If the caller’s thread of control was not created through the <a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><code>threading</code></a> module, a dummy thread object with limited functionality is returned.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span>Added <code>current_thread()</code> spelling.</p> </div> </dd>
</dl> <dl class="function"> <dt id="threading.enumerate">
<code>threading.enumerate()</code> </dt> <dd>
<p>Return a list of all <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code>Thread</code></a> objects currently alive. The list includes daemonic threads, dummy thread objects created by <a class="reference internal" href="#threading.current_thread" title="threading.current_thread"><code>current_thread()</code></a>, and the main thread. It excludes terminated threads and threads that have not yet been started.</p> </dd>
</dl> <dl class="function"> <dt>
<code>threading.Event()</code> </dt> <dd>
<p>A factory function that returns a new event object. An event manages a flag that can be set to true with the <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code>set()</code></a> method and reset to false with the <code>clear()</code> method. The <code>wait()</code> method blocks until the flag is true.</p> <p>See <a class="reference internal" href="#event-objects"><span class="std std-ref">Event Objects</span></a>.</p> </dd>
</dl> <dl class="class"> <dt id="threading.local">
<code>class threading.local</code> </dt> <dd>
<p>A class that represents thread-local data. Thread-local data are data whose values are thread specific. To manage thread-local data, just create an instance of <a class="reference internal" href="#threading.local" title="threading.local"><code>local</code></a> (or a subclass) and store attributes on it:</p> <pre data-language="python">mydata = threading.local()
mydata.x = 1
</pre> <p>The instance’s values will be different for separate threads.</p> <p>For more details and extensive examples, see the documentation string of the <code>_threading_local</code> module.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="threading.Lock">
<code>threading.Lock()</code> </dt> <dd>
<p>A factory function that returns a new primitive lock object. Once a thread has acquired it, subsequent attempts to acquire it block, until it is released; any thread may release it.</p> <p>See <a class="reference internal" href="#lock-objects"><span class="std std-ref">Lock Objects</span></a>.</p> </dd>
</dl> <dl class="function"> <dt id="threading.RLock">
<code>threading.RLock()</code> </dt> <dd>
<p>A factory function that returns a new reentrant lock object. A reentrant lock must be released by the thread that acquired it. Once a thread has acquired a reentrant lock, the same thread may acquire it again without blocking; the thread must release it once for each time it has acquired it.</p> <p>See <a class="reference internal" href="#rlock-objects"><span class="std std-ref">RLock Objects</span></a>.</p> </dd>
</dl> <dl class="function"> <dt>
<code>threading.Semaphore([value])</code> </dt> <dd>
<p>A factory function that returns a new semaphore object. A semaphore manages a counter representing the number of <code>release()</code> calls minus the number of <code>acquire()</code> calls, plus an initial value. The <code>acquire()</code> method blocks if necessary until it can return without making the counter negative. If not given, <em>value</em> defaults to 1.</p> <p>See <a class="reference internal" href="#semaphore-objects"><span class="std std-ref">Semaphore Objects</span></a>.</p> </dd>
</dl> <dl class="function"> <dt id="threading.BoundedSemaphore">
<code>threading.BoundedSemaphore([value])</code> </dt> <dd>
<p>A factory function that returns a new bounded semaphore object. A bounded semaphore checks to make sure its current value doesn’t exceed its initial value. If it does, <a class="reference internal" href="exceptions#exceptions.ValueError" title="exceptions.ValueError"><code>ValueError</code></a> is raised. In most situations semaphores are used to guard resources with limited capacity. If the semaphore is released too many times it’s a sign of a bug. If not given, <em>value</em> defaults to 1.</p> </dd>
</dl> <dl class="class"> <dt>
<code>class threading.Thread</code> </dt> <dd>
<p>A class that represents a thread of control. This class can be safely subclassed in a limited fashion.</p> <p>See <a class="reference internal" href="#thread-objects"><span class="std std-ref">Thread Objects</span></a>.</p> </dd>
</dl> <dl class="class"> <dt>
<code>class threading.Timer</code> </dt> <dd>
<p>A thread that executes a function after a specified interval has passed.</p> <p>See <a class="reference internal" href="#timer-objects"><span class="std std-ref">Timer Objects</span></a>.</p> </dd>
</dl> <dl class="function"> <dt id="threading.settrace">
<code>threading.settrace(func)</code> </dt> <dd>
<p id="index-1">Set a trace function for all threads started from the <a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><code>threading</code></a> module. The <em>func</em> will be passed to <a class="reference internal" href="sys#sys.settrace" title="sys.settrace"><code>sys.settrace()</code></a> for each thread, before its <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method is called.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="threading.setprofile">
<code>threading.setprofile(func)</code> </dt> <dd>
<p id="index-2">Set a profile function for all threads started from the <a class="reference internal" href="#module-threading" title="threading: Higher-level threading interface."><code>threading</code></a> module. The <em>func</em> will be passed to <a class="reference internal" href="sys#sys.setprofile" title="sys.setprofile"><code>sys.setprofile()</code></a> for each thread, before its <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method is called.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="threading.stack_size">
<code>threading.stack_size([size])</code> </dt> <dd>
<p>Return the thread stack size used when creating new threads. The optional <em>size</em> argument specifies the stack size to be used for subsequently created threads, and must be 0 (use platform or configured default) or a positive integer value of at least 32,768 (32 KiB). If <em>size</em> is not specified, 0 is used. If changing the thread stack size is unsupported, a <a class="reference internal" href="#threading.ThreadError" title="threading.ThreadError"><code>ThreadError</code></a> is raised. If the specified stack size is invalid, a <a class="reference internal" href="exceptions#exceptions.ValueError" title="exceptions.ValueError"><code>ValueError</code></a> is raised and the stack size is unmodified. 32kB is currently the minimum supported stack size value to guarantee sufficient stack space for the interpreter itself. Note that some platforms may have particular restrictions on values for the stack size, such as requiring a minimum stack size &gt; 32kB or requiring allocation in multiples of the system memory page size - platform documentation should be referred to for more information (4kB pages are common; using multiples of 4096 for the stack size is the suggested approach in the absence of more specific information). Availability: Windows, systems with POSIX threads.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.5.</span></p> </div> </dd>
</dl> <dl class="exception"> <dt id="threading.ThreadError">
<code>exception threading.ThreadError</code> </dt> <dd>
<p>Raised for various threading-related errors as described below. Note that many interfaces use <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a> instead of <a class="reference internal" href="#threading.ThreadError" title="threading.ThreadError"><code>ThreadError</code></a>.</p> </dd>
</dl> <p>Detailed interfaces for the objects are documented below.</p> <p>The design of this module is loosely based on Java’s threading model. However, where Java makes locks and condition variables basic behavior of every object, they are separate objects in Python. Python’s <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code>Thread</code></a> class supports a subset of the behavior of Java’s Thread class; currently, there are no priorities, no thread groups, and threads cannot be destroyed, stopped, suspended, resumed, or interrupted. The static methods of Java’s Thread class, when implemented, are mapped to module-level functions.</p> <p>All of the methods described below are executed atomically.</p>  <h2 id="id1">1. Thread Objects</h2> <p id="thread-objects">This class represents an activity that is run in a separate thread of control. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the <code>run()</code> method in a subclass. No other methods (except for the constructor) should be overridden in a subclass. In other words, <em>only</em> override the <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> and <code>run()</code> methods of this class.</p> <p>Once a thread object is created, its activity must be started by calling the thread’s <code>start()</code> method. This invokes the <code>run()</code> method in a separate thread of control.</p> <p>Once the thread’s activity is started, the thread is considered ‘alive’. It stops being alive when its <code>run()</code> method terminates – either normally, or by raising an unhandled exception. The <code>is_alive()</code> method tests whether the thread is alive.</p> <p>Other threads can call a thread’s <code>join()</code> method. This blocks the calling thread until the thread whose <code>join()</code> method is called is terminated.</p> <p>A thread has a name. The name can be passed to the constructor, and read or changed through the <code>name</code> attribute.</p> <p>A thread can be flagged as a “daemon thread”. The significance of this flag is that the entire Python program exits when only daemon threads are left. The initial value is inherited from the creating thread. The flag can be set through the <code>daemon</code> property.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Daemon threads are abruptly stopped at shutdown. Their resources (such as open files, database transactions, etc.) may not be released properly. If you want your threads to stop gracefully, make them non-daemonic and use a suitable signalling mechanism such as an <a class="reference internal" href="#threading.Event" title="threading.Event"><code>Event</code></a>.</p> </div> <p>There is a “main thread” object; this corresponds to the initial thread of control in the Python program. It is not a daemon thread.</p> <p>There is the possibility that “dummy thread objects” are created. These are thread objects corresponding to “alien threads”, which are threads of control started outside the threading module, such as directly from C code. Dummy thread objects have limited functionality; they are always considered alive and daemonic, and cannot be <code>join()</code>ed. They are never deleted, since it is impossible to detect the termination of alien threads.</p> <dl class="class"> <dt id="threading.Thread">
<code>class threading.Thread(group=None, target=None, name=None, args=(), kwargs={})</code> </dt> <dd>
<p>This constructor should always be called with keyword arguments. Arguments are:</p> <p><em>group</em> should be <code>None</code>; reserved for future extension when a <code>ThreadGroup</code> class is implemented.</p> <p><em>target</em> is the callable object to be invoked by the <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method. Defaults to <code>None</code>, meaning nothing is called.</p> <p><em>name</em> is the thread name. By default, a unique name is constructed of the form “Thread-<em>N</em>” where <em>N</em> is a small decimal number.</p> <p><em>args</em> is the argument tuple for the target invocation. Defaults to <code>()</code>.</p> <p><em>kwargs</em> is a dictionary of keyword arguments for the target invocation. Defaults to <code>{}</code>.</p> <p>If the subclass overrides the constructor, it must make sure to invoke the base class constructor (<code>Thread.__init__()</code>) before doing anything else to the thread.</p> <dl class="method"> <dt id="threading.Thread.start">
<code>start()</code> </dt> <dd>
<p>Start the thread’s activity.</p> <p>It must be called at most once per thread object. It arranges for the object’s <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method to be invoked in a separate thread of control.</p> <p>This method will raise a <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a> if called more than once on the same thread object.</p> </dd>
</dl> <dl class="method"> <dt id="threading.Thread.run">
<code>run()</code> </dt> <dd>
<p>Method representing the thread’s activity.</p> <p>You may override this method in a subclass. The standard <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method invokes the callable object passed to the object’s constructor as the <em>target</em> argument, if any, with sequential and keyword arguments taken from the <em>args</em> and <em>kwargs</em> arguments, respectively.</p> </dd>
</dl> <dl class="method"> <dt id="threading.Thread.join">
<code>join([timeout])</code> </dt> <dd>
<p>Wait until the thread terminates. This blocks the calling thread until the thread whose <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> method is called terminates – either normally or through an unhandled exception – or until the optional timeout occurs.</p> <p>When the <em>timeout</em> argument is present and not <code>None</code>, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> always returns <code>None</code>, you must call <a class="reference internal" href="#threading.Thread.isAlive" title="threading.Thread.isAlive"><code>isAlive()</code></a> after <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> to decide whether a timeout happened – if the thread is still alive, the <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> call timed out.</p> <p>When the <em>timeout</em> argument is not present or <code>None</code>, the operation will block until the thread terminates.</p> <p>A thread can be <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a>ed many times.</p> <p><a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> raises a <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a> if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to <a class="reference internal" href="#threading.Thread.join" title="threading.Thread.join"><code>join()</code></a> a thread before it has been started and attempts to do so raises the same exception.</p> </dd>
</dl> <dl class="attribute"> <dt id="threading.Thread.name">
<code>name</code> </dt> <dd>
<p>A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="threading.Thread.getName">
<code>getName()</code> </dt> <dt id="threading.Thread.setName">
<code>setName()</code> </dt> <dd>
<p>Pre-2.6 API for <a class="reference internal" href="#threading.Thread.name" title="threading.Thread.name"><code>name</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="threading.Thread.ident">
<code>ident</code> </dt> <dd>
<p>The ‘thread identifier’ of this thread or <code>None</code> if the thread has not been started. This is a nonzero integer. See the <a class="reference internal" href="thread#thread.get_ident" title="thread.get_ident"><code>thread.get_ident()</code></a> function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="threading.Thread.is_alive">
<code>is_alive()</code> </dt> <dt id="threading.Thread.isAlive">
<code>isAlive()</code> </dt> <dd>
<p>Return whether the thread is alive.</p> <p>This method returns <code>True</code> just before the <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method starts until just after the <a class="reference internal" href="#threading.Thread.run" title="threading.Thread.run"><code>run()</code></a> method terminates. The module function <a class="reference internal" href="#threading.enumerate" title="threading.enumerate"><code>enumerate()</code></a> returns a list of all alive threads.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span>Added <code>is_alive()</code> spelling.</p> </div> </dd>
</dl> <dl class="attribute"> <dt id="threading.Thread.daemon">
<code>daemon</code> </dt> <dd>
<p>A boolean value indicating whether this thread is a daemon thread (True) or not (False). This must be set before <a class="reference internal" href="#threading.Thread.start" title="threading.Thread.start"><code>start()</code></a> is called, otherwise <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a> is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to <a class="reference internal" href="#threading.Thread.daemon" title="threading.Thread.daemon"><code>daemon</code></a> = <code>False</code>.</p> <p>The entire Python program exits when no alive non-daemon threads are left.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="threading.Thread.isDaemon">
<code>isDaemon()</code> </dt> <dt id="threading.Thread.setDaemon">
<code>setDaemon()</code> </dt> <dd>
<p>Pre-2.6 API for <a class="reference internal" href="#threading.Thread.daemon" title="threading.Thread.daemon"><code>daemon</code></a>.</p> </dd>
</dl> </dd>
</dl>   <h2 id="id2">2. Lock Objects</h2> <p id="lock-objects">A primitive lock is a synchronization primitive that is not owned by a particular thread when locked. In Python, it is currently the lowest level synchronization primitive available, implemented directly by the <a class="reference internal" href="thread#module-thread" title="thread: Create multiple threads of control within one interpreter."><code>thread</code></a> extension module.</p> <p>A primitive lock is in one of two states, “locked” or “unlocked”. It is created in the unlocked state. It has two basic methods, <code>acquire()</code> and <code>release()</code>. When the state is unlocked, <code>acquire()</code> changes the state to locked and returns immediately. When the state is locked, <code>acquire()</code> blocks until a call to <code>release()</code> in another thread changes it to unlocked, then the <code>acquire()</code> call resets it to locked and returns. The <code>release()</code> method should only be called in the locked state; it changes the state to unlocked and returns immediately. If an attempt is made to release an unlocked lock, a <a class="reference internal" href="#threading.ThreadError" title="threading.ThreadError"><code>ThreadError</code></a> will be raised.</p> <p>When more than one thread is blocked in <code>acquire()</code> waiting for the state to turn to unlocked, only one thread proceeds when a <code>release()</code> call resets the state to unlocked; which one of the waiting threads proceeds is not defined, and may vary across implementations.</p> <p>All methods are executed atomically.</p> <dl class="method"> <dt id="threading.Lock.acquire">
<code>Lock.acquire([blocking])</code> </dt> <dd>
<p>Acquire a lock, blocking or non-blocking.</p> <p>When invoked with the <em>blocking</em> argument set to <code>True</code> (the default), block until the lock is unlocked, then set it to locked and return <code>True</code>.</p> <p>When invoked with the <em>blocking</em> argument set to <code>False</code>, do not block. If a call with <em>blocking</em> set to <code>True</code> would block, return <code>False</code> immediately; otherwise, set the lock to locked and return <code>True</code>.</p> </dd>
</dl> <dl class="method"> <dt id="threading.Lock.release">
<code>Lock.release()</code> </dt> <dd>
<p>Release a lock.</p> <p>When the lock is locked, reset it to unlocked, and return. If any other threads are blocked waiting for the lock to become unlocked, allow exactly one of them to proceed.</p> <p>When invoked on an unlocked lock, a <a class="reference internal" href="#threading.ThreadError" title="threading.ThreadError"><code>ThreadError</code></a> is raised.</p> <p>There is no return value.</p> </dd>
</dl>   <h2 id="id3">3. RLock Objects</h2> <p id="rlock-objects">A reentrant lock is a synchronization primitive that may be acquired multiple times by the same thread. Internally, it uses the concepts of “owning thread” and “recursion level” in addition to the locked/unlocked state used by primitive locks. In the locked state, some thread owns the lock; in the unlocked state, no thread owns it.</p> <p>To lock the lock, a thread calls its <code>acquire()</code> method; this returns once the thread owns the lock. To unlock the lock, a thread calls its <code>release()</code> method. <code>acquire()</code>/<code>release()</code> call pairs may be nested; only the final <code>release()</code> (the <code>release()</code> of the outermost pair) resets the lock to unlocked and allows another thread blocked in <code>acquire()</code> to proceed.</p> <dl class="method"> <dt id="threading.RLock.acquire">
<code>RLock.acquire([blocking=1])</code> </dt> <dd>
<p>Acquire a lock, blocking or non-blocking.</p> <p>When invoked without arguments: if this thread already owns the lock, increment the recursion level by one, and return immediately. Otherwise, if another thread owns the lock, block until the lock is unlocked. Once the lock is unlocked (not owned by any thread), then grab ownership, set the recursion level to one, and return. If more than one thread is blocked waiting until the lock is unlocked, only one at a time will be able to grab ownership of the lock. There is no return value in this case.</p> <p>When invoked with the <em>blocking</em> argument set to true, do the same thing as when called without arguments, and return true.</p> <p>When invoked with the <em>blocking</em> argument set to false, do not block. If a call without an argument would block, return false immediately; otherwise, do the same thing as when called without arguments, and return true.</p> </dd>
</dl> <dl class="method"> <dt id="threading.RLock.release">
<code>RLock.release()</code> </dt> <dd>
<p>Release a lock, decrementing the recursion level. If after the decrement it is zero, reset the lock to unlocked (not owned by any thread), and if any other threads are blocked waiting for the lock to become unlocked, allow exactly one of them to proceed. If after the decrement the recursion level is still nonzero, the lock remains locked and owned by the calling thread.</p> <p>Only call this method when the calling thread owns the lock. A <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a> is raised if this method is called when the lock is unlocked.</p> <p>There is no return value.</p> </dd>
</dl>   <h2 id="id4">4. Condition Objects</h2> <p id="condition-objects">A condition variable is always associated with some kind of lock; this can be passed in or one will be created by default. (Passing one in is useful when several condition variables must share the same lock.)</p> <p>A condition variable has <code>acquire()</code> and <code>release()</code> methods that call the corresponding methods of the associated lock. It also has a <code>wait()</code> method, and <code>notify()</code> and <code>notifyAll()</code> methods. These three must only be called when the calling thread has acquired the lock, otherwise a <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a> is raised.</p> <p>The <code>wait()</code> method releases the lock, and then blocks until it is awakened by a <code>notify()</code> or <code>notifyAll()</code> call for the same condition variable in another thread. Once awakened, it re-acquires the lock and returns. It is also possible to specify a timeout.</p> <p>The <code>notify()</code> method wakes up one of the threads waiting for the condition variable, if any are waiting. The <code>notifyAll()</code> method wakes up all threads waiting for the condition variable.</p> <p>Note: the <code>notify()</code> and <code>notifyAll()</code> methods don’t release the lock; this means that the thread or threads awakened will not return from their <code>wait()</code> call immediately, but only when the thread that called <code>notify()</code> or <code>notifyAll()</code> finally relinquishes ownership of the lock.</p> <p>Tip: the typical programming style using condition variables uses the lock to synchronize access to some shared state; threads that are interested in a particular change of state call <code>wait()</code> repeatedly until they see the desired state, while threads that modify the state call <code>notify()</code> or <code>notifyAll()</code> when they change the state in such a way that it could possibly be a desired state for one of the waiters. For example, the following code is a generic producer-consumer situation with unlimited buffer capacity:</p> <pre data-language="python"># Consume one item
cv.acquire()
while not an_item_is_available():
    cv.wait()
get_an_available_item()
cv.release()

# Produce one item
cv.acquire()
make_an_item_available()
cv.notify()
cv.release()
</pre> <p>To choose between <code>notify()</code> and <code>notifyAll()</code>, consider whether one state change can be interesting for only one or several waiting threads. E.g. in a typical producer-consumer situation, adding one item to the buffer only needs to wake up one consumer thread.</p> <dl class="class"> <dt id="threading.Condition">
<code>class threading.Condition([lock])</code> </dt> <dd>
<p>If the <em>lock</em> argument is given and not <code>None</code>, it must be a <a class="reference internal" href="#threading.Lock" title="threading.Lock"><code>Lock</code></a> or <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code>RLock</code></a> object, and it is used as the underlying lock. Otherwise, a new <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code>RLock</code></a> object is created and used as the underlying lock.</p> <dl class="method"> <dt id="threading.Condition.acquire">
<code>acquire(*args)</code> </dt> <dd>
<p>Acquire the underlying lock. This method calls the corresponding method on the underlying lock; the return value is whatever that method returns.</p> </dd>
</dl> <dl class="method"> <dt id="threading.Condition.release">
<code>release()</code> </dt> <dd>
<p>Release the underlying lock. This method calls the corresponding method on the underlying lock; there is no return value.</p> </dd>
</dl> <dl class="method"> <dt id="threading.Condition.wait">
<code>wait([timeout])</code> </dt> <dd>
<p>Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a> is raised.</p> <p>This method releases the underlying lock, and then blocks until it is awakened by a <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code>notify()</code></a> or <a class="reference internal" href="#threading.Condition.notifyAll" title="threading.Condition.notifyAll"><code>notifyAll()</code></a> call for the same condition variable in another thread, or until the optional timeout occurs. Once awakened or timed out, it re-acquires the lock and returns.</p> <p>When the <em>timeout</em> argument is present and not <code>None</code>, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof).</p> <p>When the underlying lock is an <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code>RLock</code></a>, it is not released using its <a class="reference internal" href="#threading.Condition.release" title="threading.Condition.release"><code>release()</code></a> method, since this may not actually unlock the lock when it was acquired multiple times recursively. Instead, an internal interface of the <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code>RLock</code></a> class is used, which really unlocks it even when it has been recursively acquired several times. Another internal interface is then used to restore the recursion level when the lock is reacquired.</p> </dd>
</dl> <dl class="method"> <dt id="threading.Condition.notify">
<code>notify(n=1)</code> </dt> <dd>
<p>By default, wake up one thread waiting on this condition, if any. If the calling thread has not acquired the lock when this method is called, a <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a> is raised.</p> <p>This method wakes up at most <em>n</em> of the threads waiting for the condition variable; it is a no-op if no threads are waiting.</p> <p>The current implementation wakes up exactly <em>n</em> threads, if at least <em>n</em> threads are waiting. However, it’s not safe to rely on this behavior. A future, optimized implementation may occasionally wake up more than <em>n</em> threads.</p> <p>Note: an awakened thread does not actually return from its <a class="reference internal" href="#threading.Condition.wait" title="threading.Condition.wait"><code>wait()</code></a> call until it can reacquire the lock. Since <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code>notify()</code></a> does not release the lock, its caller should.</p> </dd>
</dl> <dl class="method"> <dt id="threading.Condition.notify_all">
<code>notify_all()</code> </dt> <dt id="threading.Condition.notifyAll">
<code>notifyAll()</code> </dt> <dd>
<p>Wake up all threads waiting on this condition. This method acts like <a class="reference internal" href="#threading.Condition.notify" title="threading.Condition.notify"><code>notify()</code></a>, but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a> is raised.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span>Added <code>notify_all()</code> spelling.</p> </div> </dd>
</dl> </dd>
</dl>   <h2 id="id5">5. Semaphore Objects</h2> <p id="semaphore-objects">This is one of the oldest synchronization primitives in the history of computer science, invented by the early Dutch computer scientist Edsger W. Dijkstra (he used <code>P()</code> and <code>V()</code> instead of <code>acquire()</code> and <code>release()</code>).</p> <p>A semaphore manages an internal counter which is decremented by each <code>acquire()</code> call and incremented by each <code>release()</code> call. The counter can never go below zero; when <code>acquire()</code> finds that it is zero, it blocks, waiting until some other thread calls <code>release()</code>.</p> <dl class="class"> <dt id="threading.Semaphore">
<code>class threading.Semaphore([value])</code> </dt> <dd>
<p>The optional argument gives the initial <em>value</em> for the internal counter; it defaults to <code>1</code>. If the <em>value</em> given is less than 0, <a class="reference internal" href="exceptions#exceptions.ValueError" title="exceptions.ValueError"><code>ValueError</code></a> is raised.</p> <dl class="method"> <dt id="threading.Semaphore.acquire">
<code>acquire([blocking])</code> </dt> <dd>
<p>Acquire a semaphore.</p> <p>When invoked without arguments: if the internal counter is larger than zero on entry, decrement it by one and return immediately. If it is zero on entry, block, waiting until some other thread has called <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code>release()</code></a> to make it larger than zero. This is done with proper interlocking so that if multiple <a class="reference internal" href="#threading.Semaphore.acquire" title="threading.Semaphore.acquire"><code>acquire()</code></a> calls are blocked, <a class="reference internal" href="#threading.Semaphore.release" title="threading.Semaphore.release"><code>release()</code></a> will wake exactly one of them up. The implementation may pick one at random, so the order in which blocked threads are awakened should not be relied on. There is no return value in this case.</p> <p>When invoked with <em>blocking</em> set to true, do the same thing as when called without arguments, and return true.</p> <p>When invoked with <em>blocking</em> set to false, do not block. If a call without an argument would block, return false immediately; otherwise, do the same thing as when called without arguments, and return true.</p> </dd>
</dl> <dl class="method"> <dt id="threading.Semaphore.release">
<code>release()</code> </dt> <dd>
<p>Release a semaphore, incrementing the internal counter by one. When it was zero on entry and another thread is waiting for it to become larger than zero again, wake up that thread.</p> </dd>
</dl> </dd>
</dl>  <h3 id="semaphore-examples">5.1. <a class="reference internal" href="#threading.Semaphore" title="threading.Semaphore"><code>Semaphore</code></a> Example</h3> <p id="semaphore-example">Semaphores are often used to guard resources with limited capacity, for example, a database server. In any situation where the size of the resource is fixed, you should use a bounded semaphore. Before spawning any worker threads, your main thread would initialize the semaphore:</p> <pre data-language="python">maxconnections = 5
...
pool_sema = BoundedSemaphore(value=maxconnections)
</pre> <p>Once spawned, worker threads call the semaphore’s acquire and release methods when they need to connect to the server:</p> <pre data-language="python">pool_sema.acquire()
conn = connectdb()
... use connection ...
conn.close()
pool_sema.release()
</pre> <p>The use of a bounded semaphore reduces the chance that a programming error which causes the semaphore to be released more than it’s acquired will go undetected.</p>    <h2 id="id6">6. Event Objects</h2> <p id="event-objects">This is one of the simplest mechanisms for communication between threads: one thread signals an event and other threads wait for it.</p> <p>An event object manages an internal flag that can be set to true with the <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code>set()</code></a> method and reset to false with the <a class="reference internal" href="#threading.Event.clear" title="threading.Event.clear"><code>clear()</code></a> method. The <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code>wait()</code></a> method blocks until the flag is true.</p> <dl class="class"> <dt id="threading.Event">
<code>class threading.Event</code> </dt> <dd>
<p>The internal flag is initially false.</p> <dl class="method"> <dt id="threading.Event.is_set">
<code>is_set()</code> </dt> <dt id="threading.Event.isSet">
<code>isSet()</code> </dt> <dd>
<p>Return true if and only if the internal flag is true.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span>Added <code>is_set()</code> spelling.</p> </div> </dd>
</dl> <dl class="method"> <dt id="threading.Event.set">
<code>set()</code> </dt> <dd>
<p>Set the internal flag to true. All threads waiting for it to become true are awakened. Threads that call <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code>wait()</code></a> once the flag is true will not block at all.</p> </dd>
</dl> <dl class="method"> <dt id="threading.Event.clear">
<code>clear()</code> </dt> <dd>
<p>Reset the internal flag to false. Subsequently, threads calling <a class="reference internal" href="#threading.Event.wait" title="threading.Event.wait"><code>wait()</code></a> will block until <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code>set()</code></a> is called to set the internal flag to true again.</p> </dd>
</dl> <dl class="method"> <dt id="threading.Event.wait">
<code>wait([timeout])</code> </dt> <dd>
<p>Block until the internal flag is true. If the internal flag is true on entry, return immediately. Otherwise, block until another thread calls <a class="reference internal" href="#threading.Event.set" title="threading.Event.set"><code>set()</code></a> to set the flag to true, or until the optional timeout occurs.</p> <p>When the timeout argument is present and not <code>None</code>, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof).</p> <p>This method returns the internal flag on exit, so it will always return <code>True</code> except if a timeout is given and the operation times out.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>Previously, the method always returned <code>None</code>.</p> </div> </dd>
</dl> </dd>
</dl>   <h2 id="id7">7. Timer Objects</h2> <p id="timer-objects">This class represents an action that should be run only after a certain amount of time has passed — a timer. <a class="reference internal" href="#threading.Timer" title="threading.Timer"><code>Timer</code></a> is a subclass of <a class="reference internal" href="#threading.Thread" title="threading.Thread"><code>Thread</code></a> and as such also functions as an example of creating custom threads.</p> <p>Timers are started, as with threads, by calling their <code>start()</code> method. The timer can be stopped (before its action has begun) by calling the <a class="reference internal" href="#threading.Timer.cancel" title="threading.Timer.cancel"><code>cancel()</code></a> method. The interval the timer will wait before executing its action may not be exactly the same as the interval specified by the user.</p> <p>For example:</p> <pre data-language="python">def hello():
    print "hello, world"

t = Timer(30.0, hello)
t.start()  # after 30 seconds, "hello, world" will be printed
</pre> <dl class="class"> <dt id="threading.Timer">
<code>class threading.Timer(interval, function, args=[], kwargs={})</code> </dt> <dd>
<p>Create a timer that will run <em>function</em> with arguments <em>args</em> and keyword arguments <em>kwargs</em>, after <em>interval</em> seconds have passed.</p> <dl class="method"> <dt id="threading.Timer.cancel">
<code>cancel()</code> </dt> <dd>
<p>Stop the timer, and cancel the execution of the timer’s action. This will only work if the timer is still in its waiting stage.</p> </dd>
</dl> </dd>
</dl>   <h2 id="with-locks">8. Using locks, conditions, and semaphores in the with statement</h2> <p id="using-locks-conditions-and-semaphores-in-the-with-statement">All of the objects provided by this module that have <code>acquire()</code> and <code>release()</code> methods can be used as context managers for a <a class="reference internal" href="https://docs.python.org/2.7/reference/compound_stmts.html#with"><code>with</code></a> statement. The <code>acquire()</code> method will be called when the block is entered, and <code>release()</code> will be called when the block is exited.</p> <p>Currently, <a class="reference internal" href="#threading.Lock" title="threading.Lock"><code>Lock</code></a>, <a class="reference internal" href="#threading.RLock" title="threading.RLock"><code>RLock</code></a>, <a class="reference internal" href="#threading.Condition" title="threading.Condition"><code>Condition</code></a>, <a class="reference internal" href="#threading.Semaphore" title="threading.Semaphore"><code>Semaphore</code></a>, and <a class="reference internal" href="#threading.BoundedSemaphore" title="threading.BoundedSemaphore"><code>BoundedSemaphore</code></a> objects may be used as <a class="reference internal" href="https://docs.python.org/2.7/reference/compound_stmts.html#with"><code>with</code></a> statement context managers. For example:</p> <pre data-language="python">import threading

some_rlock = threading.RLock()

with some_rlock:
    print "some_rlock is locked while this executes"
</pre>   <h2 id="threaded-imports">9. Importing in threaded code</h2> <p id="importing-in-threaded-code">While the import machinery is thread-safe, there are two key restrictions on threaded imports due to inherent limitations in the way that thread-safety is provided:</p> <ul class="simple"> <li>Firstly, other than in the main module, an import should not have the side effect of spawning a new thread and then waiting for that thread in any way. Failing to abide by this restriction can lead to a deadlock if the spawned thread directly or indirectly attempts to import a module.</li> <li>Secondly, all import attempts must be completed before the interpreter starts shutting itself down. This can be most easily achieved by only performing imports from non-daemon threads created through the threading module. Daemon threads and threads created directly with the thread module will require some other form of synchronization to ensure they do not attempt imports after system shutdown has commenced. Failure to abide by this restriction will lead to intermittent exceptions and crashes during interpreter shutdown (as the late imports attempt to access machinery which is no longer in a valid state).</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/threading.html" class="_attribution-link">https://docs.python.org/2.7/library/threading.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
