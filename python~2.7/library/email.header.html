
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>email.header&#58; Internationalized Headers - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content="RFC 2822 is the base standard that describes the format of email messages. It derives from the older RFC 822 standard which came into widespread use &hellip;">
  <meta name="keywords" content="email, header, internationalized, headers, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/email.header.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/python~2.7.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="email-header-internationalized-headers"> email.header: Internationalized headers</h1> <p id="module-email.header"><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-0"><strong>RFC 2822</strong></a> is the base standard that describes the format of email messages. It derives from the older <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html" id="index-1"><strong>RFC 822</strong></a> standard which came into widespread use at a time when most email was composed of ASCII characters only. <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-2"><strong>RFC 2822</strong></a> is a specification written assuming email contains only 7-bit ASCII characters.</p> <p>Of course, as email has been deployed worldwide, it has become internationalized, such that language specific character sets can now be used in email messages. The base standard still requires email messages to be transferred using only 7-bit ASCII characters, so a slew of RFCs have been written describing how to encode email containing non-ASCII characters into <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-3"><strong>RFC 2822</strong></a>-compliant format. These RFCs include <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html" id="index-4"><strong>RFC 2045</strong></a>, <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2046.html" id="index-5"><strong>RFC 2046</strong></a>, <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html" id="index-6"><strong>RFC 2047</strong></a>, and <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2231.html" id="index-7"><strong>RFC 2231</strong></a>. The <a class="reference internal" href="email#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages, including MIME documents."><code>email</code></a> package supports these standards in its <a class="reference internal" href="#module-email.header" title="email.header: Representing non-ASCII headers"><code>email.header</code></a> and <a class="reference internal" href="email.charset#module-email.charset" title="email.charset: Character Sets"><code>email.charset</code></a> modules.</p> <p>If you want to include non-ASCII characters in your email headers, say in the <em class="mailheader">Subject</em> or <em class="mailheader">To</em> fields, you should use the <a class="reference internal" href="#email.header.Header" title="email.header.Header"><code>Header</code></a> class and assign the field in the <a class="reference internal" href="email.message#email.message.Message" title="email.message.Message"><code>Message</code></a> object to an instance of <a class="reference internal" href="#email.header.Header" title="email.header.Header"><code>Header</code></a> instead of using a string for the header value. Import the <a class="reference internal" href="#email.header.Header" title="email.header.Header"><code>Header</code></a> class from the <a class="reference internal" href="#module-email.header" title="email.header: Representing non-ASCII headers"><code>email.header</code></a> module. For example:</p> <pre data-language="python">&gt;&gt;&gt; from email.message import Message
&gt;&gt;&gt; from email.header import Header
&gt;&gt;&gt; msg = Message()
&gt;&gt;&gt; h = Header('p\xf6stal', 'iso-8859-1')
&gt;&gt;&gt; msg['Subject'] = h
&gt;&gt;&gt; print msg.as_string()
Subject: =?iso-8859-1?q?p=F6stal?=
</pre> <p>Notice here how we wanted the <em class="mailheader">Subject</em> field to contain a non-ASCII character? We did this by creating a <a class="reference internal" href="#email.header.Header" title="email.header.Header"><code>Header</code></a> instance and passing in the character set that the byte string was encoded in. When the subsequent <a class="reference internal" href="email.message#email.message.Message" title="email.message.Message"><code>Message</code></a> instance was flattened, the <em class="mailheader">Subject</em> field was properly <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html" id="index-8"><strong>RFC 2047</strong></a> encoded. MIME-aware mail readers would show this header using the embedded ISO-8859-1 character.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.2.2.</span></p> </div> <p>Here is the <a class="reference internal" href="#email.header.Header" title="email.header.Header"><code>Header</code></a> class description:</p> <dl class="class"> <dt id="email.header.Header">
<code>class email.header.Header([s[, charset[, maxlinelen[, header_name[, continuation_ws[, errors]]]]]])</code> </dt> <dd>
<p>Create a MIME-compliant header that can contain strings in different character sets.</p> <p>Optional <em>s</em> is the initial header value. If <code>None</code> (the default), the initial header value is not set. You can later append to the header with <a class="reference internal" href="#email.header.Header.append" title="email.header.Header.append"><code>append()</code></a> method calls. <em>s</em> may be a byte string or a Unicode string, but see the <a class="reference internal" href="#email.header.Header.append" title="email.header.Header.append"><code>append()</code></a> documentation for semantics.</p> <p>Optional <em>charset</em> serves two purposes: it has the same meaning as the <em>charset</em> argument to the <a class="reference internal" href="#email.header.Header.append" title="email.header.Header.append"><code>append()</code></a> method. It also sets the default character set for all subsequent <a class="reference internal" href="#email.header.Header.append" title="email.header.Header.append"><code>append()</code></a> calls that omit the <em>charset</em> argument. If <em>charset</em> is not provided in the constructor (the default), the <code>us-ascii</code> character set is used both as <em>s</em>’s initial charset and as the default for subsequent <a class="reference internal" href="#email.header.Header.append" title="email.header.Header.append"><code>append()</code></a> calls.</p> <p>The maximum line length can be specified explicitly via <em>maxlinelen</em>. For splitting the first line to a shorter value (to account for the field header which isn’t included in <em>s</em>, e.g. <em class="mailheader">Subject</em>) pass in the name of the field in <em>header_name</em>. The default <em>maxlinelen</em> is 76, and the default value for <em>header_name</em> is <code>None</code>, meaning it is not taken into account for the first line of a long, split header.</p> <p>Optional <em>continuation_ws</em> must be <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-9"><strong>RFC 2822</strong></a>-compliant folding whitespace, and is usually either a space or a hard tab character. This character will be prepended to continuation lines. <em>continuation_ws</em> defaults to a single space character (” “).</p> <p>Optional <em>errors</em> is passed straight through to the <a class="reference internal" href="#email.header.Header.append" title="email.header.Header.append"><code>append()</code></a> method.</p> <dl class="method"> <dt id="email.header.Header.append">
<code>append(s[, charset[, errors]])</code> </dt> <dd>
<p>Append the string <em>s</em> to the MIME header.</p> <p>Optional <em>charset</em>, if given, should be a <a class="reference internal" href="email.charset#email.charset.Charset" title="email.charset.Charset"><code>Charset</code></a> instance (see <a class="reference internal" href="email.charset#module-email.charset" title="email.charset: Character Sets"><code>email.charset</code></a>) or the name of a character set, which will be converted to a <a class="reference internal" href="email.charset#email.charset.Charset" title="email.charset.Charset"><code>Charset</code></a> instance. A value of <code>None</code> (the default) means that the <em>charset</em> given in the constructor is used.</p> <p><em>s</em> may be a byte string or a Unicode string. If it is a byte string (i.e. <code>isinstance(s, str)</code> is true), then <em>charset</em> is the encoding of that byte string, and a <a class="reference internal" href="exceptions#exceptions.UnicodeError" title="exceptions.UnicodeError"><code>UnicodeError</code></a> will be raised if the string cannot be decoded with that character set.</p> <p>If <em>s</em> is a Unicode string, then <em>charset</em> is a hint specifying the character set of the characters in the string. In this case, when producing an <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-10"><strong>RFC 2822</strong></a>-compliant header using <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html" id="index-11"><strong>RFC 2047</strong></a> rules, the Unicode string will be encoded using the following charsets in order: <code>us-ascii</code>, the <em>charset</em> hint, <code>utf-8</code>. The first character set to not provoke a <a class="reference internal" href="exceptions#exceptions.UnicodeError" title="exceptions.UnicodeError"><code>UnicodeError</code></a> is used.</p> <p>Optional <em>errors</em> is passed through to any <a class="reference internal" href="functions#unicode" title="unicode"><code>unicode()</code></a> or <code>unicode.encode()</code> call, and defaults to “strict”.</p> </dd>
</dl> <dl class="method"> <dt id="email.header.Header.encode">
<code>encode([splitchars])</code> </dt> <dd>
<p>Encode a message header into an RFC-compliant format, possibly wrapping long lines and encapsulating non-ASCII parts in base64 or quoted-printable encodings. Optional <em>splitchars</em> is a string containing characters to split long ASCII lines on, in rough support of <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-12"><strong>RFC 2822</strong></a>’s <em>highest level syntactic breaks</em>. This doesn’t affect <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html" id="index-13"><strong>RFC 2047</strong></a> encoded lines.</p> </dd>
</dl> <p>The <a class="reference internal" href="#email.header.Header" title="email.header.Header"><code>Header</code></a> class also provides a number of methods to support standard operators and built-in functions.</p> <dl class="method"> <dt id="email.header.Header.__str__">
<code>__str__()</code> </dt> <dd>
<p>A synonym for <a class="reference internal" href="#email.header.Header.encode" title="email.header.Header.encode"><code>Header.encode()</code></a>. Useful for <code>str(aHeader)</code>.</p> </dd>
</dl> <dl class="method"> <dt id="email.header.Header.__unicode__">
<code>__unicode__()</code> </dt> <dd>
<p>A helper for the built-in <a class="reference internal" href="functions#unicode" title="unicode"><code>unicode()</code></a> function. Returns the header as a Unicode string.</p> </dd>
</dl> <dl class="method"> <dt id="email.header.Header.__eq__">
<code>__eq__(other)</code> </dt> <dd>
<p>This method allows you to compare two <a class="reference internal" href="#email.header.Header" title="email.header.Header"><code>Header</code></a> instances for equality.</p> </dd>
</dl> <dl class="method"> <dt id="email.header.Header.__ne__">
<code>__ne__(other)</code> </dt> <dd>
<p>This method allows you to compare two <a class="reference internal" href="#email.header.Header" title="email.header.Header"><code>Header</code></a> instances for inequality.</p> </dd>
</dl> </dd>
</dl> <p>The <a class="reference internal" href="#module-email.header" title="email.header: Representing non-ASCII headers"><code>email.header</code></a> module also provides the following convenient functions.</p> <dl class="function"> <dt id="email.header.decode_header">
<code>email.header.decode_header(header)</code> </dt> <dd>
<p>Decode a message header value without converting the character set. The header value is in <em>header</em>.</p> <p>This function returns a list of <code>(decoded_string, charset)</code> pairs containing each of the decoded parts of the header. <em>charset</em> is <code>None</code> for non-encoded parts of the header, otherwise a lower case string containing the name of the character set specified in the encoded string.</p> <p>Here’s an example:</p> <pre data-language="python">&gt;&gt;&gt; from email.header import decode_header
&gt;&gt;&gt; decode_header('=?iso-8859-1?q?p=F6stal?=')
[('p\xf6stal', 'iso-8859-1')]
</pre> </dd>
</dl> <dl class="function"> <dt id="email.header.make_header">
<code>email.header.make_header(decoded_seq[, maxlinelen[, header_name[, continuation_ws]]])</code> </dt> <dd>
<p>Create a <a class="reference internal" href="#email.header.Header" title="email.header.Header"><code>Header</code></a> instance from a sequence of pairs as returned by <a class="reference internal" href="#email.header.decode_header" title="email.header.decode_header"><code>decode_header()</code></a>.</p> <p><a class="reference internal" href="#email.header.decode_header" title="email.header.decode_header"><code>decode_header()</code></a> takes a header value string and returns a sequence of pairs of the format <code>(decoded_string, charset)</code> where <em>charset</em> is the name of the character set.</p> <p>This function takes one of those sequence of pairs and returns a <a class="reference internal" href="#email.header.Header" title="email.header.Header"><code>Header</code></a> instance. Optional <em>maxlinelen</em>, <em>header_name</em>, and <em>continuation_ws</em> are as in the <a class="reference internal" href="#email.header.Header" title="email.header.Header"><code>Header</code></a> constructor.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/email.header.html" class="_attribution-link">https://docs.python.org/2.7/library/email.header.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
