
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Itertools - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" New in version 2.3. ">
  <meta name="keywords" content="itertools, —, functions, creating, iterators, for, efficient, looping, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/itertools.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/python~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="itertools-functions-creating-iterators-for-efficient-looping"> itertools — Functions creating iterators for efficient looping</h1> <div class="versionadded" id="module-itertools"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> <p>This module implements a number of <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> building blocks inspired by constructs from APL, Haskell, and SML. Each has been recast in a form suitable for Python.</p> <p>The module standardizes a core set of fast, memory efficient tools that are useful by themselves or in combination. Together, they form an “iterator algebra” making it possible to construct specialized tools succinctly and efficiently in pure Python.</p> <p>For instance, SML provides a tabulation tool: <code>tabulate(f)</code> which produces a sequence <code>f(0), f(1), ...</code>. The same effect can be achieved in Python by combining <a class="reference internal" href="#itertools.imap" title="itertools.imap"><code>imap()</code></a> and <a class="reference internal" href="#itertools.count" title="itertools.count"><code>count()</code></a> to form <code>imap(f, count())</code>.</p> <p>These tools and their built-in counterparts also work well with the high-speed functions in the <a class="reference internal" href="operator#module-operator" title="operator: Functions corresponding to the standard operators."><code>operator</code></a> module. For example, the multiplication operator can be mapped across two vectors to form an efficient dot-product: <code>sum(imap(operator.mul, vector1, vector2))</code>.</p> <p><strong>Infinite Iterators:</strong></p> <table class="docutils align-center">  <thead> <tr>
<th class="head"><p>Iterator</p></th> <th class="head"><p>Arguments</p></th> <th class="head"><p>Results</p></th> <th class="head"><p>Example</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#itertools.count" title="itertools.count"><code>count()</code></a></p></td> <td><p>start, [step]</p></td> <td><p>start, start+step, start+2*step, …</p></td> <td><p><code>count(10) --&gt; 10 11 12 13 14 ...</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.cycle" title="itertools.cycle"><code>cycle()</code></a></p></td> <td><p>p</p></td> <td><p>p0, p1, … plast, p0, p1, …</p></td> <td><p><code>cycle('ABCD') --&gt; A B C D A B C D ...</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.repeat" title="itertools.repeat"><code>repeat()</code></a></p></td> <td><p>elem [,n]</p></td> <td><p>elem, elem, elem, … endlessly or up to n times</p></td> <td><p><code>repeat(10, 3) --&gt; 10 10 10</code></p></td> </tr>  </table> <p><strong>Iterators terminating on the shortest input sequence:</strong></p> <table class="docutils align-center">  <thead> <tr>
<th class="head"><p>Iterator</p></th> <th class="head"><p>Arguments</p></th> <th class="head"><p>Results</p></th> <th class="head"><p>Example</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#itertools.chain" title="itertools.chain"><code>chain()</code></a></p></td> <td><p>p, q, …</p></td> <td><p>p0, p1, … plast, q0, q1, …</p></td> <td><p><code>chain('ABC', 'DEF') --&gt; A B C D E F</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.compress" title="itertools.compress"><code>compress()</code></a></p></td> <td><p>data, selectors</p></td> <td><p>(d[0] if s[0]), (d[1] if s[1]), …</p></td> <td><p><code>compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.dropwhile" title="itertools.dropwhile"><code>dropwhile()</code></a></p></td> <td><p>pred, seq</p></td> <td><p>seq[n], seq[n+1], starting when pred fails</p></td> <td><p><code>dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code>groupby()</code></a></p></td> <td><p>iterable[, keyfunc]</p></td> <td><p>sub-iterators grouped by value of keyfunc(v)</p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.ifilter" title="itertools.ifilter"><code>ifilter()</code></a></p></td> <td><p>pred, seq</p></td> <td><p>elements of seq where pred(elem) is true</p></td> <td><p><code>ifilter(lambda x: x%2, range(10)) --&gt; 1 3 5 7 9</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.ifilterfalse" title="itertools.ifilterfalse"><code>ifilterfalse()</code></a></p></td> <td><p>pred, seq</p></td> <td><p>elements of seq where pred(elem) is false</p></td> <td><p><code>ifilterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.islice" title="itertools.islice"><code>islice()</code></a></p></td> <td><p>seq, [start,] stop [, step]</p></td> <td><p>elements from seq[start:stop:step]</p></td> <td><p><code>islice('ABCDEFG', 2, None) --&gt; C D E F G</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.imap" title="itertools.imap"><code>imap()</code></a></p></td> <td><p>func, p, q, …</p></td> <td><p>func(p0, q0), func(p1, q1), …</p></td> <td><p><code>imap(pow, (2,3,10), (5,2,3)) --&gt; 32 9 1000</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.starmap" title="itertools.starmap"><code>starmap()</code></a></p></td> <td><p>func, seq</p></td> <td><p>func(*seq[0]), func(*seq[1]), …</p></td> <td><p><code>starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.tee" title="itertools.tee"><code>tee()</code></a></p></td> <td><p>it, n</p></td> <td><p>it1, it2, … itn splits one iterator into n</p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.takewhile" title="itertools.takewhile"><code>takewhile()</code></a></p></td> <td><p>pred, seq</p></td> <td><p>seq[0], seq[1], until pred fails</p></td> <td><p><code>takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.izip" title="itertools.izip"><code>izip()</code></a></p></td> <td><p>p, q, …</p></td> <td><p>(p[0], q[0]), (p[1], q[1]), …</p></td> <td><p><code>izip('ABCD', 'xy') --&gt; Ax By</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.izip_longest" title="itertools.izip_longest"><code>izip_longest()</code></a></p></td> <td><p>p, q, …</p></td> <td><p>(p[0], q[0]), (p[1], q[1]), …</p></td> <td><p><code>izip_longest('ABCD', 'xy', fillvalue='-') --&gt; Ax By C- D-</code></p></td> </tr>  </table> <p><strong>Combinatoric generators:</strong></p> <table class="docutils align-center">  <thead> <tr>
<th class="head"><p>Iterator</p></th> <th class="head"><p>Arguments</p></th> <th class="head"><p>Results</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#itertools.product" title="itertools.product"><code>product()</code></a></p></td> <td><p>p, q, … [repeat=1]</p></td> <td><p>cartesian product, equivalent to a nested for-loop</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.permutations" title="itertools.permutations"><code>permutations()</code></a></p></td> <td><p>p[, r]</p></td> <td><p>r-length tuples, all possible orderings, no repeated elements</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.combinations" title="itertools.combinations"><code>combinations()</code></a></p></td> <td><p>p, r</p></td> <td><p>r-length tuples, in sorted order, no repeated elements</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#itertools.combinations_with_replacement" title="itertools.combinations_with_replacement"><code>combinations_with_replacement()</code></a></p></td> <td><p>p, r</p></td> <td><p>r-length tuples, in sorted order, with repeated elements</p></td> </tr> <tr>
<td><p><code>product('ABCD', repeat=2)</code></p></td> <td></td> <td><p><code>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD</code></p></td> </tr> <tr>
<td><p><code>permutations('ABCD', 2)</code></p></td> <td></td> <td><p><code>AB AC AD BA BC BD CA CB CD DA DB DC</code></p></td> </tr> <tr>
<td><p><code>combinations('ABCD', 2)</code></p></td> <td></td> <td><p><code>AB AC AD BC BD CD</code></p></td> </tr> <tr>
<td><p><code>combinations_with_replacement('ABCD', 2)</code></p></td> <td></td> <td><p><code>AA AB AC AD BB BC BD CC CD DD</code></p></td> </tr>  </table>  <h2 id="itertools-functions">1. Itertool functions</h2> <p id="itertool-functions">The following module functions all construct and return iterators. Some provide streams of infinite length, so they should only be accessed by functions or loops that truncate the stream.</p> <dl class="function"> <dt id="itertools.chain">
<code>itertools.chain(*iterables)</code> </dt> <dd>
<p>Make an iterator that returns elements from the first iterable until it is exhausted, then proceeds to the next iterable, until all of the iterables are exhausted. Used for treating consecutive sequences as a single sequence. Roughly equivalent to:</p> <pre data-language="python">def chain(*iterables):
    # chain('ABC', 'DEF') --&gt; A B C D E F
    for it in iterables:
        for element in it:
            yield element
</pre> </dd>
</dl> <dl class="classmethod"> <dt id="itertools.chain.from_iterable">
<code>classmethod chain.from_iterable(iterable)</code> </dt> <dd>
<p>Alternate constructor for <a class="reference internal" href="#itertools.chain" title="itertools.chain"><code>chain()</code></a>. Gets chained inputs from a single iterable argument that is evaluated lazily. Roughly equivalent to:</p> <pre data-language="python">def from_iterable(iterables):
    # chain.from_iterable(['ABC', 'DEF']) --&gt; A B C D E F
    for it in iterables:
        for element in it:
            yield element
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="itertools.combinations">
<code>itertools.combinations(iterable, r)</code> </dt> <dd>
<p>Return <em>r</em> length subsequences of elements from the input <em>iterable</em>.</p> <p>Combinations are emitted in lexicographic sort order. So, if the input <em>iterable</em> is sorted, the combination tuples will be produced in sorted order.</p> <p>Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each combination.</p> <p>Roughly equivalent to:</p> <pre data-language="python">def combinations(iterable, r):
    # combinations('ABCD', 2) --&gt; AB AC AD BC BD CD
    # combinations(range(4), 3) --&gt; 012 013 023 123
    pool = tuple(iterable)
    n = len(pool)
    if r &gt; n:
        return
    indices = range(r)
    yield tuple(pool[i] for i in indices)
    while True:
        for i in reversed(range(r)):
            if indices[i] != i + n - r:
                break
        else:
            return
        indices[i] += 1
        for j in range(i+1, r):
            indices[j] = indices[j-1] + 1
        yield tuple(pool[i] for i in indices)
</pre> <p>The code for <a class="reference internal" href="#itertools.combinations" title="itertools.combinations"><code>combinations()</code></a> can be also expressed as a subsequence of <a class="reference internal" href="#itertools.permutations" title="itertools.permutations"><code>permutations()</code></a> after filtering entries where the elements are not in sorted order (according to their position in the input pool):</p> <pre data-language="python">def combinations(iterable, r):
    pool = tuple(iterable)
    n = len(pool)
    for indices in permutations(range(n), r):
        if sorted(indices) == list(indices):
            yield tuple(pool[i] for i in indices)
</pre> <p>The number of items returned is <code>n! / r! / (n-r)!</code> when <code>0 &lt;= r &lt;= n</code> or zero when <code>r &gt; n</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="itertools.combinations_with_replacement">
<code>itertools.combinations_with_replacement(iterable, r)</code> </dt> <dd>
<p>Return <em>r</em> length subsequences of elements from the input <em>iterable</em> allowing individual elements to be repeated more than once.</p> <p>Combinations are emitted in lexicographic sort order. So, if the input <em>iterable</em> is sorted, the combination tuples will be produced in sorted order.</p> <p>Elements are treated as unique based on their position, not on their value. So if the input elements are unique, the generated combinations will also be unique.</p> <p>Roughly equivalent to:</p> <pre data-language="python">def combinations_with_replacement(iterable, r):
    # combinations_with_replacement('ABC', 2) --&gt; AA AB AC BB BC CC
    pool = tuple(iterable)
    n = len(pool)
    if not n and r:
        return
    indices = [0] * r
    yield tuple(pool[i] for i in indices)
    while True:
        for i in reversed(range(r)):
            if indices[i] != n - 1:
                break
        else:
            return
        indices[i:] = [indices[i] + 1] * (r - i)
        yield tuple(pool[i] for i in indices)
</pre> <p>The code for <a class="reference internal" href="#itertools.combinations_with_replacement" title="itertools.combinations_with_replacement"><code>combinations_with_replacement()</code></a> can be also expressed as a subsequence of <a class="reference internal" href="#itertools.product" title="itertools.product"><code>product()</code></a> after filtering entries where the elements are not in sorted order (according to their position in the input pool):</p> <pre data-language="python">def combinations_with_replacement(iterable, r):
    pool = tuple(iterable)
    n = len(pool)
    for indices in product(range(n), repeat=r):
        if sorted(indices) == list(indices):
            yield tuple(pool[i] for i in indices)
</pre> <p>The number of items returned is <code>(n+r-1)! / r! / (n-1)!</code> when <code>n &gt; 0</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="itertools.compress">
<code>itertools.compress(data, selectors)</code> </dt> <dd>
<p>Make an iterator that filters elements from <em>data</em> returning only those that have a corresponding element in <em>selectors</em> that evaluates to <code>True</code>. Stops when either the <em>data</em> or <em>selectors</em> iterables has been exhausted. Roughly equivalent to:</p> <pre data-language="python">def compress(data, selectors):
    # compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F
    return (d for d, s in izip(data, selectors) if s)
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="itertools.count">
<code>itertools.count(start=0, step=1)</code> </dt> <dd>
<p>Make an iterator that returns evenly spaced values starting with <em>n</em>. Often used as an argument to <a class="reference internal" href="#itertools.imap" title="itertools.imap"><code>imap()</code></a> to generate consecutive data points. Also, used with <a class="reference internal" href="#itertools.izip" title="itertools.izip"><code>izip()</code></a> to add sequence numbers. Equivalent to:</p> <pre data-language="python">def count(start=0, step=1):
    # count(10) --&gt; 10 11 12 13 14 ...
    # count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...
    n = start
    while True:
        yield n
        n += step
</pre> <p>When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: <code>(start + step * i
for i in count())</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>added <em>step</em> argument and allowed non-integer arguments.</p> </div> </dd>
</dl> <dl class="function"> <dt id="itertools.cycle">
<code>itertools.cycle(iterable)</code> </dt> <dd>
<p>Make an iterator returning elements from the iterable and saving a copy of each. When the iterable is exhausted, return elements from the saved copy. Repeats indefinitely. Roughly equivalent to:</p> <pre data-language="python">def cycle(iterable):
    # cycle('ABCD') --&gt; A B C D A B C D A B C D ...
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
              yield element
</pre> <p>Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable).</p> </dd>
</dl> <dl class="function"> <dt id="itertools.dropwhile">
<code>itertools.dropwhile(predicate, iterable)</code> </dt> <dd>
<p>Make an iterator that drops elements from the iterable as long as the predicate is true; afterwards, returns every element. Note, the iterator does not produce <em>any</em> output until the predicate first becomes false, so it may have a lengthy start-up time. Roughly equivalent to:</p> <pre data-language="python">def dropwhile(predicate, iterable):
    # dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1
    iterable = iter(iterable)
    for x in iterable:
        if not predicate(x):
            yield x
            break
    for x in iterable:
        yield x
</pre> </dd>
</dl> <dl class="function"> <dt id="itertools.groupby">
<code>itertools.groupby(iterable[, key])</code> </dt> <dd>
<p>Make an iterator that returns consecutive keys and groups from the <em>iterable</em>. The <em>key</em> is a function computing a key value for each element. If not specified or is <code>None</code>, <em>key</em> defaults to an identity function and returns the element unchanged. Generally, the iterable needs to already be sorted on the same key function.</p> <p>The operation of <a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code>groupby()</code></a> is similar to the <code>uniq</code> filter in Unix. It generates a break or new group every time the value of the key function changes (which is why it is usually necessary to have sorted the data using the same key function). That behavior differs from SQL’s GROUP BY which aggregates common elements regardless of their input order.</p> <p>The returned group is itself an iterator that shares the underlying iterable with <a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code>groupby()</code></a>. Because the source is shared, when the <a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code>groupby()</code></a> object is advanced, the previous group is no longer visible. So, if that data is needed later, it should be stored as a list:</p> <pre data-language="python">groups = []
uniquekeys = []
data = sorted(data, key=keyfunc)
for k, g in groupby(data, keyfunc):
    groups.append(list(g))      # Store group iterator as a list
    uniquekeys.append(k)
</pre> <p><a class="reference internal" href="#itertools.groupby" title="itertools.groupby"><code>groupby()</code></a> is roughly equivalent to:</p> <pre data-language="python">class groupby(object):
    # [k for k, g in groupby('AAAABBBCCDAABBB')] --&gt; A B C D A B
    # [list(g) for k, g in groupby('AAAABBBCCD')] --&gt; AAAA BBB CC D
    def __init__(self, iterable, key=None):
        if key is None:
            key = lambda x: x
        self.keyfunc = key
        self.it = iter(iterable)
        self.tgtkey = self.currkey = self.currvalue = object()
    def __iter__(self):
        return self
    def next(self):
        while self.currkey == self.tgtkey:
            self.currvalue = next(self.it)    # Exit on StopIteration
            self.currkey = self.keyfunc(self.currvalue)
        self.tgtkey = self.currkey
        return (self.currkey, self._grouper(self.tgtkey))
    def _grouper(self, tgtkey):
        while self.currkey == tgtkey:
            yield self.currvalue
            self.currvalue = next(self.it)    # Exit on StopIteration
            self.currkey = self.keyfunc(self.currvalue)
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="itertools.ifilter">
<code>itertools.ifilter(predicate, iterable)</code> </dt> <dd>
<p>Make an iterator that filters elements from iterable returning only those for which the predicate is <code>True</code>. If <em>predicate</em> is <code>None</code>, return the items that are true. Roughly equivalent to:</p> <pre data-language="python">def ifilter(predicate, iterable):
    # ifilter(lambda x: x%2, range(10)) --&gt; 1 3 5 7 9
    if predicate is None:
        predicate = bool
    for x in iterable:
        if predicate(x):
            yield x
</pre> </dd>
</dl> <dl class="function"> <dt id="itertools.ifilterfalse">
<code>itertools.ifilterfalse(predicate, iterable)</code> </dt> <dd>
<p>Make an iterator that filters elements from iterable returning only those for which the predicate is <code>False</code>. If <em>predicate</em> is <code>None</code>, return the items that are false. Roughly equivalent to:</p> <pre data-language="python">def ifilterfalse(predicate, iterable):
    # ifilterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8
    if predicate is None:
        predicate = bool
    for x in iterable:
        if not predicate(x):
            yield x
</pre> </dd>
</dl> <dl class="function"> <dt id="itertools.imap">
<code>itertools.imap(function, *iterables)</code> </dt> <dd>
<p>Make an iterator that computes the function using arguments from each of the iterables. If <em>function</em> is set to <code>None</code>, then <a class="reference internal" href="#itertools.imap" title="itertools.imap"><code>imap()</code></a> returns the arguments as a tuple. Like <a class="reference internal" href="functions#map" title="map"><code>map()</code></a> but stops when the shortest iterable is exhausted instead of filling in <code>None</code> for shorter iterables. The reason for the difference is that infinite iterator arguments are typically an error for <a class="reference internal" href="functions#map" title="map"><code>map()</code></a> (because the output is fully evaluated) but represent a common and useful way of supplying arguments to <a class="reference internal" href="#itertools.imap" title="itertools.imap"><code>imap()</code></a>. Roughly equivalent to:</p> <pre data-language="python">def imap(function, *iterables):
    # imap(pow, (2,3,10), (5,2,3)) --&gt; 32 9 1000
    iterables = map(iter, iterables)
    while True:
        args = [next(it) for it in iterables]
        if function is None:
            yield tuple(args)
        else:
            yield function(*args)
</pre> </dd>
</dl> <dl class="function"> <dt id="itertools.islice">
<code>itertools.islice(iterable, stop)</code> </dt> <dt>
<code>itertools.islice(iterable, start, stop[, step])</code> </dt> <dd>
<p>Make an iterator that returns selected elements from the iterable. If <em>start</em> is non-zero, then elements from the iterable are skipped until start is reached. Afterward, elements are returned consecutively unless <em>step</em> is set higher than one which results in items being skipped. If <em>stop</em> is <code>None</code>, then iteration continues until the iterator is exhausted, if at all; otherwise, it stops at the specified position. Unlike regular slicing, <a class="reference internal" href="#itertools.islice" title="itertools.islice"><code>islice()</code></a> does not support negative values for <em>start</em>, <em>stop</em>, or <em>step</em>. Can be used to extract related fields from data where the internal structure has been flattened (for example, a multi-line report may list a name field on every third line). Roughly equivalent to:</p> <pre data-language="python">def islice(iterable, *args):
    # islice('ABCDEFG', 2) --&gt; A B
    # islice('ABCDEFG', 2, 4) --&gt; C D
    # islice('ABCDEFG', 2, None) --&gt; C D E F G
    # islice('ABCDEFG', 0, None, 2) --&gt; A C E G
    s = slice(*args)
    start, stop, step = s.start or 0, s.stop or sys.maxint, s.step or 1
    it = iter(xrange(start, stop, step)))
    try:
        nexti = next(it)
    except StopIteration:
        # Consume *iterable* up to the *start* position.
        for i, element in izip(xrange(start), iterable):
            pass
        return
    try:
        for i, element in enumerate(iterable):
            if i == nexti:
                yield element
                nexti = next(it)
    except StopIteration:
        # Consume to *stop*.
        for i, element in izip(xrange(i + 1, stop), iterable):
            pass
</pre> <p>If <em>start</em> is <code>None</code>, then iteration starts at zero. If <em>step</em> is <code>None</code>, then the step defaults to one.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.5: </span>accept <code>None</code> values for default <em>start</em> and <em>step</em>.</p> </div> </dd>
</dl> <dl class="function"> <dt id="itertools.izip">
<code>itertools.izip(*iterables)</code> </dt> <dd>
<p>Make an iterator that aggregates elements from each of the iterables. Like <a class="reference internal" href="functions#zip" title="zip"><code>zip()</code></a> except that it returns an iterator instead of a list. Used for lock-step iteration over several iterables at a time. Roughly equivalent to:</p> <pre data-language="python">def izip(*iterables):
    # izip('ABCD', 'xy') --&gt; Ax By
    iterators = map(iter, iterables)
    while iterators:
        yield tuple(map(next, iterators))
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.4: </span>When no iterables are specified, returns a zero length iterator instead of raising a <a class="reference internal" href="exceptions#exceptions.TypeError" title="exceptions.TypeError"><code>TypeError</code></a> exception.</p> </div> <p>The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using <code>izip(*[iter(s)]*n)</code>.</p> <p><a class="reference internal" href="#itertools.izip" title="itertools.izip"><code>izip()</code></a> should only be used with unequal length inputs when you don’t care about trailing, unmatched values from the longer iterables. If those values are important, use <a class="reference internal" href="#itertools.izip_longest" title="itertools.izip_longest"><code>izip_longest()</code></a> instead.</p> </dd>
</dl> <dl class="function"> <dt id="itertools.izip_longest">
<code>itertools.izip_longest(*iterables[, fillvalue])</code> </dt> <dd>
<p>Make an iterator that aggregates elements from each of the iterables. If the iterables are of uneven length, missing values are filled-in with <em>fillvalue</em>. Iteration continues until the longest iterable is exhausted. Roughly equivalent to:</p> <pre data-language="python">class ZipExhausted(Exception):
    pass

def izip_longest(*args, **kwds):
    # izip_longest('ABCD', 'xy', fillvalue='-') --&gt; Ax By C- D-
    fillvalue = kwds.get('fillvalue')
    counter = [len(args) - 1]
    def sentinel():
        if not counter[0]:
            raise ZipExhausted
        counter[0] -= 1
        yield fillvalue
    fillers = repeat(fillvalue)
    iterators = [chain(it, sentinel(), fillers) for it in args]
    try:
        while iterators:
            yield tuple(map(next, iterators))
    except ZipExhausted:
        pass
</pre> <p>If one of the iterables is potentially infinite, then the <a class="reference internal" href="#itertools.izip_longest" title="itertools.izip_longest"><code>izip_longest()</code></a> function should be wrapped with something that limits the number of calls (for example <a class="reference internal" href="#itertools.islice" title="itertools.islice"><code>islice()</code></a> or <a class="reference internal" href="#itertools.takewhile" title="itertools.takewhile"><code>takewhile()</code></a>). If not specified, <em>fillvalue</em> defaults to <code>None</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="itertools.permutations">
<code>itertools.permutations(iterable[, r])</code> </dt> <dd>
<p>Return successive <em>r</em> length permutations of elements in the <em>iterable</em>.</p> <p>If <em>r</em> is not specified or is <code>None</code>, then <em>r</em> defaults to the length of the <em>iterable</em> and all possible full-length permutations are generated.</p> <p>Permutations are emitted in lexicographic sort order. So, if the input <em>iterable</em> is sorted, the permutation tuples will be produced in sorted order.</p> <p>Elements are treated as unique based on their position, not on their value. So if the input elements are unique, there will be no repeat values in each permutation.</p> <p>Roughly equivalent to:</p> <pre data-language="python">def permutations(iterable, r=None):
    # permutations('ABCD', 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC
    # permutations(range(3)) --&gt; 012 021 102 120 201 210
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    if r &gt; n:
        return
    indices = range(n)
    cycles = range(n, n-r, -1)
    yield tuple(pool[i] for i in indices[:r])
    while n:
        for i in reversed(range(r)):
            cycles[i] -= 1
            if cycles[i] == 0:
                indices[i:] = indices[i+1:] + indices[i:i+1]
                cycles[i] = n - i
            else:
                j = cycles[i]
                indices[i], indices[-j] = indices[-j], indices[i]
                yield tuple(pool[i] for i in indices[:r])
                break
        else:
            return
</pre> <p>The code for <a class="reference internal" href="#itertools.permutations" title="itertools.permutations"><code>permutations()</code></a> can be also expressed as a subsequence of <a class="reference internal" href="#itertools.product" title="itertools.product"><code>product()</code></a>, filtered to exclude entries with repeated elements (those from the same position in the input pool):</p> <pre data-language="python">def permutations(iterable, r=None):
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    for indices in product(range(n), repeat=r):
        if len(set(indices)) == r:
            yield tuple(pool[i] for i in indices)
</pre> <p>The number of items returned is <code>n! / (n-r)!</code> when <code>0 &lt;= r &lt;= n</code> or zero when <code>r &gt; n</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="itertools.product">
<code>itertools.product(*iterables[, repeat])</code> </dt> <dd>
<p>Cartesian product of input iterables.</p> <p>Roughly equivalent to nested for-loops in a generator expression. For example, <code>product(A, B)</code> returns the same as <code>((x,y) for x in A for y in B)</code>.</p> <p>The nested loops cycle like an odometer with the rightmost element advancing on every iteration. This pattern creates a lexicographic ordering so that if the input’s iterables are sorted, the product tuples are emitted in sorted order.</p> <p>To compute the product of an iterable with itself, specify the number of repetitions with the optional <em>repeat</em> keyword argument. For example, <code>product(A, repeat=4)</code> means the same as <code>product(A, A, A, A)</code>.</p> <p>This function is roughly equivalent to the following code, except that the actual implementation does not build up intermediate results in memory:</p> <pre data-language="python">def product(*args, **kwds):
    # product('ABCD', 'xy') --&gt; Ax Ay Bx By Cx Cy Dx Dy
    # product(range(2), repeat=3) --&gt; 000 001 010 011 100 101 110 111
    pools = map(tuple, args) * kwds.get('repeat', 1)
    result = [[]]
    for pool in pools:
        result = [x+[y] for x in result for y in pool]
    for prod in result:
        yield tuple(prod)
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="itertools.repeat">
<code>itertools.repeat(object[, times])</code> </dt> <dd>
<p>Make an iterator that returns <em>object</em> over and over again. Runs indefinitely unless the <em>times</em> argument is specified. Used as argument to <a class="reference internal" href="#itertools.imap" title="itertools.imap"><code>imap()</code></a> for invariant function parameters. Also used with <a class="reference internal" href="#itertools.izip" title="itertools.izip"><code>izip()</code></a> to create constant fields in a tuple record. Roughly equivalent to:</p> <pre data-language="python">def repeat(object, times=None):
    # repeat(10, 3) --&gt; 10 10 10
    if times is None:
        while True:
            yield object
    else:
        for i in xrange(times):
            yield object
</pre> <p>A common use for <em>repeat</em> is to supply a stream of constant values to <em>imap</em> or <em>zip</em>:</p> <pre data-language="python">&gt;&gt;&gt; list(imap(pow, xrange(10), repeat(2)))
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</pre> </dd>
</dl> <dl class="function"> <dt id="itertools.starmap">
<code>itertools.starmap(function, iterable)</code> </dt> <dd>
<p>Make an iterator that computes the function using arguments obtained from the iterable. Used instead of <a class="reference internal" href="#itertools.imap" title="itertools.imap"><code>imap()</code></a> when argument parameters are already grouped in tuples from a single iterable (the data has been “pre-zipped”). The difference between <a class="reference internal" href="#itertools.imap" title="itertools.imap"><code>imap()</code></a> and <a class="reference internal" href="#itertools.starmap" title="itertools.starmap"><code>starmap()</code></a> parallels the distinction between <code>function(a,b)</code> and <code>function(*c)</code>. Roughly equivalent to:</p> <pre data-language="python">def starmap(function, iterable):
    # starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000
    for args in iterable:
        yield function(*args)
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span>Previously, <a class="reference internal" href="#itertools.starmap" title="itertools.starmap"><code>starmap()</code></a> required the function arguments to be tuples. Now, any iterable is allowed.</p> </div> </dd>
</dl> <dl class="function"> <dt id="itertools.takewhile">
<code>itertools.takewhile(predicate, iterable)</code> </dt> <dd>
<p>Make an iterator that returns elements from the iterable as long as the predicate is true. Roughly equivalent to:</p> <pre data-language="python">def takewhile(predicate, iterable):
    # takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4
    for x in iterable:
        if predicate(x):
            yield x
        else:
            break
</pre> </dd>
</dl> <dl class="function"> <dt id="itertools.tee">
<code>itertools.tee(iterable[, n=2])</code> </dt> <dd>
<p>Return <em>n</em> independent iterators from a single iterable. Roughly equivalent to:</p> <pre data-language="python">def tee(iterable, n=2):
    it = iter(iterable)
    deques = [collections.deque() for i in range(n)]
    def gen(mydeque):
        while True:
            if not mydeque:             # when the local deque is empty
                newval = next(it)       # fetch a new value and
                for d in deques:        # load it to all the deques
                    d.append(newval)
            yield mydeque.popleft()
    return tuple(gen(d) for d in deques)
</pre> <p>Once <a class="reference internal" href="#itertools.tee" title="itertools.tee"><code>tee()</code></a> has made a split, the original <em>iterable</em> should not be used anywhere else; otherwise, the <em>iterable</em> could get advanced without the tee objects being informed.</p> <p><code>tee</code> iterators are not threadsafe. A <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a> may be raised when using simultaneously iterators returned by the same <a class="reference internal" href="#itertools.tee" title="itertools.tee"><code>tee()</code></a> call, even if the original <em>iterable</em> is threadsafe.</p> <p>This itertool may require significant auxiliary storage (depending on how much temporary data needs to be stored). In general, if one iterator uses most or all of the data before another iterator starts, it is faster to use <code>list()</code> instead of <a class="reference internal" href="#itertools.tee" title="itertools.tee"><code>tee()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> </dd>
</dl>   <h2 id="itertools-recipes">2. Recipes</h2> <p id="recipes">This section shows recipes for creating an extended toolset using the existing itertools as building blocks.</p> <p>The extended tools offer the same high performance as the underlying toolset. The superior memory performance is kept by processing elements one at a time rather than bringing the whole iterable into memory all at once. Code volume is kept small by linking the tools together in a functional style which helps eliminate temporary variables. High speed is retained by preferring “vectorized” building blocks over the use of for-loops and <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-generator"><span class="xref std std-term">generator</span></a>s which incur interpreter overhead.</p> <pre data-language="python">def take(n, iterable):
    "Return first n items of the iterable as a list"
    return list(islice(iterable, n))

def tabulate(function, start=0):
    "Return function(0), function(1), ..."
    return imap(function, count(start))

def consume(iterator, n=None):
    "Advance the iterator n-steps ahead. If n is None, consume entirely."
    # Use functions that consume iterators at C speed.
    if n is None:
        # feed the entire iterator into a zero-length deque
        collections.deque(iterator, maxlen=0)
    else:
        # advance to the empty slice starting at position n
        next(islice(iterator, n, n), None)

def nth(iterable, n, default=None):
    "Returns the nth item or a default value"
    return next(islice(iterable, n, None), default)

def all_equal(iterable):
    "Returns True if all the elements are equal to each other"
    g = groupby(iterable)
    return next(g, True) and not next(g, False)

def quantify(iterable, pred=bool):
    "Count how many times the predicate is true"
    return sum(imap(pred, iterable))

def padnone(iterable):
    """Returns the sequence elements and then returns None indefinitely.

    Useful for emulating the behavior of the built-in map() function.
    """
    return chain(iterable, repeat(None))

def ncycles(iterable, n):
    "Returns the sequence elements n times"
    return chain.from_iterable(repeat(tuple(iterable), n))

def dotproduct(vec1, vec2):
    return sum(imap(operator.mul, vec1, vec2))

def flatten(listOfLists):
    "Flatten one level of nesting"
    return chain.from_iterable(listOfLists)

def repeatfunc(func, times=None, *args):
    """Repeat calls to func with specified arguments.

    Example:  repeatfunc(random.random)
    """
    if times is None:
        return starmap(func, repeat(args))
    return starmap(func, repeat(args, times))

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    next(b, None)
    return izip(a, b)

def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx
    args = [iter(iterable)] * n
    return izip_longest(fillvalue=fillvalue, *args)

def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    pending = len(iterables)
    nexts = cycle(iter(it).next for it in iterables)
    while pending:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            pending -= 1
            nexts = cycle(islice(nexts, pending))

def powerset(iterable):
    "powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

def unique_everseen(iterable, key=None):
    "List unique elements, preserving order. Remember all elements ever seen."
    # unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D
    # unique_everseen('ABBCcAD', str.lower) --&gt; A B C D
    seen = set()
    seen_add = seen.add
    if key is None:
        for element in ifilterfalse(seen.__contains__, iterable):
            seen_add(element)
            yield element
    else:
        for element in iterable:
            k = key(element)
            if k not in seen:
                seen_add(k)
                yield element

def unique_justseen(iterable, key=None):
    "List unique elements, preserving order. Remember only the element just seen."
    # unique_justseen('AAAABBBCCDAABBB') --&gt; A B C D A B
    # unique_justseen('ABBCcAD', str.lower) --&gt; A B C A D
    return imap(next, imap(itemgetter(1), groupby(iterable, key)))

def iter_except(func, exception, first=None):
    """ Call a function repeatedly until an exception is raised.

    Converts a call-until-exception interface to an iterator interface.
    Like __builtin__.iter(func, sentinel) but uses an exception instead
    of a sentinel to end the loop.

    Examples:
        bsddbiter = iter_except(db.next, bsddb.error, db.first)
        heapiter = iter_except(functools.partial(heappop, h), IndexError)
        dictiter = iter_except(d.popitem, KeyError)
        dequeiter = iter_except(d.popleft, IndexError)
        queueiter = iter_except(q.get_nowait, Queue.Empty)
        setiter = iter_except(s.pop, KeyError)

    """
    try:
        if first is not None:
            yield first()
        while 1:
            yield func()
    except exception:
        pass

def random_product(*args, **kwds):
    "Random selection from itertools.product(*args, **kwds)"
    pools = map(tuple, args) * kwds.get('repeat', 1)
    return tuple(random.choice(pool) for pool in pools)

def random_permutation(iterable, r=None):
    "Random selection from itertools.permutations(iterable, r)"
    pool = tuple(iterable)
    r = len(pool) if r is None else r
    return tuple(random.sample(pool, r))

def random_combination(iterable, r):
    "Random selection from itertools.combinations(iterable, r)"
    pool = tuple(iterable)
    n = len(pool)
    indices = sorted(random.sample(xrange(n), r))
    return tuple(pool[i] for i in indices)

def random_combination_with_replacement(iterable, r):
    "Random selection from itertools.combinations_with_replacement(iterable, r)"
    pool = tuple(iterable)
    n = len(pool)
    indices = sorted(random.randrange(n) for i in xrange(r))
    return tuple(pool[i] for i in indices)

def tee_lookahead(t, i):
    """Inspect the i-th upcomping value from a tee object
       while leaving the tee object at its current position.

       Raise an IndexError if the underlying iterator doesn't
       have enough values.

    """
    for value in islice(t.__copy__(), i, None):
        return value
    raise IndexError(i)
</pre> <p>Note, many of the above recipes can be optimized by replacing global lookups with local variables defined as default values. For example, the <em>dotproduct</em> recipe can be written as:</p> <pre data-language="python">def dotproduct(vec1, vec2, sum=sum, imap=imap, mul=operator.mul):
    return sum(imap(mul, vec1, vec2))
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/itertools.html" class="_attribution-link">https://docs.python.org/2.7/library/itertools.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
