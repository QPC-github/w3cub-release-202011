
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Rfc822 - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content="Deprecated since version 2.3&#58; The email package should be used in preference to the rfc822 module. This module is present only to maintain &hellip;">
  <meta name="keywords" content="rfc, —, parse, mail, headers, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/rfc822.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/python~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="rfc822-parse-rfc-2822-mail-headers"> rfc822 — Parse RFC 2822 mail headers</h1> <div class="deprecated" id="module-rfc822"> <p><span class="versionmodified deprecated">Deprecated since version 2.3: </span>The <a class="reference internal" href="email#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages, including MIME documents."><code>email</code></a> package should be used in preference to the <a class="reference internal" href="#module-rfc822" title="rfc822: Parse 2822 style mail messages. (deprecated)"><code>rfc822</code></a> module. This module is present only to maintain backward compatibility, and has been removed in Python 3.</p> </div> <p>This module defines a class, <a class="reference internal" href="#rfc822.Message" title="rfc822.Message"><code>Message</code></a>, which represents an “email message” as defined by the Internet standard <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-0"><strong>RFC 2822</strong></a>. <a class="footnote-reference brackets" href="#id4" id="id1">1</a> Such messages consist of a collection of message headers, and a message body. This module also defines a helper class <a class="reference internal" href="#rfc822.AddressList" title="rfc822.AddressList"><code>AddressList</code></a> for parsing <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-1"><strong>RFC 2822</strong></a> addresses. Please refer to the RFC for information on the specific syntax of <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-2"><strong>RFC 2822</strong></a> messages.</p> <p id="index-3">The <a class="reference internal" href="mailbox#module-mailbox" title="mailbox: Manipulate mailboxes in various formats"><code>mailbox</code></a> module provides classes to read mailboxes produced by various end-user mail programs.</p> <dl class="class"> <dt id="rfc822.Message">
<code>class rfc822.Message(file[, seekable])</code> </dt> <dd>
<p>A <a class="reference internal" href="#rfc822.Message" title="rfc822.Message"><code>Message</code></a> instance is instantiated with an input object as parameter. Message relies only on the input object having a <a class="reference internal" href="readline#module-readline" title="readline: GNU readline support for Python. (Unix)"><code>readline()</code></a> method; in particular, ordinary file objects qualify. Instantiation reads headers from the input object up to a delimiter line (normally a blank line) and stores them in the instance. The message body, following the headers, is not consumed.</p> <p>This class can work with any input object that supports a <a class="reference internal" href="readline#module-readline" title="readline: GNU readline support for Python. (Unix)"><code>readline()</code></a> method. If the input object has seek and tell capability, the <a class="reference internal" href="#rfc822.Message.rewindbody" title="rfc822.Message.rewindbody"><code>rewindbody()</code></a> method will work; also, illegal lines will be pushed back onto the input stream. If the input object lacks seek but has an <code>unread()</code> method that can push back a line of input, <a class="reference internal" href="#rfc822.Message" title="rfc822.Message"><code>Message</code></a> will use that to push back illegal lines. Thus this class can be used to parse messages coming from a buffered stream.</p> <p>The optional <em>seekable</em> argument is provided as a workaround for certain stdio libraries in which <code>tell()</code> discards buffered data before discovering that the <code>lseek()</code> system call doesn’t work. For maximum portability, you should set the seekable argument to zero to prevent that initial <code>tell()</code> when passing in an unseekable object such as a file object created from a socket object.</p> <p>Input lines as read from the file may either be terminated by CR-LF or by a single linefeed; a terminating CR-LF is replaced by a single linefeed before the line is stored.</p> <p>All header matching is done independent of upper or lower case; e.g. <code>m['From']</code>, <code>m['from']</code> and <code>m['FROM']</code> all yield the same result.</p> </dd>
</dl> <dl class="class"> <dt id="rfc822.AddressList">
<code>class rfc822.AddressList(field)</code> </dt> <dd>
<p>You may instantiate the <a class="reference internal" href="#rfc822.AddressList" title="rfc822.AddressList"><code>AddressList</code></a> helper class using a single string parameter, a comma-separated list of <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-4"><strong>RFC 2822</strong></a> addresses to be parsed. (The parameter <code>None</code> yields an empty list.)</p> </dd>
</dl> <dl class="function"> <dt id="rfc822.quote">
<code>rfc822.quote(str)</code> </dt> <dd>
<p>Return a new string with backslashes in <em>str</em> replaced by two backslashes and double quotes replaced by backslash-double quote.</p> </dd>
</dl> <dl class="function"> <dt id="rfc822.unquote">
<code>rfc822.unquote(str)</code> </dt> <dd>
<p>Return a new string which is an <em>unquoted</em> version of <em>str</em>. If <em>str</em> ends and begins with double quotes, they are stripped off. Likewise if <em>str</em> ends and begins with angle brackets, they are stripped off.</p> </dd>
</dl> <dl class="function"> <dt id="rfc822.parseaddr">
<code>rfc822.parseaddr(address)</code> </dt> <dd>
<p>Parse <em>address</em>, which should be the value of some address-containing field such as <em class="mailheader">To</em> or <em class="mailheader">Cc</em>, into its constituent “realname” and “email address” parts. Returns a tuple of that information, unless the parse fails, in which case a 2-tuple <code>(None, None)</code> is returned.</p> </dd>
</dl> <dl class="function"> <dt id="rfc822.dump_address_pair">
<code>rfc822.dump_address_pair(pair)</code> </dt> <dd>
<p>The inverse of <a class="reference internal" href="#rfc822.parseaddr" title="rfc822.parseaddr"><code>parseaddr()</code></a>, this takes a 2-tuple of the form <code>(realname,
email_address)</code> and returns the string value suitable for a <em class="mailheader">To</em> or <em class="mailheader">Cc</em> header. If the first element of <em>pair</em> is false, then the second element is returned unmodified.</p> </dd>
</dl> <dl class="function"> <dt id="rfc822.parsedate">
<code>rfc822.parsedate(date)</code> </dt> <dd>
<p>Attempts to parse a date according to the rules in <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-5"><strong>RFC 2822</strong></a>. however, some mailers don’t follow that format as specified, so <a class="reference internal" href="#rfc822.parsedate" title="rfc822.parsedate"><code>parsedate()</code></a> tries to guess correctly in such cases. <em>date</em> is a string containing an <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-6"><strong>RFC 2822</strong></a> date, such as <code>'Mon, 20 Nov 1995 19:12:08 -0500'</code>. If it succeeds in parsing the date, <a class="reference internal" href="#rfc822.parsedate" title="rfc822.parsedate"><code>parsedate()</code></a> returns a 9-tuple that can be passed directly to <a class="reference internal" href="time#time.mktime" title="time.mktime"><code>time.mktime()</code></a>; otherwise <code>None</code> will be returned. Note that indexes 6, 7, and 8 of the result tuple are not usable.</p> </dd>
</dl> <dl class="function"> <dt id="rfc822.parsedate_tz">
<code>rfc822.parsedate_tz(date)</code> </dt> <dd>
<p>Performs the same function as <a class="reference internal" href="#rfc822.parsedate" title="rfc822.parsedate"><code>parsedate()</code></a>, but returns either <code>None</code> or a 10-tuple; the first 9 elements make up a tuple that can be passed directly to <a class="reference internal" href="time#time.mktime" title="time.mktime"><code>time.mktime()</code></a>, and the tenth is the offset of the date’s timezone from UTC (which is the official term for Greenwich Mean Time). (Note that the sign of the timezone offset is the opposite of the sign of the <code>time.timezone</code> variable for the same timezone; the latter variable follows the POSIX standard while this module follows <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-7"><strong>RFC 2822</strong></a>.) If the input string has no timezone, the last element of the tuple returned is <code>None</code>. Note that indexes 6, 7, and 8 of the result tuple are not usable.</p> </dd>
</dl> <dl class="function"> <dt id="rfc822.mktime_tz">
<code>rfc822.mktime_tz(tuple)</code> </dt> <dd>
<p>Turn a 10-tuple as returned by <a class="reference internal" href="#rfc822.parsedate_tz" title="rfc822.parsedate_tz"><code>parsedate_tz()</code></a> into a UTC timestamp. If the timezone item in the tuple is <code>None</code>, assume local time. Minor deficiency: this first interprets the first 8 elements as a local time and then compensates for the timezone difference; this may yield a slight error around daylight savings time switch dates. Not enough to worry about for common use.</p> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="email#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages, including MIME documents."><code>email</code></a>
</dt>
<dd>
<p>Comprehensive email handling package; supersedes the <a class="reference internal" href="#module-rfc822" title="rfc822: Parse 2822 style mail messages. (deprecated)"><code>rfc822</code></a> module.</p> </dd> <dt>
<code>Module</code> <a class="reference internal" href="mailbox#module-mailbox" title="mailbox: Manipulate mailboxes in various formats"><code>mailbox</code></a>
</dt>
<dd>
<p>Classes to read various mailbox formats produced by end-user mail programs.</p> </dd> <dt>
<code>Module</code> <a class="reference internal" href="mimetools#module-mimetools" title="mimetools: Tools for parsing MIME-style message bodies. (deprecated)"><code>mimetools</code></a>
</dt>
<dd>
<p>Subclass of <a class="reference internal" href="#rfc822.Message" title="rfc822.Message"><code>rfc822.Message</code></a> that handles MIME encoded messages.</p> </dd> </dl> </div>  <h2 id="id2">1. Message Objects</h2> <p id="message-objects">A <a class="reference internal" href="#rfc822.Message" title="rfc822.Message"><code>Message</code></a> instance has the following methods:</p> <dl class="method"> <dt id="rfc822.Message.rewindbody">
<code>Message.rewindbody()</code> </dt> <dd>
<p>Seek to the start of the message body. This only works if the file object is seekable.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.Message.isheader">
<code>Message.isheader(line)</code> </dt> <dd>
<p>Returns a line’s canonicalized fieldname (the dictionary key that will be used to index it) if the line is a legal <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-8"><strong>RFC 2822</strong></a> header; otherwise returns <code>None</code> (implying that parsing should stop here and the line be pushed back on the input stream). It is sometimes useful to override this method in a subclass.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.Message.islast">
<code>Message.islast(line)</code> </dt> <dd>
<p>Return true if the given line is a delimiter on which Message should stop. The delimiter line is consumed, and the file object’s read location positioned immediately after it. By default this method just checks that the line is blank, but you can override it in a subclass.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.Message.iscomment">
<code>Message.iscomment(line)</code> </dt> <dd>
<p>Return <code>True</code> if the given line should be ignored entirely, just skipped. By default this is a stub that always returns <code>False</code>, but you can override it in a subclass.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.Message.getallmatchingheaders">
<code>Message.getallmatchingheaders(name)</code> </dt> <dd>
<p>Return a list of lines consisting of all headers matching <em>name</em>, if any. Each physical line, whether it is a continuation line or not, is a separate list item. Return the empty list if no header matches <em>name</em>.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.Message.getfirstmatchingheader">
<code>Message.getfirstmatchingheader(name)</code> </dt> <dd>
<p>Return a list of lines comprising the first header matching <em>name</em>, and its continuation line(s), if any. Return <code>None</code> if there is no header matching <em>name</em>.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.Message.getrawheader">
<code>Message.getrawheader(name)</code> </dt> <dd>
<p>Return a single string consisting of the text after the colon in the first header matching <em>name</em>. This includes leading whitespace, the trailing linefeed, and internal linefeeds and whitespace if there any continuation line(s) were present. Return <code>None</code> if there is no header matching <em>name</em>.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.Message.getheader">
<code>Message.getheader(name[, default])</code> </dt> <dd>
<p>Return a single string consisting of the last header matching <em>name</em>, but strip leading and trailing whitespace. Internal whitespace is not stripped. The optional <em>default</em> argument can be used to specify a different default to be returned when there is no header matching <em>name</em>; it defaults to <code>None</code>. This is the preferred way to get parsed headers.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.Message.get">
<code>Message.get(name[, default])</code> </dt> <dd>
<p>An alias for <a class="reference internal" href="#rfc822.Message.getheader" title="rfc822.Message.getheader"><code>getheader()</code></a>, to make the interface more compatible with regular dictionaries.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.Message.getaddr">
<code>Message.getaddr(name)</code> </dt> <dd>
<p>Return a pair <code>(full name, email address)</code> parsed from the string returned by <code>getheader(name)</code>. If no header matching <em>name</em> exists, return <code>(None,
None)</code>; otherwise both the full name and the address are (possibly empty) strings.</p> <p>Example: If <em>m</em>’s first <em class="mailheader">From</em> header contains the string <code>'jack@cwi.nl (Jack Jansen)'</code>, then <code>m.getaddr('From')</code> will yield the pair <code>('Jack Jansen', 'jack@cwi.nl')</code>. If the header contained <code>'Jack Jansen
&lt;jack@cwi.nl&gt;'</code> instead, it would yield the exact same result.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.Message.getaddrlist">
<code>Message.getaddrlist(name)</code> </dt> <dd>
<p>This is similar to <code>getaddr(list)</code>, but parses a header containing a list of email addresses (e.g. a <em class="mailheader">To</em> header) and returns a list of <code>(full
name, email address)</code> pairs (even if there was only one address in the header). If there is no header matching <em>name</em>, return an empty list.</p> <p>If multiple headers exist that match the named header (e.g. if there are several <em class="mailheader">Cc</em> headers), all are parsed for addresses. Any continuation lines the named headers contain are also parsed.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.Message.getdate">
<code>Message.getdate(name)</code> </dt> <dd>
<p>Retrieve a header using <a class="reference internal" href="#rfc822.Message.getheader" title="rfc822.Message.getheader"><code>getheader()</code></a> and parse it into a 9-tuple compatible with <a class="reference internal" href="time#time.mktime" title="time.mktime"><code>time.mktime()</code></a>; note that fields 6, 7, and 8 are not usable. If there is no header matching <em>name</em>, or it is unparsable, return <code>None</code>.</p> <p>Date parsing appears to be a black art, and not all mailers adhere to the standard. While it has been tested and found correct on a large collection of email from many sources, it is still possible that this function may occasionally yield an incorrect result.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.Message.getdate_tz">
<code>Message.getdate_tz(name)</code> </dt> <dd>
<p>Retrieve a header using <a class="reference internal" href="#rfc822.Message.getheader" title="rfc822.Message.getheader"><code>getheader()</code></a> and parse it into a 10-tuple; the first 9 elements will make a tuple compatible with <a class="reference internal" href="time#time.mktime" title="time.mktime"><code>time.mktime()</code></a>, and the 10th is a number giving the offset of the date’s timezone from UTC. Note that fields 6, 7, and 8 are not usable. Similarly to <a class="reference internal" href="#rfc822.Message.getdate" title="rfc822.Message.getdate"><code>getdate()</code></a>, if there is no header matching <em>name</em>, or it is unparsable, return <code>None</code>.</p> </dd>
</dl> <p><a class="reference internal" href="#rfc822.Message" title="rfc822.Message"><code>Message</code></a> instances also support a limited mapping interface. In particular: <code>m[name]</code> is like <code>m.getheader(name)</code> but raises <a class="reference internal" href="exceptions#exceptions.KeyError" title="exceptions.KeyError"><code>KeyError</code></a> if there is no matching header; and <code>len(m)</code>, <code>m.get(name[, default])</code>, <code>name in m</code>, <code>m.keys()</code>, <code>m.values()</code> <code>m.items()</code>, and <code>m.setdefault(name[, default])</code> act as expected, with the one difference that <code>setdefault()</code> uses an empty string as the default value. <a class="reference internal" href="#rfc822.Message" title="rfc822.Message"><code>Message</code></a> instances also support the mapping writable interface <code>m[name]
= value</code> and <code>del m[name]</code>. <a class="reference internal" href="#rfc822.Message" title="rfc822.Message"><code>Message</code></a> objects do not support the <code>clear()</code>, <a class="reference internal" href="copy#module-copy" title="copy: Shallow and deep copy operations."><code>copy()</code></a>, <code>popitem()</code>, or <code>update()</code> methods of the mapping interface. (Support for <code>get()</code> and <code>setdefault()</code> was only added in Python 2.2.)</p> <p>Finally, <a class="reference internal" href="#rfc822.Message" title="rfc822.Message"><code>Message</code></a> instances have some public instance variables:</p> <dl class="attribute"> <dt id="rfc822.Message.headers">
<code>Message.headers</code> </dt> <dd>
<p>A list containing the entire set of header lines, in the order in which they were read (except that setitem calls may disturb this order). Each line contains a trailing newline. The blank line terminating the headers is not contained in the list.</p> </dd>
</dl> <dl class="attribute"> <dt id="rfc822.Message.fp">
<code>Message.fp</code> </dt> <dd>
<p>The file or file-like object passed at instantiation time. This can be used to read the message content.</p> </dd>
</dl> <dl class="attribute"> <dt id="rfc822.Message.unixfrom">
<code>Message.unixfrom</code> </dt> <dd>
<p>The Unix <code>From</code> line, if the message had one, or an empty string. This is needed to regenerate the message in some contexts, such as an <code>mbox</code>-style mailbox file.</p> </dd>
</dl>   <h2 id="id3">2. AddressList Objects</h2> <p id="addresslist-objects">An <a class="reference internal" href="#rfc822.AddressList" title="rfc822.AddressList"><code>AddressList</code></a> instance has the following methods:</p> <dl class="method"> <dt id="rfc822.AddressList.__len__">
<code>AddressList.__len__()</code> </dt> <dd>
<p>Return the number of addresses in the address list.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.AddressList.__str__">
<code>AddressList.__str__()</code> </dt> <dd>
<p>Return a canonicalized string representation of the address list. Addresses are rendered in “name” &lt;<a class="reference external" href="mailto:host%40domain">host<span>@</span>domain</a>&gt; form, comma-separated.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.AddressList.__add__">
<code>AddressList.__add__(alist)</code> </dt> <dd>
<p>Return a new <a class="reference internal" href="#rfc822.AddressList" title="rfc822.AddressList"><code>AddressList</code></a> instance that contains all addresses in both <a class="reference internal" href="#rfc822.AddressList" title="rfc822.AddressList"><code>AddressList</code></a> operands, with duplicates removed (set union).</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.AddressList.__iadd__">
<code>AddressList.__iadd__(alist)</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#rfc822.AddressList.__add__" title="rfc822.AddressList.__add__"><code>__add__()</code></a>; turns this <a class="reference internal" href="#rfc822.AddressList" title="rfc822.AddressList"><code>AddressList</code></a> instance into the union of itself and the right-hand instance, <em>alist</em>.</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.AddressList.__sub__">
<code>AddressList.__sub__(alist)</code> </dt> <dd>
<p>Return a new <a class="reference internal" href="#rfc822.AddressList" title="rfc822.AddressList"><code>AddressList</code></a> instance that contains every address in the left-hand <a class="reference internal" href="#rfc822.AddressList" title="rfc822.AddressList"><code>AddressList</code></a> operand that is not present in the right-hand address operand (set difference).</p> </dd>
</dl> <dl class="method"> <dt id="rfc822.AddressList.__isub__">
<code>AddressList.__isub__(alist)</code> </dt> <dd>
<p>In-place version of <a class="reference internal" href="#rfc822.AddressList.__sub__" title="rfc822.AddressList.__sub__"><code>__sub__()</code></a>, removing addresses in this list which are also in <em>alist</em>.</p> </dd>
</dl> <p>Finally, <a class="reference internal" href="#rfc822.AddressList" title="rfc822.AddressList"><code>AddressList</code></a> instances have one public instance variable:</p> <dl class="attribute"> <dt id="rfc822.AddressList.addresslist">
<code>AddressList.addresslist</code> </dt> <dd>
<p>A list of tuple string pairs, one per address. In each member, the first is the canonicalized name part, the second is the actual route-address (<code>'@'</code>-separated username-host.domain pair).</p> </dd>
</dl> <h4 class="rubric">Footnotes</h4> <dl class="footnote brackets"> <dt class="label" id="id4">
<code>1</code> </dt> <dd>
<p>This module originally conformed to <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html" id="index-9"><strong>RFC 822</strong></a>, hence the name. Since then, <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-10"><strong>RFC 2822</strong></a> has been released as an update to <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html" id="index-11"><strong>RFC 822</strong></a>. This module should be considered <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html" id="index-12"><strong>RFC 2822</strong></a>-conformant, especially in cases where the syntax or semantics have changed since <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html" id="index-13"><strong>RFC 822</strong></a>.</p> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/rfc822.html" class="_attribution-link">https://docs.python.org/2.7/library/rfc822.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
