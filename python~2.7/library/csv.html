
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Csv - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" New in version 2.3. ">
  <meta name="keywords" content="csv, —, file, reading, and, writing, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/csv.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/python~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="csv-csv-file-reading-and-writing"> csv — CSV File Reading and Writing</h1> <div class="versionadded" id="module-csv"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> <p id="index-0">The so-called CSV (Comma Separated Values) format is the most common import and export format for spreadsheets and databases. There is no “CSV standard”, so the format is operationally defined by the many applications which read and write it. The lack of a standard means that subtle differences often exist in the data produced and consumed by different applications. These differences can make it annoying to process CSV files from multiple sources. Still, while the delimiters and quoting characters vary, the overall format is similar enough that it is possible to write a single module which can efficiently manipulate such data, hiding the details of reading and writing the data from the programmer.</p> <p>The <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module implements classes to read and write tabular data in CSV format. It allows programmers to say, “write this data in the format preferred by Excel,” or “read data from this file which was generated by Excel,” without knowing the precise details of the CSV format used by Excel. Programmers can also describe the CSV formats understood by other applications or define their own special-purpose CSV formats.</p> <p>The <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module’s <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> and <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects read and write sequences. Programmers can also read and write data in dictionary form using the <a class="reference internal" href="#csv.DictReader" title="csv.DictReader"><code>DictReader</code></a> and <a class="reference internal" href="#csv.DictWriter" title="csv.DictWriter"><code>DictWriter</code></a> classes.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This version of the <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module doesn’t support Unicode input. Also, there are currently some issues regarding ASCII NUL characters. Accordingly, all input should be UTF-8 or printable ASCII to be safe; see the examples in section <a class="reference internal" href="#csv-examples"><span class="std std-ref">Examples</span></a>.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<a class="pep reference external" href="https://www.python.org/dev/peps/pep-0305" id="index-1"><strong>PEP 305</strong></a> - CSV File API</dt>
<dd>
<p>The Python Enhancement Proposal which proposed this addition to Python.</p> </dd> </dl> </div>  <h2 id="csv-contents">1. Module Contents</h2> <p id="module-contents">The <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module defines the following functions:</p> <dl class="function"> <dt id="csv.reader">
<code>csv.reader(csvfile, dialect='excel', **fmtparams)</code> </dt> <dd>
<p>Return a reader object which will iterate over lines in the given <em>csvfile</em>. <em>csvfile</em> can be any object which supports the <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> protocol and returns a string each time its <code>next()</code> method is called — file objects and list objects are both suitable. If <em>csvfile</em> is a file object, it must be opened with the ‘b’ flag on platforms where that makes a difference. An optional <em>dialect</em> parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> class or one of the strings returned by the <a class="reference internal" href="#csv.list_dialects" title="csv.list_dialects"><code>list_dialects()</code></a> function. The other optional <em>fmtparams</em> keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about the dialect and formatting parameters, see section <a class="reference internal" href="#csv-fmt-params"><span class="std std-ref">Dialects and Formatting Parameters</span></a>.</p> <p>Each row read from the csv file is returned as a list of strings. No automatic data type conversion is performed.</p> <p>A short usage example:</p> <pre data-language="python">&gt;&gt;&gt; import csv
&gt;&gt;&gt; with open('eggs.csv', 'rb') as csvfile:
...     spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
...     for row in spamreader:
...         print ', '.join(row)
Spam, Spam, Spam, Spam, Spam, Baked Beans
Spam, Lovely Spam, Wonderful Spam
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.5: </span>The parser is now stricter with respect to multi-line quoted fields. Previously, if a line ended within a quoted field without a terminating newline character, a newline would be inserted into the returned field. This behavior caused problems when reading files which contained carriage return characters within fields. The behavior was changed to return the field without inserting newlines. As a consequence, if newlines embedded within fields are important, the input should be split into lines in a manner which preserves the newline characters.</p> </div> </dd>
</dl> <dl class="function"> <dt id="csv.writer">
<code>csv.writer(csvfile, dialect='excel', **fmtparams)</code> </dt> <dd>
<p>Return a writer object responsible for converting the user’s data into delimited strings on the given file-like object. <em>csvfile</em> can be any object with a <code>write()</code> method. If <em>csvfile</em> is a file object, it must be opened with the ‘b’ flag on platforms where that makes a difference. An optional <em>dialect</em> parameter can be given which is used to define a set of parameters specific to a particular CSV dialect. It may be an instance of a subclass of the <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> class or one of the strings returned by the <a class="reference internal" href="#csv.list_dialects" title="csv.list_dialects"><code>list_dialects()</code></a> function. The other optional <em>fmtparams</em> keyword arguments can be given to override individual formatting parameters in the current dialect. For full details about the dialect and formatting parameters, see section <a class="reference internal" href="#csv-fmt-params"><span class="std std-ref">Dialects and Formatting Parameters</span></a>. To make it as easy as possible to interface with modules which implement the DB API, the value <a class="reference internal" href="constants#None" title="None"><code>None</code></a> is written as the empty string. While this isn’t a reversible transformation, it makes it easier to dump SQL NULL data values to CSV files without preprocessing the data returned from a <code>cursor.fetch*</code> call. Floats are stringified with <a class="reference internal" href="functions#repr" title="repr"><code>repr()</code></a> before being written. All other non-string data are stringified with <a class="reference internal" href="functions#str" title="str"><code>str()</code></a> before being written.</p> <p>A short usage example:</p> <pre data-language="python">import csv
with open('eggs.csv', 'wb') as csvfile:
    spamwriter = csv.writer(csvfile, delimiter=' ',
                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])
    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])
</pre> </dd>
</dl> <dl class="function"> <dt id="csv.register_dialect">
<code>csv.register_dialect(name, [dialect, ]**fmtparams)</code> </dt> <dd>
<p>Associate <em>dialect</em> with <em>name</em>. <em>name</em> must be a string or Unicode object. The dialect can be specified either by passing a sub-class of <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a>, or by <em>fmtparams</em> keyword arguments, or both, with keyword arguments overriding parameters of the dialect. For full details about the dialect and formatting parameters, see section <a class="reference internal" href="#csv-fmt-params"><span class="std std-ref">Dialects and Formatting Parameters</span></a>.</p> </dd>
</dl> <dl class="function"> <dt id="csv.unregister_dialect">
<code>csv.unregister_dialect(name)</code> </dt> <dd>
<p>Delete the dialect associated with <em>name</em> from the dialect registry. An <a class="reference internal" href="#csv.Error" title="csv.Error"><code>Error</code></a> is raised if <em>name</em> is not a registered dialect name.</p> </dd>
</dl> <dl class="function"> <dt id="csv.get_dialect">
<code>csv.get_dialect(name)</code> </dt> <dd>
<p>Return the dialect associated with <em>name</em>. An <a class="reference internal" href="#csv.Error" title="csv.Error"><code>Error</code></a> is raised if <em>name</em> is not a registered dialect name.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.5: </span>This function now returns an immutable <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a>. Previously an instance of the requested dialect was returned. Users could modify the underlying class, changing the behavior of active readers and writers.</p> </div> </dd>
</dl> <dl class="function"> <dt id="csv.list_dialects">
<code>csv.list_dialects()</code> </dt> <dd>
<p>Return the names of all registered dialects.</p> </dd>
</dl> <dl class="function"> <dt id="csv.field_size_limit">
<code>csv.field_size_limit([new_limit])</code> </dt> <dd>
<p>Returns the current maximum field size allowed by the parser. If <em>new_limit</em> is given, this becomes the new limit.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.5.</span></p> </div> </dd>
</dl> <p>The <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module defines the following classes:</p> <dl class="class"> <dt id="csv.DictReader">
<code>class csv.DictReader(f, fieldnames=None, restkey=None, restval=None, dialect='excel', *args, **kwds)</code> </dt> <dd>
<p>Create an object which operates like a regular reader but maps the information read into a dict whose keys are given by the optional <em>fieldnames</em> parameter. The <em>fieldnames</em> parameter is a <a class="reference internal" href="collections#collections-abstract-base-classes"><span class="std std-ref">sequence</span></a> whose elements are associated with the fields of the input data in order. These elements become the keys of the resulting dictionary. If the <em>fieldnames</em> parameter is omitted, the values in the first row of the file <em>f</em> will be used as the fieldnames. If the row read has more fields than the fieldnames sequence, the remaining data is added as a sequence keyed by the value of <em>restkey</em>. If the row read has fewer fields than the fieldnames sequence, the remaining keys take the value of the optional <em>restval</em> parameter. Any other optional or keyword arguments are passed to the underlying <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> instance.</p> <p>A short usage example:</p> <pre data-language="python">&gt;&gt;&gt; import csv
&gt;&gt;&gt; with open('names.csv') as csvfile:
...     reader = csv.DictReader(csvfile)
...     for row in reader:
...         print(row['first_name'], row['last_name'])
...
Baked Beans
Lovely Spam
Wonderful Spam
</pre> </dd>
</dl> <dl class="class"> <dt id="csv.DictWriter">
<code>class csv.DictWriter(f, fieldnames, restval='', extrasaction='raise', dialect='excel', *args, **kwds)</code> </dt> <dd>
<p>Create an object which operates like a regular writer but maps dictionaries onto output rows. The <em>fieldnames</em> parameter is a <a class="reference internal" href="collections#collections-abstract-base-classes"><span class="std std-ref">sequence</span></a> of keys that identify the order in which values in the dictionary passed to the <code>writerow()</code> method are written to the file <em>f</em>. The optional <em>restval</em> parameter specifies the value to be written if the dictionary is missing a key in <em>fieldnames</em>. If the dictionary passed to the <code>writerow()</code> method contains a key not found in <em>fieldnames</em>, the optional <em>extrasaction</em> parameter indicates what action to take. If it is set to <code>'raise'</code> a <a class="reference internal" href="exceptions#exceptions.ValueError" title="exceptions.ValueError"><code>ValueError</code></a> is raised. If it is set to <code>'ignore'</code>, extra values in the dictionary are ignored. Any other optional or keyword arguments are passed to the underlying <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> instance.</p> <p>Note that unlike the <a class="reference internal" href="#csv.DictReader" title="csv.DictReader"><code>DictReader</code></a> class, the <em>fieldnames</em> parameter of the <a class="reference internal" href="#csv.DictWriter" title="csv.DictWriter"><code>DictWriter</code></a> is not optional. Since Python’s <a class="reference internal" href="stdtypes#dict" title="dict"><code>dict</code></a> objects are not ordered, there is not enough information available to deduce the order in which the row should be written to the file <em>f</em>.</p> <p>A short usage example:</p> <pre data-language="python">import csv

with open('names.csv', 'w') as csvfile:
    fieldnames = ['first_name', 'last_name']
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

    writer.writeheader()
    writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})
    writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})
    writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})
</pre> </dd>
</dl> <dl class="class"> <dt id="csv.Dialect">
<code>class csv.Dialect</code> </dt> <dd>
<p>The <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> class is a container class relied on primarily for its attributes, which are used to define the parameters for a specific <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> or <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> instance.</p> </dd>
</dl> <dl class="class"> <dt id="csv.excel">
<code>class csv.excel</code> </dt> <dd>
<p>The <a class="reference internal" href="#csv.excel" title="csv.excel"><code>excel</code></a> class defines the usual properties of an Excel-generated CSV file. It is registered with the dialect name <code>'excel'</code>.</p> </dd>
</dl> <dl class="class"> <dt id="csv.excel_tab">
<code>class csv.excel_tab</code> </dt> <dd>
<p>The <a class="reference internal" href="#csv.excel_tab" title="csv.excel_tab"><code>excel_tab</code></a> class defines the usual properties of an Excel-generated TAB-delimited file. It is registered with the dialect name <code>'excel-tab'</code>.</p> </dd>
</dl> <dl class="class"> <dt id="csv.Sniffer">
<code>class csv.Sniffer</code> </dt> <dd>
<p>The <a class="reference internal" href="#csv.Sniffer" title="csv.Sniffer"><code>Sniffer</code></a> class is used to deduce the format of a CSV file.</p> <p>The <a class="reference internal" href="#csv.Sniffer" title="csv.Sniffer"><code>Sniffer</code></a> class provides two methods:</p> <dl class="method"> <dt id="csv.Sniffer.sniff">
<code>sniff(sample, delimiters=None)</code> </dt> <dd>
<p>Analyze the given <em>sample</em> and return a <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> subclass reflecting the parameters found. If the optional <em>delimiters</em> parameter is given, it is interpreted as a string containing possible valid delimiter characters.</p> </dd>
</dl> <dl class="method"> <dt id="csv.Sniffer.has_header">
<code>has_header(sample)</code> </dt> <dd>
<p>Analyze the sample text (presumed to be in CSV format) and return <a class="reference internal" href="constants#True" title="True"><code>True</code></a> if the first row appears to be a series of column headers.</p> </dd>
</dl> </dd>
</dl> <p>An example for <a class="reference internal" href="#csv.Sniffer" title="csv.Sniffer"><code>Sniffer</code></a> use:</p> <pre data-language="python">with open('example.csv', 'rb') as csvfile:
    dialect = csv.Sniffer().sniff(csvfile.read(1024))
    csvfile.seek(0)
    reader = csv.reader(csvfile, dialect)
    # ... process CSV file contents here ...
</pre> <p>The <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module defines the following constants:</p> <dl class="data"> <dt id="csv.QUOTE_ALL">
<code>csv.QUOTE_ALL</code> </dt> <dd>
<p>Instructs <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects to quote all fields.</p> </dd>
</dl> <dl class="data"> <dt id="csv.QUOTE_MINIMAL">
<code>csv.QUOTE_MINIMAL</code> </dt> <dd>
<p>Instructs <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects to only quote those fields which contain special characters such as <em>delimiter</em>, <em>quotechar</em> or any of the characters in <em>lineterminator</em>.</p> </dd>
</dl> <dl class="data"> <dt id="csv.QUOTE_NONNUMERIC">
<code>csv.QUOTE_NONNUMERIC</code> </dt> <dd>
<p>Instructs <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects to quote all non-numeric fields.</p> <p>Instructs the reader to convert all non-quoted fields to type <em>float</em>.</p> </dd>
</dl> <dl class="data"> <dt id="csv.QUOTE_NONE">
<code>csv.QUOTE_NONE</code> </dt> <dd>
<p>Instructs <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects to never quote fields. When the current <em>delimiter</em> occurs in output data it is preceded by the current <em>escapechar</em> character. If <em>escapechar</em> is not set, the writer will raise <a class="reference internal" href="#csv.Error" title="csv.Error"><code>Error</code></a> if any characters that require escaping are encountered.</p> <p>Instructs <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> to perform no special processing of quote characters.</p> </dd>
</dl> <p>The <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module defines the following exception:</p> <dl class="exception"> <dt id="csv.Error">
<code>exception csv.Error</code> </dt> <dd>
<p>Raised by any of the functions when an error is detected.</p> </dd>
</dl>   <h2 id="csv-fmt-params">2. Dialects and Formatting Parameters</h2> <p id="dialects-and-formatting-parameters">To make it easier to specify the format of input and output records, specific formatting parameters are grouped together into dialects. A dialect is a subclass of the <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> class having a set of specific methods and a single <code>validate()</code> method. When creating <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> or <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a> objects, the programmer can specify a string or a subclass of the <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> class as the dialect parameter. In addition to, or instead of, the <em>dialect</em> parameter, the programmer can also specify individual formatting parameters, which have the same names as the attributes defined below for the <a class="reference internal" href="#csv.Dialect" title="csv.Dialect"><code>Dialect</code></a> class.</p> <p>Dialects support the following attributes:</p> <dl class="attribute"> <dt id="csv.Dialect.delimiter">
<code>Dialect.delimiter</code> </dt> <dd>
<p>A one-character string used to separate fields. It defaults to <code>','</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="csv.Dialect.doublequote">
<code>Dialect.doublequote</code> </dt> <dd>
<p>Controls how instances of <em>quotechar</em> appearing inside a field should themselves be quoted. When <a class="reference internal" href="constants#True" title="True"><code>True</code></a>, the character is doubled. When <a class="reference internal" href="constants#False" title="False"><code>False</code></a>, the <em>escapechar</em> is used as a prefix to the <em>quotechar</em>. It defaults to <a class="reference internal" href="constants#True" title="True"><code>True</code></a>.</p> <p>On output, if <em>doublequote</em> is <a class="reference internal" href="constants#False" title="False"><code>False</code></a> and no <em>escapechar</em> is set, <a class="reference internal" href="#csv.Error" title="csv.Error"><code>Error</code></a> is raised if a <em>quotechar</em> is found in a field.</p> </dd>
</dl> <dl class="attribute"> <dt id="csv.Dialect.escapechar">
<code>Dialect.escapechar</code> </dt> <dd>
<p>A one-character string used by the writer to escape the <em>delimiter</em> if <em>quoting</em> is set to <a class="reference internal" href="#csv.QUOTE_NONE" title="csv.QUOTE_NONE"><code>QUOTE_NONE</code></a> and the <em>quotechar</em> if <em>doublequote</em> is <a class="reference internal" href="constants#False" title="False"><code>False</code></a>. On reading, the <em>escapechar</em> removes any special meaning from the following character. It defaults to <a class="reference internal" href="constants#None" title="None"><code>None</code></a>, which disables escaping.</p> </dd>
</dl> <dl class="attribute"> <dt id="csv.Dialect.lineterminator">
<code>Dialect.lineterminator</code> </dt> <dd>
<p>The string used to terminate lines produced by the <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer</code></a>. It defaults to <code>'\r\n'</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader</code></a> is hard-coded to recognise either <code>'\r'</code> or <code>'\n'</code> as end-of-line, and ignores <em>lineterminator</em>. This behavior may change in the future.</p> </div> </dd>
</dl> <dl class="attribute"> <dt id="csv.Dialect.quotechar">
<code>Dialect.quotechar</code> </dt> <dd>
<p>A one-character string used to quote fields containing special characters, such as the <em>delimiter</em> or <em>quotechar</em>, or which contain new-line characters. It defaults to <code>'"'</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="csv.Dialect.quoting">
<code>Dialect.quoting</code> </dt> <dd>
<p>Controls when quotes should be generated by the writer and recognised by the reader. It can take on any of the <code>QUOTE_*</code> constants (see section <a class="reference internal" href="#csv-contents"><span class="std std-ref">Module Contents</span></a>) and defaults to <a class="reference internal" href="#csv.QUOTE_MINIMAL" title="csv.QUOTE_MINIMAL"><code>QUOTE_MINIMAL</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="csv.Dialect.skipinitialspace">
<code>Dialect.skipinitialspace</code> </dt> <dd>
<p>When <a class="reference internal" href="constants#True" title="True"><code>True</code></a>, whitespace immediately following the <em>delimiter</em> is ignored. The default is <a class="reference internal" href="constants#False" title="False"><code>False</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="csv.Dialect.strict">
<code>Dialect.strict</code> </dt> <dd>
<p>When <code>True</code>, raise exception <a class="reference internal" href="#csv.Error" title="csv.Error"><code>Error</code></a> on bad CSV input. The default is <code>False</code>.</p> </dd>
</dl>   <h2 id="reader-objects">3. Reader Objects</h2> <p>Reader objects (<a class="reference internal" href="#csv.DictReader" title="csv.DictReader"><code>DictReader</code></a> instances and objects returned by the <a class="reference internal" href="#csv.reader" title="csv.reader"><code>reader()</code></a> function) have the following public methods:</p> <dl class="method"> <dt id="csv.csvreader.next">
<code>csvreader.next()</code> </dt> <dd>
<p>Return the next row of the reader’s iterable object as a list, parsed according to the current dialect.</p> </dd>
</dl> <p>Reader objects have the following public attributes:</p> <dl class="attribute"> <dt id="csv.csvreader.dialect">
<code>csvreader.dialect</code> </dt> <dd>
<p>A read-only description of the dialect in use by the parser.</p> </dd>
</dl> <dl class="attribute"> <dt id="csv.csvreader.line_num">
<code>csvreader.line_num</code> </dt> <dd>
<p>The number of lines read from the source iterator. This is not the same as the number of records returned, as records can span multiple lines.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.5.</span></p> </div> </dd>
</dl> <p>DictReader objects have the following public attribute:</p> <dl class="attribute"> <dt id="csv.csvreader.fieldnames">
<code>csvreader.fieldnames</code> </dt> <dd>
<p>If not passed as a parameter when creating the object, this attribute is initialized upon first access or when the first record is read from the file.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6.</span></p> </div> </dd>
</dl>   <h2 id="writer-objects">4. Writer Objects</h2> <p><code>Writer</code> objects (<a class="reference internal" href="#csv.DictWriter" title="csv.DictWriter"><code>DictWriter</code></a> instances and objects returned by the <a class="reference internal" href="#csv.writer" title="csv.writer"><code>writer()</code></a> function) have the following public methods. A <em>row</em> must be a sequence of strings or numbers for <code>Writer</code> objects and a dictionary mapping fieldnames to strings or numbers (by passing them through <a class="reference internal" href="functions#str" title="str"><code>str()</code></a> first) for <a class="reference internal" href="#csv.DictWriter" title="csv.DictWriter"><code>DictWriter</code></a> objects. Note that complex numbers are written out surrounded by parens. This may cause some problems for other programs which read CSV files (assuming they support complex numbers at all).</p> <dl class="method"> <dt id="csv.csvwriter.writerow">
<code>csvwriter.writerow(row)</code> </dt> <dd>
<p>Write the <em>row</em> parameter to the writer’s file object, formatted according to the current dialect.</p> </dd>
</dl> <dl class="method"> <dt id="csv.csvwriter.writerows">
<code>csvwriter.writerows(rows)</code> </dt> <dd>
<p>Write all elements in <em>rows</em> (an iterable of <em>row</em> objects as described above) to the writer’s file object, formatted according to the current dialect.</p> </dd>
</dl> <p>Writer objects have the following public attribute:</p> <dl class="attribute"> <dt id="csv.csvwriter.dialect">
<code>csvwriter.dialect</code> </dt> <dd>
<p>A read-only description of the dialect in use by the writer.</p> </dd>
</dl> <p>DictWriter objects have the following public method:</p> <dl class="method"> <dt id="csv.DictWriter.writeheader">
<code>DictWriter.writeheader()</code> </dt> <dd>
<p>Write a row with the field names (as specified in the constructor).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl>   <h2 id="csv-examples">5. Examples</h2> <p id="examples">The simplest example of reading a CSV file:</p> <pre data-language="python">import csv
with open('some.csv', 'rb') as f:
    reader = csv.reader(f)
    for row in reader:
        print row
</pre> <p>Reading a file with an alternate format:</p> <pre data-language="python">import csv
with open('passwd', 'rb') as f:
    reader = csv.reader(f, delimiter=':', quoting=csv.QUOTE_NONE)
    for row in reader:
        print row
</pre> <p>The corresponding simplest possible writing example is:</p> <pre data-language="python">import csv
with open('some.csv', 'wb') as f:
    writer = csv.writer(f)
    writer.writerows(someiterable)
</pre> <p>Registering a new dialect:</p> <pre data-language="python">import csv
csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)
with open('passwd', 'rb') as f:
    reader = csv.reader(f, 'unixpwd')
</pre> <p>A slightly more advanced use of the reader — catching and reporting errors:</p> <pre data-language="python">import csv, sys
filename = 'some.csv'
with open(filename, 'rb') as f:
    reader = csv.reader(f)
    try:
        for row in reader:
            print row
    except csv.Error as e:
        sys.exit('file %s, line %d: %s' % (filename, reader.line_num, e))
</pre> <p>And while the module doesn’t directly support parsing strings, it can easily be done:</p> <pre data-language="python">import csv
for row in csv.reader(['one,two,three']):
    print row
</pre> <p>The <a class="reference internal" href="#module-csv" title="csv: Write and read tabular data to and from delimited files."><code>csv</code></a> module doesn’t directly support reading and writing Unicode, but it is 8-bit-clean save for some problems with ASCII NUL characters. So you can write functions or classes that handle the encoding and decoding for you as long as you avoid encodings like UTF-16 that use NULs. UTF-8 is recommended.</p> <p><code>unicode_csv_reader()</code> below is a <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-generator"><span class="xref std std-term">generator</span></a> that wraps <a class="reference internal" href="#csv.reader" title="csv.reader"><code>csv.reader</code></a> to handle Unicode CSV data (a list of Unicode strings). <code>utf_8_encoder()</code> is a <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-generator"><span class="xref std std-term">generator</span></a> that encodes the Unicode strings as UTF-8, one string (or row) at a time. The encoded strings are parsed by the CSV reader, and <code>unicode_csv_reader()</code> decodes the UTF-8-encoded cells back into Unicode:</p> <pre data-language="python">import csv

def unicode_csv_reader(unicode_csv_data, dialect=csv.excel, **kwargs):
    # csv.py doesn't do Unicode; encode temporarily as UTF-8:
    csv_reader = csv.reader(utf_8_encoder(unicode_csv_data),
                            dialect=dialect, **kwargs)
    for row in csv_reader:
        # decode UTF-8 back to Unicode, cell by cell:
        yield [unicode(cell, 'utf-8') for cell in row]

def utf_8_encoder(unicode_csv_data):
    for line in unicode_csv_data:
        yield line.encode('utf-8')
</pre> <p>For all other encodings the following <code>UnicodeReader</code> and <code>UnicodeWriter</code> classes can be used. They take an additional <em>encoding</em> parameter in their constructor and make sure that the data passes the real reader or writer encoded as UTF-8:</p> <pre data-language="python">import csv, codecs, cStringIO

class UTF8Recoder:
    """
    Iterator that reads an encoded stream and reencodes the input to UTF-8
    """
    def __init__(self, f, encoding):
        self.reader = codecs.getreader(encoding)(f)

    def __iter__(self):
        return self

    def next(self):
        return self.reader.next().encode("utf-8")

class UnicodeReader:
    """
    A CSV reader which will iterate over lines in the CSV file "f",
    which is encoded in the given encoding.
    """

    def __init__(self, f, dialect=csv.excel, encoding="utf-8", **kwds):
        f = UTF8Recoder(f, encoding)
        self.reader = csv.reader(f, dialect=dialect, **kwds)

    def next(self):
        row = self.reader.next()
        return [unicode(s, "utf-8") for s in row]

    def __iter__(self):
        return self

class UnicodeWriter:
    """
    A CSV writer which will write rows to CSV file "f",
    which is encoded in the given encoding.
    """

    def __init__(self, f, dialect=csv.excel, encoding="utf-8", **kwds):
        # Redirect output to a queue
        self.queue = cStringIO.StringIO()
        self.writer = csv.writer(self.queue, dialect=dialect, **kwds)
        self.stream = f
        self.encoder = codecs.getincrementalencoder(encoding)()

    def writerow(self, row):
        self.writer.writerow([s.encode("utf-8") for s in row])
        # Fetch UTF-8 output from the queue ...
        data = self.queue.getvalue()
        data = data.decode("utf-8")
        # ... and reencode it into the target encoding
        data = self.encoder.encode(data)
        # write to the target stream
        self.stream.write(data)
        # empty queue
        self.queue.truncate(0)

    def writerows(self, rows):
        for row in rows:
            self.writerow(row)
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/csv.html" class="_attribution-link">https://docs.python.org/2.7/library/csv.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
