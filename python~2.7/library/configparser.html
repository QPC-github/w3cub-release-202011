
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>ConfigParser - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" Note ">
  <meta name="keywords" content="configparser, —, configuration, file, parser, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/configparser.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/python~2.7.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="configparser-configuration-file-parser"> ConfigParser — Configuration file parser</h1> <div class="admonition note" id="module-ConfigParser"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="#module-ConfigParser" title="ConfigParser: Configuration file parser."><code>ConfigParser</code></a> module has been renamed to <code>configparser</code> in Python 3. The <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-2to3"><span class="xref std std-term">2to3</span></a> tool will automatically adapt imports when converting your sources to Python 3.</p> </div> <p id="index-0">This module defines the class <a class="reference internal" href="#ConfigParser.ConfigParser" title="ConfigParser.ConfigParser"><code>ConfigParser</code></a>. The <a class="reference internal" href="#ConfigParser.ConfigParser" title="ConfigParser.ConfigParser"><code>ConfigParser</code></a> class implements a basic configuration file parser language which provides a structure similar to what you would find on Microsoft Windows INI files. You can use this to write Python programs which can be customized by end users easily.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This library does <em>not</em> interpret or write the value-type prefixes used in the Windows Registry extended version of INI syntax.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="shlex#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code>shlex</code></a>
</dt>
<dd>
<p>Support for creating Unix shell-like mini-languages which can be used as an alternate format for application configuration files.</p> </dd> <dt>
<code>Module</code> <a class="reference internal" href="json#module-json" title="json: Encode and decode the JSON format."><code>json</code></a>
</dt>
<dd>
<p>The json module implements a subset of JavaScript syntax which can also be used for this purpose.</p> </dd> </dl> </div> <p>The configuration file consists of sections, led by a <code>[section]</code> header and followed by <code>name: value</code> entries, with continuations in the style of <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html" id="index-1"><strong>RFC 822</strong></a> (see section 3.1.1, “LONG HEADER FIELDS”); <code>name=value</code> is also accepted. Note that leading whitespace is removed from values. The optional values can contain format strings which refer to other values in the same section, or values in a special <code>DEFAULT</code> section. Additional defaults can be provided on initialization and retrieval. Lines beginning with <code>'#'</code> or <code>';'</code> are ignored and may be used to provide comments.</p> <p>Configuration files may include comments, prefixed by specific characters (<code>#</code> and <code>;</code>). Comments may appear on their own in an otherwise empty line, or may be entered in lines holding values or section names. In the latter case, they need to be preceded by a whitespace character to be recognized as a comment. (For backwards compatibility, only <code>;</code> starts an inline comment, while <code>#</code> does not.)</p> <p>On top of the core functionality, <a class="reference internal" href="#ConfigParser.SafeConfigParser" title="ConfigParser.SafeConfigParser"><code>SafeConfigParser</code></a> supports interpolation. This means values can contain format strings which refer to other values in the same section, or values in a special <code>DEFAULT</code> section. Additional defaults can be provided on initialization.</p> <p>For example:</p> <pre data-language="python">[My Section]
foodir: %(dir)s/whatever
dir=frob
long: this value continues
   in the next line
</pre> <p>would resolve the <code>%(dir)s</code> to the value of <code>dir</code> (<code>frob</code> in this case). All reference expansions are done on demand.</p> <p>Default values can be specified by passing them into the <a class="reference internal" href="#ConfigParser.ConfigParser" title="ConfigParser.ConfigParser"><code>ConfigParser</code></a> constructor as a dictionary. Additional defaults may be passed into the <code>get()</code> method which will override all others.</p> <p>Sections are normally stored in a built-in dictionary. An alternative dictionary type can be passed to the <a class="reference internal" href="#ConfigParser.ConfigParser" title="ConfigParser.ConfigParser"><code>ConfigParser</code></a> constructor. For example, if a dictionary type is passed that sorts its keys, the sections will be sorted on write-back, as will be the keys within each section.</p> <dl class="class"> <dt id="ConfigParser.RawConfigParser">
<code>class ConfigParser.RawConfigParser([defaults[, dict_type[, allow_no_value]]])</code> </dt> <dd>
<p>The basic configuration object. When <em>defaults</em> is given, it is initialized into the dictionary of intrinsic defaults. When <em>dict_type</em> is given, it will be used to create the dictionary objects for the list of sections, for the options within a section, and for the default values. When <em>allow_no_value</em> is true (default: <code>False</code>), options without values are accepted; the value presented for these is <code>None</code>.</p> <p>This class does not support the magical interpolation behavior.</p> <p>All option names are passed through the <a class="reference internal" href="#ConfigParser.RawConfigParser.optionxform" title="ConfigParser.RawConfigParser.optionxform"><code>optionxform()</code></a> method. Its default implementation converts option names to lower case.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span><em>dict_type</em> was added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>The default <em>dict_type</em> is <a class="reference internal" href="collections#collections.OrderedDict" title="collections.OrderedDict"><code>collections.OrderedDict</code></a>. <em>allow_no_value</em> was added.</p> </div> </dd>
</dl> <dl class="class"> <dt id="ConfigParser.ConfigParser">
<code>class ConfigParser.ConfigParser([defaults[, dict_type[, allow_no_value]]])</code> </dt> <dd>
<p>Derived class of <a class="reference internal" href="#ConfigParser.RawConfigParser" title="ConfigParser.RawConfigParser"><code>RawConfigParser</code></a> that implements the magical interpolation feature and adds optional arguments to the <a class="reference internal" href="#ConfigParser.ConfigParser.get" title="ConfigParser.ConfigParser.get"><code>get()</code></a> and <a class="reference internal" href="#ConfigParser.ConfigParser.items" title="ConfigParser.ConfigParser.items"><code>items()</code></a> methods. The values in <em>defaults</em> must be appropriate for the <code>%()s</code> string interpolation. Note that <em>__name__</em> is an intrinsic default; its value is the section name, and will override any value provided in <em>defaults</em>.</p> <p>All option names used in interpolation will be passed through the <code>optionxform()</code> method just like any other option name reference. Using the default implementation of <code>optionxform()</code>, the values <code>foo %(bar)s</code> and <code>foo %(BAR)s</code> are equivalent.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span><em>dict_type</em> was added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>The default <em>dict_type</em> is <a class="reference internal" href="collections#collections.OrderedDict" title="collections.OrderedDict"><code>collections.OrderedDict</code></a>. <em>allow_no_value</em> was added.</p> </div> </dd>
</dl> <dl class="class"> <dt id="ConfigParser.SafeConfigParser">
<code>class ConfigParser.SafeConfigParser([defaults[, dict_type[, allow_no_value]]])</code> </dt> <dd>
<p>Derived class of <a class="reference internal" href="#ConfigParser.ConfigParser" title="ConfigParser.ConfigParser"><code>ConfigParser</code></a> that implements a more-sane variant of the magical interpolation feature. This implementation is more predictable as well. New applications should prefer this version if they don’t need to be compatible with older versions of Python.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span><em>dict_type</em> was added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>The default <em>dict_type</em> is <a class="reference internal" href="collections#collections.OrderedDict" title="collections.OrderedDict"><code>collections.OrderedDict</code></a>. <em>allow_no_value</em> was added.</p> </div> </dd>
</dl> <dl class="exception"> <dt id="ConfigParser.Error">
<code>exception ConfigParser.Error</code> </dt> <dd>
<p>Base class for all other configparser exceptions.</p> </dd>
</dl> <dl class="exception"> <dt id="ConfigParser.NoSectionError">
<code>exception ConfigParser.NoSectionError</code> </dt> <dd>
<p>Exception raised when a specified section is not found.</p> </dd>
</dl> <dl class="exception"> <dt id="ConfigParser.DuplicateSectionError">
<code>exception ConfigParser.DuplicateSectionError</code> </dt> <dd>
<p>Exception raised if <code>add_section()</code> is called with the name of a section that is already present.</p> </dd>
</dl> <dl class="exception"> <dt id="ConfigParser.NoOptionError">
<code>exception ConfigParser.NoOptionError</code> </dt> <dd>
<p>Exception raised when a specified option is not found in the specified section.</p> </dd>
</dl> <dl class="exception"> <dt id="ConfigParser.InterpolationError">
<code>exception ConfigParser.InterpolationError</code> </dt> <dd>
<p>Base class for exceptions raised when problems occur performing string interpolation.</p> </dd>
</dl> <dl class="exception"> <dt id="ConfigParser.InterpolationDepthError">
<code>exception ConfigParser.InterpolationDepthError</code> </dt> <dd>
<p>Exception raised when string interpolation cannot be completed because the number of iterations exceeds <a class="reference internal" href="#ConfigParser.MAX_INTERPOLATION_DEPTH" title="ConfigParser.MAX_INTERPOLATION_DEPTH"><code>MAX_INTERPOLATION_DEPTH</code></a>. Subclass of <a class="reference internal" href="#ConfigParser.InterpolationError" title="ConfigParser.InterpolationError"><code>InterpolationError</code></a>.</p> </dd>
</dl> <dl class="exception"> <dt id="ConfigParser.InterpolationMissingOptionError">
<code>exception ConfigParser.InterpolationMissingOptionError</code> </dt> <dd>
<p>Exception raised when an option referenced from a value does not exist. Subclass of <a class="reference internal" href="#ConfigParser.InterpolationError" title="ConfigParser.InterpolationError"><code>InterpolationError</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </dd>
</dl> <dl class="exception"> <dt id="ConfigParser.InterpolationSyntaxError">
<code>exception ConfigParser.InterpolationSyntaxError</code> </dt> <dd>
<p>Exception raised when the source text into which substitutions are made does not conform to the required syntax. Subclass of <a class="reference internal" href="#ConfigParser.InterpolationError" title="ConfigParser.InterpolationError"><code>InterpolationError</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </dd>
</dl> <dl class="exception"> <dt id="ConfigParser.MissingSectionHeaderError">
<code>exception ConfigParser.MissingSectionHeaderError</code> </dt> <dd>
<p>Exception raised when attempting to parse a file which has no section headers.</p> </dd>
</dl> <dl class="exception"> <dt id="ConfigParser.ParsingError">
<code>exception ConfigParser.ParsingError</code> </dt> <dd>
<p>Exception raised when errors occur attempting to parse a file.</p> </dd>
</dl> <dl class="data"> <dt id="ConfigParser.MAX_INTERPOLATION_DEPTH">
<code>ConfigParser.MAX_INTERPOLATION_DEPTH</code> </dt> <dd>
<p>The maximum depth for recursive interpolation for <code>get()</code> when the <em>raw</em> parameter is false. This is relevant only for the <a class="reference internal" href="#ConfigParser.ConfigParser" title="ConfigParser.ConfigParser"><code>ConfigParser</code></a> class.</p> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="shlex#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code>shlex</code></a>
</dt>
<dd>
<p>Support for a creating Unix shell-like mini-languages which can be used as an alternate format for application configuration files.</p> </dd> </dl> </div>  <h2 id="id1">1. RawConfigParser Objects</h2> <p id="rawconfigparser-objects"><a class="reference internal" href="#ConfigParser.RawConfigParser" title="ConfigParser.RawConfigParser"><code>RawConfigParser</code></a> instances have the following methods:</p> <dl class="method"> <dt id="ConfigParser.RawConfigParser.defaults">
<code>RawConfigParser.defaults()</code> </dt> <dd>
<p>Return a dictionary containing the instance-wide defaults.</p> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.sections">
<code>RawConfigParser.sections()</code> </dt> <dd>
<p>Return a list of the sections available; <code>DEFAULT</code> is not included in the list.</p> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.add_section">
<code>RawConfigParser.add_section(section)</code> </dt> <dd>
<p>Add a section named <em>section</em> to the instance. If a section by the given name already exists, <a class="reference internal" href="#ConfigParser.DuplicateSectionError" title="ConfigParser.DuplicateSectionError"><code>DuplicateSectionError</code></a> is raised. If the name <code>DEFAULT</code> (or any of it’s case-insensitive variants) is passed, <a class="reference internal" href="exceptions#exceptions.ValueError" title="exceptions.ValueError"><code>ValueError</code></a> is raised.</p> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.has_section">
<code>RawConfigParser.has_section(section)</code> </dt> <dd>
<p>Indicates whether the named section is present in the configuration. The <code>DEFAULT</code> section is not acknowledged.</p> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.options">
<code>RawConfigParser.options(section)</code> </dt> <dd>
<p>Returns a list of options available in the specified <em>section</em>.</p> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.has_option">
<code>RawConfigParser.has_option(section, option)</code> </dt> <dd>
<p>If the given section exists, and contains the given option, return <a class="reference internal" href="constants#True" title="True"><code>True</code></a>; otherwise return <a class="reference internal" href="constants#False" title="False"><code>False</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.read">
<code>RawConfigParser.read(filenames)</code> </dt> <dd>
<p>Attempt to read and parse a list of filenames, returning a list of filenames which were successfully parsed. If <em>filenames</em> is a string or Unicode string, it is treated as a single filename. If a file named in <em>filenames</em> cannot be opened, that file will be ignored. This is designed so that you can specify a list of potential configuration file locations (for example, the current directory, the user’s home directory, and some system-wide directory), and all existing configuration files in the list will be read. If none of the named files exist, the <a class="reference internal" href="#ConfigParser.ConfigParser" title="ConfigParser.ConfigParser"><code>ConfigParser</code></a> instance will contain an empty dataset. An application which requires initial values to be loaded from a file should load the required file or files using <a class="reference internal" href="#ConfigParser.RawConfigParser.readfp" title="ConfigParser.RawConfigParser.readfp"><code>readfp()</code></a> before calling <a class="reference internal" href="#ConfigParser.RawConfigParser.read" title="ConfigParser.RawConfigParser.read"><code>read()</code></a> for any optional files:</p> <pre data-language="python">import ConfigParser, os

config = ConfigParser.ConfigParser()
config.readfp(open('defaults.cfg'))
config.read(['site.cfg', os.path.expanduser('~/.myapp.cfg')])
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.4: </span>Returns list of successfully parsed filenames.</p> </div> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.readfp">
<code>RawConfigParser.readfp(fp[, filename])</code> </dt> <dd>
<p>Read and parse configuration data from the file or file-like object in <em>fp</em> (only the <a class="reference internal" href="readline#module-readline" title="readline: GNU readline support for Python. (Unix)"><code>readline()</code></a> method is used). If <em>filename</em> is omitted and <em>fp</em> has a <code>name</code> attribute, that is used for <em>filename</em>; the default is <code>&lt;???&gt;</code>.</p> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.get">
<code>RawConfigParser.get(section, option)</code> </dt> <dd>
<p>Get an <em>option</em> value for the named <em>section</em>.</p> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.getint">
<code>RawConfigParser.getint(section, option)</code> </dt> <dd>
<p>A convenience method which coerces the <em>option</em> in the specified <em>section</em> to an integer.</p> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.getfloat">
<code>RawConfigParser.getfloat(section, option)</code> </dt> <dd>
<p>A convenience method which coerces the <em>option</em> in the specified <em>section</em> to a floating point number.</p> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.getboolean">
<code>RawConfigParser.getboolean(section, option)</code> </dt> <dd>
<p>A convenience method which coerces the <em>option</em> in the specified <em>section</em> to a Boolean value. Note that the accepted values for the option are <code>"1"</code>, <code>"yes"</code>, <code>"true"</code>, and <code>"on"</code>, which cause this method to return <code>True</code>, and <code>"0"</code>, <code>"no"</code>, <code>"false"</code>, and <code>"off"</code>, which cause it to return <code>False</code>. These string values are checked in a case-insensitive manner. Any other value will cause it to raise <a class="reference internal" href="exceptions#exceptions.ValueError" title="exceptions.ValueError"><code>ValueError</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.items">
<code>RawConfigParser.items(section)</code> </dt> <dd>
<p>Return a list of <code>(name, value)</code> pairs for each option in the given <em>section</em>.</p> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.set">
<code>RawConfigParser.set(section, option, value)</code> </dt> <dd>
<p>If the given section exists, set the given option to the specified value; otherwise raise <a class="reference internal" href="#ConfigParser.NoSectionError" title="ConfigParser.NoSectionError"><code>NoSectionError</code></a>. While it is possible to use <a class="reference internal" href="#ConfigParser.RawConfigParser" title="ConfigParser.RawConfigParser"><code>RawConfigParser</code></a> (or <a class="reference internal" href="#ConfigParser.ConfigParser" title="ConfigParser.ConfigParser"><code>ConfigParser</code></a> with <em>raw</em> parameters set to true) for <em>internal</em> storage of non-string values, full functionality (including interpolation and output to files) can only be achieved using string values.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.write">
<code>RawConfigParser.write(fileobject)</code> </dt> <dd>
<p>Write a representation of the configuration to the specified file object. This representation can be parsed by a future <a class="reference internal" href="#ConfigParser.RawConfigParser.read" title="ConfigParser.RawConfigParser.read"><code>read()</code></a> call.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.remove_option">
<code>RawConfigParser.remove_option(section, option)</code> </dt> <dd>
<p>Remove the specified <em>option</em> from the specified <em>section</em>. If the section does not exist, raise <a class="reference internal" href="#ConfigParser.NoSectionError" title="ConfigParser.NoSectionError"><code>NoSectionError</code></a>. If the option existed to be removed, return <a class="reference internal" href="constants#True" title="True"><code>True</code></a>; otherwise return <a class="reference internal" href="constants#False" title="False"><code>False</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.remove_section">
<code>RawConfigParser.remove_section(section)</code> </dt> <dd>
<p>Remove the specified <em>section</em> from the configuration. If the section in fact existed, return <code>True</code>. Otherwise return <code>False</code>.</p> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.RawConfigParser.optionxform">
<code>RawConfigParser.optionxform(option)</code> </dt> <dd>
<p>Transforms the option name <em>option</em> as found in an input file or as passed in by client code to the form that should be used in the internal structures. The default implementation returns a lower-case version of <em>option</em>; subclasses may override this or client code can set an attribute of this name on instances to affect this behavior.</p> <p>You don’t necessarily need to subclass a ConfigParser to use this method, you can also re-set it on an instance, to a function that takes a string argument. Setting it to <code>str</code>, for example, would make option names case sensitive:</p> <pre data-language="python">cfgparser = ConfigParser()
...
cfgparser.optionxform = str
</pre> <p>Note that when reading configuration files, whitespace around the option names are stripped before <a class="reference internal" href="#ConfigParser.RawConfigParser.optionxform" title="ConfigParser.RawConfigParser.optionxform"><code>optionxform()</code></a> is called.</p> </dd>
</dl>   <h2 id="id2">2. ConfigParser Objects</h2> <p id="configparser-objects">The <a class="reference internal" href="#ConfigParser.ConfigParser" title="ConfigParser.ConfigParser"><code>ConfigParser</code></a> class extends some methods of the <a class="reference internal" href="#ConfigParser.RawConfigParser" title="ConfigParser.RawConfigParser"><code>RawConfigParser</code></a> interface, adding some optional arguments.</p> <dl class="method"> <dt id="ConfigParser.ConfigParser.get">
<code>ConfigParser.get(section, option[, raw[, vars]])</code> </dt> <dd>
<p>Get an <em>option</em> value for the named <em>section</em>. If <em>vars</em> is provided, it must be a dictionary. The <em>option</em> is looked up in <em>vars</em> (if provided), <em>section</em>, and in <em>defaults</em> in that order.</p> <p>All the <code>'%'</code> interpolations are expanded in the return values, unless the <em>raw</em> argument is true. Values for interpolation keys are looked up in the same manner as the option.</p> </dd>
</dl> <dl class="method"> <dt id="ConfigParser.ConfigParser.items">
<code>ConfigParser.items(section[, raw[, vars]])</code> </dt> <dd>
<p>Return a list of <code>(name, value)</code> pairs for each option in the given <em>section</em>. Optional arguments have the same meaning as for the <a class="reference internal" href="#ConfigParser.ConfigParser.get" title="ConfigParser.ConfigParser.get"><code>get()</code></a> method.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </dd>
</dl>   <h2 id="id3">3. SafeConfigParser Objects</h2> <p id="safeconfigparser-objects">The <a class="reference internal" href="#ConfigParser.SafeConfigParser" title="ConfigParser.SafeConfigParser"><code>SafeConfigParser</code></a> class implements the same extended interface as <a class="reference internal" href="#ConfigParser.ConfigParser" title="ConfigParser.ConfigParser"><code>ConfigParser</code></a>, with the following addition:</p> <dl class="method"> <dt id="ConfigParser.SafeConfigParser.set">
<code>SafeConfigParser.set(section, option, value)</code> </dt> <dd>
<p>If the given section exists, set the given option to the specified value; otherwise raise <a class="reference internal" href="#ConfigParser.NoSectionError" title="ConfigParser.NoSectionError"><code>NoSectionError</code></a>. <em>value</em> must be a string (<a class="reference internal" href="functions#str" title="str"><code>str</code></a> or <a class="reference internal" href="functions#unicode" title="unicode"><code>unicode</code></a>); if not, <a class="reference internal" href="exceptions#exceptions.TypeError" title="exceptions.TypeError"><code>TypeError</code></a> is raised.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> </dd>
</dl>   <h2 id="examples">4. Examples</h2> <p>An example of writing to a configuration file:</p> <pre data-language="python">import ConfigParser

config = ConfigParser.RawConfigParser()

# When adding sections or items, add them in the reverse order of
# how you want them to be displayed in the actual file.
# In addition, please note that using RawConfigParser's and the raw
# mode of ConfigParser's respective set functions, you can assign
# non-string values to keys internally, but will receive an error
# when attempting to write to a file or when you get it in non-raw
# mode. SafeConfigParser does not allow such assignments to take place.
config.add_section('Section1')
config.set('Section1', 'an_int', '15')
config.set('Section1', 'a_bool', 'true')
config.set('Section1', 'a_float', '3.1415')
config.set('Section1', 'baz', 'fun')
config.set('Section1', 'bar', 'Python')
config.set('Section1', 'foo', '%(bar)s is %(baz)s!')

# Writing our configuration file to 'example.cfg'
with open('example.cfg', 'wb') as configfile:
    config.write(configfile)
</pre> <p>An example of reading the configuration file again:</p> <pre data-language="python">import ConfigParser

config = ConfigParser.RawConfigParser()
config.read('example.cfg')

# getfloat() raises an exception if the value is not a float
# getint() and getboolean() also do this for their respective types
a_float = config.getfloat('Section1', 'a_float')
an_int = config.getint('Section1', 'an_int')
print a_float + an_int

# Notice that the next output does not interpolate '%(bar)s' or '%(baz)s'.
# This is because we are using a RawConfigParser().
if config.getboolean('Section1', 'a_bool'):
    print config.get('Section1', 'foo')
</pre> <p>To get interpolation, you will need to use a <a class="reference internal" href="#ConfigParser.ConfigParser" title="ConfigParser.ConfigParser"><code>ConfigParser</code></a> or <a class="reference internal" href="#ConfigParser.SafeConfigParser" title="ConfigParser.SafeConfigParser"><code>SafeConfigParser</code></a>:</p> <pre data-language="python">import ConfigParser

config = ConfigParser.ConfigParser()
config.read('example.cfg')

# Set the third, optional argument of get to 1 if you wish to use raw mode.
print config.get('Section1', 'foo', 0)  # -&gt; "Python is fun!"
print config.get('Section1', 'foo', 1)  # -&gt; "%(bar)s is %(baz)s!"

# The optional fourth argument is a dict with members that will take
# precedence in interpolation.
print config.get('Section1', 'foo', 0, {'bar': 'Documentation',
                                        'baz': 'evil'})
</pre> <p>Defaults are available in all three types of ConfigParsers. They are used in interpolation if an option used is not defined elsewhere.</p> <pre data-language="python">import ConfigParser

# New instance with 'bar' and 'baz' defaulting to 'Life' and 'hard' each
config = ConfigParser.SafeConfigParser({'bar': 'Life', 'baz': 'hard'})
config.read('example.cfg')

print config.get('Section1', 'foo')  # -&gt; "Python is fun!"
config.remove_option('Section1', 'bar')
config.remove_option('Section1', 'baz')
print config.get('Section1', 'foo')  # -&gt; "Life is hard!"
</pre> <p>The function <code>opt_move</code> below can be used to move options between sections:</p> <pre data-language="python">def opt_move(config, section1, section2, option):
    try:
        config.set(section2, option, config.get(section1, option, 1))
    except ConfigParser.NoSectionError:
        # Create non-existent section
        config.add_section(section2)
        opt_move(config, section1, section2, option)
    else:
        config.remove_option(section1, option)
</pre> <p>Some configuration files are known to include settings without values, but which otherwise conform to the syntax supported by <a class="reference internal" href="#module-ConfigParser" title="ConfigParser: Configuration file parser."><code>ConfigParser</code></a>. The <em>allow_no_value</em> parameter to the constructor can be used to indicate that such values should be accepted:</p> <pre data-language="pycon3">&gt;&gt;&gt; import ConfigParser
&gt;&gt;&gt; import io

&gt;&gt;&gt; sample_config = """
... [mysqld]
... user = mysql
... pid-file = /var/run/mysqld/mysqld.pid
... skip-external-locking
... old_passwords = 1
... skip-bdb
... skip-innodb
... """
&gt;&gt;&gt; config = ConfigParser.RawConfigParser(allow_no_value=True)
&gt;&gt;&gt; config.readfp(io.BytesIO(sample_config))

&gt;&gt;&gt; # Settings with values are treated as before:
&gt;&gt;&gt; config.get("mysqld", "user")
'mysql'

&gt;&gt;&gt; # Settings without values provide None:
&gt;&gt;&gt; config.get("mysqld", "skip-bdb")

&gt;&gt;&gt; # Settings which aren't specified still raise an error:
&gt;&gt;&gt; config.get("mysqld", "does-not-exist")
Traceback (most recent call last):
  ...
ConfigParser.NoOptionError: No option 'does-not-exist' in section: 'mysqld'
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/configparser.html" class="_attribution-link">https://docs.python.org/2.7/library/configparser.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
