
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Urllib2 - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" Note ">
  <meta name="keywords" content="urllib, —, extensible, library, for, opening, urls, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/urllib2.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/python~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="urllib2-extensible-library-for-opening-urls"> urllib2 — extensible library for opening URLs</h1> <div class="admonition note" id="module-urllib2"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="#module-urllib2" title="urllib2: Next generation URL opening library."><code>urllib2</code></a> module has been split across several modules in Python 3 named <code>urllib.request</code> and <code>urllib.error</code>. The <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-2to3"><span class="xref std std-term">2to3</span></a> tool will automatically adapt imports when converting your sources to Python 3.</p> </div> <p>The <a class="reference internal" href="#module-urllib2" title="urllib2: Next generation URL opening library."><code>urllib2</code></a> module defines functions and classes which help in opening URLs (mostly HTTP) in a complex world — basic and digest authentication, redirections, cookies and more.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference external" href="http://requests.readthedocs.org/">Requests package</a> is recommended for a higher-level HTTP client interface.</p> </div> <p>The <a class="reference internal" href="#module-urllib2" title="urllib2: Next generation URL opening library."><code>urllib2</code></a> module defines the following functions:</p> <dl class="function"> <dt id="urllib2.urlopen">
<code>urllib2.urlopen(url[, data[, timeout[, cafile[, capath[, cadefault[, context]]]]])</code> </dt> <dd>
<p>Open the URL <em>url</em>, which can be either a string or a <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> object.</p> <p><em>data</em> may be a string specifying additional data to send to the server, or <code>None</code> if no such data is needed. Currently HTTP requests are the only ones that use <em>data</em>; the HTTP request will be a POST instead of a GET when the <em>data</em> parameter is provided. <em>data</em> should be a buffer in the standard <em class="mimetype">application/x-www-form-urlencoded</em> format. The <a class="reference internal" href="urllib#urllib.urlencode" title="urllib.urlencode"><code>urllib.urlencode()</code></a> function takes a mapping or sequence of 2-tuples and returns a string in this format. urllib2 module sends HTTP/1.1 requests with <code>Connection:close</code> header included.</p> <p>The optional <em>timeout</em> parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). This actually only works for HTTP, HTTPS and FTP connections.</p> <p>If <em>context</em> is specified, it must be a <a class="reference internal" href="ssl#ssl.SSLContext" title="ssl.SSLContext"><code>ssl.SSLContext</code></a> instance describing the various SSL options. See <a class="reference internal" href="httplib#httplib.HTTPSConnection" title="httplib.HTTPSConnection"><code>HTTPSConnection</code></a> for more details.</p> <p>The optional <em>cafile</em> and <em>capath</em> parameters specify a set of trusted CA certificates for HTTPS requests. <em>cafile</em> should point to a single file containing a bundle of CA certificates, whereas <em>capath</em> should point to a directory of hashed certificate files. More information can be found in <a class="reference internal" href="ssl#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code>ssl.SSLContext.load_verify_locations()</code></a>.</p> <p>The <em>cadefault</em> parameter is ignored.</p> <p>This function returns a file-like object with three additional methods:</p> <ul class="simple"> <li>
<code>geturl()</code> — return the URL of the resource retrieved, commonly used to determine if a redirect was followed</li> <li>
<code>info()</code> — return the meta-information of the page, such as headers, in the form of an <a class="reference internal" href="mimetools#mimetools.Message" title="mimetools.Message"><code>mimetools.Message</code></a> instance (see <a class="reference external" href="https://www.cs.tut.fi/~jkorpela/http.html">Quick Reference to HTTP Headers</a>)</li> <li>
<code>getcode()</code> — return the HTTP status code of the response.</li> </ul> <p>Raises <a class="reference internal" href="#urllib2.URLError" title="urllib2.URLError"><code>URLError</code></a> on errors.</p> <p>Note that <code>None</code> may be returned if no handler handles the request (though the default installed global <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a> uses <a class="reference internal" href="#urllib2.UnknownHandler" title="urllib2.UnknownHandler"><code>UnknownHandler</code></a> to ensure this never happens).</p> <p>In addition, if proxy settings are detected (for example, when a <code>*_proxy</code> environment variable like <code id="index-0">http_proxy</code> is set), <a class="reference internal" href="#urllib2.ProxyHandler" title="urllib2.ProxyHandler"><code>ProxyHandler</code></a> is default installed and makes sure the requests are handled through the proxy.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span><em>timeout</em> was added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7.9: </span><em>cafile</em>, <em>capath</em>, <em>cadefault</em>, and <em>context</em> were added.</p> </div> </dd>
</dl> <dl class="function"> <dt id="urllib2.install_opener">
<code>urllib2.install_opener(opener)</code> </dt> <dd>
<p>Install an <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a> instance as the default global opener. Installing an opener is only necessary if you want urlopen to use that opener; otherwise, simply call <a class="reference internal" href="#urllib2.OpenerDirector.open" title="urllib2.OpenerDirector.open"><code>OpenerDirector.open()</code></a> instead of <a class="reference internal" href="#urllib2.urlopen" title="urllib2.urlopen"><code>urlopen()</code></a>. The code does not check for a real <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a>, and any class with the appropriate interface will work.</p> </dd>
</dl> <dl class="function"> <dt id="urllib2.build_opener">
<code>urllib2.build_opener([handler, ...])</code> </dt> <dd>
<p>Return an <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a> instance, which chains the handlers in the order given. <em>handler</em>s can be either instances of <a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a>, or subclasses of <a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a> (in which case it must be possible to call the constructor without any parameters). Instances of the following classes will be in front of the <em>handler</em>s, unless the <em>handler</em>s contain them, instances of them or subclasses of them: <a class="reference internal" href="#urllib2.ProxyHandler" title="urllib2.ProxyHandler"><code>ProxyHandler</code></a> (if proxy settings are detected), <a class="reference internal" href="#urllib2.UnknownHandler" title="urllib2.UnknownHandler"><code>UnknownHandler</code></a>, <a class="reference internal" href="#urllib2.HTTPHandler" title="urllib2.HTTPHandler"><code>HTTPHandler</code></a>, <a class="reference internal" href="#urllib2.HTTPDefaultErrorHandler" title="urllib2.HTTPDefaultErrorHandler"><code>HTTPDefaultErrorHandler</code></a>, <a class="reference internal" href="#urllib2.HTTPRedirectHandler" title="urllib2.HTTPRedirectHandler"><code>HTTPRedirectHandler</code></a>, <a class="reference internal" href="#urllib2.FTPHandler" title="urllib2.FTPHandler"><code>FTPHandler</code></a>, <a class="reference internal" href="#urllib2.FileHandler" title="urllib2.FileHandler"><code>FileHandler</code></a>, <a class="reference internal" href="#urllib2.HTTPErrorProcessor" title="urllib2.HTTPErrorProcessor"><code>HTTPErrorProcessor</code></a>.</p> <p>If the Python installation has SSL support (i.e., if the <a class="reference internal" href="ssl#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code>ssl</code></a> module can be imported), <a class="reference internal" href="#urllib2.HTTPSHandler" title="urllib2.HTTPSHandler"><code>HTTPSHandler</code></a> will also be added.</p> <p>Beginning in Python 2.3, a <a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a> subclass may also change its <code>handler_order</code> attribute to modify its position in the handlers list.</p> </dd>
</dl> <p>The following exceptions are raised as appropriate:</p> <dl class="exception"> <dt id="urllib2.URLError">
<code>exception urllib2.URLError</code> </dt> <dd>
<p>The handlers raise this exception (or derived exceptions) when they run into a problem. It is a subclass of <a class="reference internal" href="exceptions#exceptions.IOError" title="exceptions.IOError"><code>IOError</code></a>.</p> <dl class="attribute"> <dt id="urllib2.URLError.reason">
<code>reason</code> </dt> <dd>
<p>The reason for this error. It can be a message string or another exception instance (<a class="reference internal" href="socket#socket.error" title="socket.error"><code>socket.error</code></a> for remote URLs, <a class="reference internal" href="exceptions#exceptions.OSError" title="exceptions.OSError"><code>OSError</code></a> for local URLs).</p> </dd>
</dl> </dd>
</dl> <dl class="exception"> <dt id="urllib2.HTTPError">
<code>exception urllib2.HTTPError</code> </dt> <dd>
<p>Though being an exception (a subclass of <a class="reference internal" href="#urllib2.URLError" title="urllib2.URLError"><code>URLError</code></a>), an <a class="reference internal" href="#urllib2.HTTPError" title="urllib2.HTTPError"><code>HTTPError</code></a> can also function as a non-exceptional file-like return value (the same thing that <a class="reference internal" href="#urllib2.urlopen" title="urllib2.urlopen"><code>urlopen()</code></a> returns). This is useful when handling exotic HTTP errors, such as requests for authentication.</p> <dl class="attribute"> <dt id="urllib2.HTTPError.code">
<code>code</code> </dt> <dd>
<p>An HTTP status code as defined in <a class="reference external" href="http://www.faqs.org/rfcs/rfc2616.html">RFC 2616</a>. This numeric value corresponds to a value found in the dictionary of codes as found in <a class="reference internal" href="basehttpserver#BaseHTTPServer.BaseHTTPRequestHandler.responses" title="BaseHTTPServer.BaseHTTPRequestHandler.responses"><code>BaseHTTPServer.BaseHTTPRequestHandler.responses</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="urllib2.HTTPError.reason">
<code>reason</code> </dt> <dd>
<p>The reason for this error. It can be a message string or another exception instance.</p> </dd>
</dl> </dd>
</dl> <p>The following classes are provided:</p> <dl class="class"> <dt id="urllib2.Request">
<code>class urllib2.Request(url[, data][, headers][, origin_req_host][, unverifiable])</code> </dt> <dd>
<p>This class is an abstraction of a URL request.</p> <p><em>url</em> should be a string containing a valid URL.</p> <p><em>data</em> may be a string specifying additional data to send to the server, or <code>None</code> if no such data is needed. Currently HTTP requests are the only ones that use <em>data</em>; the HTTP request will be a POST instead of a GET when the <em>data</em> parameter is provided. <em>data</em> should be a buffer in the standard <em class="mimetype">application/x-www-form-urlencoded</em> format. The <a class="reference internal" href="urllib#urllib.urlencode" title="urllib.urlencode"><code>urllib.urlencode()</code></a> function takes a mapping or sequence of 2-tuples and returns a string in this format.</p> <p><em>headers</em> should be a dictionary, and will be treated as if <a class="reference internal" href="#urllib2.Request.add_header" title="urllib2.Request.add_header"><code>add_header()</code></a> was called with each key and value as arguments. This is often used to “spoof” the <code>User-Agent</code> header value, which is used by a browser to identify itself – some HTTP servers only allow requests coming from common browsers as opposed to scripts. For example, Mozilla Firefox may identify itself as <code>"Mozilla/5.0
(X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11"</code>, while <a class="reference internal" href="#module-urllib2" title="urllib2: Next generation URL opening library."><code>urllib2</code></a>’s default user agent string is <code>"Python-urllib/2.6"</code> (on Python 2.6).</p> <p>The final two arguments are only of interest for correct handling of third-party HTTP cookies:</p> <p><em>origin_req_host</em> should be the request-host of the origin transaction, as defined by <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2965.html" id="index-1"><strong>RFC 2965</strong></a>. It defaults to <code>cookielib.request_host(self)</code>. This is the host name or IP address of the original request that was initiated by the user. For example, if the request is for an image in an HTML document, this should be the request-host of the request for the page containing the image.</p> <p><em>unverifiable</em> should indicate whether the request is unverifiable, as defined by RFC 2965. It defaults to <code>False</code>. An unverifiable request is one whose URL the user did not have the option to approve. For example, if the request is for an image in an HTML document, and the user had no option to approve the automatic fetching of the image, this should be true.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.OpenerDirector">
<code>class urllib2.OpenerDirector</code> </dt> <dd>
<p>The <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a> class opens URLs via <a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a>s chained together. It manages the chaining of handlers, and recovery from errors.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.BaseHandler">
<code>class urllib2.BaseHandler</code> </dt> <dd>
<p>This is the base class for all registered handlers — and handles only the simple mechanics of registration.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.HTTPDefaultErrorHandler">
<code>class urllib2.HTTPDefaultErrorHandler</code> </dt> <dd>
<p>A class which defines a default handler for HTTP error responses; all responses are turned into <a class="reference internal" href="#urllib2.HTTPError" title="urllib2.HTTPError"><code>HTTPError</code></a> exceptions.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.HTTPRedirectHandler">
<code>class urllib2.HTTPRedirectHandler</code> </dt> <dd>
<p>A class to handle redirections.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.HTTPCookieProcessor">
<code>class urllib2.HTTPCookieProcessor([cookiejar])</code> </dt> <dd>
<p>A class to handle HTTP Cookies.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.ProxyHandler">
<code>class urllib2.ProxyHandler([proxies])</code> </dt> <dd>
<p>Cause requests to go through a proxy. If <em>proxies</em> is given, it must be a dictionary mapping protocol names to URLs of proxies. The default is to read the list of proxies from the environment variables <code id="index-2">&lt;protocol&gt;_proxy</code>. If no proxy environment variables are set, then in a Windows environment proxy settings are obtained from the registry’s Internet Settings section, and in a Mac OS X environment proxy information is retrieved from the OS X System Configuration Framework.</p> <p>To disable autodetected proxy pass an empty dictionary.</p>  <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>HTTP_PROXY</code> will be ignored if a variable <code>REQUEST_METHOD</code> is set; see the documentation on <a class="reference internal" href="urllib#urllib.getproxies" title="urllib.getproxies"><code>getproxies()</code></a>.</p> </div>  </dd>
</dl> <dl class="class"> <dt id="urllib2.HTTPPasswordMgr">
<code>class urllib2.HTTPPasswordMgr</code> </dt> <dd>
<p>Keep a database of <code>(realm, uri) -&gt; (user, password)</code> mappings.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.HTTPPasswordMgrWithDefaultRealm">
<code>class urllib2.HTTPPasswordMgrWithDefaultRealm</code> </dt> <dd>
<p>Keep a database of <code>(realm, uri) -&gt; (user, password)</code> mappings. A realm of <code>None</code> is considered a catch-all realm, which is searched if no other realm fits.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.AbstractBasicAuthHandler">
<code>class urllib2.AbstractBasicAuthHandler([password_mgr])</code> </dt> <dd>
<p>This is a mixin class that helps with HTTP authentication, both to the remote host and to a proxy. <em>password_mgr</em>, if given, should be something that is compatible with <a class="reference internal" href="#urllib2.HTTPPasswordMgr" title="urllib2.HTTPPasswordMgr"><code>HTTPPasswordMgr</code></a>; refer to section <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr Objects</span></a> for information on the interface that must be supported.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.HTTPBasicAuthHandler">
<code>class urllib2.HTTPBasicAuthHandler([password_mgr])</code> </dt> <dd>
<p>Handle authentication with the remote host. <em>password_mgr</em>, if given, should be something that is compatible with <a class="reference internal" href="#urllib2.HTTPPasswordMgr" title="urllib2.HTTPPasswordMgr"><code>HTTPPasswordMgr</code></a>; refer to section <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr Objects</span></a> for information on the interface that must be supported.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.ProxyBasicAuthHandler">
<code>class urllib2.ProxyBasicAuthHandler([password_mgr])</code> </dt> <dd>
<p>Handle authentication with the proxy. <em>password_mgr</em>, if given, should be something that is compatible with <a class="reference internal" href="#urllib2.HTTPPasswordMgr" title="urllib2.HTTPPasswordMgr"><code>HTTPPasswordMgr</code></a>; refer to section <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr Objects</span></a> for information on the interface that must be supported.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.AbstractDigestAuthHandler">
<code>class urllib2.AbstractDigestAuthHandler([password_mgr])</code> </dt> <dd>
<p>This is a mixin class that helps with HTTP authentication, both to the remote host and to a proxy. <em>password_mgr</em>, if given, should be something that is compatible with <a class="reference internal" href="#urllib2.HTTPPasswordMgr" title="urllib2.HTTPPasswordMgr"><code>HTTPPasswordMgr</code></a>; refer to section <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr Objects</span></a> for information on the interface that must be supported.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.HTTPDigestAuthHandler">
<code>class urllib2.HTTPDigestAuthHandler([password_mgr])</code> </dt> <dd>
<p>Handle authentication with the remote host. <em>password_mgr</em>, if given, should be something that is compatible with <a class="reference internal" href="#urllib2.HTTPPasswordMgr" title="urllib2.HTTPPasswordMgr"><code>HTTPPasswordMgr</code></a>; refer to section <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr Objects</span></a> for information on the interface that must be supported.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.ProxyDigestAuthHandler">
<code>class urllib2.ProxyDigestAuthHandler([password_mgr])</code> </dt> <dd>
<p>Handle authentication with the proxy. <em>password_mgr</em>, if given, should be something that is compatible with <a class="reference internal" href="#urllib2.HTTPPasswordMgr" title="urllib2.HTTPPasswordMgr"><code>HTTPPasswordMgr</code></a>; refer to section <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">HTTPPasswordMgr Objects</span></a> for information on the interface that must be supported.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.HTTPHandler">
<code>class urllib2.HTTPHandler</code> </dt> <dd>
<p>A class to handle opening of HTTP URLs.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.HTTPSHandler">
<code>class urllib2.HTTPSHandler([debuglevel[, context]])</code> </dt> <dd>
<p>A class to handle opening of HTTPS URLs. <em>context</em> has the same meaning as for <a class="reference internal" href="httplib#httplib.HTTPSConnection" title="httplib.HTTPSConnection"><code>httplib.HTTPSConnection</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7.9: </span><em>context</em> added.</p> </div> </dd>
</dl> <dl class="class"> <dt id="urllib2.FileHandler">
<code>class urllib2.FileHandler</code> </dt> <dd>
<p>Open local files.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.FTPHandler">
<code>class urllib2.FTPHandler</code> </dt> <dd>
<p>Open FTP URLs.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.CacheFTPHandler">
<code>class urllib2.CacheFTPHandler</code> </dt> <dd>
<p>Open FTP URLs, keeping a cache of open FTP connections to minimize delays.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.UnknownHandler">
<code>class urllib2.UnknownHandler</code> </dt> <dd>
<p>A catch-all class to handle unknown URLs.</p> </dd>
</dl> <dl class="class"> <dt id="urllib2.HTTPErrorProcessor">
<code>class urllib2.HTTPErrorProcessor</code> </dt> <dd>
<p>Process HTTP error responses.</p> </dd>
</dl>  <h2 id="id1">1. Request Objects</h2> <p id="request-objects">The following methods describe all of <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a>’s public interface, and so all must be overridden in subclasses.</p> <dl class="method"> <dt id="urllib2.Request.add_data">
<code>Request.add_data(data)</code> </dt> <dd>
<p>Set the <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> data to <em>data</em>. This is ignored by all handlers except HTTP handlers — and there it should be a byte string, and will change the request to be <code>POST</code> rather than <code>GET</code>.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.get_method">
<code>Request.get_method()</code> </dt> <dd>
<p>Return a string indicating the HTTP request method. This is only meaningful for HTTP requests, and currently always returns <code>'GET'</code> or <code>'POST'</code>.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.has_data">
<code>Request.has_data()</code> </dt> <dd>
<p>Return whether the instance has a non-<code>None</code> data.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.get_data">
<code>Request.get_data()</code> </dt> <dd>
<p>Return the instance’s data.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.add_header">
<code>Request.add_header(key, val)</code> </dt> <dd>
<p>Add another header to the request. Headers are currently ignored by all handlers except HTTP handlers, where they are added to the list of headers sent to the server. Note that there cannot be more than one header with the same name, and later calls will overwrite previous calls in case the <em>key</em> collides. Currently, this is no loss of HTTP functionality, since all headers which have meaning when used more than once have a (header-specific) way of gaining the same functionality using only one header.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.add_unredirected_header">
<code>Request.add_unredirected_header(key, header)</code> </dt> <dd>
<p>Add a header that will not be added to a redirected request.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.has_header">
<code>Request.has_header(header)</code> </dt> <dd>
<p>Return whether the instance has the named header (checks both regular and unredirected).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.get_full_url">
<code>Request.get_full_url()</code> </dt> <dd>
<p>Return the URL given in the constructor.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.get_type">
<code>Request.get_type()</code> </dt> <dd>
<p>Return the type of the URL — also known as the scheme.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.get_host">
<code>Request.get_host()</code> </dt> <dd>
<p>Return the host to which a connection will be made.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.get_selector">
<code>Request.get_selector()</code> </dt> <dd>
<p>Return the selector — the part of the URL that is sent to the server.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.get_header">
<code>Request.get_header(header_name, default=None)</code> </dt> <dd>
<p>Return the value of the given header. If the header is not present, return the default value.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.header_items">
<code>Request.header_items()</code> </dt> <dd>
<p>Return a list of tuples (header_name, header_value) of the Request headers.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.set_proxy">
<code>Request.set_proxy(host, type)</code> </dt> <dd>
<p>Prepare the request by connecting to a proxy server. The <em>host</em> and <em>type</em> will replace those of the instance, and the instance’s selector will be the original URL given in the constructor.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.get_origin_req_host">
<code>Request.get_origin_req_host()</code> </dt> <dd>
<p>Return the request-host of the origin transaction, as defined by <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2965.html" id="index-3"><strong>RFC 2965</strong></a>. See the documentation for the <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> constructor.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.Request.is_unverifiable">
<code>Request.is_unverifiable()</code> </dt> <dd>
<p>Return whether the request is unverifiable, as defined by RFC 2965. See the documentation for the <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> constructor.</p> </dd>
</dl>   <h2 id="opener-director-objects">2. OpenerDirector Objects</h2> <p id="openerdirector-objects"><a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a> instances have the following methods:</p> <dl class="method"> <dt id="urllib2.OpenerDirector.add_handler">
<code>OpenerDirector.add_handler(handler)</code> </dt> <dd>
<p><em>handler</em> should be an instance of <a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a>. The following methods are searched, and added to the possible chains (note that HTTP errors are a special case).</p> <ul class="simple"> <li>
<code><em>protocol</em>_open</code> — signal that the handler knows how to open <em>protocol</em> URLs.</li> <li>
<code>http_error_<em>type</em></code> — signal that the handler knows how to handle HTTP errors with HTTP error code <em>type</em>.</li> <li>
<code><em>protocol</em>_error</code> — signal that the handler knows how to handle errors from (non-<code>http</code>) <em>protocol</em>.</li> <li>
<code><em>protocol</em>_request</code> — signal that the handler knows how to pre-process <em>protocol</em> requests.</li> <li>
<code><em>protocol</em>_response</code> — signal that the handler knows how to post-process <em>protocol</em> responses.</li> </ul> </dd>
</dl> <dl class="method"> <dt id="urllib2.OpenerDirector.open">
<code>OpenerDirector.open(url[, data][, timeout])</code> </dt> <dd>
<p>Open the given <em>url</em> (which can be a request object or a string), optionally passing the given <em>data</em>. Arguments, return values and exceptions raised are the same as those of <a class="reference internal" href="#urllib2.urlopen" title="urllib2.urlopen"><code>urlopen()</code></a> (which simply calls the <a class="reference internal" href="functions#open" title="open"><code>open()</code></a> method on the currently installed global <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a>). The optional <em>timeout</em> parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). The timeout feature actually works only for HTTP, HTTPS and FTP connections).</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span><em>timeout</em> was added.</p> </div> </dd>
</dl> <dl class="method"> <dt id="urllib2.OpenerDirector.error">
<code>OpenerDirector.error(proto[, arg[, ...]])</code> </dt> <dd>
<p>Handle an error of the given protocol. This will call the registered error handlers for the given protocol with the given arguments (which are protocol specific). The HTTP protocol is a special case which uses the HTTP response code to determine the specific error handler; refer to the <code>http_error_*()</code> methods of the handler classes.</p> <p>Return values and exceptions raised are the same as those of <a class="reference internal" href="#urllib2.urlopen" title="urllib2.urlopen"><code>urlopen()</code></a>.</p> </dd>
</dl> <p>OpenerDirector objects open URLs in three stages:</p> <p>The order in which these methods are called within each stage is determined by sorting the handler instances.</p> <ol class="arabic"> <li>Every handler with a method named like <code><em>protocol</em>_request</code> has that method called to pre-process the request.</li> <li>
<p>Handlers with a method named like <code><em>protocol</em>_open</code> are called to handle the request. This stage ends when a handler either returns a non-<a class="reference internal" href="constants#None" title="None"><code>None</code></a> value (ie. a response), or raises an exception (usually <a class="reference internal" href="#urllib2.URLError" title="urllib2.URLError"><code>URLError</code></a>). Exceptions are allowed to propagate.</p> <p>In fact, the above algorithm is first tried for methods named <code>default_open()</code>. If all such methods return <a class="reference internal" href="constants#None" title="None"><code>None</code></a>, the algorithm is repeated for methods named like <code><em>protocol</em>_open</code>. If all such methods return <a class="reference internal" href="constants#None" title="None"><code>None</code></a>, the algorithm is repeated for methods named <code>unknown_open()</code>.</p> <p>Note that the implementation of these methods may involve calls of the parent <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a> instance’s <a class="reference internal" href="#urllib2.OpenerDirector.open" title="urllib2.OpenerDirector.open"><code>open()</code></a> and <a class="reference internal" href="#urllib2.OpenerDirector.error" title="urllib2.OpenerDirector.error"><code>error()</code></a> methods.</p> </li> <li>Every handler with a method named like <code><em>protocol</em>_response</code> has that method called to post-process the response.</li> </ol>   <h2 id="base-handler-objects">3. BaseHandler Objects</h2> <p id="basehandler-objects"><a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a> objects provide a couple of methods that are directly useful, and others that are meant to be used by derived classes. These are intended for direct use:</p> <dl class="method"> <dt id="urllib2.BaseHandler.add_parent">
<code>BaseHandler.add_parent(director)</code> </dt> <dd>
<p>Add a director as parent.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.BaseHandler.close">
<code>BaseHandler.close()</code> </dt> <dd>
<p>Remove any parents.</p> </dd>
</dl> <p>The following attributes and methods should only be used by classes derived from <a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The convention has been adopted that subclasses defining <code>protocol_request()</code> or <code>protocol_response()</code> methods are named <code>*Processor</code>; all others are named <code>*Handler</code>.</p> </div> <dl class="attribute"> <dt id="urllib2.BaseHandler.parent">
<code>BaseHandler.parent</code> </dt> <dd>
<p>A valid <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a>, which can be used to open using a different protocol, or handle errors.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.BaseHandler.default_open">
<code>BaseHandler.default_open(req)</code> </dt> <dd>
<p>This method is <em>not</em> defined in <a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a>, but subclasses should define it if they want to catch all URLs.</p> <p>This method, if implemented, will be called by the parent <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a>. It should return a file-like object as described in the return value of the <a class="reference internal" href="functions#open" title="open"><code>open()</code></a> of <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a>, or <code>None</code>. It should raise <a class="reference internal" href="#urllib2.URLError" title="urllib2.URLError"><code>URLError</code></a>, unless a truly exceptional thing happens (for example, <a class="reference internal" href="exceptions#exceptions.MemoryError" title="exceptions.MemoryError"><code>MemoryError</code></a> should not be mapped to <a class="reference internal" href="#urllib2.URLError" title="urllib2.URLError"><code>URLError</code></a>).</p> <p>This method will be called before any protocol-specific open method.</p> </dd>
</dl> <dl class="method"> <dt>
<code>BaseHandler.protocol_open(req)</code> </dt> <dd>
<p>(“protocol” is to be replaced by the protocol name.)</p> <p>This method is <em>not</em> defined in <a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a>, but subclasses should define it if they want to handle URLs with the given <em>protocol</em>.</p> <p>This method, if defined, will be called by the parent <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a>. Return values should be the same as for <a class="reference internal" href="#urllib2.BaseHandler.default_open" title="urllib2.BaseHandler.default_open"><code>default_open()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.BaseHandler.unknown_open">
<code>BaseHandler.unknown_open(req)</code> </dt> <dd>
<p>This method is <em>not</em> defined in <a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a>, but subclasses should define it if they want to catch all URLs with no specific registered handler to open it.</p> <p>This method, if implemented, will be called by the <a class="reference internal" href="#urllib2.BaseHandler.parent" title="urllib2.BaseHandler.parent"><code>parent</code></a> <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a>. Return values should be the same as for <a class="reference internal" href="#urllib2.BaseHandler.default_open" title="urllib2.BaseHandler.default_open"><code>default_open()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.BaseHandler.http_error_default">
<code>BaseHandler.http_error_default(req, fp, code, msg, hdrs)</code> </dt> <dd>
<p>This method is <em>not</em> defined in <a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a>, but subclasses should override it if they intend to provide a catch-all for otherwise unhandled HTTP errors. It will be called automatically by the <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a> getting the error, and should not normally be called in other circumstances.</p> <p><em>req</em> will be a <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> object, <em>fp</em> will be a file-like object with the HTTP error body, <em>code</em> will be the three-digit code of the error, <em>msg</em> will be the user-visible explanation of the code and <em>hdrs</em> will be a mapping object with the headers of the error.</p> <p>Return values and exceptions raised should be the same as those of <a class="reference internal" href="#urllib2.urlopen" title="urllib2.urlopen"><code>urlopen()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.BaseHandler.http_error_nnn">
<code>BaseHandler.http_error_nnn(req, fp, code, msg, hdrs)</code> </dt> <dd>
<p><em>nnn</em> should be a three-digit HTTP error code. This method is also not defined in <a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a>, but will be called, if it exists, on an instance of a subclass, when an HTTP error with code <em>nnn</em> occurs.</p> <p>Subclasses should override this method to handle specific HTTP errors.</p> <p>Arguments, return values and exceptions raised should be the same as for <a class="reference internal" href="#urllib2.BaseHandler.http_error_default" title="urllib2.BaseHandler.http_error_default"><code>http_error_default()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt>
<code>BaseHandler.protocol_request(req)</code> </dt> <dd>
<p>(“protocol” is to be replaced by the protocol name.)</p> <p>This method is <em>not</em> defined in <a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a>, but subclasses should define it if they want to pre-process requests of the given <em>protocol</em>.</p> <p>This method, if defined, will be called by the parent <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a>. <em>req</em> will be a <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> object. The return value should be a <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> object.</p> </dd>
</dl> <dl class="method"> <dt>
<code>BaseHandler.protocol_response(req, response)</code> </dt> <dd>
<p>(“protocol” is to be replaced by the protocol name.)</p> <p>This method is <em>not</em> defined in <a class="reference internal" href="#urllib2.BaseHandler" title="urllib2.BaseHandler"><code>BaseHandler</code></a>, but subclasses should define it if they want to post-process responses of the given <em>protocol</em>.</p> <p>This method, if defined, will be called by the parent <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a>. <em>req</em> will be a <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> object. <em>response</em> will be an object implementing the same interface as the return value of <a class="reference internal" href="#urllib2.urlopen" title="urllib2.urlopen"><code>urlopen()</code></a>. The return value should implement the same interface as the return value of <a class="reference internal" href="#urllib2.urlopen" title="urllib2.urlopen"><code>urlopen()</code></a>.</p> </dd>
</dl>   <h2 id="http-redirect-handler">4. HTTPRedirectHandler Objects</h2> <div class="admonition note" id="httpredirecthandler-objects"> <p class="admonition-title">Note</p> <p>Some HTTP redirections require action from this module’s client code. If this is the case, <a class="reference internal" href="#urllib2.HTTPError" title="urllib2.HTTPError"><code>HTTPError</code></a> is raised. See <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html" id="index-4"><strong>RFC 2616</strong></a> for details of the precise meanings of the various redirection codes.</p> </div> <dl class="method"> <dt id="urllib2.HTTPRedirectHandler.redirect_request">
<code>HTTPRedirectHandler.redirect_request(req, fp, code, msg, hdrs, newurl)</code> </dt> <dd>
<p>Return a <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> or <code>None</code> in response to a redirect. This is called by the default implementations of the <code>http_error_30*()</code> methods when a redirection is received from the server. If a redirection should take place, return a new <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> to allow <code>http_error_30*()</code> to perform the redirect to <em>newurl</em>. Otherwise, raise <a class="reference internal" href="#urllib2.HTTPError" title="urllib2.HTTPError"><code>HTTPError</code></a> if no other handler should try to handle this URL, or return <code>None</code> if you can’t but another handler might.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The default implementation of this method does not strictly follow <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html" id="index-5"><strong>RFC 2616</strong></a>, which says that 301 and 302 responses to <code>POST</code> requests must not be automatically redirected without confirmation by the user. In reality, browsers do allow automatic redirection of these responses, changing the POST to a <code>GET</code>, and the default implementation reproduces this behavior.</p> </div> </dd>
</dl> <dl class="method"> <dt id="urllib2.HTTPRedirectHandler.http_error_301">
<code>HTTPRedirectHandler.http_error_301(req, fp, code, msg, hdrs)</code> </dt> <dd>
<p>Redirect to the <code>Location:</code> or <code>URI:</code> URL. This method is called by the parent <a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a> when getting an HTTP ‘moved permanently’ response.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.HTTPRedirectHandler.http_error_302">
<code>HTTPRedirectHandler.http_error_302(req, fp, code, msg, hdrs)</code> </dt> <dd>
<p>The same as <a class="reference internal" href="#urllib2.HTTPRedirectHandler.http_error_301" title="urllib2.HTTPRedirectHandler.http_error_301"><code>http_error_301()</code></a>, but called for the ‘found’ response.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.HTTPRedirectHandler.http_error_303">
<code>HTTPRedirectHandler.http_error_303(req, fp, code, msg, hdrs)</code> </dt> <dd>
<p>The same as <a class="reference internal" href="#urllib2.HTTPRedirectHandler.http_error_301" title="urllib2.HTTPRedirectHandler.http_error_301"><code>http_error_301()</code></a>, but called for the ‘see other’ response.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.HTTPRedirectHandler.http_error_307">
<code>HTTPRedirectHandler.http_error_307(req, fp, code, msg, hdrs)</code> </dt> <dd>
<p>The same as <a class="reference internal" href="#urllib2.HTTPRedirectHandler.http_error_301" title="urllib2.HTTPRedirectHandler.http_error_301"><code>http_error_301()</code></a>, but called for the ‘temporary redirect’ response.</p> </dd>
</dl>   <h2 id="http-cookie-processor">5. HTTPCookieProcessor Objects</h2> <div class="versionadded" id="httpcookieprocessor-objects"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> <p><a class="reference internal" href="#urllib2.HTTPCookieProcessor" title="urllib2.HTTPCookieProcessor"><code>HTTPCookieProcessor</code></a> instances have one attribute:</p> <dl class="attribute"> <dt id="urllib2.HTTPCookieProcessor.cookiejar">
<code>HTTPCookieProcessor.cookiejar</code> </dt> <dd>
<p>The <a class="reference internal" href="cookielib#cookielib.CookieJar" title="cookielib.CookieJar"><code>cookielib.CookieJar</code></a> in which cookies are stored.</p> </dd>
</dl>   <h2 id="proxy-handler">6. ProxyHandler Objects</h2> <dl class="method" id="proxyhandler-objects"> <dt>
<code>ProxyHandler.protocol_open(request)</code> </dt> <dd>
<p>(“protocol” is to be replaced by the protocol name.)</p> <p>The <a class="reference internal" href="#urllib2.ProxyHandler" title="urllib2.ProxyHandler"><code>ProxyHandler</code></a> will have a method <code><em>protocol</em>_open</code> for every <em>protocol</em> which has a proxy in the <em>proxies</em> dictionary given in the constructor. The method will modify requests to go through the proxy, by calling <code>request.set_proxy()</code>, and call the next handler in the chain to actually execute the protocol.</p> </dd>
</dl>   <h2 id="http-password-mgr">7. HTTPPasswordMgr Objects</h2> <p id="httppasswordmgr-objects">These methods are available on <a class="reference internal" href="#urllib2.HTTPPasswordMgr" title="urllib2.HTTPPasswordMgr"><code>HTTPPasswordMgr</code></a> and <a class="reference internal" href="#urllib2.HTTPPasswordMgrWithDefaultRealm" title="urllib2.HTTPPasswordMgrWithDefaultRealm"><code>HTTPPasswordMgrWithDefaultRealm</code></a> objects.</p> <dl class="method"> <dt id="urllib2.HTTPPasswordMgr.add_password">
<code>HTTPPasswordMgr.add_password(realm, uri, user, passwd)</code> </dt> <dd>
<p><em>uri</em> can be either a single URI, or a sequence of URIs. <em>realm</em>, <em>user</em> and <em>passwd</em> must be strings. This causes <code>(user, passwd)</code> to be used as authentication tokens when authentication for <em>realm</em> and a super-URI of any of the given URIs is given.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.HTTPPasswordMgr.find_user_password">
<code>HTTPPasswordMgr.find_user_password(realm, authuri)</code> </dt> <dd>
<p>Get user/password for given realm and URI, if any. This method will return <code>(None, None)</code> if there is no matching user/password.</p> <p>For <a class="reference internal" href="#urllib2.HTTPPasswordMgrWithDefaultRealm" title="urllib2.HTTPPasswordMgrWithDefaultRealm"><code>HTTPPasswordMgrWithDefaultRealm</code></a> objects, the realm <code>None</code> will be searched if the given <em>realm</em> has no matching user/password.</p> </dd>
</dl>   <h2 id="abstract-basic-auth-handler">8. AbstractBasicAuthHandler Objects</h2> <dl class="method" id="abstractbasicauthhandler-objects"> <dt id="urllib2.AbstractBasicAuthHandler.http_error_auth_reqed">
<code>AbstractBasicAuthHandler.http_error_auth_reqed(authreq, host, req, headers)</code> </dt> <dd>
<p>Handle an authentication request by getting a user/password pair, and re-trying the request. <em>authreq</em> should be the name of the header where the information about the realm is included in the request, <em>host</em> specifies the URL and path to authenticate for, <em>req</em> should be the (failed) <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> object, and <em>headers</em> should be the error headers.</p> <p><em>host</em> is either an authority (e.g. <code>"python.org"</code>) or a URL containing an authority component (e.g. <code>"http://python.org/"</code>). In either case, the authority must not contain a userinfo component (so, <code>"python.org"</code> and <code>"python.org:80"</code> are fine, <code>"joe:password@python.org"</code> is not).</p> </dd>
</dl>   <h2 id="http-basic-auth-handler">9. HTTPBasicAuthHandler Objects</h2> <dl class="method" id="httpbasicauthhandler-objects"> <dt id="urllib2.HTTPBasicAuthHandler.http_error_401">
<code>HTTPBasicAuthHandler.http_error_401(req, fp, code, msg, hdrs)</code> </dt> <dd>
<p>Retry the request with authentication information, if available.</p> </dd>
</dl>   <h2 id="proxy-basic-auth-handler">10. ProxyBasicAuthHandler Objects</h2> <dl class="method" id="proxybasicauthhandler-objects"> <dt id="urllib2.ProxyBasicAuthHandler.http_error_407">
<code>ProxyBasicAuthHandler.http_error_407(req, fp, code, msg, hdrs)</code> </dt> <dd>
<p>Retry the request with authentication information, if available.</p> </dd>
</dl>   <h2 id="abstract-digest-auth-handler">11. AbstractDigestAuthHandler Objects</h2> <dl class="method" id="abstractdigestauthhandler-objects"> <dt id="urllib2.AbstractDigestAuthHandler.http_error_auth_reqed">
<code>AbstractDigestAuthHandler.http_error_auth_reqed(authreq, host, req, headers)</code> </dt> <dd>
<p><em>authreq</em> should be the name of the header where the information about the realm is included in the request, <em>host</em> should be the host to authenticate to, <em>req</em> should be the (failed) <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> object, and <em>headers</em> should be the error headers.</p> </dd>
</dl>   <h2 id="http-digest-auth-handler">12. HTTPDigestAuthHandler Objects</h2> <dl class="method" id="httpdigestauthhandler-objects"> <dt id="urllib2.HTTPDigestAuthHandler.http_error_401">
<code>HTTPDigestAuthHandler.http_error_401(req, fp, code, msg, hdrs)</code> </dt> <dd>
<p>Retry the request with authentication information, if available.</p> </dd>
</dl>   <h2 id="proxy-digest-auth-handler">13. ProxyDigestAuthHandler Objects</h2> <dl class="method" id="proxydigestauthhandler-objects"> <dt id="urllib2.ProxyDigestAuthHandler.http_error_407">
<code>ProxyDigestAuthHandler.http_error_407(req, fp, code, msg, hdrs)</code> </dt> <dd>
<p>Retry the request with authentication information, if available.</p> </dd>
</dl>   <h2 id="http-handler-objects">14. HTTPHandler Objects</h2> <dl class="method" id="httphandler-objects"> <dt id="urllib2.HTTPHandler.http_open">
<code>HTTPHandler.http_open(req)</code> </dt> <dd>
<p>Send an HTTP request, which can be either GET or POST, depending on <code>req.has_data()</code>.</p> </dd>
</dl>   <h2 id="https-handler-objects">15. HTTPSHandler Objects</h2> <dl class="method" id="httpshandler-objects"> <dt id="urllib2.HTTPSHandler.https_open">
<code>HTTPSHandler.https_open(req)</code> </dt> <dd>
<p>Send an HTTPS request, which can be either GET or POST, depending on <code>req.has_data()</code>.</p> </dd>
</dl>   <h2 id="file-handler-objects">16. FileHandler Objects</h2> <dl class="method" id="filehandler-objects"> <dt id="urllib2.FileHandler.file_open">
<code>FileHandler.file_open(req)</code> </dt> <dd>
<p>Open the file locally, if there is no host name, or the host name is <code>'localhost'</code>. Change the protocol to <code>ftp</code> otherwise, and retry opening it using <code>parent</code>.</p> </dd>
</dl>   <h2 id="ftp-handler-objects">17. FTPHandler Objects</h2> <dl class="method" id="ftphandler-objects"> <dt id="urllib2.FTPHandler.ftp_open">
<code>FTPHandler.ftp_open(req)</code> </dt> <dd>
<p>Open the FTP file indicated by <em>req</em>. The login is always done with empty username and password.</p> </dd>
</dl>   <h2 id="cacheftp-handler-objects">18. CacheFTPHandler Objects</h2> <p id="cacheftphandler-objects"><a class="reference internal" href="#urllib2.CacheFTPHandler" title="urllib2.CacheFTPHandler"><code>CacheFTPHandler</code></a> objects are <a class="reference internal" href="#urllib2.FTPHandler" title="urllib2.FTPHandler"><code>FTPHandler</code></a> objects with the following additional methods:</p> <dl class="method"> <dt id="urllib2.CacheFTPHandler.setTimeout">
<code>CacheFTPHandler.setTimeout(t)</code> </dt> <dd>
<p>Set timeout of connections to <em>t</em> seconds.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.CacheFTPHandler.setMaxConns">
<code>CacheFTPHandler.setMaxConns(m)</code> </dt> <dd>
<p>Set maximum number of cached connections to <em>m</em>.</p> </dd>
</dl>   <h2 id="unknown-handler-objects">19. UnknownHandler Objects</h2> <dl class="method" id="unknownhandler-objects"> <dt id="urllib2.UnknownHandler.unknown_open">
<code>UnknownHandler.unknown_open()</code> </dt> <dd>
<p>Raise a <a class="reference internal" href="#urllib2.URLError" title="urllib2.URLError"><code>URLError</code></a> exception.</p> </dd>
</dl>   <h2 id="http-error-processor-objects">20. HTTPErrorProcessor Objects</h2> <div class="versionadded" id="httperrorprocessor-objects"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> <dl class="method"> <dt id="urllib2.HTTPErrorProcessor.http_response">
<code>HTTPErrorProcessor.http_response()</code> </dt> <dd>
<p>Process HTTP error responses.</p> <p>For 200 error codes, the response object is returned immediately.</p> <p>For non-200 error codes, this simply passes the job on to the <code><em>protocol</em>_error_code</code> handler methods, via <a class="reference internal" href="#urllib2.OpenerDirector.error" title="urllib2.OpenerDirector.error"><code>OpenerDirector.error()</code></a>. Eventually, <a class="reference internal" href="#urllib2.HTTPDefaultErrorHandler" title="urllib2.HTTPDefaultErrorHandler"><code>urllib2.HTTPDefaultErrorHandler</code></a> will raise an <a class="reference internal" href="#urllib2.HTTPError" title="urllib2.HTTPError"><code>HTTPError</code></a> if no other handler handles the error.</p> </dd>
</dl> <dl class="method"> <dt id="urllib2.HTTPErrorProcessor.https_response">
<code>HTTPErrorProcessor.https_response()</code> </dt> <dd>
<p>Process HTTPS error responses.</p> <p>The behavior is same as <a class="reference internal" href="#urllib2.HTTPErrorProcessor.http_response" title="urllib2.HTTPErrorProcessor.http_response"><code>http_response()</code></a>.</p> </dd>
</dl>   <h2 id="urllib2-examples">21. Examples</h2> <p id="examples">In addition to the examples below, more examples are given in <a class="reference internal" href="https://docs.python.org/2.7/howto/urllib2.html#urllib-howto"><span class="std std-ref">HOWTO Fetch Internet Resources Using urllib2</span></a>.</p> <p>This example gets the python.org main page and displays the first 100 bytes of it:</p> <pre data-language="python">&gt;&gt;&gt; import urllib2
&gt;&gt;&gt; f = urllib2.urlopen('http://www.python.org/')
&gt;&gt;&gt; print f.read(100)
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;?xml-stylesheet href="./css/ht2html
</pre> <p>Here we are sending a data-stream to the stdin of a CGI and reading the data it returns to us. Note that this example will only work when the Python installation supports SSL.</p> <pre data-language="python">&gt;&gt;&gt; import urllib2
&gt;&gt;&gt; req = urllib2.Request(url='https://localhost/cgi-bin/test.cgi',
...                       data='This data is passed to stdin of the CGI')
&gt;&gt;&gt; f = urllib2.urlopen(req)
&gt;&gt;&gt; print f.read()
Got Data: "This data is passed to stdin of the CGI"
</pre> <p>The code for the sample CGI used in the above example is:</p> <pre data-language="python">#!/usr/bin/env python
import sys
data = sys.stdin.read()
print 'Content-type: text-plain\n\nGot Data: "%s"' % data
</pre> <p>Use of Basic HTTP Authentication:</p> <pre data-language="python">import urllib2
# Create an OpenerDirector with support for Basic HTTP Authentication...
auth_handler = urllib2.HTTPBasicAuthHandler()
auth_handler.add_password(realm='PDQ Application',
                          uri='https://mahler:8092/site-updates.py',
                          user='klem',
                          passwd='kadidd!ehopper')
opener = urllib2.build_opener(auth_handler)
# ...and install it globally so it can be used with urlopen.
urllib2.install_opener(opener)
urllib2.urlopen('http://www.example.com/login.html')
</pre> <p><a class="reference internal" href="#urllib2.build_opener" title="urllib2.build_opener"><code>build_opener()</code></a> provides many handlers by default, including a <a class="reference internal" href="#urllib2.ProxyHandler" title="urllib2.ProxyHandler"><code>ProxyHandler</code></a>. By default, <a class="reference internal" href="#urllib2.ProxyHandler" title="urllib2.ProxyHandler"><code>ProxyHandler</code></a> uses the environment variables named <code>&lt;scheme&gt;_proxy</code>, where <code>&lt;scheme&gt;</code> is the URL scheme involved. For example, the <code id="index-6">http_proxy</code> environment variable is read to obtain the HTTP proxy’s URL.</p> <p>This example replaces the default <a class="reference internal" href="#urllib2.ProxyHandler" title="urllib2.ProxyHandler"><code>ProxyHandler</code></a> with one that uses programmatically-supplied proxy URLs, and adds proxy authorization support with <a class="reference internal" href="#urllib2.ProxyBasicAuthHandler" title="urllib2.ProxyBasicAuthHandler"><code>ProxyBasicAuthHandler</code></a>.</p> <pre data-language="python">proxy_handler = urllib2.ProxyHandler({'http': 'http://www.example.com:3128/'})
proxy_auth_handler = urllib2.ProxyBasicAuthHandler()
proxy_auth_handler.add_password('realm', 'host', 'username', 'password')

opener = urllib2.build_opener(proxy_handler, proxy_auth_handler)
# This time, rather than install the OpenerDirector, we use it directly:
opener.open('http://www.example.com/login.html')
</pre> <p>Adding HTTP headers:</p> <p>Use the <em>headers</em> argument to the <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> constructor, or:</p> <pre data-language="python">import urllib2
req = urllib2.Request('http://www.example.com/')
req.add_header('Referer', 'http://www.python.org/')
# Customize the default User-Agent header value:
req.add_header('User-Agent', 'urllib-example/0.1 (Contact: . . .)')
r = urllib2.urlopen(req)
</pre> <p><a class="reference internal" href="#urllib2.OpenerDirector" title="urllib2.OpenerDirector"><code>OpenerDirector</code></a> automatically adds a <em class="mailheader">User-Agent</em> header to every <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a>. To change this:</p> <pre data-language="python">import urllib2
opener = urllib2.build_opener()
opener.addheaders = [('User-agent', 'Mozilla/5.0')]
opener.open('http://www.example.com/')
</pre> <p>Also, remember that a few standard headers (<em class="mailheader">Content-Length</em>, <em class="mailheader">Content-Type</em> and <em class="mailheader">Host</em>) are added when the <a class="reference internal" href="#urllib2.Request" title="urllib2.Request"><code>Request</code></a> is passed to <a class="reference internal" href="#urllib2.urlopen" title="urllib2.urlopen"><code>urlopen()</code></a> (or <a class="reference internal" href="#urllib2.OpenerDirector.open" title="urllib2.OpenerDirector.open"><code>OpenerDirector.open()</code></a>).</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/urllib2.html" class="_attribution-link">https://docs.python.org/2.7/library/urllib2.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
