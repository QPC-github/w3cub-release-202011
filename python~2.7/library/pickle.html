
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Pickle - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content="The pickle module implements a fundamental, but powerful algorithm for serializing and de-serializing a Python object structure. “Pickling” is the &hellip;">
  <meta name="keywords" content="pickle, —, python, object, serialization, cpickle, faster, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/pickle.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/python~2.7.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="pickle-python-object-serialization"> pickle — Python object serialization</h1> <p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module implements a fundamental, but powerful algorithm for serializing and de-serializing a Python object structure. “Pickling” is the process whereby a Python object hierarchy is converted into a byte stream, and “unpickling” is the inverse operation, whereby a byte stream is converted back into an object hierarchy. Pickling (and unpickling) is alternatively known as “serialization”, “marshalling,” <a class="footnote-reference brackets" href="#id11" id="id1">1</a> or “flattening”, however, to avoid confusion, the terms used here are “pickling” and “unpickling”.</p> <p>This documentation describes both the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module and the <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> module.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module is not secure against erroneous or maliciously constructed data. Never unpickle data received from an untrusted or unauthenticated source.</p> </div>  <h2 id="relationship-to-other-python-modules">1. Relationship to other Python modules</h2> <p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module has an optimized cousin called the <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> module. As its name implies, <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> is written in C, so it can be up to 1000 times faster than <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a>. However it does not support subclassing of the <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code>Pickler()</code></a> and <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code>Unpickler()</code></a> classes, because in <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> these are functions, not classes. Most applications have no need for this functionality, and can benefit from the improved performance of <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a>. Other than that, the interfaces of the two modules are nearly identical; the common interface is described in this manual and differences are pointed out where necessary. In the following discussions, we use the term “pickle” to collectively describe the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> and <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> modules.</p> <p>The data streams the two modules produce are guaranteed to be interchangeable.</p> <p>Python has a more primitive serialization module called <a class="reference internal" href="marshal#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a>, but in general <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> should always be the preferred way to serialize Python objects. <a class="reference internal" href="marshal#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a> exists primarily to support Python’s <code>.pyc</code> files.</p> <p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module differs from <a class="reference internal" href="marshal#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a> in several significant ways:</p> <ul> <li>
<p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module keeps track of the objects it has already serialized, so that later references to the same object won’t be serialized again. <a class="reference internal" href="marshal#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a> doesn’t do this.</p> <p>This has implications both for recursive objects and object sharing. Recursive objects are objects that contain references to themselves. These are not handled by marshal, and in fact, attempting to marshal recursive objects will crash your Python interpreter. Object sharing happens when there are multiple references to the same object in different places in the object hierarchy being serialized. <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> stores such objects only once, and ensures that all other references point to the master copy. Shared objects remain shared, which can be very important for mutable objects.</p> </li> <li>
<a class="reference internal" href="marshal#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a> cannot be used to serialize user-defined classes and their instances. <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> can save and restore class instances transparently, however the class definition must be importable and live in the same module as when the object was stored.</li> <li>The <a class="reference internal" href="marshal#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a> serialization format is not guaranteed to be portable across Python versions. Because its primary job in life is to support <code>.pyc</code> files, the Python implementers reserve the right to change the serialization format in non-backwards compatible ways should the need arise. The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> serialization format is guaranteed to be backwards compatible across Python releases.</li> </ul> <p>Note that serialization is a more primitive notion than persistence; although <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> reads and writes file objects, it does not handle the issue of naming persistent objects, nor the (even more complicated) issue of concurrent access to persistent objects. The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module can transform a complex object into a byte stream and it can transform the byte stream into an object with the same internal structure. Perhaps the most obvious thing to do with these byte streams is to write them onto a file, but it is also conceivable to send them across a network or store them in a database. The module <a class="reference internal" href="shelve#module-shelve" title="shelve: Python object persistence."><code>shelve</code></a> provides a simple interface to pickle and unpickle objects on DBM-style database files.</p>   <h2 id="data-stream-format">2. Data stream format</h2> <p id="index-1">The data format used by <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> is Python-specific. This has the advantage that there are no restrictions imposed by external standards such as XDR (which can’t represent pointer sharing); however it means that non-Python programs may not be able to reconstruct pickled Python objects.</p> <p>By default, the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> data format uses a printable ASCII representation. This is slightly more voluminous than a binary representation. The big advantage of using printable ASCII (and of some other characteristics of <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a>’s representation) is that for debugging or recovery purposes it is possible for a human to read the pickled file with a standard text editor.</p> <p>There are currently 3 different protocols which can be used for pickling.</p> <ul class="simple"> <li>Protocol version 0 is the original ASCII protocol and is backwards compatible with earlier versions of Python.</li> <li>Protocol version 1 is the old binary format which is also compatible with earlier versions of Python.</li> <li>Protocol version 2 was introduced in Python 2.3. It provides much more efficient pickling of <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-new-style-class"><span class="xref std std-term">new-style class</span></a>es.</li> </ul> <p>Refer to <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0307" id="index-2"><strong>PEP 307</strong></a> for more information.</p> <p>If a <em>protocol</em> is not specified, protocol 0 is used. If <em>protocol</em> is specified as a negative value or <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code>HIGHEST_PROTOCOL</code></a>, the highest protocol version available will be used.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.3: </span>Introduced the <em>protocol</em> parameter.</p> </div> <p>A binary format, which is slightly more efficient, can be chosen by specifying a <em>protocol</em> version &gt;= 1.</p>   <h2 id="usage">3. Usage</h2> <p>To serialize an object hierarchy, you first create a pickler, then you call the pickler’s <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code>dump()</code></a> method. To de-serialize a data stream, you first create an unpickler, then you call the unpickler’s <a class="reference internal" href="#pickle.load" title="pickle.load"><code>load()</code></a> method. The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module provides the following constant:</p> <dl class="data"> <dt id="pickle.HIGHEST_PROTOCOL">
<code>pickle.HIGHEST_PROTOCOL</code> </dt> <dd>
<p>The highest protocol version available. This value can be passed as a <em>protocol</em> value.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </dd>
</dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Be sure to always open pickle files created with protocols &gt;= 1 in binary mode. For the old ASCII-based pickle protocol 0 you can use either text mode or binary mode as long as you stay consistent.</p> <p>A pickle file written with protocol 0 in binary mode will contain lone linefeeds as line terminators and therefore will look “funny” when viewed in Notepad or other editors which do not support this format.</p> </div> <p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module provides the following functions to make the pickling process more convenient:</p> <dl class="function"> <dt id="pickle.dump">
<code>pickle.dump(obj, file[, protocol])</code> </dt> <dd>
<p>Write a pickled representation of <em>obj</em> to the open file object <em>file</em>. This is equivalent to <code>Pickler(file, protocol).dump(obj)</code>.</p> <p>If the <em>protocol</em> parameter is omitted, protocol 0 is used. If <em>protocol</em> is specified as a negative value or <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code>HIGHEST_PROTOCOL</code></a>, the highest protocol version will be used.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.3: </span>Introduced the <em>protocol</em> parameter.</p> </div> <p><em>file</em> must have a <code>write()</code> method that accepts a single string argument. It can thus be a file object opened for writing, a <a class="reference internal" href="stringio#module-StringIO" title="StringIO: Read and write strings as if they were files."><code>StringIO</code></a> object, or any other custom object that meets this interface.</p> </dd>
</dl> <dl class="function"> <dt id="pickle.load">
<code>pickle.load(file)</code> </dt> <dd>
<p>Read a string from the open file object <em>file</em> and interpret it as a pickle data stream, reconstructing and returning the original object hierarchy. This is equivalent to <code>Unpickler(file).load()</code>.</p> <p><em>file</em> must have two methods, a <code>read()</code> method that takes an integer argument, and a <a class="reference internal" href="readline#module-readline" title="readline: GNU readline support for Python. (Unix)"><code>readline()</code></a> method that requires no arguments. Both methods should return a string. Thus <em>file</em> can be a file object opened for reading, a <a class="reference internal" href="stringio#module-StringIO" title="StringIO: Read and write strings as if they were files."><code>StringIO</code></a> object, or any other custom object that meets this interface.</p> <p>This function automatically determines whether the data stream was written in binary mode or not.</p> </dd>
</dl> <dl class="function"> <dt id="pickle.dumps">
<code>pickle.dumps(obj[, protocol])</code> </dt> <dd>
<p>Return the pickled representation of the object as a string, instead of writing it to a file.</p> <p>If the <em>protocol</em> parameter is omitted, protocol 0 is used. If <em>protocol</em> is specified as a negative value or <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code>HIGHEST_PROTOCOL</code></a>, the highest protocol version will be used.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.3: </span>The <em>protocol</em> parameter was added.</p> </div> </dd>
</dl> <dl class="function"> <dt id="pickle.loads">
<code>pickle.loads(string)</code> </dt> <dd>
<p>Read a pickled object hierarchy from a string. Characters in the string past the pickled object’s representation are ignored.</p> </dd>
</dl> <p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module also defines three exceptions:</p> <dl class="exception"> <dt id="pickle.PickleError">
<code>exception pickle.PickleError</code> </dt> <dd>
<p>A common base class for the other exceptions defined below. This inherits from <a class="reference internal" href="exceptions#exceptions.Exception" title="exceptions.Exception"><code>Exception</code></a>.</p> </dd>
</dl> <dl class="exception"> <dt id="pickle.PicklingError">
<code>exception pickle.PicklingError</code> </dt> <dd>
<p>This exception is raised when an unpicklable object is passed to the <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code>dump()</code></a> method.</p> </dd>
</dl> <dl class="exception"> <dt id="pickle.UnpicklingError">
<code>exception pickle.UnpicklingError</code> </dt> <dd>
<p>This exception is raised when there is a problem unpickling an object. Note that other exceptions may also be raised during unpickling, including (but not necessarily limited to) <a class="reference internal" href="exceptions#exceptions.AttributeError" title="exceptions.AttributeError"><code>AttributeError</code></a>, <a class="reference internal" href="exceptions#exceptions.EOFError" title="exceptions.EOFError"><code>EOFError</code></a>, <a class="reference internal" href="exceptions#exceptions.ImportError" title="exceptions.ImportError"><code>ImportError</code></a>, and <a class="reference internal" href="exceptions#exceptions.IndexError" title="exceptions.IndexError"><code>IndexError</code></a>.</p> </dd>
</dl> <p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module also exports two callables <a class="footnote-reference brackets" href="#id12" id="id2">2</a>, <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code>Pickler</code></a> and <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code>Unpickler</code></a>:</p> <dl class="class"> <dt id="pickle.Pickler">
<code>class pickle.Pickler(file[, protocol])</code> </dt> <dd>
<p>This takes a file-like object to which it will write a pickle data stream.</p> <p>If the <em>protocol</em> parameter is omitted, protocol 0 is used. If <em>protocol</em> is specified as a negative value or <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code>HIGHEST_PROTOCOL</code></a>, the highest protocol version will be used.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.3: </span>Introduced the <em>protocol</em> parameter.</p> </div> <p><em>file</em> must have a <code>write()</code> method that accepts a single string argument. It can thus be an open file object, a <a class="reference internal" href="stringio#module-StringIO" title="StringIO: Read and write strings as if they were files."><code>StringIO</code></a> object, or any other custom object that meets this interface.</p> <p><a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code>Pickler</code></a> objects define one (or two) public methods:</p> <dl class="method"> <dt id="pickle.Pickler.dump">
<code>dump(obj)</code> </dt> <dd>
<p>Write a pickled representation of <em>obj</em> to the open file object given in the constructor. Either the binary or ASCII format will be used, depending on the value of the <em>protocol</em> argument passed to the constructor.</p> </dd>
</dl> <dl class="method"> <dt id="pickle.Pickler.clear_memo">
<code>clear_memo()</code> </dt> <dd>
<p>Clears the pickler’s “memo”. The memo is the data structure that remembers which objects the pickler has already seen, so that shared or recursive objects pickled by reference and not by value. This method is useful when re-using picklers.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Prior to Python 2.3, <a class="reference internal" href="#pickle.Pickler.clear_memo" title="pickle.Pickler.clear_memo"><code>clear_memo()</code></a> was only available on the picklers created by <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a>. In the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module, picklers have an instance variable called <code>memo</code> which is a Python dictionary. So to clear the memo for a <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module pickler, you could do the following:</p> <pre data-language="python">mypickler.memo.clear()
</pre> <p>Code that does not need to support older versions of Python should simply use <a class="reference internal" href="#pickle.Pickler.clear_memo" title="pickle.Pickler.clear_memo"><code>clear_memo()</code></a>.</p> </div> </dd>
</dl> </dd>
</dl> <p>It is possible to make multiple calls to the <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code>dump()</code></a> method of the same <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code>Pickler</code></a> instance. These must then be matched to the same number of calls to the <a class="reference internal" href="#pickle.load" title="pickle.load"><code>load()</code></a> method of the corresponding <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code>Unpickler</code></a> instance. If the same object is pickled by multiple <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code>dump()</code></a> calls, the <a class="reference internal" href="#pickle.load" title="pickle.load"><code>load()</code></a> will all yield references to the same object. <a class="footnote-reference brackets" href="#id13" id="id3">3</a></p> <p><a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code>Unpickler</code></a> objects are defined as:</p> <dl class="class"> <dt id="pickle.Unpickler">
<code>class pickle.Unpickler(file)</code> </dt> <dd>
<p>This takes a file-like object from which it will read a pickle data stream. This class automatically determines whether the data stream was written in binary mode or not, so it does not need a flag as in the <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code>Pickler</code></a> factory.</p> <p><em>file</em> must have two methods, a <code>read()</code> method that takes an integer argument, and a <a class="reference internal" href="readline#module-readline" title="readline: GNU readline support for Python. (Unix)"><code>readline()</code></a> method that requires no arguments. Both methods should return a string. Thus <em>file</em> can be a file object opened for reading, a <a class="reference internal" href="stringio#module-StringIO" title="StringIO: Read and write strings as if they were files."><code>StringIO</code></a> object, or any other custom object that meets this interface.</p> <p><a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code>Unpickler</code></a> objects have one (or two) public methods:</p> <dl class="method"> <dt id="pickle.Unpickler.load">
<code>load()</code> </dt> <dd>
<p>Read a pickled object representation from the open file object given in the constructor, and return the reconstituted object hierarchy specified therein.</p> <p>This method automatically determines whether the data stream was written in binary mode or not.</p> </dd>
</dl> <dl class="method"> <dt id="pickle.Unpickler.noload">
<code>noload()</code> </dt> <dd>
<p>This is just like <a class="reference internal" href="#pickle.load" title="pickle.load"><code>load()</code></a> except that it doesn’t actually create any objects. This is useful primarily for finding what’s called “persistent ids” that may be referenced in a pickle data stream. See section <a class="reference internal" href="#pickle-protocol"><span class="std std-ref">The pickle protocol</span></a> below for more details.</p> <p><strong>Note:</strong> the <a class="reference internal" href="#pickle.Unpickler.noload" title="pickle.Unpickler.noload"><code>noload()</code></a> method is currently only available on <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code>Unpickler</code></a> objects created with the <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> module. <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code>Unpickler</code></a>s do not have the <a class="reference internal" href="#pickle.Unpickler.noload" title="pickle.Unpickler.noload"><code>noload()</code></a> method.</p> </dd>
</dl> </dd>
</dl>   <h2 id="what-can-be-pickled-and-unpickled">4. What can be pickled and unpickled?</h2> <p>The following types can be pickled:</p> <ul class="simple"> <li>
<code>None</code>, <code>True</code>, and <code>False</code>
</li> <li>integers, long integers, floating point numbers, complex numbers</li> <li>normal and Unicode strings</li> <li>tuples, lists, sets, and dictionaries containing only picklable objects</li> <li>functions defined at the top level of a module</li> <li>built-in functions defined at the top level of a module</li> <li>classes that are defined at the top level of a module</li> <li>instances of such classes whose <a class="reference internal" href="stdtypes#object.__dict__" title="object.__dict__"><code>__dict__</code></a> or the result of calling <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code>__getstate__()</code></a> is picklable (see section <a class="reference internal" href="#pickle-protocol"><span class="std std-ref">The pickle protocol</span></a> for details).</li> </ul> <p>Attempts to pickle unpicklable objects will raise the <a class="reference internal" href="#pickle.PicklingError" title="pickle.PicklingError"><code>PicklingError</code></a> exception; when this happens, an unspecified number of bytes may have already been written to the underlying file. Trying to pickle a highly recursive data structure may exceed the maximum recursion depth, a <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a> will be raised in this case. You can carefully raise this limit with <a class="reference internal" href="sys#sys.setrecursionlimit" title="sys.setrecursionlimit"><code>sys.setrecursionlimit()</code></a>.</p> <p>Note that functions (built-in and user-defined) are pickled by “fully qualified” name reference, not by value. This means that only the function name is pickled, along with the name of the module the function is defined in. Neither the function’s code, nor any of its function attributes are pickled. Thus the defining module must be importable in the unpickling environment, and the module must contain the named object, otherwise an exception will be raised. <a class="footnote-reference brackets" href="#id14" id="id4">4</a></p> <p>Similarly, classes are pickled by named reference, so the same restrictions in the unpickling environment apply. Note that none of the class’s code or data is pickled, so in the following example the class attribute <code>attr</code> is not restored in the unpickling environment:</p> <pre data-language="python">class Foo:
    attr = 'a class attr'

picklestring = pickle.dumps(Foo)
</pre> <p>These restrictions are why picklable functions and classes must be defined in the top level of a module.</p> <p>Similarly, when class instances are pickled, their class’s code and data are not pickled along with them. Only the instance data are pickled. This is done on purpose, so you can fix bugs in a class or add methods to the class and still load objects that were created with an earlier version of the class. If you plan to have long-lived objects that will see many versions of a class, it may be worthwhile to put a version number in the objects so that suitable conversions can be made by the class’s <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a> method.</p>   <h2 id="pickle-protocol">5. The pickle protocol</h2> <p id="the-pickle-protocol">This section describes the “pickling protocol” that defines the interface between the pickler/unpickler and the objects that are being serialized. This protocol provides a standard way for you to define, customize, and control how your objects are serialized and de-serialized. The description in this section doesn’t cover specific customizations that you can employ to make the unpickling environment slightly safer from untrusted pickle data streams; see section <a class="reference internal" href="#pickle-sub"><span class="std std-ref">Subclassing Unpicklers</span></a> for more details.</p>  <h3 id="pickle-inst">5.1. Pickling and unpickling normal class instances</h3> <dl class="method" id="pickling-and-unpickling-normal-class-instances"> <dt id="object.__getinitargs__">
<code>object.__getinitargs__()</code> </dt> <dd>
<p>When a pickled class instance is unpickled, its <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> method is normally <em>not</em> invoked. If it is desirable that the <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> method be called on unpickling, an old-style class can define a method <a class="reference internal" href="#object.__getinitargs__" title="object.__getinitargs__"><code>__getinitargs__()</code></a>, which should return a <em>tuple</em> of positional arguments to be passed to the class constructor (<a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> for example). Keyword arguments are not supported. The <a class="reference internal" href="#object.__getinitargs__" title="object.__getinitargs__"><code>__getinitargs__()</code></a> method is called at pickle time; the tuple it returns is incorporated in the pickle for the instance.</p> </dd>
</dl> <dl class="method"> <dt id="object.__getnewargs__">
<code>object.__getnewargs__()</code> </dt> <dd>
<p>New-style types can provide a <a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code>__getnewargs__()</code></a> method that is used for protocol 2. Implementing this method is needed if the type establishes some internal invariants when the instance is created, or if the memory allocation is affected by the values passed to the <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> method for the type (as it is for tuples and strings). Instances of a <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-new-style-class"><span class="xref std std-term">new-style class</span></a> <code>C</code> are created using</p> <pre data-language="python">obj = C.__new__(C, *args)
</pre> <p>where <em>args</em> is the result of calling <a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code>__getnewargs__()</code></a> on the original object; if there is no <a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code>__getnewargs__()</code></a>, an empty tuple is assumed.</p> </dd>
</dl> <dl class="method"> <dt id="object.__getstate__">
<code>object.__getstate__()</code> </dt> <dd>
<p>Classes can further influence how their instances are pickled; if the class defines the method <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code>__getstate__()</code></a>, it is called and the return state is pickled as the contents for the instance, instead of the contents of the instance’s dictionary. If there is no <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code>__getstate__()</code></a> method, the instance’s <a class="reference internal" href="stdtypes#object.__dict__" title="object.__dict__"><code>__dict__</code></a> is pickled.</p> </dd>
</dl> <dl class="method"> <dt id="object.__setstate__">
<code>object.__setstate__(state)</code> </dt> <dd>
<p>Upon unpickling, if the class also defines the method <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a>, it is called with the unpickled state. <a class="footnote-reference brackets" href="#id15" id="id5">5</a> If there is no <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a> method, the pickled state must be a dictionary and its items are assigned to the new instance’s dictionary. If a class defines both <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code>__getstate__()</code></a> and <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a>, the state object needn’t be a dictionary and these methods can do what they want. <a class="footnote-reference brackets" href="#id16" id="id6">6</a></p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-new-style-class"><span class="xref std std-term">new-style class</span></a>es, if <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code>__getstate__()</code></a> returns a false value, the <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a> method will not be called.</p> </div> </dd>
</dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>At unpickling time, some methods like <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code>__getattr__()</code></a>, <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code>__getattribute__()</code></a>, or <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code>__setattr__()</code></a> may be called upon the instance. In case those methods rely on some internal invariant being true, the type should implement either <a class="reference internal" href="#object.__getinitargs__" title="object.__getinitargs__"><code>__getinitargs__()</code></a> or <a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code>__getnewargs__()</code></a> to establish such an invariant; otherwise, neither <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> nor <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> will be called.</p> </div>   <h3 id="pickling-and-unpickling-extension-types">5.2. Pickling and unpickling extension types</h3> <dl class="method"> <dt id="object.__reduce__">
<code>object.__reduce__()</code> </dt> <dd>
<p>When the <code>Pickler</code> encounters an object of a type it knows nothing about — such as an extension type — it looks in two places for a hint of how to pickle it. One alternative is for the object to implement a <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> method. If provided, at pickling time <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> will be called with no arguments, and it must return either a string or a tuple.</p> <p>If a string is returned, it names a global variable whose contents are pickled as normal. The string returned by <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> should be the object’s local name relative to its module; the pickle module searches the module namespace to determine the object’s module.</p> <p>When a tuple is returned, it must be between two and five elements long. Optional elements can either be omitted, or <code>None</code> can be provided as their value. The contents of this tuple are pickled as normal and used to reconstruct the object at unpickling time. The semantics of each element are:</p> <ul> <li>
<p>A callable object that will be called to create the initial version of the object. The next element of the tuple will provide arguments for this callable, and later elements provide additional state information that will subsequently be used to fully reconstruct the pickled data.</p> <p>In the unpickling environment this object must be either a class, a callable registered as a “safe constructor” (see below), or it must have an attribute <code>__safe_for_unpickling__</code> with a true value. Otherwise, an <code>UnpicklingError</code> will be raised in the unpickling environment. Note that as usual, the callable itself is pickled by name.</p> </li> <li>
<p>A tuple of arguments for the callable object.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.5: </span>Formerly, this argument could also be <code>None</code>.</p> </div> </li> <li>Optionally, the object’s state, which will be passed to the object’s <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a> method as described in section <a class="reference internal" href="#pickle-inst"><span class="std std-ref">Pickling and unpickling normal class instances</span></a>. If the object has no <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a> method, then, as above, the value must be a dictionary and it will be added to the object’s <a class="reference internal" href="stdtypes#object.__dict__" title="object.__dict__"><code>__dict__</code></a>.</li> <li>Optionally, an iterator (and not a sequence) yielding successive list items. These list items will be pickled, and appended to the object using either <code>obj.append(item)</code> or <code>obj.extend(list_of_items)</code>. This is primarily used for list subclasses, but may be used by other classes as long as they have <code>append()</code> and <code>extend()</code> methods with the appropriate signature. (Whether <code>append()</code> or <code>extend()</code> is used depends on which pickle protocol version is used as well as the number of items to append, so both must be supported.)</li> <li>Optionally, an iterator (not a sequence) yielding successive dictionary items, which should be tuples of the form <code>(key, value)</code>. These items will be pickled and stored to the object using <code>obj[key] = value</code>. This is primarily used for dictionary subclasses, but may be used by other classes as long as they implement <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code>__setitem__()</code></a>.</li> </ul> </dd>
</dl> <dl class="method"> <dt id="object.__reduce_ex__">
<code>object.__reduce_ex__(protocol)</code> </dt> <dd>
<p>It is sometimes useful to know the protocol version when implementing <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a>. This can be done by implementing a method named <a class="reference internal" href="#object.__reduce_ex__" title="object.__reduce_ex__"><code>__reduce_ex__()</code></a> instead of <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a>. <a class="reference internal" href="#object.__reduce_ex__" title="object.__reduce_ex__"><code>__reduce_ex__()</code></a>, when it exists, is called in preference over <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> (you may still provide <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> for backwards compatibility). The <a class="reference internal" href="#object.__reduce_ex__" title="object.__reduce_ex__"><code>__reduce_ex__()</code></a> method will be called with a single integer argument, the protocol version.</p> <p>The <a class="reference internal" href="functions#object" title="object"><code>object</code></a> class implements both <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> and <a class="reference internal" href="#object.__reduce_ex__" title="object.__reduce_ex__"><code>__reduce_ex__()</code></a>; however, if a subclass overrides <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> but not <a class="reference internal" href="#object.__reduce_ex__" title="object.__reduce_ex__"><code>__reduce_ex__()</code></a>, the <a class="reference internal" href="#object.__reduce_ex__" title="object.__reduce_ex__"><code>__reduce_ex__()</code></a> implementation detects this and calls <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a>.</p> </dd>
</dl> <p>An alternative to implementing a <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> method on the object to be pickled, is to register the callable with the <a class="reference internal" href="copy_reg#module-copy_reg" title="copy_reg: Register pickle support functions."><code>copy_reg</code></a> module. This module provides a way for programs to register “reduction functions” and constructors for user-defined types. Reduction functions have the same semantics and interface as the <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> method described above, except that they are called with a single argument, the object to be pickled.</p> <p>The registered constructor is deemed a “safe constructor” for purposes of unpickling as described above.</p>   <h3 id="pickling-and-unpickling-external-objects">5.3. Pickling and unpickling external objects</h3> <p id="index-3">For the benefit of object persistence, the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module supports the notion of a reference to an object outside the pickled data stream. Such objects are referenced by a “persistent id”, which is just an arbitrary string of printable ASCII characters. The resolution of such names is not defined by the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module; it will delegate this resolution to user defined functions on the pickler and unpickler. <a class="footnote-reference brackets" href="#id17" id="id7">7</a></p> <p>To define external persistent id resolution, you need to set the <code>persistent_id</code> attribute of the pickler object and the <code>persistent_load</code> attribute of the unpickler object.</p> <p>To pickle objects that have an external persistent id, the pickler must have a custom <code>persistent_id()</code> method that takes an object as an argument and returns either <code>None</code> or the persistent id for that object. When <code>None</code> is returned, the pickler simply pickles the object as normal. When a persistent id string is returned, the pickler will pickle that string, along with a marker so that the unpickler will recognize the string as a persistent id.</p> <p>To unpickle external objects, the unpickler must have a custom <code>persistent_load()</code> function that takes a persistent id string and returns the referenced object.</p> <p>Here’s a silly example that <em>might</em> shed more light:</p> <pre data-language="python">import pickle
from cStringIO import StringIO

src = StringIO()
p = pickle.Pickler(src)

def persistent_id(obj):
    if hasattr(obj, 'x'):
        return 'the value %d' % obj.x
    else:
        return None

p.persistent_id = persistent_id

class Integer:
    def __init__(self, x):
        self.x = x
    def __str__(self):
        return 'My name is integer %d' % self.x

i = Integer(7)
print i
p.dump(i)

datastream = src.getvalue()
print repr(datastream)
dst = StringIO(datastream)

up = pickle.Unpickler(dst)

class FancyInteger(Integer):
    def __str__(self):
        return 'I am the integer %d' % self.x

def persistent_load(persid):
    if persid.startswith('the value '):
        value = int(persid.split()[2])
        return FancyInteger(value)
    else:
        raise pickle.UnpicklingError, 'Invalid persistent id'

up.persistent_load = persistent_load

j = up.load()
print j
</pre> <p>In the <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> module, the unpickler’s <code>persistent_load</code> attribute can also be set to a Python list, in which case, when the unpickler reaches a persistent id, the persistent id string will simply be appended to this list. This functionality exists so that a pickle data stream can be “sniffed” for object references without actually instantiating all the objects in a pickle. <a class="footnote-reference brackets" href="#id18" id="id8">8</a> Setting <code>persistent_load</code> to a list is usually used in conjunction with the <code>noload()</code> method on the Unpickler.</p>    <h2 id="pickle-sub">6. Subclassing Unpicklers</h2> <p id="subclassing-unpicklers">By default, unpickling will import any class that it finds in the pickle data. You can control exactly what gets unpickled and what gets called by customizing your unpickler. Unfortunately, exactly how you do this is different depending on whether you’re using <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> or <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a>. <a class="footnote-reference brackets" href="#id19" id="id9">9</a></p> <p>In the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module, you need to derive a subclass from <code>Unpickler</code>, overriding the <code>load_global()</code> method. <code>load_global()</code> should read two lines from the pickle data stream where the first line will the name of the module containing the class and the second line will be the name of the instance’s class. It then looks up the class, possibly importing the module and digging out the attribute, then it appends what it finds to the unpickler’s stack. Later on, this class will be assigned to the <code>__class__</code> attribute of an empty class, as a way of magically creating an instance without calling its class’s <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a>. Your job (should you choose to accept it), would be to have <code>load_global()</code> push onto the unpickler’s stack, a known safe version of any class you deem safe to unpickle. It is up to you to produce such a class. Or you could raise an error if you want to disallow all unpickling of instances. If this sounds like a hack, you’re right. Refer to the source code to make this work.</p> <p>Things are a little cleaner with <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a>, but not by much. To control what gets unpickled, you can set the unpickler’s <code>find_global</code> attribute to a function or <code>None</code>. If it is <code>None</code> then any attempts to unpickle instances will raise an <code>UnpicklingError</code>. If it is a function, then it should accept a module name and a class name, and return the corresponding class object. It is responsible for looking up the class and performing any necessary imports, and it may raise an error to prevent instances of the class from being unpickled.</p> <p>The moral of the story is that you should be really careful about the source of the strings your application unpickles.</p>   <h2 id="pickle-example">7. Example</h2> <p id="example">For the simplest code, use the <code>dump()</code> and <code>load()</code> functions. Note that a self-referencing list is pickled and restored correctly.</p> <pre data-language="python">import pickle

data1 = {'a': [1, 2.0, 3, 4+6j],
         'b': ('string', u'Unicode string'),
         'c': None}

selfref_list = [1, 2, 3]
selfref_list.append(selfref_list)

output = open('data.pkl', 'wb')

# Pickle dictionary using protocol 0.
pickle.dump(data1, output)

# Pickle the list using the highest protocol available.
pickle.dump(selfref_list, output, -1)

output.close()
</pre> <p>The following example reads the resulting pickled data. When reading a pickle-containing file, you should open the file in binary mode because you can’t be sure if the ASCII or binary format was used.</p> <pre data-language="python">import pprint, pickle

pkl_file = open('data.pkl', 'rb')

data1 = pickle.load(pkl_file)
pprint.pprint(data1)

data2 = pickle.load(pkl_file)
pprint.pprint(data2)

pkl_file.close()
</pre> <p>Here’s a larger example that shows how to modify pickling behavior for a class. The <code>TextReader</code> class opens a text file, and returns the line number and line contents each time its <code>readline()</code> method is called. If a <code>TextReader</code> instance is pickled, all attributes <em>except</em> the file object member are saved. When the instance is unpickled, the file is reopened, and reading resumes from the last location. The <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a> and <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code>__getstate__()</code></a> methods are used to implement this behavior.</p> <pre data-language="python">#!/usr/local/bin/python

class TextReader:
    """Print and number lines in a text file."""
    def __init__(self, file):
        self.file = file
        self.fh = open(file)
        self.lineno = 0

    def readline(self):
        self.lineno = self.lineno + 1
        line = self.fh.readline()
        if not line:
            return None
        if line.endswith("\n"):
            line = line[:-1]
        return "%d: %s" % (self.lineno, line)

    def __getstate__(self):
        odict = self.__dict__.copy() # copy the dict since we change it
        del odict['fh']              # remove filehandle entry
        return odict

    def __setstate__(self, dict):
        fh = open(dict['file'])      # reopen file
        count = dict['lineno']       # read from file...
        while count:                 # until line count is restored
            fh.readline()
            count = count - 1
        self.__dict__.update(dict)   # update attributes
        self.fh = fh                 # save the file object
</pre> <p>A sample usage might be something like this:</p> <pre data-language="python">&gt;&gt;&gt; import TextReader
&gt;&gt;&gt; obj = TextReader.TextReader("TextReader.py")
&gt;&gt;&gt; obj.readline()
'1: #!/usr/local/bin/python'
&gt;&gt;&gt; obj.readline()
'2: '
&gt;&gt;&gt; obj.readline()
'3: class TextReader:'
&gt;&gt;&gt; import pickle
&gt;&gt;&gt; pickle.dump(obj, open('save.p', 'wb'))
</pre> <p>If you want to see that <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> works across Python processes, start another Python session, before continuing. What follows can happen from either the same process or a new process.</p> <pre data-language="python">&gt;&gt;&gt; import pickle
&gt;&gt;&gt; reader = pickle.load(open('save.p', 'rb'))
&gt;&gt;&gt; reader.readline()
'4:     """Print and number lines in a text file."""'
</pre> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="copy_reg#module-copy_reg" title="copy_reg: Register pickle support functions."><code>copy_reg</code></a>
</dt>
<dd>
<p>Pickle interface constructor registration for extension types.</p> </dd> <dt>
<code>Module</code> <a class="reference internal" href="shelve#module-shelve" title="shelve: Python object persistence."><code>shelve</code></a>
</dt>
<dd>
<p>Indexed databases of objects; uses <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a>.</p> </dd> <dt>
<code>Module</code> <a class="reference internal" href="copy#module-copy" title="copy: Shallow and deep copy operations."><code>copy</code></a>
</dt>
<dd>
<p>Shallow and deep object copying.</p> </dd> <dt>
<code>Module</code> <a class="reference internal" href="marshal#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a>
</dt>
<dd>
<p>High-performance serialization of built-in types.</p> </dd> </dl> </div>    <h1 id="cpickle-a-faster-pickle"> cPickle — A faster pickle</h1> <p id="module-cPickle">The <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> module supports serialization and de-serialization of Python objects, providing an interface and functionality nearly identical to the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module. There are several differences, the most important being performance and subclassability.</p> <p>First, <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> can be up to 1000 times faster than <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> because the former is implemented in C. Second, in the <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> module the callables <code>Pickler()</code> and <code>Unpickler()</code> are functions, not classes. This means that you cannot use them to derive custom pickling and unpickling subclasses. Most applications have no need for this functionality and should benefit from the greatly improved performance of the <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> module.</p> <p>The pickle data stream produced by <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> and <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> are identical, so it is possible to use <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> and <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> interchangeably with existing pickles. <a class="footnote-reference brackets" href="#id20" id="id10">10</a></p> <p>There are additional minor differences in API between <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> and <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a>, however for most applications, they are interchangeable. More documentation is provided in the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module documentation, which includes a list of the documented differences.</p> <h4 class="rubric">Footnotes</h4> <dl class="footnote brackets"> <dt class="label" id="id11">
<code>1</code> </dt> <dd>
<p>Don’t confuse this with the <a class="reference internal" href="marshal#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a> module</p> </dd> <dt class="label" id="id12">
<code>2</code> </dt> <dd>
<p>In the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module these callables are classes, which you could subclass to customize the behavior. However, in the <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a> module these callables are factory functions and so cannot be subclassed. One common reason to subclass is to control what objects can actually be unpickled. See section <a class="reference internal" href="#pickle-sub"><span class="std std-ref">Subclassing Unpicklers</span></a> for more details.</p> </dd> <dt class="label" id="id13">
<code>3</code> </dt> <dd>
<p><em>Warning</em>: this is intended for pickling multiple objects without intervening modifications to the objects or their parts. If you modify an object and then pickle it again using the same <code>Pickler</code> instance, the object is not pickled again — a reference to it is pickled and the <code>Unpickler</code> will return the old value, not the modified one. There are two problems here: (1) detecting changes, and (2) marshalling a minimal set of changes. Garbage Collection may also become a problem here.</p> </dd> <dt class="label" id="id14">
<code>4</code> </dt> <dd>
<p>The exception raised will likely be an <a class="reference internal" href="exceptions#exceptions.ImportError" title="exceptions.ImportError"><code>ImportError</code></a> or an <a class="reference internal" href="exceptions#exceptions.AttributeError" title="exceptions.AttributeError"><code>AttributeError</code></a> but it could be something else.</p> </dd> <dt class="label" id="id15">
<code>5</code> </dt> <dd>
<p>These methods can also be used to implement copying class instances.</p> </dd> <dt class="label" id="id16">
<code>6</code> </dt> <dd>
<p>This protocol is also used by the shallow and deep copying operations defined in the <a class="reference internal" href="copy#module-copy" title="copy: Shallow and deep copy operations."><code>copy</code></a> module.</p> </dd> <dt class="label" id="id17">
<code>7</code> </dt> <dd>
<p>The actual mechanism for associating these user defined functions is slightly different for <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> and <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a>. The description given here works the same for both implementations. Users of the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module could also use subclassing to effect the same results, overriding the <code>persistent_id()</code> and <code>persistent_load()</code> methods in the derived classes.</p> </dd> <dt class="label" id="id18">
<code>8</code> </dt> <dd>
<p>We’ll leave you with the image of Guido and Jim sitting around sniffing pickles in their living rooms.</p> </dd> <dt class="label" id="id19">
<code>9</code> </dt> <dd>
<p>A word of caution: the mechanisms described here use internal attributes and methods, which are subject to change in future versions of Python. We intend to someday provide a common interface for controlling this behavior, which will work in either <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> or <a class="reference internal" href="#module-cPickle" title="cPickle: Faster version of pickle, but not subclassable."><code>cPickle</code></a>.</p> </dd> <dt class="label" id="id20">
<code>10</code> </dt> <dd>
<p>Since the pickle data format is actually a tiny stack-oriented programming language, and some freedom is taken in the encodings of certain objects, it is possible that the two modules produce different data streams for the same input objects. However it is guaranteed that they will always be able to read each other’s data streams.</p> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/pickle.html" class="_attribution-link">https://docs.python.org/2.7/library/pickle.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
