
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Io - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" New in version 2.6. ">
  <meta name="keywords" content="io, —, core, tools, for, working, with, streams, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/io.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/python~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="io-core-tools-for-working-with-streams"> io — Core tools for working with streams</h1> <div class="versionadded" id="module-io"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> <p>The <a class="reference internal" href="#module-io" title="io: Core tools for working with streams."><code>io</code></a> module provides the Python interfaces to stream handling. Under Python 2.x, this is proposed as an alternative to the built-in <a class="reference internal" href="functions#file" title="file"><code>file</code></a> object, but in Python 3.x it is the default interface to access files and streams.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Since this module has been designed primarily for Python 3.x, you have to be aware that all uses of “bytes” in this document refer to the <a class="reference internal" href="functions#str" title="str"><code>str</code></a> type (of which <code>bytes</code> is an alias), and all uses of “text” refer to the <a class="reference internal" href="functions#unicode" title="unicode"><code>unicode</code></a> type. Furthermore, those two types are not interchangeable in the <a class="reference internal" href="#module-io" title="io: Core tools for working with streams."><code>io</code></a> APIs.</p> </div> <p>At the top of the I/O hierarchy is the abstract base class <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a>. It defines the basic interface to a stream. Note, however, that there is no separation between reading and writing to streams; implementations are allowed to raise an <a class="reference internal" href="exceptions#exceptions.IOError" title="exceptions.IOError"><code>IOError</code></a> if they do not support a given operation.</p> <p>Extending <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a> is <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a> which deals simply with the reading and writing of raw bytes to a stream. <a class="reference internal" href="#io.FileIO" title="io.FileIO"><code>FileIO</code></a> subclasses <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a> to provide an interface to files in the machine’s file system.</p> <p><a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a> deals with buffering on a raw byte stream (<a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a>). Its subclasses, <a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code>BufferedWriter</code></a>, <a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code>BufferedReader</code></a>, and <a class="reference internal" href="#io.BufferedRWPair" title="io.BufferedRWPair"><code>BufferedRWPair</code></a> buffer streams that are readable, writable, and both readable and writable. <a class="reference internal" href="#io.BufferedRandom" title="io.BufferedRandom"><code>BufferedRandom</code></a> provides a buffered interface to random access streams. <a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code>BytesIO</code></a> is a simple stream of in-memory bytes.</p> <p>Another <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a> subclass, <a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code>TextIOBase</code></a>, deals with streams whose bytes represent text, and handles encoding and decoding from and to <a class="reference internal" href="functions#unicode" title="unicode"><code>unicode</code></a> strings. <a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code>TextIOWrapper</code></a>, which extends it, is a buffered text interface to a buffered raw stream (<a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a>). Finally, <a class="reference internal" href="#io.StringIO" title="io.StringIO"><code>StringIO</code></a> is an in-memory stream for unicode text.</p> <p>Argument names are not part of the specification, and only the arguments of <a class="reference internal" href="#io.open" title="io.open"><code>open()</code></a> are intended to be used as keyword arguments.</p>  <h2 id="module-interface">1. Module Interface</h2> <dl class="data"> <dt id="io.DEFAULT_BUFFER_SIZE">
<code>io.DEFAULT_BUFFER_SIZE</code> </dt> <dd>
<p>An int containing the default buffer size used by the module’s buffered I/O classes. <a class="reference internal" href="#io.open" title="io.open"><code>open()</code></a> uses the file’s blksize (as obtained by <a class="reference internal" href="os#os.stat" title="os.stat"><code>os.stat()</code></a>) if possible.</p> </dd>
</dl> <dl class="function"> <dt id="io.open">
<code>io.open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True)</code> </dt> <dd>
<p>Open <em>file</em> and return a corresponding stream. If the file cannot be opened, an <a class="reference internal" href="exceptions#exceptions.IOError" title="exceptions.IOError"><code>IOError</code></a> is raised.</p> <p><em>file</em> is either a string giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed, unless <em>closefd</em> is set to <code>False</code>.)</p> <p><em>mode</em> is an optional string that specifies the mode in which the file is opened. It defaults to <code>'r'</code> which means open for reading in text mode. Other common values are <code>'w'</code> for writing (truncating the file if it already exists), and <code>'a'</code> for appending (which on <em>some</em> Unix systems, means that <em>all</em> writes append to the end of the file regardless of the current seek position). In text mode, if <em>encoding</em> is not specified the encoding used is platform dependent. (For reading and writing raw bytes use binary mode and leave <em>encoding</em> unspecified.) The available modes are:</p> <table class="docutils align-center">   <tr>
<td><p>Character</p></td> <td><p>Meaning</p></td> </tr> <tr>
<td><p><code>'r'</code></p></td> <td><p>open for reading (default)</p></td> </tr> <tr>
<td><p><code>'w'</code></p></td> <td><p>open for writing, truncating the file first</p></td> </tr> <tr>
<td><p><code>'a'</code></p></td> <td><p>open for writing, appending to the end of the file if it exists</p></td> </tr> <tr>
<td><p><code>'b'</code></p></td> <td><p>binary mode</p></td> </tr> <tr>
<td><p><code>'t'</code></p></td> <td><p>text mode (default)</p></td> </tr> <tr>
<td><p><code>'+'</code></p></td> <td><p>open a disk file for updating (reading and writing)</p></td> </tr> <tr>
<td><p><code>'U'</code></p></td> <td><p>universal newlines mode (for backwards compatibility; should not be used in new code)</p></td> </tr>  </table> <p>The default mode is <code>'rt'</code> (open for reading text). For binary random access, the mode <code>'w+b'</code> opens and truncates the file to 0 bytes, while <code>'r+b'</code> opens the file without truncation.</p> <p>Python distinguishes between files opened in binary and text modes, even when the underlying operating system doesn’t. Files opened in binary mode (including <code>'b'</code> in the <em>mode</em> argument) return contents as <code>bytes</code> objects without any decoding. In text mode (the default, or when <code>'t'</code> is included in the <em>mode</em> argument), the contents of the file are returned as <a class="reference internal" href="functions#unicode" title="unicode"><code>unicode</code></a> strings, the bytes having been first decoded using a platform-dependent encoding or using the specified <em>encoding</em> if given.</p> <p><em>buffering</em> is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable in text mode), and an integer &gt; 1 to indicate the size of a fixed-size chunk buffer. When no <em>buffering</em> argument is given, the default buffering policy works as follows:</p> <ul class="simple"> <li>Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on <a class="reference internal" href="#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code>DEFAULT_BUFFER_SIZE</code></a>. On many systems, the buffer will typically be 4096 or 8192 bytes long.</li> <li>“Interactive” text files (files for which <code>isatty()</code> returns True) use line buffering. Other text files use the policy described above for binary files.</li> </ul> <p><em>encoding</em> is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever <a class="reference internal" href="locale#locale.getpreferredencoding" title="locale.getpreferredencoding"><code>locale.getpreferredencoding()</code></a> returns), but any encoding supported by Python can be used. See the <a class="reference internal" href="codecs#module-codecs" title="codecs: Encode and decode data and streams."><code>codecs</code></a> module for the list of supported encodings.</p> <p><em>errors</em> is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. Pass <code>'strict'</code> to raise a <a class="reference internal" href="exceptions#exceptions.ValueError" title="exceptions.ValueError"><code>ValueError</code></a> exception if there is an encoding error (the default of <code>None</code> has the same effect), or pass <code>'ignore'</code> to ignore errors. (Note that ignoring encoding errors can lead to data loss.) <code>'replace'</code> causes a replacement marker (such as <code>'?'</code>) to be inserted where there is malformed data. When writing, <code>'xmlcharrefreplace'</code> (replace with the appropriate XML character reference) or <code>'backslashreplace'</code> (replace with backslashed escape sequences) can be used. Any other error handling name that has been registered with <a class="reference internal" href="codecs#codecs.register_error" title="codecs.register_error"><code>codecs.register_error()</code></a> is also valid.</p> <p id="index-0"><em>newline</em> controls how <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> works (it only applies to text mode). It can be <code>None</code>, <code>''</code>, <code>'\n'</code>, <code>'\r'</code>, and <code>'\r\n'</code>. It works as follows:</p> <ul class="simple"> <li>On input, if <em>newline</em> is <code>None</code>, universal newlines mode is enabled. Lines in the input can end in <code>'\n'</code>, <code>'\r'</code>, or <code>'\r\n'</code>, and these are translated into <code>'\n'</code> before being returned to the caller. If it is <code>''</code>, universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</li> <li>On output, if <em>newline</em> is <code>None</code>, any <code>'\n'</code> characters written are translated to the system default line separator, <a class="reference internal" href="os#os.linesep" title="os.linesep"><code>os.linesep</code></a>. If <em>newline</em> is <code>''</code>, no translation takes place. If <em>newline</em> is any of the other legal values, any <code>'\n'</code> characters written are translated to the given string.</li> </ul> <p>If <em>closefd</em> is <code>False</code> and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given <em>closefd</em> has no effect and must be <code>True</code> (the default).</p> <p>The type of file object returned by the <a class="reference internal" href="#io.open" title="io.open"><code>open()</code></a> function depends on the mode. When <a class="reference internal" href="#io.open" title="io.open"><code>open()</code></a> is used to open a file in a text mode (<code>'w'</code>, <code>'r'</code>, <code>'wt'</code>, <code>'rt'</code>, etc.), it returns a subclass of <a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code>TextIOBase</code></a> (specifically <a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code>TextIOWrapper</code></a>). When used to open a file in a binary mode with buffering, the returned class is a subclass of <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a>. The exact class varies: in read binary mode, it returns a <a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code>BufferedReader</code></a>; in write binary and append binary modes, it returns a <a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code>BufferedWriter</code></a>, and in read/write mode, it returns a <a class="reference internal" href="#io.BufferedRandom" title="io.BufferedRandom"><code>BufferedRandom</code></a>. When buffering is disabled, the raw stream, a subclass of <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a>, <a class="reference internal" href="#io.FileIO" title="io.FileIO"><code>FileIO</code></a>, is returned.</p> <p>It is also possible to use an <a class="reference internal" href="functions#unicode" title="unicode"><code>unicode</code></a> or <code>bytes</code> string as a file for both reading and writing. For <a class="reference internal" href="functions#unicode" title="unicode"><code>unicode</code></a> strings <a class="reference internal" href="#io.StringIO" title="io.StringIO"><code>StringIO</code></a> can be used like a file opened in text mode, and for <code>bytes</code> a <a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code>BytesIO</code></a> can be used like a file opened in a binary mode.</p> </dd>
</dl> <dl class="exception"> <dt id="io.BlockingIOError">
<code>exception io.BlockingIOError</code> </dt> <dd>
<p>Error raised when blocking would occur on a non-blocking stream. It inherits <a class="reference internal" href="exceptions#exceptions.IOError" title="exceptions.IOError"><code>IOError</code></a>.</p> <p>In addition to those of <a class="reference internal" href="exceptions#exceptions.IOError" title="exceptions.IOError"><code>IOError</code></a>, <a class="reference internal" href="#io.BlockingIOError" title="io.BlockingIOError"><code>BlockingIOError</code></a> has one attribute:</p> <dl class="attribute"> <dt id="io.BlockingIOError.characters_written">
<code>characters_written</code> </dt> <dd>
<p>An integer containing the number of characters written to the stream before it blocked.</p> </dd>
</dl> </dd>
</dl> <dl class="exception"> <dt id="io.UnsupportedOperation">
<code>exception io.UnsupportedOperation</code> </dt> <dd>
<p>An exception inheriting <a class="reference internal" href="exceptions#exceptions.IOError" title="exceptions.IOError"><code>IOError</code></a> and <a class="reference internal" href="exceptions#exceptions.ValueError" title="exceptions.ValueError"><code>ValueError</code></a> that is raised when an unsupported operation is called on a stream.</p> </dd>
</dl>   <h2 id="i-o-base-classes">2. I/O Base Classes</h2> <dl class="class"> <dt id="io.IOBase">
<code>class io.IOBase</code> </dt> <dd>
<p>The abstract base class for all I/O classes, acting on streams of bytes. There is no public constructor.</p> <p>This class provides empty abstract implementations for many methods that derived classes can override selectively; the default implementations represent a file that cannot be read, written or seeked.</p> <p>Even though <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a> does not declare <code>read()</code>, <code>readinto()</code>, or <code>write()</code> because their signatures will vary, implementations and clients should consider those methods part of the interface. Also, implementations may raise an <a class="reference internal" href="exceptions#exceptions.IOError" title="exceptions.IOError"><code>IOError</code></a> when operations they do not support are called.</p> <p>The basic type used for binary data read from or written to a file is <code>bytes</code> (also known as <a class="reference internal" href="functions#str" title="str"><code>str</code></a>). Method arguments may also be <a class="reference internal" href="functions#bytearray" title="bytearray"><code>bytearray</code></a> or <a class="reference internal" href="stdtypes#memoryview" title="memoryview"><code>memoryview</code></a> of arrays of bytes. In some cases, such as <a class="reference internal" href="#io.RawIOBase.readinto" title="io.RawIOBase.readinto"><code>readinto()</code></a>, a writable object such as <a class="reference internal" href="functions#bytearray" title="bytearray"><code>bytearray</code></a> is required. Text I/O classes work with <a class="reference internal" href="functions#unicode" title="unicode"><code>unicode</code></a> data.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>Implementations should support <a class="reference internal" href="stdtypes#memoryview" title="memoryview"><code>memoryview</code></a> arguments.</p> </div> <p>Note that calling any method (even inquiries) on a closed stream is undefined. Implementations may raise <a class="reference internal" href="exceptions#exceptions.IOError" title="exceptions.IOError"><code>IOError</code></a> in this case.</p> <p>IOBase (and its subclasses) support the iterator protocol, meaning that an <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a> object can be iterated over yielding the lines in a stream. Lines are defined slightly differently depending on whether the stream is a binary stream (yielding <code>bytes</code>), or a text stream (yielding <a class="reference internal" href="functions#unicode" title="unicode"><code>unicode</code></a> strings). See <a class="reference internal" href="#io.IOBase.readline" title="io.IOBase.readline"><code>readline()</code></a> below.</p> <p>IOBase is also a context manager and therefore supports the <a class="reference internal" href="https://docs.python.org/2.7/reference/compound_stmts.html#with"><code>with</code></a> statement. In this example, <em>file</em> is closed after the <a class="reference internal" href="https://docs.python.org/2.7/reference/compound_stmts.html#with"><code>with</code></a> statement’s suite is finished—even if an exception occurs:</p> <pre data-language="python">with io.open('spam.txt', 'w') as file:
    file.write(u'Spam and eggs!')
</pre> <p><a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a> provides these data attributes and methods:</p> <dl class="method"> <dt id="io.IOBase.close">
<code>close()</code> </dt> <dd>
<p>Flush and close this stream. This method has no effect if the file is already closed. Once the file is closed, any operation on the file (e.g. reading or writing) will raise a <a class="reference internal" href="exceptions#exceptions.ValueError" title="exceptions.ValueError"><code>ValueError</code></a>.</p> <p>As a convenience, it is allowed to call this method more than once; only the first call, however, will have an effect.</p> </dd>
</dl> <dl class="attribute"> <dt id="io.IOBase.closed">
<code>closed</code> </dt> <dd>
<p>True if the stream is closed.</p> </dd>
</dl> <dl class="method"> <dt id="io.IOBase.fileno">
<code>fileno()</code> </dt> <dd>
<p>Return the underlying file descriptor (an integer) of the stream if it exists. An <a class="reference internal" href="exceptions#exceptions.IOError" title="exceptions.IOError"><code>IOError</code></a> is raised if the IO object does not use a file descriptor.</p> </dd>
</dl> <dl class="method"> <dt id="io.IOBase.flush">
<code>flush()</code> </dt> <dd>
<p>Flush the write buffers of the stream if applicable. This does nothing for read-only and non-blocking streams.</p> </dd>
</dl> <dl class="method"> <dt id="io.IOBase.isatty">
<code>isatty()</code> </dt> <dd>
<p>Return <code>True</code> if the stream is interactive (i.e., connected to a terminal/tty device).</p> </dd>
</dl> <dl class="method"> <dt id="io.IOBase.readable">
<code>readable()</code> </dt> <dd>
<p>Return <code>True</code> if the stream can be read from. If <code>False</code>, <code>read()</code> will raise <a class="reference internal" href="exceptions#exceptions.IOError" title="exceptions.IOError"><code>IOError</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="io.IOBase.readline">
<code>readline(limit=-1)</code> </dt> <dd>
<p>Read and return one line from the stream. If <em>limit</em> is specified, at most <em>limit</em> bytes will be read.</p> <p>The line terminator is always <code>b'\n'</code> for binary files; for text files, the <em>newline</em> argument to <a class="reference internal" href="#io.open" title="io.open"><code>open()</code></a> can be used to select the line terminator(s) recognized.</p> </dd>
</dl> <dl class="method"> <dt id="io.IOBase.readlines">
<code>readlines(hint=-1)</code> </dt> <dd>
<p>Read and return a list of lines from the stream. <em>hint</em> can be specified to control the number of lines read: no more lines will be read if the total size (in bytes/characters) of all lines so far exceeds <em>hint</em>.</p> <p>Note that it’s already possible to iterate on file objects using <code>for
line in file: ...</code> without calling <code>file.readlines()</code>.</p> </dd>
</dl> <dl class="method"> <dt id="io.IOBase.seek">
<code>seek(offset, whence=SEEK_SET)</code> </dt> <dd>
<p>Change the stream position to the given byte <em>offset</em>. <em>offset</em> is interpreted relative to the position indicated by <em>whence</em>. The default value for <em>whence</em> is <code>SEEK_SET</code>. Values for <em>whence</em> are:</p> <ul class="simple"> <li>
<code>SEEK_SET</code> or <code>0</code> – start of the stream (the default); <em>offset</em> should be zero or positive</li> <li>
<code>SEEK_CUR</code> or <code>1</code> – current stream position; <em>offset</em> may be negative</li> <li>
<code>SEEK_END</code> or <code>2</code> – end of the stream; <em>offset</em> is usually negative</li> </ul> <p>Return the new absolute position.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7: </span>The <code>SEEK_*</code> constants</p> </div> </dd>
</dl> <dl class="method"> <dt id="io.IOBase.seekable">
<code>seekable()</code> </dt> <dd>
<p>Return <code>True</code> if the stream supports random access. If <code>False</code>, <a class="reference internal" href="#io.IOBase.seek" title="io.IOBase.seek"><code>seek()</code></a>, <a class="reference internal" href="#io.IOBase.tell" title="io.IOBase.tell"><code>tell()</code></a> and <a class="reference internal" href="#io.IOBase.truncate" title="io.IOBase.truncate"><code>truncate()</code></a> will raise <a class="reference internal" href="exceptions#exceptions.IOError" title="exceptions.IOError"><code>IOError</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="io.IOBase.tell">
<code>tell()</code> </dt> <dd>
<p>Return the current stream position.</p> </dd>
</dl> <dl class="method"> <dt id="io.IOBase.truncate">
<code>truncate(size=None)</code> </dt> <dd>
<p>Resize the stream to the given <em>size</em> in bytes (or the current position if <em>size</em> is not specified). The current stream position isn’t changed. This resizing can extend or reduce the current file size. In case of extension, the contents of the new file area depend on the platform (on most systems, additional bytes are zero-filled, on Windows they’re undetermined). The new file size is returned.</p> </dd>
</dl> <dl class="method"> <dt id="io.IOBase.writable">
<code>writable()</code> </dt> <dd>
<p>Return <code>True</code> if the stream supports writing. If <code>False</code>, <code>write()</code> and <a class="reference internal" href="#io.IOBase.truncate" title="io.IOBase.truncate"><code>truncate()</code></a> will raise <a class="reference internal" href="exceptions#exceptions.IOError" title="exceptions.IOError"><code>IOError</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="io.IOBase.writelines">
<code>writelines(lines)</code> </dt> <dd>
<p>Write a list of lines to the stream. Line separators are not added, so it is usual for each of the lines provided to have a line separator at the end.</p> </dd>
</dl> <dl class="method"> <dt id="io.IOBase.__del__">
<code>__del__()</code> </dt> <dd>
<p>Prepare for object destruction. <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a> provides a default implementation of this method that calls the instance’s <a class="reference internal" href="#io.IOBase.close" title="io.IOBase.close"><code>close()</code></a> method.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="io.RawIOBase">
<code>class io.RawIOBase</code> </dt> <dd>
<p>Base class for raw binary I/O. It inherits <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a>. There is no public constructor.</p> <p>Raw binary I/O typically provides low-level access to an underlying OS device or API, and does not try to encapsulate it in high-level primitives (this is left to Buffered I/O and Text I/O, described later in this page).</p> <p>In addition to the attributes and methods from <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a>, RawIOBase provides the following methods:</p> <dl class="method"> <dt id="io.RawIOBase.read">
<code>read(n=-1)</code> </dt> <dd>
<p>Read up to <em>n</em> bytes from the object and return them. As a convenience, if <em>n</em> is unspecified or -1, <a class="reference internal" href="#io.RawIOBase.readall" title="io.RawIOBase.readall"><code>readall()</code></a> is called. Otherwise, only one system call is ever made. Fewer than <em>n</em> bytes may be returned if the operating system call returns fewer than <em>n</em> bytes.</p> <p>If 0 bytes are returned, and <em>n</em> was not 0, this indicates end of file. If the object is in non-blocking mode and no bytes are available, <code>None</code> is returned.</p> </dd>
</dl> <dl class="method"> <dt id="io.RawIOBase.readall">
<code>readall()</code> </dt> <dd>
<p>Read and return all the bytes from the stream until EOF, using multiple calls to the stream if necessary.</p> </dd>
</dl> <dl class="method"> <dt id="io.RawIOBase.readinto">
<code>readinto(b)</code> </dt> <dd>
<p>Read up to len(b) bytes into <em>b</em>, and return the number of bytes read. The object <em>b</em> should be a pre-allocated, writable array of bytes, either <a class="reference internal" href="functions#bytearray" title="bytearray"><code>bytearray</code></a> or <a class="reference internal" href="stdtypes#memoryview" title="memoryview"><code>memoryview</code></a>. If the object is in non-blocking mode and no bytes are available, <code>None</code> is returned.</p> </dd>
</dl> <dl class="method"> <dt id="io.RawIOBase.write">
<code>write(b)</code> </dt> <dd>
<p>Write <em>b</em> to the underlying raw stream, and return the number of bytes written. The object <em>b</em> should be an array of bytes, either <code>bytes</code>, <a class="reference internal" href="functions#bytearray" title="bytearray"><code>bytearray</code></a>, or <a class="reference internal" href="stdtypes#memoryview" title="memoryview"><code>memoryview</code></a>. The return value can be less than <code>len(b)</code>, depending on specifics of the underlying raw stream, and especially if it is in non-blocking mode. <code>None</code> is returned if the raw stream is set not to block and no single byte could be readily written to it. The caller may release or mutate <em>b</em> after this method returns, so the implementation should only access <em>b</em> during the method call.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="io.BufferedIOBase">
<code>class io.BufferedIOBase</code> </dt> <dd>
<p>Base class for binary streams that support some kind of buffering. It inherits <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a>. There is no public constructor.</p> <p>The main difference with <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a> is that methods <a class="reference internal" href="#io.BufferedIOBase.read" title="io.BufferedIOBase.read"><code>read()</code></a>, <a class="reference internal" href="#io.BufferedIOBase.readinto" title="io.BufferedIOBase.readinto"><code>readinto()</code></a> and <a class="reference internal" href="#io.BufferedIOBase.write" title="io.BufferedIOBase.write"><code>write()</code></a> will try (respectively) to read as much input as requested or to consume all given output, at the expense of making perhaps more than one system call.</p> <p>In addition, those methods can raise <a class="reference internal" href="#io.BlockingIOError" title="io.BlockingIOError"><code>BlockingIOError</code></a> if the underlying raw stream is in non-blocking mode and cannot take or give enough data; unlike their <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a> counterparts, they will never return <code>None</code>.</p> <p>Besides, the <a class="reference internal" href="#io.BufferedIOBase.read" title="io.BufferedIOBase.read"><code>read()</code></a> method does not have a default implementation that defers to <a class="reference internal" href="#io.BufferedIOBase.readinto" title="io.BufferedIOBase.readinto"><code>readinto()</code></a>.</p> <p>A typical <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a> implementation should not inherit from a <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a> implementation, but wrap one, like <a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code>BufferedWriter</code></a> and <a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code>BufferedReader</code></a> do.</p> <p><a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a> provides or overrides these methods and attribute in addition to those from <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a>:</p> <dl class="attribute"> <dt id="io.BufferedIOBase.raw">
<code>raw</code> </dt> <dd>
<p>The underlying raw stream (a <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a> instance) that <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a> deals with. This is not part of the <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a> API and may not exist on some implementations.</p> </dd>
</dl> <dl class="method"> <dt id="io.BufferedIOBase.detach">
<code>detach()</code> </dt> <dd>
<p>Separate the underlying raw stream from the buffer and return it.</p> <p>After the raw stream has been detached, the buffer is in an unusable state.</p> <p>Some buffers, like <a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code>BytesIO</code></a>, do not have the concept of a single raw stream to return from this method. They raise <a class="reference internal" href="#io.UnsupportedOperation" title="io.UnsupportedOperation"><code>UnsupportedOperation</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="io.BufferedIOBase.read">
<code>read(n=-1)</code> </dt> <dd>
<p>Read and return up to <em>n</em> bytes. If the argument is omitted, <code>None</code>, or negative, data is read and returned until EOF is reached. An empty bytes object is returned if the stream is already at EOF.</p> <p>If the argument is positive, and the underlying raw stream is not interactive, multiple raw reads may be issued to satisfy the byte count (unless EOF is reached first). But for interactive raw streams, at most one raw read will be issued, and a short result does not imply that EOF is imminent.</p> <p>A <a class="reference internal" href="#io.BlockingIOError" title="io.BlockingIOError"><code>BlockingIOError</code></a> is raised if the underlying raw stream is in non blocking-mode, and has no data available at the moment.</p> </dd>
</dl> <dl class="method"> <dt id="io.BufferedIOBase.read1">
<code>read1(n=-1)</code> </dt> <dd>
<p>Read and return up to <em>n</em> bytes, with at most one call to the underlying raw stream’s <a class="reference internal" href="#io.RawIOBase.read" title="io.RawIOBase.read"><code>read()</code></a> method. This can be useful if you are implementing your own buffering on top of a <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a> object.</p> </dd>
</dl> <dl class="method"> <dt id="io.BufferedIOBase.readinto">
<code>readinto(b)</code> </dt> <dd>
<p>Read up to len(b) bytes into <em>b</em>, and return the number of bytes read. The object <em>b</em> should be a pre-allocated, writable array of bytes, either <a class="reference internal" href="functions#bytearray" title="bytearray"><code>bytearray</code></a> or <a class="reference internal" href="stdtypes#memoryview" title="memoryview"><code>memoryview</code></a>.</p> <p>Like <a class="reference internal" href="#io.BufferedIOBase.read" title="io.BufferedIOBase.read"><code>read()</code></a>, multiple reads may be issued to the underlying raw stream, unless the latter is ‘interactive’.</p> <p>A <a class="reference internal" href="#io.BlockingIOError" title="io.BlockingIOError"><code>BlockingIOError</code></a> is raised if the underlying raw stream is in non blocking-mode, and has no data available at the moment.</p> </dd>
</dl> <dl class="method"> <dt id="io.BufferedIOBase.write">
<code>write(b)</code> </dt> <dd>
<p>Write <em>b</em>, and return the number of bytes written (always equal to <code>len(b)</code>, since if the write fails an <a class="reference internal" href="exceptions#exceptions.IOError" title="exceptions.IOError"><code>IOError</code></a> will be raised). The object <em>b</em> should be an array of bytes, either <code>bytes</code>, <a class="reference internal" href="functions#bytearray" title="bytearray"><code>bytearray</code></a>, or <a class="reference internal" href="stdtypes#memoryview" title="memoryview"><code>memoryview</code></a>. Depending on the actual implementation, these bytes may be readily written to the underlying stream, or held in a buffer for performance and latency reasons.</p> <p>When in non-blocking mode, a <a class="reference internal" href="#io.BlockingIOError" title="io.BlockingIOError"><code>BlockingIOError</code></a> is raised if the data needed to be written to the raw stream but it couldn’t accept all the data without blocking.</p> <p>The caller may release or mutate <em>b</em> after this method returns, so the implementation should only access <em>b</em> during the method call.</p> </dd>
</dl> </dd>
</dl>   <h2 id="raw-file-i-o">3. Raw File I/O</h2> <dl class="class"> <dt id="io.FileIO">
<code>class io.FileIO(name, mode='r', closefd=True)</code> </dt> <dd>
<p><a class="reference internal" href="#io.FileIO" title="io.FileIO"><code>FileIO</code></a> represents an OS-level file containing bytes data. It implements the <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a> interface (and therefore the <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a> interface, too).</p> <p>The <em>name</em> can be one of two things:</p> <ul class="simple"> <li>a string representing the path to the file which will be opened;</li> <li>an integer representing the number of an existing OS-level file descriptor to which the resulting <a class="reference internal" href="#io.FileIO" title="io.FileIO"><code>FileIO</code></a> object will give access.</li> </ul> <p>The <em>mode</em> can be <code>'r'</code>, <code>'w'</code> or <code>'a'</code> for reading (default), writing, or appending. The file will be created if it doesn’t exist when opened for writing or appending; it will be truncated when opened for writing. Add a <code>'+'</code> to the mode to allow simultaneous reading and writing.</p> <p>The <code>read()</code> (when called with a positive argument), <code>readinto()</code> and <code>write()</code> methods on this class will only make one system call.</p> <p>In addition to the attributes and methods from <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a> and <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a>, <a class="reference internal" href="#io.FileIO" title="io.FileIO"><code>FileIO</code></a> provides the following data attributes and methods:</p> <dl class="attribute"> <dt id="io.FileIO.mode">
<code>mode</code> </dt> <dd>
<p>The mode as given in the constructor.</p> </dd>
</dl> <dl class="attribute"> <dt id="io.FileIO.name">
<code>name</code> </dt> <dd>
<p>The file name. This is the file descriptor of the file when no name is given in the constructor.</p> </dd>
</dl> </dd>
</dl>   <h2 id="buffered-streams">4. Buffered Streams</h2> <p>Buffered I/O streams provide a higher-level interface to an I/O device than raw I/O does.</p> <dl class="class"> <dt id="io.BytesIO">
<code>class io.BytesIO([initial_bytes])</code> </dt> <dd>
<p>A stream implementation using an in-memory bytes buffer. It inherits <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a>.</p> <p>The optional argument <em>initial_bytes</em> is a <code>bytes</code> object that contains initial data.</p> <p><a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code>BytesIO</code></a> provides or overrides these methods in addition to those from <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a> and <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a>:</p> <dl class="method"> <dt id="io.BytesIO.getvalue">
<code>getvalue()</code> </dt> <dd>
<p>Return <code>bytes</code> containing the entire contents of the buffer.</p> </dd>
</dl> <dl class="method"> <dt id="io.BytesIO.read1">
<code>read1()</code> </dt> <dd>
<p>In <a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code>BytesIO</code></a>, this is the same as <code>read()</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="io.BufferedReader">
<code>class io.BufferedReader(raw, buffer_size=DEFAULT_BUFFER_SIZE)</code> </dt> <dd>
<p>A buffer providing higher-level access to a readable, sequential <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a> object. It inherits <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a>. When reading data from this object, a larger amount of data may be requested from the underlying raw stream, and kept in an internal buffer. The buffered data can then be returned directly on subsequent reads.</p> <p>The constructor creates a <a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code>BufferedReader</code></a> for the given readable <em>raw</em> stream and <em>buffer_size</em>. If <em>buffer_size</em> is omitted, <a class="reference internal" href="#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code>DEFAULT_BUFFER_SIZE</code></a> is used.</p> <p><a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code>BufferedReader</code></a> provides or overrides these methods in addition to those from <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a> and <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a>:</p> <dl class="method"> <dt id="io.BufferedReader.peek">
<code>peek([n])</code> </dt> <dd>
<p>Return bytes from the stream without advancing the position. At most one single read on the raw stream is done to satisfy the call. The number of bytes returned may be less or more than requested.</p> </dd>
</dl> <dl class="method"> <dt id="io.BufferedReader.read">
<code>read([n])</code> </dt> <dd>
<p>Read and return <em>n</em> bytes, or if <em>n</em> is not given or negative, until EOF or if the read call would block in non-blocking mode.</p> </dd>
</dl> <dl class="method"> <dt id="io.BufferedReader.read1">
<code>read1(n)</code> </dt> <dd>
<p>Read and return up to <em>n</em> bytes with only one call on the raw stream. If at least one byte is buffered, only buffered bytes are returned. Otherwise, one raw stream read call is made.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="io.BufferedWriter">
<code>class io.BufferedWriter(raw, buffer_size=DEFAULT_BUFFER_SIZE)</code> </dt> <dd>
<p>A buffer providing higher-level access to a writeable, sequential <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a> object. It inherits <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a>. When writing to this object, data is normally held into an internal buffer. The buffer will be written out to the underlying <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a> object under various conditions, including:</p> <ul class="simple"> <li>when the buffer gets too small for all pending data;</li> <li>when <a class="reference internal" href="#io.BufferedWriter.flush" title="io.BufferedWriter.flush"><code>flush()</code></a> is called;</li> <li>when a <code>seek()</code> is requested (for <a class="reference internal" href="#io.BufferedRandom" title="io.BufferedRandom"><code>BufferedRandom</code></a> objects);</li> <li>when the <a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code>BufferedWriter</code></a> object is closed or destroyed.</li> </ul> <p>The constructor creates a <a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code>BufferedWriter</code></a> for the given writeable <em>raw</em> stream. If the <em>buffer_size</em> is not given, it defaults to <a class="reference internal" href="#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code>DEFAULT_BUFFER_SIZE</code></a>.</p> <p>A third argument, <em>max_buffer_size</em>, is supported, but unused and deprecated.</p> <p><a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code>BufferedWriter</code></a> provides or overrides these methods in addition to those from <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a> and <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a>:</p> <dl class="method"> <dt id="io.BufferedWriter.flush">
<code>flush()</code> </dt> <dd>
<p>Force bytes held in the buffer into the raw stream. A <a class="reference internal" href="#io.BlockingIOError" title="io.BlockingIOError"><code>BlockingIOError</code></a> should be raised if the raw stream blocks.</p> </dd>
</dl> <dl class="method"> <dt id="io.BufferedWriter.write">
<code>write(b)</code> </dt> <dd>
<p>Write <em>b</em>, and return the number of bytes written. The object <em>b</em> should be an array of bytes, either <code>bytes</code>, <a class="reference internal" href="functions#bytearray" title="bytearray"><code>bytearray</code></a>, or <a class="reference internal" href="stdtypes#memoryview" title="memoryview"><code>memoryview</code></a>. When in non-blocking mode, a <a class="reference internal" href="#io.BlockingIOError" title="io.BlockingIOError"><code>BlockingIOError</code></a> is raised if the buffer needs to be written out but the raw stream blocks.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="io.BufferedRandom">
<code>class io.BufferedRandom(raw, buffer_size=DEFAULT_BUFFER_SIZE)</code> </dt> <dd>
<p>A buffered interface to random access streams. It inherits <a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code>BufferedReader</code></a> and <a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code>BufferedWriter</code></a>, and further supports <code>seek()</code> and <code>tell()</code> functionality.</p> <p>The constructor creates a reader and writer for a seekable raw stream, given in the first argument. If the <em>buffer_size</em> is omitted it defaults to <a class="reference internal" href="#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code>DEFAULT_BUFFER_SIZE</code></a>.</p> <p>A third argument, <em>max_buffer_size</em>, is supported, but unused and deprecated.</p> <p><a class="reference internal" href="#io.BufferedRandom" title="io.BufferedRandom"><code>BufferedRandom</code></a> is capable of anything <a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code>BufferedReader</code></a> or <a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code>BufferedWriter</code></a> can do.</p> </dd>
</dl> <dl class="class"> <dt id="io.BufferedRWPair">
<code>class io.BufferedRWPair(reader, writer, buffer_size=DEFAULT_BUFFER_SIZE)</code> </dt> <dd>
<p>A buffered I/O object combining two unidirectional <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a> objects – one readable, the other writeable – into a single bidirectional endpoint. It inherits <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a>.</p> <p><em>reader</em> and <em>writer</em> are <a class="reference internal" href="#io.RawIOBase" title="io.RawIOBase"><code>RawIOBase</code></a> objects that are readable and writeable respectively. If the <em>buffer_size</em> is omitted it defaults to <a class="reference internal" href="#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code>DEFAULT_BUFFER_SIZE</code></a>.</p> <p>A fourth argument, <em>max_buffer_size</em>, is supported, but unused and deprecated.</p> <p><a class="reference internal" href="#io.BufferedRWPair" title="io.BufferedRWPair"><code>BufferedRWPair</code></a> implements all of <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a>’s methods except for <a class="reference internal" href="#io.BufferedIOBase.detach" title="io.BufferedIOBase.detach"><code>detach()</code></a>, which raises <a class="reference internal" href="#io.UnsupportedOperation" title="io.UnsupportedOperation"><code>UnsupportedOperation</code></a>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="#io.BufferedRWPair" title="io.BufferedRWPair"><code>BufferedRWPair</code></a> does not attempt to synchronize accesses to its underlying raw streams. You should not pass it the same object as reader and writer; use <a class="reference internal" href="#io.BufferedRandom" title="io.BufferedRandom"><code>BufferedRandom</code></a> instead.</p> </div> </dd>
</dl>   <h2 id="text-i-o">5. Text I/O</h2> <dl class="class"> <dt id="io.TextIOBase">
<code>class io.TextIOBase</code> </dt> <dd>
<p>Base class for text streams. This class provides a unicode character and line based interface to stream I/O. There is no <code>readinto()</code> method because Python’s <a class="reference internal" href="functions#unicode" title="unicode"><code>unicode</code></a> strings are immutable. It inherits <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a>. There is no public constructor.</p> <p><a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code>TextIOBase</code></a> provides or overrides these data attributes and methods in addition to those from <a class="reference internal" href="#io.IOBase" title="io.IOBase"><code>IOBase</code></a>:</p> <dl class="attribute"> <dt id="io.TextIOBase.encoding">
<code>encoding</code> </dt> <dd>
<p>The name of the encoding used to decode the stream’s bytes into strings, and to encode strings into bytes.</p> </dd>
</dl> <dl class="attribute"> <dt id="io.TextIOBase.errors">
<code>errors</code> </dt> <dd>
<p>The error setting of the decoder or encoder.</p> </dd>
</dl> <dl class="attribute"> <dt id="io.TextIOBase.newlines">
<code>newlines</code> </dt> <dd>
<p>A string, a tuple of strings, or <code>None</code>, indicating the newlines translated so far. Depending on the implementation and the initial constructor flags, this may not be available.</p> </dd>
</dl> <dl class="attribute"> <dt id="io.TextIOBase.buffer">
<code>buffer</code> </dt> <dd>
<p>The underlying binary buffer (a <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a> instance) that <a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code>TextIOBase</code></a> deals with. This is not part of the <a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code>TextIOBase</code></a> API and may not exist on some implementations.</p> </dd>
</dl> <dl class="method"> <dt id="io.TextIOBase.detach">
<code>detach()</code> </dt> <dd>
<p>Separate the underlying binary buffer from the <a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code>TextIOBase</code></a> and return it.</p> <p>After the underlying buffer has been detached, the <a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code>TextIOBase</code></a> is in an unusable state.</p> <p>Some <a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code>TextIOBase</code></a> implementations, like <a class="reference internal" href="#io.StringIO" title="io.StringIO"><code>StringIO</code></a>, may not have the concept of an underlying buffer and calling this method will raise <a class="reference internal" href="#io.UnsupportedOperation" title="io.UnsupportedOperation"><code>UnsupportedOperation</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="io.TextIOBase.read">
<code>read(n=-1)</code> </dt> <dd>
<p>Read and return at most <em>n</em> characters from the stream as a single <a class="reference internal" href="functions#unicode" title="unicode"><code>unicode</code></a>. If <em>n</em> is negative or <code>None</code>, reads until EOF.</p> </dd>
</dl> <dl class="method"> <dt id="io.TextIOBase.readline">
<code>readline(limit=-1)</code> </dt> <dd>
<p>Read until newline or EOF and return a single <code>unicode</code>. If the stream is already at EOF, an empty string is returned.</p> <p>If <em>limit</em> is specified, at most <em>limit</em> characters will be read.</p> </dd>
</dl> <dl class="method"> <dt id="io.TextIOBase.seek">
<code>seek(offset, whence=SEEK_SET)</code> </dt> <dd>
<p>Change the stream position to the given <em>offset</em>. Behaviour depends on the <em>whence</em> parameter. The default value for <em>whence</em> is <code>SEEK_SET</code>.</p> <ul class="simple"> <li>
<code>SEEK_SET</code> or <code>0</code>: seek from the start of the stream (the default); <em>offset</em> must either be a number returned by <a class="reference internal" href="#io.TextIOBase.tell" title="io.TextIOBase.tell"><code>TextIOBase.tell()</code></a>, or zero. Any other <em>offset</em> value produces undefined behaviour.</li> <li>
<code>SEEK_CUR</code> or <code>1</code>: “seek” to the current position; <em>offset</em> must be zero, which is a no-operation (all other values are unsupported).</li> <li>
<code>SEEK_END</code> or <code>2</code>: seek to the end of the stream; <em>offset</em> must be zero (all other values are unsupported).</li> </ul> <p>Return the new absolute position as an opaque number.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7: </span>The <code>SEEK_*</code> constants.</p> </div> </dd>
</dl> <dl class="method"> <dt id="io.TextIOBase.tell">
<code>tell()</code> </dt> <dd>
<p>Return the current stream position as an opaque number. The number does not usually represent a number of bytes in the underlying binary storage.</p> </dd>
</dl> <dl class="method"> <dt id="io.TextIOBase.write">
<code>write(s)</code> </dt> <dd>
<p>Write the <a class="reference internal" href="functions#unicode" title="unicode"><code>unicode</code></a> string <em>s</em> to the stream and return the number of characters written.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="io.TextIOWrapper">
<code>class io.TextIOWrapper(buffer, encoding=None, errors=None, newline=None, line_buffering=False)</code> </dt> <dd>
<p>A buffered text stream over a <a class="reference internal" href="#io.BufferedIOBase" title="io.BufferedIOBase"><code>BufferedIOBase</code></a> binary stream. It inherits <a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code>TextIOBase</code></a>.</p> <p><em>encoding</em> gives the name of the encoding that the stream will be decoded or encoded with. It defaults to <a class="reference internal" href="locale#locale.getpreferredencoding" title="locale.getpreferredencoding"><code>locale.getpreferredencoding()</code></a>.</p> <p><em>errors</em> is an optional string that specifies how encoding and decoding errors are to be handled. Pass <code>'strict'</code> to raise a <a class="reference internal" href="exceptions#exceptions.ValueError" title="exceptions.ValueError"><code>ValueError</code></a> exception if there is an encoding error (the default of <code>None</code> has the same effect), or pass <code>'ignore'</code> to ignore errors. (Note that ignoring encoding errors can lead to data loss.) <code>'replace'</code> causes a replacement marker (such as <code>'?'</code>) to be inserted where there is malformed data. When writing, <code>'xmlcharrefreplace'</code> (replace with the appropriate XML character reference) or <code>'backslashreplace'</code> (replace with backslashed escape sequences) can be used. Any other error handling name that has been registered with <a class="reference internal" href="codecs#codecs.register_error" title="codecs.register_error"><code>codecs.register_error()</code></a> is also valid.</p> <p id="index-1"><em>newline</em> controls how line endings are handled. It can be <code>None</code>, <code>''</code>, <code>'\n'</code>, <code>'\r'</code>, and <code>'\r\n'</code>. It works as follows:</p> <ul class="simple"> <li>On input, if <em>newline</em> is <code>None</code>, <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> mode is enabled. Lines in the input can end in <code>'\n'</code>, <code>'\r'</code>, or <code>'\r\n'</code>, and these are translated into <code>'\n'</code> before being returned to the caller. If it is <code>''</code>, universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</li> <li>On output, if <em>newline</em> is <code>None</code>, any <code>'\n'</code> characters written are translated to the system default line separator, <a class="reference internal" href="os#os.linesep" title="os.linesep"><code>os.linesep</code></a>. If <em>newline</em> is <code>''</code>, no translation takes place. If <em>newline</em> is any of the other legal values, any <code>'\n'</code> characters written are translated to the given string.</li> </ul> <p>If <em>line_buffering</em> is <code>True</code>, <code>flush()</code> is implied when a call to write contains a newline character or a carriage return.</p> <p><a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code>TextIOWrapper</code></a> provides one attribute in addition to those of <a class="reference internal" href="#io.TextIOBase" title="io.TextIOBase"><code>TextIOBase</code></a> and its parents:</p> <dl class="attribute"> <dt id="io.TextIOWrapper.line_buffering">
<code>line_buffering</code> </dt> <dd>
<p>Whether line buffering is enabled.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="io.StringIO">
<code>class io.StringIO(initial_value=u'', newline=u'\n')</code> </dt> <dd>
<p>An in-memory stream for unicode text. It inherits <a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code>TextIOWrapper</code></a>.</p> <p>The initial value of the buffer can be set by providing <em>initial_value</em>. If newline translation is enabled, newlines will be encoded as if by <a class="reference internal" href="#io.TextIOBase.write" title="io.TextIOBase.write"><code>write()</code></a>. The stream is positioned at the start of the buffer.</p> <p>The <em>newline</em> argument works like that of <a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code>TextIOWrapper</code></a>. The default is to consider only <code>\n</code> characters as ends of lines and to do no newline translation. If <em>newline</em> is set to <code>None</code>, newlines are written as <code>\n</code> on all platforms, but universal newline decoding is still performed when reading.</p> <p><a class="reference internal" href="#io.StringIO" title="io.StringIO"><code>StringIO</code></a> provides this method in addition to those from <a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code>TextIOWrapper</code></a> and its parents:</p> <dl class="method"> <dt id="io.StringIO.getvalue">
<code>getvalue()</code> </dt> <dd>
<p>Return a <code>unicode</code> containing the entire contents of the buffer at any time before the <a class="reference internal" href="#io.StringIO" title="io.StringIO"><code>StringIO</code></a> object’s <code>close()</code> method is called. Newlines are decoded as if by <a class="reference internal" href="#io.TextIOBase.read" title="io.TextIOBase.read"><code>read()</code></a>, although the stream position is not changed.</p> </dd>
</dl> <p>Example usage:</p> <pre data-language="python">import io

output = io.StringIO()
output.write(u'First line.\n')
output.write(u'Second line.\n')

# Retrieve file contents -- this will be
# u'First line.\nSecond line.\n'
contents = output.getvalue()

# Close object and discard memory buffer --
# .getvalue() will now raise an exception.
output.close()
</pre> </dd>
</dl> <dl class="class"> <dt id="io.IncrementalNewlineDecoder">
<code>class io.IncrementalNewlineDecoder</code> </dt> <dd>
<p>A helper codec that decodes newlines for <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> mode. It inherits <a class="reference internal" href="codecs#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code>codecs.IncrementalDecoder</code></a>.</p> </dd>
</dl>   <h2 id="advanced-topics">6. Advanced topics</h2> <p>Here we will discuss several advanced topics pertaining to the concrete I/O implementations described above.</p>  <h3 id="performance">6.1. Performance</h3>  <h4 id="binary-i-o">6.1.1. Binary I/O</h4> <p>By reading and writing only large chunks of data even when the user asks for a single byte, buffered I/O is designed to hide any inefficiency in calling and executing the operating system’s unbuffered I/O routines. The gain will vary very much depending on the OS and the kind of I/O which is performed (for example, on some contemporary OSes such as Linux, unbuffered disk I/O can be as fast as buffered I/O). The bottom line, however, is that buffered I/O will offer you predictable performance regardless of the platform and the backing device. Therefore, it is most always preferable to use buffered I/O rather than unbuffered I/O.</p>   <h4 id="id1">6.1.2. Text I/O</h4> <p>Text I/O over a binary storage (such as a file) is significantly slower than binary I/O over the same storage, because it implies conversions from unicode to binary data using a character codec. This can become noticeable if you handle huge amounts of text data (for example very large log files). Also, <code>TextIOWrapper.tell()</code> and <code>TextIOWrapper.seek()</code> are both quite slow due to the reconstruction algorithm used.</p> <p><a class="reference internal" href="#io.StringIO" title="io.StringIO"><code>StringIO</code></a>, however, is a native in-memory unicode container and will exhibit similar speed to <a class="reference internal" href="#io.BytesIO" title="io.BytesIO"><code>BytesIO</code></a>.</p>    <h3 id="multi-threading">6.2. Multi-threading</h3> <p><a class="reference internal" href="#io.FileIO" title="io.FileIO"><code>FileIO</code></a> objects are thread-safe to the extent that the operating system calls (such as <code>read(2)</code> under Unix) they are wrapping are thread-safe too.</p> <p>Binary buffered objects (instances of <a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code>BufferedReader</code></a>, <a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code>BufferedWriter</code></a>, <a class="reference internal" href="#io.BufferedRandom" title="io.BufferedRandom"><code>BufferedRandom</code></a> and <a class="reference internal" href="#io.BufferedRWPair" title="io.BufferedRWPair"><code>BufferedRWPair</code></a>) protect their internal structures using a lock; it is therefore safe to call them from multiple threads at once.</p> <p><a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code>TextIOWrapper</code></a> objects are not thread-safe.</p>   <h3 id="reentrancy">6.3. Reentrancy</h3> <p>Binary buffered objects (instances of <a class="reference internal" href="#io.BufferedReader" title="io.BufferedReader"><code>BufferedReader</code></a>, <a class="reference internal" href="#io.BufferedWriter" title="io.BufferedWriter"><code>BufferedWriter</code></a>, <a class="reference internal" href="#io.BufferedRandom" title="io.BufferedRandom"><code>BufferedRandom</code></a> and <a class="reference internal" href="#io.BufferedRWPair" title="io.BufferedRWPair"><code>BufferedRWPair</code></a>) are not reentrant. While reentrant calls will not happen in normal situations, they can arise if you are doing I/O in a <a class="reference internal" href="signal#module-signal" title="signal: Set handlers for asynchronous events."><code>signal</code></a> handler. If it is attempted to enter a buffered object again while already being accessed <em>from the same thread</em>, then a <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a> is raised.</p> <p>The above implicitly extends to text files, since the <a class="reference internal" href="functions#open" title="open"><code>open()</code></a> function will wrap a buffered object inside a <a class="reference internal" href="#io.TextIOWrapper" title="io.TextIOWrapper"><code>TextIOWrapper</code></a>. This includes standard streams and therefore affects the built-in function <a class="reference internal" href="functions#print" title="print"><code>print()</code></a> as well.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/io.html" class="_attribution-link">https://docs.python.org/2.7/library/io.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
