
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Dis - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" Source code&#58; Lib&#47;dis.py ">
  <meta name="keywords" content="dis, —, disassembler, for, python, bytecode, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/dis.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/python~2.7.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="dis-disassembler-for-python-bytecode"> dis — Disassembler for Python bytecode</h1> <p id="module-dis"><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/2.7/Lib/dis.py">Lib/dis.py</a></p>  <p>The <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code>dis</code></a> module supports the analysis of CPython <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> by disassembling it. The CPython bytecode which this module takes as an input is defined in the file <code>Include/opcode.h</code> and used by the compiler and the interpreter.</p> <div class="impl-detail compound"> <p><strong>CPython implementation detail:</strong> Bytecode is an implementation detail of the CPython interpreter! No guarantees are made that bytecode will not be added, removed, or changed between versions of Python. Use of this module should not be considered to work across Python VMs or Python releases.</p> </div> <p>Example: Given the function <code>myfunc()</code>:</p> <pre data-language="python">def myfunc(alist):
    return len(alist)
</pre> <p>the following command can be used to get the disassembly of <code>myfunc()</code>:</p> <pre data-language="python">&gt;&gt;&gt; dis.dis(myfunc)
  2           0 LOAD_GLOBAL              0 (len)
              3 LOAD_FAST                0 (alist)
              6 CALL_FUNCTION            1
              9 RETURN_VALUE
</pre> <p>(The “2” is a line number).</p> <p>The <a class="reference internal" href="#module-dis" title="dis: Disassembler for Python bytecode."><code>dis</code></a> module defines the following functions and constants:</p> <dl class="function"> <dt id="dis.dis">
<code>dis.dis([bytesource])</code> </dt> <dd>
<p>Disassemble the <em>bytesource</em> object. <em>bytesource</em> can denote either a module, a class, a method, a function, or a code object. For a module, it disassembles all functions. For a class, it disassembles all methods. For a single code sequence, it prints one line per bytecode instruction. If no object is provided, it disassembles the last traceback.</p> </dd>
</dl> <dl class="function"> <dt id="dis.distb">
<code>dis.distb([tb])</code> </dt> <dd>
<p>Disassembles the top-of-stack function of a traceback, using the last traceback if none was passed. The instruction causing the exception is indicated.</p> </dd>
</dl> <dl class="function"> <dt id="dis.disassemble">
<code>dis.disassemble(code[, lasti])</code> </dt> <dd>
<p>Disassembles a code object, indicating the last instruction if <em>lasti</em> was provided. The output is divided in the following columns:</p> <ol class="arabic simple"> <li>the line number, for the first instruction of each line</li> <li>the current instruction, indicated as <code>--&gt;</code>,</li> <li>a labelled instruction, indicated with <code>&gt;&gt;</code>,</li> <li>the address of the instruction,</li> <li>the operation code name,</li> <li>operation parameters, and</li> <li>interpretation of the parameters in parentheses.</li> </ol> <p>The parameter interpretation recognizes local and global variable names, constant values, branch targets, and compare operators.</p> </dd>
</dl> <dl class="function"> <dt id="dis.disco">
<code>dis.disco(code[, lasti])</code> </dt> <dd>
<p>A synonym for <a class="reference internal" href="#dis.disassemble" title="dis.disassemble"><code>disassemble()</code></a>. It is more convenient to type, and kept for compatibility with earlier Python releases.</p> </dd>
</dl> <dl class="function"> <dt id="dis.findlinestarts">
<code>dis.findlinestarts(code)</code> </dt> <dd>
<p>This generator function uses the <code>co_firstlineno</code> and <code>co_lnotab</code> attributes of the code object <em>code</em> to find the offsets which are starts of lines in the source code. They are generated as <code>(offset, lineno)</code> pairs.</p> </dd>
</dl> <dl class="function"> <dt id="dis.findlabels">
<code>dis.findlabels(code)</code> </dt> <dd>
<p>Detect all offsets in the code object <em>code</em> which are jump targets, and return a list of these offsets.</p> </dd>
</dl> <dl class="data"> <dt id="dis.opname">
<code>dis.opname</code> </dt> <dd>
<p>Sequence of operation names, indexable using the bytecode.</p> </dd>
</dl> <dl class="data"> <dt id="dis.opmap">
<code>dis.opmap</code> </dt> <dd>
<p>Dictionary mapping operation names to bytecodes.</p> </dd>
</dl> <dl class="data"> <dt id="dis.cmp_op">
<code>dis.cmp_op</code> </dt> <dd>
<p>Sequence of all compare operation names.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasconst">
<code>dis.hasconst</code> </dt> <dd>
<p>Sequence of bytecodes that access a constant.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasfree">
<code>dis.hasfree</code> </dt> <dd>
<p>Sequence of bytecodes that access a free variable.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasname">
<code>dis.hasname</code> </dt> <dd>
<p>Sequence of bytecodes that access an attribute by name.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasjrel">
<code>dis.hasjrel</code> </dt> <dd>
<p>Sequence of bytecodes that have a relative jump target.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hasjabs">
<code>dis.hasjabs</code> </dt> <dd>
<p>Sequence of bytecodes that have an absolute jump target.</p> </dd>
</dl> <dl class="data"> <dt id="dis.haslocal">
<code>dis.haslocal</code> </dt> <dd>
<p>Sequence of bytecodes that access a local variable.</p> </dd>
</dl> <dl class="data"> <dt id="dis.hascompare">
<code>dis.hascompare</code> </dt> <dd>
<p>Sequence of bytecodes of Boolean operations.</p> </dd>
</dl>  <h2 id="bytecodes">1. Python Bytecode Instructions</h2> <p id="python-bytecode-instructions">The Python compiler currently generates the following bytecode instructions.</p> <dl class="opcode"> <dt id="opcode-STOP_CODE">
<code>STOP_CODE()</code> </dt> <dd>
<p>Indicates end-of-code to the compiler, not used by the interpreter.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-NOP">
<code>NOP()</code> </dt> <dd>
<p>Do nothing code. Used as a placeholder by the bytecode optimizer.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_TOP">
<code>POP_TOP()</code> </dt> <dd>
<p>Removes the top-of-stack (TOS) item.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-ROT_TWO">
<code>ROT_TWO()</code> </dt> <dd>
<p>Swaps the two top-most stack items.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-ROT_THREE">
<code>ROT_THREE()</code> </dt> <dd>
<p>Lifts second and third stack item one position up, moves top down to position three.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-ROT_FOUR">
<code>ROT_FOUR()</code> </dt> <dd>
<p>Lifts second, third and forth stack item one position up, moves top down to position four.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DUP_TOP">
<code>DUP_TOP()</code> </dt> <dd>
<p>Duplicates the reference on top of the stack.</p> </dd>
</dl> <p>Unary Operations take the top of the stack, apply the operation, and push the result back on the stack.</p> <dl class="opcode"> <dt id="opcode-UNARY_POSITIVE">
<code>UNARY_POSITIVE()</code> </dt> <dd>
<p>Implements <code>TOS = +TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNARY_NEGATIVE">
<code>UNARY_NEGATIVE()</code> </dt> <dd>
<p>Implements <code>TOS = -TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNARY_NOT">
<code>UNARY_NOT()</code> </dt> <dd>
<p>Implements <code>TOS = not TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNARY_CONVERT">
<code>UNARY_CONVERT()</code> </dt> <dd>
<p>Implements <code>TOS = `TOS`</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNARY_INVERT">
<code>UNARY_INVERT()</code> </dt> <dd>
<p>Implements <code>TOS = ~TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-GET_ITER">
<code>GET_ITER()</code> </dt> <dd>
<p>Implements <code>TOS = iter(TOS)</code>.</p> </dd>
</dl> <p>Binary operations remove the top of the stack (TOS) and the second top-most stack item (TOS1) from the stack. They perform the operation, and put the result back on the stack.</p> <dl class="opcode"> <dt id="opcode-BINARY_POWER">
<code>BINARY_POWER()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 ** TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_MULTIPLY">
<code>BINARY_MULTIPLY()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 * TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_DIVIDE">
<code>BINARY_DIVIDE()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 / TOS</code> when <code>from __future__ import division</code> is not in effect.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_FLOOR_DIVIDE">
<code>BINARY_FLOOR_DIVIDE()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 // TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_TRUE_DIVIDE">
<code>BINARY_TRUE_DIVIDE()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 / TOS</code> when <code>from __future__ import division</code> is in effect.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_MODULO">
<code>BINARY_MODULO()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 % TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_ADD">
<code>BINARY_ADD()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 + TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_SUBTRACT">
<code>BINARY_SUBTRACT()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 - TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_SUBSCR">
<code>BINARY_SUBSCR()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1[TOS]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_LSHIFT">
<code>BINARY_LSHIFT()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 &lt;&lt; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_RSHIFT">
<code>BINARY_RSHIFT()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 &gt;&gt; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_AND">
<code>BINARY_AND()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 &amp; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_XOR">
<code>BINARY_XOR()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 ^ TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BINARY_OR">
<code>BINARY_OR()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1 | TOS</code>.</p> </dd>
</dl> <p>In-place operations are like binary operations, in that they remove TOS and TOS1, and push the result back on the stack, but the operation is done in-place when TOS1 supports it, and the resulting TOS may be (but does not have to be) the original TOS1.</p> <dl class="opcode"> <dt id="opcode-INPLACE_POWER">
<code>INPLACE_POWER()</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 ** TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_MULTIPLY">
<code>INPLACE_MULTIPLY()</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 * TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_DIVIDE">
<code>INPLACE_DIVIDE()</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 / TOS</code> when <code>from __future__ import
division</code> is not in effect.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_FLOOR_DIVIDE">
<code>INPLACE_FLOOR_DIVIDE()</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 // TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_TRUE_DIVIDE">
<code>INPLACE_TRUE_DIVIDE()</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 / TOS</code> when <code>from __future__ import
division</code> is in effect.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_MODULO">
<code>INPLACE_MODULO()</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 % TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_ADD">
<code>INPLACE_ADD()</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 + TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_SUBTRACT">
<code>INPLACE_SUBTRACT()</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 - TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_LSHIFT">
<code>INPLACE_LSHIFT()</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 &lt;&lt; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_RSHIFT">
<code>INPLACE_RSHIFT()</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 &gt;&gt; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_AND">
<code>INPLACE_AND()</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 &amp; TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_XOR">
<code>INPLACE_XOR()</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 ^ TOS</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-INPLACE_OR">
<code>INPLACE_OR()</code> </dt> <dd>
<p>Implements in-place <code>TOS = TOS1 | TOS</code>.</p> </dd>
</dl> <p>The slice opcodes take up to three parameters.</p> <dl class="opcode"> <dt id="opcode-SLICE+0">
<code>SLICE+0()</code> </dt> <dd>
<p>Implements <code>TOS = TOS[:]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SLICE+1">
<code>SLICE+1()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1[TOS:]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SLICE+2">
<code>SLICE+2()</code> </dt> <dd>
<p>Implements <code>TOS = TOS1[:TOS]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SLICE+3">
<code>SLICE+3()</code> </dt> <dd>
<p>Implements <code>TOS = TOS2[TOS1:TOS]</code>.</p> </dd>
</dl> <p>Slice assignment needs even an additional parameter. As any statement, they put nothing on the stack.</p> <dl class="opcode"> <dt id="opcode-STORE_SLICE+0">
<code>STORE_SLICE+0()</code> </dt> <dd>
<p>Implements <code>TOS[:] = TOS1</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_SLICE+1">
<code>STORE_SLICE+1()</code> </dt> <dd>
<p>Implements <code>TOS1[TOS:] = TOS2</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_SLICE+2">
<code>STORE_SLICE+2()</code> </dt> <dd>
<p>Implements <code>TOS1[:TOS] = TOS2</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_SLICE+3">
<code>STORE_SLICE+3()</code> </dt> <dd>
<p>Implements <code>TOS2[TOS1:TOS] = TOS3</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_SLICE+0">
<code>DELETE_SLICE+0()</code> </dt> <dd>
<p>Implements <code>del TOS[:]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_SLICE+1">
<code>DELETE_SLICE+1()</code> </dt> <dd>
<p>Implements <code>del TOS1[TOS:]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_SLICE+2">
<code>DELETE_SLICE+2()</code> </dt> <dd>
<p>Implements <code>del TOS1[:TOS]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_SLICE+3">
<code>DELETE_SLICE+3()</code> </dt> <dd>
<p>Implements <code>del TOS2[TOS1:TOS]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_SUBSCR">
<code>STORE_SUBSCR()</code> </dt> <dd>
<p>Implements <code>TOS1[TOS] = TOS2</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_SUBSCR">
<code>DELETE_SUBSCR()</code> </dt> <dd>
<p>Implements <code>del TOS1[TOS]</code>.</p> </dd>
</dl> <p>Miscellaneous opcodes.</p> <dl class="opcode"> <dt id="opcode-PRINT_EXPR">
<code>PRINT_EXPR()</code> </dt> <dd>
<p>Implements the expression statement for the interactive mode. TOS is removed from the stack and printed. In non-interactive mode, an expression statement is terminated with <a class="reference internal" href="#opcode-POP_TOP"><code>POP_TOP</code></a>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-PRINT_ITEM">
<code>PRINT_ITEM()</code> </dt> <dd>
<p>Prints TOS to the file-like object bound to <code>sys.stdout</code>. There is one such instruction for each item in the <a class="reference internal" href="https://docs.python.org/2.7/reference/simple_stmts.html#print"><code>print</code></a> statement.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-PRINT_ITEM_TO">
<code>PRINT_ITEM_TO()</code> </dt> <dd>
<p>Like <code>PRINT_ITEM</code>, but prints the item second from TOS to the file-like object at TOS. This is used by the extended print statement.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-PRINT_NEWLINE">
<code>PRINT_NEWLINE()</code> </dt> <dd>
<p>Prints a new line on <code>sys.stdout</code>. This is generated as the last operation of a <a class="reference internal" href="https://docs.python.org/2.7/reference/simple_stmts.html#print"><code>print</code></a> statement, unless the statement ends with a comma.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-PRINT_NEWLINE_TO">
<code>PRINT_NEWLINE_TO()</code> </dt> <dd>
<p>Like <code>PRINT_NEWLINE</code>, but prints the new line on the file-like object on the TOS. This is used by the extended print statement.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BREAK_LOOP">
<code>BREAK_LOOP()</code> </dt> <dd>
<p>Terminates a loop due to a <a class="reference internal" href="https://docs.python.org/2.7/reference/simple_stmts.html#break"><code>break</code></a> statement.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CONTINUE_LOOP">
<code>CONTINUE_LOOP(target)</code> </dt> <dd>
<p>Continues a loop due to a <a class="reference internal" href="https://docs.python.org/2.7/reference/simple_stmts.html#continue"><code>continue</code></a> statement. <em>target</em> is the address to jump to (which should be a <a class="reference internal" href="#opcode-FOR_ITER"><code>FOR_ITER</code></a> instruction).</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LIST_APPEND">
<code>LIST_APPEND(i)</code> </dt> <dd>
<p>Calls <code>list.append(TOS[-i], TOS)</code>. Used to implement list comprehensions. While the appended value is popped off, the list object remains on the stack so that it is available for further iterations of the loop.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_LOCALS">
<code>LOAD_LOCALS()</code> </dt> <dd>
<p>Pushes a reference to the locals of the current scope on the stack. This is used in the code for a class definition: After the class body is evaluated, the locals are passed to the class definition.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-RETURN_VALUE">
<code>RETURN_VALUE()</code> </dt> <dd>
<p>Returns with TOS to the caller of the function.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-YIELD_VALUE">
<code>YIELD_VALUE()</code> </dt> <dd>
<p>Pops <code>TOS</code> and yields it from a <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-generator"><span class="xref std std-term">generator</span></a>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-IMPORT_STAR">
<code>IMPORT_STAR()</code> </dt> <dd>
<p>Loads all symbols not starting with <code>'_'</code> directly from the module TOS to the local namespace. The module is popped after loading all names. This opcode implements <code>from module import *</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-EXEC_STMT">
<code>EXEC_STMT()</code> </dt> <dd>
<p>Implements <code>exec TOS2,TOS1,TOS</code>. The compiler fills missing optional parameters with <code>None</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_BLOCK">
<code>POP_BLOCK()</code> </dt> <dd>
<p>Removes one block from the block stack. Per frame, there is a stack of blocks, denoting nested loops, try statements, and such.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-END_FINALLY">
<code>END_FINALLY()</code> </dt> <dd>
<p>Terminates a <a class="reference internal" href="https://docs.python.org/2.7/reference/compound_stmts.html#finally"><code>finally</code></a> clause. The interpreter recalls whether the exception has to be re-raised, or whether the function returns, and continues with the outer-next block.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_CLASS">
<code>BUILD_CLASS()</code> </dt> <dd>
<p>Creates a new class object. TOS is the methods dictionary, TOS1 the tuple of the names of the base classes, and TOS2 the class name.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SETUP_WITH">
<code>SETUP_WITH(delta)</code> </dt> <dd>
<p>This opcode performs several operations before a with block starts. First, it loads <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__exit__" title="object.__exit__"><code>__exit__()</code></a> from the context manager and pushes it onto the stack for later use by <a class="reference internal" href="#opcode-WITH_CLEANUP"><code>WITH_CLEANUP</code></a>. Then, <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__enter__" title="object.__enter__"><code>__enter__()</code></a> is called, and a finally block pointing to <em>delta</em> is pushed. Finally, the result of calling the enter method is pushed onto the stack. The next opcode will either ignore it (<a class="reference internal" href="#opcode-POP_TOP"><code>POP_TOP</code></a>), or store it in (a) variable(s) (<a class="reference internal" href="#opcode-STORE_FAST"><code>STORE_FAST</code></a>, <a class="reference internal" href="#opcode-STORE_NAME"><code>STORE_NAME</code></a>, or <a class="reference internal" href="#opcode-UNPACK_SEQUENCE"><code>UNPACK_SEQUENCE</code></a>).</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-WITH_CLEANUP">
<code>WITH_CLEANUP()</code> </dt> <dd>
<p>Cleans up the stack when a <a class="reference internal" href="https://docs.python.org/2.7/reference/compound_stmts.html#with"><code>with</code></a> statement block exits. On top of the stack are 1–3 values indicating how/why the finally clause was entered:</p> <ul class="simple"> <li>TOP = <code>None</code>
</li> <li>(TOP, SECOND) = (<code>WHY_{RETURN,CONTINUE}</code>), retval</li> <li>TOP = <code>WHY_*</code>; no retval below it</li> <li>(TOP, SECOND, THIRD) = exc_info()</li> </ul> <p>Under them is EXIT, the context manager’s <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__exit__" title="object.__exit__"><code>__exit__()</code></a> bound method.</p> <p>In the last case, <code>EXIT(TOP, SECOND, THIRD)</code> is called, otherwise <code>EXIT(None, None, None)</code>.</p> <p>EXIT is removed from the stack, leaving the values above it in the same order. In addition, if the stack represents an exception, <em>and</em> the function call returns a ‘true’ value, this information is “zapped”, to prevent <code>END_FINALLY</code> from re-raising the exception. (But non-local gotos should still be resumed.)</p> </dd>
</dl> <p>All of the following opcodes expect arguments. An argument is two bytes, with the more significant byte last.</p> <dl class="opcode"> <dt id="opcode-STORE_NAME">
<code>STORE_NAME(namei)</code> </dt> <dd>
<p>Implements <code>name = TOS</code>. <em>namei</em> is the index of <em>name</em> in the attribute <code>co_names</code> of the code object. The compiler tries to use <code>STORE_FAST</code> or <code>STORE_GLOBAL</code> if possible.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_NAME">
<code>DELETE_NAME(namei)</code> </dt> <dd>
<p>Implements <code>del name</code>, where <em>namei</em> is the index into <code>co_names</code> attribute of the code object.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-UNPACK_SEQUENCE">
<code>UNPACK_SEQUENCE(count)</code> </dt> <dd>
<p>Unpacks TOS into <em>count</em> individual values, which are put onto the stack right-to-left.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DUP_TOPX">
<code>DUP_TOPX(count)</code> </dt> <dd>
<p>Duplicate <em>count</em> items, keeping them in the same order. Due to implementation limits, <em>count</em> should be between 1 and 5 inclusive.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_ATTR">
<code>STORE_ATTR(namei)</code> </dt> <dd>
<p>Implements <code>TOS.name = TOS1</code>, where <em>namei</em> is the index of name in <code>co_names</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_ATTR">
<code>DELETE_ATTR(namei)</code> </dt> <dd>
<p>Implements <code>del TOS.name</code>, using <em>namei</em> as index into <code>co_names</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_GLOBAL">
<code>STORE_GLOBAL(namei)</code> </dt> <dd>
<p>Works as <code>STORE_NAME</code>, but stores the name as a global.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_GLOBAL">
<code>DELETE_GLOBAL(namei)</code> </dt> <dd>
<p>Works as <code>DELETE_NAME</code>, but deletes a global name.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_CONST">
<code>LOAD_CONST(consti)</code> </dt> <dd>
<p>Pushes <code>co_consts[consti]</code> onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_NAME">
<code>LOAD_NAME(namei)</code> </dt> <dd>
<p>Pushes the value associated with <code>co_names[namei]</code> onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_TUPLE">
<code>BUILD_TUPLE(count)</code> </dt> <dd>
<p>Creates a tuple consuming <em>count</em> items from the stack, and pushes the resulting tuple onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_LIST">
<code>BUILD_LIST(count)</code> </dt> <dd>
<p>Works as <code>BUILD_TUPLE</code>, but creates a list.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_SET">
<code>BUILD_SET(count)</code> </dt> <dd>
<p>Works as <code>BUILD_TUPLE</code>, but creates a set.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_MAP">
<code>BUILD_MAP(count)</code> </dt> <dd>
<p>Pushes a new dictionary object onto the stack. The dictionary is pre-sized to hold <em>count</em> entries.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_ATTR">
<code>LOAD_ATTR(namei)</code> </dt> <dd>
<p>Replaces TOS with <code>getattr(TOS, co_names[namei])</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-COMPARE_OP">
<code>COMPARE_OP(opname)</code> </dt> <dd>
<p>Performs a Boolean operation. The operation name can be found in <code>cmp_op[opname]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-IMPORT_NAME">
<code>IMPORT_NAME(namei)</code> </dt> <dd>
<p>Imports the module <code>co_names[namei]</code>. TOS and TOS1 are popped and provide the <em>fromlist</em> and <em>level</em> arguments of <a class="reference internal" href="functions#__import__" title="__import__"><code>__import__()</code></a>. The module object is pushed onto the stack. The current namespace is not affected: for a proper import statement, a subsequent <code>STORE_FAST</code> instruction modifies the namespace.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-IMPORT_FROM">
<code>IMPORT_FROM(namei)</code> </dt> <dd>
<p>Loads the attribute <code>co_names[namei]</code> from the module found in TOS. The resulting object is pushed onto the stack, to be subsequently stored by a <code>STORE_FAST</code> instruction.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-JUMP_FORWARD">
<code>JUMP_FORWARD(delta)</code> </dt> <dd>
<p>Increments bytecode counter by <em>delta</em>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_JUMP_IF_TRUE">
<code>POP_JUMP_IF_TRUE(target)</code> </dt> <dd>
<p>If TOS is true, sets the bytecode counter to <em>target</em>. TOS is popped.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-POP_JUMP_IF_FALSE">
<code>POP_JUMP_IF_FALSE(target)</code> </dt> <dd>
<p>If TOS is false, sets the bytecode counter to <em>target</em>. TOS is popped.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-JUMP_IF_TRUE_OR_POP">
<code>JUMP_IF_TRUE_OR_POP(target)</code> </dt> <dd>
<p>If TOS is true, sets the bytecode counter to <em>target</em> and leaves TOS on the stack. Otherwise (TOS is false), TOS is popped.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-JUMP_IF_FALSE_OR_POP">
<code>JUMP_IF_FALSE_OR_POP(target)</code> </dt> <dd>
<p>If TOS is false, sets the bytecode counter to <em>target</em> and leaves TOS on the stack. Otherwise (TOS is true), TOS is popped.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-JUMP_ABSOLUTE">
<code>JUMP_ABSOLUTE(target)</code> </dt> <dd>
<p>Set bytecode counter to <em>target</em>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-FOR_ITER">
<code>FOR_ITER(delta)</code> </dt> <dd>
<p><code>TOS</code> is an <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>. Call its <code>next()</code> method. If this yields a new value, push it on the stack (leaving the iterator below it). If the iterator indicates it is exhausted <code>TOS</code> is popped, and the bytecode counter is incremented by <em>delta</em>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_GLOBAL">
<code>LOAD_GLOBAL(namei)</code> </dt> <dd>
<p>Loads the global named <code>co_names[namei]</code> onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SETUP_LOOP">
<code>SETUP_LOOP(delta)</code> </dt> <dd>
<p>Pushes a block for a loop onto the block stack. The block spans from the current instruction with a size of <em>delta</em> bytes.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SETUP_EXCEPT">
<code>SETUP_EXCEPT(delta)</code> </dt> <dd>
<p>Pushes a try block from a try-except clause onto the block stack. <em>delta</em> points to the first except block.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SETUP_FINALLY">
<code>SETUP_FINALLY(delta)</code> </dt> <dd>
<p>Pushes a try block from a try-except clause onto the block stack. <em>delta</em> points to the finally block.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_MAP">
<code>STORE_MAP()</code> </dt> <dd>
<p>Store a key and value pair in a dictionary. Pops the key and value while leaving the dictionary on the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_FAST">
<code>LOAD_FAST(var_num)</code> </dt> <dd>
<p>Pushes a reference to the local <code>co_varnames[var_num]</code> onto the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_FAST">
<code>STORE_FAST(var_num)</code> </dt> <dd>
<p>Stores TOS into the local <code>co_varnames[var_num]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-DELETE_FAST">
<code>DELETE_FAST(var_num)</code> </dt> <dd>
<p>Deletes local <code>co_varnames[var_num]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_CLOSURE">
<code>LOAD_CLOSURE(i)</code> </dt> <dd>
<p>Pushes a reference to the cell contained in slot <em>i</em> of the cell and free variable storage. The name of the variable is <code>co_cellvars[i]</code> if <em>i</em> is less than the length of <em>co_cellvars</em>. Otherwise it is <code>co_freevars[i -
len(co_cellvars)]</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-LOAD_DEREF">
<code>LOAD_DEREF(i)</code> </dt> <dd>
<p>Loads the cell contained in slot <em>i</em> of the cell and free variable storage. Pushes a reference to the object the cell contains on the stack.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-STORE_DEREF">
<code>STORE_DEREF(i)</code> </dt> <dd>
<p>Stores TOS into the cell contained in slot <em>i</em> of the cell and free variable storage.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-SET_LINENO">
<code>SET_LINENO(lineno)</code> </dt> <dd>
<p>This opcode is obsolete.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-RAISE_VARARGS">
<code>RAISE_VARARGS(argc)</code> </dt> <dd>
<p>Raises an exception. <em>argc</em> indicates the number of arguments to the raise statement, ranging from 0 to 3. The handler will find the traceback as TOS2, the parameter as TOS1, and the exception as TOS.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CALL_FUNCTION">
<code>CALL_FUNCTION(argc)</code> </dt> <dd>
<p>Calls a callable object. The low byte of <em>argc</em> indicates the number of positional arguments, the high byte the number of keyword arguments. The stack contains keyword arguments on top (if any), then the positional arguments below that (if any), then the callable object to call below that. Each keyword argument is represented with two values on the stack: the argument’s name, and its value, with the argument’s value above the name on the stack. The positional arguments are pushed in the order that they are passed in to the callable object, with the right-most positional argument on top. <code>CALL_FUNCTION</code> pops all arguments and the callable object off the stack, calls the callable object with those arguments, and pushes the return value returned by the callable object.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-MAKE_FUNCTION">
<code>MAKE_FUNCTION(argc)</code> </dt> <dd>
<p>Pushes a new function object on the stack. TOS is the code associated with the function. The function object is defined to have <em>argc</em> default parameters, which are found below TOS.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-MAKE_CLOSURE">
<code>MAKE_CLOSURE(argc)</code> </dt> <dd>
<p>Creates a new function object, sets its <em>func_closure</em> slot, and pushes it on the stack. TOS is the code associated with the function, TOS1 the tuple containing cells for the closure’s free variables. The function also has <em>argc</em> default parameters, which are found below the cells.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-BUILD_SLICE">
<code>BUILD_SLICE(argc)</code> </dt> <dd>
<p id="index-0">Pushes a slice object on the stack. <em>argc</em> must be 2 or 3. If it is 2, <code>slice(TOS1, TOS)</code> is pushed; if it is 3, <code>slice(TOS2, TOS1, TOS)</code> is pushed. See the <a class="reference internal" href="functions#slice" title="slice"><code>slice()</code></a> built-in function for more information.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-EXTENDED_ARG">
<code>EXTENDED_ARG(ext)</code> </dt> <dd>
<p>Prefixes any opcode which has an argument too big to fit into the default two bytes. <em>ext</em> holds two additional bytes which, taken together with the subsequent opcode’s argument, comprise a four-byte argument, <em>ext</em> being the two most-significant bytes.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CALL_FUNCTION_VAR">
<code>CALL_FUNCTION_VAR(argc)</code> </dt> <dd>
<p>Calls a callable object, similarly to <a class="reference internal" href="#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. <em>argc</em> represents the number of keyword and positional arguments, identically to <a class="reference internal" href="#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. The top of the stack contains an iterable object containing additional positional arguments. Below that are keyword arguments (if any), positional arguments (if any) and a callable object, identically to <a class="reference internal" href="#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. Before the callable object is called, the iterable object is “unpacked” and its contents are appended to the positional arguments passed in. The iterable object is ignored when computing the value of <code>argc</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CALL_FUNCTION_KW">
<code>CALL_FUNCTION_KW(argc)</code> </dt> <dd>
<p>Calls a callable object, similarly to <a class="reference internal" href="#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. <em>argc</em> represents the number of keyword and positional arguments, identically to <a class="reference internal" href="#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. The top of the stack contains a mapping object containing additional keyword arguments. Below that are keyword arguments (if any), positional arguments (if any) and a callable object, identically to <a class="reference internal" href="#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. Before the callable is called, the mapping object at the top of the stack is “unpacked” and its contents are appended to the keyword arguments passed in. The mapping object at the top of the stack is ignored when computing the value of <code>argc</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-CALL_FUNCTION_VAR_KW">
<code>CALL_FUNCTION_VAR_KW(argc)</code> </dt> <dd>
<p>Calls a callable object, similarly to <a class="reference internal" href="#opcode-CALL_FUNCTION_VAR"><code>CALL_FUNCTION_VAR</code></a> and <a class="reference internal" href="#opcode-CALL_FUNCTION_KW"><code>CALL_FUNCTION_KW</code></a>. <em>argc</em> represents the number of keyword and positional arguments, identically to <a class="reference internal" href="#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. The top of the stack contains a mapping object, as per <a class="reference internal" href="#opcode-CALL_FUNCTION_KW"><code>CALL_FUNCTION_KW</code></a>. Below that is an iterable object, as per <a class="reference internal" href="#opcode-CALL_FUNCTION_VAR"><code>CALL_FUNCTION_VAR</code></a>. Below that are keyword arguments (if any), positional arguments (if any) and a callable object, identically to <a class="reference internal" href="#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. Before the callable is called, the mapping object and iterable object are each “unpacked” and their contents passed in as keyword and positional arguments respectively, identically to <a class="reference internal" href="#opcode-CALL_FUNCTION_VAR"><code>CALL_FUNCTION_VAR</code></a> and <a class="reference internal" href="#opcode-CALL_FUNCTION_KW"><code>CALL_FUNCTION_KW</code></a>. The mapping object and iterable object are both ignored when computing the value of <code>argc</code>.</p> </dd>
</dl> <dl class="opcode"> <dt id="opcode-HAVE_ARGUMENT">
<code>HAVE_ARGUMENT()</code> </dt> <dd>
<p>This is not really an opcode. It identifies the dividing line between opcodes which don’t take arguments <code>&lt; HAVE_ARGUMENT</code> and those which do <code>&gt;= HAVE_ARGUMENT</code>.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/dis.html" class="_attribution-link">https://docs.python.org/2.7/library/dis.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
