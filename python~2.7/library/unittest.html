
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Unittest - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" New in version 2.1. ">
  <meta name="keywords" content="unittest, —, unit, testing, framework, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/unittest.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/python~2.7.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="unittest-unit-testing-framework"> unittest — Unit testing framework</h1> <div class="versionadded" id="module-unittest"> <p><span class="versionmodified added">New in version 2.1.</span></p> </div> <p>(If you are already familiar with the basic concepts of testing, you might want to skip to <a class="reference internal" href="#assert-methods"><span class="std std-ref">the list of assert methods</span></a>.)</p> <p>The Python unit testing framework, sometimes referred to as “PyUnit,” is a Python language version of JUnit, by Kent Beck and Erich Gamma. JUnit is, in turn, a Java version of Kent’s Smalltalk testing framework. Each is the de facto standard unit testing framework for its respective language.</p> <p><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> supports test automation, sharing of setup and shutdown code for tests, aggregation of tests into collections, and independence of the tests from the reporting framework. The <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> module provides classes that make it easy to support these qualities for a set of tests.</p> <p>To achieve this, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> supports some important concepts:</p> <dl class="simple"> <dt>test fixture</dt>
<dd>
<p>A <em class="dfn">test fixture</em> represents the preparation needed to perform one or more tests, and any associate cleanup actions. This may involve, for example, creating temporary or proxy databases, directories, or starting a server process.</p> </dd> <dt>test case</dt>
<dd>
<p>A <em class="dfn">test case</em> is the smallest unit of testing. It checks for a specific response to a particular set of inputs. <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> provides a base class, <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a>, which may be used to create new test cases.</p> </dd> <dt>test suite</dt>
<dd>
<p>A <em class="dfn">test suite</em> is a collection of test cases, test suites, or both. It is used to aggregate tests that should be executed together.</p> </dd> <dt>test runner</dt>
<dd>
<p>A <em class="dfn">test runner</em> is a component which orchestrates the execution of tests and provides the outcome to the user. The runner may use a graphical interface, a textual interface, or return a special value to indicate the results of executing the tests.</p> </dd> </dl> <p>The test case and test fixture concepts are supported through the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> and <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code>FunctionTestCase</code></a> classes; the former should be used when creating new tests, and the latter can be used when integrating existing test code with a <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a>-driven framework. When building test fixtures using <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a>, the <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code>setUp()</code></a> and <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code>tearDown()</code></a> methods can be overridden to provide initialization and cleanup for the fixture. With <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code>FunctionTestCase</code></a>, existing functions can be passed to the constructor for these purposes. When the test is run, the fixture initialization is run first; if it succeeds, the cleanup method is run after the test has been executed, regardless of the outcome of the test. Each instance of the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> will only be used to run a single test method, so a new fixture is created for each test.</p> <p>Test suites are implemented by the <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> class. This class allows individual tests and test suites to be aggregated; when the suite is executed, all tests added directly to the suite and in “child” test suites are run.</p> <p>A test runner is an object that provides a single method, <code>run()</code>, which accepts a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> or <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> object as a parameter, and returns a result object. The class <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code>TestResult</code></a> is provided for use as the result object. <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> provides the <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code>TextTestRunner</code></a> as an example test runner which reports test results on the standard error stream by default. Alternate runners can be implemented for other environments (such as graphical environments) without any need to derive from a specific class.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="doctest#module-doctest" title="doctest: Test pieces of code within docstrings."><code>doctest</code></a>
</dt>
<dd>
<p>Another test-support module with a very different flavor.</p> </dd> <dt><a class="reference external" href="https://pypi.org/project/unittest2">unittest2: A backport of new unittest features for Python 2.4-2.6</a></dt>
<dd>
<p>Many new features were added to unittest in Python 2.7, including test discovery. unittest2 allows you to use these features with earlier versions of Python.</p> </dd> <dt><a class="reference external" href="https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm">Simple Smalltalk Testing: With Patterns</a></dt>
<dd>
<p>Kent Beck’s original paper on testing frameworks using the pattern shared by <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a>.</p> </dd> <dt>
<a class="reference external" href="https://nose.readthedocs.io/">Nose</a> and <a class="reference external" href="https://docs.pytest.org/">pytest</a>
</dt>
<dd>
<p>Third-party unittest frameworks with a lighter-weight syntax for writing tests. For example, <code>assert func(10) == 42</code>.</p> </dd> <dt><a class="reference external" href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">The Python Testing Tools Taxonomy</a></dt>
<dd>
<p>An extensive list of Python testing tools including functional testing frameworks and mock object libraries.</p> </dd> <dt><a class="reference external" href="http://lists.idyll.org/listinfo/testing-in-python">Testing in Python Mailing List</a></dt>
<dd>
<p>A special-interest-group for discussion of testing, and testing tools, in Python.</p> </dd> </dl> </div>  <h2 id="unittest-minimal-example">1. Basic example</h2> <p id="basic-example">The <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> module provides a rich set of tools for constructing and running tests. This section demonstrates that a small subset of the tools suffice to meet the needs of most users.</p> <p>Here is a short script to test three string methods:</p> <pre data-language="python">import unittest

class TestStringMethods(unittest.TestCase):

    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO')

    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == '__main__':
    unittest.main()
</pre> <p>A testcase is created by subclassing <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>unittest.TestCase</code></a>. The three individual tests are defined with methods whose names start with the letters <code>test</code>. This naming convention informs the test runner about which methods represent tests.</p> <p>The crux of each test is a call to <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code>assertEqual()</code></a> to check for an expected result; <a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code>assertTrue()</code></a> or <a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code>assertFalse()</code></a> to verify a condition; or <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code>assertRaises()</code></a> to verify that a specific exception gets raised. These methods are used instead of the <a class="reference internal" href="https://docs.python.org/2.7/reference/simple_stmts.html#assert"><code>assert</code></a> statement so the test runner can accumulate all test results and produce a report.</p> <p>The <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code>setUp()</code></a> and <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code>tearDown()</code></a> methods allow you to define instructions that will be executed before and after each test method. They are covered in more detail in the section <a class="reference internal" href="#organizing-tests"><span class="std std-ref">Organizing test code</span></a>.</p> <p>The final block shows a simple way to run the tests. <a class="reference internal" href="#unittest.main" title="unittest.main"><code>unittest.main()</code></a> provides a command-line interface to the test script. When run from the command line, the above script produces an output that looks like this:</p> <pre data-language="python">...
----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK
</pre> <p>Instead of <a class="reference internal" href="#unittest.main" title="unittest.main"><code>unittest.main()</code></a>, there are other ways to run the tests with a finer level of control, less terse output, and no requirement to be run from the command line. For example, the last two lines may be replaced with:</p> <pre data-language="python">suite = unittest.TestLoader().loadTestsFromTestCase(TestStringMethods)
unittest.TextTestRunner(verbosity=2).run(suite)
</pre> <p>Running the revised script from the interpreter or another script produces the following output:</p> <pre data-language="python">test_isupper (__main__.TestStringMethods) ... ok
test_split (__main__.TestStringMethods) ... ok
test_upper (__main__.TestStringMethods) ... ok

----------------------------------------------------------------------
Ran 3 tests in 0.001s

OK
</pre> <p>The above examples show the most commonly used <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> features which are sufficient to meet many everyday testing needs. The remainder of the documentation explores the full feature set from first principles.</p>   <h2 id="unittest-command-line-interface">2. Command-Line Interface</h2> <p id="command-line-interface">The unittest module can be used from the command line to run tests from modules, classes or even individual test methods:</p> <pre data-language="python">python -m unittest test_module1 test_module2
python -m unittest test_module.TestClass
python -m unittest test_module.TestClass.test_method
</pre> <p>You can pass in a list with any combination of module names, and fully qualified class or method names.</p> <p>You can run tests with more detail (higher verbosity) by passing in the -v flag:</p> <pre data-language="python">python -m unittest -v test_module
</pre> <p>For a list of all the command-line options:</p> <pre data-language="python">python -m unittest -h
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>In earlier versions it was only possible to run individual test methods and not modules or classes.</p> </div>  <h3 id="command-line-options">2.1. Command-line options</h3> <p><strong class="program">unittest</strong> supports these command-line options:</p> <dl class="cmdoption"> <dt id="cmdoption-unittest-b">
<code>-b, --buffer</code> </dt> <dd>
<p>The standard output and standard error streams are buffered during the test run. Output during a passing test is discarded. Output is echoed normally on test fail or error and is added to the failure messages.</p> </dd>
</dl> <dl class="cmdoption"> <dt id="cmdoption-unittest-c">
<code>-c, --catch</code> </dt> <dd>
<p><kbd class="kbd docutils literal notranslate">Control-C</kbd> during the test run waits for the current test to end and then reports all the results so far. A second <kbd class="kbd docutils literal notranslate">Control-C</kbd> raises the normal <a class="reference internal" href="exceptions#exceptions.KeyboardInterrupt" title="exceptions.KeyboardInterrupt"><code>KeyboardInterrupt</code></a> exception.</p> <p>See <a class="reference internal" href="#signal-handling">Signal Handling</a> for the functions that provide this functionality.</p> </dd>
</dl> <dl class="cmdoption"> <dt id="cmdoption-unittest-f">
<code>-f, --failfast</code> </dt> <dd>
<p>Stop the test run on the first error or failure.</p> </dd>
</dl> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7: </span>The command-line options <code>-b</code>, <code>-c</code> and <code>-f</code> were added.</p> </div> <p>The command line can also be used for test discovery, for running all of the tests in a project or just a subset.</p>    <h2 id="unittest-test-discovery">3. Test Discovery</h2> <div class="versionadded" id="test-discovery"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> <p>Unittest supports simple test discovery. In order to be compatible with test discovery, all of the test files must be <a class="reference internal" href="https://docs.python.org/2.7/tutorial/modules.html#tut-modules"><span class="std std-ref">modules</span></a> or <a class="reference internal" href="https://docs.python.org/2.7/tutorial/modules.html#tut-packages"><span class="std std-ref">packages</span></a> importable from the top-level directory of the project (this means that their filenames must be valid <a class="reference internal" href="https://docs.python.org/2.7/reference/lexical_analysis.html#identifiers"><span class="std std-ref">identifiers</span></a>).</p> <p>Test discovery is implemented in <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code>TestLoader.discover()</code></a>, but can also be used from the command line. The basic command-line usage is:</p> <pre data-language="python">cd project_directory
python -m unittest discover
</pre> <p>The <code>discover</code> sub-command has the following options:</p> <dl class="cmdoption"> <dt id="cmdoption-unittest-discover-v">
<code>-v, --verbose</code> </dt> <dd>
<p>Verbose output</p> </dd>
</dl> <dl class="cmdoption"> <dt id="cmdoption-unittest-discover-s">
<code>-s, --start-directory directory</code> </dt> <dd>
<p>Directory to start discovery (<code>.</code> default)</p> </dd>
</dl> <dl class="cmdoption"> <dt id="cmdoption-unittest-discover-p">
<code>-p, --pattern pattern</code> </dt> <dd>
<p>Pattern to match test files (<code>test*.py</code> default)</p> </dd>
</dl> <dl class="cmdoption"> <dt id="cmdoption-unittest-discover-t">
<code>-t, --top-level-directory directory</code> </dt> <dd>
<p>Top level directory of project (defaults to start directory)</p> </dd>
</dl> <p>The <a class="reference internal" href="#cmdoption-unittest-discover-s"><code>-s</code></a>, <a class="reference internal" href="#cmdoption-unittest-discover-p"><code>-p</code></a>, and <a class="reference internal" href="#cmdoption-unittest-discover-t"><code>-t</code></a> options can be passed in as positional arguments in that order. The following two command lines are equivalent:</p> <pre data-language="python">python -m unittest discover -s project_directory -p "*_test.py"
python -m unittest discover project_directory "*_test.py"
</pre> <p>As well as being a path it is possible to pass a package name, for example <code>myproject.subpackage.test</code>, as the start directory. The package name you supply will then be imported and its location on the filesystem will be used as the start directory.</p> <div class="admonition caution"> <p class="admonition-title">Caution</p> <p>Test discovery loads tests by importing them. Once test discovery has found all the test files from the start directory you specify it turns the paths into package names to import. For example <code>foo/bar/baz.py</code> will be imported as <code>foo.bar.baz</code>.</p> <p>If you have a package installed globally and attempt test discovery on a different copy of the package then the import <em>could</em> happen from the wrong place. If this happens test discovery will warn you and exit.</p> <p>If you supply the start directory as a package name rather than a path to a directory then discover assumes that whichever location it imports from is the location you intended, so you will not get the warning.</p> </div> <p>Test modules and packages can customize test loading and discovery by through the <a class="reference internal" href="#load-tests-protocol">load_tests protocol</a>.</p>   <h2 id="organizing-tests">4. Organizing test code</h2> <p id="organizing-test-code">The basic building blocks of unit testing are <em class="dfn">test cases</em> — single scenarios that must be set up and checked for correctness. In <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a>, test cases are represented by instances of <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a>’s <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> class. To make your own test cases you must write subclasses of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a>, or use <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code>FunctionTestCase</code></a>.</p> <p>An instance of a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a>-derived class is an object that can completely run a single test method, together with optional set-up and tidy-up code.</p> <p>The testing code of a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> instance should be entirely self contained, such that it can be run either in isolation or in arbitrary combination with any number of other test cases.</p> <p>The simplest <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> subclass will simply override the <code>runTest()</code> method in order to perform specific testing code:</p> <pre data-language="python">import unittest

class DefaultWidgetSizeTestCase(unittest.TestCase):
    def runTest(self):
        widget = Widget('The widget')
        self.assertEqual(widget.size(), (50, 50), 'incorrect default size')
</pre> <p>Note that in order to test something, we use one of the <code>assert*()</code> methods provided by the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> base class. If the test fails, an exception will be raised, and <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> will identify the test case as a <em class="dfn">failure</em>. Any other exceptions will be treated as <em class="dfn">errors</em>. This helps you identify where the problem is: <em class="dfn">failures</em> are caused by incorrect results - a 5 where you expected a 6. <em class="dfn">Errors</em> are caused by incorrect code - e.g., a <a class="reference internal" href="exceptions#exceptions.TypeError" title="exceptions.TypeError"><code>TypeError</code></a> caused by an incorrect function call.</p> <p>The way to run a test case will be described later. For now, note that to construct an instance of such a test case, we call its constructor without arguments:</p> <pre data-language="python">testCase = DefaultWidgetSizeTestCase()
</pre> <p>Now, such test cases can be numerous, and their set-up can be repetitive. In the above case, constructing a <code>Widget</code> in each of 100 Widget test case subclasses would mean unsightly duplication.</p> <p>Luckily, we can factor out such set-up code by implementing a method called <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code>setUp()</code></a>, which the testing framework will automatically call for us when we run the test:</p> <pre data-language="python">import unittest

class SimpleWidgetTestCase(unittest.TestCase):
    def setUp(self):
        self.widget = Widget('The widget')

class DefaultWidgetSizeTestCase(SimpleWidgetTestCase):
    def runTest(self):
        self.assertEqual(self.widget.size(), (50,50),
                         'incorrect default size')

class WidgetResizeTestCase(SimpleWidgetTestCase):
    def runTest(self):
        self.widget.resize(100,150)
        self.assertEqual(self.widget.size(), (100,150),
                         'wrong size after resize')
</pre> <p>If the <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code>setUp()</code></a> method raises an exception while the test is running, the framework will consider the test to have suffered an error, and the <code>runTest()</code> method will not be executed.</p> <p>Similarly, we can provide a <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code>tearDown()</code></a> method that tidies up after the <code>runTest()</code> method has been run:</p> <pre data-language="python">import unittest

class SimpleWidgetTestCase(unittest.TestCase):
    def setUp(self):
        self.widget = Widget('The widget')

    def tearDown(self):
        self.widget.dispose()
        self.widget = None
</pre> <p>If <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code>setUp()</code></a> succeeded, the <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code>tearDown()</code></a> method will be run whether <code>runTest()</code> succeeded or not.</p> <p>Such a working environment for the testing code is called a <em class="dfn">fixture</em>.</p> <p>Often, many small test cases will use the same fixture. In this case, we would end up subclassing <code>SimpleWidgetTestCase</code> into many small one-method classes such as <code>DefaultWidgetSizeTestCase</code>. This is time-consuming and discouraging, so in the same vein as JUnit, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> provides a simpler mechanism:</p> <pre data-language="python">import unittest

class WidgetTestCase(unittest.TestCase):
    def setUp(self):
        self.widget = Widget('The widget')

    def tearDown(self):
        self.widget.dispose()
        self.widget = None

    def test_default_size(self):
        self.assertEqual(self.widget.size(), (50,50),
                         'incorrect default size')

    def test_resize(self):
        self.widget.resize(100,150)
        self.assertEqual(self.widget.size(), (100,150),
                         'wrong size after resize')
</pre> <p>Here we have not provided a <code>runTest()</code> method, but have instead provided two different test methods. Class instances will now each run one of the <code>test_*()</code> methods, with <code>self.widget</code> created and destroyed separately for each instance. When creating an instance we must specify the test method it is to run. We do this by passing the method name in the constructor:</p> <pre data-language="python">defaultSizeTestCase = WidgetTestCase('test_default_size')
resizeTestCase = WidgetTestCase('test_resize')
</pre> <p>Test case instances are grouped together according to the features they test. <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> provides a mechanism for this: the <em class="dfn">test suite</em>, represented by <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a>’s <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> class:</p> <pre data-language="python">widgetTestSuite = unittest.TestSuite()
widgetTestSuite.addTest(WidgetTestCase('test_default_size'))
widgetTestSuite.addTest(WidgetTestCase('test_resize'))
</pre> <p>For the ease of running tests, as we will see later, it is a good idea to provide in each test module a callable object that returns a pre-built test suite:</p> <pre data-language="python">def suite():
    suite = unittest.TestSuite()
    suite.addTest(WidgetTestCase('test_default_size'))
    suite.addTest(WidgetTestCase('test_resize'))
    return suite
</pre> <p>or even:</p> <pre data-language="python">def suite():
    tests = ['test_default_size', 'test_resize']

    return unittest.TestSuite(map(WidgetTestCase, tests))
</pre> <p>Since it is a common pattern to create a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> subclass with many similarly named test functions, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> provides a <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code>TestLoader</code></a> class that can be used to automate the process of creating a test suite and populating it with individual tests. For example,</p> <pre data-language="python">suite = unittest.TestLoader().loadTestsFromTestCase(WidgetTestCase)
</pre> <p>will create a test suite that will run <code>WidgetTestCase.test_default_size()</code> and <code>WidgetTestCase.test_resize</code>. <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code>TestLoader</code></a> uses the <code>'test'</code> method name prefix to identify test methods automatically.</p> <p>Note that the order in which the various test cases will be run is determined by sorting the test function names with respect to the built-in ordering for strings.</p> <p>Often it is desirable to group suites of test cases together, so as to run tests for the whole system at once. This is easy, since <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> instances can be added to a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> just as <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> instances can be added to a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a>:</p> <pre data-language="python">suite1 = module1.TheTestSuite()
suite2 = module2.TheTestSuite()
alltests = unittest.TestSuite([suite1, suite2])
</pre> <p>You can place the definitions of test cases and test suites in the same modules as the code they are to test (such as <code>widget.py</code>), but there are several advantages to placing the test code in a separate module, such as <code>test_widget.py</code>:</p> <ul class="simple"> <li>The test module can be run standalone from the command line.</li> <li>The test code can more easily be separated from shipped code.</li> <li>There is less temptation to change test code to fit the code it tests without a good reason.</li> <li>Test code should be modified much less frequently than the code it tests.</li> <li>Tested code can be refactored more easily.</li> <li>Tests for modules written in C must be in separate modules anyway, so why not be consistent?</li> <li>If the testing strategy changes, there is no need to change the source code.</li> </ul>   <h2 id="legacy-unit-tests">5. Re-using old test code</h2> <p id="re-using-old-test-code">Some users will find that they have existing test code that they would like to run from <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a>, without converting every old test function to a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> subclass.</p> <p>For this reason, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> provides a <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code>FunctionTestCase</code></a> class. This subclass of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> can be used to wrap an existing test function. Set-up and tear-down functions can also be provided.</p> <p>Given the following test function:</p> <pre data-language="python">def testSomething():
    something = makeSomething()
    assert something.name is not None
    # ...
</pre> <p>one can create an equivalent test case instance as follows:</p> <pre data-language="python">testcase = unittest.FunctionTestCase(testSomething)
</pre> <p>If there are additional set-up and tear-down methods that should be called as part of the test case’s operation, they can also be provided like so:</p> <pre data-language="python">testcase = unittest.FunctionTestCase(testSomething,
                                     setUp=makeSomethingDB,
                                     tearDown=deleteSomethingDB)
</pre> <p>To make migrating existing test suites easier, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> supports tests raising <a class="reference internal" href="exceptions#exceptions.AssertionError" title="exceptions.AssertionError"><code>AssertionError</code></a> to indicate test failure. However, it is recommended that you use the explicit <code>TestCase.fail*()</code> and <code>TestCase.assert*()</code> methods instead, as future versions of <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> may treat <a class="reference internal" href="exceptions#exceptions.AssertionError" title="exceptions.AssertionError"><code>AssertionError</code></a> differently.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Even though <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code>FunctionTestCase</code></a> can be used to quickly convert an existing test base over to a <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a>-based system, this approach is not recommended. Taking the time to set up proper <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> subclasses will make future test refactorings infinitely easier.</p> </div> <p>In some cases, the existing tests may have been written using the <a class="reference internal" href="doctest#module-doctest" title="doctest: Test pieces of code within docstrings."><code>doctest</code></a> module. If so, <a class="reference internal" href="doctest#module-doctest" title="doctest: Test pieces of code within docstrings."><code>doctest</code></a> provides a <code>DocTestSuite</code> class that can automatically build <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>unittest.TestSuite</code></a> instances from the existing <a class="reference internal" href="doctest#module-doctest" title="doctest: Test pieces of code within docstrings."><code>doctest</code></a>-based tests.</p>   <h2 id="unittest-skipping">6. Skipping tests and expected failures</h2> <div class="versionadded" id="skipping-tests-and-expected-failures"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> <p>Unittest supports skipping individual test methods and even whole classes of tests. In addition, it supports marking a test as an “expected failure,” a test that is broken and will fail, but shouldn’t be counted as a failure on a <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code>TestResult</code></a>.</p> <p>Skipping a test is simply a matter of using the <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code>skip()</code></a> <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> or one of its conditional variants.</p> <p>Basic skipping looks like this:</p> <pre data-language="python">class MyTestCase(unittest.TestCase):

    @unittest.skip("demonstrating skipping")
    def test_nothing(self):
        self.fail("shouldn't happen")

    @unittest.skipIf(mylib.__version__ &lt; (1, 3),
                     "not supported in this library version")
    def test_format(self):
        # Tests that work for only a certain version of the library.
        pass

    @unittest.skipUnless(sys.platform.startswith("win"), "requires Windows")
    def test_windows_support(self):
        # windows specific testing code
        pass
</pre> <p>This is the output of running the example above in verbose mode:</p> <pre data-language="python">test_format (__main__.MyTestCase) ... skipped 'not supported in this library version'
test_nothing (__main__.MyTestCase) ... skipped 'demonstrating skipping'
test_windows_support (__main__.MyTestCase) ... skipped 'requires Windows'

----------------------------------------------------------------------
Ran 3 tests in 0.005s

OK (skipped=3)
</pre> <p>Classes can be skipped just like methods:</p> <pre data-language="python">@unittest.skip("showing class skipping")
class MySkippedTestCase(unittest.TestCase):
    def test_not_run(self):
        pass
</pre> <p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code>TestCase.setUp()</code></a> can also skip the test. This is useful when a resource that needs to be set up is not available.</p> <p>Expected failures use the <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code>expectedFailure()</code></a> decorator.</p> <pre data-language="python">class ExpectedFailureTestCase(unittest.TestCase):
    @unittest.expectedFailure
    def test_fail(self):
        self.assertEqual(1, 0, "broken")
</pre> <p>It’s easy to roll your own skipping decorators by making a decorator that calls <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code>skip()</code></a> on the test when it wants it to be skipped. This decorator skips the test unless the passed object has a certain attribute:</p> <pre data-language="python">def skipUnlessHasattr(obj, attr):
    if hasattr(obj, attr):
        return lambda func: func
    return unittest.skip("{!r} doesn't have {!r}".format(obj, attr))
</pre> <p>The following decorators implement test skipping and expected failures:</p> <dl class="function"> <dt id="unittest.skip">
<code>unittest.skip(reason)</code> </dt> <dd>
<p>Unconditionally skip the decorated test. <em>reason</em> should describe why the test is being skipped.</p> </dd>
</dl> <dl class="function"> <dt id="unittest.skipIf">
<code>unittest.skipIf(condition, reason)</code> </dt> <dd>
<p>Skip the decorated test if <em>condition</em> is true.</p> </dd>
</dl> <dl class="function"> <dt id="unittest.skipUnless">
<code>unittest.skipUnless(condition, reason)</code> </dt> <dd>
<p>Skip the decorated test unless <em>condition</em> is true.</p> </dd>
</dl> <dl class="function"> <dt id="unittest.expectedFailure">
<code>unittest.expectedFailure()</code> </dt> <dd>
<p>Mark the test as an expected failure. If the test fails when run, the test is not counted as a failure.</p> </dd>
</dl> <dl class="exception"> <dt id="unittest.SkipTest">
<code>exception unittest.SkipTest(reason)</code> </dt> <dd>
<p>This exception is raised to skip a test.</p> <p>Usually you can use <a class="reference internal" href="#unittest.TestCase.skipTest" title="unittest.TestCase.skipTest"><code>TestCase.skipTest()</code></a> or one of the skipping decorators instead of raising this directly.</p> </dd>
</dl> <p>Skipped tests will not have <code>setUp()</code> or <code>tearDown()</code> run around them. Skipped classes will not have <code>setUpClass()</code> or <code>tearDownClass()</code> run.</p>   <h2 id="unittest-contents">7. Classes and functions</h2> <p id="classes-and-functions">This section describes in depth the API of <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a>.</p>  <h3 id="testcase-objects">7.1. Test cases</h3> <dl class="class" id="test-cases"> <dt id="unittest.TestCase">
<code>class unittest.TestCase(methodName='runTest')</code> </dt> <dd>
<p>Instances of the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> class represent the smallest testable units in the <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> universe. This class is intended to be used as a base class, with specific tests being implemented by concrete subclasses. This class implements the interface needed by the test runner to allow it to drive the test, and methods that the test code can use to check for and report various kinds of failure.</p> <p>Each instance of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> will run a single test method: the method named <em>methodName</em>. If you remember, we had an earlier example that went something like this:</p> <pre data-language="python">def suite():
    suite = unittest.TestSuite()
    suite.addTest(WidgetTestCase('test_default_size'))
    suite.addTest(WidgetTestCase('test_resize'))
    return suite
</pre> <p>Here, we create two instances of <code>WidgetTestCase</code>, each of which runs a single test.</p> <p><em>methodName</em> defaults to <code>runTest()</code>.</p> <p><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> instances provide three groups of methods: one group used to run the test, another used by the test implementation to check conditions and report failures, and some inquiry methods allowing information about the test itself to be gathered.</p> <p>Methods in the first group (running the test) are:</p> <dl class="method"> <dt id="unittest.TestCase.setUp">
<code>setUp()</code> </dt> <dd>
<p>Method called to prepare the test fixture. This is called immediately before calling the test method; other than <a class="reference internal" href="exceptions#exceptions.AssertionError" title="exceptions.AssertionError"><code>AssertionError</code></a> or <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code>SkipTest</code></a>, any exception raised by this method will be considered an error rather than a test failure. The default implementation does nothing.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.tearDown">
<code>tearDown()</code> </dt> <dd>
<p>Method called immediately after the test method has been called and the result recorded. This is called even if the test method raised an exception, so the implementation in subclasses may need to be particularly careful about checking internal state. Any exception, other than <a class="reference internal" href="exceptions#exceptions.AssertionError" title="exceptions.AssertionError"><code>AssertionError</code></a> or <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code>SkipTest</code></a>, raised by this method will be considered an additional error rather than a test failure (thus increasing the total number of reported errors). This method will only be called if the <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code>setUp()</code></a> succeeds, regardless of the outcome of the test method. The default implementation does nothing.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.setUpClass">
<code>setUpClass()</code> </dt> <dd>
<p>A class method called before tests in an individual class are run. <code>setUpClass</code> is called with the class as the only argument and must be decorated as a <a class="reference internal" href="functions#classmethod" title="classmethod"><code>classmethod()</code></a>:</p> <pre data-language="python">@classmethod
def setUpClass(cls):
    ...
</pre> <p>See <a class="reference internal" href="#class-and-module-fixtures">Class and Module Fixtures</a> for more details.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.tearDownClass">
<code>tearDownClass()</code> </dt> <dd>
<p>A class method called after tests in an individual class have run. <code>tearDownClass</code> is called with the class as the only argument and must be decorated as a <a class="reference internal" href="functions#classmethod" title="classmethod"><code>classmethod()</code></a>:</p> <pre data-language="python">@classmethod
def tearDownClass(cls):
    ...
</pre> <p>See <a class="reference internal" href="#class-and-module-fixtures">Class and Module Fixtures</a> for more details.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.run">
<code>run(result=None)</code> </dt> <dd>
<p>Run the test, collecting the result into the test result object passed as <em>result</em>. If <em>result</em> is omitted or <code>None</code>, a temporary result object is created (by calling the <a class="reference internal" href="#unittest.TestCase.defaultTestResult" title="unittest.TestCase.defaultTestResult"><code>defaultTestResult()</code></a> method) and used. The result object is not returned to <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code>run()</code></a>’s caller.</p> <p>The same effect may be had by simply calling the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> instance.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.skipTest">
<code>skipTest(reason)</code> </dt> <dd>
<p>Calling this during a test method or <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code>setUp()</code></a> skips the current test. See <a class="reference internal" href="#unittest-skipping"><span class="std std-ref">Skipping tests and expected failures</span></a> for more information.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.debug">
<code>debug()</code> </dt> <dd>
<p>Run the test without collecting the result. This allows exceptions raised by the test to be propagated to the caller, and can be used to support running tests under a debugger.</p> </dd>
</dl> <p id="assert-methods">The <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> class provides several assert methods to check for and report failures. The following table lists the most commonly used methods (see the tables below for more assert methods):</p> <table class="docutils align-center">  <thead> <tr>
<th class="head"><p>Method</p></th> <th class="head"><p>Checks that</p></th> <th class="head"><p>New in</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code>assertEqual(a, b)</code></a></p></td> <td><p><code>a == b</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code>assertNotEqual(a, b)</code></a></p></td> <td><p><code>a != b</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code>assertTrue(x)</code></a></p></td> <td><p><code>bool(x) is True</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code>assertFalse(x)</code></a></p></td> <td><p><code>bool(x) is False</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code>assertIs(a, b)</code></a></p></td> <td><p><code>a is b</code></p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertIsNot" title="unittest.TestCase.assertIsNot"><code>assertIsNot(a, b)</code></a></p></td> <td><p><code>a is not b</code></p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertIsNone" title="unittest.TestCase.assertIsNone"><code>assertIsNone(x)</code></a></p></td> <td><p><code>x is None</code></p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertIsNotNone" title="unittest.TestCase.assertIsNotNone"><code>assertIsNotNone(x)</code></a></p></td> <td><p><code>x is not None</code></p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertIn" title="unittest.TestCase.assertIn"><code>assertIn(a, b)</code></a></p></td> <td><p><code>a in b</code></p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertNotIn" title="unittest.TestCase.assertNotIn"><code>assertNotIn(a, b)</code></a></p></td> <td><p><code>a not in b</code></p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertIsInstance" title="unittest.TestCase.assertIsInstance"><code>assertIsInstance(a, b)</code></a></p></td> <td><p><code>isinstance(a, b)</code></p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertNotIsInstance" title="unittest.TestCase.assertNotIsInstance"><code>assertNotIsInstance(a, b)</code></a></p></td> <td><p><code>not isinstance(a, b)</code></p></td> <td><p>2.7</p></td> </tr>  </table> <p>All the assert methods (except <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code>assertRaises()</code></a>, <a class="reference internal" href="#unittest.TestCase.assertRaisesRegexp" title="unittest.TestCase.assertRaisesRegexp"><code>assertRaisesRegexp()</code></a>) accept a <em>msg</em> argument that, if specified, is used as the error message on failure (see also <a class="reference internal" href="#unittest.TestCase.longMessage" title="unittest.TestCase.longMessage"><code>longMessage</code></a>).</p> <dl class="method"> <dt id="unittest.TestCase.assertEqual">
<code>assertEqual(first, second, msg=None)</code> </dt> <dd>
<p>Test that <em>first</em> and <em>second</em> are equal. If the values do not compare equal, the test will fail.</p> <p>In addition, if <em>first</em> and <em>second</em> are the exact same type and one of list, tuple, dict, set, frozenset or unicode or any type that a subclass registers with <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code>addTypeEqualityFunc()</code></a> the type-specific equality function will be called in order to generate a more useful default error message (see also the <a class="reference internal" href="#type-specific-methods"><span class="std std-ref">list of type-specific methods</span></a>).</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>Added the automatic calling of type-specific equality function.</p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertNotEqual">
<code>assertNotEqual(first, second, msg=None)</code> </dt> <dd>
<p>Test that <em>first</em> and <em>second</em> are not equal. If the values do compare equal, the test will fail.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertTrue">
<code>assertTrue(expr, msg=None)</code> </dt> <dt id="unittest.TestCase.assertFalse">
<code>assertFalse(expr, msg=None)</code> </dt> <dd>
<p>Test that <em>expr</em> is true (or false).</p> <p>Note that this is equivalent to <code>bool(expr) is True</code> and not to <code>expr
is True</code> (use <code>assertIs(expr, True)</code> for the latter). This method should also be avoided when more specific methods are available (e.g. <code>assertEqual(a, b)</code> instead of <code>assertTrue(a == b)</code>), because they provide a better error message in case of failure.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertIs">
<code>assertIs(first, second, msg=None)</code> </dt> <dt id="unittest.TestCase.assertIsNot">
<code>assertIsNot(first, second, msg=None)</code> </dt> <dd>
<p>Test that <em>first</em> and <em>second</em> evaluate (or don’t evaluate) to the same object.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertIsNone">
<code>assertIsNone(expr, msg=None)</code> </dt> <dt id="unittest.TestCase.assertIsNotNone">
<code>assertIsNotNone(expr, msg=None)</code> </dt> <dd>
<p>Test that <em>expr</em> is (or is not) <code>None</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertIn">
<code>assertIn(first, second, msg=None)</code> </dt> <dt id="unittest.TestCase.assertNotIn">
<code>assertNotIn(first, second, msg=None)</code> </dt> <dd>
<p>Test that <em>first</em> is (or is not) in <em>second</em>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertIsInstance">
<code>assertIsInstance(obj, cls, msg=None)</code> </dt> <dt id="unittest.TestCase.assertNotIsInstance">
<code>assertNotIsInstance(obj, cls, msg=None)</code> </dt> <dd>
<p>Test that <em>obj</em> is (or is not) an instance of <em>cls</em> (which can be a class or a tuple of classes, as supported by <a class="reference internal" href="functions#isinstance" title="isinstance"><code>isinstance()</code></a>). To check for the exact type, use <a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code>assertIs(type(obj), cls)</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <p>It is also possible to check that exceptions and warnings are raised using the following methods:</p> <table class="docutils align-center">  <thead> <tr>
<th class="head"><p>Method</p></th> <th class="head"><p>Checks that</p></th> <th class="head"><p>New in</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code>assertRaises(exc, fun, *args, **kwds)</code></a></p></td> <td><p><code>fun(*args, **kwds)</code> raises <em>exc</em></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertRaisesRegexp" title="unittest.TestCase.assertRaisesRegexp"><code>assertRaisesRegexp(exc, r, fun, *args, **kwds)</code></a></p></td> <td><p><code>fun(*args, **kwds)</code> raises <em>exc</em> and the message matches regex <em>r</em></p></td> <td><p>2.7</p></td> </tr>  </table> <dl class="method"> <dt id="unittest.TestCase.assertRaises">
<code>assertRaises(exception, callable, *args, **kwds)</code> </dt> <dt>
<code>assertRaises(exception)</code> </dt> <dd>
<p>Test that an exception is raised when <em>callable</em> is called with any positional or keyword arguments that are also passed to <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code>assertRaises()</code></a>. The test passes if <em>exception</em> is raised, is an error if another exception is raised, or fails if no exception is raised. To catch any of a group of exceptions, a tuple containing the exception classes may be passed as <em>exception</em>.</p> <p>If only the <em>exception</em> argument is given, returns a context manager so that the code under test can be written inline rather than as a function:</p> <pre data-language="python">with self.assertRaises(SomeException):
    do_something()
</pre> <p>The context manager will store the caught exception object in its <code>exception</code> attribute. This can be useful if the intention is to perform additional checks on the exception raised:</p> <pre data-language="python">with self.assertRaises(SomeException) as cm:
    do_something()

the_exception = cm.exception
self.assertEqual(the_exception.error_code, 3)
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>Added the ability to use <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code>assertRaises()</code></a> as a context manager.</p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertRaisesRegexp">
<code>assertRaisesRegexp(exception, regexp, callable, *args, **kwds)</code> </dt> <dt>
<code>assertRaisesRegexp(exception, regexp)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code>assertRaises()</code></a> but also tests that <em>regexp</em> matches on the string representation of the raised exception. <em>regexp</em> may be a regular expression object or a string containing a regular expression suitable for use by <a class="reference internal" href="re#re.search" title="re.search"><code>re.search()</code></a>. Examples:</p> <pre data-language="python">self.assertRaisesRegexp(ValueError, "invalid literal for.*XYZ'$",
                        int, 'XYZ')
</pre> <p>or:</p> <pre data-language="python">with self.assertRaisesRegexp(ValueError, 'literal'):
   int('XYZ')
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <p>There are also other methods used to perform more specific checks, such as:</p> <table class="docutils align-center">  <thead> <tr>
<th class="head"><p>Method</p></th> <th class="head"><p>Checks that</p></th> <th class="head"><p>New in</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code>assertAlmostEqual(a, b)</code></a></p></td> <td><p><code>round(a-b, 7) == 0</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code>assertNotAlmostEqual(a, b)</code></a></p></td> <td><p><code>round(a-b, 7) != 0</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertGreater" title="unittest.TestCase.assertGreater"><code>assertGreater(a, b)</code></a></p></td> <td><p><code>a &gt; b</code></p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertGreaterEqual" title="unittest.TestCase.assertGreaterEqual"><code>assertGreaterEqual(a, b)</code></a></p></td> <td><p><code>a &gt;= b</code></p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertLess" title="unittest.TestCase.assertLess"><code>assertLess(a, b)</code></a></p></td> <td><p><code>a &lt; b</code></p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertLessEqual" title="unittest.TestCase.assertLessEqual"><code>assertLessEqual(a, b)</code></a></p></td> <td><p><code>a &lt;= b</code></p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertRegexpMatches" title="unittest.TestCase.assertRegexpMatches"><code>assertRegexpMatches(s, r)</code></a></p></td> <td><p><code>r.search(s)</code></p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertNotRegexpMatches" title="unittest.TestCase.assertNotRegexpMatches"><code>assertNotRegexpMatches(s, r)</code></a></p></td> <td><p><code>not r.search(s)</code></p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertItemsEqual" title="unittest.TestCase.assertItemsEqual"><code>assertItemsEqual(a, b)</code></a></p></td> <td><p>sorted(a) == sorted(b) and works with unhashable objs</p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertDictContainsSubset" title="unittest.TestCase.assertDictContainsSubset"><code>assertDictContainsSubset(a, b)</code></a></p></td> <td><p>all the key/value pairs in <em>a</em> exist in <em>b</em></p></td> <td><p>2.7</p></td> </tr>  </table> <dl class="method"> <dt id="unittest.TestCase.assertAlmostEqual">
<code>assertAlmostEqual(first, second, places=7, msg=None, delta=None)</code> </dt> <dt id="unittest.TestCase.assertNotAlmostEqual">
<code>assertNotAlmostEqual(first, second, places=7, msg=None, delta=None)</code> </dt> <dd>
<p>Test that <em>first</em> and <em>second</em> are approximately (or not approximately) equal by computing the difference, rounding to the given number of decimal <em>places</em> (default 7), and comparing to zero. Note that these methods round the values to the given number of <em>decimal places</em> (i.e. like the <a class="reference internal" href="functions#round" title="round"><code>round()</code></a> function) and not <em>significant digits</em>.</p> <p>If <em>delta</em> is supplied instead of <em>places</em> then the difference between <em>first</em> and <em>second</em> must be less or equal to (or greater than) <em>delta</em>.</p> <p>Supplying both <em>delta</em> and <em>places</em> raises a <code>TypeError</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code>assertAlmostEqual()</code></a> automatically considers almost equal objects that compare equal. <a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code>assertNotAlmostEqual()</code></a> automatically fails if the objects compare equal. Added the <em>delta</em> keyword argument.</p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertGreater">
<code>assertGreater(first, second, msg=None)</code> </dt> <dt id="unittest.TestCase.assertGreaterEqual">
<code>assertGreaterEqual(first, second, msg=None)</code> </dt> <dt id="unittest.TestCase.assertLess">
<code>assertLess(first, second, msg=None)</code> </dt> <dt id="unittest.TestCase.assertLessEqual">
<code>assertLessEqual(first, second, msg=None)</code> </dt> <dd>
<p>Test that <em>first</em> is respectively &gt;, &gt;=, &lt; or &lt;= than <em>second</em> depending on the method name. If not, the test will fail:</p> <pre data-language="python">&gt;&gt;&gt; self.assertGreaterEqual(3, 4)
AssertionError: "3" unexpectedly not greater than or equal to "4"
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertRegexpMatches">
<code>assertRegexpMatches(text, regexp, msg=None)</code> </dt> <dd>
<p>Test that a <em>regexp</em> search matches <em>text</em>. In case of failure, the error message will include the pattern and the <em>text</em> (or the pattern and the part of <em>text</em> that unexpectedly matched). <em>regexp</em> may be a regular expression object or a string containing a regular expression suitable for use by <a class="reference internal" href="re#re.search" title="re.search"><code>re.search()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertNotRegexpMatches">
<code>assertNotRegexpMatches(text, regexp, msg=None)</code> </dt> <dd>
<p>Verifies that a <em>regexp</em> search does not match <em>text</em>. Fails with an error message including the pattern and the part of <em>text</em> that matches. <em>regexp</em> may be a regular expression object or a string containing a regular expression suitable for use by <a class="reference internal" href="re#re.search" title="re.search"><code>re.search()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertItemsEqual">
<code>assertItemsEqual(actual, expected, msg=None)</code> </dt> <dd>
<p>Test that sequence <em>expected</em> contains the same elements as <em>actual</em>, regardless of their order. When they don’t, an error message listing the differences between the sequences will be generated.</p> <p>Duplicate elements are <em>not</em> ignored when comparing <em>actual</em> and <em>expected</em>. It verifies if each element has the same count in both sequences. It is the equivalent of <code>assertEqual(sorted(expected),
sorted(actual))</code> but it works with sequences of unhashable objects as well.</p> <p>In Python 3, this method is named <code>assertCountEqual</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertDictContainsSubset">
<code>assertDictContainsSubset(expected, actual, msg=None)</code> </dt> <dd>
<p>Tests whether the key/value pairs in dictionary <em>actual</em> are a superset of those in <em>expected</em>. If not, an error message listing the missing keys and mismatched values is generated.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.2.</span></p> </div> </dd>
</dl> <p id="type-specific-methods">The <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code>assertEqual()</code></a> method dispatches the equality check for objects of the same type to different type-specific methods. These methods are already implemented for most of the built-in types, but it’s also possible to register new methods using <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code>addTypeEqualityFunc()</code></a>:</p> <dl class="method"> <dt id="unittest.TestCase.addTypeEqualityFunc">
<code>addTypeEqualityFunc(typeobj, function)</code> </dt> <dd>
<p>Registers a type-specific method called by <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code>assertEqual()</code></a> to check if two objects of exactly the same <em>typeobj</em> (not subclasses) compare equal. <em>function</em> must take two positional arguments and a third msg=None keyword argument just as <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code>assertEqual()</code></a> does. It must raise <a class="reference internal" href="#unittest.TestCase.failureException" title="unittest.TestCase.failureException"><code>self.failureException(msg)</code></a> when inequality between the first two parameters is detected – possibly providing useful information and explaining the inequalities in details in the error message.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <p>The list of type-specific methods automatically used by <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code>assertEqual()</code></a> are summarized in the following table. Note that it’s usually not necessary to invoke these methods directly.</p> <table class="docutils align-center">  <thead> <tr>
<th class="head"><p>Method</p></th> <th class="head"><p>Used to compare</p></th> <th class="head"><p>New in</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code>assertMultiLineEqual(a, b)</code></a></p></td> <td><p>strings</p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code>assertSequenceEqual(a, b)</code></a></p></td> <td><p>sequences</p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code>assertListEqual(a, b)</code></a></p></td> <td><p>lists</p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code>assertTupleEqual(a, b)</code></a></p></td> <td><p>tuples</p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertSetEqual" title="unittest.TestCase.assertSetEqual"><code>assertSetEqual(a, b)</code></a></p></td> <td><p>sets or frozensets</p></td> <td><p>2.7</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code>assertDictEqual(a, b)</code></a></p></td> <td><p>dicts</p></td> <td><p>2.7</p></td> </tr>  </table> <dl class="method"> <dt id="unittest.TestCase.assertMultiLineEqual">
<code>assertMultiLineEqual(first, second, msg=None)</code> </dt> <dd>
<p>Test that the multiline string <em>first</em> is equal to the string <em>second</em>. When not equal a diff of the two strings highlighting the differences will be included in the error message. This method is used by default when comparing Unicode strings with <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code>assertEqual()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertSequenceEqual">
<code>assertSequenceEqual(seq1, seq2, msg=None, seq_type=None)</code> </dt> <dd>
<p>Tests that two sequences are equal. If a <em>seq_type</em> is supplied, both <em>seq1</em> and <em>seq2</em> must be instances of <em>seq_type</em> or a failure will be raised. If the sequences are different an error message is constructed that shows the difference between the two.</p> <p>This method is not called directly by <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code>assertEqual()</code></a>, but it’s used to implement <a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code>assertListEqual()</code></a> and <a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code>assertTupleEqual()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertListEqual">
<code>assertListEqual(list1, list2, msg=None)</code> </dt> <dt id="unittest.TestCase.assertTupleEqual">
<code>assertTupleEqual(tuple1, tuple2, msg=None)</code> </dt> <dd>
<p>Tests that two lists or tuples are equal. If not, an error message is constructed that shows only the differences between the two. An error is also raised if either of the parameters are of the wrong type. These methods are used by default when comparing lists or tuples with <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code>assertEqual()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertSetEqual">
<code>assertSetEqual(set1, set2, msg=None)</code> </dt> <dd>
<p>Tests that two sets are equal. If not, an error message is constructed that lists the differences between the sets. This method is used by default when comparing sets or frozensets with <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code>assertEqual()</code></a>.</p> <p>Fails if either of <em>set1</em> or <em>set2</em> does not have a <code>set.difference()</code> method.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.assertDictEqual">
<code>assertDictEqual(expected, actual, msg=None)</code> </dt> <dd>
<p>Test that two dictionaries are equal. If not, an error message is constructed that shows the differences in the dictionaries. This method will be used by default to compare dictionaries in calls to <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code>assertEqual()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <p id="other-methods-and-attrs">Finally the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> provides the following methods and attributes:</p> <dl class="method"> <dt id="unittest.TestCase.fail">
<code>fail(msg=None)</code> </dt> <dd>
<p>Signals a test failure unconditionally, with <em>msg</em> or <code>None</code> for the error message.</p> </dd>
</dl> <dl class="attribute"> <dt id="unittest.TestCase.failureException">
<code>failureException</code> </dt> <dd>
<p>This class attribute gives the exception raised by the test method. If a test framework needs to use a specialized exception, possibly to carry additional information, it must subclass this exception in order to “play fair” with the framework. The initial value of this attribute is <a class="reference internal" href="exceptions#exceptions.AssertionError" title="exceptions.AssertionError"><code>AssertionError</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="unittest.TestCase.longMessage">
<code>longMessage</code> </dt> <dd>
<p>If set to <code>True</code> then any explicit failure message you pass in to the <a class="reference internal" href="#assert-methods"><span class="std std-ref">assert methods</span></a> will be appended to the end of the normal failure message. The normal messages contain useful information about the objects involved, for example the message from assertEqual shows you the repr of the two unequal objects. Setting this attribute to <code>True</code> allows you to have a custom error message in addition to the normal one.</p> <p>This attribute defaults to <code>False</code>, meaning that a custom message passed to an assert method will silence the normal message.</p> <p>The class setting can be overridden in individual tests by assigning an instance attribute to <code>True</code> or <code>False</code> before calling the assert methods.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="attribute"> <dt id="unittest.TestCase.maxDiff">
<code>maxDiff</code> </dt> <dd>
<p>This attribute controls the maximum length of diffs output by assert methods that report diffs on failure. It defaults to 80*8 characters. Assert methods affected by this attribute are <a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code>assertSequenceEqual()</code></a> (including all the sequence comparison methods that delegate to it), <a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code>assertDictEqual()</code></a> and <a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code>assertMultiLineEqual()</code></a>.</p> <p>Setting <code>maxDiff</code> to <code>None</code> means that there is no maximum length of diffs.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <p>Testing frameworks can use the following methods to collect information on the test:</p> <dl class="method"> <dt id="unittest.TestCase.countTestCases">
<code>countTestCases()</code> </dt> <dd>
<p>Return the number of tests represented by this test object. For <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> instances, this will always be <code>1</code>.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.defaultTestResult">
<code>defaultTestResult()</code> </dt> <dd>
<p>Return an instance of the test result class that should be used for this test case class (if no other result instance is provided to the <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code>run()</code></a> method).</p> <p>For <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> instances, this will always be an instance of <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code>TestResult</code></a>; subclasses of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> should override this as necessary.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.id">
<code>id()</code> </dt> <dd>
<p>Return a string identifying the specific test case. This is usually the full name of the test method, including the module and class name.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.shortDescription">
<code>shortDescription()</code> </dt> <dd>
<p>Returns a description of the test, or <code>None</code> if no description has been provided. The default implementation of this method returns the first line of the test method’s docstring, if available, or <a class="reference internal" href="constants#None" title="None"><code>None</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.addCleanup">
<code>addCleanup(function, *args, **kwargs)</code> </dt> <dd>
<p>Add a function to be called after <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code>tearDown()</code></a> to cleanup resources used during the test. Functions will be called in reverse order to the order they are added (LIFO). They are called with any arguments and keyword arguments passed into <a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code>addCleanup()</code></a> when they are added.</p> <p>If <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code>setUp()</code></a> fails, meaning that <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code>tearDown()</code></a> is not called, then any cleanup functions added will still be called.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestCase.doCleanups">
<code>doCleanups()</code> </dt> <dd>
<p>This method is called unconditionally after <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code>tearDown()</code></a>, or after <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code>setUp()</code></a> if <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code>setUp()</code></a> raises an exception.</p> <p>It is responsible for calling all the cleanup functions added by <a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code>addCleanup()</code></a>. If you need cleanup functions to be called <em>prior</em> to <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code>tearDown()</code></a> then you can call <a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code>doCleanups()</code></a> yourself.</p> <p><a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code>doCleanups()</code></a> pops methods off the stack of cleanup functions one at a time, so it can be called at any time.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="unittest.FunctionTestCase">
<code>class unittest.FunctionTestCase(testFunc, setUp=None, tearDown=None, description=None)</code> </dt> <dd>
<p>This class implements the portion of the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> interface which allows the test runner to drive the test, but does not provide the methods which test code can use to check and report errors. This is used to create test cases using legacy test code, allowing it to be integrated into a <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a>-based test framework.</p> </dd>
</dl>  <h4 id="deprecated-aliases">7.1.1. Deprecated aliases</h4> <p>For historical reasons, some of the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> methods had one or more aliases that are now deprecated. The following table lists the correct names along with their deprecated aliases:</p>  <table class="docutils align-center">  <thead> <tr>
<th class="head"><p>Method Name</p></th> <th class="head"><p>Deprecated alias(es)</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code>assertEqual()</code></a></p></td> <td><p>failUnlessEqual, assertEquals</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code>assertNotEqual()</code></a></p></td> <td><p>failIfEqual</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code>assertTrue()</code></a></p></td> <td><p>failUnless, assert_</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code>assertFalse()</code></a></p></td> <td><p>failIf</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code>assertRaises()</code></a></p></td> <td><p>failUnlessRaises</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code>assertAlmostEqual()</code></a></p></td> <td><p>failUnlessAlmostEqual</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code>assertNotAlmostEqual()</code></a></p></td> <td><p>failIfAlmostEqual</p></td> </tr>  </table> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 2.7: </span>the aliases listed in the second column</p> </div>     <h3 id="testsuite-objects">7.2. Grouping tests</h3> <dl class="class" id="grouping-tests"> <dt id="unittest.TestSuite">
<code>class unittest.TestSuite(tests=())</code> </dt> <dd>
<p>This class represents an aggregation of individual test cases and test suites. The class presents the interface needed by the test runner to allow it to be run as any other test case. Running a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> instance is the same as iterating over the suite, running each test individually.</p> <p>If <em>tests</em> is given, it must be an iterable of individual test cases or other test suites that will be used to build the suite initially. Additional methods are provided to add test cases and suites to the collection later on.</p> <p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> objects behave much like <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> objects, except they do not actually implement a test. Instead, they are used to aggregate tests into groups of tests that should be run together. Some additional methods are available to add tests to <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> instances:</p> <dl class="method"> <dt id="unittest.TestSuite.addTest">
<code>addTest(test)</code> </dt> <dd>
<p>Add a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> or <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> to the suite.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestSuite.addTests">
<code>addTests(tests)</code> </dt> <dd>
<p>Add all the tests from an iterable of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> and <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> instances to this test suite.</p> <p>This is equivalent to iterating over <em>tests</em>, calling <a class="reference internal" href="#unittest.TestSuite.addTest" title="unittest.TestSuite.addTest"><code>addTest()</code></a> for each element.</p> </dd>
</dl> <p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> shares the following methods with <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a>:</p> <dl class="method"> <dt id="unittest.TestSuite.run">
<code>run(result)</code> </dt> <dd>
<p>Run the tests associated with this suite, collecting the result into the test result object passed as <em>result</em>. Note that unlike <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code>TestCase.run()</code></a>, <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code>TestSuite.run()</code></a> requires the result object to be passed in.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestSuite.debug">
<code>debug()</code> </dt> <dd>
<p>Run the tests associated with this suite without collecting the result. This allows exceptions raised by the test to be propagated to the caller and can be used to support running tests under a debugger.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestSuite.countTestCases">
<code>countTestCases()</code> </dt> <dd>
<p>Return the number of tests represented by this test object, including all individual tests and sub-suites.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestSuite.__iter__">
<code>__iter__()</code> </dt> <dd>
<p>Tests grouped by a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> are always accessed by iteration. Subclasses can lazily provide tests by overriding <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code>__iter__()</code></a>. Note that this method maybe called several times on a single suite (for example when counting tests or comparing for equality) so the tests returned must be the same for repeated iterations.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>In earlier versions the <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> accessed tests directly rather than through iteration, so overriding <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code>__iter__()</code></a> wasn’t sufficient for providing tests.</p> </div> </dd>
</dl> <p>In the typical usage of a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> object, the <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code>run()</code></a> method is invoked by a <code>TestRunner</code> rather than by the end-user test harness.</p> </dd>
</dl>   <h3 id="loading-and-running-tests">7.3. Loading and running tests</h3> <dl class="class"> <dt id="unittest.TestLoader">
<code>class unittest.TestLoader</code> </dt> <dd>
<p>The <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code>TestLoader</code></a> class is used to create test suites from classes and modules. Normally, there is no need to create an instance of this class; the <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> module provides an instance that can be shared as <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code>unittest.defaultTestLoader</code></a>. Using a subclass or instance, however, allows customization of some configurable properties.</p> <p><a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code>TestLoader</code></a> objects have the following methods:</p> <dl class="method"> <dt id="unittest.TestLoader.loadTestsFromTestCase">
<code>loadTestsFromTestCase(testCaseClass)</code> </dt> <dd>
<p>Return a suite of all test cases contained in the <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a>-derived <code>testCaseClass</code>.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestLoader.loadTestsFromModule">
<code>loadTestsFromModule(module)</code> </dt> <dd>
<p>Return a suite of all test cases contained in the given module. This method searches <em>module</em> for classes derived from <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> and creates an instance of the class for each test method defined for the class.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>While using a hierarchy of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a>-derived classes can be convenient in sharing fixtures and helper functions, defining test methods on base classes that are not intended to be instantiated directly does not play well with this method. Doing so, however, can be useful when the fixtures are different and defined in subclasses.</p> </div> <p>If a module provides a <code>load_tests</code> function it will be called to load the tests. This allows modules to customize test loading. This is the <a class="reference internal" href="#load-tests-protocol">load_tests protocol</a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>Support for <code>load_tests</code> added.</p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestLoader.loadTestsFromName">
<code>loadTestsFromName(name, module=None)</code> </dt> <dd>
<p>Return a suite of all test cases given a string specifier.</p> <p>The specifier <em>name</em> is a “dotted name” that may resolve either to a module, a test case class, a test method within a test case class, a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> instance, or a callable object which returns a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> or <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> instance. These checks are applied in the order listed here; that is, a method on a possible test case class will be picked up as “a test method within a test case class”, rather than “a callable object”.</p> <p>For example, if you have a module <code>SampleTests</code> containing a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a>-derived class <code>SampleTestCase</code> with three test methods (<code>test_one()</code>, <code>test_two()</code>, and <code>test_three()</code>), the specifier <code>'SampleTests.SampleTestCase'</code> would cause this method to return a suite which will run all three test methods. Using the specifier <code>'SampleTests.SampleTestCase.test_two'</code> would cause it to return a test suite which will run only the <code>test_two()</code> test method. The specifier can refer to modules and packages which have not been imported; they will be imported as a side-effect.</p> <p>The method optionally resolves <em>name</em> relative to the given <em>module</em>.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestLoader.loadTestsFromNames">
<code>loadTestsFromNames(names, module=None)</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#unittest.TestLoader.loadTestsFromName" title="unittest.TestLoader.loadTestsFromName"><code>loadTestsFromName()</code></a>, but takes a sequence of names rather than a single name. The return value is a test suite which supports all the tests defined for each name.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestLoader.getTestCaseNames">
<code>getTestCaseNames(testCaseClass)</code> </dt> <dd>
<p>Return a sorted sequence of method names found within <em>testCaseClass</em>; this should be a subclass of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestLoader.discover">
<code>discover(start_dir, pattern='test*.py', top_level_dir=None)</code> </dt> <dd>
<p>Find all the test modules by recursing into subdirectories from the specified start directory, and return a TestSuite object containing them. Only test files that match <em>pattern</em> will be loaded. (Using shell style pattern matching.) Only module names that are importable (i.e. are valid Python identifiers) will be loaded.</p> <p>All test modules must be importable from the top level of the project. If the start directory is not the top level directory then the top level directory must be specified separately.</p> <p>If importing a module fails, for example due to a syntax error, then this will be recorded as a single error and discovery will continue.</p> <p>If a test package name (directory with <code>__init__.py</code>) matches the pattern then the package will be checked for a <code>load_tests</code> function. If this exists then it will be called with <em>loader</em>, <em>tests</em>, <em>pattern</em>.</p> <p>If load_tests exists then discovery does <em>not</em> recurse into the package, <code>load_tests</code> is responsible for loading all tests in the package.</p> <p>The pattern is deliberately not stored as a loader attribute so that packages can continue discovery themselves. <em>top_level_dir</em> is stored so <code>load_tests</code> does not need to pass this argument in to <code>loader.discover()</code>.</p> <p><em>start_dir</em> can be a dotted module name as well as a directory.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <p>The following attributes of a <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code>TestLoader</code></a> can be configured either by subclassing or assignment on an instance:</p> <dl class="attribute"> <dt id="unittest.TestLoader.testMethodPrefix">
<code>testMethodPrefix</code> </dt> <dd>
<p>String giving the prefix of method names which will be interpreted as test methods. The default value is <code>'test'</code>.</p> <p>This affects <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code>getTestCaseNames()</code></a> and all the <code>loadTestsFrom*()</code> methods.</p> </dd>
</dl> <dl class="attribute"> <dt id="unittest.TestLoader.sortTestMethodsUsing">
<code>sortTestMethodsUsing</code> </dt> <dd>
<p>Function to be used to compare method names when sorting them in <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code>getTestCaseNames()</code></a> and all the <code>loadTestsFrom*()</code> methods. The default value is the built-in <a class="reference internal" href="functions#cmp" title="cmp"><code>cmp()</code></a> function; the attribute can also be set to <a class="reference internal" href="constants#None" title="None"><code>None</code></a> to disable the sort.</p> </dd>
</dl> <dl class="attribute"> <dt id="unittest.TestLoader.suiteClass">
<code>suiteClass</code> </dt> <dd>
<p>Callable object that constructs a test suite from a list of tests. No methods on the resulting object are needed. The default value is the <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> class.</p> <p>This affects all the <code>loadTestsFrom*()</code> methods.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="unittest.TestResult">
<code>class unittest.TestResult</code> </dt> <dd>
<p>This class is used to compile information about which tests have succeeded and which have failed.</p> <p>A <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code>TestResult</code></a> object stores the results of a set of tests. The <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> and <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> classes ensure that results are properly recorded; test authors do not need to worry about recording the outcome of tests.</p> <p>Testing frameworks built on top of <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code>unittest</code></a> may want access to the <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code>TestResult</code></a> object generated by running a set of tests for reporting purposes; a <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code>TestResult</code></a> instance is returned by the <code>TestRunner.run()</code> method for this purpose.</p> <p><a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code>TestResult</code></a> instances have the following attributes that will be of interest when inspecting the results of running a set of tests:</p> <dl class="attribute"> <dt id="unittest.TestResult.errors">
<code>errors</code> </dt> <dd>
<p>A list containing 2-tuples of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> instances and strings holding formatted tracebacks. Each tuple represents a test which raised an unexpected exception.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.2: </span>Contains formatted tracebacks instead of <a class="reference internal" href="sys#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a> results.</p> </div> </dd>
</dl> <dl class="attribute"> <dt id="unittest.TestResult.failures">
<code>failures</code> </dt> <dd>
<p>A list containing 2-tuples of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> instances and strings holding formatted tracebacks. Each tuple represents a test where a failure was explicitly signalled using the <code>TestCase.assert*()</code> methods.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.2: </span>Contains formatted tracebacks instead of <a class="reference internal" href="sys#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a> results.</p> </div> </dd>
</dl> <dl class="attribute"> <dt id="unittest.TestResult.skipped">
<code>skipped</code> </dt> <dd>
<p>A list containing 2-tuples of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> instances and strings holding the reason for skipping the test.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="attribute"> <dt id="unittest.TestResult.expectedFailures">
<code>expectedFailures</code> </dt> <dd>
<p>A list containing 2-tuples of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> instances and strings holding formatted tracebacks. Each tuple represents an expected failure of the test case.</p> </dd>
</dl> <dl class="attribute"> <dt id="unittest.TestResult.unexpectedSuccesses">
<code>unexpectedSuccesses</code> </dt> <dd>
<p>A list containing <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> instances that were marked as expected failures, but succeeded.</p> </dd>
</dl> <dl class="attribute"> <dt id="unittest.TestResult.shouldStop">
<code>shouldStop</code> </dt> <dd>
<p>Set to <code>True</code> when the execution of tests should stop by <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code>stop()</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="unittest.TestResult.testsRun">
<code>testsRun</code> </dt> <dd>
<p>The total number of tests run so far.</p> </dd>
</dl> <dl class="attribute"> <dt id="unittest.TestResult.buffer">
<code>buffer</code> </dt> <dd>
<p>If set to true, <code>sys.stdout</code> and <code>sys.stderr</code> will be buffered in between <a class="reference internal" href="#unittest.TestResult.startTest" title="unittest.TestResult.startTest"><code>startTest()</code></a> and <a class="reference internal" href="#unittest.TestResult.stopTest" title="unittest.TestResult.stopTest"><code>stopTest()</code></a> being called. Collected output will only be echoed onto the real <code>sys.stdout</code> and <code>sys.stderr</code> if the test fails or errors. Any output is also attached to the failure / error message.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="attribute"> <dt id="unittest.TestResult.failfast">
<code>failfast</code> </dt> <dd>
<p>If set to true <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code>stop()</code></a> will be called on the first failure or error, halting the test run.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestResult.wasSuccessful">
<code>wasSuccessful()</code> </dt> <dd>
<p>Return <code>True</code> if all tests run so far have passed, otherwise returns <code>False</code>.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestResult.stop">
<code>stop()</code> </dt> <dd>
<p>This method can be called to signal that the set of tests being run should be aborted by setting the <a class="reference internal" href="#unittest.TestResult.shouldStop" title="unittest.TestResult.shouldStop"><code>shouldStop</code></a> attribute to <code>True</code>. <code>TestRunner</code> objects should respect this flag and return without running any additional tests.</p> <p>For example, this feature is used by the <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code>TextTestRunner</code></a> class to stop the test framework when the user signals an interrupt from the keyboard. Interactive tools which provide <code>TestRunner</code> implementations can use this in a similar manner.</p> </dd>
</dl> <p>The following methods of the <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code>TestResult</code></a> class are used to maintain the internal data structures, and may be extended in subclasses to support additional reporting requirements. This is particularly useful in building tools which support interactive reporting while tests are being run.</p> <dl class="method"> <dt id="unittest.TestResult.startTest">
<code>startTest(test)</code> </dt> <dd>
<p>Called when the test case <em>test</em> is about to be run.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestResult.stopTest">
<code>stopTest(test)</code> </dt> <dd>
<p>Called after the test case <em>test</em> has been executed, regardless of the outcome.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestResult.startTestRun">
<code>startTestRun()</code> </dt> <dd>
<p>Called once before any tests are executed.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestResult.stopTestRun">
<code>stopTestRun()</code> </dt> <dd>
<p>Called once after all tests are executed.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="unittest.TestResult.addError">
<code>addError(test, err)</code> </dt> <dd>
<p>Called when the test case <em>test</em> raises an unexpected exception. <em>err</em> is a tuple of the form returned by <a class="reference internal" href="sys#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a>: <code>(type, value,
traceback)</code>.</p> <p>The default implementation appends a tuple <code>(test, formatted_err)</code> to the instance’s <a class="reference internal" href="#unittest.TestResult.errors" title="unittest.TestResult.errors"><code>errors</code></a> attribute, where <em>formatted_err</em> is a formatted traceback derived from <em>err</em>.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestResult.addFailure">
<code>addFailure(test, err)</code> </dt> <dd>
<p>Called when the test case <em>test</em> signals a failure. <em>err</em> is a tuple of the form returned by <a class="reference internal" href="sys#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a>: <code>(type, value, traceback)</code>.</p> <p>The default implementation appends a tuple <code>(test, formatted_err)</code> to the instance’s <a class="reference internal" href="#unittest.TestResult.failures" title="unittest.TestResult.failures"><code>failures</code></a> attribute, where <em>formatted_err</em> is a formatted traceback derived from <em>err</em>.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestResult.addSuccess">
<code>addSuccess(test)</code> </dt> <dd>
<p>Called when the test case <em>test</em> succeeds.</p> <p>The default implementation does nothing.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestResult.addSkip">
<code>addSkip(test, reason)</code> </dt> <dd>
<p>Called when the test case <em>test</em> is skipped. <em>reason</em> is the reason the test gave for skipping.</p> <p>The default implementation appends a tuple <code>(test, reason)</code> to the instance’s <a class="reference internal" href="#unittest.TestResult.skipped" title="unittest.TestResult.skipped"><code>skipped</code></a> attribute.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestResult.addExpectedFailure">
<code>addExpectedFailure(test, err)</code> </dt> <dd>
<p>Called when the test case <em>test</em> fails, but was marked with the <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code>expectedFailure()</code></a> decorator.</p> <p>The default implementation appends a tuple <code>(test, formatted_err)</code> to the instance’s <a class="reference internal" href="#unittest.TestResult.expectedFailures" title="unittest.TestResult.expectedFailures"><code>expectedFailures</code></a> attribute, where <em>formatted_err</em> is a formatted traceback derived from <em>err</em>.</p> </dd>
</dl> <dl class="method"> <dt id="unittest.TestResult.addUnexpectedSuccess">
<code>addUnexpectedSuccess(test)</code> </dt> <dd>
<p>Called when the test case <em>test</em> was marked with the <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code>expectedFailure()</code></a> decorator, but succeeded.</p> <p>The default implementation appends the test to the instance’s <a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><code>unexpectedSuccesses</code></a> attribute.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="unittest.TextTestResult">
<code>class unittest.TextTestResult(stream, descriptions, verbosity)</code> </dt> <dd>
<p>A concrete implementation of <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code>TestResult</code></a> used by the <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code>TextTestRunner</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7: </span>This class was previously named <code>_TextTestResult</code>. The old name still exists as an alias but is deprecated.</p> </div> </dd>
</dl> <dl class="data"> <dt id="unittest.defaultTestLoader">
<code>unittest.defaultTestLoader</code> </dt> <dd>
<p>Instance of the <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code>TestLoader</code></a> class intended to be shared. If no customization of the <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code>TestLoader</code></a> is needed, this instance can be used instead of repeatedly creating new instances.</p> </dd>
</dl> <dl class="class"> <dt id="unittest.TextTestRunner">
<code>class unittest.TextTestRunner(stream=sys.stderr, descriptions=True, verbosity=1, failfast=False, buffer=False, resultclass=None)</code> </dt> <dd>
<p>A basic test runner implementation which prints results on standard error. It has a few configurable parameters, but is essentially very simple. Graphical applications which run test suites should provide alternate implementations.</p> <dl class="method"> <dt id="unittest.TextTestRunner._makeResult">
<code>_makeResult()</code> </dt> <dd>
<p>This method returns the instance of <code>TestResult</code> used by <code>run()</code>. It is not intended to be called directly, but can be overridden in subclasses to provide a custom <code>TestResult</code>.</p> <p><code>_makeResult()</code> instantiates the class or callable passed in the <code>TextTestRunner</code> constructor as the <code>resultclass</code> argument. It defaults to <a class="reference internal" href="#unittest.TextTestResult" title="unittest.TextTestResult"><code>TextTestResult</code></a> if no <code>resultclass</code> is provided. The result class is instantiated with the following arguments:</p> <pre data-language="python">stream, descriptions, verbosity
</pre> </dd>
</dl> </dd>
</dl> <dl class="function"> <dt id="unittest.main">
<code>unittest.main([module[, defaultTest[, argv[, testRunner[, testLoader[, exit[, verbosity[, failfast[, catchbreak[, buffer]]]]]]]]]])</code> </dt> <dd>
<p>A command-line program that loads a set of tests from <em>module</em> and runs them; this is primarily for making test modules conveniently executable. The simplest use for this function is to include the following line at the end of a test script:</p> <pre data-language="python">if __name__ == '__main__':
    unittest.main()
</pre> <p>You can run tests with more detailed information by passing in the verbosity argument:</p> <pre data-language="python">if __name__ == '__main__':
    unittest.main(verbosity=2)
</pre> <p>The <em>defaultTest</em> argument is the name of the test to run if no test names are specified via <em>argv</em>. If not specified or <code>None</code> and no test names are provided via <em>argv</em>, all tests found in <em>module</em> are run.</p> <p>The <em>argv</em> argument can be a list of options passed to the program, with the first element being the program name. If not specified or <code>None</code>, the values of <a class="reference internal" href="sys#sys.argv" title="sys.argv"><code>sys.argv</code></a> are used.</p> <p>The <em>testRunner</em> argument can either be a test runner class or an already created instance of it. By default <code>main</code> calls <a class="reference internal" href="sys#sys.exit" title="sys.exit"><code>sys.exit()</code></a> with an exit code indicating success or failure of the tests run.</p> <p>The <em>testLoader</em> argument has to be a <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code>TestLoader</code></a> instance, and defaults to <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code>defaultTestLoader</code></a>.</p> <p><code>main</code> supports being used from the interactive interpreter by passing in the argument <code>exit=False</code>. This displays the result on standard output without calling <a class="reference internal" href="sys#sys.exit" title="sys.exit"><code>sys.exit()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; from unittest import main
&gt;&gt;&gt; main(module='test_module', exit=False)
</pre> <p>The <em>failfast</em>, <em>catchbreak</em> and <em>buffer</em> parameters have the same effect as the same-name <a class="reference internal" href="#command-line-options">command-line options</a>.</p> <p>Calling <code>main</code> actually returns an instance of the <code>TestProgram</code> class. This stores the result of the tests run as the <code>result</code> attribute.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>The <em>exit</em>, <em>verbosity</em>, <em>failfast</em>, <em>catchbreak</em> and <em>buffer</em> parameters were added.</p> </div> </dd>
</dl>  <h4 id="load-tests-protocol">7.3.1. load_tests Protocol</h4> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> <p>Modules or packages can customize how tests are loaded from them during normal test runs or test discovery by implementing a function called <code>load_tests</code>.</p> <p>If a test module defines <code>load_tests</code> it will be called by <a class="reference internal" href="#unittest.TestLoader.loadTestsFromModule" title="unittest.TestLoader.loadTestsFromModule"><code>TestLoader.loadTestsFromModule()</code></a> with the following arguments:</p> <pre data-language="python">load_tests(loader, standard_tests, None)
</pre> <p>It should return a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a>.</p> <p><em>loader</em> is the instance of <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code>TestLoader</code></a> doing the loading. <em>standard_tests</em> are the tests that would be loaded by default from the module. It is common for test modules to only want to add or remove tests from the standard set of tests. The third argument is used when loading packages as part of test discovery.</p> <p>A typical <code>load_tests</code> function that loads tests from a specific set of <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> classes may look like:</p> <pre data-language="python">test_cases = (TestCase1, TestCase2, TestCase3)

def load_tests(loader, tests, pattern):
    suite = TestSuite()
    for test_class in test_cases:
        tests = loader.loadTestsFromTestCase(test_class)
        suite.addTests(tests)
    return suite
</pre> <p>If discovery is started, either from the command line or by calling <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code>TestLoader.discover()</code></a>, with a pattern that matches a package name then the package <code>__init__.py</code> will be checked for <code>load_tests</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The default pattern is <code>'test*.py'</code>. This matches all Python files that start with <code>'test'</code> but <em>won’t</em> match any test directories.</p> <p>A pattern like <code>'test*'</code> will match test packages as well as modules.</p> </div> <p>If the package <code>__init__.py</code> defines <code>load_tests</code> then it will be called and discovery not continued into the package. <code>load_tests</code> is called with the following arguments:</p> <pre data-language="python">load_tests(loader, standard_tests, pattern)
</pre> <p>This should return a <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a> representing all the tests from the package. (<code>standard_tests</code> will only contain tests collected from <code>__init__.py</code>.)</p> <p>Because the pattern is passed into <code>load_tests</code> the package is free to continue (and potentially modify) test discovery. A ‘do nothing’ <code>load_tests</code> function for a test package would look like:</p> <pre data-language="python">def load_tests(loader, standard_tests, pattern):
    # top level directory cached on loader instance
    this_dir = os.path.dirname(__file__)
    package_tests = loader.discover(start_dir=this_dir, pattern=pattern)
    standard_tests.addTests(package_tests)
    return standard_tests
</pre>     <h2 id="class-and-module-fixtures">8. Class and Module Fixtures</h2> <p>Class and module level fixtures are implemented in <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code>TestSuite</code></a>. When the test suite encounters a test from a new class then <code>tearDownClass()</code> from the previous class (if there is one) is called, followed by <code>setUpClass()</code> from the new class.</p> <p>Similarly if a test is from a different module from the previous test then <code>tearDownModule</code> from the previous module is run, followed by <code>setUpModule</code> from the new module.</p> <p>After all the tests have run the final <code>tearDownClass</code> and <code>tearDownModule</code> are run.</p> <p>Note that shared fixtures do not play well with [potential] features like test parallelization and they break test isolation. They should be used with care.</p> <p>The default ordering of tests created by the unittest test loaders is to group all tests from the same modules and classes together. This will lead to <code>setUpClass</code> / <code>setUpModule</code> (etc) being called exactly once per class and module. If you randomize the order, so that tests from different modules and classes are adjacent to each other, then these shared fixture functions may be called multiple times in a single test run.</p> <p>Shared fixtures are not intended to work with suites with non-standard ordering. A <code>BaseTestSuite</code> still exists for frameworks that don’t want to support shared fixtures.</p> <p>If there are any exceptions raised during one of the shared fixture functions the test is reported as an error. Because there is no corresponding test instance an <code>_ErrorHolder</code> object (that has the same interface as a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a>) is created to represent the error. If you are just using the standard unittest test runner then this detail doesn’t matter, but if you are a framework author it may be relevant.</p>  <h3 id="setupclass-and-teardownclass">8.1. setUpClass and tearDownClass</h3> <p>These must be implemented as class methods:</p> <pre data-language="python">import unittest

class Test(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls._connection = createExpensiveConnectionObject()

    @classmethod
    def tearDownClass(cls):
        cls._connection.destroy()
</pre> <p>If you want the <code>setUpClass</code> and <code>tearDownClass</code> on base classes called then you must call up to them yourself. The implementations in <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code>TestCase</code></a> are empty.</p> <p>If an exception is raised during a <code>setUpClass</code> then the tests in the class are not run and the <code>tearDownClass</code> is not run. Skipped classes will not have <code>setUpClass</code> or <code>tearDownClass</code> run. If the exception is a <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code>SkipTest</code></a> exception then the class will be reported as having been skipped instead of as an error.</p>   <h3 id="setupmodule-and-teardownmodule">8.2. setUpModule and tearDownModule</h3> <p>These should be implemented as functions:</p> <pre data-language="python">def setUpModule():
    createConnection()

def tearDownModule():
    closeConnection()
</pre> <p>If an exception is raised in a <code>setUpModule</code> then none of the tests in the module will be run and the <code>tearDownModule</code> will not be run. If the exception is a <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code>SkipTest</code></a> exception then the module will be reported as having been skipped instead of as an error.</p>    <h2 id="signal-handling">9. Signal Handling</h2> <p>The <a class="reference internal" href="#cmdoption-unittest-c"><code>-c/--catch</code></a> command-line option to unittest, along with the <code>catchbreak</code> parameter to <a class="reference internal" href="#unittest.main" title="unittest.main"><code>unittest.main()</code></a>, provide more friendly handling of control-C during a test run. With catch break behavior enabled control-C will allow the currently running test to complete, and the test run will then end and report all the results so far. A second control-c will raise a <a class="reference internal" href="exceptions#exceptions.KeyboardInterrupt" title="exceptions.KeyboardInterrupt"><code>KeyboardInterrupt</code></a> in the usual way.</p> <p>The control-c handling signal handler attempts to remain compatible with code or tests that install their own <code>signal.SIGINT</code> handler. If the <code>unittest</code> handler is called but <em>isn’t</em> the installed <code>signal.SIGINT</code> handler, i.e. it has been replaced by the system under test and delegated to, then it calls the default handler. This will normally be the expected behavior by code that replaces an installed handler and delegates to it. For individual tests that need <code>unittest</code> control-c handling disabled the <a class="reference internal" href="#unittest.removeHandler" title="unittest.removeHandler"><code>removeHandler()</code></a> decorator can be used.</p> <p>There are a few utility functions for framework authors to enable control-c handling functionality within test frameworks.</p> <dl class="function"> <dt id="unittest.installHandler">
<code>unittest.installHandler()</code> </dt> <dd>
<p>Install the control-c handler. When a <code>signal.SIGINT</code> is received (usually in response to the user pressing control-c) all registered results have <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code>stop()</code></a> called.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="unittest.registerResult">
<code>unittest.registerResult(result)</code> </dt> <dd>
<p>Register a <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code>TestResult</code></a> object for control-c handling. Registering a result stores a weak reference to it, so it doesn’t prevent the result from being garbage collected.</p> <p>Registering a <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code>TestResult</code></a> object has no side-effects if control-c handling is not enabled, so test frameworks can unconditionally register all results they create independently of whether or not handling is enabled.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="unittest.removeResult">
<code>unittest.removeResult(result)</code> </dt> <dd>
<p>Remove a registered result. Once a result has been removed then <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code>stop()</code></a> will no longer be called on that result object in response to a control-c.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="unittest.removeHandler">
<code>unittest.removeHandler(function=None)</code> </dt> <dd>
<p>When called without arguments this function removes the control-c handler if it has been installed. This function can also be used as a test decorator to temporarily remove the handler while the test is being executed:</p> <pre data-language="python">@unittest.removeHandler
def test_signal_handling(self):
    ...
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/unittest.html" class="_attribution-link">https://docs.python.org/2.7/library/unittest.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
