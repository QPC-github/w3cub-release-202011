
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Logging - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" Important ">
  <meta name="keywords" content="logging, —, facility, for, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/logging.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/python~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="logging-logging-facility-for-python"> logging — Logging facility for Python</h1> <div class="sidebar" id="module-logging"> <p class="sidebar-title">Important</p> <p>This page contains the API reference information. For tutorial information and discussion of more advanced topics, see</p> <ul class="simple"> <li><a class="reference internal" href="https://docs.python.org/2.7/howto/logging.html#logging-basic-tutorial"><span class="std std-ref">Basic Tutorial</span></a></li> <li><a class="reference internal" href="https://docs.python.org/2.7/howto/logging.html#logging-advanced-tutorial"><span class="std std-ref">Advanced Tutorial</span></a></li> <li><a class="reference internal" href="https://docs.python.org/2.7/howto/logging-cookbook.html#logging-cookbook"><span class="std std-ref">Logging Cookbook</span></a></li> </ul> </div> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/2.7/Lib/logging/__init__.py">Lib/logging/__init__.py</a></p>  <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> <p>This module defines functions and classes which implement a flexible event logging system for applications and libraries.</p> <p>The key benefit of having the logging API provided by a standard library module is that all Python modules can participate in logging, so your application log can include your own messages integrated with messages from third-party modules.</p> <p>The module provides a lot of functionality and flexibility. If you are unfamiliar with logging, the best way to get to grips with it is to see the tutorials (see the links on the right).</p> <p>The basic classes defined by the module, together with their functions, are listed below.</p> <ul class="simple"> <li>Loggers expose the interface that application code directly uses.</li> <li>Handlers send the log records (created by loggers) to the appropriate destination.</li> <li>Filters provide a finer grained facility for determining which log records to output.</li> <li>Formatters specify the layout of log records in the final output.</li> </ul>  <h2 id="logger">1. Logger Objects</h2> <p id="logger-objects">Loggers have the following attributes and methods. Note that Loggers are never instantiated directly, but always through the module-level function <code>logging.getLogger(name)</code>. Multiple calls to <a class="reference internal" href="#logging.getLogger" title="logging.getLogger"><code>getLogger()</code></a> with the same name will always return a reference to the same Logger object.</p> <p>The <code>name</code> is potentially a period-separated hierarchical value, like <code>foo.bar.baz</code> (though it could also be just plain <code>foo</code>, for example). Loggers that are further down in the hierarchical list are children of loggers higher up in the list. For example, given a logger with a name of <code>foo</code>, loggers with names of <code>foo.bar</code>, <code>foo.bar.baz</code>, and <code>foo.bam</code> are all descendants of <code>foo</code>. The logger name hierarchy is analogous to the Python package hierarchy, and identical to it if you organise your loggers on a per-module basis using the recommended construction <code>logging.getLogger(__name__)</code>. That’s because in a module, <code>__name__</code> is the module’s name in the Python package namespace.</p> <dl class="class"> <dt id="logging.Logger">
<code>class logging.Logger</code> </dt> 
</dl> <dl class="attribute"> <dt id="logging.Logger.propagate">
<code>Logger.propagate</code> </dt> <dd>
<p>If this evaluates to true, events logged to this logger will be passed to the handlers of higher level (ancestor) loggers, in addition to any handlers attached to this logger. Messages are passed directly to the ancestor loggers’ handlers - neither the level nor filters of the ancestor loggers in question are considered.</p> <p>If this evaluates to false, logging messages are not passed to the handlers of ancestor loggers.</p> <p>The constructor sets this attribute to <code>True</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you attach a handler to a logger <em>and</em> one or more of its ancestors, it may emit the same record multiple times. In general, you should not need to attach a handler to more than one logger - if you just attach it to the appropriate logger which is highest in the logger hierarchy, then it will see all events logged by all descendant loggers, provided that their propagate setting is left set to <code>True</code>. A common scenario is to attach handlers only to the root logger, and to let propagation take care of the rest.</p> </div> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.setLevel">
<code>Logger.setLevel(level)</code> </dt> <dd>
<p>Sets the threshold for this logger to <em>level</em>. Logging messages which are less severe than <em>level</em> will be ignored. When a logger is created, the level is set to <code>NOTSET</code> (which causes all messages to be processed when the logger is the root logger, or delegation to the parent when the logger is a non-root logger). Note that the root logger is created with level <code>WARNING</code>.</p> <p>The term ‘delegation to the parent’ means that if a logger has a level of NOTSET, its chain of ancestor loggers is traversed until either an ancestor with a level other than NOTSET is found, or the root is reached.</p> <p>If an ancestor is found with a level other than NOTSET, then that ancestor’s level is treated as the effective level of the logger where the ancestor search began, and is used to determine how a logging event is handled.</p> <p>If the root is reached, and it has a level of NOTSET, then all messages will be processed. Otherwise, the root’s level will be used as the effective level.</p> <p>See <a class="reference internal" href="#levels"><span class="std std-ref">Logging Levels</span></a> for a list of levels.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.isEnabledFor">
<code>Logger.isEnabledFor(lvl)</code> </dt> <dd>
<p>Indicates if a message of severity <em>lvl</em> would be processed by this logger. This method checks first the module-level level set by <code>logging.disable(lvl)</code> and then the logger’s effective level as determined by <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code>getEffectiveLevel()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.getEffectiveLevel">
<code>Logger.getEffectiveLevel()</code> </dt> <dd>
<p>Indicates the effective level for this logger. If a value other than <code>NOTSET</code> has been set using <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code>setLevel()</code></a>, it is returned. Otherwise, the hierarchy is traversed towards the root until a value other than <code>NOTSET</code> is found, and that value is returned. The value returned is an integer, typically one of <code>logging.DEBUG</code>, <code>logging.INFO</code> etc.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.getChild">
<code>Logger.getChild(suffix)</code> </dt> <dd>
<p>Returns a logger which is a descendant to this logger, as determined by the suffix. Thus, <code>logging.getLogger('abc').getChild('def.ghi')</code> would return the same logger as would be returned by <code>logging.getLogger('abc.def.ghi')</code>. This is a convenience method, useful when the parent logger is named using e.g. <code>__name__</code> rather than a literal string.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.debug">
<code>Logger.debug(msg, *args, **kwargs)</code> </dt> <dd>
<p>Logs a message with level <code>DEBUG</code> on this logger. The <em>msg</em> is the message format string, and the <em>args</em> are the arguments which are merged into <em>msg</em> using the string formatting operator. (Note that this means that you can use keywords in the format string, together with a single dictionary argument.)</p> <p>There are two keyword arguments in <em>kwargs</em> which are inspected: <em>exc_info</em> which, if it does not evaluate as false, causes exception information to be added to the logging message. If an exception tuple (in the format returned by <a class="reference internal" href="sys#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a>) is provided, it is used; otherwise, <a class="reference internal" href="sys#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a> is called to get the exception information.</p> <p>The second keyword argument is <em>extra</em> which can be used to pass a dictionary which is used to populate the __dict__ of the LogRecord created for the logging event with user-defined attributes. These custom attributes can then be used as you like. For example, they could be incorporated into logged messages. For example:</p> <pre data-language="python">FORMAT = '%(asctime)-15s %(clientip)s %(user)-8s %(message)s'
logging.basicConfig(format=FORMAT)
d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}
logger = logging.getLogger('tcpserver')
logger.warning('Protocol problem: %s', 'connection reset', extra=d)
</pre> <p>would print something like</p> <pre data-language="python">2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
</pre> <p>The keys in the dictionary passed in <em>extra</em> should not clash with the keys used by the logging system. (See the <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> documentation for more information on which keys are used by the logging system.)</p> <p>If you choose to use these attributes in logged messages, you need to exercise some care. In the above example, for instance, the <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> has been set up with a format string which expects ‘clientip’ and ‘user’ in the attribute dictionary of the LogRecord. If these are missing, the message will not be logged because a string formatting exception will occur. So in this case, you always need to pass the <em>extra</em> dictionary with these keys.</p> <p>While this might be annoying, this feature is intended for use in specialized circumstances, such as multi-threaded servers where the same code executes in many contexts, and interesting conditions which arise are dependent on this context (such as remote client IP address and authenticated user name, in the above example). In such circumstances, it is likely that specialized <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a>s would be used with particular <code>Handler</code>s.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.info">
<code>Logger.info(msg, *args, **kwargs)</code> </dt> <dd>
<p>Logs a message with level <code>INFO</code> on this logger. The arguments are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.warning">
<code>Logger.warning(msg, *args, **kwargs)</code> </dt> <dd>
<p>Logs a message with level <code>WARNING</code> on this logger. The arguments are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.error">
<code>Logger.error(msg, *args, **kwargs)</code> </dt> <dd>
<p>Logs a message with level <code>ERROR</code> on this logger. The arguments are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.critical">
<code>Logger.critical(msg, *args, **kwargs)</code> </dt> <dd>
<p>Logs a message with level <code>CRITICAL</code> on this logger. The arguments are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.log">
<code>Logger.log(lvl, msg, *args, **kwargs)</code> </dt> <dd>
<p>Logs a message with integer level <em>lvl</em> on this logger. The other arguments are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.exception">
<code>Logger.exception(msg, *args, **kwargs)</code> </dt> <dd>
<p>Logs a message with level <code>ERROR</code> on this logger. The arguments are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>, except that any passed <em>exc_info</em> is not inspected. Exception info is always added to the logging message. This method should only be called from an exception handler.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.addFilter">
<code>Logger.addFilter(filter)</code> </dt> <dd>
<p>Adds the specified filter <em>filter</em> to this logger.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.removeFilter">
<code>Logger.removeFilter(filter)</code> </dt> <dd>
<p>Removes the specified filter <em>filter</em> from this logger.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.filter">
<code>Logger.filter(record)</code> </dt> <dd>
<p>Applies this logger’s filters to the record and returns a true value if the record is to be processed. The filters are consulted in turn, until one of them returns a false value. If none of them return a false value, the record will be processed (passed to handlers). If one returns a false value, no further processing of the record occurs.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.addHandler">
<code>Logger.addHandler(hdlr)</code> </dt> <dd>
<p>Adds the specified handler <em>hdlr</em> to this logger.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.removeHandler">
<code>Logger.removeHandler(hdlr)</code> </dt> <dd>
<p>Removes the specified handler <em>hdlr</em> from this logger.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.findCaller">
<code>Logger.findCaller()</code> </dt> <dd>
<p>Finds the caller’s source filename and line number. Returns the filename, line number and function name as a 3-element tuple.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.4: </span>The function name was added. In earlier versions, the filename and line number were returned as a 2-element tuple.</p> </div> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.handle">
<code>Logger.handle(record)</code> </dt> <dd>
<p>Handles a record by passing it to all handlers associated with this logger and its ancestors (until a false value of <em>propagate</em> is found). This method is used for unpickled records received from a socket, as well as those created locally. Logger-level filtering is applied using <a class="reference internal" href="#logging.Logger.filter" title="logging.Logger.filter"><code>filter()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Logger.makeRecord">
<code>Logger.makeRecord(name, lvl, fn, lno, msg, args, exc_info, func=None, extra=None)</code> </dt> <dd>
<p>This is a factory method which can be overridden in subclasses to create specialized <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> instances.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.5: </span><em>func</em> and <em>extra</em> were added.</p> </div> </dd>
</dl>   <h2 id="levels">2. Logging Levels</h2> <p id="logging-levels">The numeric values of logging levels are given in the following table. These are primarily of interest if you want to define your own levels, and need them to have specific values relative to the predefined levels. If you define a level with the same numeric value, it overwrites the predefined value; the predefined name is lost.</p> <table class="docutils align-center">  <thead> <tr>
<th class="head"><p>Level</p></th> <th class="head"><p>Numeric value</p></th> </tr> </thead>  <tr>
<td><p><code>CRITICAL</code></p></td> <td><p>50</p></td> </tr> <tr>
<td><p><code>ERROR</code></p></td> <td><p>40</p></td> </tr> <tr>
<td><p><code>WARNING</code></p></td> <td><p>30</p></td> </tr> <tr>
<td><p><code>INFO</code></p></td> <td><p>20</p></td> </tr> <tr>
<td><p><code>DEBUG</code></p></td> <td><p>10</p></td> </tr> <tr>
<td><p><code>NOTSET</code></p></td> <td><p>0</p></td> </tr>  </table>   <h2 id="handler">3. Handler Objects</h2> <p id="handler-objects">Handlers have the following attributes and methods. Note that <code>Handler</code> is never instantiated directly; this class acts as a base for more useful subclasses. However, the <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> method in subclasses needs to call <a class="reference internal" href="#logging.Handler.__init__" title="logging.Handler.__init__"><code>Handler.__init__()</code></a>.</p> <dl class="method"> <dt id="logging.Handler.__init__">
<code>Handler.__init__(level=NOTSET)</code> </dt> <dd>
<p>Initializes the <code>Handler</code> instance by setting its level, setting the list of filters to the empty list and creating a lock (using <a class="reference internal" href="#logging.Handler.createLock" title="logging.Handler.createLock"><code>createLock()</code></a>) for serializing access to an I/O mechanism.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.createLock">
<code>Handler.createLock()</code> </dt> <dd>
<p>Initializes a thread lock which can be used to serialize access to underlying I/O functionality which may not be threadsafe.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.acquire">
<code>Handler.acquire()</code> </dt> <dd>
<p>Acquires the thread lock created with <a class="reference internal" href="#logging.Handler.createLock" title="logging.Handler.createLock"><code>createLock()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.release">
<code>Handler.release()</code> </dt> <dd>
<p>Releases the thread lock acquired with <a class="reference internal" href="#logging.Handler.acquire" title="logging.Handler.acquire"><code>acquire()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.setLevel">
<code>Handler.setLevel(level)</code> </dt> <dd>
<p>Sets the threshold for this handler to <em>level</em>. Logging messages which are less severe than <em>level</em> will be ignored. When a handler is created, the level is set to <code>NOTSET</code> (which causes all messages to be processed).</p> <p>See <a class="reference internal" href="#levels"><span class="std std-ref">Logging Levels</span></a> for a list of levels.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.setFormatter">
<code>Handler.setFormatter(fmt)</code> </dt> <dd>
<p>Sets the <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> for this handler to <em>fmt</em>.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.addFilter">
<code>Handler.addFilter(filter)</code> </dt> <dd>
<p>Adds the specified filter <em>filter</em> to this handler.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.removeFilter">
<code>Handler.removeFilter(filter)</code> </dt> <dd>
<p>Removes the specified filter <em>filter</em> from this handler.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.filter">
<code>Handler.filter(record)</code> </dt> <dd>
<p>Applies this handler’s filters to the record and returns a true value if the record is to be processed. The filters are consulted in turn, until one of them returns a false value. If none of them return a false value, the record will be emitted. If one returns a false value, the handler will not emit the record.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.flush">
<code>Handler.flush()</code> </dt> <dd>
<p>Ensure all logging output has been flushed. This version does nothing and is intended to be implemented by subclasses.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.close">
<code>Handler.close()</code> </dt> <dd>
<p>Tidy up any resources used by the handler. This version does no output but removes the handler from an internal list of handlers which is closed when <a class="reference internal" href="#logging.shutdown" title="logging.shutdown"><code>shutdown()</code></a> is called. Subclasses should ensure that this gets called from overridden <a class="reference internal" href="#logging.Handler.close" title="logging.Handler.close"><code>close()</code></a> methods.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.handle">
<code>Handler.handle(record)</code> </dt> <dd>
<p>Conditionally emits the specified logging record, depending on filters which may have been added to the handler. Wraps the actual emission of the record with acquisition/release of the I/O thread lock.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.handleError">
<code>Handler.handleError(record)</code> </dt> <dd>
<p>This method should be called from handlers when an exception is encountered during an <a class="reference internal" href="#logging.Handler.emit" title="logging.Handler.emit"><code>emit()</code></a> call. If the module-level attribute <code>raiseExceptions</code> is <code>False</code>, exceptions get silently ignored. This is what is mostly wanted for a logging system - most users will not care about errors in the logging system, they are more interested in application errors. You could, however, replace this with a custom handler if you wish. The specified record is the one which was being processed when the exception occurred. (The default value of <code>raiseExceptions</code> is <code>True</code>, as that is more useful during development).</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.format">
<code>Handler.format(record)</code> </dt> <dd>
<p>Do formatting for a record - if a formatter is set, use it. Otherwise, use the default formatter for the module.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Handler.emit">
<code>Handler.emit(record)</code> </dt> <dd>
<p>Do whatever it takes to actually log the specified logging record. This version is intended to be implemented by subclasses and so raises a <a class="reference internal" href="exceptions#exceptions.NotImplementedError" title="exceptions.NotImplementedError"><code>NotImplementedError</code></a>.</p> </dd>
</dl> <p>For a list of handlers included as standard, see <a class="reference internal" href="logging.handlers#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code>logging.handlers</code></a>.</p>   <h2 id="id1">4. Formatter Objects</h2> <p id="formatter-objects"><a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> objects have the following attributes and methods. They are responsible for converting a <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> to (usually) a string which can be interpreted by either a human or an external system. The base <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> allows a formatting string to be specified. If none is supplied, the default value of <code>'%(message)s'</code> is used, which just includes the message in the logging call. To have additional items of information in the formatted output (such as a timestamp), keep reading.</p> <p>A Formatter can be initialized with a format string which makes use of knowledge of the <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> attributes - such as the default value mentioned above making use of the fact that the user’s message and arguments are pre-formatted into a <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a>’s <em>message</em> attribute. This format string contains standard Python %-style mapping keys. See section <a class="reference internal" href="stdtypes#string-formatting"><span class="std std-ref">String Formatting Operations</span></a> for more information on string formatting.</p> <p>The useful mapping keys in a <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> are given in the section on <a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">LogRecord attributes</span></a>.</p> <dl class="class"> <dt id="logging.Formatter">
<code>class logging.Formatter(fmt=None, datefmt=None)</code> </dt> <dd>
<p>Returns a new instance of the <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> class. The instance is initialized with a format string for the message as a whole, as well as a format string for the date/time portion of a message. If no <em>fmt</em> is specified, <code>'%(message)s'</code> is used. If no <em>datefmt</em> is specified, the ISO8601 date format is used.</p> <dl class="method"> <dt id="logging.Formatter.format">
<code>format(record)</code> </dt> <dd>
<p>The record’s attribute dictionary is used as the operand to a string formatting operation. Returns the resulting string. Before formatting the dictionary, a couple of preparatory steps are carried out. The <em>message</em> attribute of the record is computed using <em>msg</em> % <em>args</em>. If the formatting string contains <code>'(asctime)'</code>, <a class="reference internal" href="#logging.Formatter.formatTime" title="logging.Formatter.formatTime"><code>formatTime()</code></a> is called to format the event time. If there is exception information, it is formatted using <a class="reference internal" href="#logging.Formatter.formatException" title="logging.Formatter.formatException"><code>formatException()</code></a> and appended to the message. Note that the formatted exception information is cached in attribute <em>exc_text</em>. This is useful because the exception information can be pickled and sent across the wire, but you should be careful if you have more than one <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> subclass which customizes the formatting of exception information. In this case, you will have to clear the cached value after a formatter has done its formatting, so that the next formatter to handle the event doesn’t use the cached value but recalculates it afresh.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Formatter.formatTime">
<code>formatTime(record, datefmt=None)</code> </dt> <dd>
<p>This method should be called from <a class="reference internal" href="functions#format" title="format"><code>format()</code></a> by a formatter which wants to make use of a formatted time. This method can be overridden in formatters to provide for any specific requirement, but the basic behavior is as follows: if <em>datefmt</em> (a string) is specified, it is used with <a class="reference internal" href="time#time.strftime" title="time.strftime"><code>time.strftime()</code></a> to format the creation time of the record. Otherwise, the ISO8601 format is used. The resulting string is returned.</p> <p>This function uses a user-configurable function to convert the creation time to a tuple. By default, <a class="reference internal" href="time#time.localtime" title="time.localtime"><code>time.localtime()</code></a> is used; to change this for a particular formatter instance, set the <code>converter</code> attribute to a function with the same signature as <a class="reference internal" href="time#time.localtime" title="time.localtime"><code>time.localtime()</code></a> or <a class="reference internal" href="time#time.gmtime" title="time.gmtime"><code>time.gmtime()</code></a>. To change it for all formatters, for example if you want all logging times to be shown in GMT, set the <code>converter</code> attribute in the <code>Formatter</code> class.</p> </dd>
</dl> <dl class="method"> <dt id="logging.Formatter.formatException">
<code>formatException(exc_info)</code> </dt> <dd>
<p>Formats the specified exception information (a standard exception tuple as returned by <a class="reference internal" href="sys#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a>) as a string. This default implementation just uses <a class="reference internal" href="traceback#traceback.print_exception" title="traceback.print_exception"><code>traceback.print_exception()</code></a>. The resulting string is returned.</p> </dd>
</dl> </dd>
</dl>   <h2 id="filter">5. Filter Objects</h2> <p id="filter-objects"><code>Filters</code> can be used by <code>Handlers</code> and <code>Loggers</code> for more sophisticated filtering than is provided by levels. The base filter class only allows events which are below a certain point in the logger hierarchy. For example, a filter initialized with ‘A.B’ will allow events logged by loggers ‘A.B’, ‘A.B.C’, ‘A.B.C.D’, ‘A.B.D’ etc. but not ‘A.BB’, ‘B.A.B’ etc. If initialized with the empty string, all events are passed.</p> <dl class="class"> <dt id="logging.Filter">
<code>class logging.Filter(name='')</code> </dt> <dd>
<p>Returns an instance of the <a class="reference internal" href="#logging.Filter" title="logging.Filter"><code>Filter</code></a> class. If <em>name</em> is specified, it names a logger which, together with its children, will have its events allowed through the filter. If <em>name</em> is the empty string, allows every event.</p> <dl class="method"> <dt id="logging.Filter.filter">
<code>filter(record)</code> </dt> <dd>
<p>Is the specified record to be logged? Returns zero for no, nonzero for yes. If deemed appropriate, the record may be modified in-place by this method.</p> </dd>
</dl> </dd>
</dl> <p>Note that filters attached to handlers are consulted before an event is emitted by the handler, whereas filters attached to loggers are consulted whenever an event is logged (using <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>, <a class="reference internal" href="#logging.info" title="logging.info"><code>info()</code></a>, etc.), before sending an event to handlers. This means that events which have been generated by descendant loggers will not be filtered by a logger’s filter setting, unless the filter has also been applied to those descendant loggers.</p> <p>You don’t actually need to subclass <code>Filter</code>: you can pass any instance which has a <code>filter</code> method with the same semantics.</p> <p>Although filters are used primarily to filter records based on more sophisticated criteria than levels, they get to see every record which is processed by the handler or logger they’re attached to: this can be useful if you want to do things like counting how many records were processed by a particular logger or handler, or adding, changing or removing attributes in the LogRecord being processed. Obviously changing the LogRecord needs to be done with some care, but it does allow the injection of contextual information into logs (see <a class="reference internal" href="https://docs.python.org/2.7/howto/logging-cookbook.html#filters-contextual"><span class="std std-ref">Using Filters to impart contextual information</span></a>).</p>   <h2 id="log-record">6. LogRecord Objects</h2> <p id="logrecord-objects"><a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> instances are created automatically by the <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code>Logger</code></a> every time something is logged, and can be created manually via <a class="reference internal" href="#logging.makeLogRecord" title="logging.makeLogRecord"><code>makeLogRecord()</code></a> (for example, from a pickled event received over the wire).</p> <dl class="class"> <dt id="logging.LogRecord">
<code>class logging.LogRecord(name, level, pathname, lineno, msg, args, exc_info, func=None)</code> </dt> <dd>
<p>Contains all the information pertinent to the event being logged.</p> <p>The primary information is passed in <code>msg</code> and <code>args</code>, which are combined using <code>msg % args</code> to create the <code>message</code> field of the record.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>name</strong> – The name of the logger used to log the event represented by this LogRecord. Note that this name will always have this value, even though it may be emitted by a handler attached to a different (ancestor) logger.</li> <li>
<strong>level</strong> – The numeric level of the logging event (one of DEBUG, INFO etc.) Note that this is converted to <em>two</em> attributes of the LogRecord: <code>levelno</code> for the numeric value and <code>levelname</code> for the corresponding level name.</li> <li>
<strong>pathname</strong> – The full pathname of the source file where the logging call was made.</li> <li>
<strong>lineno</strong> – The line number in the source file where the logging call was made.</li> <li>
<strong>msg</strong> – The event description message, possibly a format string with placeholders for variable data.</li> <li>
<strong>args</strong> – Variable data to merge into the <em>msg</em> argument to obtain the event description.</li> <li>
<strong>exc_info</strong> – An exception tuple with the current exception information, or <code>None</code> if no exception information is available.</li> <li>
<strong>func</strong> – The name of the function or method from which the logging call was invoked.</li> </ul> </dd> </dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.5: </span><em>func</em> was added.</p> </div> <dl class="method"> <dt id="logging.LogRecord.getMessage">
<code>getMessage()</code> </dt> <dd>
<p>Returns the message for this <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> instance after merging any user-supplied arguments with the message. If the user-supplied message argument to the logging call is not a string, <a class="reference internal" href="functions#str" title="str"><code>str()</code></a> is called on it to convert it to a string. This allows use of user-defined classes as messages, whose <code>__str__</code> method can return the actual format string to be used.</p> </dd>
</dl> </dd>
</dl>   <h2 id="id2">7. LogRecord attributes</h2> <p id="logrecord-attributes">The LogRecord has a number of attributes, most of which are derived from the parameters to the constructor. (Note that the names do not always correspond exactly between the LogRecord constructor parameters and the LogRecord attributes.) These attributes can be used to merge data from the record into the format string. The following table lists (in alphabetical order) the attribute names, their meanings and the corresponding placeholder in a %-style format string.</p> <table class="docutils align-center">  <thead> <tr>
<th class="head"><p>Attribute name</p></th> <th class="head"><p>Format</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p>args</p></td> <td><p>You shouldn’t need to format this yourself.</p></td> <td><p>The tuple of arguments merged into <code>msg</code> to produce <code>message</code>, or a dict whose values are used for the merge (when there is only one argument, and it is a dictionary).</p></td> </tr> <tr>
<td><p>asctime</p></td> <td><p><code>%(asctime)s</code></p></td> <td><p>Human-readable time when the <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> was created. By default this is of the form ‘2003-07-08 16:49:45,896’ (the numbers after the comma are millisecond portion of the time).</p></td> </tr> <tr>
<td><p>created</p></td> <td><p><code>%(created)f</code></p></td> <td><p>Time when the <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> was created (as returned by <a class="reference internal" href="time#time.time" title="time.time"><code>time.time()</code></a>).</p></td> </tr> <tr>
<td><p>exc_info</p></td> <td><p>You shouldn’t need to format this yourself.</p></td> <td><p>Exception tuple (à la <code>sys.exc_info</code>) or, if no exception has occurred, <code>None</code>.</p></td> </tr> <tr>
<td><p>filename</p></td> <td><p><code>%(filename)s</code></p></td> <td><p>Filename portion of <code>pathname</code>.</p></td> </tr> <tr>
<td><p>funcName</p></td> <td><p><code>%(funcName)s</code></p></td> <td><p>Name of function containing the logging call.</p></td> </tr> <tr>
<td><p>levelname</p></td> <td><p><code>%(levelname)s</code></p></td> <td><p>Text logging level for the message (<code>'DEBUG'</code>, <code>'INFO'</code>, <code>'WARNING'</code>, <code>'ERROR'</code>, <code>'CRITICAL'</code>).</p></td> </tr> <tr>
<td><p>levelno</p></td> <td><p><code>%(levelno)s</code></p></td> <td><p>Numeric logging level for the message (<code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code>).</p></td> </tr> <tr>
<td><p>lineno</p></td> <td><p><code>%(lineno)d</code></p></td> <td><p>Source line number where the logging call was issued (if available).</p></td> </tr> <tr>
<td><p>module</p></td> <td><p><code>%(module)s</code></p></td> <td><p>Module (name portion of <code>filename</code>).</p></td> </tr> <tr>
<td><p>msecs</p></td> <td><p><code>%(msecs)d</code></p></td> <td><p>Millisecond portion of the time when the <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> was created.</p></td> </tr> <tr>
<td><p>message</p></td> <td><p><code>%(message)s</code></p></td> <td><p>The logged message, computed as <code>msg %
args</code>. This is set when <a class="reference internal" href="#logging.Formatter.format" title="logging.Formatter.format"><code>Formatter.format()</code></a> is invoked.</p></td> </tr> <tr>
<td><p>msg</p></td> <td><p>You shouldn’t need to format this yourself.</p></td> <td><p>The format string passed in the original logging call. Merged with <code>args</code> to produce <code>message</code>, or an arbitrary object (see <a class="reference internal" href="https://docs.python.org/2.7/howto/logging.html#arbitrary-object-messages"><span class="std std-ref">Using arbitrary objects as messages</span></a>).</p></td> </tr> <tr>
<td><p>name</p></td> <td><p><code>%(name)s</code></p></td> <td><p>Name of the logger used to log the call.</p></td> </tr> <tr>
<td><p>pathname</p></td> <td><p><code>%(pathname)s</code></p></td> <td><p>Full pathname of the source file where the logging call was issued (if available).</p></td> </tr> <tr>
<td><p>process</p></td> <td><p><code>%(process)d</code></p></td> <td><p>Process ID (if available).</p></td> </tr> <tr>
<td><p>processName</p></td> <td><p><code>%(processName)s</code></p></td> <td><p>Process name (if available).</p></td> </tr> <tr>
<td><p>relativeCreated</p></td> <td><p><code>%(relativeCreated)d</code></p></td> <td><p>Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.</p></td> </tr> <tr>
<td><p>thread</p></td> <td><p><code>%(thread)d</code></p></td> <td><p>Thread ID (if available).</p></td> </tr> <tr>
<td><p>threadName</p></td> <td><p><code>%(threadName)s</code></p></td> <td><p>Thread name (if available).</p></td> </tr>  </table> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.5: </span><em>funcName</em> was added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span><em>processName</em> was added.</p> </div>   <h2 id="logger-adapter">8. LoggerAdapter Objects</h2> <p id="loggeradapter-objects"><a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code>LoggerAdapter</code></a> instances are used to conveniently pass contextual information into logging calls. For a usage example, see the section on <a class="reference internal" href="https://docs.python.org/2.7/howto/logging-cookbook.html#context-info"><span class="std std-ref">adding contextual information to your logging output</span></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> <dl class="class"> <dt id="logging.LoggerAdapter">
<code>class logging.LoggerAdapter(logger, extra)</code> </dt> <dd>
<p>Returns an instance of <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code>LoggerAdapter</code></a> initialized with an underlying <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code>Logger</code></a> instance and a dict-like object.</p> <dl class="method"> <dt id="logging.LoggerAdapter.process">
<code>process(msg, kwargs)</code> </dt> <dd>
<p>Modifies the message and/or keyword arguments passed to a logging call in order to insert contextual information. This implementation takes the object passed as <em>extra</em> to the constructor and adds it to <em>kwargs</em> using key ‘extra’. The return value is a (<em>msg</em>, <em>kwargs</em>) tuple which has the (possibly modified) versions of the arguments passed in.</p> </dd>
</dl> </dd>
</dl> <p>In addition to the above, <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code>LoggerAdapter</code></a> supports the following methods of <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code>Logger</code></a>: <a class="reference internal" href="#logging.Logger.debug" title="logging.Logger.debug"><code>debug()</code></a>, <a class="reference internal" href="#logging.Logger.info" title="logging.Logger.info"><code>info()</code></a>, <a class="reference internal" href="#logging.Logger.warning" title="logging.Logger.warning"><code>warning()</code></a>, <a class="reference internal" href="#logging.Logger.error" title="logging.Logger.error"><code>error()</code></a>, <a class="reference internal" href="#logging.Logger.exception" title="logging.Logger.exception"><code>exception()</code></a>, <a class="reference internal" href="#logging.Logger.critical" title="logging.Logger.critical"><code>critical()</code></a>, <a class="reference internal" href="#logging.Logger.log" title="logging.Logger.log"><code>log()</code></a> and <a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code>isEnabledFor()</code></a>. These methods have the same signatures as their counterparts in <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code>Logger</code></a>, so you can use the two types of instances interchangeably for these calls.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.7: </span>The <a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code>isEnabledFor()</code></a> method was added to <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code>LoggerAdapter</code></a>. This method delegates to the underlying logger.</p> </div>   <h2 id="thread-safety">9. Thread Safety</h2> <p>The logging module is intended to be thread-safe without any special work needing to be done by its clients. It achieves this though using threading locks; there is one lock to serialize access to the module’s shared data, and each handler also creates a lock to serialize access to its underlying I/O.</p> <p>If you are implementing asynchronous signal handlers using the <a class="reference internal" href="signal#module-signal" title="signal: Set handlers for asynchronous events."><code>signal</code></a> module, you may not be able to use logging from within such handlers. This is because lock implementations in the <a class="reference internal" href="threading#module-threading" title="threading: Higher-level threading interface."><code>threading</code></a> module are not always re-entrant, and so cannot be invoked from such signal handlers.</p>   <h2 id="module-level-functions">10. Module-Level Functions</h2> <p>In addition to the classes described above, there are a number of module- level functions.</p> <dl class="function"> <dt id="logging.getLogger">
<code>logging.getLogger([name])</code> </dt> <dd>
<p>Return a logger with the specified name or, if no name is specified, return a logger which is the root logger of the hierarchy. If specified, the name is typically a dot-separated hierarchical name like <em>“a”</em>, <em>“a.b”</em> or <em>“a.b.c.d”</em>. Choice of these names is entirely up to the developer who is using logging.</p> <p>All calls to this function with a given name return the same logger instance. This means that logger instances never need to be passed between different parts of an application.</p> </dd>
</dl> <dl class="function"> <dt id="logging.getLoggerClass">
<code>logging.getLoggerClass()</code> </dt> <dd>
<p>Return either the standard <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code>Logger</code></a> class, or the last class passed to <a class="reference internal" href="#logging.setLoggerClass" title="logging.setLoggerClass"><code>setLoggerClass()</code></a>. This function may be called from within a new class definition, to ensure that installing a customized <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code>Logger</code></a> class will not undo customizations already applied by other code. For example:</p> <pre data-language="python">class MyLogger(logging.getLoggerClass()):
    # ... override behaviour here
</pre> </dd>
</dl> <dl class="function"> <dt id="logging.debug">
<code>logging.debug(msg[, *args[, **kwargs]])</code> </dt> <dd>
<p>Logs a message with level <code>DEBUG</code> on the root logger. The <em>msg</em> is the message format string, and the <em>args</em> are the arguments which are merged into <em>msg</em> using the string formatting operator. (Note that this means that you can use keywords in the format string, together with a single dictionary argument.)</p> <p>There are two keyword arguments in <em>kwargs</em> which are inspected: <em>exc_info</em> which, if it does not evaluate as false, causes exception information to be added to the logging message. If an exception tuple (in the format returned by <a class="reference internal" href="sys#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a>) is provided, it is used; otherwise, <a class="reference internal" href="sys#sys.exc_info" title="sys.exc_info"><code>sys.exc_info()</code></a> is called to get the exception information.</p> <p>The other optional keyword argument is <em>extra</em> which can be used to pass a dictionary which is used to populate the __dict__ of the LogRecord created for the logging event with user-defined attributes. These custom attributes can then be used as you like. For example, they could be incorporated into logged messages. For example:</p> <pre data-language="python">FORMAT = "%(asctime)-15s %(clientip)s %(user)-8s %(message)s"
logging.basicConfig(format=FORMAT)
d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}
logging.warning("Protocol problem: %s", "connection reset", extra=d)
</pre> <p>would print something like:</p> <pre data-language="python">2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
</pre> <p>The keys in the dictionary passed in <em>extra</em> should not clash with the keys used by the logging system. (See the <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> documentation for more information on which keys are used by the logging system.)</p> <p>If you choose to use these attributes in logged messages, you need to exercise some care. In the above example, for instance, the <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> has been set up with a format string which expects ‘clientip’ and ‘user’ in the attribute dictionary of the LogRecord. If these are missing, the message will not be logged because a string formatting exception will occur. So in this case, you always need to pass the <em>extra</em> dictionary with these keys.</p> <p>While this might be annoying, this feature is intended for use in specialized circumstances, such as multi-threaded servers where the same code executes in many contexts, and interesting conditions which arise are dependent on this context (such as remote client IP address and authenticated user name, in the above example). In such circumstances, it is likely that specialized <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a>s would be used with particular <code>Handler</code>s.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.5: </span><em>extra</em> was added.</p> </div> </dd>
</dl> <dl class="function"> <dt id="logging.info">
<code>logging.info(msg[, *args[, **kwargs]])</code> </dt> <dd>
<p>Logs a message with level <code>INFO</code> on the root logger. The arguments are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="logging.warning">
<code>logging.warning(msg[, *args[, **kwargs]])</code> </dt> <dd>
<p>Logs a message with level <code>WARNING</code> on the root logger. The arguments are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="logging.error">
<code>logging.error(msg[, *args[, **kwargs]])</code> </dt> <dd>
<p>Logs a message with level <code>ERROR</code> on the root logger. The arguments are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="logging.critical">
<code>logging.critical(msg[, *args[, **kwargs]])</code> </dt> <dd>
<p>Logs a message with level <code>CRITICAL</code> on the root logger. The arguments are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="logging.exception">
<code>logging.exception(msg[, *args[, **kwargs]])</code> </dt> <dd>
<p>Logs a message with level <code>ERROR</code> on the root logger. The arguments are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>, except that any passed <em>exc_info</em> is not inspected. Exception info is always added to the logging message. This function should only be called from an exception handler.</p> </dd>
</dl> <dl class="function"> <dt id="logging.log">
<code>logging.log(level, msg[, *args[, **kwargs]])</code> </dt> <dd>
<p>Logs a message with level <em>level</em> on the root logger. The other arguments are interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The above module-level convenience functions, which delegate to the root logger, call <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code>basicConfig()</code></a> to ensure that at least one handler is available. Because of this, they should <em>not</em> be used in threads, in versions of Python earlier than 2.7.1 and 3.2, unless at least one handler has been added to the root logger <em>before</em> the threads are started. In earlier versions of Python, due to a thread safety shortcoming in <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code>basicConfig()</code></a>, this can (under rare circumstances) lead to handlers being added multiple times to the root logger, which can in turn lead to multiple messages for the same event.</p> </div> </dd>
</dl> <dl class="function"> <dt id="logging.disable">
<code>logging.disable(lvl)</code> </dt> <dd>
<p>Provides an overriding level <em>lvl</em> for all loggers which takes precedence over the logger’s own level. When the need arises to temporarily throttle logging output down across the whole application, this function can be useful. Its effect is to disable all logging calls of severity <em>lvl</em> and below, so that if you call it with a value of INFO, then all INFO and DEBUG events would be discarded, whereas those of severity WARNING and above would be processed according to the logger’s effective level. If <code>logging.disable(logging.NOTSET)</code> is called, it effectively removes this overriding level, so that logging output again depends on the effective levels of individual loggers.</p> </dd>
</dl> <dl class="function"> <dt id="logging.addLevelName">
<code>logging.addLevelName(lvl, levelName)</code> </dt> <dd>
<p>Associates level <em>lvl</em> with text <em>levelName</em> in an internal dictionary, which is used to map numeric levels to a textual representation, for example when a <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> formats a message. This function can also be used to define your own levels. The only constraints are that all levels used must be registered using this function, levels should be positive integers and they should increase in increasing order of severity.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you are thinking of defining your own levels, please see the section on <a class="reference internal" href="https://docs.python.org/2.7/howto/logging.html#custom-levels"><span class="std std-ref">Custom Levels</span></a>.</p> </div> </dd>
</dl> <dl class="function"> <dt id="logging.getLevelName">
<code>logging.getLevelName(lvl)</code> </dt> <dd>
<p>Returns the textual representation of logging level <em>lvl</em>. If the level is one of the predefined levels <code>CRITICAL</code>, <code>ERROR</code>, <code>WARNING</code>, <code>INFO</code> or <code>DEBUG</code> then you get the corresponding string. If you have associated levels with names using <a class="reference internal" href="#logging.addLevelName" title="logging.addLevelName"><code>addLevelName()</code></a> then the name you have associated with <em>lvl</em> is returned. If a numeric value corresponding to one of the defined levels is passed in, the corresponding string representation is returned. Otherwise, the string “Level %s” % lvl is returned.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Integer levels should be used when e.g. setting levels on instances of <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code>Logger</code></a> and handlers. This function is used to convert between an integer level and the level name displayed in the formatted log output by means of the <code>%(levelname)s</code> format specifier (see <a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">LogRecord attributes</span></a>).</p> </div> </dd>
</dl> <dl class="function"> <dt id="logging.makeLogRecord">
<code>logging.makeLogRecord(attrdict)</code> </dt> <dd>
<p>Creates and returns a new <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> instance whose attributes are defined by <em>attrdict</em>. This function is useful for taking a pickled <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> attribute dictionary, sent over a socket, and reconstituting it as a <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code>LogRecord</code></a> instance at the receiving end.</p> </dd>
</dl> <dl class="function"> <dt id="logging.basicConfig">
<code>logging.basicConfig([**kwargs])</code> </dt> <dd>
<p>Does basic configuration for the logging system by creating a <a class="reference internal" href="logging.handlers#logging.StreamHandler" title="logging.StreamHandler"><code>StreamHandler</code></a> with a default <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code>Formatter</code></a> and adding it to the root logger. The functions <a class="reference internal" href="#logging.debug" title="logging.debug"><code>debug()</code></a>, <a class="reference internal" href="#logging.info" title="logging.info"><code>info()</code></a>, <a class="reference internal" href="#logging.warning" title="logging.warning"><code>warning()</code></a>, <a class="reference internal" href="#logging.error" title="logging.error"><code>error()</code></a> and <a class="reference internal" href="#logging.critical" title="logging.critical"><code>critical()</code></a> will call <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code>basicConfig()</code></a> automatically if no handlers are defined for the root logger.</p> <p>This function does nothing if the root logger already has handlers configured for it.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.4: </span>Formerly, <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code>basicConfig()</code></a> did not take any keyword arguments.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This function should be called from the main thread before other threads are started. In versions of Python prior to 2.7.1 and 3.2, if this function is called from multiple threads, it is possible (in rare circumstances) that a handler will be added to the root logger more than once, leading to unexpected results such as messages being duplicated in the log.</p> </div> <p>The following keyword arguments are supported.</p> <table class="docutils align-center">  <thead> <tr>
<th class="head"><p>Format</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p><em>filename</em></p></td> <td><p>Specifies that a FileHandler be created, using the specified filename, rather than a StreamHandler.</p></td> </tr> <tr>
<td><p><em>filemode</em></p></td> <td><p>If <em>filename</em> is specified, open the file in this mode. Defaults to <code>'a'</code>.</p></td> </tr> <tr>
<td><p><em>format</em></p></td> <td><p>Use the specified format string for the handler.</p></td> </tr> <tr>
<td><p><em>datefmt</em></p></td> <td><p>Use the specified date/time format, as accepted by <a class="reference internal" href="time#time.strftime" title="time.strftime"><code>time.strftime()</code></a>.</p></td> </tr> <tr>
<td><p><em>level</em></p></td> <td><p>Set the root logger level to the specified <a class="reference internal" href="#levels"><span class="std std-ref">level</span></a>.</p></td> </tr> <tr>
<td><p><em>stream</em></p></td> <td><p>Use the specified stream to initialize the StreamHandler. Note that this argument is incompatible with <em>filename</em> - if both are present, <em>stream</em> is ignored.</p></td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="logging.shutdown">
<code>logging.shutdown()</code> </dt> <dd>
<p>Informs the logging system to perform an orderly shutdown by flushing and closing all handlers. This should be called at application exit and no further use of the logging system should be made after this call.</p> </dd>
</dl> <dl class="function"> <dt id="logging.setLoggerClass">
<code>logging.setLoggerClass(klass)</code> </dt> <dd>
<p>Tells the logging system to use the class <em>klass</em> when instantiating a logger. The class should define <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> such that only a name argument is required, and the <a class="reference internal" href="https://docs.python.org/2.7/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> should call <code>Logger.__init__()</code>. This function is typically called before any loggers are instantiated by applications which need to use custom logger behavior.</p> </dd>
</dl>   <h2 id="integration-with-the-warnings-module">11. Integration with the warnings module</h2> <p>The <a class="reference internal" href="#logging.captureWarnings" title="logging.captureWarnings"><code>captureWarnings()</code></a> function can be used to integrate <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code>logging</code></a> with the <a class="reference internal" href="warnings#module-warnings" title="warnings: Issue warning messages and control their disposition."><code>warnings</code></a> module.</p> <dl class="function"> <dt id="logging.captureWarnings">
<code>logging.captureWarnings(capture)</code> </dt> <dd>
<p>This function is used to turn the capture of warnings by logging on and off.</p> <p>If <em>capture</em> is <code>True</code>, warnings issued by the <a class="reference internal" href="warnings#module-warnings" title="warnings: Issue warning messages and control their disposition."><code>warnings</code></a> module will be redirected to the logging system. Specifically, a warning will be formatted using <a class="reference internal" href="warnings#warnings.formatwarning" title="warnings.formatwarning"><code>warnings.formatwarning()</code></a> and the resulting string logged to a logger named <code>'py.warnings'</code> with a severity of <code>WARNING</code>.</p> <p>If <em>capture</em> is <code>False</code>, the redirection of warnings to the logging system will stop, and warnings will be redirected to their original destinations (i.e. those in effect before <code>captureWarnings(True)</code> was called).</p> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="logging.config#module-logging.config" title="logging.config: Configuration of the logging module."><code>logging.config</code></a>
</dt>
<dd>
<p>Configuration API for the logging module.</p> </dd> <dt>
<code>Module</code> <a class="reference internal" href="logging.handlers#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code>logging.handlers</code></a>
</dt>
<dd>
<p>Useful handlers included with the logging module.</p> </dd> <dt>
<a class="pep reference external" href="https://www.python.org/dev/peps/pep-0282" id="index-1"><strong>PEP 282</strong></a> - A Logging System</dt>
<dd>
<p>The proposal which described this feature for inclusion in the Python standard library.</p> </dd> <dt><a class="reference external" href="https://www.red-dove.com/python_logging.html">Original Python logging package</a></dt>
<dd>
<p>This is the original source for the <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code>logging</code></a> package. The version of the package available from this site is suitable for use with Python 1.5.2, 2.1.x and 2.2.x, which do not include the <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code>logging</code></a> package in the standard library.</p> </dd> </dl> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/logging.html" class="_attribution-link">https://docs.python.org/2.7/library/logging.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
