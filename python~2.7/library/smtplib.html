
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Smtplib - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" Source code&#58; Lib&#47;smtplib.py ">
  <meta name="keywords" content="smtplib, —, smtp, protocol, client, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/smtplib.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/python~2.7.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="smtplib-smtp-protocol-client"> smtplib — SMTP protocol client</h1> <p id="module-smtplib"><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/2.7/Lib/smtplib.py">Lib/smtplib.py</a></p>  <p>The <a class="reference internal" href="#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code>smtplib</code></a> module defines an SMTP client session object that can be used to send mail to any Internet machine with an SMTP or ESMTP listener daemon. For details of SMTP and ESMTP operation, consult <a class="rfc reference external" href="https://tools.ietf.org/html/rfc821.html" id="index-1"><strong>RFC 821</strong></a> (Simple Mail Transfer Protocol) and <a class="rfc reference external" href="https://tools.ietf.org/html/rfc1869.html" id="index-2"><strong>RFC 1869</strong></a> (SMTP Service Extensions).</p> <dl class="class"> <dt id="smtplib.SMTP">
<code>class smtplib.SMTP([host[, port[, local_hostname[, timeout]]]])</code> </dt> <dd>
<p>An <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code>SMTP</code></a> instance encapsulates an SMTP connection. It has methods that support a full repertoire of SMTP and ESMTP operations. If the optional host and port parameters are given, the SMTP <a class="reference internal" href="#smtplib.SMTP.connect" title="smtplib.SMTP.connect"><code>connect()</code></a> method is called with those parameters during initialization. If specified, <em>local_hostname</em> is used as the FQDN of the local host in the HELO/EHLO command. Otherwise, the local hostname is found using <a class="reference internal" href="socket#socket.getfqdn" title="socket.getfqdn"><code>socket.getfqdn()</code></a>. If the <a class="reference internal" href="#smtplib.SMTP.connect" title="smtplib.SMTP.connect"><code>connect()</code></a> call returns anything other than a success code, an <a class="reference internal" href="#smtplib.SMTPConnectError" title="smtplib.SMTPConnectError"><code>SMTPConnectError</code></a> is raised. The optional <em>timeout</em> parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). If the timeout expires, <a class="reference internal" href="socket#socket.timeout" title="socket.timeout"><code>socket.timeout</code></a> is raised.</p> <p>For normal use, you should only require the initialization/connect, <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code>sendmail()</code></a>, and <a class="reference internal" href="#smtplib.SMTP.quit" title="smtplib.SMTP.quit"><code>SMTP.quit()</code></a> methods. An example is included below.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span><em>timeout</em> was added.</p> </div> </dd>
</dl> <dl class="class"> <dt id="smtplib.SMTP_SSL">
<code>class smtplib.SMTP_SSL([host[, port[, local_hostname[, keyfile[, certfile[, timeout]]]]]])</code> </dt> <dd>
<p>An <a class="reference internal" href="#smtplib.SMTP_SSL" title="smtplib.SMTP_SSL"><code>SMTP_SSL</code></a> instance behaves exactly the same as instances of <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code>SMTP</code></a>. <a class="reference internal" href="#smtplib.SMTP_SSL" title="smtplib.SMTP_SSL"><code>SMTP_SSL</code></a> should be used for situations where SSL is required from the beginning of the connection and using <code>starttls()</code> is not appropriate. If <em>host</em> is not specified, the local host is used. If <em>port</em> is omitted, the standard SMTP-over-SSL port (465) is used. <em>local_hostname</em> has the same meaning as it does for the <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code>SMTP</code></a> class. <em>keyfile</em> and <em>certfile</em> are also optional, and can contain a PEM formatted private key and certificate chain file for the SSL connection. The optional <em>timeout</em> parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). If the timeout expires, <a class="reference internal" href="socket#socket.timeout" title="socket.timeout"><code>socket.timeout</code></a> is raised.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="smtplib.LMTP">
<code>class smtplib.LMTP([host[, port[, local_hostname]]])</code> </dt> <dd>
<p>The LMTP protocol, which is very similar to ESMTP, is heavily based on the standard SMTP client. It’s common to use Unix sockets for LMTP, so our <code>connect()</code> method must support that as well as a regular host:port server. <em>local_hostname</em> has the same meaning as it does for the <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code>SMTP</code></a> class. To specify a Unix socket, you must use an absolute path for <em>host</em>, starting with a ‘/’.</p> <p>Authentication is supported, using the regular SMTP mechanism. When using a Unix socket, LMTP generally don’t support or require any authentication, but your mileage might vary.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </dd>
</dl> <p>A nice selection of exceptions is defined as well:</p> <dl class="exception"> <dt id="smtplib.SMTPException">
<code>exception smtplib.SMTPException</code> </dt> <dd>
<p>The base exception class for all the other exceptions provided by this module.</p> </dd>
</dl> <dl class="exception"> <dt id="smtplib.SMTPServerDisconnected">
<code>exception smtplib.SMTPServerDisconnected</code> </dt> <dd>
<p>This exception is raised when the server unexpectedly disconnects, or when an attempt is made to use the <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code>SMTP</code></a> instance before connecting it to a server.</p> </dd>
</dl> <dl class="exception"> <dt id="smtplib.SMTPResponseException">
<code>exception smtplib.SMTPResponseException</code> </dt> <dd>
<p>Base class for all exceptions that include an SMTP error code. These exceptions are generated in some instances when the SMTP server returns an error code. The error code is stored in the <code>smtp_code</code> attribute of the error, and the <code>smtp_error</code> attribute is set to the error message.</p> </dd>
</dl> <dl class="exception"> <dt id="smtplib.SMTPSenderRefused">
<code>exception smtplib.SMTPSenderRefused</code> </dt> <dd>
<p>Sender address refused. In addition to the attributes set by on all <a class="reference internal" href="#smtplib.SMTPResponseException" title="smtplib.SMTPResponseException"><code>SMTPResponseException</code></a> exceptions, this sets ‘sender’ to the string that the SMTP server refused.</p> </dd>
</dl> <dl class="exception"> <dt id="smtplib.SMTPRecipientsRefused">
<code>exception smtplib.SMTPRecipientsRefused</code> </dt> <dd>
<p>All recipient addresses refused. The errors for each recipient are accessible through the attribute <code>recipients</code>, which is a dictionary of exactly the same sort as <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code>SMTP.sendmail()</code></a> returns.</p> </dd>
</dl> <dl class="exception"> <dt id="smtplib.SMTPDataError">
<code>exception smtplib.SMTPDataError</code> </dt> <dd>
<p>The SMTP server refused to accept the message data.</p> </dd>
</dl> <dl class="exception"> <dt id="smtplib.SMTPConnectError">
<code>exception smtplib.SMTPConnectError</code> </dt> <dd>
<p>Error occurred during establishment of a connection with the server.</p> </dd>
</dl> <dl class="exception"> <dt id="smtplib.SMTPHeloError">
<code>exception smtplib.SMTPHeloError</code> </dt> <dd>
<p>The server refused our <code>HELO</code> message.</p> </dd>
</dl> <dl class="exception"> <dt id="smtplib.SMTPAuthenticationError">
<code>exception smtplib.SMTPAuthenticationError</code> </dt> <dd>
<p>SMTP authentication went wrong. Most probably the server didn’t accept the username/password combination provided.</p> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<a class="rfc reference external" href="https://tools.ietf.org/html/rfc821.html" id="index-3"><strong>RFC 821</strong></a> - Simple Mail Transfer Protocol</dt>
<dd>
<p>Protocol definition for SMTP. This document covers the model, operating procedure, and protocol details for SMTP.</p> </dd> <dt>
<a class="rfc reference external" href="https://tools.ietf.org/html/rfc1869.html" id="index-4"><strong>RFC 1869</strong></a> - SMTP Service Extensions</dt>
<dd>
<p>Definition of the ESMTP extensions for SMTP. This describes a framework for extending SMTP with new commands, supporting dynamic discovery of the commands provided by the server, and defines a few additional commands.</p> </dd> </dl> </div>  <h2 id="id1">1. SMTP Objects</h2> <p id="smtp-objects">An <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code>SMTP</code></a> instance has the following methods:</p> <dl class="method"> <dt id="smtplib.SMTP.set_debuglevel">
<code>SMTP.set_debuglevel(level)</code> </dt> <dd>
<p>Set the debug output level. A true value for <em>level</em> results in debug messages for connection and for all messages sent to and received from the server.</p> </dd>
</dl> <dl class="method"> <dt id="smtplib.SMTP.docmd">
<code>SMTP.docmd(cmd[, argstring])</code> </dt> <dd>
<p>Send a command <em>cmd</em> to the server. The optional argument <em>argstring</em> is simply concatenated to the command, separated by a space.</p> <p>This returns a 2-tuple composed of a numeric response code and the actual response line (multiline responses are joined into one long line.)</p> <p>In normal operation it should not be necessary to call this method explicitly. It is used to implement other methods and may be useful for testing private extensions.</p> <p>If the connection to the server is lost while waiting for the reply, <a class="reference internal" href="#smtplib.SMTPServerDisconnected" title="smtplib.SMTPServerDisconnected"><code>SMTPServerDisconnected</code></a> will be raised.</p> </dd>
</dl> <dl class="method"> <dt id="smtplib.SMTP.connect">
<code>SMTP.connect([host[, port]])</code> </dt> <dd>
<p>Connect to a host on a given port. The defaults are to connect to the local host at the standard SMTP port (25). If the hostname ends with a colon (<code>':'</code>) followed by a number, that suffix will be stripped off and the number interpreted as the port number to use. This method is automatically invoked by the constructor if a host is specified during instantiation. Returns a 2-tuple of the response code and message sent by the server in its connection response.</p> </dd>
</dl> <dl class="method"> <dt id="smtplib.SMTP.helo">
<code>SMTP.helo([hostname])</code> </dt> <dd>
<p>Identify yourself to the SMTP server using <code>HELO</code>. The hostname argument defaults to the fully qualified domain name of the local host. The message returned by the server is stored as the <code>helo_resp</code> attribute of the object.</p> <p>In normal operation it should not be necessary to call this method explicitly. It will be implicitly called by the <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code>sendmail()</code></a> when necessary.</p> </dd>
</dl> <dl class="method"> <dt id="smtplib.SMTP.ehlo">
<code>SMTP.ehlo([hostname])</code> </dt> <dd>
<p>Identify yourself to an ESMTP server using <code>EHLO</code>. The hostname argument defaults to the fully qualified domain name of the local host. Examine the response for ESMTP option and store them for use by <a class="reference internal" href="#smtplib.SMTP.has_extn" title="smtplib.SMTP.has_extn"><code>has_extn()</code></a>. Also sets several informational attributes: the message returned by the server is stored as the <code>ehlo_resp</code> attribute, <code>does_esmtp</code> is set to true or false depending on whether the server supports ESMTP, and <code>esmtp_features</code> will be a dictionary containing the names of the SMTP service extensions this server supports, and their parameters (if any).</p> <p>Unless you wish to use <a class="reference internal" href="#smtplib.SMTP.has_extn" title="smtplib.SMTP.has_extn"><code>has_extn()</code></a> before sending mail, it should not be necessary to call this method explicitly. It will be implicitly called by <a class="reference internal" href="#smtplib.SMTP.sendmail" title="smtplib.SMTP.sendmail"><code>sendmail()</code></a> when necessary.</p> </dd>
</dl> <dl class="method"> <dt id="smtplib.SMTP.ehlo_or_helo_if_needed">
<code>SMTP.ehlo_or_helo_if_needed()</code> </dt> <dd>
<p>This method call <a class="reference internal" href="#smtplib.SMTP.ehlo" title="smtplib.SMTP.ehlo"><code>ehlo()</code></a> and or <a class="reference internal" href="#smtplib.SMTP.helo" title="smtplib.SMTP.helo"><code>helo()</code></a> if there has been no previous <code>EHLO</code> or <code>HELO</code> command this session. It tries ESMTP <code>EHLO</code> first.</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code>SMTPHeloError</code></a>
</dt>
<dd>
<p>The server didn’t reply properly to the <code>HELO</code> greeting.</p> </dd> </dl> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="smtplib.SMTP.has_extn">
<code>SMTP.has_extn(name)</code> </dt> <dd>
<p>Return <a class="reference internal" href="constants#True" title="True"><code>True</code></a> if <em>name</em> is in the set of SMTP service extensions returned by the server, <a class="reference internal" href="constants#False" title="False"><code>False</code></a> otherwise. Case is ignored.</p> </dd>
</dl> <dl class="method"> <dt id="smtplib.SMTP.verify">
<code>SMTP.verify(address)</code> </dt> <dd>
<p>Check the validity of an address on this server using SMTP <code>VRFY</code>. Returns a tuple consisting of code 250 and a full <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html" id="index-5"><strong>RFC 822</strong></a> address (including human name) if the user address is valid. Otherwise returns an SMTP error code of 400 or greater and an error string.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Many sites disable SMTP <code>VRFY</code> in order to foil spammers.</p> </div> </dd>
</dl> <dl class="method"> <dt id="smtplib.SMTP.login">
<code>SMTP.login(user, password)</code> </dt> <dd>
<p>Log in on an SMTP server that requires authentication. The arguments are the username and the password to authenticate with. If there has been no previous <code>EHLO</code> or <code>HELO</code> command this session, this method tries ESMTP <code>EHLO</code> first. This method will return normally if the authentication was successful, or may raise the following exceptions:</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code>SMTPHeloError</code></a>
</dt>
<dd>
<p>The server didn’t reply properly to the <code>HELO</code> greeting.</p> </dd> <dt>
 <a class="reference internal" href="#smtplib.SMTPAuthenticationError" title="smtplib.SMTPAuthenticationError"><code>SMTPAuthenticationError</code></a>
</dt>
<dd>
<p>The server didn’t accept the username/password combination.</p> </dd> <dt>
 <a class="reference internal" href="#smtplib.SMTPException" title="smtplib.SMTPException"><code>SMTPException</code></a>
</dt>
<dd>
<p>No suitable authentication method was found.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="smtplib.SMTP.starttls">
<code>SMTP.starttls([keyfile[, certfile]])</code> </dt> <dd>
<p>Put the SMTP connection in TLS (Transport Layer Security) mode. All SMTP commands that follow will be encrypted. You should then call <a class="reference internal" href="#smtplib.SMTP.ehlo" title="smtplib.SMTP.ehlo"><code>ehlo()</code></a> again.</p> <p>If <em>keyfile</em> and <em>certfile</em> are provided, these are passed to the <a class="reference internal" href="socket#module-socket" title="socket: Low-level networking interface."><code>socket</code></a> module’s <a class="reference internal" href="ssl#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code>ssl()</code></a> function.</p> <p>If there has been no previous <code>EHLO</code> or <code>HELO</code> command this session, this method tries ESMTP <code>EHLO</code> first.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6.</span></p> </div> <dl class="simple"> <dt>
 <a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code>SMTPHeloError</code></a>
</dt>
<dd>
<p>The server didn’t reply properly to the <code>HELO</code> greeting.</p> </dd> <dt>
 <a class="reference internal" href="#smtplib.SMTPException" title="smtplib.SMTPException"><code>SMTPException</code></a>
</dt>
<dd>
<p>The server does not support the STARTTLS extension.</p> </dd> </dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6.</span></p> </div> <dl class="simple"> <dt>
 <a class="reference internal" href="exceptions#exceptions.RuntimeError" title="exceptions.RuntimeError"><code>RuntimeError</code></a>
</dt>
<dd>
<p>SSL/TLS support is not available to your Python interpreter.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="smtplib.SMTP.sendmail">
<code>SMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options])</code> </dt> <dd>
<p>Send mail. The required arguments are an <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html" id="index-6"><strong>RFC 822</strong></a> from-address string, a list of <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html" id="index-7"><strong>RFC 822</strong></a> to-address strings (a bare string will be treated as a list with 1 address), and a message string. The caller may pass a list of ESMTP options (such as <code>8bitmime</code>) to be used in <code>MAIL FROM</code> commands as <em>mail_options</em>. ESMTP options (such as <code>DSN</code> commands) that should be used with all <code>RCPT</code> commands can be passed as <em>rcpt_options</em>. (If you need to use different ESMTP options to different recipients you have to use the low-level methods such as <code>mail()</code>, <code>rcpt()</code> and <code>data()</code> to send the message.)</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <em>from_addr</em> and <em>to_addrs</em> parameters are used to construct the message envelope used by the transport agents. The <a class="reference internal" href="#smtplib.SMTP" title="smtplib.SMTP"><code>SMTP</code></a> does not modify the message headers in any way.</p> </div> <p>If there has been no previous <code>EHLO</code> or <code>HELO</code> command this session, this method tries ESMTP <code>EHLO</code> first. If the server does ESMTP, message size and each of the specified options will be passed to it (if the option is in the feature set the server advertises). If <code>EHLO</code> fails, <code>HELO</code> will be tried and ESMTP options suppressed.</p> <p>This method will return normally if the mail is accepted for at least one recipient. Otherwise it will raise an exception. That is, if this method does not raise an exception, then someone should get your mail. If this method does not raise an exception, it returns a dictionary, with one entry for each recipient that was refused. Each entry contains a tuple of the SMTP error code and the accompanying error message sent by the server.</p> <p>This method may raise the following exceptions:</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#smtplib.SMTPRecipientsRefused" title="smtplib.SMTPRecipientsRefused"><code>SMTPRecipientsRefused</code></a>
</dt>
<dd>
<p>All recipients were refused. Nobody got the mail. The <code>recipients</code> attribute of the exception object is a dictionary with information about the refused recipients (like the one returned when at least one recipient was accepted).</p> </dd> <dt>
 <a class="reference internal" href="#smtplib.SMTPHeloError" title="smtplib.SMTPHeloError"><code>SMTPHeloError</code></a>
</dt>
<dd>
<p>The server didn’t reply properly to the <code>HELO</code> greeting.</p> </dd> <dt>
 <a class="reference internal" href="#smtplib.SMTPSenderRefused" title="smtplib.SMTPSenderRefused"><code>SMTPSenderRefused</code></a>
</dt>
<dd>
<p>The server didn’t accept the <em>from_addr</em>.</p> </dd> <dt>
 <a class="reference internal" href="#smtplib.SMTPDataError" title="smtplib.SMTPDataError"><code>SMTPDataError</code></a>
</dt>
<dd>
<p>The server replied with an unexpected error code (other than a refusal of a recipient).</p> </dd> </dl> <p>Unless otherwise noted, the connection will be open even after an exception is raised.</p> </dd>
</dl> <dl class="method"> <dt id="smtplib.SMTP.quit">
<code>SMTP.quit()</code> </dt> <dd>
<p>Terminate the SMTP session and close the connection. Return the result of the SMTP <code>QUIT</code> command.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.6: </span>Return a value.</p> </div> </dd>
</dl> <p>Low-level methods corresponding to the standard SMTP/ESMTP commands <code>HELP</code>, <code>RSET</code>, <code>NOOP</code>, <code>MAIL</code>, <code>RCPT</code>, and <code>DATA</code> are also supported. Normally these do not need to be called directly, so they are not documented here. For details, consult the module code.</p>   <h2 id="id2">2. SMTP Example</h2> <p id="smtp-example">This example prompts the user for addresses needed in the message envelope (‘To’ and ‘From’ addresses), and the message to be delivered. Note that the headers to be included with the message must be included in the message as entered; this example doesn’t do any processing of the <a class="rfc reference external" href="https://tools.ietf.org/html/rfc822.html" id="index-8"><strong>RFC 822</strong></a> headers. In particular, the ‘To’ and ‘From’ addresses must be included in the message headers explicitly.</p> <pre data-language="python">import smtplib

def prompt(prompt):
    return raw_input(prompt).strip()

fromaddr = prompt("From: ")
toaddrs  = prompt("To: ").split()
print "Enter message, end with ^D (Unix) or ^Z (Windows):"

# Add the From: and To: headers at the start!
msg = ("From: %s\r\nTo: %s\r\n\r\n"
       % (fromaddr, ", ".join(toaddrs)))
while 1:
    try:
        line = raw_input()
    except EOFError:
        break
    if not line:
        break
    msg = msg + line

print "Message length is " + repr(len(msg))

server = smtplib.SMTP('localhost')
server.set_debuglevel(1)
server.sendmail(fromaddr, toaddrs, msg)
server.quit()
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In general, you will want to use the <a class="reference internal" href="email#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages, including MIME documents."><code>email</code></a> package’s features to construct an email message, which you can then convert to a string and send via <code>sendmail()</code>; see <a class="reference internal" href="email-examples#email-examples"><span class="std std-ref">email: Examples</span></a>.</p> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/smtplib.html" class="_attribution-link">https://docs.python.org/2.7/library/smtplib.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
