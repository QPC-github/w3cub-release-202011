
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Optparse - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" New in version 2.3. ">
  <meta name="keywords" content="optparse, —, parser, for, command, line, options, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/optparse.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/python~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="optparse-parser-for-command-line-options"> optparse — Parser for command line options</h1> <div class="versionadded" id="module-optparse"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 2.7: </span>The <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> module is deprecated and will not be developed further; development will continue with the <a class="reference internal" href="argparse#module-argparse" title="argparse: Command-line option and argument parsing library."><code>argparse</code></a> module.</p> </div> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/2.7/Lib/optparse.py">Lib/optparse.py</a></p>  <p><a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> is a more convenient, flexible, and powerful library for parsing command-line options than the old <a class="reference internal" href="getopt#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code>getopt</code></a> module. <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> uses a more declarative style of command-line parsing: you create an instance of <a class="reference internal" href="#optparse.OptionParser" title="optparse.OptionParser"><code>OptionParser</code></a>, populate it with options, and parse the command line. <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> allows users to specify options in the conventional GNU/POSIX syntax, and additionally generates usage and help messages for you.</p> <p>Here’s an example of using <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> in a simple script:</p> <pre data-language="python">from optparse import OptionParser
...
parser = OptionParser()
parser.add_option("-f", "--file", dest="filename",
                  help="write report to FILE", metavar="FILE")
parser.add_option("-q", "--quiet",
                  action="store_false", dest="verbose", default=True,
                  help="don't print status messages to stdout")

(options, args) = parser.parse_args()
</pre> <p>With these few lines of code, users of your script can now do the “usual thing” on the command-line, for example:</p> <pre data-language="python">&lt;yourscript&gt; --file=outfile -q
</pre> <p>As it parses the command line, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> sets attributes of the <code>options</code> object returned by <code>parse_args()</code> based on user-supplied command-line values. When <code>parse_args()</code> returns from parsing this command line, <code>options.filename</code> will be <code>"outfile"</code> and <code>options.verbose</code> will be <code>False</code>. <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> supports both long and short options, allows short options to be merged together, and allows options to be associated with their arguments in a variety of ways. Thus, the following command lines are all equivalent to the above example:</p> <pre data-language="python">&lt;yourscript&gt; -f outfile --quiet
&lt;yourscript&gt; --quiet --file outfile
&lt;yourscript&gt; -q -foutfile
&lt;yourscript&gt; -qfoutfile
</pre> <p>Additionally, users can run one of</p> <pre data-language="python">&lt;yourscript&gt; -h
&lt;yourscript&gt; --help
</pre> <p>and <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> will print out a brief summary of your script’s options:</p> <pre data-language="text">Usage: &lt;yourscript&gt; [options]

Options:
  -h, --help            show this help message and exit
  -f FILE, --file=FILE  write report to FILE
  -q, --quiet           don't print status messages to stdout
</pre> <p>where the value of <em>yourscript</em> is determined at runtime (normally from <code>sys.argv[0]</code>).</p>  <h2 id="optparse-background">1. Background</h2> <p id="background"><a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> was explicitly designed to encourage the creation of programs with straightforward, conventional command-line interfaces. To that end, it supports only the most common command-line syntax and semantics conventionally used under Unix. If you are unfamiliar with these conventions, read this section to acquaint yourself with them.</p>  <h3 id="optparse-terminology">1.1. Terminology</h3> <dl id="terminology"> <dt>argument</dt>
<dd>
<p>a string entered on the command-line, and passed by the shell to <code>execl()</code> or <code>execv()</code>. In Python, arguments are elements of <code>sys.argv[1:]</code> (<code>sys.argv[0]</code> is the name of the program being executed). Unix shells also use the term “word”.</p> <p>It is occasionally desirable to substitute an argument list other than <code>sys.argv[1:]</code>, so you should read “argument” as “an element of <code>sys.argv[1:]</code>, or of some other list provided as a substitute for <code>sys.argv[1:]</code>”.</p> </dd> <dt>option</dt>
<dd>
<p>an argument used to supply extra information to guide or customize the execution of a program. There are many different syntaxes for options; the traditional Unix syntax is a hyphen (“-“) followed by a single letter, e.g. <code>-x</code> or <code>-F</code>. Also, traditional Unix syntax allows multiple options to be merged into a single argument, e.g. <code>-x -F</code> is equivalent to <code>-xF</code>. The GNU project introduced <code>--</code> followed by a series of hyphen-separated words, e.g. <code>--file</code> or <code>--dry-run</code>. These are the only two option syntaxes provided by <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>.</p> <p>Some other option syntaxes that the world has seen include:</p> <ul class="simple"> <li>a hyphen followed by a few letters, e.g. <code>-pf</code> (this is <em>not</em> the same as multiple options merged into a single argument)</li> <li>a hyphen followed by a whole word, e.g. <code>-file</code> (this is technically equivalent to the previous syntax, but they aren’t usually seen in the same program)</li> <li>a plus sign followed by a single letter, or a few letters, or a word, e.g. <code>+f</code>, <code>+rgb</code>
</li> <li>a slash followed by a letter, or a few letters, or a word, e.g. <code>/f</code>, <code>/file</code>
</li> </ul> <p>These option syntaxes are not supported by <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>, and they never will be. This is deliberate: the first three are non-standard on any environment, and the last only makes sense if you’re exclusively targeting VMS, MS-DOS, and/or Windows.</p> </dd> <dt>option argument</dt>
<dd>
<p>an argument that follows an option, is closely associated with that option, and is consumed from the argument list when that option is. With <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>, option arguments may either be in a separate argument from their option:</p> <pre data-language="text">-f foo
--file foo
</pre> <p>or included in the same argument:</p> <pre data-language="text">-ffoo
--file=foo
</pre> <p>Typically, a given option either takes an argument or it doesn’t. Lots of people want an “optional option arguments” feature, meaning that some options will take an argument if they see it, and won’t if they don’t. This is somewhat controversial, because it makes parsing ambiguous: if <code>-a</code> takes an optional argument and <code>-b</code> is another option entirely, how do we interpret <code>-ab</code>? Because of this ambiguity, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> does not support this feature.</p> </dd> <dt>positional argument</dt>
<dd>
<p>something leftover in the argument list after options have been parsed, i.e. after options and their arguments have been parsed and removed from the argument list.</p> </dd> <dt>required option</dt>
<dd>
<p>an option that must be supplied on the command-line; note that the phrase “required option” is self-contradictory in English. <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> doesn’t prevent you from implementing required options, but doesn’t give you much help at it either.</p> </dd> </dl> <p>For example, consider this hypothetical command-line:</p> <pre data-language="python">prog -v --report report.txt foo bar
</pre> <p><code>-v</code> and <code>--report</code> are both options. Assuming that <code>--report</code> takes one argument, <code>report.txt</code> is an option argument. <code>foo</code> and <code>bar</code> are positional arguments.</p>   <h3 id="optparse-what-options-for">1.2. What are options for?</h3> <p id="what-are-options-for">Options are used to provide extra information to tune or customize the execution of a program. In case it wasn’t clear, options are usually <em>optional</em>. A program should be able to run just fine with no options whatsoever. (Pick a random program from the Unix or GNU toolsets. Can it run without any options at all and still make sense? The main exceptions are <code>find</code>, <code>tar</code>, and <code>dd</code>—all of which are mutant oddballs that have been rightly criticized for their non-standard syntax and confusing interfaces.)</p> <p>Lots of people want their programs to have “required options”. Think about it. If it’s required, then it’s <em>not optional</em>! If there is a piece of information that your program absolutely requires in order to run successfully, that’s what positional arguments are for.</p> <p>As an example of good command-line interface design, consider the humble <code>cp</code> utility, for copying files. It doesn’t make much sense to try to copy files without supplying a destination and at least one source. Hence, <code>cp</code> fails if you run it with no arguments. However, it has a flexible, useful syntax that does not require any options at all:</p> <pre data-language="python">cp SOURCE DEST
cp SOURCE ... DEST-DIR
</pre> <p>You can get pretty far with just that. Most <code>cp</code> implementations provide a bunch of options to tweak exactly how the files are copied: you can preserve mode and modification time, avoid following symlinks, ask before clobbering existing files, etc. But none of this distracts from the core mission of <code>cp</code>, which is to copy either one file to another, or several files to another directory.</p>   <h3 id="optparse-what-positional-arguments-for">1.3. What are positional arguments for?</h3> <p id="what-are-positional-arguments-for">Positional arguments are for those pieces of information that your program absolutely, positively requires to run.</p> <p>A good user interface should have as few absolute requirements as possible. If your program requires 17 distinct pieces of information in order to run successfully, it doesn’t much matter <em>how</em> you get that information from the user—most people will give up and walk away before they successfully run the program. This applies whether the user interface is a command-line, a configuration file, or a GUI: if you make that many demands on your users, most of them will simply give up.</p> <p>In short, try to minimize the amount of information that users are absolutely required to supply—use sensible defaults whenever possible. Of course, you also want to make your programs reasonably flexible. That’s what options are for. Again, it doesn’t matter if they are entries in a config file, widgets in the “Preferences” dialog of a GUI, or command-line options—the more options you implement, the more flexible your program is, and the more complicated its implementation becomes. Too much flexibility has drawbacks as well, of course; too many options can overwhelm users and make your code much harder to maintain.</p>    <h2 id="optparse-tutorial">2. Tutorial</h2> <p id="tutorial">While <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> is quite flexible and powerful, it’s also straightforward to use in most cases. This section covers the code patterns that are common to any <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>-based program.</p> <p>First, you need to import the OptionParser class; then, early in the main program, create an OptionParser instance:</p> <pre data-language="python">from optparse import OptionParser
...
parser = OptionParser()
</pre> <p>Then you can start defining options. The basic syntax is:</p> <pre data-language="python">parser.add_option(opt_str, ...,
                  attr=value, ...)
</pre> <p>Each option has one or more option strings, such as <code>-f</code> or <code>--file</code>, and several option attributes that tell <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> what to expect and what to do when it encounters that option on the command line.</p> <p>Typically, each option will have one short option string and one long option string, e.g.:</p> <pre data-language="python">parser.add_option("-f", "--file", ...)
</pre> <p>You’re free to define as many short option strings and as many long option strings as you like (including zero), as long as there is at least one option string overall.</p> <p>The option strings passed to <a class="reference internal" href="#optparse.OptionParser.add_option" title="optparse.OptionParser.add_option"><code>OptionParser.add_option()</code></a> are effectively labels for the option defined by that call. For brevity, we will frequently refer to <em>encountering an option</em> on the command line; in reality, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> encounters <em>option strings</em> and looks up options from them.</p> <p>Once all of your options are defined, instruct <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> to parse your program’s command line:</p> <pre data-language="python">(options, args) = parser.parse_args()
</pre> <p>(If you like, you can pass a custom argument list to <code>parse_args()</code>, but that’s rarely necessary: by default it uses <code>sys.argv[1:]</code>.)</p> <p><code>parse_args()</code> returns two values:</p> <ul class="simple"> <li>
<code>options</code>, an object containing values for all of your options—e.g. if <code>--file</code> takes a single string argument, then <code>options.file</code> will be the filename supplied by the user, or <code>None</code> if the user did not supply that option</li> <li>
<code>args</code>, the list of positional arguments leftover after parsing options</li> </ul> <p>This tutorial section only covers the four most important option attributes: <a class="reference internal" href="#optparse.Option.action" title="optparse.Option.action"><code>action</code></a>, <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a>, <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a> (destination), and <a class="reference internal" href="#optparse.Option.help" title="optparse.Option.help"><code>help</code></a>. Of these, <a class="reference internal" href="#optparse.Option.action" title="optparse.Option.action"><code>action</code></a> is the most fundamental.</p>  <h3 id="optparse-understanding-option-actions">2.1. Understanding option actions</h3> <p id="understanding-option-actions">Actions tell <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> what to do when it encounters an option on the command line. There is a fixed set of actions hard-coded into <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>; adding new actions is an advanced topic covered in section <a class="reference internal" href="#optparse-extending-optparse"><span class="std std-ref">Extending optparse</span></a>. Most actions tell <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> to store a value in some variable—for example, take a string from the command line and store it in an attribute of <code>options</code>.</p> <p>If you don’t specify an option action, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> defaults to <code>store</code>.</p>   <h3 id="optparse-store-action">2.2. The store action</h3> <p id="the-store-action">The most common option action is <code>store</code>, which tells <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> to take the next argument (or the remainder of the current argument), ensure that it is of the correct type, and store it to your chosen destination.</p> <p>For example:</p> <pre data-language="python">parser.add_option("-f", "--file",
                  action="store", type="string", dest="filename")
</pre> <p>Now let’s make up a fake command line and ask <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> to parse it:</p> <pre data-language="python">args = ["-f", "foo.txt"]
(options, args) = parser.parse_args(args)
</pre> <p>When <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> sees the option string <code>-f</code>, it consumes the next argument, <code>foo.txt</code>, and stores it in <code>options.filename</code>. So, after this call to <code>parse_args()</code>, <code>options.filename</code> is <code>"foo.txt"</code>.</p> <p>Some other option types supported by <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> are <code>int</code> and <code>float</code>. Here’s an option that expects an integer argument:</p> <pre data-language="python">parser.add_option("-n", type="int", dest="num")
</pre> <p>Note that this option has no long option string, which is perfectly acceptable. Also, there’s no explicit action, since the default is <code>store</code>.</p> <p>Let’s parse another fake command-line. This time, we’ll jam the option argument right up against the option: since <code>-n42</code> (one argument) is equivalent to <code>-n 42</code> (two arguments), the code</p> <pre data-language="python">(options, args) = parser.parse_args(["-n42"])
print options.num
</pre> <p>will print <code>42</code>.</p> <p>If you don’t specify a type, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> assumes <code>string</code>. Combined with the fact that the default action is <code>store</code>, that means our first example can be a lot shorter:</p> <pre data-language="python">parser.add_option("-f", "--file", dest="filename")
</pre> <p>If you don’t supply a destination, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> figures out a sensible default from the option strings: if the first long option string is <code>--foo-bar</code>, then the default destination is <code>foo_bar</code>. If there are no long option strings, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> looks at the first short option string: the default destination for <code>-f</code> is <code>f</code>.</p> <p><a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> also includes built-in <code>long</code> and <code>complex</code> types. Adding types is covered in section <a class="reference internal" href="#optparse-extending-optparse"><span class="std std-ref">Extending optparse</span></a>.</p>   <h3 id="optparse-handling-boolean-options">2.3. Handling boolean (flag) options</h3> <p id="handling-boolean-flag-options">Flag options—set a variable to true or false when a particular option is seen —are quite common. <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> supports them with two separate actions, <code>store_true</code> and <code>store_false</code>. For example, you might have a <code>verbose</code> flag that is turned on with <code>-v</code> and off with <code>-q</code>:</p> <pre data-language="python">parser.add_option("-v", action="store_true", dest="verbose")
parser.add_option("-q", action="store_false", dest="verbose")
</pre> <p>Here we have two different options with the same destination, which is perfectly OK. (It just means you have to be a bit careful when setting default values— see below.)</p> <p>When <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> encounters <code>-v</code> on the command line, it sets <code>options.verbose</code> to <code>True</code>; when it encounters <code>-q</code>, <code>options.verbose</code> is set to <code>False</code>.</p>   <h3 id="optparse-other-actions">2.4. Other actions</h3> <p id="other-actions">Some other actions supported by <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> are:</p> <dl class="simple"> <dt>
<code>"store_const"</code> </dt>
<dd>
<p>store a constant value</p> </dd> <dt>
<code>"append"</code> </dt>
<dd>
<p>append this option’s argument to a list</p> </dd> <dt>
<code>"count"</code> </dt>
<dd>
<p>increment a counter by one</p> </dd> <dt>
<code>"callback"</code> </dt>
<dd>
<p>call a specified function</p> </dd> </dl> <p>These are covered in section <a class="reference internal" href="#optparse-reference-guide"><span class="std std-ref">Reference Guide</span></a>, Reference Guide and section <a class="reference internal" href="#optparse-option-callbacks"><span class="std std-ref">Option Callbacks</span></a>.</p>   <h3 id="optparse-default-values">2.5. Default values</h3> <p id="default-values">All of the above examples involve setting some variable (the “destination”) when certain command-line options are seen. What happens if those options are never seen? Since we didn’t supply any defaults, they are all set to <code>None</code>. This is usually fine, but sometimes you want more control. <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> lets you supply a default value for each destination, which is assigned before the command line is parsed.</p> <p>First, consider the verbose/quiet example. If we want <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> to set <code>verbose</code> to <code>True</code> unless <code>-q</code> is seen, then we can do this:</p> <pre data-language="python">parser.add_option("-v", action="store_true", dest="verbose", default=True)
parser.add_option("-q", action="store_false", dest="verbose")
</pre> <p>Since default values apply to the <em>destination</em> rather than to any particular option, and these two options happen to have the same destination, this is exactly equivalent:</p> <pre data-language="python">parser.add_option("-v", action="store_true", dest="verbose")
parser.add_option("-q", action="store_false", dest="verbose", default=True)
</pre> <p>Consider this:</p> <pre data-language="python">parser.add_option("-v", action="store_true", dest="verbose", default=False)
parser.add_option("-q", action="store_false", dest="verbose", default=True)
</pre> <p>Again, the default value for <code>verbose</code> will be <code>True</code>: the last default value supplied for any particular destination is the one that counts.</p> <p>A clearer way to specify default values is the <code>set_defaults()</code> method of OptionParser, which you can call at any time before calling <code>parse_args()</code>:</p> <pre data-language="python">parser.set_defaults(verbose=True)
parser.add_option(...)
(options, args) = parser.parse_args()
</pre> <p>As before, the last value specified for a given option destination is the one that counts. For clarity, try to use one method or the other of setting default values, not both.</p>   <h3 id="optparse-generating-help">2.6. Generating help</h3> <p id="generating-help"><a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>’s ability to generate help and usage text automatically is useful for creating user-friendly command-line interfaces. All you have to do is supply a <a class="reference internal" href="#optparse.Option.help" title="optparse.Option.help"><code>help</code></a> value for each option, and optionally a short usage message for your whole program. Here’s an OptionParser populated with user-friendly (documented) options:</p> <pre data-language="python">usage = "usage: %prog [options] arg1 arg2"
parser = OptionParser(usage=usage)
parser.add_option("-v", "--verbose",
                  action="store_true", dest="verbose", default=True,
                  help="make lots of noise [default]")
parser.add_option("-q", "--quiet",
                  action="store_false", dest="verbose",
                  help="be vewwy quiet (I'm hunting wabbits)")
parser.add_option("-f", "--filename",
                  metavar="FILE", help="write output to FILE")
parser.add_option("-m", "--mode",
                  default="intermediate",
                  help="interaction mode: novice, intermediate, "
                       "or expert [default: %default]")
</pre> <p>If <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> encounters either <code>-h</code> or <code>--help</code> on the command-line, or if you just call <code>parser.print_help()</code>, it prints the following to standard output:</p> <pre data-language="text">Usage: &lt;yourscript&gt; [options] arg1 arg2

Options:
  -h, --help            show this help message and exit
  -v, --verbose         make lots of noise [default]
  -q, --quiet           be vewwy quiet (I'm hunting wabbits)
  -f FILE, --filename=FILE
                        write output to FILE
  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or
                        expert [default: intermediate]
</pre> <p>(If the help output is triggered by a help option, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> exits after printing the help text.)</p> <p>There’s a lot going on here to help <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> generate the best possible help message:</p> <ul> <li>
<p>the script defines its own usage message:</p> <pre data-language="python">usage = "usage: %prog [options] arg1 arg2"
</pre> <p><a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> expands <code>%prog</code> in the usage string to the name of the current program, i.e. <code>os.path.basename(sys.argv[0])</code>. The expanded string is then printed before the detailed option help.</p> <p>If you don’t supply a usage string, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> uses a bland but sensible default: <code>"Usage: %prog [options]"</code>, which is fine if your script doesn’t take any positional arguments.</p> </li> <li>every option defines a help string, and doesn’t worry about line-wrapping— <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> takes care of wrapping lines and making the help output look good.</li> <li>
<p>options that take a value indicate this fact in their automatically-generated help message, e.g. for the “mode” option:</p> <pre data-language="python">-m MODE, --mode=MODE
</pre> <p>Here, “MODE” is called the meta-variable: it stands for the argument that the user is expected to supply to <code>-m</code>/<code>--mode</code>. By default, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> converts the destination variable name to uppercase and uses that for the meta-variable. Sometimes, that’s not what you want—for example, the <code>--filename</code> option explicitly sets <code>metavar="FILE"</code>, resulting in this automatically-generated option description:</p> <pre data-language="python">-f FILE, --filename=FILE
</pre> <p>This is important for more than just saving space, though: the manually written help text uses the meta-variable <code>FILE</code> to clue the user in that there’s a connection between the semi-formal syntax <code>-f FILE</code> and the informal semantic description “write output to FILE”. This is a simple but effective way to make your help text a lot clearer and more useful for end users.</p> </li> </ul> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.4: </span>Options that have a default value can include <code>%default</code> in the help string—<a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> will replace it with <a class="reference internal" href="functions#str" title="str"><code>str()</code></a> of the option’s default value. If an option has no default value (or the default value is <code>None</code>), <code>%default</code> expands to <code>none</code>.</p> </div>  <h4 id="grouping-options">2.6.1. Grouping Options</h4> <p>When dealing with many options, it is convenient to group these options for better help output. An <a class="reference internal" href="#optparse.OptionParser" title="optparse.OptionParser"><code>OptionParser</code></a> can contain several option groups, each of which can contain several options.</p> <p>An option group is obtained using the class <a class="reference internal" href="#optparse.OptionGroup" title="optparse.OptionGroup"><code>OptionGroup</code></a>:</p> <dl class="class"> <dt id="optparse.OptionGroup">
<code>class optparse.OptionGroup(parser, title, description=None)</code> </dt> <dd>
<p>where</p> <ul class="simple"> <li>parser is the <a class="reference internal" href="#optparse.OptionParser" title="optparse.OptionParser"><code>OptionParser</code></a> instance the group will be insterted in to</li> <li>title is the group title</li> <li>description, optional, is a long description of the group</li> </ul> </dd>
</dl> <p><a class="reference internal" href="#optparse.OptionGroup" title="optparse.OptionGroup"><code>OptionGroup</code></a> inherits from <code>OptionContainer</code> (like <a class="reference internal" href="#optparse.OptionParser" title="optparse.OptionParser"><code>OptionParser</code></a>) and so the <code>add_option()</code> method can be used to add an option to the group.</p> <p>Once all the options are declared, using the <a class="reference internal" href="#optparse.OptionParser" title="optparse.OptionParser"><code>OptionParser</code></a> method <code>add_option_group()</code> the group is added to the previously defined parser.</p> <p>Continuing with the parser defined in the previous section, adding an <a class="reference internal" href="#optparse.OptionGroup" title="optparse.OptionGroup"><code>OptionGroup</code></a> to a parser is easy:</p> <pre data-language="python">group = OptionGroup(parser, "Dangerous Options",
                    "Caution: use these options at your own risk.  "
                    "It is believed that some of them bite.")
group.add_option("-g", action="store_true", help="Group option.")
parser.add_option_group(group)
</pre> <p>This would result in the following help output:</p> <pre data-language="text">Usage: &lt;yourscript&gt; [options] arg1 arg2

Options:
  -h, --help            show this help message and exit
  -v, --verbose         make lots of noise [default]
  -q, --quiet           be vewwy quiet (I'm hunting wabbits)
  -f FILE, --filename=FILE
                        write output to FILE
  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or
                        expert [default: intermediate]

  Dangerous Options:
    Caution: use these options at your own risk.  It is believed that some
    of them bite.

    -g                  Group option.
</pre> <p>A bit more complete example might involve using more than one group: still extending the previous example:</p> <pre data-language="python">group = OptionGroup(parser, "Dangerous Options",
                    "Caution: use these options at your own risk.  "
                    "It is believed that some of them bite.")
group.add_option("-g", action="store_true", help="Group option.")
parser.add_option_group(group)

group = OptionGroup(parser, "Debug Options")
group.add_option("-d", "--debug", action="store_true",
                 help="Print debug information")
group.add_option("-s", "--sql", action="store_true",
                 help="Print all SQL statements executed")
group.add_option("-e", action="store_true", help="Print every action done")
parser.add_option_group(group)
</pre> <p>that results in the following output:</p> <pre data-language="text">Usage: &lt;yourscript&gt; [options] arg1 arg2

Options:
  -h, --help            show this help message and exit
  -v, --verbose         make lots of noise [default]
  -q, --quiet           be vewwy quiet (I'm hunting wabbits)
  -f FILE, --filename=FILE
                        write output to FILE
  -m MODE, --mode=MODE  interaction mode: novice, intermediate, or expert
                        [default: intermediate]

  Dangerous Options:
    Caution: use these options at your own risk.  It is believed that some
    of them bite.

    -g                  Group option.

  Debug Options:
    -d, --debug         Print debug information
    -s, --sql           Print all SQL statements executed
    -e                  Print every action done
</pre> <p>Another interesting method, in particular when working programmatically with option groups is:</p> <dl class="method"> <dt id="optparse.OptionParser.get_option_group">
<code>OptionParser.get_option_group(opt_str)</code> </dt> <dd>
<p>Return the <a class="reference internal" href="#optparse.OptionGroup" title="optparse.OptionGroup"><code>OptionGroup</code></a> to which the short or long option string <em>opt_str</em> (e.g. <code>'-o'</code> or <code>'--option'</code>) belongs. If there’s no such <a class="reference internal" href="#optparse.OptionGroup" title="optparse.OptionGroup"><code>OptionGroup</code></a>, return <code>None</code>.</p> </dd>
</dl>    <h3 id="optparse-printing-version-string">2.7. Printing a version string</h3> <p id="printing-a-version-string">Similar to the brief usage string, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> can also print a version string for your program. You have to supply the string as the <code>version</code> argument to OptionParser:</p> <pre data-language="python">parser = OptionParser(usage="%prog [-f] [-q]", version="%prog 1.0")
</pre> <p><code>%prog</code> is expanded just like it is in <code>usage</code>. Apart from that, <code>version</code> can contain anything you like. When you supply it, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> automatically adds a <code>--version</code> option to your parser. If it encounters this option on the command line, it expands your <code>version</code> string (by replacing <code>%prog</code>), prints it to stdout, and exits.</p> <p>For example, if your script is called <code>/usr/bin/foo</code>:</p> <pre data-language="shell">$ /usr/bin/foo --version
foo 1.0
</pre> <p>The following two methods can be used to print and get the <code>version</code> string:</p> <dl class="method"> <dt id="optparse.OptionParser.print_version">
<code>OptionParser.print_version(file=None)</code> </dt> <dd>
<p>Print the version message for the current program (<code>self.version</code>) to <em>file</em> (default stdout). As with <a class="reference internal" href="#optparse.OptionParser.print_usage" title="optparse.OptionParser.print_usage"><code>print_usage()</code></a>, any occurrence of <code>%prog</code> in <code>self.version</code> is replaced with the name of the current program. Does nothing if <code>self.version</code> is empty or undefined.</p> </dd>
</dl> <dl class="method"> <dt id="optparse.OptionParser.get_version">
<code>OptionParser.get_version()</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#optparse.OptionParser.print_version" title="optparse.OptionParser.print_version"><code>print_version()</code></a> but returns the version string instead of printing it.</p> </dd>
</dl>   <h3 id="optparse-how-optparse-handles-errors">2.8. How <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> handles errors</h3> <p id="how-optparse-handles-errors">There are two broad classes of errors that <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> has to worry about: programmer errors and user errors. Programmer errors are usually erroneous calls to <a class="reference internal" href="#optparse.OptionParser.add_option" title="optparse.OptionParser.add_option"><code>OptionParser.add_option()</code></a>, e.g. invalid option strings, unknown option attributes, missing option attributes, etc. These are dealt with in the usual way: raise an exception (either <code>optparse.OptionError</code> or <a class="reference internal" href="exceptions#exceptions.TypeError" title="exceptions.TypeError"><code>TypeError</code></a>) and let the program crash.</p> <p>Handling user errors is much more important, since they are guaranteed to happen no matter how stable your code is. <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> can automatically detect some user errors, such as bad option arguments (passing <code>-n 4x</code> where <code>-n</code> takes an integer argument), missing arguments (<code>-n</code> at the end of the command line, where <code>-n</code> takes an argument of any type). Also, you can call <code>OptionParser.error()</code> to signal an application-defined error condition:</p> <pre data-language="python">(options, args) = parser.parse_args()
...
if options.a and options.b:
    parser.error("options -a and -b are mutually exclusive")
</pre> <p>In either case, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> handles the error the same way: it prints the program’s usage message and an error message to standard error and exits with error status 2.</p> <p>Consider the first example above, where the user passes <code>4x</code> to an option that takes an integer:</p> <pre data-language="shell">$ /usr/bin/foo -n 4x
Usage: foo [options]

foo: error: option -n: invalid integer value: '4x'
</pre> <p>Or, where the user fails to pass a value at all:</p> <pre data-language="shell">$ /usr/bin/foo -n
Usage: foo [options]

foo: error: -n option requires an argument
</pre> <p><a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>-generated error messages take care always to mention the option involved in the error; be sure to do the same when calling <code>OptionParser.error()</code> from your application code.</p> <p>If <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>’s default error-handling behaviour does not suit your needs, you’ll need to subclass OptionParser and override its <code>exit()</code> and/or <code>error()</code> methods.</p>   <h3 id="optparse-putting-it-all-together">2.9. Putting it all together</h3> <p id="putting-it-all-together">Here’s what <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>-based scripts usually look like:</p> <pre data-language="python">from optparse import OptionParser
...
def main():
    usage = "usage: %prog [options] arg"
    parser = OptionParser(usage)
    parser.add_option("-f", "--file", dest="filename",
                      help="read data from FILENAME")
    parser.add_option("-v", "--verbose",
                      action="store_true", dest="verbose")
    parser.add_option("-q", "--quiet",
                      action="store_false", dest="verbose")
    ...
    (options, args) = parser.parse_args()
    if len(args) != 1:
        parser.error("incorrect number of arguments")
    if options.verbose:
        print "reading %s..." % options.filename
    ...

if __name__ == "__main__":
    main()
</pre>    <h2 id="optparse-reference-guide">3. Reference Guide</h2>  <h3 id="optparse-creating-parser">3.1. Creating the parser</h3> <p id="reference-guide">The first step in using <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> is to create an OptionParser instance.</p> <dl class="class"> <dt id="optparse.OptionParser">
<code>class optparse.OptionParser(...)</code> </dt> <dd>
<p>The OptionParser constructor has no required arguments, but a number of optional keyword arguments. You should always pass them as keyword arguments, i.e. do not rely on the order in which the arguments are declared.</p> <dl class="simple"> <dt>
<code>usage (default: "%prog [options]")</code> </dt>
<dd>
<p>The usage summary to print when your program is run incorrectly or with a help option. When <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> prints the usage string, it expands <code>%prog</code> to <code>os.path.basename(sys.argv[0])</code> (or to <code>prog</code> if you passed that keyword argument). To suppress a usage message, pass the special value <code>optparse.SUPPRESS_USAGE</code>.</p> </dd> <dt>
<code>option_list (default: [])</code> </dt>
<dd>
<p>A list of Option objects to populate the parser with. The options in <code>option_list</code> are added after any options in <code>standard_option_list</code> (a class attribute that may be set by OptionParser subclasses), but before any version or help options. Deprecated; use <a class="reference internal" href="#optparse.OptionParser.add_option" title="optparse.OptionParser.add_option"><code>add_option()</code></a> after creating the parser instead.</p> </dd> <dt>
<code>option_class (default: optparse.Option)</code> </dt>
<dd>
<p>Class to use when adding options to the parser in <a class="reference internal" href="#optparse.OptionParser.add_option" title="optparse.OptionParser.add_option"><code>add_option()</code></a>.</p> </dd> <dt>
<code>version (default: None)</code> </dt>
<dd>
<p>A version string to print when the user supplies a version option. If you supply a true value for <code>version</code>, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> automatically adds a version option with the single option string <code>--version</code>. The substring <code>%prog</code> is expanded the same as for <code>usage</code>.</p> </dd> <dt>
<code>conflict_handler (default: "error")</code> </dt>
<dd>
<p>Specifies what to do when options with conflicting option strings are added to the parser; see section <a class="reference internal" href="#optparse-conflicts-between-options"><span class="std std-ref">Conflicts between options</span></a>.</p> </dd> <dt>
<code>description (default: None)</code> </dt>
<dd>
<p>A paragraph of text giving a brief overview of your program. <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> reformats this paragraph to fit the current terminal width and prints it when the user requests help (after <code>usage</code>, but before the list of options).</p> </dd> <dt>
<code>formatter (default: a new IndentedHelpFormatter)</code> </dt>
<dd>
<p>An instance of optparse.HelpFormatter that will be used for printing help text. <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> provides two concrete classes for this purpose: IndentedHelpFormatter and TitledHelpFormatter.</p> </dd> <dt>
<code>add_help_option (default: True)</code> </dt>
<dd>
<p>If true, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> will add a help option (with option strings <code>-h</code> and <code>--help</code>) to the parser.</p> </dd> <dt>
<code>prog</code> </dt>
<dd>
<p>The string to use when expanding <code>%prog</code> in <code>usage</code> and <code>version</code> instead of <code>os.path.basename(sys.argv[0])</code>.</p> </dd> <dt>
<code>epilog (default: None)</code> </dt>
<dd>
<p>A paragraph of help text to print after the option help.</p> </dd> </dl> </dd>
</dl>   <h3 id="optparse-populating-parser">3.2. Populating the parser</h3> <p id="populating-the-parser">There are several ways to populate the parser with options. The preferred way is by using <a class="reference internal" href="#optparse.OptionParser.add_option" title="optparse.OptionParser.add_option"><code>OptionParser.add_option()</code></a>, as shown in section <a class="reference internal" href="#optparse-tutorial"><span class="std std-ref">Tutorial</span></a>. <code>add_option()</code> can be called in one of two ways:</p> <ul class="simple"> <li>pass it an Option instance (as returned by <code>make_option()</code>)</li> <li>pass it any combination of positional and keyword arguments that are acceptable to <code>make_option()</code> (i.e., to the Option constructor), and it will create the Option instance for you</li> </ul> <p>The other alternative is to pass a list of pre-constructed Option instances to the OptionParser constructor, as in:</p> <pre data-language="python">option_list = [
    make_option("-f", "--filename",
                action="store", type="string", dest="filename"),
    make_option("-q", "--quiet",
                action="store_false", dest="verbose"),
    ]
parser = OptionParser(option_list=option_list)
</pre> <p>(<code>make_option()</code> is a factory function for creating Option instances; currently it is an alias for the Option constructor. A future version of <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> may split Option into several classes, and <code>make_option()</code> will pick the right class to instantiate. Do not instantiate Option directly.)</p>   <h3 id="optparse-defining-options">3.3. Defining options</h3> <p id="defining-options">Each Option instance represents a set of synonymous command-line option strings, e.g. <code>-f</code> and <code>--file</code>. You can specify any number of short or long option strings, but you must specify at least one overall option string.</p> <p>The canonical way to create an <code>Option</code> instance is with the <code>add_option()</code> method of <a class="reference internal" href="#optparse.OptionParser" title="optparse.OptionParser"><code>OptionParser</code></a>.</p> <dl class="method"> <dt id="optparse.OptionParser.add_option">
<code>OptionParser.add_option(option)</code> </dt> <dt>
<code>OptionParser.add_option(*opt_str, attr=value, ...)</code> </dt> <dd>
<p>To define an option with only a short option string:</p> <pre data-language="python">parser.add_option("-f", attr=value, ...)
</pre> <p>And to define an option with only a long option string:</p> <pre data-language="python">parser.add_option("--foo", attr=value, ...)
</pre> <p>The keyword arguments define attributes of the new Option object. The most important option attribute is <a class="reference internal" href="#optparse.Option.action" title="optparse.Option.action"><code>action</code></a>, and it largely determines which other attributes are relevant or required. If you pass irrelevant option attributes, or fail to pass required ones, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> raises an <code>OptionError</code> exception explaining your mistake.</p> <p>An option’s <em>action</em> determines what <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> does when it encounters this option on the command-line. The standard option actions hard-coded into <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> are:</p> <dl class="simple"> <dt>
<code>"store"</code> </dt>
<dd>
<p>store this option’s argument (default)</p> </dd> <dt>
<code>"store_const"</code> </dt>
<dd>
<p>store a constant value</p> </dd> <dt>
<code>"store_true"</code> </dt>
<dd>
<p>store a true value</p> </dd> <dt>
<code>"store_false"</code> </dt>
<dd>
<p>store a false value</p> </dd> <dt>
<code>"append"</code> </dt>
<dd>
<p>append this option’s argument to a list</p> </dd> <dt>
<code>"append_const"</code> </dt>
<dd>
<p>append a constant value to a list</p> </dd> <dt>
<code>"count"</code> </dt>
<dd>
<p>increment a counter by one</p> </dd> <dt>
<code>"callback"</code> </dt>
<dd>
<p>call a specified function</p> </dd> <dt>
<code>"help"</code> </dt>
<dd>
<p>print a usage message including all options and the documentation for them</p> </dd> </dl> <p>(If you don’t supply an action, the default is <code>"store"</code>. For this action, you may also supply <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a> and <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a> option attributes; see <a class="reference internal" href="#optparse-standard-option-actions"><span class="std std-ref">Standard option actions</span></a>.)</p> </dd>
</dl> <p>As you can see, most actions involve storing or updating a value somewhere. <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> always creates a special object for this, conventionally called <code>options</code> (it happens to be an instance of <code>optparse.Values</code>). Option arguments (and various other values) are stored as attributes of this object, according to the <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a> (destination) option attribute.</p> <p>For example, when you call</p> <pre data-language="python">parser.parse_args()
</pre> <p>one of the first things <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> does is create the <code>options</code> object:</p> <pre data-language="python">options = Values()
</pre> <p>If one of the options in this parser is defined with</p> <pre data-language="python">parser.add_option("-f", "--file", action="store", type="string", dest="filename")
</pre> <p>and the command-line being parsed includes any of the following:</p> <pre data-language="python">-ffoo
-f foo
--file=foo
--file foo
</pre> <p>then <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>, on seeing this option, will do the equivalent of</p> <pre data-language="python">options.filename = "foo"
</pre> <p>The <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a> and <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a> option attributes are almost as important as <a class="reference internal" href="#optparse.Option.action" title="optparse.Option.action"><code>action</code></a>, but <a class="reference internal" href="#optparse.Option.action" title="optparse.Option.action"><code>action</code></a> is the only one that makes sense for <em>all</em> options.</p>   <h3 id="optparse-option-attributes">3.4. Option attributes</h3> <p id="option-attributes">The following option attributes may be passed as keyword arguments to <a class="reference internal" href="#optparse.OptionParser.add_option" title="optparse.OptionParser.add_option"><code>OptionParser.add_option()</code></a>. If you pass an option attribute that is not relevant to a particular option, or fail to pass a required option attribute, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> raises <code>OptionError</code>.</p> <dl class="attribute"> <dt id="optparse.Option.action">
<code>Option.action</code> </dt> <dd>
<p>(default: <code>"store"</code>)</p> <p>Determines <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>’s behaviour when this option is seen on the command line; the available options are documented <a class="reference internal" href="#optparse-standard-option-actions"><span class="std std-ref">here</span></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.type">
<code>Option.type</code> </dt> <dd>
<p>(default: <code>"string"</code>)</p> <p>The argument type expected by this option (e.g., <code>"string"</code> or <code>"int"</code>); the available option types are documented <a class="reference internal" href="#optparse-standard-option-types"><span class="std std-ref">here</span></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.dest">
<code>Option.dest</code> </dt> <dd>
<p>(default: derived from option strings)</p> <p>If the option’s action implies writing or modifying a value somewhere, this tells <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> where to write it: <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a> names an attribute of the <code>options</code> object that <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> builds as it parses the command line.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.default">
<code>Option.default</code> </dt> <dd>
<p>The value to use for this option’s destination if the option is not seen on the command line. See also <a class="reference internal" href="#optparse.OptionParser.set_defaults" title="optparse.OptionParser.set_defaults"><code>OptionParser.set_defaults()</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.nargs">
<code>Option.nargs</code> </dt> <dd>
<p>(default: 1)</p> <p>How many arguments of type <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a> should be consumed when this option is seen. If &gt; 1, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> will store a tuple of values to <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.const">
<code>Option.const</code> </dt> <dd>
<p>For actions that store a constant value, the constant value to store.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.choices">
<code>Option.choices</code> </dt> <dd>
<p>For options of type <code>"choice"</code>, the list of strings the user may choose from.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.callback">
<code>Option.callback</code> </dt> <dd>
<p>For options with action <code>"callback"</code>, the callable to call when this option is seen. See section <a class="reference internal" href="#optparse-option-callbacks"><span class="std std-ref">Option Callbacks</span></a> for detail on the arguments passed to the callable.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.callback_args">
<code>Option.callback_args</code> </dt> <dt id="optparse.Option.callback_kwargs">
<code>Option.callback_kwargs</code> </dt> <dd>
<p>Additional positional and keyword arguments to pass to <code>callback</code> after the four standard callback arguments.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.help">
<code>Option.help</code> </dt> <dd>
<p>Help text to print for this option when listing all available options after the user supplies a <a class="reference internal" href="#optparse.Option.help" title="optparse.Option.help"><code>help</code></a> option (such as <code>--help</code>). If no help text is supplied, the option will be listed without help text. To hide this option, use the special value <code>optparse.SUPPRESS_HELP</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.metavar">
<code>Option.metavar</code> </dt> <dd>
<p>(default: derived from option strings)</p> <p>Stand-in for the option argument(s) to use when printing help text. See section <a class="reference internal" href="#optparse-tutorial"><span class="std std-ref">Tutorial</span></a> for an example.</p> </dd>
</dl>   <h3 id="optparse-standard-option-actions">3.5. Standard option actions</h3> <p id="standard-option-actions">The various option actions all have slightly different requirements and effects. Most actions have several relevant option attributes which you may specify to guide <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>’s behaviour; a few have required attributes, which you must specify for any option using that action.</p> <ul> <li>
<p><code>"store"</code> [relevant: <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a>, <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>, <a class="reference internal" href="#optparse.Option.nargs" title="optparse.Option.nargs"><code>nargs</code></a>, <a class="reference internal" href="#optparse.Option.choices" title="optparse.Option.choices"><code>choices</code></a>]</p> <p>The option must be followed by an argument, which is converted to a value according to <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a> and stored in <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>. If <a class="reference internal" href="#optparse.Option.nargs" title="optparse.Option.nargs"><code>nargs</code></a> &gt; 1, multiple arguments will be consumed from the command line; all will be converted according to <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a> and stored to <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a> as a tuple. See the <a class="reference internal" href="#optparse-standard-option-types"><span class="std std-ref">Standard option types</span></a> section.</p> <p>If <a class="reference internal" href="#optparse.Option.choices" title="optparse.Option.choices"><code>choices</code></a> is supplied (a list or tuple of strings), the type defaults to <code>"choice"</code>.</p> <p>If <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a> is not supplied, it defaults to <code>"string"</code>.</p> <p>If <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a> is not supplied, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> derives a destination from the first long option string (e.g., <code>--foo-bar</code> implies <code>foo_bar</code>). If there are no long option strings, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> derives a destination from the first short option string (e.g., <code>-f</code> implies <code>f</code>).</p> <p>Example:</p> <pre data-language="python">parser.add_option("-f")
parser.add_option("-p", type="float", nargs=3, dest="point")
</pre> <p>As it parses the command line</p> <pre data-language="python">-f foo.txt -p 1 -3.5 4 -fbar.txt
</pre> <p><a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> will set</p> <pre data-language="python">options.f = "foo.txt"
options.point = (1.0, -3.5, 4.0)
options.f = "bar.txt"
</pre> </li> <li>
<p><code>"store_const"</code> [required: <a class="reference internal" href="#optparse.Option.const" title="optparse.Option.const"><code>const</code></a>; relevant: <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>]</p> <p>The value <a class="reference internal" href="#optparse.Option.const" title="optparse.Option.const"><code>const</code></a> is stored in <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>.</p> <p>Example:</p> <pre data-language="python">parser.add_option("-q", "--quiet",
                  action="store_const", const=0, dest="verbose")
parser.add_option("-v", "--verbose",
                  action="store_const", const=1, dest="verbose")
parser.add_option("--noisy",
                  action="store_const", const=2, dest="verbose")
</pre> <p>If <code>--noisy</code> is seen, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> will set</p> <pre data-language="python">options.verbose = 2
</pre> </li> <li>
<p><code>"store_true"</code> [relevant: <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>]</p> <p>A special case of <code>"store_const"</code> that stores a true value to <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>.</p> </li> <li>
<p><code>"store_false"</code> [relevant: <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>]</p> <p>Like <code>"store_true"</code>, but stores a false value.</p> <p>Example:</p> <pre data-language="python">parser.add_option("--clobber", action="store_true", dest="clobber")
parser.add_option("--no-clobber", action="store_false", dest="clobber")
</pre> </li> <li>
<p><code>"append"</code> [relevant: <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a>, <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>, <a class="reference internal" href="#optparse.Option.nargs" title="optparse.Option.nargs"><code>nargs</code></a>, <a class="reference internal" href="#optparse.Option.choices" title="optparse.Option.choices"><code>choices</code></a>]</p> <p>The option must be followed by an argument, which is appended to the list in <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>. If no default value for <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a> is supplied, an empty list is automatically created when <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> first encounters this option on the command-line. If <a class="reference internal" href="#optparse.Option.nargs" title="optparse.Option.nargs"><code>nargs</code></a> &gt; 1, multiple arguments are consumed, and a tuple of length <a class="reference internal" href="#optparse.Option.nargs" title="optparse.Option.nargs"><code>nargs</code></a> is appended to <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>.</p> <p>The defaults for <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a> and <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a> are the same as for the <code>"store"</code> action.</p> <p>Example:</p> <pre data-language="python">parser.add_option("-t", "--tracks", action="append", type="int")
</pre> <p>If <code>-t3</code> is seen on the command-line, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> does the equivalent of:</p> <pre data-language="python">options.tracks = []
options.tracks.append(int("3"))
</pre> <p>If, a little later on, <code>--tracks=4</code> is seen, it does:</p> <pre data-language="python">options.tracks.append(int("4"))
</pre> <p>The <code>append</code> action calls the <code>append</code> method on the current value of the option. This means that any default value specified must have an <code>append</code> method. It also means that if the default value is non-empty, the default elements will be present in the parsed value for the option, with any values from the command line appended after those default values:</p> <pre data-language="python">&gt;&gt;&gt; parser.add_option("--files", action="append", default=['~/.mypkg/defaults'])
&gt;&gt;&gt; opts, args = parser.parse_args(['--files', 'overrides.mypkg'])
&gt;&gt;&gt; opts.files
['~/.mypkg/defaults', 'overrides.mypkg']
</pre> </li> <li>
<p><code>"append_const"</code> [required: <a class="reference internal" href="#optparse.Option.const" title="optparse.Option.const"><code>const</code></a>; relevant: <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>]</p> <p>Like <code>"store_const"</code>, but the value <a class="reference internal" href="#optparse.Option.const" title="optparse.Option.const"><code>const</code></a> is appended to <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>; as with <code>"append"</code>, <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a> defaults to <code>None</code>, and an empty list is automatically created the first time the option is encountered.</p> </li> <li>
<p><code>"count"</code> [relevant: <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>]</p> <p>Increment the integer stored at <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a>. If no default value is supplied, <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a> is set to zero before being incremented the first time.</p> <p>Example:</p> <pre data-language="python">parser.add_option("-v", action="count", dest="verbosity")
</pre> <p>The first time <code>-v</code> is seen on the command line, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> does the equivalent of:</p> <pre data-language="python">options.verbosity = 0
options.verbosity += 1
</pre> <p>Every subsequent occurrence of <code>-v</code> results in</p> <pre data-language="python">options.verbosity += 1
</pre> </li> <li>
<p><code>"callback"</code> [required: <a class="reference internal" href="#optparse.Option.callback" title="optparse.Option.callback"><code>callback</code></a>; relevant: <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a>, <a class="reference internal" href="#optparse.Option.nargs" title="optparse.Option.nargs"><code>nargs</code></a>, <a class="reference internal" href="#optparse.Option.callback_args" title="optparse.Option.callback_args"><code>callback_args</code></a>, <a class="reference internal" href="#optparse.Option.callback_kwargs" title="optparse.Option.callback_kwargs"><code>callback_kwargs</code></a>]</p> <p>Call the function specified by <a class="reference internal" href="#optparse.Option.callback" title="optparse.Option.callback"><code>callback</code></a>, which is called as</p> <pre data-language="python">func(option, opt_str, value, parser, *args, **kwargs)
</pre> <p>See section <a class="reference internal" href="#optparse-option-callbacks"><span class="std std-ref">Option Callbacks</span></a> for more detail.</p> </li> <li>
<p><code>"help"</code></p> <p>Prints a complete help message for all the options in the current option parser. The help message is constructed from the <code>usage</code> string passed to OptionParser’s constructor and the <a class="reference internal" href="#optparse.Option.help" title="optparse.Option.help"><code>help</code></a> string passed to every option.</p> <p>If no <a class="reference internal" href="#optparse.Option.help" title="optparse.Option.help"><code>help</code></a> string is supplied for an option, it will still be listed in the help message. To omit an option entirely, use the special value <code>optparse.SUPPRESS_HELP</code>.</p> <p><a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> automatically adds a <a class="reference internal" href="#optparse.Option.help" title="optparse.Option.help"><code>help</code></a> option to all OptionParsers, so you do not normally need to create one.</p> <p>Example:</p> <pre data-language="python">from optparse import OptionParser, SUPPRESS_HELP

# usually, a help option is added automatically, but that can
# be suppressed using the add_help_option argument
parser = OptionParser(add_help_option=False)

parser.add_option("-h", "--help", action="help")
parser.add_option("-v", action="store_true", dest="verbose",
                  help="Be moderately verbose")
parser.add_option("--file", dest="filename",
                  help="Input file to read data from")
parser.add_option("--secret", help=SUPPRESS_HELP)
</pre> <p>If <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> sees either <code>-h</code> or <code>--help</code> on the command line, it will print something like the following help message to stdout (assuming <code>sys.argv[0]</code> is <code>"foo.py"</code>):</p> <pre data-language="text">Usage: foo.py [options]

Options:
  -h, --help        Show this help message and exit
  -v                Be moderately verbose
  --file=FILENAME   Input file to read data from
</pre> <p>After printing the help message, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> terminates your process with <code>sys.exit(0)</code>.</p> </li> <li>
<p><code>"version"</code></p> <p>Prints the version number supplied to the OptionParser to stdout and exits. The version number is actually formatted and printed by the <code>print_version()</code> method of OptionParser. Generally only relevant if the <code>version</code> argument is supplied to the OptionParser constructor. As with <a class="reference internal" href="#optparse.Option.help" title="optparse.Option.help"><code>help</code></a> options, you will rarely create <code>version</code> options, since <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> automatically adds them when needed.</p> </li> </ul>   <h3 id="optparse-standard-option-types">3.6. Standard option types</h3> <p id="standard-option-types"><a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> has six built-in option types: <code>"string"</code>, <code>"int"</code>, <code>"long"</code>, <code>"choice"</code>, <code>"float"</code> and <code>"complex"</code>. If you need to add new option types, see section <a class="reference internal" href="#optparse-extending-optparse"><span class="std std-ref">Extending optparse</span></a>.</p> <p>Arguments to string options are not checked or converted in any way: the text on the command line is stored in the destination (or passed to the callback) as-is.</p> <p>Integer arguments (type <code>"int"</code> or <code>"long"</code>) are parsed as follows:</p> <ul class="simple"> <li>if the number starts with <code>0x</code>, it is parsed as a hexadecimal number</li> <li>if the number starts with <code>0</code>, it is parsed as an octal number</li> <li>if the number starts with <code>0b</code>, it is parsed as a binary number</li> <li>otherwise, the number is parsed as a decimal number</li> </ul> <p>The conversion is done by calling either <a class="reference internal" href="functions#int" title="int"><code>int()</code></a> or <a class="reference internal" href="functions#long" title="long"><code>long()</code></a> with the appropriate base (2, 8, 10, or 16). If this fails, so will <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>, although with a more useful error message.</p> <p><code>"float"</code> and <code>"complex"</code> option arguments are converted directly with <a class="reference internal" href="functions#float" title="float"><code>float()</code></a> and <a class="reference internal" href="functions#complex" title="complex"><code>complex()</code></a>, with similar error-handling.</p> <p><code>"choice"</code> options are a subtype of <code>"string"</code> options. The <a class="reference internal" href="#optparse.Option.choices" title="optparse.Option.choices"><code>choices</code></a> option attribute (a sequence of strings) defines the set of allowed option arguments. <code>optparse.check_choice()</code> compares user-supplied option arguments against this master list and raises <code>OptionValueError</code> if an invalid string is given.</p>   <h3 id="optparse-parsing-arguments">3.7. Parsing arguments</h3> <p id="parsing-arguments">The whole point of creating and populating an OptionParser is to call its <code>parse_args()</code> method:</p> <pre data-language="python">(options, args) = parser.parse_args(args=None, values=None)
</pre> <p>where the input parameters are</p> <dl class="simple"> <dt>
<code>args</code> </dt>
<dd>
<p>the list of arguments to process (default: <code>sys.argv[1:]</code>)</p> </dd> <dt>
<code>values</code> </dt>
<dd>
<p>an <code>optparse.Values</code> object to store option arguments in (default: a new instance of <code>Values</code>) – if you give an existing object, the option defaults will not be initialized on it</p> </dd> </dl> <p>and the return values are</p> <dl class="simple"> <dt>
<code>options</code> </dt>
<dd>
<p>the same object that was passed in as <code>values</code>, or the optparse.Values instance created by <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a></p> </dd> <dt>
<code>args</code> </dt>
<dd>
<p>the leftover positional arguments after all options have been processed</p> </dd> </dl> <p>The most common usage is to supply neither keyword argument. If you supply <code>values</code>, it will be modified with repeated <a class="reference internal" href="functions#setattr" title="setattr"><code>setattr()</code></a> calls (roughly one for every option argument stored to an option destination) and returned by <code>parse_args()</code>.</p> <p>If <code>parse_args()</code> encounters any errors in the argument list, it calls the OptionParser’s <code>error()</code> method with an appropriate end-user error message. This ultimately terminates your process with an exit status of 2 (the traditional Unix exit status for command-line errors).</p>   <h3 id="optparse-querying-manipulating-option-parser">3.8. Querying and manipulating your option parser</h3> <p id="querying-and-manipulating-your-option-parser">The default behavior of the option parser can be customized slightly, and you can also poke around your option parser and see what’s there. OptionParser provides several methods to help you out:</p> <dl class="method"> <dt id="optparse.OptionParser.disable_interspersed_args">
<code>OptionParser.disable_interspersed_args()</code> </dt> <dd>
<p>Set parsing to stop on the first non-option. For example, if <code>-a</code> and <code>-b</code> are both simple options that take no arguments, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> normally accepts this syntax:</p> <pre data-language="python">prog -a arg1 -b arg2
</pre> <p>and treats it as equivalent to</p> <pre data-language="python">prog -a -b arg1 arg2
</pre> <p>To disable this feature, call <a class="reference internal" href="#optparse.OptionParser.disable_interspersed_args" title="optparse.OptionParser.disable_interspersed_args"><code>disable_interspersed_args()</code></a>. This restores traditional Unix syntax, where option parsing stops with the first non-option argument.</p> <p>Use this if you have a command processor which runs another command which has options of its own and you want to make sure these options don’t get confused. For example, each command might have a different set of options.</p> </dd>
</dl> <dl class="method"> <dt id="optparse.OptionParser.enable_interspersed_args">
<code>OptionParser.enable_interspersed_args()</code> </dt> <dd>
<p>Set parsing to not stop on the first non-option, allowing interspersing switches with command arguments. This is the default behavior.</p> </dd>
</dl> <dl class="method"> <dt id="optparse.OptionParser.get_option">
<code>OptionParser.get_option(opt_str)</code> </dt> <dd>
<p>Returns the Option instance with the option string <em>opt_str</em>, or <code>None</code> if no options have that option string.</p> </dd>
</dl> <dl class="method"> <dt id="optparse.OptionParser.has_option">
<code>OptionParser.has_option(opt_str)</code> </dt> <dd>
<p>Return true if the OptionParser has an option with option string <em>opt_str</em> (e.g., <code>-q</code> or <code>--verbose</code>).</p> </dd>
</dl> <dl class="method"> <dt id="optparse.OptionParser.remove_option">
<code>OptionParser.remove_option(opt_str)</code> </dt> <dd>
<p>If the <a class="reference internal" href="#optparse.OptionParser" title="optparse.OptionParser"><code>OptionParser</code></a> has an option corresponding to <em>opt_str</em>, that option is removed. If that option provided any other option strings, all of those option strings become invalid. If <em>opt_str</em> does not occur in any option belonging to this <a class="reference internal" href="#optparse.OptionParser" title="optparse.OptionParser"><code>OptionParser</code></a>, raises <a class="reference internal" href="exceptions#exceptions.ValueError" title="exceptions.ValueError"><code>ValueError</code></a>.</p> </dd>
</dl>   <h3 id="optparse-conflicts-between-options">3.9. Conflicts between options</h3> <p id="conflicts-between-options">If you’re not careful, it’s easy to define options with conflicting option strings:</p> <pre data-language="python">parser.add_option("-n", "--dry-run", ...)
...
parser.add_option("-n", "--noisy", ...)
</pre> <p>(This is particularly true if you’ve defined your own OptionParser subclass with some standard options.)</p> <p>Every time you add an option, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> checks for conflicts with existing options. If it finds any, it invokes the current conflict-handling mechanism. You can set the conflict-handling mechanism either in the constructor:</p> <pre data-language="python">parser = OptionParser(..., conflict_handler=handler)
</pre> <p>or with a separate call:</p> <pre data-language="python">parser.set_conflict_handler(handler)
</pre> <p>The available conflict handlers are:</p>  <dl class="simple"> <dt>
<code>"error" (default)</code> </dt>
<dd>
<p>assume option conflicts are a programming error and raise <code>OptionConflictError</code></p> </dd> <dt>
<code>"resolve"</code> </dt>
<dd>
<p>resolve option conflicts intelligently (see below)</p> </dd> </dl>  <p>As an example, let’s define an <a class="reference internal" href="#optparse.OptionParser" title="optparse.OptionParser"><code>OptionParser</code></a> that resolves conflicts intelligently and add conflicting options to it:</p> <pre data-language="python">parser = OptionParser(conflict_handler="resolve")
parser.add_option("-n", "--dry-run", ..., help="do no harm")
parser.add_option("-n", "--noisy", ..., help="be noisy")
</pre> <p>At this point, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> detects that a previously-added option is already using the <code>-n</code> option string. Since <code>conflict_handler</code> is <code>"resolve"</code>, it resolves the situation by removing <code>-n</code> from the earlier option’s list of option strings. Now <code>--dry-run</code> is the only way for the user to activate that option. If the user asks for help, the help message will reflect that:</p> <pre data-language="python">Options:
  --dry-run     do no harm
  ...
  -n, --noisy   be noisy
</pre> <p>It’s possible to whittle away the option strings for a previously-added option until there are none left, and the user has no way of invoking that option from the command-line. In that case, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> removes that option completely, so it doesn’t show up in help text or anywhere else. Carrying on with our existing OptionParser:</p> <pre data-language="python">parser.add_option("--dry-run", ..., help="new dry-run option")
</pre> <p>At this point, the original <code>-n</code>/<code>--dry-run</code> option is no longer accessible, so <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> removes it, leaving this help text:</p> <pre data-language="python">Options:
  ...
  -n, --noisy   be noisy
  --dry-run     new dry-run option
</pre>   <h3 id="optparse-cleanup">3.10. Cleanup</h3> <p id="cleanup">OptionParser instances have several cyclic references. This should not be a problem for Python’s garbage collector, but you may wish to break the cyclic references explicitly by calling <code>destroy()</code> on your OptionParser once you are done with it. This is particularly useful in long-running applications where large object graphs are reachable from your OptionParser.</p>   <h3 id="optparse-other-methods">3.11. Other methods</h3> <p id="other-methods">OptionParser supports several other public methods:</p> <dl class="method"> <dt id="optparse.OptionParser.set_usage">
<code>OptionParser.set_usage(usage)</code> </dt> <dd>
<p>Set the usage string according to the rules described above for the <code>usage</code> constructor keyword argument. Passing <code>None</code> sets the default usage string; use <code>optparse.SUPPRESS_USAGE</code> to suppress a usage message.</p> </dd>
</dl> <dl class="method"> <dt id="optparse.OptionParser.print_usage">
<code>OptionParser.print_usage(file=None)</code> </dt> <dd>
<p>Print the usage message for the current program (<code>self.usage</code>) to <em>file</em> (default stdout). Any occurrence of the string <code>%prog</code> in <code>self.usage</code> is replaced with the name of the current program. Does nothing if <code>self.usage</code> is empty or not defined.</p> </dd>
</dl> <dl class="method"> <dt id="optparse.OptionParser.get_usage">
<code>OptionParser.get_usage()</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#optparse.OptionParser.print_usage" title="optparse.OptionParser.print_usage"><code>print_usage()</code></a> but returns the usage string instead of printing it.</p> </dd>
</dl> <dl class="method"> <dt id="optparse.OptionParser.set_defaults">
<code>OptionParser.set_defaults(dest=value, ...)</code> </dt> <dd>
<p>Set default values for several option destinations at once. Using <a class="reference internal" href="#optparse.OptionParser.set_defaults" title="optparse.OptionParser.set_defaults"><code>set_defaults()</code></a> is the preferred way to set default values for options, since multiple options can share the same destination. For example, if several “mode” options all set the same destination, any one of them can set the default, and the last one wins:</p> <pre data-language="python">parser.add_option("--advanced", action="store_const",
                  dest="mode", const="advanced",
                  default="novice")    # overridden below
parser.add_option("--novice", action="store_const",
                  dest="mode", const="novice",
                  default="advanced")  # overrides above setting
</pre> <p>To avoid this confusion, use <a class="reference internal" href="#optparse.OptionParser.set_defaults" title="optparse.OptionParser.set_defaults"><code>set_defaults()</code></a>:</p> <pre data-language="python">parser.set_defaults(mode="advanced")
parser.add_option("--advanced", action="store_const",
                  dest="mode", const="advanced")
parser.add_option("--novice", action="store_const",
                  dest="mode", const="novice")
</pre> </dd>
</dl>    <h2 id="optparse-option-callbacks">4. Option Callbacks</h2> <p id="option-callbacks">When <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>’s built-in actions and types aren’t quite enough for your needs, you have two choices: extend <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> or define a callback option. Extending <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> is more general, but overkill for a lot of simple cases. Quite often a simple callback is all you need.</p> <p>There are two steps to defining a callback option:</p> <ul class="simple"> <li>define the option itself using the <code>"callback"</code> action</li> <li>write the callback; this is a function (or method) that takes at least four arguments, as described below</li> </ul>  <h3 id="optparse-defining-callback-option">4.1. Defining a callback option</h3> <p id="defining-a-callback-option">As always, the easiest way to define a callback option is by using the <a class="reference internal" href="#optparse.OptionParser.add_option" title="optparse.OptionParser.add_option"><code>OptionParser.add_option()</code></a> method. Apart from <a class="reference internal" href="#optparse.Option.action" title="optparse.Option.action"><code>action</code></a>, the only option attribute you must specify is <code>callback</code>, the function to call:</p> <pre data-language="python">parser.add_option("-c", action="callback", callback=my_callback)
</pre> <p><code>callback</code> is a function (or other callable object), so you must have already defined <code>my_callback()</code> when you create this callback option. In this simple case, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> doesn’t even know if <code>-c</code> takes any arguments, which usually means that the option takes no arguments—the mere presence of <code>-c</code> on the command-line is all it needs to know. In some circumstances, though, you might want your callback to consume an arbitrary number of command-line arguments. This is where writing callbacks gets tricky; it’s covered later in this section.</p> <p><a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> always passes four particular arguments to your callback, and it will only pass additional arguments if you specify them via <a class="reference internal" href="#optparse.Option.callback_args" title="optparse.Option.callback_args"><code>callback_args</code></a> and <a class="reference internal" href="#optparse.Option.callback_kwargs" title="optparse.Option.callback_kwargs"><code>callback_kwargs</code></a>. Thus, the minimal callback function signature is:</p> <pre data-language="python">def my_callback(option, opt, value, parser):
</pre> <p>The four arguments to a callback are described below.</p> <p>There are several other option attributes that you can supply when you define a callback option:</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a>
</dt>
<dd>
<p>has its usual meaning: as with the <code>"store"</code> or <code>"append"</code> actions, it instructs <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> to consume one argument and convert it to <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a>. Rather than storing the converted value(s) anywhere, though, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> passes it to your callback function.</p> </dd> <dt>
 <a class="reference internal" href="#optparse.Option.nargs" title="optparse.Option.nargs"><code>nargs</code></a>
</dt>
<dd>
<p>also has its usual meaning: if it is supplied and &gt; 1, <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> will consume <a class="reference internal" href="#optparse.Option.nargs" title="optparse.Option.nargs"><code>nargs</code></a> arguments, each of which must be convertible to <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a>. It then passes a tuple of converted values to your callback.</p> </dd> <dt>
 <a class="reference internal" href="#optparse.Option.callback_args" title="optparse.Option.callback_args"><code>callback_args</code></a>
</dt>
<dd>
<p>a tuple of extra positional arguments to pass to the callback</p> </dd> <dt>
 <a class="reference internal" href="#optparse.Option.callback_kwargs" title="optparse.Option.callback_kwargs"><code>callback_kwargs</code></a>
</dt>
<dd>
<p>a dictionary of extra keyword arguments to pass to the callback</p> </dd> </dl>   <h3 id="optparse-how-callbacks-called">4.2. How callbacks are called</h3> <p id="how-callbacks-are-called">All callbacks are called as follows:</p> <pre data-language="python">func(option, opt_str, value, parser, *args, **kwargs)
</pre> <p>where</p> <dl> <dt>
<code>option</code> </dt>
<dd>
<p>is the Option instance that’s calling the callback</p> </dd> <dt>
<code>opt_str</code> </dt>
<dd>
<p>is the option string seen on the command-line that’s triggering the callback. (If an abbreviated long option was used, <code>opt_str</code> will be the full, canonical option string—e.g. if the user puts <code>--foo</code> on the command-line as an abbreviation for <code>--foobar</code>, then <code>opt_str</code> will be <code>"--foobar"</code>.)</p> </dd> <dt>
<code>value</code> </dt>
<dd>
<p>is the argument to this option seen on the command-line. <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> will only expect an argument if <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a> is set; the type of <code>value</code> will be the type implied by the option’s type. If <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a> for this option is <code>None</code> (no argument expected), then <code>value</code> will be <code>None</code>. If <a class="reference internal" href="#optparse.Option.nargs" title="optparse.Option.nargs"><code>nargs</code></a> &gt; 1, <code>value</code> will be a tuple of values of the appropriate type.</p> </dd> <dt>
<code>parser</code> </dt>
<dd>
<p>is the OptionParser instance driving the whole thing, mainly useful because you can access some other interesting data through its instance attributes:</p> <dl class="simple"> <dt>
<code>parser.largs</code> </dt>
<dd>
<p>the current list of leftover arguments, ie. arguments that have been consumed but are neither options nor option arguments. Feel free to modify <code>parser.largs</code>, e.g. by adding more arguments to it. (This list will become <code>args</code>, the second return value of <code>parse_args()</code>.)</p> </dd> <dt>
<code>parser.rargs</code> </dt>
<dd>
<p>the current list of remaining arguments, ie. with <code>opt_str</code> and <code>value</code> (if applicable) removed, and only the arguments following them still there. Feel free to modify <code>parser.rargs</code>, e.g. by consuming more arguments.</p> </dd> <dt>
<code>parser.values</code> </dt>
<dd>
<p>the object where option values are by default stored (an instance of optparse.OptionValues). This lets callbacks use the same mechanism as the rest of <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> for storing option values; you don’t need to mess around with globals or closures. You can also access or modify the value(s) of any options already encountered on the command-line.</p> </dd> </dl> </dd> <dt>
<code>args</code> </dt>
<dd>
<p>is a tuple of arbitrary positional arguments supplied via the <a class="reference internal" href="#optparse.Option.callback_args" title="optparse.Option.callback_args"><code>callback_args</code></a> option attribute.</p> </dd> <dt>
<code>kwargs</code> </dt>
<dd>
<p>is a dictionary of arbitrary keyword arguments supplied via <a class="reference internal" href="#optparse.Option.callback_kwargs" title="optparse.Option.callback_kwargs"><code>callback_kwargs</code></a>.</p> </dd> </dl>   <h3 id="optparse-raising-errors-in-callback">4.3. Raising errors in a callback</h3> <p id="raising-errors-in-a-callback">The callback function should raise <code>OptionValueError</code> if there are any problems with the option or its argument(s). <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> catches this and terminates the program, printing the error message you supply to stderr. Your message should be clear, concise, accurate, and mention the option at fault. Otherwise, the user will have a hard time figuring out what they did wrong.</p>   <h3 id="optparse-callback-example-1">4.4. Callback example 1: trivial callback</h3> <p id="callback-example-1-trivial-callback">Here’s an example of a callback option that takes no arguments, and simply records that the option was seen:</p> <pre data-language="python">def record_foo_seen(option, opt_str, value, parser):
    parser.values.saw_foo = True

parser.add_option("--foo", action="callback", callback=record_foo_seen)
</pre> <p>Of course, you could do that with the <code>"store_true"</code> action.</p>   <h3 id="optparse-callback-example-2">4.5. Callback example 2: check option order</h3> <p id="callback-example-2-check-option-order">Here’s a slightly more interesting example: record the fact that <code>-a</code> is seen, but blow up if it comes after <code>-b</code> in the command-line.</p> <pre data-language="python">def check_order(option, opt_str, value, parser):
    if parser.values.b:
        raise OptionValueError("can't use -a after -b")
    parser.values.a = 1
...
parser.add_option("-a", action="callback", callback=check_order)
parser.add_option("-b", action="store_true", dest="b")
</pre>   <h3 id="optparse-callback-example-3">4.6. Callback example 3: check option order (generalized)</h3> <p id="callback-example-3-check-option-order-generalized">If you want to re-use this callback for several similar options (set a flag, but blow up if <code>-b</code> has already been seen), it needs a bit of work: the error message and the flag that it sets must be generalized.</p> <pre data-language="python">def check_order(option, opt_str, value, parser):
    if parser.values.b:
        raise OptionValueError("can't use %s after -b" % opt_str)
    setattr(parser.values, option.dest, 1)
...
parser.add_option("-a", action="callback", callback=check_order, dest='a')
parser.add_option("-b", action="store_true", dest="b")
parser.add_option("-c", action="callback", callback=check_order, dest='c')
</pre>   <h3 id="optparse-callback-example-4">4.7. Callback example 4: check arbitrary condition</h3> <p id="callback-example-4-check-arbitrary-condition">Of course, you could put any condition in there—you’re not limited to checking the values of already-defined options. For example, if you have options that should not be called when the moon is full, all you have to do is this:</p> <pre data-language="python">def check_moon(option, opt_str, value, parser):
    if is_moon_full():
        raise OptionValueError("%s option invalid when moon is full"
                               % opt_str)
    setattr(parser.values, option.dest, 1)
...
parser.add_option("--foo",
                  action="callback", callback=check_moon, dest="foo")
</pre> <p>(The definition of <code>is_moon_full()</code> is left as an exercise for the reader.)</p>   <h3 id="optparse-callback-example-5">4.8. Callback example 5: fixed arguments</h3> <p id="callback-example-5-fixed-arguments">Things get slightly more interesting when you define callback options that take a fixed number of arguments. Specifying that a callback option takes arguments is similar to defining a <code>"store"</code> or <code>"append"</code> option: if you define <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a>, then the option takes one argument that must be convertible to that type; if you further define <a class="reference internal" href="#optparse.Option.nargs" title="optparse.Option.nargs"><code>nargs</code></a>, then the option takes <a class="reference internal" href="#optparse.Option.nargs" title="optparse.Option.nargs"><code>nargs</code></a> arguments.</p> <p>Here’s an example that just emulates the standard <code>"store"</code> action:</p> <pre data-language="python">def store_value(option, opt_str, value, parser):
    setattr(parser.values, option.dest, value)
...
parser.add_option("--foo",
                  action="callback", callback=store_value,
                  type="int", nargs=3, dest="foo")
</pre> <p>Note that <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> takes care of consuming 3 arguments and converting them to integers for you; all you have to do is store them. (Or whatever; obviously you don’t need a callback for this example.)</p>   <h3 id="optparse-callback-example-6">4.9. Callback example 6: variable arguments</h3> <p id="callback-example-6-variable-arguments">Things get hairy when you want an option to take a variable number of arguments. For this case, you must write a callback, as <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> doesn’t provide any built-in capabilities for it. And you have to deal with certain intricacies of conventional Unix command-line parsing that <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> normally handles for you. In particular, callbacks should implement the conventional rules for bare <code>--</code> and <code>-</code> arguments:</p> <ul class="simple"> <li>either <code>--</code> or <code>-</code> can be option arguments</li> <li>bare <code>--</code> (if not the argument to some option): halt command-line processing and discard the <code>--</code>
</li> <li>bare <code>-</code> (if not the argument to some option): halt command-line processing but keep the <code>-</code> (append it to <code>parser.largs</code>)</li> </ul> <p>If you want an option that takes a variable number of arguments, there are several subtle, tricky issues to worry about. The exact implementation you choose will be based on which trade-offs you’re willing to make for your application (which is why <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> doesn’t support this sort of thing directly).</p> <p>Nevertheless, here’s a stab at a callback for an option with variable arguments:</p> <pre data-language="python">def vararg_callback(option, opt_str, value, parser):
    assert value is None
    value = []

    def floatable(str):
        try:
            float(str)
            return True
        except ValueError:
            return False

    for arg in parser.rargs:
        # stop on --foo like options
        if arg[:2] == "--" and len(arg) &gt; 2:
            break
        # stop on -a, but not on -3 or -3.0
        if arg[:1] == "-" and len(arg) &gt; 1 and not floatable(arg):
            break
        value.append(arg)

    del parser.rargs[:len(value)]
    setattr(parser.values, option.dest, value)

...
parser.add_option("-c", "--callback", dest="vararg_attr",
                  action="callback", callback=vararg_callback)
</pre>    <h2 id="optparse-extending-optparse">5. Extending optparse</h2> <p id="extending-optparse">Since the two major controlling factors in how <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> interprets command-line options are the action and type of each option, the most likely direction of extension is to add new actions and new types.</p>  <h3 id="optparse-adding-new-types">5.1. Adding new types</h3> <p id="adding-new-types">To add new types, you need to define your own subclass of <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>’s <code>Option</code> class. This class has a couple of attributes that define <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>’s types: <a class="reference internal" href="#optparse.Option.TYPES" title="optparse.Option.TYPES"><code>TYPES</code></a> and <a class="reference internal" href="#optparse.Option.TYPE_CHECKER" title="optparse.Option.TYPE_CHECKER"><code>TYPE_CHECKER</code></a>.</p> <dl class="attribute"> <dt id="optparse.Option.TYPES">
<code>Option.TYPES</code> </dt> <dd>
<p>A tuple of type names; in your subclass, simply define a new tuple <a class="reference internal" href="#optparse.Option.TYPES" title="optparse.Option.TYPES"><code>TYPES</code></a> that builds on the standard one.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.TYPE_CHECKER">
<code>Option.TYPE_CHECKER</code> </dt> <dd>
<p>A dictionary mapping type names to type-checking functions. A type-checking function has the following signature:</p> <pre data-language="python">def check_mytype(option, opt, value)
</pre> <p>where <code>option</code> is an <code>Option</code> instance, <code>opt</code> is an option string (e.g., <code>-f</code>), and <code>value</code> is the string from the command line that must be checked and converted to your desired type. <code>check_mytype()</code> should return an object of the hypothetical type <code>mytype</code>. The value returned by a type-checking function will wind up in the OptionValues instance returned by <code>OptionParser.parse_args()</code>, or be passed to a callback as the <code>value</code> parameter.</p> <p>Your type-checking function should raise <code>OptionValueError</code> if it encounters any problems. <code>OptionValueError</code> takes a single string argument, which is passed as-is to <a class="reference internal" href="#optparse.OptionParser" title="optparse.OptionParser"><code>OptionParser</code></a>’s <code>error()</code> method, which in turn prepends the program name and the string <code>"error:"</code> and prints everything to stderr before terminating the process.</p> </dd>
</dl> <p>Here’s a silly example that demonstrates adding a <code>"complex"</code> option type to parse Python-style complex numbers on the command line. (This is even sillier than it used to be, because <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> 1.3 added built-in support for complex numbers, but never mind.)</p> <p>First, the necessary imports:</p> <pre data-language="python">from copy import copy
from optparse import Option, OptionValueError
</pre> <p>You need to define your type-checker first, since it’s referred to later (in the <a class="reference internal" href="#optparse.Option.TYPE_CHECKER" title="optparse.Option.TYPE_CHECKER"><code>TYPE_CHECKER</code></a> class attribute of your Option subclass):</p> <pre data-language="python">def check_complex(option, opt, value):
    try:
        return complex(value)
    except ValueError:
        raise OptionValueError(
            "option %s: invalid complex value: %r" % (opt, value))
</pre> <p>Finally, the Option subclass:</p> <pre data-language="python">class MyOption (Option):
    TYPES = Option.TYPES + ("complex",)
    TYPE_CHECKER = copy(Option.TYPE_CHECKER)
    TYPE_CHECKER["complex"] = check_complex
</pre> <p>(If we didn’t make a <a class="reference internal" href="copy#module-copy" title="copy: Shallow and deep copy operations."><code>copy()</code></a> of <a class="reference internal" href="#optparse.Option.TYPE_CHECKER" title="optparse.Option.TYPE_CHECKER"><code>Option.TYPE_CHECKER</code></a>, we would end up modifying the <a class="reference internal" href="#optparse.Option.TYPE_CHECKER" title="optparse.Option.TYPE_CHECKER"><code>TYPE_CHECKER</code></a> attribute of <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>’s Option class. This being Python, nothing stops you from doing that except good manners and common sense.)</p> <p>That’s it! Now you can write a script that uses the new option type just like any other <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a>-based script, except you have to instruct your OptionParser to use MyOption instead of Option:</p> <pre data-language="python">parser = OptionParser(option_class=MyOption)
parser.add_option("-c", type="complex")
</pre> <p>Alternately, you can build your own option list and pass it to OptionParser; if you don’t use <code>add_option()</code> in the above way, you don’t need to tell OptionParser which option class to use:</p> <pre data-language="python">option_list = [MyOption("-c", action="store", type="complex", dest="c")]
parser = OptionParser(option_list=option_list)
</pre>   <h3 id="optparse-adding-new-actions">5.2. Adding new actions</h3> <p id="adding-new-actions">Adding new actions is a bit trickier, because you have to understand that <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> has a couple of classifications for actions:</p> <dl class="simple"> <dt>“store” actions</dt>
<dd>
<p>actions that result in <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> storing a value to an attribute of the current OptionValues instance; these options require a <a class="reference internal" href="#optparse.Option.dest" title="optparse.Option.dest"><code>dest</code></a> attribute to be supplied to the Option constructor.</p> </dd> <dt>“typed” actions</dt>
<dd>
<p>actions that take a value from the command line and expect it to be of a certain type; or rather, a string that can be converted to a certain type. These options require a <a class="reference internal" href="#optparse.Option.type" title="optparse.Option.type"><code>type</code></a> attribute to the Option constructor.</p> </dd> </dl> <p>These are overlapping sets: some default “store” actions are <code>"store"</code>, <code>"store_const"</code>, <code>"append"</code>, and <code>"count"</code>, while the default “typed” actions are <code>"store"</code>, <code>"append"</code>, and <code>"callback"</code>.</p> <p>When you add an action, you need to categorize it by listing it in at least one of the following class attributes of Option (all are lists of strings):</p> <dl class="attribute"> <dt id="optparse.Option.ACTIONS">
<code>Option.ACTIONS</code> </dt> <dd>
<p>All actions must be listed in ACTIONS.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.STORE_ACTIONS">
<code>Option.STORE_ACTIONS</code> </dt> <dd>
<p>“store” actions are additionally listed here.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.TYPED_ACTIONS">
<code>Option.TYPED_ACTIONS</code> </dt> <dd>
<p>“typed” actions are additionally listed here.</p> </dd>
</dl> <dl class="attribute"> <dt id="optparse.Option.ALWAYS_TYPED_ACTIONS">
<code>Option.ALWAYS_TYPED_ACTIONS</code> </dt> <dd>
<p>Actions that always take a type (i.e. whose options always take a value) are additionally listed here. The only effect of this is that <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> assigns the default type, <code>"string"</code>, to options with no explicit type whose action is listed in <a class="reference internal" href="#optparse.Option.ALWAYS_TYPED_ACTIONS" title="optparse.Option.ALWAYS_TYPED_ACTIONS"><code>ALWAYS_TYPED_ACTIONS</code></a>.</p> </dd>
</dl> <p>In order to actually implement your new action, you must override Option’s <code>take_action()</code> method and add a case that recognizes your action.</p> <p>For example, let’s add an <code>"extend"</code> action. This is similar to the standard <code>"append"</code> action, but instead of taking a single value from the command-line and appending it to an existing list, <code>"extend"</code> will take multiple values in a single comma-delimited string, and extend an existing list with them. That is, if <code>--names</code> is an <code>"extend"</code> option of type <code>"string"</code>, the command line</p> <pre data-language="python">--names=foo,bar --names blah --names ding,dong
</pre> <p>would result in a list</p> <pre data-language="python">["foo", "bar", "blah", "ding", "dong"]
</pre> <p>Again we define a subclass of Option:</p> <pre data-language="python">class MyOption(Option):

    ACTIONS = Option.ACTIONS + ("extend",)
    STORE_ACTIONS = Option.STORE_ACTIONS + ("extend",)
    TYPED_ACTIONS = Option.TYPED_ACTIONS + ("extend",)
    ALWAYS_TYPED_ACTIONS = Option.ALWAYS_TYPED_ACTIONS + ("extend",)

    def take_action(self, action, dest, opt, value, values, parser):
        if action == "extend":
            lvalue = value.split(",")
            values.ensure_value(dest, []).extend(lvalue)
        else:
            Option.take_action(
                self, action, dest, opt, value, values, parser)
</pre> <p>Features of note:</p> <ul> <li>
<code>"extend"</code> both expects a value on the command-line and stores that value somewhere, so it goes in both <a class="reference internal" href="#optparse.Option.STORE_ACTIONS" title="optparse.Option.STORE_ACTIONS"><code>STORE_ACTIONS</code></a> and <a class="reference internal" href="#optparse.Option.TYPED_ACTIONS" title="optparse.Option.TYPED_ACTIONS"><code>TYPED_ACTIONS</code></a>.</li> <li>to ensure that <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> assigns the default type of <code>"string"</code> to <code>"extend"</code> actions, we put the <code>"extend"</code> action in <a class="reference internal" href="#optparse.Option.ALWAYS_TYPED_ACTIONS" title="optparse.Option.ALWAYS_TYPED_ACTIONS"><code>ALWAYS_TYPED_ACTIONS</code></a> as well.</li> <li>
<code>MyOption.take_action()</code> implements just this one new action, and passes control back to <code>Option.take_action()</code> for the standard <a class="reference internal" href="#module-optparse" title="optparse: Command-line option parsing library. (deprecated)"><code>optparse</code></a> actions.</li> <li>
<p><code>values</code> is an instance of the optparse_parser.Values class, which provides the very useful <code>ensure_value()</code> method. <code>ensure_value()</code> is essentially <a class="reference internal" href="functions#getattr" title="getattr"><code>getattr()</code></a> with a safety valve; it is called as</p> <pre data-language="python">values.ensure_value(attr, value)
</pre> <p>If the <code>attr</code> attribute of <code>values</code> doesn’t exist or is <code>None</code>, then ensure_value() first sets it to <code>value</code>, and then returns ‘value. This is very handy for actions like <code>"extend"</code>, <code>"append"</code>, and <code>"count"</code>, all of which accumulate data in a variable and expect that variable to be of a certain type (a list for the first two, an integer for the latter). Using <code>ensure_value()</code> means that scripts using your action don’t have to worry about setting a default value for the option destinations in question; they can just leave the default as <code>None</code> and <code>ensure_value()</code> will take care of getting it right when it’s needed.</p> </li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/optparse.html" class="_attribution-link">https://docs.python.org/2.7/library/optparse.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
