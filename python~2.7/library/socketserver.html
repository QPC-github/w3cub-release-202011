
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>SocketServer - Python 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" Note ">
  <meta name="keywords" content="socketserver, —, framework, for, network, servers, python, python~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/python~2.7/library/socketserver.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/python~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~2.7/" class="_nav-link" title="" style="margin-left:0;">Python 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _python">
				
				
<h1 id="socketserver-a-framework-for-network-servers"> SocketServer — A framework for network servers</h1> <div class="admonition note" id="module-SocketServer"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="#module-SocketServer" title="SocketServer: A framework for network servers."><code>SocketServer</code></a> module has been renamed to <code>socketserver</code> in Python 3. The <a class="reference internal" href="https://docs.python.org/2.7/glossary.html#term-2to3"><span class="xref std std-term">2to3</span></a> tool will automatically adapt imports when converting your sources to Python 3.</p> </div> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/2.7/Lib/SocketServer.py">Lib/SocketServer.py</a></p>  <p>The <a class="reference internal" href="#module-SocketServer" title="SocketServer: A framework for network servers."><code>SocketServer</code></a> module simplifies the task of writing network servers.</p> <p>There are four basic concrete server classes:</p> <dl class="class"> <dt id="SocketServer.TCPServer">
<code>class SocketServer.TCPServer(server_address, RequestHandlerClass, bind_and_activate=True)</code> </dt> <dd>
<p>This uses the Internet TCP protocol, which provides for continuous streams of data between the client and server. If <em>bind_and_activate</em> is true, the constructor automatically attempts to invoke <a class="reference internal" href="#SocketServer.BaseServer.server_bind" title="SocketServer.BaseServer.server_bind"><code>server_bind()</code></a> and <a class="reference internal" href="#SocketServer.BaseServer.server_activate" title="SocketServer.BaseServer.server_activate"><code>server_activate()</code></a>. The other parameters are passed to the <a class="reference internal" href="#SocketServer.BaseServer" title="SocketServer.BaseServer"><code>BaseServer</code></a> base class.</p> </dd>
</dl> <dl class="class"> <dt id="SocketServer.UDPServer">
<code>class SocketServer.UDPServer(server_address, RequestHandlerClass, bind_and_activate=True)</code> </dt> <dd>
<p>This uses datagrams, which are discrete packets of information that may arrive out of order or be lost while in transit. The parameters are the same as for <a class="reference internal" href="#SocketServer.TCPServer" title="SocketServer.TCPServer"><code>TCPServer</code></a>.</p> </dd>
</dl> <dl class="class"> <dt id="SocketServer.UnixStreamServer">
<code>class SocketServer.UnixStreamServer(server_address, RequestHandlerClass, bind_and_activate=True)</code> </dt> <dt id="SocketServer.UnixDatagramServer">
<code>class SocketServer.UnixDatagramServer(server_address, RequestHandlerClass, bind_and_activate=True)</code> </dt> <dd>
<p>These more infrequently used classes are similar to the TCP and UDP classes, but use Unix domain sockets; they’re not available on non-Unix platforms. The parameters are the same as for <a class="reference internal" href="#SocketServer.TCPServer" title="SocketServer.TCPServer"><code>TCPServer</code></a>.</p> </dd>
</dl> <p>These four classes process requests <em class="dfn">synchronously</em>; each request must be completed before the next request can be started. This isn’t suitable if each request takes a long time to complete, because it requires a lot of computation, or because it returns a lot of data which the client is slow to process. The solution is to create a separate process or thread to handle each request; the <a class="reference internal" href="#SocketServer.ForkingMixIn" title="SocketServer.ForkingMixIn"><code>ForkingMixIn</code></a> and <a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code>ThreadingMixIn</code></a> mix-in classes can be used to support asynchronous behaviour.</p> <p>Creating a server requires several steps. First, you must create a request handler class by subclassing the <a class="reference internal" href="#SocketServer.BaseRequestHandler" title="SocketServer.BaseRequestHandler"><code>BaseRequestHandler</code></a> class and overriding its <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code>handle()</code></a> method; this method will process incoming requests. Second, you must instantiate one of the server classes, passing it the server’s address and the request handler class. Then call the <a class="reference internal" href="#SocketServer.BaseServer.handle_request" title="SocketServer.BaseServer.handle_request"><code>handle_request()</code></a> or <a class="reference internal" href="#SocketServer.BaseServer.serve_forever" title="SocketServer.BaseServer.serve_forever"><code>serve_forever()</code></a> method of the server object to process one or many requests. Finally, call <a class="reference internal" href="#SocketServer.BaseServer.server_close" title="SocketServer.BaseServer.server_close"><code>server_close()</code></a> to close the socket.</p> <p>When inheriting from <a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code>ThreadingMixIn</code></a> for threaded connection behavior, you should explicitly declare how you want your threads to behave on an abrupt shutdown. The <a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code>ThreadingMixIn</code></a> class defines an attribute <em>daemon_threads</em>, which indicates whether or not the server should wait for thread termination. You should set the flag explicitly if you would like threads to behave autonomously; the default is <a class="reference internal" href="constants#False" title="False"><code>False</code></a>, meaning that Python will not exit until all threads created by <a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code>ThreadingMixIn</code></a> have exited.</p> <p>Server classes have the same external methods and attributes, no matter what network protocol they use.</p>  <h2 id="server-creation-notes">1. Server Creation Notes</h2> <p>There are five classes in an inheritance diagram, four of which represent synchronous servers of four types:</p> <pre data-language="python">+------------+
| BaseServer |
+------------+
      |
      v
+-----------+        +------------------+
| TCPServer |-------&gt;| UnixStreamServer |
+-----------+        +------------------+
      |
      v
+-----------+        +--------------------+
| UDPServer |-------&gt;| UnixDatagramServer |
+-----------+        +--------------------+
</pre> <p>Note that <a class="reference internal" href="#SocketServer.UnixDatagramServer" title="SocketServer.UnixDatagramServer"><code>UnixDatagramServer</code></a> derives from <a class="reference internal" href="#SocketServer.UDPServer" title="SocketServer.UDPServer"><code>UDPServer</code></a>, not from <a class="reference internal" href="#SocketServer.UnixStreamServer" title="SocketServer.UnixStreamServer"><code>UnixStreamServer</code></a> — the only difference between an IP and a Unix stream server is the address family, which is simply repeated in both Unix server classes.</p> <dl class="class"> <dt id="SocketServer.ForkingMixIn">
<code>class SocketServer.ForkingMixIn</code> </dt> <dt id="SocketServer.ThreadingMixIn">
<code>class SocketServer.ThreadingMixIn</code> </dt> <dd>
<p>Forking and threading versions of each type of server can be created using these mix-in classes. For instance, <a class="reference internal" href="#SocketServer.ThreadingUDPServer" title="SocketServer.ThreadingUDPServer"><code>ThreadingUDPServer</code></a> is created as follows:</p> <pre data-language="python">class ThreadingUDPServer(ThreadingMixIn, UDPServer):
    pass
</pre> <p>The mix-in class comes first, since it overrides a method defined in <a class="reference internal" href="#SocketServer.UDPServer" title="SocketServer.UDPServer"><code>UDPServer</code></a>. Setting the various attributes also changes the behavior of the underlying server mechanism.</p> <p><a class="reference internal" href="#SocketServer.ForkingMixIn" title="SocketServer.ForkingMixIn"><code>ForkingMixIn</code></a> and the Forking classes mentioned below are only available on POSIX platforms that support <a class="reference internal" href="os#os.fork" title="os.fork"><code>fork()</code></a>.</p> </dd>
</dl> <dl class="class"> <dt id="SocketServer.ForkingTCPServer">
<code>class SocketServer.ForkingTCPServer</code> </dt> <dt id="SocketServer.ForkingUDPServer">
<code>class SocketServer.ForkingUDPServer</code> </dt> <dt id="SocketServer.ThreadingTCPServer">
<code>class SocketServer.ThreadingTCPServer</code> </dt> <dt id="SocketServer.ThreadingUDPServer">
<code>class SocketServer.ThreadingUDPServer</code> </dt> <dd>
<p>These classes are pre-defined using the mix-in classes.</p> </dd>
</dl> <p>To implement a service, you must derive a class from <a class="reference internal" href="#SocketServer.BaseRequestHandler" title="SocketServer.BaseRequestHandler"><code>BaseRequestHandler</code></a> and redefine its <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code>handle()</code></a> method. You can then run various versions of the service by combining one of the server classes with your request handler class. The request handler class must be different for datagram or stream services. This can be hidden by using the handler subclasses <a class="reference internal" href="#SocketServer.StreamRequestHandler" title="SocketServer.StreamRequestHandler"><code>StreamRequestHandler</code></a> or <a class="reference internal" href="#SocketServer.DatagramRequestHandler" title="SocketServer.DatagramRequestHandler"><code>DatagramRequestHandler</code></a>.</p> <p>Of course, you still have to use your head! For instance, it makes no sense to use a forking server if the service contains state in memory that can be modified by different requests, since the modifications in the child process would never reach the initial state kept in the parent process and passed to each child. In this case, you can use a threading server, but you will probably have to use locks to protect the integrity of the shared data.</p> <p>On the other hand, if you are building an HTTP server where all data is stored externally (for instance, in the file system), a synchronous class will essentially render the service “deaf” while one request is being handled – which may be for a very long time if a client is slow to receive all the data it has requested. Here a threading or forking server is appropriate.</p> <p>In some cases, it may be appropriate to process part of a request synchronously, but to finish processing in a forked child depending on the request data. This can be implemented by using a synchronous server and doing an explicit fork in the request handler class <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code>handle()</code></a> method.</p> <p>Another approach to handling multiple simultaneous requests in an environment that supports neither threads nor <a class="reference internal" href="os#os.fork" title="os.fork"><code>fork()</code></a> (or where these are too expensive or inappropriate for the service) is to maintain an explicit table of partially finished requests and to use <a class="reference internal" href="select#select.select" title="select.select"><code>select()</code></a> to decide which request to work on next (or whether to handle a new incoming request). This is particularly important for stream services where each client can potentially be connected for a long time (if threads or subprocesses cannot be used). See <a class="reference internal" href="asyncore#module-asyncore" title="asyncore: A base class for developing asynchronous socket handling services."><code>asyncore</code></a> for another way to manage this.</p>   <h2 id="server-objects">2. Server Objects</h2> <dl class="class"> <dt id="SocketServer.BaseServer">
<code>class SocketServer.BaseServer(server_address, RequestHandlerClass)</code> </dt> <dd>
<p>This is the superclass of all Server objects in the module. It defines the interface, given below, but does not implement most of the methods, which is done in subclasses. The two parameters are stored in the respective <a class="reference internal" href="#SocketServer.BaseServer.server_address" title="SocketServer.BaseServer.server_address"><code>server_address</code></a> and <a class="reference internal" href="#SocketServer.BaseServer.RequestHandlerClass" title="SocketServer.BaseServer.RequestHandlerClass"><code>RequestHandlerClass</code></a> attributes.</p> <dl class="method"> <dt id="SocketServer.BaseServer.fileno">
<code>fileno()</code> </dt> <dd>
<p>Return an integer file descriptor for the socket on which the server is listening. This function is most commonly passed to <a class="reference internal" href="select#select.select" title="select.select"><code>select.select()</code></a>, to allow monitoring multiple servers in the same process.</p> </dd>
</dl> <dl class="method"> <dt id="SocketServer.BaseServer.handle_request">
<code>handle_request()</code> </dt> <dd>
<p>Process a single request. This function calls the following methods in order: <a class="reference internal" href="#SocketServer.BaseServer.get_request" title="SocketServer.BaseServer.get_request"><code>get_request()</code></a>, <a class="reference internal" href="#SocketServer.BaseServer.verify_request" title="SocketServer.BaseServer.verify_request"><code>verify_request()</code></a>, and <a class="reference internal" href="#SocketServer.BaseServer.process_request" title="SocketServer.BaseServer.process_request"><code>process_request()</code></a>. If the user-provided <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code>handle()</code></a> method of the handler class raises an exception, the server’s <a class="reference internal" href="#SocketServer.BaseServer.handle_error" title="SocketServer.BaseServer.handle_error"><code>handle_error()</code></a> method will be called. If no request is received within <a class="reference internal" href="#SocketServer.BaseServer.timeout" title="SocketServer.BaseServer.timeout"><code>timeout</code></a> seconds, <a class="reference internal" href="#SocketServer.BaseServer.handle_timeout" title="SocketServer.BaseServer.handle_timeout"><code>handle_timeout()</code></a> will be called and <a class="reference internal" href="#SocketServer.BaseServer.handle_request" title="SocketServer.BaseServer.handle_request"><code>handle_request()</code></a> will return.</p> </dd>
</dl> <dl class="method"> <dt id="SocketServer.BaseServer.serve_forever">
<code>serve_forever(poll_interval=0.5)</code> </dt> <dd>
<p>Handle requests until an explicit <a class="reference internal" href="#SocketServer.BaseServer.shutdown" title="SocketServer.BaseServer.shutdown"><code>shutdown()</code></a> request. Poll for shutdown every <em>poll_interval</em> seconds. Ignores the <a class="reference internal" href="#SocketServer.BaseServer.timeout" title="SocketServer.BaseServer.timeout"><code>timeout</code></a> attribute. If you need to do periodic tasks, do them in another thread.</p> </dd>
</dl> <dl class="method"> <dt id="SocketServer.BaseServer.shutdown">
<code>shutdown()</code> </dt> <dd>
<p>Tell the <a class="reference internal" href="#SocketServer.BaseServer.serve_forever" title="SocketServer.BaseServer.serve_forever"><code>serve_forever()</code></a> loop to stop and wait until it does.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="SocketServer.BaseServer.server_close">
<code>server_close()</code> </dt> <dd>
<p>Clean up the server. May be overridden.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </dd>
</dl> <dl class="attribute"> <dt id="SocketServer.BaseServer.address_family">
<code>address_family</code> </dt> <dd>
<p>The family of protocols to which the server’s socket belongs. Common examples are <a class="reference internal" href="socket#socket.AF_INET" title="socket.AF_INET"><code>socket.AF_INET</code></a> and <a class="reference internal" href="socket#socket.AF_UNIX" title="socket.AF_UNIX"><code>socket.AF_UNIX</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="SocketServer.BaseServer.RequestHandlerClass">
<code>RequestHandlerClass</code> </dt> <dd>
<p>The user-provided request handler class; an instance of this class is created for each request.</p> </dd>
</dl> <dl class="attribute"> <dt id="SocketServer.BaseServer.server_address">
<code>server_address</code> </dt> <dd>
<p>The address on which the server is listening. The format of addresses varies depending on the protocol family; see the documentation for the <a class="reference internal" href="socket#module-socket" title="socket: Low-level networking interface."><code>socket</code></a> module for details. For Internet protocols, this is a tuple containing a string giving the address, and an integer port number: <code>('127.0.0.1', 80)</code>, for example.</p> </dd>
</dl> <dl class="attribute"> <dt id="SocketServer.BaseServer.socket">
<code>socket</code> </dt> <dd>
<p>The socket object on which the server will listen for incoming requests.</p> </dd>
</dl> <p>The server classes support the following class variables:</p> <dl class="attribute"> <dt id="SocketServer.BaseServer.allow_reuse_address">
<code>allow_reuse_address</code> </dt> <dd>
<p>Whether the server will allow the reuse of an address. This defaults to <a class="reference internal" href="constants#False" title="False"><code>False</code></a>, and can be set in subclasses to change the policy.</p> </dd>
</dl> <dl class="attribute"> <dt id="SocketServer.BaseServer.request_queue_size">
<code>request_queue_size</code> </dt> <dd>
<p>The size of the request queue. If it takes a long time to process a single request, any requests that arrive while the server is busy are placed into a queue, up to <a class="reference internal" href="#SocketServer.BaseServer.request_queue_size" title="SocketServer.BaseServer.request_queue_size"><code>request_queue_size</code></a> requests. Once the queue is full, further requests from clients will get a “Connection denied” error. The default value is usually 5, but this can be overridden by subclasses.</p> </dd>
</dl> <dl class="attribute"> <dt id="SocketServer.BaseServer.socket_type">
<code>socket_type</code> </dt> <dd>
<p>The type of socket used by the server; <a class="reference internal" href="socket#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code>socket.SOCK_STREAM</code></a> and <a class="reference internal" href="socket#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code>socket.SOCK_DGRAM</code></a> are two common values.</p> </dd>
</dl> <dl class="attribute"> <dt id="SocketServer.BaseServer.timeout">
<code>timeout</code> </dt> <dd>
<p>Timeout duration, measured in seconds, or <a class="reference internal" href="constants#None" title="None"><code>None</code></a> if no timeout is desired. If <a class="reference internal" href="#SocketServer.BaseServer.handle_request" title="SocketServer.BaseServer.handle_request"><code>handle_request()</code></a> receives no incoming requests within the timeout period, the <a class="reference internal" href="#SocketServer.BaseServer.handle_timeout" title="SocketServer.BaseServer.handle_timeout"><code>handle_timeout()</code></a> method is called.</p> </dd>
</dl> <p>There are various server methods that can be overridden by subclasses of base server classes like <a class="reference internal" href="#SocketServer.TCPServer" title="SocketServer.TCPServer"><code>TCPServer</code></a>; these methods aren’t useful to external users of the server object.</p> <dl class="method"> <dt id="SocketServer.BaseServer.finish_request">
<code>finish_request(request, client_address)</code> </dt> <dd>
<p>Actually processes the request by instantiating <a class="reference internal" href="#SocketServer.BaseServer.RequestHandlerClass" title="SocketServer.BaseServer.RequestHandlerClass"><code>RequestHandlerClass</code></a> and calling its <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code>handle()</code></a> method.</p> </dd>
</dl> <dl class="method"> <dt id="SocketServer.BaseServer.get_request">
<code>get_request()</code> </dt> <dd>
<p>Must accept a request from the socket, and return a 2-tuple containing the <em>new</em> socket object to be used to communicate with the client, and the client’s address.</p> </dd>
</dl> <dl class="method"> <dt id="SocketServer.BaseServer.handle_error">
<code>handle_error(request, client_address)</code> </dt> <dd>
<p>This function is called if the <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code>handle()</code></a> method of a <a class="reference internal" href="#SocketServer.BaseServer.RequestHandlerClass" title="SocketServer.BaseServer.RequestHandlerClass"><code>RequestHandlerClass</code></a> instance raises an exception. The default action is to print the traceback to standard output and continue handling further requests.</p> </dd>
</dl> <dl class="method"> <dt id="SocketServer.BaseServer.handle_timeout">
<code>handle_timeout()</code> </dt> <dd>
<p>This function is called when the <a class="reference internal" href="#SocketServer.BaseServer.timeout" title="SocketServer.BaseServer.timeout"><code>timeout</code></a> attribute has been set to a value other than <a class="reference internal" href="constants#None" title="None"><code>None</code></a> and the timeout period has passed with no requests being received. The default action for forking servers is to collect the status of any child processes that have exited, while in threading servers this method does nothing.</p> </dd>
</dl> <dl class="method"> <dt id="SocketServer.BaseServer.process_request">
<code>process_request(request, client_address)</code> </dt> <dd>
<p>Calls <a class="reference internal" href="#SocketServer.BaseServer.finish_request" title="SocketServer.BaseServer.finish_request"><code>finish_request()</code></a> to create an instance of the <a class="reference internal" href="#SocketServer.BaseServer.RequestHandlerClass" title="SocketServer.BaseServer.RequestHandlerClass"><code>RequestHandlerClass</code></a>. If desired, this function can create a new process or thread to handle the request; the <a class="reference internal" href="#SocketServer.ForkingMixIn" title="SocketServer.ForkingMixIn"><code>ForkingMixIn</code></a> and <a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code>ThreadingMixIn</code></a> classes do this.</p> </dd>
</dl> <dl class="method"> <dt id="SocketServer.BaseServer.server_activate">
<code>server_activate()</code> </dt> <dd>
<p>Called by the server’s constructor to activate the server. The default behavior for a TCP server just invokes <a class="reference internal" href="socket#socket.socket.listen" title="socket.socket.listen"><code>listen()</code></a> on the server’s socket. May be overridden.</p> </dd>
</dl> <dl class="method"> <dt id="SocketServer.BaseServer.server_bind">
<code>server_bind()</code> </dt> <dd>
<p>Called by the server’s constructor to bind the socket to the desired address. May be overridden.</p> </dd>
</dl> <dl class="method"> <dt id="SocketServer.BaseServer.verify_request">
<code>verify_request(request, client_address)</code> </dt> <dd>
<p>Must return a Boolean value; if the value is <a class="reference internal" href="constants#True" title="True"><code>True</code></a>, the request will be processed, and if it’s <a class="reference internal" href="constants#False" title="False"><code>False</code></a>, the request will be denied. This function can be overridden to implement access controls for a server. The default implementation always returns <a class="reference internal" href="constants#True" title="True"><code>True</code></a>.</p> </dd>
</dl> </dd>
</dl>   <h2 id="request-handler-objects">3. Request Handler Objects</h2> <dl class="class"> <dt id="SocketServer.BaseRequestHandler">
<code>class SocketServer.BaseRequestHandler</code> </dt> <dd>
<p>This is the superclass of all request handler objects. It defines the interface, given below. A concrete request handler subclass must define a new <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code>handle()</code></a> method, and can override any of the other methods. A new instance of the subclass is created for each request.</p> <dl class="method"> <dt id="SocketServer.BaseRequestHandler.setup">
<code>setup()</code> </dt> <dd>
<p>Called before the <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code>handle()</code></a> method to perform any initialization actions required. The default implementation does nothing.</p> </dd>
</dl> <dl class="method"> <dt id="SocketServer.BaseRequestHandler.handle">
<code>handle()</code> </dt> <dd>
<p>This function must do all the work required to service a request. The default implementation does nothing. Several instance attributes are available to it; the request is available as <code>self.request</code>; the client address as <code>self.client_address</code>; and the server instance as <code>self.server</code>, in case it needs access to per-server information.</p> <p>The type of <code>self.request</code> is different for datagram or stream services. For stream services, <code>self.request</code> is a socket object; for datagram services, <code>self.request</code> is a pair of string and socket.</p> </dd>
</dl> <dl class="method"> <dt id="SocketServer.BaseRequestHandler.finish">
<code>finish()</code> </dt> <dd>
<p>Called after the <a class="reference internal" href="#SocketServer.BaseRequestHandler.handle" title="SocketServer.BaseRequestHandler.handle"><code>handle()</code></a> method to perform any clean-up actions required. The default implementation does nothing. If <a class="reference internal" href="#SocketServer.BaseRequestHandler.setup" title="SocketServer.BaseRequestHandler.setup"><code>setup()</code></a> raises an exception, this function will not be called.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="SocketServer.StreamRequestHandler">
<code>class SocketServer.StreamRequestHandler</code> </dt> <dt id="SocketServer.DatagramRequestHandler">
<code>class SocketServer.DatagramRequestHandler</code> </dt> <dd>
<p>These <a class="reference internal" href="#SocketServer.BaseRequestHandler" title="SocketServer.BaseRequestHandler"><code>BaseRequestHandler</code></a> subclasses override the <a class="reference internal" href="#SocketServer.BaseRequestHandler.setup" title="SocketServer.BaseRequestHandler.setup"><code>setup()</code></a> and <a class="reference internal" href="#SocketServer.BaseRequestHandler.finish" title="SocketServer.BaseRequestHandler.finish"><code>finish()</code></a> methods, and provide <code>self.rfile</code> and <code>self.wfile</code> attributes. The <code>self.rfile</code> and <code>self.wfile</code> attributes can be read or written, respectively, to get the request data or return data to the client.</p> </dd>
</dl>   <h2 id="examples">4. Examples</h2>  <h3 id="socketserver-tcpserver-example">4.1. <a class="reference internal" href="#SocketServer.TCPServer" title="SocketServer.TCPServer"><code>SocketServer.TCPServer</code></a> Example</h3> <p>This is the server side:</p> <pre data-language="python">import SocketServer

class MyTCPHandler(SocketServer.BaseRequestHandler):
    """
    The request handler class for our server.

    It is instantiated once per connection to the server, and must
    override the handle() method to implement communication to the
    client.
    """

    def handle(self):
        # self.request is the TCP socket connected to the client
        self.data = self.request.recv(1024).strip()
        print "{} wrote:".format(self.client_address[0])
        print self.data
        # just send back the same data, but upper-cased
        self.request.sendall(self.data.upper())

if __name__ == "__main__":
    HOST, PORT = "localhost", 9999

    # Create the server, binding to localhost on port 9999
    server = SocketServer.TCPServer((HOST, PORT), MyTCPHandler)

    # Activate the server; this will keep running until you
    # interrupt the program with Ctrl-C
    server.serve_forever()
</pre> <p>An alternative request handler class that makes use of streams (file-like objects that simplify communication by providing the standard file interface):</p> <pre data-language="python">class MyTCPHandler(SocketServer.StreamRequestHandler):

    def handle(self):
        # self.rfile is a file-like object created by the handler;
        # we can now use e.g. readline() instead of raw recv() calls
        self.data = self.rfile.readline().strip()
        print "{} wrote:".format(self.client_address[0])
        print self.data
        # Likewise, self.wfile is a file-like object used to write back
        # to the client
        self.wfile.write(self.data.upper())
</pre> <p>The difference is that the <code>readline()</code> call in the second handler will call <code>recv()</code> multiple times until it encounters a newline character, while the single <code>recv()</code> call in the first handler will just return what has been sent from the client in one <code>sendall()</code> call.</p> <p>This is the client side:</p> <pre data-language="python">import socket
import sys

HOST, PORT = "localhost", 9999
data = " ".join(sys.argv[1:])

# Create a socket (SOCK_STREAM means a TCP socket)
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
    # Connect to server and send data
    sock.connect((HOST, PORT))
    sock.sendall(data + "\n")

    # Receive data from the server and shut down
    received = sock.recv(1024)
finally:
    sock.close()

print "Sent:     {}".format(data)
print "Received: {}".format(received)
</pre> <p>The output of the example should look something like this:</p> <p>Server:</p> <pre data-language="shell">$ python TCPServer.py
127.0.0.1 wrote:
hello world with TCP
127.0.0.1 wrote:
python is nice
</pre> <p>Client:</p> <pre data-language="shell">$ python TCPClient.py hello world with TCP
Sent:     hello world with TCP
Received: HELLO WORLD WITH TCP
$ python TCPClient.py python is nice
Sent:     python is nice
Received: PYTHON IS NICE
</pre>   <h3 id="socketserver-udpserver-example">4.2. <a class="reference internal" href="#SocketServer.UDPServer" title="SocketServer.UDPServer"><code>SocketServer.UDPServer</code></a> Example</h3> <p>This is the server side:</p> <pre data-language="python">import SocketServer

class MyUDPHandler(SocketServer.BaseRequestHandler):
    """
    This class works similar to the TCP handler class, except that
    self.request consists of a pair of data and client socket, and since
    there is no connection the client address must be given explicitly
    when sending data back via sendto().
    """

    def handle(self):
        data = self.request[0].strip()
        socket = self.request[1]
        print "{} wrote:".format(self.client_address[0])
        print data
        socket.sendto(data.upper(), self.client_address)

if __name__ == "__main__":
    HOST, PORT = "localhost", 9999
    server = SocketServer.UDPServer((HOST, PORT), MyUDPHandler)
    server.serve_forever()
</pre> <p>This is the client side:</p> <pre data-language="python">import socket
import sys

HOST, PORT = "localhost", 9999
data = " ".join(sys.argv[1:])

# SOCK_DGRAM is the socket type to use for UDP sockets
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# As you can see, there is no connect() call; UDP has no connections.
# Instead, data is directly sent to the recipient via sendto().
sock.sendto(data + "\n", (HOST, PORT))
received = sock.recv(1024)

print "Sent:     {}".format(data)
print "Received: {}".format(received)
</pre> <p>The output of the example should look exactly like for the TCP server example.</p>   <h3 id="asynchronous-mixins">4.3. Asynchronous Mixins</h3> <p>To build asynchronous handlers, use the <a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code>ThreadingMixIn</code></a> and <a class="reference internal" href="#SocketServer.ForkingMixIn" title="SocketServer.ForkingMixIn"><code>ForkingMixIn</code></a> classes.</p> <p>An example for the <a class="reference internal" href="#SocketServer.ThreadingMixIn" title="SocketServer.ThreadingMixIn"><code>ThreadingMixIn</code></a> class:</p> <pre data-language="python">import socket
import threading
import SocketServer

class ThreadedTCPRequestHandler(SocketServer.BaseRequestHandler):

    def handle(self):
        data = self.request.recv(1024)
        cur_thread = threading.current_thread()
        response = "{}: {}".format(cur_thread.name, data)
        self.request.sendall(response)

class ThreadedTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    pass

def client(ip, port, message):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    try:
        sock.sendall(message)
        response = sock.recv(1024)
        print "Received: {}".format(response)
    finally:
        sock.close()

if __name__ == "__main__":
    # Port 0 means to select an arbitrary unused port
    HOST, PORT = "localhost", 0

    server = ThreadedTCPServer((HOST, PORT), ThreadedTCPRequestHandler)
    ip, port = server.server_address

    # Start a thread with the server -- that thread will then start one
    # more thread for each request
    server_thread = threading.Thread(target=server.serve_forever)
    # Exit the server thread when the main thread terminates
    server_thread.daemon = True
    server_thread.start()
    print "Server loop running in thread:", server_thread.name

    client(ip, port, "Hello World 1")
    client(ip, port, "Hello World 2")
    client(ip, port, "Hello World 3")

    server.shutdown()
    server.server_close()
</pre> <p>The output of the example should look something like this:</p> <pre data-language="shell">$ python ThreadedTCPServer.py
Server loop running in thread: Thread-1
Received: Thread-2: Hello World 1
Received: Thread-3: Hello World 2
Received: Thread-4: Hello World 3
</pre> <p>The <a class="reference internal" href="#SocketServer.ForkingMixIn" title="SocketServer.ForkingMixIn"><code>ForkingMixIn</code></a> class is used in the same way, except that the server will spawn a new process for each request. Available only on POSIX platforms that support <a class="reference internal" href="os#os.fork" title="os.fork"><code>fork()</code></a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/2.7/library/socketserver.html" class="_attribution-link">https://docs.python.org/2.7/library/socketserver.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
