
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Suspense for Data Fetching - React - W3cubDocs</title>
  
  <meta name="description" content=" Caution&#58; ">
  <meta name="keywords" content="suspense, for, data, fetching, experimental, react">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/react/concurrent-mode-suspense.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/react.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/react/" class="_nav-link" title="" style="margin-left:0;">React</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1>Suspense for Data Fetching (Experimental)</h1>  <blockquote> <p>Caution:</p> <p>This page describes <strong>experimental features that are <a href="concurrent-mode-adoption">not yet available</a> in a stable release</strong>. Don’t rely on experimental builds of React in production apps. These features may change significantly and without a warning before they become a part of React.</p> <p>This documentation is aimed at early adopters and people who are curious. <strong>If you’re new to React, don’t worry about these features</strong> — you don’t need to learn them right now. For example, if you’re looking for a data fetching tutorial that works today, read <a href="https://www.robinwieruch.de/react-hooks-fetch-data/">this article</a> instead.</p> </blockquote>  <p>React 16.6 added a <code class="gatsby-code-text">&lt;Suspense&gt;</code> component that lets you “wait” for some code to load and declaratively specify a loading state (like a spinner) while we’re waiting:</p> <pre data-language="jsx">const ProfilePage = React.lazy(() =&gt; import('./ProfilePage')); // Lazy-loaded

// Show a spinner while the profile is loading
&lt;Suspense fallback={&lt;Spinner /&gt;}&gt;
  &lt;ProfilePage /&gt;
&lt;/Suspense&gt;</pre> <p>Suspense for Data Fetching is a new feature that lets you also use <code class="gatsby-code-text">&lt;Suspense&gt;</code> to <strong>declaratively “wait” for anything else, including data.</strong> This page focuses on the data fetching use case, but it can also wait for images, scripts, or other asynchronous work.</p> <ul> <li> <p><a href="#what-is-suspense-exactly">What Is Suspense, Exactly?</a></p> <ul> <li><a href="#what-suspense-is-not">What Suspense Is Not</a></li> <li><a href="#what-suspense-lets-you-do">What Suspense Lets You Do</a></li> </ul> </li> <li> <p><a href="#using-suspense-in-practice">Using Suspense in Practice</a></p> <ul> <li><a href="#what-if-i-dont-use-relay">What If I Don’t Use Relay?</a></li> <li><a href="#for-library-authors">For Library Authors</a></li> </ul> </li> <li> <p><a href="#traditional-approaches-vs-suspense">Traditional Approaches vs Suspense</a></p> <ul> <li><a href="#approach-1-fetch-on-render-not-using-suspense">Approach 1: Fetch-on-Render (not using Suspense)</a></li> <li><a href="#approach-2-fetch-then-render-not-using-suspense">Approach 2: Fetch-Then-Render (not using Suspense)</a></li> <li><a href="#approach-3-render-as-you-fetch-using-suspense">Approach 3: Render-as-You-Fetch (using Suspense)</a></li> </ul> </li> <li> <p><a href="#start-fetching-early">Start Fetching Early</a></p> <ul> <li><a href="#were-still-figuring-this-out">We’re Still Figuring This Out</a></li> </ul> </li> <li> <p><a href="#suspense-and-race-conditions">Suspense and Race Conditions</a></p> <ul> <li><a href="#race-conditions-with-useeffect">Race Conditions with useEffect</a></li> <li><a href="#race-conditions-with-componentdidupdate">Race Conditions with componentDidUpdate</a></li> <li><a href="#the-problem">The Problem</a></li> <li><a href="#solving-race-conditions-with-suspense">Solving Race Conditions with Suspense</a></li> </ul> </li> <li><a href="#handling-errors">Handling Errors</a></li> <li><a href="#next-steps">Next Steps</a></li> </ul> <h2 id="what-is-suspense-exactly">What Is Suspense, Exactly? </h2> <p>Suspense lets your components “wait” for something before they can render. In <a href="https://codesandbox.io/s/frosty-hermann-bztrp">this example</a>, two components wait for an asynchronous API call to fetch some data:</p> <pre data-language="jsx">const resource = fetchProfileData();

function ProfilePage() {
  return (
    &lt;Suspense fallback={&lt;h1&gt;Loading profile...&lt;/h1&gt;}&gt;
      &lt;ProfileDetails /&gt;
      &lt;Suspense fallback={&lt;h1&gt;Loading posts...&lt;/h1&gt;}&gt;
        &lt;ProfileTimeline /&gt;
      &lt;/Suspense&gt;
    &lt;/Suspense&gt;
  );
}

function ProfileDetails() {
  // Try to read user info, although it might not have loaded yet
  const user = resource.user.read();
  return &lt;h1&gt;{user.name}&lt;/h1&gt;;
}

function ProfileTimeline() {
  // Try to read posts, although they might not have loaded yet
  const posts = resource.posts.read();
  return (
    &lt;ul&gt;
      {posts.map(post =&gt; (
        &lt;li key={post.id}&gt;{post.text}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</pre> <p><strong><a href="https://codesandbox.io/s/frosty-hermann-bztrp">Try it on CodeSandbox</a></strong></p> <p>This demo is a teaser. Don’t worry if it doesn’t quite make sense yet. We’ll talk more about how it works below. Keep in mind that Suspense is more of a <em>mechanism</em>, and particular APIs like <code class="gatsby-code-text">fetchProfileData()</code> or <code class="gatsby-code-text">resource.posts.read()</code> in the above example are not very important. If you’re curious, you can find their definitions right in the <a href="https://codesandbox.io/s/frosty-hermann-bztrp">demo sandbox</a>.</p> <p>Suspense is not a data fetching library. It’s a <strong>mechanism for data fetching libraries</strong> to communicate to React that <em>the data a component is reading is not ready yet</em>. React can then wait for it to be ready and update the UI. At Facebook, we use Relay and its <a href="https://relay.dev/docs/en/experimental/step-by-step">new Suspense integration</a>. We expect that other libraries like Apollo can provide similar integrations.</p> <p>In the long term, we intend Suspense to become the primary way to read asynchronous data from components — no matter where that data is coming from.</p> <h3 id="what-suspense-is-not">What Suspense Is Not </h3> <p>Suspense is significantly different from existing approaches to these problems, so reading about it for the first time often leads to misconceptions. Let’s clarify the most common ones:</p> <ul> <li>
<strong>It is not a data fetching implementation.</strong> It does not assume that you use GraphQL, REST, or any other particular data format, library, transport, or protocol.</li> <li>
<strong>It is not a ready-to-use client.</strong> You can’t “replace” <code class="gatsby-code-text">fetch</code> or Relay with Suspense. But you can use a library that’s integrated with Suspense (for example, <a href="https://relay.dev/docs/en/experimental/api-reference">new Relay APIs</a>).</li> <li>
<strong>It does not couple data fetching to the view layer.</strong> It helps orchestrate displaying the loading states in your UI, but it doesn’t tie your network logic to React components.</li> </ul> <h3 id="what-suspense-lets-you-do">What Suspense Lets You Do </h3> <p>So what’s the point of Suspense? There are a few ways we can answer this:</p> <ul> <li>
<strong>It lets data fetching libraries deeply integrate with React.</strong> If a data fetching library implements Suspense support, using it from React components feels very natural.</li> <li>
<strong>It lets you orchestrate intentionally designed loading states.</strong> It doesn’t say <em>how</em> the data is fetched, but it lets you closely control the visual loading sequence of your app.</li> <li>
<strong>It helps you avoid race conditions.</strong> Even with <code class="gatsby-code-text">await</code>, asynchronous code is often error-prone. Suspense feels more like reading data <em>synchronously</em> — as if it were already loaded.</li> </ul> <h2 id="using-suspense-in-practice">Using Suspense in Practice </h2> <p>At Facebook, so far we have only used the Relay integration with Suspense in production. <strong>If you’re looking for a practical guide to get started today, <a href="https://relay.dev/docs/en/experimental/step-by-step">check out the Relay Guide</a>!</strong> It demonstrates patterns that have already worked well for us in production.</p> <p><strong>The code demos on this page use a “fake” API implementation rather than Relay.</strong> This makes them easier to understand if you’re not familiar with GraphQL, but they won’t tell you the “right way” to build an app with Suspense. This page is more conceptual and is intended to help you see <em>why</em> Suspense works in a certain way, and which problems it solves.</p> <h3 id="what-if-i-dont-use-relay">What If I Don’t Use Relay? </h3> <p>If you don’t use Relay today, you might have to wait before you can really try Suspense in your app. So far, it’s the only implementation that we tested in production and are confident in.</p> <p>Over the next several months, many libraries will appear with different takes on Suspense APIs. <strong>If you prefer to learn when things are more stable, you might prefer to ignore this work for now, and come back when the Suspense ecosystem is more mature.</strong></p> <p>You can also write your own integration for a data fetching library, if you’d like.</p> <h3 id="for-library-authors">For Library Authors </h3> <p>We expect to see a lot of experimentation in the community with other libraries. There is one important thing to note for data fetching library authors.</p> <p>Although it’s technically doable, Suspense is <strong>not</strong> currently intended as a way to start fetching data when a component renders. Rather, it lets components express that they’re “waiting” for data that is <em>already being fetched</em>. <strong><a href="https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html">Building Great User Experiences with Concurrent Mode and Suspense</a> describes why this matters and how to implement this pattern in practice.</strong></p> <p>Unless you have a solution that helps prevent waterfalls, we suggest to prefer APIs that favor or enforce fetching before render. For a concrete example, you can look at how <a href="https://relay.dev/docs/en/experimental/api-reference#usepreloadedquery">Relay Suspense API</a> enforces preloading. Our messaging about this hasn’t been very consistent in the past. Suspense for Data Fetching is still experimental, so you can expect our recommendations to change over time as we learn more from production usage and understand the problem space better.</p> <h2 id="traditional-approaches-vs-suspense">Traditional Approaches vs Suspense </h2> <p>We could introduce Suspense without mentioning the popular data fetching approaches. However, this makes it more difficult to see which problems Suspense solves, why these problems are worth solving, and how Suspense is different from the existing solutions.</p> <p>Instead, we’ll look at Suspense as a logical next step in a sequence of approaches:</p> <ul> <li>
<strong>Fetch-on-render (for example, <code class="gatsby-code-text">fetch</code> in <code class="gatsby-code-text">useEffect</code>):</strong> Start rendering components. Each of these components may trigger data fetching in their effects and lifecycle methods. This approach often leads to “waterfalls”.</li> <li>
<strong>Fetch-then-render (for example, Relay without Suspense):</strong> Start fetching all the data for the next screen as early as possible. When the data is ready, render the new screen. We can’t do anything until the data arrives.</li> <li>
<strong>Render-as-you-fetch (for example, Relay with Suspense):</strong> Start fetching all the required data for the next screen as early as possible, and start rendering the new screen <em>immediately — before we get a network response</em>. As data streams in, React retries rendering components that still need data until they’re all ready.</li> </ul> <blockquote> <p>Note</p> <p>This is a bit simplified, and in practice solutions tend to use a mix of different approaches. Still, we will look at them in isolation to better contrast their tradeoffs.</p> </blockquote> <p>To compare these approaches, we’ll implement a profile page with each of them.</p> <h3 id="approach-1-fetch-on-render-not-using-suspense">Approach 1: Fetch-on-Render (not using Suspense) </h3> <p>A common way to fetch data in React apps today is to use an effect:</p> <pre data-language="jsx">// In a function component:
useEffect(() =&gt; {
  fetchSomething();
}, []);

// Or, in a class component:
componentDidMount() {
  fetchSomething();
}</pre> <p>We call this approach “fetch-on-render” because it doesn’t start fetching until <em>after</em> the component has rendered on the screen. This leads to a problem known as a “waterfall”.</p> <p>Consider these <code class="gatsby-code-text">&lt;ProfilePage&gt;</code> and <code class="gatsby-code-text">&lt;ProfileTimeline&gt;</code> components:</p> <pre data-language="jsx">function ProfilePage() {
  const [user, setUser] = useState(null);

  useEffect(() =&gt; {    fetchUser().then(u =&gt; setUser(u));  }, []);
  if (user === null) {
    return &lt;p&gt;Loading profile...&lt;/p&gt;;
  }
  return (
    &lt;&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
      &lt;ProfileTimeline /&gt;
    &lt;/&gt;
  );
}

function ProfileTimeline() {
  const [posts, setPosts] = useState(null);

  useEffect(() =&gt; {    fetchPosts().then(p =&gt; setPosts(p));  }, []);
  if (posts === null) {
    return &lt;h2&gt;Loading posts...&lt;/h2&gt;;
  }
  return (
    &lt;ul&gt;
      {posts.map(post =&gt; (
        &lt;li key={post.id}&gt;{post.text}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</pre> <p><strong><a href="https://codesandbox.io/s/fragrant-glade-8huj6">Try it on CodeSandbox</a></strong></p> <p>If you run this code and watch the console logs, you’ll notice the sequence is:</p> <ol> <li>We start fetching user details</li> <li>We wait…</li> <li>We finish fetching user details</li> <li>We start fetching posts</li> <li>We wait…</li> <li>We finish fetching posts</li> </ol> <p>If fetching user details takes three seconds, we’ll only <em>start</em> fetching the posts after three seconds! That’s a “waterfall”: an unintentional <em>sequence</em> that should have been parallelized.</p> <p>Waterfalls are common in code that fetches data on render. They’re possible to solve, but as the product grows, many people prefer to use a solution that guards against this problem.</p> <h3 id="approach-2-fetch-then-render-not-using-suspense">Approach 2: Fetch-Then-Render (not using Suspense) </h3> <p>Libraries can prevent waterfalls by offering a more centralized way to do data fetching. For example, Relay solves this problem by moving the information about the data a component needs to statically analyzable <em>fragments</em>, which later get composed into a single query.</p> <p>On this page, we don’t assume knowledge of Relay, so we won’t be using it for this example. Instead, we’ll write something similar manually by combining our data fetching methods:</p> <pre data-language="jsx">function fetchProfileData() {
  return Promise.all([
    fetchUser(),
    fetchPosts()
  ]).then(([user, posts]) =&gt; {
    return {user, posts};
  })
}</pre> <p>In this example, <code class="gatsby-code-text">&lt;ProfilePage&gt;</code> waits for both requests but starts them in parallel:</p> <pre data-language="jsx">// Kick off fetching as early as possibleconst promise = fetchProfileData();
function ProfilePage() {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState(null);

  useEffect(() =&gt; {    promise.then(data =&gt; {      setUser(data.user);      setPosts(data.posts);    });  }, []);
  if (user === null) {
    return &lt;p&gt;Loading profile...&lt;/p&gt;;
  }
  return (
    &lt;&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
      &lt;ProfileTimeline posts={posts} /&gt;
    &lt;/&gt;
  );
}

// The child doesn't trigger fetching anymore
function ProfileTimeline({ posts }) {
  if (posts === null) {
    return &lt;h2&gt;Loading posts...&lt;/h2&gt;;
  }
  return (
    &lt;ul&gt;
      {posts.map(post =&gt; (
        &lt;li key={post.id}&gt;{post.text}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</pre> <p><strong><a href="https://codesandbox.io/s/wandering-morning-ev6r0">Try it on CodeSandbox</a></strong></p> <p>The event sequence now becomes like this:</p> <ol> <li>We start fetching user details</li> <li>We start fetching posts</li> <li>We wait…</li> <li>We finish fetching user details</li> <li>We finish fetching posts</li> </ol> <p>We’ve solved the previous network “waterfall”, but accidentally introduced a different one. We wait for <em>all</em> data to come back with <code class="gatsby-code-text">Promise.all()</code> inside <code class="gatsby-code-text">fetchProfileData</code>, so now we can’t render profile details until the posts have been fetched too. We have to wait for both.</p> <p>Of course, this is possible to fix in this particular example. We could remove the <code class="gatsby-code-text">Promise.all()</code> call, and wait for both Promises separately. However, this approach gets progressively more difficult as the complexity of our data and component tree grows. It’s hard to write reliable components when arbitrary parts of the data tree may be missing or stale. So fetching all data for the new screen and <em>then</em> rendering is often a more practical option.</p> <h3 id="approach-3-render-as-you-fetch-using-suspense">Approach 3: Render-as-You-Fetch (using Suspense) </h3> <p>In the previous approach, we fetched data before we called <code class="gatsby-code-text">setState</code>:</p> <ol> <li>Start fetching</li> <li>Finish fetching</li> <li>Start rendering</li> </ol> <p>With Suspense, we still start fetching first, but we flip the last two steps around:</p> <ol> <li>Start fetching</li> <li><strong>Start rendering</strong></li> <li><strong>Finish fetching</strong></li> </ol> <p><strong>With Suspense, we don’t wait for the response to come back before we start rendering.</strong> In fact, we start rendering <em>pretty much immediately</em> after kicking off the network request:</p> <pre data-language="jsx">// This is not a Promise. It's a special object from our Suspense integration.
const resource = fetchProfileData();
function ProfilePage() {
  return (
    &lt;Suspense fallback={&lt;h1&gt;Loading profile...&lt;/h1&gt;}&gt;
      &lt;ProfileDetails /&gt;
      &lt;Suspense fallback={&lt;h1&gt;Loading posts...&lt;/h1&gt;}&gt;
        &lt;ProfileTimeline /&gt;
      &lt;/Suspense&gt;
    &lt;/Suspense&gt;
  );
}

function ProfileDetails() {
  // Try to read user info, although it might not have loaded yet
  const user = resource.user.read();  return &lt;h1&gt;{user.name}&lt;/h1&gt;;
}

function ProfileTimeline() {
  // Try to read posts, although they might not have loaded yet
  const posts = resource.posts.read();  return (
    &lt;ul&gt;
      {posts.map(post =&gt; (
        &lt;li key={post.id}&gt;{post.text}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</pre> <p><strong><a href="https://codesandbox.io/s/frosty-hermann-bztrp">Try it on CodeSandbox</a></strong></p> <p>Here’s what happens when we render <code class="gatsby-code-text">&lt;ProfilePage&gt;</code> on the screen:</p> <ol> <li>We’ve already kicked off the requests in <code class="gatsby-code-text">fetchProfileData()</code>. It gave us a special “resource” instead of a Promise. In a realistic example, it would be provided by our data library’s Suspense integration, like Relay.</li> <li>React tries to render <code class="gatsby-code-text">&lt;ProfilePage&gt;</code>. It returns <code class="gatsby-code-text">&lt;ProfileDetails&gt;</code> and <code class="gatsby-code-text">&lt;ProfileTimeline&gt;</code> as children.</li> <li>React tries to render <code class="gatsby-code-text">&lt;ProfileDetails&gt;</code>. It calls <code class="gatsby-code-text">resource.user.read()</code>. None of the data is fetched yet, so this component “suspends”. React skips over it, and tries rendering other components in the tree.</li> <li>React tries to render <code class="gatsby-code-text">&lt;ProfileTimeline&gt;</code>. It calls <code class="gatsby-code-text">resource.posts.read()</code>. Again, there’s no data yet, so this component also “suspends”. React skips over it too, and tries rendering other components in the tree.</li> <li>There’s nothing left to try rendering. Because <code class="gatsby-code-text">&lt;ProfileDetails&gt;</code> suspended, React shows the closest <code class="gatsby-code-text">&lt;Suspense&gt;</code> fallback above it in the tree: <code class="gatsby-code-text">&lt;h1&gt;Loading profile...&lt;/h1&gt;</code>. We’re done for now.</li> </ol> <p>This <code class="gatsby-code-text">resource</code> object represents the data that isn’t there yet, but might eventually get loaded. When we call <code class="gatsby-code-text">read()</code>, we either get the data, or the component “suspends”.</p> <p><strong>As more data streams in, React will retry rendering, and each time it might be able to progress “deeper”.</strong> When <code class="gatsby-code-text">resource.user</code> is fetched, the <code class="gatsby-code-text">&lt;ProfileDetails&gt;</code> component will render successfully and we’ll no longer need the <code class="gatsby-code-text">&lt;h1&gt;Loading profile...&lt;/h1&gt;</code> fallback. Eventually, we’ll get all the data, and there will be no fallbacks on the screen.</p> <p>This has an interesting implication. Even if we use a GraphQL client that collects all data requirements in a single request, <em>streaming the response lets us show more content sooner</em>. Because we render-<em>as-we-fetch</em> (as opposed to <em>after</em> fetching), if <code class="gatsby-code-text">user</code> appears in the response earlier than <code class="gatsby-code-text">posts</code>, we’ll be able to “unlock” the outer <code class="gatsby-code-text">&lt;Suspense&gt;</code> boundary before the response even finishes. We might have missed this earlier, but even the fetch-then-render solution contained a waterfall: between fetching and rendering. Suspense doesn’t inherently suffer from this waterfall, and libraries like Relay take advantage of this.</p> <p>Note how we eliminated the <code class="gatsby-code-text">if (...)</code> “is loading” checks from our components. This doesn’t only remove boilerplate code, but it also simplifies making quick design changes. For example, if we wanted profile details and posts to always “pop in” together, we could delete the <code class="gatsby-code-text">&lt;Suspense&gt;</code> boundary between them. Or we could make them independent from each other by giving each <em>its own</em> <code class="gatsby-code-text">&lt;Suspense&gt;</code> boundary. Suspense lets us change the granularity of our loading states and orchestrate their sequencing without invasive changes to our code.</p> <h2 id="start-fetching-early">Start Fetching Early </h2> <p>If you’re working on a data fetching library, there’s a crucial aspect of Render-as-You-Fetch you don’t want to miss. <strong>We kick off fetching <em>before</em> rendering.</strong> Look at this code example closer:</p> <pre data-language="jsx">// Start fetching early!
const resource = fetchProfileData();

// ...

function ProfileDetails() {
  // Try to read user info
  const user = resource.user.read();
  return &lt;h1&gt;{user.name}&lt;/h1&gt;;
}</pre> <p><strong><a href="https://codesandbox.io/s/frosty-hermann-bztrp">Try it on CodeSandbox</a></strong></p> <p>Note that the <code class="gatsby-code-text">read()</code> call in this example doesn’t <em>start</em> fetching. It only tries to read the data that is <strong>already being fetched</strong>. This difference is crucial to creating fast applications with Suspense. We don’t want to delay loading data until a component starts rendering. As a data fetching library author, you can enforce this by making it impossible to get a <code class="gatsby-code-text">resource</code> object without also starting a fetch. Every demo on this page using our “fake API” enforces this.</p> <p>You might object that fetching “at the top level” like in this example is impractical. What are we going to do if we navigate to another profile’s page? We might want to fetch based on props. The answer to this is <strong>we want to start fetching in the event handlers instead</strong>. Here is a simplified example of navigating between user’s pages:</p> <pre data-language="jsx">// First fetch: as soon as possibleconst initialResource = fetchProfileData(0);
function App() {
  const [resource, setResource] = useState(initialResource);
  return (
    &lt;&gt;
      &lt;button onClick={() =&gt; {
        const nextUserId = getNextId(resource.userId);
        // Next fetch: when the user clicks        setResource(fetchProfileData(nextUserId));      }}&gt;
        Next
      &lt;/button&gt;
      &lt;ProfilePage resource={resource} /&gt;
    &lt;/&gt;
  );
}</pre> <p><strong><a href="https://codesandbox.io/s/infallible-feather-xjtbu">Try it on CodeSandbox</a></strong></p> <p>With this approach, we can <strong>fetch code and data in parallel</strong>. When we navigate between pages, we don’t need to wait for a page’s code to load to start loading its data. We can start fetching both code and data at the same time (during the link click), delivering a much better user experience.</p> <p>This poses a question of how do we know <em>what</em> to fetch before rendering the next screen. There are several ways to solve this (for example, by integrating data fetching closer with your routing solution). If you work on a data fetching library, <a href="https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html">Building Great User Experiences with Concurrent Mode and Suspense</a> presents a deep dive on how to accomplish this and why it’s important.</p> <h3 id="were-still-figuring-this-out">We’re Still Figuring This Out </h3> <p>Suspense itself as a mechanism is flexible and doesn’t have many constraints. Product code needs to be more constrained to ensure no waterfalls, but there are different ways to provide these guarantees. Some questions that we’re currently exploring include:</p> <ul> <li>Fetching early can be cumbersome to express. How do we make it easier to avoid waterfalls?</li> <li>When we fetch data for a page, can the API encourage including data for instant transitions <em>from</em> it?</li> <li>What is the lifetime of a response? Should caching be global or local? Who manages the cache?</li> <li>Can Proxies help express lazy-loaded APIs without inserting <code class="gatsby-code-text">read()</code> calls everywhere?</li> <li>What would the equivalent of composing GraphQL queries look like for arbitrary Suspense data?</li> </ul> <p>Relay has its own answers to some of these questions. There is certainly more than a single way to do it, and we’re excited to see what new ideas the React community comes up with.</p> <h2 id="suspense-and-race-conditions">Suspense and Race Conditions </h2> <p>Race conditions are bugs that happen due to incorrect assumptions about the order in which our code may run. Fetching data in the <code class="gatsby-code-text">useEffect</code> Hook or in class lifecycle methods like <code class="gatsby-code-text">componentDidUpdate</code> often leads to them. Suspense can help here, too — let’s see how.</p> <p>To demonstrate the issue, we will add a top-level <code class="gatsby-code-text">&lt;App&gt;</code> component that renders our <code class="gatsby-code-text">&lt;ProfilePage&gt;</code> with a button that lets us <strong>switch between different profiles</strong>:</p> <pre data-language="jsx">function getNextId(id) {
  // ...
}

function App() {
  const [id, setId] = useState(0);
  return (
    &lt;&gt;
      &lt;button onClick={() =&gt; setId(getNextId(id))}&gt;        Next      &lt;/button&gt;      &lt;ProfilePage id={id} /&gt;
    &lt;/&gt;
  );
}</pre> <p>Let’s compare how different data fetching strategies deal with this requirement.</p> <h3 id="race-conditions-with-useeffect">Race Conditions with <code class="gatsby-code-text">useEffect</code> </h3> <p>First, we’ll try a version of our original “fetch in effect” example. We’ll modify it to pass an <code class="gatsby-code-text">id</code> parameter from the <code class="gatsby-code-text">&lt;ProfilePage&gt;</code> props to <code class="gatsby-code-text">fetchUser(id)</code> and <code class="gatsby-code-text">fetchPosts(id)</code>:</p> <pre data-language="jsx">function ProfilePage({ id }) {  const [user, setUser] = useState(null);

  useEffect(() =&gt; {
    fetchUser(id).then(u =&gt; setUser(u));  }, [id]);
  if (user === null) {
    return &lt;p&gt;Loading profile...&lt;/p&gt;;
  }
  return (
    &lt;&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
      &lt;ProfileTimeline id={id} /&gt;    &lt;/&gt;
  );
}

function ProfileTimeline({ id }) {  const [posts, setPosts] = useState(null);

  useEffect(() =&gt; {
    fetchPosts(id).then(p =&gt; setPosts(p));  }, [id]);
  if (posts === null) {
    return &lt;h2&gt;Loading posts...&lt;/h2&gt;;
  }
  return (
    &lt;ul&gt;
      {posts.map(post =&gt; (
        &lt;li key={post.id}&gt;{post.text}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</pre> <p><strong><a href="https://codesandbox.io/s/nervous-glade-b5sel">Try it on CodeSandbox</a></strong></p> <p>Note how we also changed the effect dependencies from <code class="gatsby-code-text">[]</code> to <code class="gatsby-code-text">[id]</code> — because we want the effect to re-run when the <code class="gatsby-code-text">id</code> changes. Otherwise, we wouldn’t refetch new data.</p> <p>If we try this code, it might seem like it works at first. However, if we randomize the delay time in our “fake API” implementation and press the “Next” button fast enough, we’ll see from the console logs that something is going very wrong. <strong>Requests from the previous profiles may sometimes “come back” after we’ve already switched the profile to another ID — and in that case they can overwrite the new state with a stale response for a different ID.</strong></p> <p>This problem is possible to fix (you could use the effect cleanup function to either ignore or cancel stale requests), but it’s unintuitive and difficult to debug.</p> <h3 id="race-conditions-with-componentdidupdate">Race Conditions with <code class="gatsby-code-text">componentDidUpdate</code> </h3> <p>One might think that this is a problem specific to <code class="gatsby-code-text">useEffect</code> or Hooks. Maybe if we port this code to classes or use convenient syntax like <code class="gatsby-code-text">async</code> / <code class="gatsby-code-text">await</code>, it will solve the problem?</p> <p>Let’s try that:</p> <pre data-language="jsx">class ProfilePage extends React.Component {
  state = {
    user: null,
  };
  componentDidMount() {
    this.fetchData(this.props.id);
  }
  componentDidUpdate(prevProps) {
    if (prevProps.id !== this.props.id) {
      this.fetchData(this.props.id);
    }
  }
  async fetchData(id) {
    const user = await fetchUser(id);
    this.setState({ user });
  }
  render() {
    const { id } = this.props;
    const { user } = this.state;
    if (user === null) {
      return &lt;p&gt;Loading profile...&lt;/p&gt;;
    }
    return (
      &lt;&gt;
        &lt;h1&gt;{user.name}&lt;/h1&gt;
        &lt;ProfileTimeline id={id} /&gt;
      &lt;/&gt;
    );
  }
}

class ProfileTimeline extends React.Component {
  state = {
    posts: null,
  };
  componentDidMount() {
    this.fetchData(this.props.id);
  }
  componentDidUpdate(prevProps) {
    if (prevProps.id !== this.props.id) {
      this.fetchData(this.props.id);
    }
  }
  async fetchData(id) {
    const posts = await fetchPosts(id);
    this.setState({ posts });
  }
  render() {
    const { posts } = this.state;
    if (posts === null) {
      return &lt;h2&gt;Loading posts...&lt;/h2&gt;;
    }
    return (
      &lt;ul&gt;
        {posts.map(post =&gt; (
          &lt;li key={post.id}&gt;{post.text}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    );
  }
}</pre> <p><strong><a href="https://codesandbox.io/s/trusting-clarke-8twuq">Try it on CodeSandbox</a></strong></p> <p>This code is deceptively easy to read.</p> <p>Unfortunately, neither using a class nor the <code class="gatsby-code-text">async</code> / <code class="gatsby-code-text">await</code> syntax helped us solve this problem. This version suffers from exactly the same race conditions, for the same reasons.</p> <h3 id="the-problem">The Problem </h3> <p>React components have their own “lifecycle”. They may receive props or update state at any point in time. However, each asynchronous request <em>also</em> has its own “lifecycle”. It starts when we kick it off, and finishes when we get a response. The difficulty we’re experiencing is “synchronizing” several processes in time that affect each other. This is hard to think about.</p> <h3 id="solving-race-conditions-with-suspense">Solving Race Conditions with Suspense </h3> <p>Let’s rewrite this example again, but using Suspense only:</p> <pre data-language="jsx">const initialResource = fetchProfileData(0);

function App() {
  const [resource, setResource] = useState(initialResource);
  return (
    &lt;&gt;
      &lt;button onClick={() =&gt; {
        const nextUserId = getNextId(resource.userId);
        setResource(fetchProfileData(nextUserId));
      }}&gt;
        Next
      &lt;/button&gt;
      &lt;ProfilePage resource={resource} /&gt;
    &lt;/&gt;
  );
}

function ProfilePage({ resource }) {
  return (
    &lt;Suspense fallback={&lt;h1&gt;Loading profile...&lt;/h1&gt;}&gt;
      &lt;ProfileDetails resource={resource} /&gt;
      &lt;Suspense fallback={&lt;h1&gt;Loading posts...&lt;/h1&gt;}&gt;
        &lt;ProfileTimeline resource={resource} /&gt;
      &lt;/Suspense&gt;
    &lt;/Suspense&gt;
  );
}

function ProfileDetails({ resource }) {
  const user = resource.user.read();
  return &lt;h1&gt;{user.name}&lt;/h1&gt;;
}

function ProfileTimeline({ resource }) {
  const posts = resource.posts.read();
  return (
    &lt;ul&gt;
      {posts.map(post =&gt; (
        &lt;li key={post.id}&gt;{post.text}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</pre> <p><strong><a href="https://codesandbox.io/s/infallible-feather-xjtbu">Try it on CodeSandbox</a></strong></p> <p>In the previous Suspense example, we only had one <code class="gatsby-code-text">resource</code>, so we held it in a top-level variable. Now that we have multiple resources, we moved it to the <code class="gatsby-code-text">&lt;App&gt;</code>’s component state:</p> <pre data-language="jsx">const initialResource = fetchProfileData(0);

function App() {
  const [resource, setResource] = useState(initialResource);</pre> <p>When we click “Next”, the <code class="gatsby-code-text">&lt;App&gt;</code> component kicks off a request for the next profile, and passes <em>that</em> object down to the <code class="gatsby-code-text">&lt;ProfilePage&gt;</code> component:</p> <pre data-language="jsx">  &lt;&gt;
    &lt;button onClick={() =&gt; {
      const nextUserId = getNextId(resource.userId);
      setResource(fetchProfileData(nextUserId));    }}&gt;
      Next
    &lt;/button&gt;
    &lt;ProfilePage resource={resource} /&gt;  &lt;/&gt;</pre> <p>Again, notice that <strong>we’re not waiting for the response to set the state. It’s the other way around: we set the state (and start rendering) immediately after kicking off a request</strong>. As soon as we have more data, React “fills in” the content inside <code class="gatsby-code-text">&lt;Suspense&gt;</code> components.</p> <p>This code is very readable, but unlike the examples earlier, the Suspense version doesn’t suffer from race conditions. You might be wondering why. The answer is that in the Suspense version, we don’t have to think about <em>time</em> as much in our code. Our original code with race conditions needed to set the state <em>at the right moment later</em>, or otherwise it would be wrong. But with Suspense, we set the state <em>immediately</em> — so it’s harder to mess it up.</p> <h2 id="handling-errors">Handling Errors </h2> <p>When we write code with Promises, we might use <code class="gatsby-code-text">catch()</code> to handle errors. How does this work with Suspense, given that we don’t <em>wait</em> for Promises to start rendering?</p> <p>With Suspense, handling fetching errors works the same way as handling rendering errors — you can render an <a href="error-boundaries">error boundary</a> anywhere to “catch” errors in components below.</p> <p>First, we’ll define an error boundary component to use across our project:</p> <pre data-language="jsx">// Error boundaries currently have to be classes.
class ErrorBoundary extends React.Component {
  state = { hasError: false, error: null };
  static getDerivedStateFromError(error) {
    return {
      hasError: true,
      error
    };
  }
  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
}</pre> <p>And then we can put it anywhere in the tree to catch errors:</p> <pre data-language="jsx">function ProfilePage() {
  return (
    &lt;Suspense fallback={&lt;h1&gt;Loading profile...&lt;/h1&gt;}&gt;
      &lt;ProfileDetails /&gt;
      &lt;ErrorBoundary fallback={&lt;h2&gt;Could not fetch posts.&lt;/h2&gt;}&gt;        &lt;Suspense fallback={&lt;h1&gt;Loading posts...&lt;/h1&gt;}&gt;
          &lt;ProfileTimeline /&gt;
        &lt;/Suspense&gt;
      &lt;/ErrorBoundary&gt;    &lt;/Suspense&gt;
  );
}</pre> <p><strong><a href="https://codesandbox.io/s/adoring-goodall-8wbn7">Try it on CodeSandbox</a></strong></p> <p>It would catch both rendering errors <em>and</em> errors from Suspense data fetching. We can have as many error boundaries as we like but it’s best to <a href="https://aweary.dev/fault-tolerance-react/">be intentional</a> about their placement.</p> <h2 id="next-steps">Next Steps </h2> <p>We’ve now covered the basics of Suspense for Data Fetching! Importantly, we now better understand <em>why</em> Suspense works this way, and how it fits into the data fetching space.</p> <p>Suspense answers some questions, but it also poses new questions of its own:</p> <ul> <li>If some component “suspends”, does the app freeze? How to avoid this?</li> <li>What if we want to show a spinner in a different place than “above” the component in a tree?</li> <li>If we intentionally <em>want</em> to show an inconsistent UI for a small period of time, can we do that?</li> <li>Instead of showing a spinner, can we add a visual effect like “greying out” the current screen?</li> <li>Why does our <a href="https://codesandbox.io/s/infallible-feather-xjtbu">last Suspense example</a> log a warning when clicking the “Next” button?</li> </ul> <p>To answer these questions, we will refer to the next section on <a href="concurrent-mode-patterns">Concurrent UI Patterns</a>.</p>
<span><span>Is this page useful?</span></span><div class="_attribution">
  <p class="_attribution-p">
    © 2013–present Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>
    <a href="https://reactjs.org/docs/concurrent-mode-suspense.html" class="_attribution-link">https://reactjs.org/docs/concurrent-mode-suspense.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
