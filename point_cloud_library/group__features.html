
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Module Features - PointCloudLibrary - W3cubDocs</title>
  
  <meta name="description" content="The pcl_features library contains data structures and mechanisms for 3D feature estimation from point cloud data. 3D features are representations at &hellip;">
  <meta name="keywords" content="overview, requirements, module, features, pointcloudlibrary, point_cloud_library">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/point_cloud_library/group__features.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/point_cloud_library.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/point_cloud_library/" class="_nav-link" title="" style="margin-left:0;">PointCloudLibrary</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _point_cloud_library">
				
				
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2> <h1>
<a class="anchor" id="secFeaturesPresentation"></a> Overview</h1> <p>The <b>pcl_features</b> library contains data structures and mechanisms for 3D feature estimation from point cloud data. <em>3D features</em> are representations at a certain 3D point or position in space, which describe geometrical patterns based on the information available around the point. The data space selected around the query point is usually referred as the <b>k-neighborhood</b>.</p> <p>The following figure shows a simple example of a selected query point, and its selected k-neighborhood.</p> <div class="image"> <img src="http://www.pointclouds.org/assets/images/contents/documentation/features_normal.png" alt=""> </div> <p>An example of two of the most widely used geometric point features are the underlying surface's estimated curvature and normal at a query point <b>p</b>. Both of them are considered local features, as they characterize a point using the information provided by its k closest point neighbors. For determining these neighbors efficiently, the input dataset is usually split into smaller chunks using spatial decomposition techniques such as octrees or kD-trees (see the figure below - left: kD-tree, right: octree), and then closest point searches are performed in that space. Depending on the application one can opt for either determining a fixed number of k points in the vicinity of p, or all points which are found inside of a sphere of radius r centered at p. Unarguably, one the easiest methods for estimating the surface normals and curvature changes at a point p is to perform an eigendecomposition (i.e. compute the eigenvectors and eigenvalues) of the k-neighborhood point surface patch. Thus, the eigenvector corresponding to the smallest eigenvalue will approximate the surface normal n at point p, while the surface curvature change will be estimated from the eigenvalues as:</p> <center> <img class="formulaInl" alt="$\frac{\lambda_0}{\lambda_0 + \lambda_1 + \lambda_2}$" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAAUBAMAAAA0D9PTAAAAMFBMVEUAAAAAAABHcEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABXgkToAAAAD3RSTlPFXQAuj6xIb4Ce6bnS9N0mKi8mAAAA1klEQVQoz2NQwg0YkNgqSbjl1BbhllNaiEeuB4/cfCOPaTjkdDKDFgngkFuo/OkSLjkgYCpBllMWRAatgQh2EoM6Ay7gxKCkXoQZLipGUPs+gbmK8HABqlDZBJXbCRZRh4eLsJKS8ieonD1crgcmp8QClattEmlRCo0JFQKGS0KTWih3qJHSXiX3w0A57cZHj3WVjC2MQeGi6qRkXGaslKMn5LQDKLdTaeFiXbCZwHABygHNVL6k/kh9EiRcJipA7FNSgsiBgOdGiJx6E8xjGc0wVouTEgD/RV9XMjAs9AAAAABJRU5ErkJggg==">, where <img class="formulaInl" alt="$\lambda_0 &lt; \lambda_1 &lt; \lambda_2$" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE8AAAAOBAMAAACcHlx8AAAAMFBMVEVHcEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlTPQ5AAAAD3RSTlMALkiA0p7pxblvrF2P9N0ot5BwAAAA+klEQVQoz2NgIB5sQOUyCaDyheCsEjSFn1D5YgdgLHk0GypQucwXYCw+uBaGJSBr9yPUeILIjzAuD0wL44oJIIp/ApTP2gOmPGAKGT8yMBuA6HYFMJ/dgYEZRHN5QuTtGZiCIRqzGArFgXQLRB2D1gfGeKATeF5CDVq/QZWrAMRotmd8wAaUkSiC+NrhMwOIyxACcQKLeoEp9weQTQb8uwvAMhCVegzHIAqhKh8xfWDgWgBkdDBwVDtAZFiBrmK8xCAvAOEymADDg82A4TLDVBAPKDYhgQ3qzw0gPhNMIYMx0CUMDNKcEwKg7o0xRg3ksEAU7t67C4hPEQBUZi1NhYB3EgAAAABJRU5ErkJggg==">.</center>
<div class="image"> <img src="http://www.pointclouds.org/assets/images/contents/documentation/features_bunny.png" alt=""> </div> <p>Please visit <a href="http://www.pointclouds.org">http://www.pointclouds.org</a> for more information.</p> <h1>
<a class="anchor" id="secFeaturesRequirements"></a> Requirements</h1> <ul> <li><a class="el" href="group__common">common</a></li> <li><a class="el" href="https://pointclouds.org/documentation/group__search.html">search</a></li> <li><a class="el" href="group__kdtree">kdtree</a></li> <li><a class="el" href="group__octree">octree</a></li> <li>
<a class="el" href="classpcl_1_1_range_image">range_image</a> </li> </ul> <table class="memberdecls"> <tr class="heading"><td colspan="2"><h2 class="groupheader">
<a name="nested-classes"></a> Classes</h2></td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_shape_context3_d_estimation">pcl::ShapeContext3DEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_shape_context3_d_estimation" title="ShapeContext3DEstimation implements the 3D shape context descriptor as described in:">ShapeContext3DEstimation</a> implements the 3D shape context descriptor as described in: <a href="classpcl_1_1_shape_context3_d_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_b_o_a_r_d_local_reference_frame_estimation">pcl::BOARDLocalReferenceFrameEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_b_o_a_r_d_local_reference_frame_estimation" title="BOARDLocalReferenceFrameEstimation implements the BOrder Aware Repeatable Directions algorithm for lo...">BOARDLocalReferenceFrameEstimation</a> implements the BOrder Aware Repeatable Directions algorithm for local reference frame estimation as described here: <a href="classpcl_1_1_b_o_a_r_d_local_reference_frame_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_boundary_estimation">pcl::BoundaryEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_boundary_estimation" title="BoundaryEstimation estimates whether a set of points is lying on surface boundaries using an angle cr...">BoundaryEstimation</a> estimates whether a set of points is lying on surface boundaries using an angle criterion. <a href="classpcl_1_1_boundary_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_b_r_i_s_k2_d_estimation">pcl::BRISK2DEstimation&lt; PointInT, PointOutT, KeypointT, IntensityT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">Implementation of the BRISK-descriptor, based on the original code and paper reference by. <a href="classpcl_1_1_b_r_i_s_k2_d_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_c_r_h_estimation">pcl::CRHEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_c_r_h_estimation" title="CRHEstimation estimates the Camera Roll Histogram (CRH) descriptor for a given point cloud dataset co...">CRHEstimation</a> estimates the <a class="el" href="https://pointclouds.org/documentation/class_camera.html">Camera</a> Roll <a class="el" href="structpcl_1_1_histogram" title="A point structure representing an N-D histogram.">Histogram</a> (CRH) descriptor for a given point cloud dataset containing XYZ data and normals, as presented in: <a href="classpcl_1_1_c_r_h_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_c_v_f_h_estimation">pcl::CVFHEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_c_v_f_h_estimation" title="CVFHEstimation estimates the Clustered Viewpoint Feature Histogram (CVFH) descriptor for a given poin...">CVFHEstimation</a> estimates the Clustered Viewpoint <a class="el" href="classpcl_1_1_feature" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram" title="A point structure representing an N-D histogram.">Histogram</a> (CVFH) descriptor for a given point cloud dataset containing XYZ data and normals, as presented in: <a href="classpcl_1_1_c_v_f_h_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_difference_of_normals_estimation">pcl::DifferenceOfNormalsEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">A Difference of Normals (DoN) scale filter implementation for point cloud data. <a href="classpcl_1_1_difference_of_normals_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_e_s_f_estimation">pcl::ESFEstimation&lt; PointInT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b><a class="el" href="classpcl_1_1_e_s_f_estimation" title="ESFEstimation estimates the ensemble of shape functions descriptors for a given point cloud dataset c...">ESFEstimation</a></b> estimates the ensemble of shape functions descriptors for a given point cloud dataset containing points. <a href="classpcl_1_1_e_s_f_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_feature">pcl::Feature&lt; PointInT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_feature" title="Feature represents the base feature class.">Feature</a> represents the base feature class. <a href="classpcl_1_1_feature#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_feature_with_local_reference_frames">pcl::FeatureWithLocalReferenceFrames&lt; PointInT, PointRFT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_feature_with_local_reference_frames" title="FeatureWithLocalReferenceFrames provides a public interface for descriptor extractor classes which ne...">FeatureWithLocalReferenceFrames</a> provides a public interface for descriptor extractor classes which need a local reference frame at each input keypoint. <a href="classpcl_1_1_feature_with_local_reference_frames#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_f_l_a_r_e_local_reference_frame_estimation">pcl::FLARELocalReferenceFrameEstimation&lt; PointInT, PointNT, PointOutT, SignedDistanceT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_f_l_a_r_e_local_reference_frame_estimation" title="FLARELocalReferenceFrameEstimation implements the Fast LocAl Reference framE algorithm for local refe...">FLARELocalReferenceFrameEstimation</a> implements the Fast LocAl Reference framE algorithm for local reference frame estimation as described here: <a href="classpcl_1_1_f_l_a_r_e_local_reference_frame_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_f_p_f_h_estimation">pcl::FPFHEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_f_p_f_h_estimation" title="FPFHEstimation estimates the Fast Point Feature Histogram (FPFH) descriptor for a given point cloud d...">FPFHEstimation</a> estimates the <b>Fast Point <a class="el" href="classpcl_1_1_feature" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram" title="A point structure representing an N-D histogram.">Histogram</a> (FPFH)</b> descriptor for a given point cloud dataset containing points and normals. <a href="classpcl_1_1_f_p_f_h_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_f_p_f_h_estimation_o_m_p">pcl::FPFHEstimationOMP&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_f_p_f_h_estimation_o_m_p" title="FPFHEstimationOMP estimates the Fast Point Feature Histogram (FPFH) descriptor for a given point clou...">FPFHEstimationOMP</a> estimates the Fast Point <a class="el" href="classpcl_1_1_feature" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram" title="A point structure representing an N-D histogram.">Histogram</a> (FPFH) descriptor for a given point cloud dataset containing points and normals, in parallel, using the OpenMP standard. <a href="classpcl_1_1_f_p_f_h_estimation_o_m_p#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_g_a_s_d_estimation">pcl::GASDEstimation&lt; PointInT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_g_a_s_d_estimation" title="GASDEstimation estimates the Globally Aligned Spatial Distribution (GASD) descriptor for a given poin...">GASDEstimation</a> estimates the Globally Aligned Spatial Distribution (GASD) descriptor for a given point cloud dataset given XYZ data. <a href="classpcl_1_1_g_a_s_d_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_g_a_s_d_color_estimation">pcl::GASDColorEstimation&lt; PointInT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_g_a_s_d_color_estimation" title="GASDColorEstimation estimates the Globally Aligned Spatial Distribution (GASD) descriptor for a given...">GASDColorEstimation</a> estimates the Globally Aligned Spatial Distribution (GASD) descriptor for a given point cloud dataset given XYZ and <a class="el" href="structpcl_1_1_r_g_b" title="A structure representing RGB color information.">RGB</a> data. <a href="classpcl_1_1_g_a_s_d_color_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_g_f_p_f_h_estimation">pcl::GFPFHEstimation&lt; PointInT, PointLT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b><a class="el" href="classpcl_1_1_g_f_p_f_h_estimation" title="GFPFHEstimation estimates the Global Fast Point Feature Histogram (GFPFH) descriptor for a given poin...">GFPFHEstimation</a></b> estimates the Global Fast Point <a class="el" href="classpcl_1_1_feature" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram" title="A point structure representing an N-D histogram.">Histogram</a> (GFPFH) descriptor for a given point cloud dataset containing points and labels. <a href="classpcl_1_1_g_f_p_f_h_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_g_r_s_d_estimation">pcl::GRSDEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b><a class="el" href="classpcl_1_1_g_r_s_d_estimation" title="GRSDEstimation estimates the Global Radius-based Surface Descriptor (GRSD) for a given point cloud da...">GRSDEstimation</a></b> estimates the Global Radius-based Surface Descriptor (GRSD) for a given point cloud dataset containing points and normals. <a href="classpcl_1_1_g_r_s_d_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_intensity_gradient_estimation">pcl::IntensityGradientEstimation&lt; PointInT, PointNT, PointOutT, IntensitySelectorT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_intensity_gradient_estimation" title="IntensityGradientEstimation estimates the intensity gradient for a point cloud that contains position...">IntensityGradientEstimation</a> estimates the intensity gradient for a point cloud that contains position and intensity values. <a href="classpcl_1_1_intensity_gradient_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_intensity_spin_estimation">pcl::IntensitySpinEstimation&lt; PointInT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_intensity_spin_estimation" title="IntensitySpinEstimation estimates the intensity-domain spin image descriptors for a given point cloud...">IntensitySpinEstimation</a> estimates the intensity-domain spin image descriptors for a given point cloud dataset containing points and intensity. <a href="classpcl_1_1_intensity_spin_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_moment_invariants_estimation">pcl::MomentInvariantsEstimation&lt; PointInT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_moment_invariants_estimation" title="MomentInvariantsEstimation estimates the 3 moment invariants (j1, j2, j3) at each 3D point.">MomentInvariantsEstimation</a> estimates the 3 moment invariants (j1, j2, j3) at each 3D point. <a href="classpcl_1_1_moment_invariants_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_narf">pcl::Narf</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">NARF (<a class="el" href="structpcl_1_1_normal" title="A point structure representing normal coordinates and the surface curvature estimate.">Normal</a> Aligned Radial Features) is a point feature descriptor type for 3D data. <a href="classpcl_1_1_narf#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_narf_descriptor">pcl::NarfDescriptor</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b>Computes</b> NARF feature descriptors for points in a range image See B. <a href="classpcl_1_1_narf_descriptor#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_normal_estimation">pcl::NormalEstimation&lt; PointInT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_normal_estimation" title="NormalEstimation estimates local surface properties (surface normals and curvatures)at each 3D point.">NormalEstimation</a> estimates local surface properties (surface normals and curvatures)at each 3D point. <a href="classpcl_1_1_normal_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_normal_estimation_o_m_p">pcl::NormalEstimationOMP&lt; PointInT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_normal_estimation_o_m_p" title="NormalEstimationOMP estimates local surface properties at each 3D point, such as surface normals and ...">NormalEstimationOMP</a> estimates local surface properties at each 3D point, such as surface normals and curvatures, in parallel, using the OpenMP standard. <a href="classpcl_1_1_normal_estimation_o_m_p#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_o_u_r_c_v_f_h_estimation">pcl::OURCVFHEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_o_u_r_c_v_f_h_estimation" title="OURCVFHEstimation estimates the Oriented, Unique and Repetable Clustered Viewpoint Feature Histogram ...">OURCVFHEstimation</a> estimates the Oriented, Unique and Repetable Clustered Viewpoint <a class="el" href="classpcl_1_1_feature" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram" title="A point structure representing an N-D histogram.">Histogram</a> (CVFH) descriptor for a given point cloud dataset given XYZ data and normals, as presented in: <a href="classpcl_1_1_o_u_r_c_v_f_h_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_p_f_h_estimation">pcl::PFHEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_p_f_h_estimation" title="PFHEstimation estimates the Point Feature Histogram (PFH) descriptor for a given point cloud dataset ...">PFHEstimation</a> estimates the Point <a class="el" href="classpcl_1_1_feature" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram" title="A point structure representing an N-D histogram.">Histogram</a> (PFH) descriptor for a given point cloud dataset containing points and normals. <a href="classpcl_1_1_p_f_h_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_principal_curvatures_estimation">pcl::PrincipalCurvaturesEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_principal_curvatures_estimation" title="PrincipalCurvaturesEstimation estimates the directions (eigenvectors) and magnitudes (eigenvalues) of...">PrincipalCurvaturesEstimation</a> estimates the directions (eigenvectors) and magnitudes (eigenvalues) of principal surface curvatures for a given point cloud dataset containing points and normals. <a href="classpcl_1_1_principal_curvatures_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_range_image_border_extractor">pcl::RangeImageBorderExtractor</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b>Extract</b> obstacle borders from range images, meaning positions where there is a transition from foreground to background. <a href="classpcl_1_1_range_image_border_extractor#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_r_i_f_t_estimation">pcl::RIFTEstimation&lt; PointInT, GradientT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_r_i_f_t_estimation" title="RIFTEstimation estimates the Rotation Invariant Feature Transform descriptors for a given point cloud...">RIFTEstimation</a> estimates the Rotation Invariant <a class="el" href="classpcl_1_1_feature" title="Feature represents the base feature class.">Feature</a> Transform descriptors for a given point cloud dataset containing points and intensity. <a href="classpcl_1_1_r_i_f_t_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_r_s_d_estimation">pcl::RSDEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<b><a class="el" href="classpcl_1_1_r_s_d_estimation" title="RSDEstimation estimates the Radius-based Surface Descriptor (minimal and maximal radius of the local ...">RSDEstimation</a></b> estimates the Radius-based Surface Descriptor (minimal and maximal radius of the local surface's curves) for a given point cloud dataset containing points and normals. <a href="classpcl_1_1_r_s_d_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_estimation_base">pcl::SHOTEstimationBase&lt; PointInT, PointNT, PointOutT, PointRFT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_s_h_o_t_estimation" title="SHOTEstimation estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given po...">SHOTEstimation</a> estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given point cloud dataset containing points and normals. <a href="classpcl_1_1_s_h_o_t_estimation_base#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_estimation">pcl::SHOTEstimation&lt; PointInT, PointNT, PointOutT, PointRFT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_s_h_o_t_estimation" title="SHOTEstimation estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given po...">SHOTEstimation</a> estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given point cloud dataset containing points and normals. <a href="classpcl_1_1_s_h_o_t_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_color_estimation">pcl::SHOTColorEstimation&lt; PointInT, PointNT, PointOutT, PointRFT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_s_h_o_t_color_estimation" title="SHOTColorEstimation estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a giv...">SHOTColorEstimation</a> estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given point cloud dataset containing points, normals and colors. <a href="classpcl_1_1_s_h_o_t_color_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_local_reference_frame_estimation">pcl::SHOTLocalReferenceFrameEstimation&lt; PointInT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_s_h_o_t_local_reference_frame_estimation" title="SHOTLocalReferenceFrameEstimation estimates the Local Reference Frame used in the calculation of the ...">SHOTLocalReferenceFrameEstimation</a> estimates the Local Reference Frame used in the calculation of the (SHOT) descriptor. <a href="classpcl_1_1_s_h_o_t_local_reference_frame_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_local_reference_frame_estimation_o_m_p">pcl::SHOTLocalReferenceFrameEstimationOMP&lt; PointInT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_s_h_o_t_local_reference_frame_estimation" title="SHOTLocalReferenceFrameEstimation estimates the Local Reference Frame used in the calculation of the ...">SHOTLocalReferenceFrameEstimation</a> estimates the Local Reference Frame used in the calculation of the (SHOT) descriptor. <a href="classpcl_1_1_s_h_o_t_local_reference_frame_estimation_o_m_p#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_estimation_o_m_p">pcl::SHOTEstimationOMP&lt; PointInT, PointNT, PointOutT, PointRFT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_s_h_o_t_estimation_o_m_p" title="SHOTEstimationOMP estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given...">SHOTEstimationOMP</a> estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given point cloud dataset containing points and normals, in parallel, using the OpenMP standard. <a href="classpcl_1_1_s_h_o_t_estimation_o_m_p#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_s_h_o_t_color_estimation_o_m_p">pcl::SHOTColorEstimationOMP&lt; PointInT, PointNT, PointOutT, PointRFT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_s_h_o_t_color_estimation_o_m_p" title="SHOTColorEstimationOMP estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a ...">SHOTColorEstimationOMP</a> estimates the Signature of Histograms of OrienTations (SHOT) descriptor for a given point cloud dataset containing points, normals and colors, in parallel, using the OpenMP standard. <a href="classpcl_1_1_s_h_o_t_color_estimation_o_m_p#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_spin_image_estimation">pcl::SpinImageEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">Estimates spin-image descriptors in the given input points. <a href="classpcl_1_1_spin_image_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_unique_shape_context">pcl::UniqueShapeContext&lt; PointInT, PointOutT, PointRFT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_unique_shape_context" title="UniqueShapeContext implements the Unique Shape Context Descriptor described here:">UniqueShapeContext</a> implements the Unique Shape Context Descriptor described here: <a href="classpcl_1_1_unique_shape_context#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:">
<td class="memItemLeft" align="right" valign="top">class </td>
<td class="memItemRight" valign="bottom"><a class="el" href="classpcl_1_1_v_f_h_estimation">pcl::VFHEstimation&lt; PointInT, PointNT, PointOutT &gt;</a></td>
</tr> <tr class="memdesc:">
<td class="mdescLeft"> </td>
<td class="mdescRight">
<a class="el" href="classpcl_1_1_v_f_h_estimation" title="VFHEstimation estimates the Viewpoint Feature Histogram (VFH) descriptor for a given point cloud data...">VFHEstimation</a> estimates the <b>Viewpoint <a class="el" href="classpcl_1_1_feature" title="Feature represents the base feature class.">Feature</a> <a class="el" href="structpcl_1_1_histogram" title="A point structure representing an N-D histogram.">Histogram</a> (VFH)</b> descriptor for a given point cloud dataset containing points and normals. <a href="classpcl_1_1_v_f_h_estimation#details">More...</a><br>
</td>
</tr> <tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr> </table>
<table class="memberdecls"> <tr class="heading"><td colspan="2"><h2 class="groupheader">
<a name="func-members"></a> Functions</h2></td></tr> <tr class="memitem:gae5798e2ee9ef558efd8a9f1da82c5eb1">
<td class="memItemLeft" align="right" valign="top">void </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="group__features#gae5798e2ee9ef558efd8a9f1da82c5eb1">pcl::solvePlaneParameters</a> (const Eigen::Matrix3f &amp;covariance_matrix, const Eigen::Vector4f &amp;point, Eigen::Vector4f &amp;plane_parameters, float &amp;curvature)</td>
</tr> <tr class="memdesc:gae5798e2ee9ef558efd8a9f1da82c5eb1">
<td class="mdescLeft"> </td>
<td class="mdescRight">Solve the eigenvalues and eigenvectors of a given 3x3 covariance matrix, and estimate the least-squares plane normal and surface curvature. <a href="group__features#gae5798e2ee9ef558efd8a9f1da82c5eb1">More...</a><br>
</td>
</tr> <tr class="separator:gae5798e2ee9ef558efd8a9f1da82c5eb1"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga78bd0e1c11a8a299ef98209b6360f8fe">
<td class="memItemLeft" align="right" valign="top">void </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="group__features#ga78bd0e1c11a8a299ef98209b6360f8fe">pcl::solvePlaneParameters</a> (const Eigen::Matrix3f &amp;covariance_matrix, float &amp;nx, float &amp;ny, float &amp;nz, float &amp;curvature)</td>
</tr> <tr class="memdesc:ga78bd0e1c11a8a299ef98209b6360f8fe">
<td class="mdescLeft"> </td>
<td class="mdescRight">Solve the eigenvalues and eigenvectors of a given 3x3 covariance matrix, and estimate the least-squares plane normal and surface curvature. <a href="group__features#ga78bd0e1c11a8a299ef98209b6360f8fe">More...</a><br>
</td>
</tr> <tr class="separator:ga78bd0e1c11a8a299ef98209b6360f8fe"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:gacd392447cd77d22a66f1f7b885f923e1"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr> <tr class="memitem:gacd392447cd77d22a66f1f7b885f923e1">
<td class="memTemplItemLeft" align="right" valign="top">bool </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__features#gacd392447cd77d22a66f1f7b885f923e1">pcl::computePointNormal</a> (const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp;cloud, Eigen::Vector4f &amp;plane_parameters, float &amp;curvature)</td>
</tr> <tr class="memdesc:gacd392447cd77d22a66f1f7b885f923e1">
<td class="mdescLeft"> </td>
<td class="mdescRight">Compute the Least-Squares plane fit for a given set of points, and return the estimated plane parameters together with the surface curvature. <a href="group__features#gacd392447cd77d22a66f1f7b885f923e1">More...</a><br>
</td>
</tr> <tr class="separator:gacd392447cd77d22a66f1f7b885f923e1"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:gab0d3ced73abbf469ed7fd6f53a467226"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr> <tr class="memitem:gab0d3ced73abbf469ed7fd6f53a467226">
<td class="memTemplItemLeft" align="right" valign="top">bool </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__features#gab0d3ced73abbf469ed7fd6f53a467226">pcl::computePointNormal</a> (const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp;cloud, const <a class="el" href="https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;indices, Eigen::Vector4f &amp;plane_parameters, float &amp;curvature)</td>
</tr> <tr class="memdesc:gab0d3ced73abbf469ed7fd6f53a467226">
<td class="mdescLeft"> </td>
<td class="mdescRight">Compute the Least-Squares plane fit for a given set of points, using their indices, and return the estimated plane parameters together with the surface curvature. <a href="group__features#gab0d3ced73abbf469ed7fd6f53a467226">More...</a><br>
</td>
</tr> <tr class="separator:gab0d3ced73abbf469ed7fd6f53a467226"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga53df49d690e1cb76cd1f53495508bff1"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr> <tr class="memitem:ga53df49d690e1cb76cd1f53495508bff1">
<td class="memTemplItemLeft" align="right" valign="top">void </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__features#ga53df49d690e1cb76cd1f53495508bff1">pcl::flipNormalTowardsViewpoint</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &amp;point, float vp_x, float vp_y, float vp_z, Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;normal)</td>
</tr> <tr class="memdesc:ga53df49d690e1cb76cd1f53495508bff1">
<td class="mdescLeft"> </td>
<td class="mdescRight">Flip (in place) the estimated normal of a point towards a given viewpoint. <a href="group__features#ga53df49d690e1cb76cd1f53495508bff1">More...</a><br>
</td>
</tr> <tr class="separator:ga53df49d690e1cb76cd1f53495508bff1"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga56793b5c90e46de7c0ec910f505bca89"><td class="memTemplParams" colspan="2">template&lt;typename PointT , typename Scalar &gt; </td></tr> <tr class="memitem:ga56793b5c90e46de7c0ec910f505bca89">
<td class="memTemplItemLeft" align="right" valign="top">void </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__features#ga56793b5c90e46de7c0ec910f505bca89">pcl::flipNormalTowardsViewpoint</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &amp;point, float vp_x, float vp_y, float vp_z, Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;normal)</td>
</tr> <tr class="memdesc:ga56793b5c90e46de7c0ec910f505bca89">
<td class="mdescLeft"> </td>
<td class="mdescRight">Flip (in place) the estimated normal of a point towards a given viewpoint. <a href="group__features#ga56793b5c90e46de7c0ec910f505bca89">More...</a><br>
</td>
</tr> <tr class="separator:ga56793b5c90e46de7c0ec910f505bca89"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:gadc981cb599bd53b6f1d66e7fd932e493"><td class="memTemplParams" colspan="2">template&lt;typename PointT &gt; </td></tr> <tr class="memitem:gadc981cb599bd53b6f1d66e7fd932e493">
<td class="memTemplItemLeft" align="right" valign="top">void </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__features#gadc981cb599bd53b6f1d66e7fd932e493">pcl::flipNormalTowardsViewpoint</a> (const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &amp;point, float vp_x, float vp_y, float vp_z, float &amp;nx, float &amp;ny, float &amp;nz)</td>
</tr> <tr class="memdesc:gadc981cb599bd53b6f1d66e7fd932e493">
<td class="mdescLeft"> </td>
<td class="mdescRight">Flip (in place) the estimated normal of a point towards a given viewpoint. <a href="group__features#gadc981cb599bd53b6f1d66e7fd932e493">More...</a><br>
</td>
</tr> <tr class="separator:gadc981cb599bd53b6f1d66e7fd932e493"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:gaa356aaff8bfc2bdc2a472d80402da004"><td class="memTemplParams" colspan="2">template&lt;typename PointNT &gt; </td></tr> <tr class="memitem:gaa356aaff8bfc2bdc2a472d80402da004">
<td class="memTemplItemLeft" align="right" valign="top">bool </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__features#gaa356aaff8bfc2bdc2a472d80402da004">pcl::flipNormalTowardsNormalsMean</a> (<a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; PointNT &gt; const &amp;normal_cloud, <a class="el" href="https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> const &amp;normal_indices, Eigen::Vector3f &amp;normal)</td>
</tr> <tr class="memdesc:gaa356aaff8bfc2bdc2a472d80402da004">
<td class="mdescLeft"> </td>
<td class="mdescRight">Flip (in place) normal to get the same sign of the mean of the normals specified by normal_indices. <a href="group__features#gaa356aaff8bfc2bdc2a472d80402da004">More...</a><br>
</td>
</tr> <tr class="separator:gaa356aaff8bfc2bdc2a472d80402da004"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:gaacfebe0c36e7d879e48bd3f163aec3c9">
<td class="memItemLeft" align="right" valign="top">
<a class="el" href="https://pointclouds.org/documentation/pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool </td>
<td class="memItemRight" valign="bottom">
<a class="el" href="group__features#gaacfebe0c36e7d879e48bd3f163aec3c9">pcl::computePairFeatures</a> (const Eigen::Vector4f &amp;p1, const Eigen::Vector4f &amp;n1, const Eigen::Vector4f &amp;p2, const Eigen::Vector4f &amp;n2, float &amp;f1, float &amp;f2, float &amp;f3, float &amp;f4)</td>
</tr> <tr class="memdesc:gaacfebe0c36e7d879e48bd3f163aec3c9">
<td class="mdescLeft"> </td>
<td class="mdescRight">Compute the 4-tuple representation containing the three angles and one distance between two points represented by Cartesian coordinates and normals. <a href="group__features#gaacfebe0c36e7d879e48bd3f163aec3c9">More...</a><br>
</td>
</tr> <tr class="separator:gaacfebe0c36e7d879e48bd3f163aec3c9"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:gaa0c7f523d0882cc9e9a4273b0276d4ab"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr> <tr class="memitem:gaa0c7f523d0882cc9e9a4273b0276d4ab">
<td class="memTemplItemLeft" align="right" valign="top">void </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__features#gaa0c7f523d0882cc9e9a4273b0276d4ab">pcl::getFeaturePointCloud</a> (const std::vector&lt; Eigen::MatrixXf, Eigen::aligned_allocator&lt; Eigen::MatrixXf &gt; &gt; &amp;histograms2D, <a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_histogram">Histogram</a>&lt; N &gt; &gt; &amp;histogramsPC)</td>
</tr> <tr class="memdesc:gaa0c7f523d0882cc9e9a4273b0276d4ab">
<td class="mdescLeft"> </td>
<td class="mdescRight">Transform a list of 2D matrices into a point cloud containing the values in a vector (Histogram&lt;N&gt;). <a href="group__features#gaa0c7f523d0882cc9e9a4273b0276d4ab">More...</a><br>
</td>
</tr> <tr class="separator:gaa0c7f523d0882cc9e9a4273b0276d4ab"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:gaa1d42d8d792cf835ece2ee2a7cf7180a"><td class="memTemplParams" colspan="2">template&lt;typename PointInT , typename PointNT , typename PointOutT &gt; </td></tr> <tr class="memitem:gaa1d42d8d792cf835ece2ee2a7cf7180a">
<td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXf </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__features#gaa1d42d8d792cf835ece2ee2a7cf7180a">pcl::computeRSD</a> (const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; PointInT &gt; &amp;surface, const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; PointNT &gt; &amp;normals, const <a class="el" href="https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;indices, double max_dist, int nr_subdiv, double plane_radius, PointOutT &amp;radii, bool compute_histogram=false)</td>
</tr> <tr class="memdesc:gaa1d42d8d792cf835ece2ee2a7cf7180a">
<td class="mdescLeft"> </td>
<td class="mdescRight">Estimate the Radius-based Surface Descriptor (RSD) for a given point based on its spatial neighborhood of 3D points with normals. <a href="group__features#gaa1d42d8d792cf835ece2ee2a7cf7180a">More...</a><br>
</td>
</tr> <tr class="separator:gaa1d42d8d792cf835ece2ee2a7cf7180a"><td class="memSeparator" colspan="2"> </td></tr> <tr class="memitem:ga1dba4c4656c23b5fd76e26ec52460a30"><td class="memTemplParams" colspan="2">template&lt;typename PointNT , typename PointOutT &gt; </td></tr> <tr class="memitem:ga1dba4c4656c23b5fd76e26ec52460a30">
<td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXf </td>
<td class="memTemplItemRight" valign="bottom">
<a class="el" href="group__features#ga1dba4c4656c23b5fd76e26ec52460a30">pcl::computeRSD</a> (const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; PointNT &gt; &amp;normals, const <a class="el" href="https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp;indices, const std::vector&lt; float &gt; &amp;sqr_dists, double max_dist, int nr_subdiv, double plane_radius, PointOutT &amp;radii, bool compute_histogram=false)</td>
</tr> <tr class="memdesc:ga1dba4c4656c23b5fd76e26ec52460a30">
<td class="mdescLeft"> </td>
<td class="mdescRight">Estimate the Radius-based Surface Descriptor (RSD) for a given point based on its spatial neighborhood of 3D points with normals. <a href="group__features#ga1dba4c4656c23b5fd76e26ec52460a30">More...</a><br>
</td>
</tr> <tr class="separator:ga1dba4c4656c23b5fd76e26ec52460a30"><td class="memSeparator" colspan="2"> </td></tr> </table> <h2 class="groupheader">Function Documentation</h2> <a id="gaacfebe0c36e7d879e48bd3f163aec3c9"></a> <h2 class="memtitle">computePairFeatures()</h2> <div class="memitem"> <div class="memproto"> <table class="memname"> <tr> <td class="memname">
<a class="el" href="https://pointclouds.org/documentation/pcl__macros_8h.html#a2b443b7908f11aed38b620b570e5ebce">PCL_EXPORTS</a> bool pcl::computePairFeatures </td> <td>(</td> <td class="paramtype">const Eigen::Vector4f &amp; </td> <td class="paramname">
<em>p1</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const Eigen::Vector4f &amp; </td> <td class="paramname">
<em>n1</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const Eigen::Vector4f &amp; </td> <td class="paramname">
<em>p2</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const Eigen::Vector4f &amp; </td> <td class="paramname">
<em>n2</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>f1</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>f2</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>f3</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>f4</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/features/pfh_tools.h&gt;</code></p> <p>Compute the 4-tuple representation containing the three angles and one distance between two points represented by Cartesian coordinates and normals. </p> <dl class="section note">
<dt>Note</dt>
<dd>For explanations about the features, please see the literature mentioned above (the order of the features might be different). </dd>
</dl> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">p1</td>
<td>the first XYZ point </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">n1</td>
<td>the first surface normal </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">p2</td>
<td>the second XYZ point </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">n2</td>
<td>the second surface normal </td>
</tr> <tr>
<td class="paramdir">[out]</td>
<td class="paramname">f1</td>
<td>the first angular feature (angle between the projection of nq_idx and u) </td>
</tr> <tr>
<td class="paramdir">[out]</td>
<td class="paramname">f2</td>
<td>the second angular feature (angle between nq_idx and v) </td>
</tr> <tr>
<td class="paramdir">[out]</td>
<td class="paramname">f3</td>
<td>the third angular feature (angle between np_idx and |p_idx - q_idx|) </td>
</tr> <tr>
<td class="paramdir">[out]</td>
<td class="paramname">f4</td>
<td>the distance feature (p_idx - q_idx)</td>
</tr> </table> </dd> </dl> <dl class="section note">
<dt>Note</dt>
<dd>For efficiency reasons, we assume that the point data passed to the method is finite. </dd>
</dl> <p class="reference">Referenced by <a class="el" href="https://pointclouds.org/documentation/fpfh_8hpp_source.html#l00052">pcl::FPFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::computePairFeatures()</a>, <a class="el" href="https://pointclouds.org/documentation/pfh_8hpp_source.html#l00049">pcl::PFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::computePairFeatures()</a>, <a class="el" href="https://pointclouds.org/documentation/pfh_8hpp_source.html#l00061">pcl::PFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::computePointPFHSignature()</a>, <a class="el" href="https://pointclouds.org/documentation/vfh_8hpp_source.html#l00092">pcl::VFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::computePointSPFHSignature()</a>, and <a class="el" href="https://pointclouds.org/documentation/fpfh_8hpp_source.html#l00064">pcl::FPFHEstimation&lt; PointInT, PointNT, PointOutT &gt;::computePointSPFHSignature()</a>.</p> </div> </div> <a id="gab0d3ced73abbf469ed7fd6f53a467226"></a> <h2 class="memtitle">computePointNormal() <span class="overload">[1/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT &gt; </div> <table class="mlabels"> <tr> <td class="mlabels-left"> <table class="memname"> <tr> <td class="memname">bool pcl::computePointNormal </td> <td>(</td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp; </td> <td class="paramname">
<em>cloud</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp; </td> <td class="paramname">
<em>indices</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">Eigen::Vector4f &amp; </td> <td class="paramname">
<em>plane_parameters</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>curvature</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td class="mlabels-right"> <span class="mlabels"><span class="mlabel">inline</span></span> </td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/features/normal_3d.h&gt;</code></p> <p>Compute the Least-Squares plane fit for a given set of points, using their indices, and return the estimated plane parameters together with the surface curvature. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">cloud</td>
<td>the input point cloud </td>
</tr> <tr>
<td class="paramname">indices</td>
<td>the point cloud indices that need to be used </td>
</tr> <tr>
<td class="paramname">plane_parameters</td>
<td>the plane parameters as: a, b, c, d (ax + by + cz + d = 0) </td>
</tr> <tr>
<td class="paramname">curvature</td>
<td>the estimated surface curvature as a measure of <p class="formulaDsp"> <img class="formulaDsp" alt="\[ \lambda_0 / (\lambda_0 + \lambda_1 + \lambda_2) \]" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAAQBAMAAADjdJw9AAAAMFBMVEVHcEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlTPQ5AAAAD3RSTlMAXUjFuS6P6YBv0p6s9N1PMNQCAAABV0lEQVQoz8WSL0zDQBTGv627/htlXeYwLISEBLOGgCRZhiGoTiwYxNSwMwQkiiAgqUCSMDxiIwFJpkiwCDQK3YkJHO/eteu1ao4TX/u7fN/Lu3sH/NPqw1nKZys9U1Qa4xmVIOco4Oo4Mcr1pPaMUJBpllp81jyWY/7vsN4mMRhNYDf1tVkL+Mu6yVpTha9hka7nfQV8Y/VY3TZK9AkYaxG6mo9QaNgCNgAr5O5i0dmTsTWCrZEzoSPW6491n9E8QIYP/ep9kMRGs8rlHao+GnTondjCB3A1+BlEjHI3Rft1eIy5irnNIytswOWet/Hl4X3RFSHHErwRc4hYxS7QkrET6hnlT5xqMYlazB7SsOi65dWJCGaDmqRhGH6piRUvPEx9EvUYqPg0SgZAVYMORvSZSjBfgmzctLnv62idfyfjlmXVi5kwdPNPsJcj0UN5nKGzkKWe8h8TD0LjzyFmgwAAAABJRU5ErkJggg=="> </p> </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html#l00094">94</a> of file <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html">normal_3d.h</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/centroid_8hpp_source.html#l00485">pcl::computeMeanAndCovarianceMatrix()</a>, and <a class="el" href="https://pointclouds.org/documentation/feature_8hpp_source.html#l00052">pcl::solvePlaneParameters()</a>.</p> </div> </div> <a id="gacd392447cd77d22a66f1f7b885f923e1"></a> <h2 class="memtitle">computePointNormal() <span class="overload">[2/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT &gt; </div> <table class="mlabels"> <tr> <td class="mlabels-left"> <table class="memname"> <tr> <td class="memname">bool pcl::computePointNormal </td> <td>(</td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &gt; &amp; </td> <td class="paramname">
<em>cloud</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">Eigen::Vector4f &amp; </td> <td class="paramname">
<em>plane_parameters</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>curvature</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td class="mlabels-right"> <span class="mlabels"><span class="mlabel">inline</span></span> </td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/features/normal_3d.h&gt;</code></p> <p>Compute the Least-Squares plane fit for a given set of points, and return the estimated plane parameters together with the surface curvature. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">cloud</td>
<td>the input point cloud </td>
</tr> <tr>
<td class="paramname">plane_parameters</td>
<td>the plane parameters as: a, b, c, d (ax + by + cz + d = 0) </td>
</tr> <tr>
<td class="paramname">curvature</td>
<td>the estimated surface curvature as a measure of <p class="formulaDsp"> <img class="formulaDsp" alt="\[ \lambda_0 / (\lambda_0 + \lambda_1 + \lambda_2) \]" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAAQBAMAAADjdJw9AAAAMFBMVEVHcEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlTPQ5AAAAD3RSTlMAXUjFuS6P6YBv0p6s9N1PMNQCAAABV0lEQVQoz8WSL0zDQBTGv627/htlXeYwLISEBLOGgCRZhiGoTiwYxNSwMwQkiiAgqUCSMDxiIwFJpkiwCDQK3YkJHO/eteu1ao4TX/u7fN/Lu3sH/NPqw1nKZys9U1Qa4xmVIOco4Oo4Mcr1pPaMUJBpllp81jyWY/7vsN4mMRhNYDf1tVkL+Mu6yVpTha9hka7nfQV8Y/VY3TZK9AkYaxG6mo9QaNgCNgAr5O5i0dmTsTWCrZEzoSPW6491n9E8QIYP/ep9kMRGs8rlHao+GnTondjCB3A1+BlEjHI3Rft1eIy5irnNIytswOWet/Hl4X3RFSHHErwRc4hYxS7QkrET6hnlT5xqMYlazB7SsOi65dWJCGaDmqRhGH6piRUvPEx9EvUYqPg0SgZAVYMORvSZSjBfgmzctLnv62idfyfjlmXVi5kwdPNPsJcj0UN5nKGzkKWe8h8TD0LjzyFmgwAAAABJRU5ErkJggg=="> </p> </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html#l00061">61</a> of file <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html">normal_3d.h</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/centroid_8hpp_source.html#l00485">pcl::computeMeanAndCovarianceMatrix()</a>, <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00443">pcl::PointCloud&lt; PointT &gt;::size()</a>, and <a class="el" href="https://pointclouds.org/documentation/feature_8hpp_source.html#l00052">pcl::solvePlaneParameters()</a>.</p> <p class="reference">Referenced by <a class="el" href="https://pointclouds.org/documentation/normal__3d_8hpp_source.html#l00048">pcl::NormalEstimation&lt; PointInT, PointNT &gt;::computeFeature()</a>, <a class="el" href="https://pointclouds.org/documentation/integral__image__normal_8hpp_source.html#l00838">pcl::IntegralImageNormalEstimation&lt; pcl::PointXYZRGBA, pcl::Normal &gt;::computeFeatureFull()</a>, and <a class="el" href="https://pointclouds.org/documentation/integral__image__normal_8hpp_source.html#l01025">pcl::IntegralImageNormalEstimation&lt; pcl::PointXYZRGBA, pcl::Normal &gt;::computeFeaturePart()</a>.</p> </div> </div> <a id="gaa1d42d8d792cf835ece2ee2a7cf7180a"></a> <h2 class="memtitle">computeRSD() <span class="overload">[1/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointInT , typename PointNT , typename PointOutT &gt; </div> <table class="memname"> <tr> <td class="memname">Eigen::MatrixXf pcl::computeRSD </td> <td>(</td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; PointInT &gt; &amp; </td> <td class="paramname">
<em>surface</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; PointNT &gt; &amp; </td> <td class="paramname">
<em>normals</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp; </td> <td class="paramname">
<em>indices</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">double </td> <td class="paramname">
<em>max_dist</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">int </td> <td class="paramname">
<em>nr_subdiv</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">double </td> <td class="paramname">
<em>plane_radius</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">PointOutT &amp; </td> <td class="paramname">
<em>radii</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">bool </td> <td class="paramname">
<em>compute_histogram</em> = <code>false</code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/features/rsd.h&gt;</code></p> <p>Estimate the Radius-based Surface Descriptor (RSD) for a given point based on its spatial neighborhood of 3D points with normals. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">surface</td>
<td>the dataset containing the XYZ points </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">normals</td>
<td>the dataset containing the surface normals at each point in the dataset </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">indices</td>
<td>the neighborhood point indices in the dataset (first point is used as the reference) </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">max_dist</td>
<td>the upper bound for the considered distance interval </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">nr_subdiv</td>
<td>the number of subdivisions for the considered distance interval </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">plane_radius</td>
<td>maximum radius, above which everything can be considered planar </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">radii</td>
<td>the output point of a type that should have r_min and r_max fields </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">compute_histogram</td>
<td>if not false, the full neighborhood histogram is provided, usable as a point signature </td>
</tr> </table> </dd> </dl> <dl class="section note">
<dt>Note</dt>
<dd>: orientation is neglected!</dd> <dd> : we neglect points that are outside the specified interval!</dd>
</dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/rsd_8hpp_source.html#l00049">49</a> of file <a class="el" href="https://pointclouds.org/documentation/rsd_8hpp_source.html">rsd.hpp</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/pcl__macros_8h_source.html#l00201">M_PI</a>.</p> <p class="reference">Referenced by <a class="el" href="https://pointclouds.org/documentation/rsd_8hpp_source.html#l00248">pcl::RSDEstimation&lt; PointInT, PointNT, PointOutT &gt;::computeFeature()</a>.</p> </div> </div> <a id="ga1dba4c4656c23b5fd76e26ec52460a30"></a> <h2 class="memtitle">computeRSD() <span class="overload">[2/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointNT , typename PointOutT &gt; </div> <table class="memname"> <tr> <td class="memname">Eigen::MatrixXf pcl::computeRSD </td> <td>(</td> <td class="paramtype">const <a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; PointNT &gt; &amp; </td> <td class="paramname">
<em>normals</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const <a class="el" href="https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> &amp; </td> <td class="paramname">
<em>indices</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const std::vector&lt; float &gt; &amp; </td> <td class="paramname">
<em>sqr_dists</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">double </td> <td class="paramname">
<em>max_dist</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">int </td> <td class="paramname">
<em>nr_subdiv</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">double </td> <td class="paramname">
<em>plane_radius</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">PointOutT &amp; </td> <td class="paramname">
<em>radii</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">bool </td> <td class="paramname">
<em>compute_histogram</em> = <code>false</code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/features/rsd.h&gt;</code></p> <p>Estimate the Radius-based Surface Descriptor (RSD) for a given point based on its spatial neighborhood of 3D points with normals. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">normals</td>
<td>the dataset containing the surface normals at each point in the dataset </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">indices</td>
<td>the neighborhood point indices in the dataset (first point is used as the reference) </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">sqr_dists</td>
<td>the squared distances from the first to all points in the neighborhood </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">max_dist</td>
<td>the upper bound for the considered distance interval </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">nr_subdiv</td>
<td>the number of subdivisions for the considered distance interval </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">plane_radius</td>
<td>maximum radius, above which everything can be considered planar </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">radii</td>
<td>the output point of a type that should have r_min and r_max fields </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">compute_histogram</td>
<td>if not false, the full neighborhood histogram is provided, usable as a point signature </td>
</tr> </table> </dd> </dl> <dl class="section note">
<dt>Note</dt>
<dd>: orientation is neglected!</dd> <dd> : we neglect points that are outside the specified interval!</dd>
</dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/rsd_8hpp_source.html#l00149">149</a> of file <a class="el" href="https://pointclouds.org/documentation/rsd_8hpp_source.html">rsd.hpp</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/pcl__macros_8h_source.html#l00201">M_PI</a>.</p> </div> </div> <a id="gaa356aaff8bfc2bdc2a472d80402da004"></a> <h2 class="memtitle">flipNormalTowardsNormalsMean()</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointNT &gt; </div> <table class="mlabels"> <tr> <td class="mlabels-left"> <table class="memname"> <tr> <td class="memname">bool pcl::flipNormalTowardsNormalsMean </td> <td>(</td> <td class="paramtype">
<a class="el" href="classpcl_1_1_point_cloud">pcl::PointCloud</a>&lt; PointNT &gt; const &amp; </td> <td class="paramname">
<em>normal_cloud</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">
<a class="el" href="https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6">pcl::Indices</a> const &amp; </td> <td class="paramname">
<em>normal_indices</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">Eigen::Vector3f &amp; </td> <td class="paramname">
<em>normal</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td class="mlabels-right"> <span class="mlabels"><span class="mlabel">inline</span></span> </td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/features/normal_3d.h&gt;</code></p> <p>Flip (in place) normal to get the same sign of the mean of the normals specified by normal_indices. </p> <p>The method is described in: A. Petrelli, L. Di Stefano, "A repeatable and efficient canonical reference for surface matching", 3DimPVT, 2012 A. Petrelli, L. Di Stefano, "On the repeatability of the local reference frame for partial shape matching", 13th International Conference on Computer Vision (ICCV), 2011</p> <p>Normals should be unit vectors. Otherwise the resulting mean would be weighted by the normal norms. </p>
<dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">normal_cloud</td>
<td>Cloud of normals used to compute the mean </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">normal_indices</td>
<td>Indices of normals used to compute the mean </td>
</tr> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">normal</td>
<td>input <a class="el" href="structpcl_1_1_normal" title="A point structure representing normal coordinates and the surface curvature estimate.">Normal</a> to flip. <a class="el" href="structpcl_1_1_normal" title="A point structure representing normal coordinates and the surface curvature estimate.">Normal</a> is modified by the function. </td>
</tr> </table> </dd> </dl> <dl class="section return">
<dt>Returns</dt>
<dd>false if normal_indices does not contain any valid normal. </dd>
</dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html#l00204">204</a> of file <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html">normal_3d.h</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/point__tests_8h_source.html#l00055">pcl::isFinite()</a>.</p> </div> </div> <a id="ga56793b5c90e46de7c0ec910f505bca89"></a> <h2 class="memtitle">flipNormalTowardsViewpoint() <span class="overload">[1/3]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT , typename Scalar &gt; </div> <table class="mlabels"> <tr> <td class="mlabels-left"> <table class="memname"> <tr> <td class="memname">void pcl::flipNormalTowardsViewpoint </td> <td>(</td> <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &amp; </td> <td class="paramname">
<em>point</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>vp_x</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>vp_y</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>vp_z</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp; </td> <td class="paramname">
<em>normal</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td class="mlabels-right"> <span class="mlabels"><span class="mlabel">inline</span></span> </td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/features/normal_3d.h&gt;</code></p> <p>Flip (in place) the estimated normal of a point towards a given viewpoint. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">point</td>
<td>a given point </td>
</tr> <tr>
<td class="paramname">vp_x</td>
<td>the X coordinate of the viewpoint </td>
</tr> <tr>
<td class="paramname">vp_y</td>
<td>the X coordinate of the viewpoint </td>
</tr> <tr>
<td class="paramname">vp_z</td>
<td>the X coordinate of the viewpoint </td>
</tr> <tr>
<td class="paramname">normal</td>
<td>the plane normal to be flipped </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html#l00149">149</a> of file <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html">normal_3d.h</a>.</p> </div> </div> <a id="ga53df49d690e1cb76cd1f53495508bff1"></a> <h2 class="memtitle">flipNormalTowardsViewpoint() <span class="overload">[2/3]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT , typename Scalar &gt; </div> <table class="mlabels"> <tr> <td class="mlabels-left"> <table class="memname"> <tr> <td class="memname">void pcl::flipNormalTowardsViewpoint </td> <td>(</td> <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &amp; </td> <td class="paramname">
<em>point</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>vp_x</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>vp_y</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>vp_z</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp; </td> <td class="paramname">
<em>normal</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td class="mlabels-right"> <span class="mlabels"><span class="mlabel">inline</span></span> </td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/features/normal_3d.h&gt;</code></p> <p>Flip (in place) the estimated normal of a point towards a given viewpoint. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">point</td>
<td>a given point </td>
</tr> <tr>
<td class="paramname">vp_x</td>
<td>the X coordinate of the viewpoint </td>
</tr> <tr>
<td class="paramname">vp_y</td>
<td>the X coordinate of the viewpoint </td>
</tr> <tr>
<td class="paramname">vp_z</td>
<td>the X coordinate of the viewpoint </td>
</tr> <tr>
<td class="paramname">normal</td>
<td>the plane normal to be flipped </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html#l00122">122</a> of file <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html">normal_3d.h</a>.</p> <p class="reference">Referenced by <a class="el" href="https://pointclouds.org/documentation/from__meshes_8h_source.html#l00017">pcl::features::computeApproximateNormals()</a>, <a class="el" href="https://pointclouds.org/documentation/normal__3d_8hpp_source.html#l00048">pcl::NormalEstimation&lt; PointInT, PointNT &gt;::computeFeature()</a>, <a class="el" href="https://pointclouds.org/documentation/integral__image__normal_8hpp_source.html#l00207">pcl::IntegralImageNormalEstimation&lt; pcl::PointXYZRGBA, pcl::Normal &gt;::computePointNormal()</a>, and <a class="el" href="https://pointclouds.org/documentation/integral__image__normal_8hpp_source.html#l00462">pcl::IntegralImageNormalEstimation&lt; pcl::PointXYZRGBA, pcl::Normal &gt;::computePointNormalMirror()</a>.</p> </div> </div> <a id="gadc981cb599bd53b6f1d66e7fd932e493"></a> <h2 class="memtitle">flipNormalTowardsViewpoint() <span class="overload">[3/3]</span>
</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;typename PointT &gt; </div> <table class="mlabels"> <tr> <td class="mlabels-left"> <table class="memname"> <tr> <td class="memname">void pcl::flipNormalTowardsViewpoint </td> <td>(</td> <td class="paramtype">const <a class="el" href="structpcl_1_1_point_x_y_z_r_g_b">PointT</a> &amp; </td> <td class="paramname">
<em>point</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>vp_x</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>vp_y</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float </td> <td class="paramname">
<em>vp_z</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>nx</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>ny</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>nz</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td class="mlabels-right"> <span class="mlabels"><span class="mlabel">inline</span></span> </td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/features/normal_3d.h&gt;</code></p> <p>Flip (in place) the estimated normal of a point towards a given viewpoint. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">point</td>
<td>a given point </td>
</tr> <tr>
<td class="paramname">vp_x</td>
<td>the X coordinate of the viewpoint </td>
</tr> <tr>
<td class="paramname">vp_y</td>
<td>the X coordinate of the viewpoint </td>
</tr> <tr>
<td class="paramname">vp_z</td>
<td>the X coordinate of the viewpoint </td>
</tr> <tr>
<td class="paramname">nx</td>
<td>the resultant X component of the plane normal </td>
</tr> <tr>
<td class="paramname">ny</td>
<td>the resultant Y component of the plane normal </td>
</tr> <tr>
<td class="paramname">nz</td>
<td>the resultant Z component of the plane normal </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html#l00170">170</a> of file <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html">normal_3d.h</a>.</p> </div> </div> <a id="gaa0c7f523d0882cc9e9a4273b0276d4ab"></a> <h2 class="memtitle">getFeaturePointCloud()</h2> <div class="memitem"> <div class="memproto"> <div class="memtemplate"> template&lt;int N&gt; </div> <table class="memname"> <tr> <td class="memname">void pcl::getFeaturePointCloud </td> <td>(</td> <td class="paramtype">const std::vector&lt; Eigen::MatrixXf, Eigen::aligned_allocator&lt; Eigen::MatrixXf &gt; &gt; &amp; </td> <td class="paramname">
<em>histograms2D</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">
<a class="el" href="classpcl_1_1_point_cloud">PointCloud</a>&lt; <a class="el" href="structpcl_1_1_histogram">Histogram</a>&lt; N &gt; &gt; &amp; </td> <td class="paramname">
<em>histogramsPC</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/features/rsd.h&gt;</code></p> <p>Transform a list of 2D matrices into a point cloud containing the values in a vector (Histogram&lt;N&gt;). </p> <p>Can be used to transform the 2D histograms obtained in <a class="el" href="classpcl_1_1_r_s_d_estimation">RSDEstimation</a> into a point cloud. </p>
<dl class="section note">
<dt>Note</dt>
<dd>The template parameter N should be (greater or) equal to the product of the number of rows and columns. </dd>
</dl> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramdir">[in]</td>
<td class="paramname">histograms2D</td>
<td>the list of neighborhood 2D histograms </td>
</tr> <tr>
<td class="paramdir">[out]</td>
<td class="paramname">histogramsPC</td>
<td>the dataset containing the linearized matrices </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/rsd_8h_source.html#l00057">57</a> of file <a class="el" href="https://pointclouds.org/documentation/rsd_8h_source.html">rsd.h</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2point__cloud_8h_source.html#l00429">pcl::PointCloud&lt; PointT &gt;::begin()</a>.</p> </div> </div> <a id="gae5798e2ee9ef558efd8a9f1da82c5eb1"></a> <h2 class="memtitle">solvePlaneParameters() <span class="overload">[1/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <table class="mlabels"> <tr> <td class="mlabels-left"> <table class="memname"> <tr> <td class="memname">void pcl::solvePlaneParameters </td> <td>(</td> <td class="paramtype">const Eigen::Matrix3f &amp; </td> <td class="paramname">
<em>covariance_matrix</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">const Eigen::Vector4f &amp; </td> <td class="paramname">
<em>point</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">Eigen::Vector4f &amp; </td> <td class="paramname">
<em>plane_parameters</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>curvature</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td class="mlabels-right"> <span class="mlabels"><span class="mlabel">inline</span></span> </td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/features/feature.h&gt;</code></p> <p>Solve the eigenvalues and eigenvectors of a given 3x3 covariance matrix, and estimate the least-squares plane normal and surface curvature. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">covariance_matrix</td>
<td>the 3x3 covariance matrix </td>
</tr> <tr>
<td class="paramname">point</td>
<td>a point lying on the least-squares plane (SSE aligned) </td>
</tr> <tr>
<td class="paramname">plane_parameters</td>
<td>the resultant plane parameters as: a, b, c, d (ax + by + cz + d = 0) </td>
</tr> <tr>
<td class="paramname">curvature</td>
<td>the estimated surface curvature as a measure of <p class="formulaDsp"> <img class="formulaDsp" alt="\[ \lambda_0 / (\lambda_0 + \lambda_1 + \lambda_2) \]" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAAQBAMAAADjdJw9AAAAMFBMVEVHcEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlTPQ5AAAAD3RSTlMAXUjFuS6P6YBv0p6s9N1PMNQCAAABV0lEQVQoz8WSL0zDQBTGv627/htlXeYwLISEBLOGgCRZhiGoTiwYxNSwMwQkiiAgqUCSMDxiIwFJpkiwCDQK3YkJHO/eteu1ao4TX/u7fN/Lu3sH/NPqw1nKZys9U1Qa4xmVIOco4Oo4Mcr1pPaMUJBpllp81jyWY/7vsN4mMRhNYDf1tVkL+Mu6yVpTha9hka7nfQV8Y/VY3TZK9AkYaxG6mo9QaNgCNgAr5O5i0dmTsTWCrZEzoSPW6491n9E8QIYP/ep9kMRGs8rlHao+GnTondjCB3A1+BlEjHI3Rft1eIy5irnNIytswOWet/Hl4X3RFSHHErwRc4hYxS7QkrET6hnlT5xqMYlazB7SsOi65dWJCGaDmqRhGH6piRUvPEx9EvUYqPg0SgZAVYMORvSZSjBfgmzctLnv62idfyfjlmXVi5kwdPNPsJcj0UN5nKGzkKWe8h8TD0LjzyFmgwAAAABJRU5ErkJggg=="> </p> </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/feature_8hpp_source.html#l00052">52</a> of file <a class="el" href="https://pointclouds.org/documentation/feature_8hpp_source.html">feature.hpp</a>.</p> <p class="reference">Referenced by <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html#l00061">pcl::computePointNormal()</a>, and <a class="el" href="https://pointclouds.org/documentation/features_2include_2pcl_2features_2normal__3d_8h_source.html#l00284">pcl::NormalEstimation&lt; PointInT, PointNT &gt;::computePointNormal()</a>.</p> </div> </div> <a id="ga78bd0e1c11a8a299ef98209b6360f8fe"></a> <h2 class="memtitle">solvePlaneParameters() <span class="overload">[2/2]</span>
</h2> <div class="memitem"> <div class="memproto"> <table class="mlabels"> <tr> <td class="mlabels-left"> <table class="memname"> <tr> <td class="memname">void pcl::solvePlaneParameters </td> <td>(</td> <td class="paramtype">const Eigen::Matrix3f &amp; </td> <td class="paramname">
<em>covariance_matrix</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>nx</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>ny</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>nz</em>, </td> </tr> <tr> <td class="paramkey"></td> <td></td> <td class="paramtype">float &amp; </td> <td class="paramname">
<em>curvature</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td class="mlabels-right"> <span class="mlabels"><span class="mlabel">inline</span></span> </td> </tr> </table> </div>
<div class="memdoc"> <p><code>#include &lt;pcl/features/feature.h&gt;</code></p> <p>Solve the eigenvalues and eigenvectors of a given 3x3 covariance matrix, and estimate the least-squares plane normal and surface curvature. </p> <dl class="params">
<dt>Parameters</dt>
<dd> <table class="params"> <tr>
<td class="paramname">covariance_matrix</td>
<td>the 3x3 covariance matrix </td>
</tr> <tr>
<td class="paramname">nx</td>
<td>the resultant X component of the plane normal </td>
</tr> <tr>
<td class="paramname">ny</td>
<td>the resultant Y component of the plane normal </td>
</tr> <tr>
<td class="paramname">nz</td>
<td>the resultant Z component of the plane normal </td>
</tr> <tr>
<td class="paramname">curvature</td>
<td>the estimated surface curvature as a measure of <p class="formulaDsp"> <img class="formulaDsp" alt="\[ \lambda_0 / (\lambda_0 + \lambda_1 + \lambda_2) \]" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAAAQBAMAAADjdJw9AAAAMFBMVEVHcEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlTPQ5AAAAD3RSTlMAXUjFuS6P6YBv0p6s9N1PMNQCAAABV0lEQVQoz8WSL0zDQBTGv627/htlXeYwLISEBLOGgCRZhiGoTiwYxNSwMwQkiiAgqUCSMDxiIwFJpkiwCDQK3YkJHO/eteu1ao4TX/u7fN/Lu3sH/NPqw1nKZys9U1Qa4xmVIOco4Oo4Mcr1pPaMUJBpllp81jyWY/7vsN4mMRhNYDf1tVkL+Mu6yVpTha9hka7nfQV8Y/VY3TZK9AkYaxG6mo9QaNgCNgAr5O5i0dmTsTWCrZEzoSPW6491n9E8QIYP/ep9kMRGs8rlHao+GnTondjCB3A1+BlEjHI3Rft1eIy5irnNIytswOWet/Hl4X3RFSHHErwRc4hYxS7QkrET6hnlT5xqMYlazB7SsOi65dWJCGaDmqRhGH6piRUvPEx9EvUYqPg0SgZAVYMORvSZSjBfgmzctLnv62idfyfjlmXVi5kwdPNPsJcj0UN5nKGzkKWe8h8TD0LjzyFmgwAAAABJRU5ErkJggg=="> </p> </td>
</tr> </table> </dd> </dl> <p class="definition">Definition at line <a class="el" href="https://pointclouds.org/documentation/feature_8hpp_source.html#l00065">65</a> of file <a class="el" href="https://pointclouds.org/documentation/feature_8hpp_source.html">feature.hpp</a>.</p> <p class="reference">References <a class="el" href="https://pointclouds.org/documentation/common_2include_2pcl_2common_2impl_2eigen_8hpp_source.html#l00296">pcl::eigen33()</a>.</p> </div> </div> <div class="_attribution">
  <p class="_attribution-p">
    © 2009–2012, Willow Garage, Inc.<br>© 2012–, Open Perception, Inc.<br>Licensed under the BSD License.<br>
    <a href="https://pointclouds.org/documentation/group__features.html" class="_attribution-link">https://pointclouds.org/documentation/group__features.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
