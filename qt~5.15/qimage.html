
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>QImage (Class) - Qt 5.15 - W3cubDocs</title>
  
  <meta name="description" content="The QImage class provides a hardware-independent image representation that allows direct access to the pixel data, and can be used as a paint device &hellip;">
  <meta name="keywords" content="qimage, class, qt, qt~5.15">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/qt~5.15/qimage.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/qt~5.15.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt~5.15/" class="_nav-link" title="" style="margin-left:0;">Qt 5.15</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">QImage Class</h1>  <p>The QImage class provides a hardware-independent image representation that allows direct access to the pixel data, and can be used as a paint device. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QImage&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += gui</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qpaintdevice">QPaintDevice</a>
</td>
</tr>
</table>
<ul> <li><a href="https://doc.qt.io/qt-5.15/qimage-members.html">List of all members, including inherited members</a></li> <li><a href="https://doc.qt.io/qt-5.15/qimage-obsolete.html">Obsolete members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="threads-reentrancy">reentrant</a>.</p>  <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#Format-enum">Format</a></b> { Format_Invalid, Format_Mono, Format_MonoLSB, Format_Indexed8, Format_RGB32, â€¦, Format_BGR888 }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#InvertMode-enum">InvertMode</a></b> { InvertRgb, InvertRgba }</td>
</tr> </table>  <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#QImage-10">QImage</a></b>(QImage &amp;&amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#QImage-9">QImage</a></b>(const QImage &amp;<i>image</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#QImage-8">QImage</a></b>(const QString &amp;<i>fileName</i>, const char *<i>format</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#QImage-7">QImage</a></b>(const char *const [] <i>xpm</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#QImage-6">QImage</a></b>(const uchar *<i>data</i>, int <i>width</i>, int <i>height</i>, int <i>bytesPerLine</i>, QImage::Format <i>format</i>, QImageCleanupFunction <i>cleanupFunction</i> = nullptr, void *<i>cleanupInfo</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#QImage-5">QImage</a></b>(uchar *<i>data</i>, int <i>width</i>, int <i>height</i>, int <i>bytesPerLine</i>, QImage::Format <i>format</i>, QImageCleanupFunction <i>cleanupFunction</i> = nullptr, void *<i>cleanupInfo</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#QImage-4">QImage</a></b>(const uchar *<i>data</i>, int <i>width</i>, int <i>height</i>, QImage::Format <i>format</i>, QImageCleanupFunction <i>cleanupFunction</i> = nullptr, void *<i>cleanupInfo</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#QImage-3">QImage</a></b>(uchar *<i>data</i>, int <i>width</i>, int <i>height</i>, QImage::Format <i>format</i>, QImageCleanupFunction <i>cleanupFunction</i> = nullptr, void *<i>cleanupInfo</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#QImage-2">QImage</a></b>(int <i>width</i>, int <i>height</i>, QImage::Format <i>format</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#QImage-1">QImage</a></b>(const QSize &amp;<i>size</i>, QImage::Format <i>format</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#QImage">QImage</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#operator-eq-1">operator=</a></b>(QImage &amp;&amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#operator-eq">operator=</a></b>(const QImage &amp;<i>image</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#dtor.QImage">~QImage</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#allGray">allGray</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#applyColorTransform">applyColorTransform</a></b>(const QColorTransform &amp;<i>transform</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#bitPlaneCount">bitPlaneCount</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar *</td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#bits">bits</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const uchar *</td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#bits-1">bits</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#bytesPerLine">bytesPerLine</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qint64 </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#cacheKey">cacheKey</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRgb </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#color">color</a></b>(int <i>i</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#colorCount">colorCount</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QColorSpace </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#colorSpace">colorSpace</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QVector&lt;QRgb&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#colorTable">colorTable</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const uchar *</td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#constBits">constBits</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const uchar *</td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#constScanLine">constScanLine</a></b>(int <i>i</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#convertTo">convertTo</a></b>(QImage::Format <i>format</i>, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#convertToColorSpace">convertToColorSpace</a></b>(const QColorSpace &amp;<i>colorSpace</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#convertToFormat">convertToFormat</a></b>(QImage::Format <i>format</i>, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor) const &amp;</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#convertToFormat-1">convertToFormat</a></b>(QImage::Format <i>format</i>, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor) &amp;&amp;</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#convertToFormat-2">convertToFormat</a></b>(QImage::Format <i>format</i>, const QVector&lt;QRgb&gt; &amp;<i>colorTable</i>, Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#convertedToColorSpace">convertedToColorSpace</a></b>(const QColorSpace &amp;<i>colorSpace</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#copy">copy</a></b>(const QRect &amp;<i>rectangle</i> = QRect()) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#copy-1">copy</a></b>(int <i>x</i>, int <i>y</i>, int <i>width</i>, int <i>height</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#createAlphaMask">createAlphaMask</a></b>(Qt::ImageConversionFlags <i>flags</i> = Qt::AutoColor) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#createHeuristicMask">createHeuristicMask</a></b>(bool <i>clipTight</i> = true) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#createMaskFromColor">createMaskFromColor</a></b>(QRgb <i>color</i>, Qt::MaskMode <i>mode</i> = Qt::MaskInColor) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#depth">depth</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qreal </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#devicePixelRatio">devicePixelRatio</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#dotsPerMeterX">dotsPerMeterX</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#dotsPerMeterY">dotsPerMeterY</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#fill">fill</a></b>(uint <i>pixelValue</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#fill-1">fill</a></b>(const QColor &amp;<i>color</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#fill-2">fill</a></b>(Qt::GlobalColor <i>color</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage::Format </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#format">format</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#hasAlphaChannel">hasAlphaChannel</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#height">height</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#invertPixels">invertPixels</a></b>(QImage::InvertMode <i>mode</i> = InvertRgb)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#isGrayscale">isGrayscale</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#isNull">isNull</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#load">load</a></b>(const QString &amp;<i>fileName</i>, const char *<i>format</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#load-1">load</a></b>(QIODevice *<i>device</i>, const char *<i>format</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#loadFromData">loadFromData</a></b>(const uchar *<i>data</i>, int <i>len</i>, const char *<i>format</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#loadFromData-1">loadFromData</a></b>(const QByteArray &amp;<i>data</i>, const char *<i>format</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#mirrored">mirrored</a></b>(bool <i>horizontal</i> = false, bool <i>vertical</i> = true) const &amp;</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage &amp;&amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#mirrored-1">mirrored</a></b>(bool <i>horizontal</i> = false, bool <i>vertical</i> = true) &amp;&amp;</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPoint </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#offset">offset</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRgb </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#pixel">pixel</a></b>(const QPoint &amp;<i>position</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRgb </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#pixel-1">pixel</a></b>(int <i>x</i>, int <i>y</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QColor </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#pixelColor">pixelColor</a></b>(const QPoint &amp;<i>position</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QColor </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#pixelColor-1">pixelColor</a></b>(int <i>x</i>, int <i>y</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#pixelFormat">pixelFormat</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#pixelIndex">pixelIndex</a></b>(const QPoint &amp;<i>position</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#pixelIndex-1">pixelIndex</a></b>(int <i>x</i>, int <i>y</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QRect </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#rect">rect</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#reinterpretAsFormat">reinterpretAsFormat</a></b>(QImage::Format <i>format</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#rgbSwapped">rgbSwapped</a></b>() const &amp;</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage &amp;&amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#rgbSwapped-1">rgbSwapped</a></b>() &amp;&amp;</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#save">save</a></b>(const QString &amp;<i>fileName</i>, const char *<i>format</i> = nullptr, int <i>quality</i> = -1) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#save-1">save</a></b>(QIODevice *<i>device</i>, const char *<i>format</i> = nullptr, int <i>quality</i> = -1) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#scaled">scaled</a></b>(const QSize &amp;<i>size</i>, Qt::AspectRatioMode <i>aspectRatioMode</i> = Qt::IgnoreAspectRatio, Qt::TransformationMode <i>transformMode</i> = Qt::FastTransformation) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#scaled-1">scaled</a></b>(int <i>width</i>, int <i>height</i>, Qt::AspectRatioMode <i>aspectRatioMode</i> = Qt::IgnoreAspectRatio, Qt::TransformationMode <i>transformMode</i> = Qt::FastTransformation) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#scaledToHeight">scaledToHeight</a></b>(int <i>height</i>, Qt::TransformationMode <i>mode</i> = Qt::FastTransformation) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#scaledToWidth">scaledToWidth</a></b>(int <i>width</i>, Qt::TransformationMode <i>mode</i> = Qt::FastTransformation) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> uchar *</td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#scanLine">scanLine</a></b>(int <i>i</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const uchar *</td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#scanLine-1">scanLine</a></b>(int <i>i</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setAlphaChannel">setAlphaChannel</a></b>(const QImage &amp;<i>alphaChannel</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setColor">setColor</a></b>(int <i>index</i>, QRgb <i>colorValue</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setColorCount">setColorCount</a></b>(int <i>colorCount</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setColorSpace">setColorSpace</a></b>(const QColorSpace &amp;<i>colorSpace</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setColorTable">setColorTable</a></b>(const QVector&lt;QRgb&gt; <i>colors</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setDevicePixelRatio">setDevicePixelRatio</a></b>(qreal <i>scaleFactor</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setDotsPerMeterX">setDotsPerMeterX</a></b>(int <i>x</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setDotsPerMeterY">setDotsPerMeterY</a></b>(int <i>y</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setOffset">setOffset</a></b>(const QPoint &amp;<i>offset</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setPixel">setPixel</a></b>(const QPoint &amp;<i>position</i>, uint <i>index_or_rgb</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setPixel-1">setPixel</a></b>(int <i>x</i>, int <i>y</i>, uint <i>index_or_rgb</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setPixelColor">setPixelColor</a></b>(const QPoint &amp;<i>position</i>, const QColor &amp;<i>color</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setPixelColor-1">setPixelColor</a></b>(int <i>x</i>, int <i>y</i>, const QColor &amp;<i>color</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#setText">setText</a></b>(const QString &amp;<i>key</i>, const QString &amp;<i>text</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QSize </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#size">size</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#sizeInBytes">sizeInBytes</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#swap">swap</a></b>(QImage &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#text">text</a></b>(const QString &amp;<i>key</i> = QString()) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QStringList </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#textKeys">textKeys</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> CGImageRef </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#toCGImage">toCGImage</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#transformed-1">transformed</a></b>(const QTransform &amp;<i>matrix</i>, Qt::TransformationMode <i>mode</i> = Qt::FastTransformation) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#valid">valid</a></b>(const QPoint &amp;<i>pos</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#valid-1">valid</a></b>(int <i>x</i>, int <i>y</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#width">width</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QVariant </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#operator-QVariant">operator QVariant</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#operator-not-eq">operator!=</a></b>(const QImage &amp;<i>image</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#operator-eq-eq">operator==</a></b>(const QImage &amp;<i>image</i>) const</td>
</tr> </table>  <h2 id="static-public-members">Static Public Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#fromData">fromData</a></b>(const uchar *<i>data</i>, int <i>size</i>, const char *<i>format</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#fromData-1">fromData</a></b>(const QByteArray &amp;<i>data</i>, const char *<i>format</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage::Format </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#toImageFormat">toImageFormat</a></b>(QPixelFormat <i>format</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QPixelFormat </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#toPixelFormat">toPixelFormat</a></b>(QImage::Format <i>format</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QTransform </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#trueMatrix-1">trueMatrix</a></b>(const QTransform &amp;<i>matrix</i>, int <i>width</i>, int <i>height</i>)</td>
</tr> </table>  <h2 id="protected-functions">Protected Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> QImage </td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#smoothScaled">smoothScaled</a></b>(int <i>w</i>, int <i>h</i>) const</td>
</tr> </table>  <h2 id="related-non-members">Related Non-Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> typedef </td>
<td class="memItemRight bottomAlign"><b><a href="qimage#QImageCleanupFunction-typedef">QImageCleanupFunction</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#operator-lt-lt-21">operator&lt;&lt;</a></b>(QDataStream &amp;<i>stream</i>, const QImage &amp;<i>image</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qimage#operator-gt-gt">operator&gt;&gt;</a></b>(QDataStream &amp;<i>stream</i>, QImage &amp;<i>image</i>)</td>
</tr> </table>    <h2 id="details">Detailed Description
</h2> <p>Qt provides four classes for handling image data: QImage, <a href="qpixmap">QPixmap</a>, <a href="qbitmap">QBitmap</a> and <a href="qpicture">QPicture</a>. QImage is designed and optimized for I/O, and for direct pixel access and manipulation, while <a href="qpixmap">QPixmap</a> is designed and optimized for showing images on screen. <a href="qbitmap">QBitmap</a> is only a convenience class that inherits <a href="qpixmap">QPixmap</a>, ensuring a depth of 1. Finally, the <a href="qpicture">QPicture</a> class is a paint device that records and replays <a href="qpainter">QPainter</a> commands.</p> <p>Because QImage is a <a href="qpaintdevice">QPaintDevice</a> subclass, <a href="qpainter">QPainter</a> can be used to draw directly onto images. When using <a href="qpainter">QPainter</a> on a QImage, the painting can be performed in another thread than the current GUI thread.</p> <p>The QImage class supports several image formats described by the <a href="qimage#Format-enum">Format</a> enum. These include monochrome, 8-bit, 32-bit and alpha-blended images which are available in all versions of Qt 4.x.</p> <p>QImage provides a collection of functions that can be used to obtain a variety of information about the image. There are also several functions that enables transformation of the image.</p> <p>QImage objects can be passed around by value since the QImage class uses <a href="implicit-sharing">implicit data sharing</a>. QImage objects can also be streamed and compared.</p> <p><b>Note: </b>If you would like to load QImage objects in a static build of Qt, refer to the <a href="plugins-howto">Plugin HowTo</a>.</p> <p><b>Warning:</b> Painting on a QImage with the format <a href="qimage#Format-enum">QImage::Format_Indexed8</a> is not supported.</p>  <h3 id="reading-and-writing-image-files">Reading and Writing Image Files
</h3> <p>QImage provides several ways of loading an image file: The file can be loaded when constructing the QImage object, or by using the <a href="qimage#load">load</a>() or <a href="qimage#loadFromData">loadFromData</a>() functions later on. QImage also provides the static <a href="qimage#fromData">fromData</a>() function, constructing a QImage from the given data. When loading an image, the file name can either refer to an actual file on disk or to one of the application's embedded resources. See <a href="resources">The Qt Resource System</a> overview for details on how to embed images and other resource files in the application's executable.</p> <p>Simply call the <a href="qimage#save">save</a>() function to save a QImage object.</p> <p>The complete list of supported file formats are available through the <a href="qimagereader#supportedImageFormats">QImageReader::supportedImageFormats</a>() and <a href="qimagewriter#supportedImageFormats">QImageWriter::supportedImageFormats</a>() functions. New file formats can be added as plugins. By default, Qt supports the following formats:</p> <table class="generic"> <thead><tr class="qt-style">
<th>Format</th>
<th>Description</th>
<th>Qt's support</th>
</tr></thead> <tr class="odd" valign="top">
<td>BMP</td>
<td>Windows Bitmap</td>
<td>Read/write</td>
</tr> <tr class="even" valign="top">
<td>GIF</td>
<td>Graphic Interchange Format (optional)</td>
<td>Read</td>
</tr> <tr class="odd" valign="top">
<td>JPG</td>
<td>Joint Photographic Experts Group</td>
<td>Read/write</td>
</tr> <tr class="even" valign="top">
<td>JPEG</td>
<td>Joint Photographic Experts Group</td>
<td>Read/write</td>
</tr> <tr class="odd" valign="top">
<td>PNG</td>
<td>Portable Network Graphics</td>
<td>Read/write</td>
</tr> <tr class="even" valign="top">
<td>PBM</td>
<td>Portable Bitmap</td>
<td>Read</td>
</tr> <tr class="odd" valign="top">
<td>PGM</td>
<td>Portable Graymap</td>
<td>Read</td>
</tr> <tr class="even" valign="top">
<td>PPM</td>
<td>Portable Pixmap</td>
<td>Read/write</td>
</tr> <tr class="odd" valign="top">
<td>XBM</td>
<td>X11 Bitmap</td>
<td>Read/write</td>
</tr> <tr class="even" valign="top">
<td>XPM</td>
<td>X11 Pixmap</td>
<td>Read/write</td>
</tr> </table>  <h3 id="image-information">Image Information
</h3> <p>QImage provides a collection of functions that can be used to obtain a variety of information about the image:</p> <table class="generic"> <thead><tr class="qt-style">
<th></th>
<th>Available Functions</th>
</tr></thead> <tr class="odd" valign="top">
<td>Geometry</td>
<td>The <a href="qimage#size">size</a>(), <a href="qimage#width">width</a>(), <a href="qimage#height">height</a>(), <a href="qimage#dotsPerMeterX">dotsPerMeterX</a>(), and <a href="qimage#dotsPerMeterY">dotsPerMeterY</a>() functions provide information about the image size and aspect ratio.<p>The <a href="qimage#rect">rect</a>() function returns the image's enclosing rectangle. The <a href="qimage#valid">valid</a>() function tells if a given pair of coordinates is within this rectangle. The <a href="qimage#offset">offset</a>() function returns the number of pixels by which the image is intended to be offset by when positioned relative to other images, which also can be manipulated using the <a href="qimage#setOffset">setOffset</a>() function.</p> </td>
</tr> <tr class="even" valign="top">
<td>Colors</td>
<td>The color of a pixel can be retrieved by passing its coordinates to the <a href="qimage#pixel">pixel</a>() function. The <a href="qimage#pixel">pixel</a>() function returns the color as a <a href="qcolor#QRgb-typedef">QRgb</a> value indepedent of the image's format.<p>In case of monochrome and 8-bit images, the <a href="qimage#colorCount">colorCount</a>() and <a href="qimage#colorTable">colorTable</a>() functions provide information about the color components used to store the image data: The <a href="qimage#colorTable">colorTable</a>() function returns the image's entire color table. To obtain a single entry, use the <a href="qimage#pixelIndex">pixelIndex</a>() function to retrieve the pixel index for a given pair of coordinates, then use the <a href="qimage#color">color</a>() function to retrieve the color. Note that if you create an 8-bit image manually, you have to set a valid color table on the image as well.</p> <p>The <a href="qimage#hasAlphaChannel">hasAlphaChannel</a>() function tells if the image's format respects the alpha channel, or not. The <a href="qimage#allGray">allGray</a>() and <a href="qimage#isGrayscale">isGrayscale</a>() functions tell whether an image's colors are all shades of gray.</p> <p>See also the <a href="qimage#pixel-manipulation">Pixel Manipulation</a> and <a href="qimage#image-transformations">Image Transformations</a> sections.</p> </td>
</tr> <tr class="odd" valign="top">
<td>Text</td>
<td>The <a href="qimage#text">text</a>() function returns the image text associated with the given text key. An image's text keys can be retrieved using the <a href="qimage#textKeys">textKeys</a>() function. Use the <a href="qimage#setText">setText</a>() function to alter an image's text.</td>
</tr> <tr class="even" valign="top">
<td>Low-level information</td>
<td>The <a href="qimage#depth">depth</a>() function returns the depth of the image. The supported depths are 1 (monochrome), 8, 16, 24 and 32 bits. The <a href="qimage#bitPlaneCount">bitPlaneCount</a>() function tells how many of those bits that are used. For more information see the <a href="qimage#image-formats">Image Formats</a> section.<p>The <a href="qimage#format">format</a>(), <a href="qimage#bytesPerLine">bytesPerLine</a>(), and <a href="qimage#sizeInBytes">sizeInBytes</a>() functions provide low-level information about the data stored in the image.</p> <p>The <a href="qimage#cacheKey">cacheKey</a>() function returns a number that uniquely identifies the contents of this QImage object.</p> </td>
</tr> </table>  <h3 id="pixel-manipulation">Pixel Manipulation
</h3> <p>The functions used to manipulate an image's pixels depend on the image format. The reason is that monochrome and 8-bit images are index-based and use a color lookup table, while 32-bit images store ARGB values directly. For more information on image formats, see the <a href="qimage#image-formats">Image Formats</a> section.</p> <p>In case of a 32-bit image, the <a href="qimage#setPixel">setPixel</a>() function can be used to alter the color of the pixel at the given coordinates to any other color specified as an ARGB quadruplet. To make a suitable <a href="qcolor#QRgb-typedef">QRgb</a> value, use the <a href="qcolor#qRgb">qRgb</a>() (adding a default alpha component to the given RGB values, i.e. creating an opaque color) or <a href="qcolor#qRgba">qRgba</a>() function. For example:</p> <table class="generic"> <thead><tr class="qt-style"><th colspan="2">32-bit</th></tr></thead> <tr class="odd" valign="top">
<td><img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARwAAAEcCAMAAAAiKvvSAAADAFBMVEV5oib8/fz+/v67kyX8/fx4oSXsujL+/v79/f39/f3////ruTF6oid5oSb7/PsCAgF7oyhOTk7tuzL///+9lSd8pCy8lCbsuzR6oyd4oiW+lirrujL///4gKQ1qe0jtvTupwnq+ly39/vnBnTeQsUyBpzNnZ2e9lSdnZ2d3oCXf49b///vtvDWFqjl7pSaEqTfIqFBDNApNTUz4+PX+/v0dKQiTs1EfLAb9//2zy3/yzWnEmifp16KGqzztwUesx3WarXXEoD3GpEVeXl66kiXtwUtuZU3Alyfr6+sRGAXp6eloaGiviiPj5dy5ublbShwrOg1ldkGHahvJqVJymCNulCLPtWm5sZuenXnkszDNxpu5s524uLjRt2/GoDmlpaXuwkvMxZphgx5IYRamgyJPahhUcBlMPBBgTBNXdRtoUhRefh1rY0xaWU7uwkpreFHMxZlibE7JyMCLi4v/99j+/v7///7///+8lCZ6oyftuzO9lSf9/fzs7Oz8/Pv6+/oWFhb7+fZ+pS4AAAB5oiYxQRHtujLsuTILCwubulxmbla7kyXtvDn4+fft7e36+fn///uKrUKBrSj8/PoVFRQHBwF/qij6/fMqIANcShZ9qCeHrD2xy319c1j///MpMxafppPLsmvt0IGUtFLcxYT61nURHACQpWXtxlmip5eoxWz73IfzzGTXy6rj0ZXAmjDYw4DJrVu8lSbuwETKnynpuDGqxnGyzH+NoWN4oCX5/PKGqzrt0ogNDgLyvjP7xjX7/PoYIAftwk3RpCuFsilBVxNeXl5dXV2lpaWyqpT2wjS+qnD/yjaQcR1rjyGMrkUWEQOxqZRmiSBcShyceh91nSS/qnEdFwWfnnovJAlVQxJld0ElMgu2jyU4TBE8Lwx4Xhg1KgojGwbarC1+YxmMuyy5z41yWhdaeRz/1Tlcexzu04nJ26agpoOtsldkd0BqbFzv4LOwxYTa47ns0o2TonOvr6Tb07j/6KW/sISVyC6CgWpiY2Gnq5727Mn/9LhOVlncAAAA83RSTlP+/f3+/v7+/v3+/v7+/f7+/v7+/f7+/v7+/v79/v7+/v7+/v7+/v7+/f7+/v7+/v7+/v7//v7+/v3+/v7+/v7+/v7+/v7+/v7//v7+/v7+/v7//v7+/v7+/v7+/v7+/v7+/v7+/v7//v7+/v7+/v7+/f7+/f7//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////v///////v////////////////4lF/DFAAAgAElEQVR42uxa32sb2RWeGe5w516kkYswyOAtxSTGKkSBRPEmD6F9tCQCfrCf+ubgQAhl6cNkEExGWUeGZMGrxqxUUAJ5CBR2/4HgBoMNNn3zg8Fvxm8blrKF0kIflj70O+fOSIrthGWx7K3rK8893zn33Jlzjs79NZblSU9Kz3M8JZWSjmd7jhKeVJ6HSinH82wbWKHBVg6UoKkUeKVsKKLyICYGSjYpQkcS8aibEKzu2ILahPKEIkWirCFY1zP3IF0HD6AH2YpvwJgsgolkFAkdYxbuRDfDDUAk7CNL+KGKLXREAqVkgZdiY5pnpMYaJ7XXMzdgXduSoQxDKbUMwiAINRzTQSTDQEpUQaDpbsABGlSgoQTNIAAfBAqKqCTExEBJkSJ0QiKSukURq2sVqXI5iiK+ykzLACAPDR2PTOt4NF4WqAXpoRAeZzz+kHoSMGZFQRCRJaEECWEfWcIPDdhCHSUwDFkgU2xMk0bKcvic2CvNDVhXWaeVOcp28NVL3EECEHUAQDRTmYdRCg15mXc81B7poRDOo8Vx8pp6ErjInJ9D5lBwyHMRR3EcKeELFTdEFAuBKo7x1fs+cIwGP1ZQUgJi8HHsQxGVgJgYKPmkCJ2IiKBujQ1WV37D9/2Nxobf2NgAIOoDgMRMN8TGxkYDDWJDQCg2WI8VBHFAIqaeDGJFLXHcIEsiARLBPrKEHxqzhaqRwChigUixMU0YKcvhc2KvMDdQFPd0WDn5vKaSpwLCqCcgbCqWUKUTreTDiJW06aaTHnr8ppiYsG9OfD7hTySlB3qoL3mP8ycOdeoJbPtmWRuLtU4NTZ6ZeGIs6pc+c0iNnU3tTQNghhUHx7Gr1UePZvA3U52ZQU0IFZNqlTAaqqTBjQCoq4SrBifMjGFYxveq3rlz59dDKLjtHWNXalHVPDOxO8GP+qXPHFbjtkSfW2aqX0oOjqMdLZzq46e5YZT2068q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"></td>
<td>
<pre data-language="cpp">QImage image(3, 3, QImage::Format_RGB32);
QRgb value;

value = qRgb(189, 149, 39); // 0xffbd9527
image.setPixel(1, 1, value);

value = qRgb(122, 163, 39); // 0xff7aa327
image.setPixel(0, 1, value);
image.setPixel(1, 0, value);

value = qRgb(237, 187, 51); // 0xffedba31
image.setPixel(2, 1, value);</pre> </td>
</tr> </table> <p>In case of a 8-bit and monchrome images, the pixel value is only an index from the image's color table. So the <a href="qimage#setPixel">setPixel</a>() function can only be used to alter the color of the pixel at the given coordinates to a predefined color from the image's color table, i.e. it can only change the pixel's index value. To alter or add a color to an image's color table, use the <a href="qimage#setColor">setColor</a>() function.</p> <p>An entry in the color table is an ARGB quadruplet encoded as an <a href="qcolor#QRgb-typedef">QRgb</a> value. Use the <a href="qcolor#qRgb">qRgb</a>() and <a href="qcolor#qRgba">qRgba</a>() functions to make a suitable <a href="qcolor#QRgb-typedef">QRgb</a> value for use with the <a href="qimage#setColor">setColor</a>() function. For example:</p> <table class="generic"> <thead><tr class="qt-style"><th colspan="2">8-bit</th></tr></thead> <tr class="odd" valign="top">
<td><img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZ4AAAEcCAMAAADA2iLuAAADAFBMVEX8/Py8lCZ4oSXsujL////7+/t6oyf9/f15oib+/v69lSe7kyXruTHuuzP6+fn6+voAAADsuTHs7OzsujP4+Ph7oym+lirw8O9cXFwRERJ+pi9mZmYHBwZ6oicJCQl8pCoKCgIWFhZdXlztujIBAQK/mC7suzMDAwKCqTVSUVH19fSKrkL6+PW8lSfq6urn5+fy8vK9lCaeu2VNTU19pS1OTk7tvDZ5oSXj4+LKq1p9c1fuvj1UVFSZt1rtwUxgYGAMDAzuwESRs0x5oiaUmoftuzWmpqbBnDYODg7r1pyHrDxkZGO8vLwTExTtvTlYWFjtwUfV5LbsvDidnp3Enz2JrT92nyWcuWHGnCgREAPI3KC1tbQaGxxDMwqwqJKownTH3ZtTU1L9/fzJqVKWtViwsLDMoCn0wDNhTRa7lCW6kiWCrijw0n/vyGD++u2oqKikpKT//vLL3qT///rOsmTLsWp9pyfzz2xbW1uprp/w26LzzGTt3rLv4rz61nXT5q3vwkqUtFHpzoXsz4Do4dHcxYT44J7FokLBmCfxyl+hppfUu3jRuHHXy6pURBnHpkrxzGxOTUrt9trAmjJPU0ehm4bCnjvq3r/Dz6qxyIPotjC0zYSdlHyPmH6FqzqvsK/K3qLJqU57pSbu7u7+/vx/qiipw3b43JH4wzSbeh+rq6uqqqr8xjVaeBumgiFymSNqjiEcFwX9/PuCZhpMPA9dShZzZ0YaIwdcSRVJR0qpqakpIAd4XxjU47WQch322o7/zDdsVRUvPw6GsyojMApjhR48UBLUpyxKSEu5kiWwiiR0aEc6Lgy7kyZQaxi5ubhTQhG2jyW50I1GRkXJ07bYz7bB2JUxJgnuxlvery5HYBafqIzj2Lno0ZP/5pq7r4xvb25fX15YRRLfyY1hciE1NTXn5uMlJSWRkZDd6sI9PTzDw8ONsEeBgoHcyI3Y2Nb76K/7++BuaFj78M7uyWK0yYi0rp/MzMzV1sPhzprvyma6sZaQwC3/2zv//vfYz7FCcvVlAAAgAElEQVR42uwbS4gbR7Zp+nuRmiBhW5Zm5DAgJ4a1EYLxwSbG7CGMs4TBuIeODXbAOTUErw+FczK+5hj24oMV00v5sNB0z0nsQi6tlo4yOMEH7WV82MxMMsOyh5A9+LCvql51t2a8i+1ImsXoqft11auq16/q1XuvurqlmAAKHAq/sAQHzJk8yTJKXmwiRcGGyiTRzDJ5S0VRJNmUDPE2gotAgqGiZEyVAk0II2sKdooik7nY2NLMJUExsH7eJclTMsy5yUGRshd4ZDfJxkzJRyJrrGTyyQHIR0fKWZAmH7ZJkRUbwITD5BeW4IA5mydZxsyLbaSY2NCcJNpZJm9pmqYk25Ih3kZwEUgwNM2MqVmgCWFkTcHONGUyFxtb2rkkKAbWz7skeUqGOTc5KFL2Ao/sJtmYmflIZI3NTD45APnoSDkL0uTDNimyIieKubCegvUo/0fWkxnCwnqQm2lndsPwEahHET1A52YqusIOQAIwp/Aky+h5sYIUTmJ4kqhkmbylruuSrEiGeBvBBe+vSwEUiXOaEEbWFOx0XSZzsbGlkkuCYmD9vEuSp2RY4KYUZ8gRODe8L9q5bWvsB4CzTRM5jSc1baJYQwonMTxJ1LJM3tK2bUnWJEO8jeAikGBo2xlTu0ATwsiagp1ty2QuNrbUcklQDKyfd0nylAwzbqxMzm7TLFVKHCo8UanwVKWCqZJI8wJBE5UqWMSpWStBEhlkkjGtYEt+KUu/zw3t7NnfzQZmxXfGrI/ZWeyx7cJMw7mgFeYOzhqpVpzV2fSR8zOfvHIaFSZLPquzuSP0wi1Je+9GC2FFACRkll/4D4tbSOEkhieJrSwDZ/1SnbddWZHklmSItxFcBBIMV1YypisFmhBG1mytLF3C++FNpdjYspVLgh3A7uRdkjyR4YpMr9Sdk5qOnkmr3Lk6d7iz84nG/KuwHu29S9tbJ2cAW391vt+6MhPY2m69ODkjuOK8r5UxrsPYOHOHlvOBVsqcm3asfkUzpx97FO0L586Xu7vr6+vfTRPW13d3/3jv4x81czax58NLx3P1nDvx/c/Xn74Krv/8k7P/9Kvpw/W/XfpUqEc4t2P1F1pFL8PSpSxA5xme5Rf+w2IdKZzE8CRRl5myXtG+dX6/++zhkydPbk4RgN0vz7/5/OPzWqksZJZyCxHKZZQXJcEOYHfyLmE7Xc97zkvsY0vHc+d2bumFmLqHYo+uXXCu/+u7u48/myY8vrv+zflTF2B+ZM7tWP0jNl2m+1iqmGWmnvtPNh5cfhXsXf4vsHe4eLLug9vth7t/OnFe02fwWMoMZqloPUv3tEoZJkKJoXJJpOBSqmgfOF+tP7zZBthob2wIxHOY2tgQVJ5DzGlIFGcbCzibdvvmL3f//YfPJ53bTNRTAvU8etze656eEtTwunb55vr81HNcjM2hx9IyqOfru+0He2emCXsPbj7/4dTnk87tI2bN0901MMH6v3Ae3bp4rdbpLFfhx6EqUJUBJDgdET9EgcQ5jV9Ezc7pvfZ9ph5lBrsG3J9NOLf3xdgceixl6vn7rY0zMGtq04PumY1nP0jnNh/18AFuiJFvCNRgAIkGIyDihyiQOKfxC8sZ1eXaDNVjHlLP8f+lnue312owc4yqYQjEwMCUYQgqzyHmNCSKs4oFVdG3tYvPmPXMJ/Y8unV7rQP3teDHwRLIYgAJTkfED1EgcU7jF1FzuXZGqOdonVtJqKfbqTYM7IklOomiG5YUWXTEKvRFDAE/DSxgLRvVTleopySHVtf+DCu3Ur7zNJ09N12pSPXAzVX4cVAFUhlAgtMR8UMUSJzT+IXXNKpcPbByK89gzw2Gg60GSqKvWUbyyG6i6FI9oJ3GtNRjNJbReiq6rszLehqZ5L/VethxBNaT+Xe5zV6wnsaqtYoTTVXlFFRdyLmumtMR41QTM5SfFhbwpqvV7u1n81wagHoaU7UeqyrVM7/Yk+/t4kNPHnuY9UD/AkLUggenPlWJ7wdGYMBhNSasxxL1DWigWoQQS4VKAFCzsdydV+wpofXUqmga04g9cByR9cChm4puSuspqMeySDSIiGXJ7rnDdEQHSRK7UQRHwcWJjgVQP1ahATHiQUwMa9WNXFbXkM4tiz1lvmsww9gzM/XMJ/Yc10qm3HeGw2RJcyL2wCiPW83WMGD2bhiqS4fNdOR6vWST7bLWe1EAjs5lZRZPBG7S9OpeSEi42fRaSUQHbJ+23hyS6trteceeBnquaTg3OKpHYj02pLe2t/f1w7HHpaEzjEatESUUZCTkZZq+7EdO/HIQhuHA64Hfo75PWUfB44HLi4ZhHKdeTEfDQRw2Ez+CiuHIGdHG3GPPzKxnfo+l/BWM9umJnf2VfU05GHssmmwS0k9TOgiJS0AnXi8Mx84wJD7tx82QWm44HoZM+MF4OI6JRSnpx05IA0qN/tBbDSBY9Yc9K6hy53ZhEXvewHq4P9N+bX2raTv1cywzGXvIZkLAo3lu2ApBHaOkVU+TTcdLXNUlaQ9iTOqlPWcY0JHXSz0vJlAQDeEKLsH1E49YrhtAQ1+diD0L5/bazq2s7dw4a2u/nnjKTGtyYW00h9Sl42YMhhD1EtrvpX0aO7GvqmQANuIaodt/OXIiGg/8vt8c+q6btFpQYFkuiZpjCuqiiWccWFgv1PPa6ilpW9uKop0/dRWs6ZXqGTXBa6XNXqT6oB4jdgbEdSkYDwjejwaDsRODL4shGCWgnnDc40sGYvVSWDGoQbwyou5CPW+tnpPbmqKdvbFzWD2Bx63Hiyx/5Az9qJ+phwyYjajGcLPX6zkxHaSbvdQB9VjEjx2wGhL1em6gWuDiNl1DPYLH0ndjaVBm1mNq529c1fSDSwOSpgTGt6fCYKfeIGDWE4B6QGdJD5bb/qgVRszbBV4SgfKSPjyKqsRLCIm91CKqoZK4OfZVuamzWBq86dJAh9jzI4s9n4ANTS4NVDp2Bn4EIQW0AVoy+qgeQgbgsSD4D70+dRMncp2wT9gqHB55wNBGfuwlNGC7CFBFhb415rc0eNdWbv9s/QVWbksfHlq5WYGbthIIOvA4GlPXS3L1pJuwbFNp2IJH1BT8XNpMwL7SsLmZwErOID3Hazbr8ADEPJ1qLNTztuoBR3dvaWff2Wf7Bgc3dQJ3nIyjwApZuIlHBK6GO4qIC4lVkJkMhvDYE8YkgsceNw6teAwEYhnhiEMEjaB544B65rQlOqOlwVxfx/Fdg3/8tKMfeB3HlgaWalDqQ4CnsFRWia9SqqqGb6iWT4TQUEwh4wY+9Q1CYWFAKbVW2WYCA4g9rDbfsZ7767h3YuXGlKLxw57c1GHWY6zCg4tqyD03uILJuCymqMLqeR/cVSiDH+sIYF7Ocmw3btXlviHbsV4srN98x7rMNq1f430PplT5DuRt3/fM523prNQzt7elh17HKbN7W9otvC1dqOc3q2ettlyVH7U0xPcu+BVLVXzPUpXftDQKn7WIr2H4WcUC8UFSbf4vs9+V2POql9kXr52udZY7neVlwIAYLGOKfTPWkXTEnIZEcXawgCU6tdPXFrHnrRbWWuG/Hpl6PmtfvrbW7XbX2MEQgy6mul1B5TnEnIZEca5hAS9cu3a5/XyhnilZz9f3H7b/w971xTZxpPGYdTDYu7DGKIgjqpYucXRI4cRFSluV48SDdZw4ApdD1KvWlapIHhrgpDuhPJxaiYcUWeKB6CpRdd9IDmWNFoeVjQDZctah1CSyObuoNa4ooJxS7o8OgprrtSCk++aPjRPCNeFMbkH72fPt7Dc7fpiffzOz3/x742f1lDd++vHvv7NfSxcwx3r5xhWr51gdtxHPsf7bF5/96+O6ymdf/Hpx5li/IOz5+RNWKKx07hJ/9ac/1l9+t2n9FrtjPb+e2+Da9e1X55b29eJk+wWQyxcuXyYaFJYLLMbS6B3TxMaMNFxmCdWcF66Ku+ye2/zYM7i2+a0nyUvizreeiYi7bPbMjz1rXtq1cdPgqkH4ghpcRWNwWbWpoV08de+juktf3921WxaBPS9I1+BlZ0N1df/M1XHviN9+84cjQyNDI/SLFZYRFhsZoVZyxzSxMSMNQyxhiJqPTH3Tt3OL7bGev8d67inweHXcg6kD/fenD04frJdM3+8/MHV9p+VGS+GzF2RZ1RdlqUm8T1pA8uBG/7XDu7fVT3YfvtZ/5Pqismc+8GDfOh77eGUh8Py/V8e9I968MX349c7OjkBHIEAVlgCLBQLUSu6Y9nWxmw6SyJ7rYBm6Ol8/fH/IeuxZtvSV3tOjo1cGKqtErMaehio81GlAR0tv3ji4rcvn93l9PO/jscLCsxjPUyu5Y5rYmJEGH0sgWf1d26aHrluv7dl78or4yaj4aa81R0spJJWNylyVmTo3b1zb1uGTOVn2emUvVli8LOb1Uiu5Y5rYmJEGmSVAhJN9HdsOLhJ7FvLeA/gooxcv4pl6VvS5zcWeFQyeACdz3vrAAwAFCDxW87nhySyne5cNS1dOLrFi5dbwaB85/LfG2WvZ45c5zg8fzo+FYzGOo1ZyxzSxMSMNfpbgJ2YfY4/F4Nl/pfXMwNJh49P9VoWnsuEaRcdVA4+f83LQinBV9sgcr/IQ1BpWgeZ5Gb417OG8XpwPLBAAKm+FPVaDZ+/+L1uHB5buPTdqWXicj7Z7mw2Pn+MFJPCYE5Q+smZqPDJN4RF7/JygC5yGyCOMPZyflxFk5PEtL+CnFw+ehbQ9BB5ACeDZa8W2p8FVu41lQ2W8h7Q90O3iUDlYRhxP6i64qPFEVItMnM1C0cMtKCj9ciqLolGB3BAjBCRnIaOAqYZUFcjls2bbs/9K86WBZcOKZSs34slxuQh/ZrHHx6G0pDSnEC5xv8yrWkpKRNVk6XwWylzlZcwNFQWbi3oiARYe0w0SAJ1YUjFaM7wfqBY24hpvUfYsGTgjfXlx/yXxUu8Sq7JnuavRuWIT3f21lj08r42JqXK6NaohDTMCPQwlHpplMfuQ43VTB254eU03w1JRLySogdNMU5d5FI2Hs1ExjVAsZ4gAj0XZA123Uen0pXPnLOrUIexxOVf/eLIB02gWe7SzSYTMUEjPjyMVRcaLydJ4MS7Gx71CLJVWEe9DxVQ0AvAkCtl4uox4f1s6FVUFHuk4Y05H6URskdmzMJ/bwPAninLuTO8rVoXH5Xy1/bb490aAZ3blhpL7ENRohjoujZthJVpolUKZpGicLYeUnJHMCijeWiolAZ4JpZRTjKCZUnIhKQT4QCWXV1IaL5jocXisNN4zcHL4TO9Adfaklea54Z9a3uB89eVT6yYbnTXz3GjlxglQwKqWVrJmyijnCpqZS5goK4bNjKE+1EoFs0mKm1pcBHikJpNPJjR32DSzYkxXUcwQJzTs6lGN2srNYuM9dKcMMjfZspWbs9F5a9L1OHv8AI+ualEli/iEUirzGB4hLAZ1IxSNRxMGF5egHsviyi2hq3pUykJyvihGdVUIpyeMKOAiqHOzxxrbTmB4MDWWWnHbCfxT+H1ndQWeWvYAPMjIAHviRlbWY2LcLFfgQUqykEgU9gkpRYOeG4EH8WhczI6XkrkchocXNLNg8MJMeOxZok/z3rMS4GlwPt5zQ6EQUs19JVUol0JGUKiyR0mZAoLG/xF7CjquBaG5KaualNbhlUc145h2wszKzZ7nVrfKjdfSYtAsKxldn8jpE6UqPGZGymqIy/MRKW3qaXEMugZZHSULeVE1URrYEytrmprMIWi/VGt3DSw8BZ50DWrY45rZNYB/fkgqQA9Nj0thTTUmzBKFRyvnpMKEUcrqGTEUMsSiVmhNFgwlXDaM86WQlEIhKVGAnhzCv4E7cFbtGjxP7HE1zvJYQ9mm98XLSB4vwntPOIrgKpejZUHgo5lMNCtwQiwTz8ayqNg0lkmFkRBOZaLyWBGVY6kMfg+SvTIfCwpei3oNnpe2Z8fkytltD7z3+HlB13SB9+sa9s/onAbVFPaAgh0EcT6w6Aie0OCqA1cQmP3wFKSTjNhHSp6z256ng8dFtgu7+4/ls9ueAIf/+iqPfWuqyuE4XGXZq3plGbvWVN5LrvgJlQik4TvsAyUROm6Hf2Ame+yJVPMezHbS+SBO6rEGy6PKzYt90BXPNEfjPLlSK8ec1Dw11Xqs2XM0cF4vG8y2d0Nc+GA2Zg90FirH+7CpILs7AwF/IODzBXxYYfGxGJ7bEajYmSY2ZqQhwBJIzkDn7mkr+tysDg+bbFAz3kPhIROpuuDbBRoUli4W6+qiVnLHNLExIw2dLKGT/E5lIpUNTx026X8w1X9t6+E6ytattdMQ7fee+bz3kNNZVjZWjzuhR5nQSbwjB/rrKwdGpj6y33vqMwX+zXtTR+otNVPg7feeH4Zny8a5j6n7yep28dSavvrL13e32/DMe/mVuAF/qNog0pgoUi1ueBbSXFl+ZVduPwTPmu1PPFfv1m2x/daOdTvgu45qUOTwORbDh9ytq9iZJjZmpGEdS6BZSZpodw3m3TX4b4eT/fm3fe/XW/rufW2P99TncLJv37/zwdH6ygd33rMXztdp+dXb7x091N3dfeLEiWMnauRY9TrDPNt07MRj6d3dh45+/53tEq0TPL88dOz4L+ope44d+v7z9XbPrT7wfPXang9bWpqamtz46waN4yzmduMYszNNbMxIQxNLIFlbPtzz2l8+tzdtqY9TB8PTgsvW4XHA1wMaxMNiHg+OMTvTxMaMNDhYArYCPgSeLfY+1vU4efHtr7qPt7iboGDd5OMg7HCwGIaqamea2JiRBjdLgMjmNnfLcQqPPaCwIPbMhKexyh4Mj7uNQvI/wkOeaDpus+cp2ONkELmqCxir8DThgvUQBjF43I6esR5Hfmysp8dRAQv0mINVgpW6kEaqV1y7LR57XqiuwXL8X25oXNnIVpI0sK4BwNMGxZ93R9x5Dy1kXMzBcDAfCYeDwWrb4/C4g25PHj/Y42FUwQk0IzaQ2g3Yc8fuGiwYHqerkS7uqQ7IVdnT5nC/G+mJFYOVQoZLJhEPRgvnU/HNVfZExjMx9+ZgMZaPeNo8jGeRSBEy0mxud4/DMaNyWxT2/Oj5PxiTsqfx37/565sbnRSfKnua2hw9kZSiSJlITz7vgM9YMNNcSjkMI5ErecbGMHvezRcj0dZ0sGdCUpR4JLhPUiSlNR1OJyFjoRhMSyCKkoksPnuezbGyi88e5z+3355svTpINxOt6Rrkg9HWiVimNR6MBHv+w971xzZx3fEYLr/OqXPgEnCWUAMjSZd4JYgmsFBUECgUCG3cUO7SumzrdLNdVlEKFNJkWSdNuQEamhhIRdOWLVlUM+0044MxnevOf6zRebYUr3+YrmoLSOsaisRAK/1v2vt5d3ZMlm1nGNt9ffd+fN/dQfz1933fu+97n297WJImc+n3JlOcfGZKBT0cGwa2COQRb0IMcnFZ4RKTSjQWj8dlPj6ViMQbpsQUqMWTXJy/F9oDerdGy4IyN94r7WE+vcEwax+/jLBFTbYHfPdTUYkXc2k+EpE0SU5EomokEueSspID33tKCjulSDIBxCMJF0WJjwYmA8p7oihKYYnnpckpIcQCOzUZjGqs765pDxYPDGmOw8VbFHF+kR5xvmTiOVxUPJUIofLd3zJlBeJxSlFFyvLg240BBZGFZJprVpUoJyhTghr1ChFJSjZHo6o3wQL9yPJXo7ySDsthKewIhcNZEQjXqWVZ2Zvktbq7K57+3a0t9fX1a8AH0RqcILxnUEB8kqADN9DU4KGMPKZl0z3RHnhdOfOX7TO0x8F6z/MaH/fK4JvWcmkJKJIoyVxEvMrFeIeq8pGGIC9d5BKSF2iPOOVtn+IEr5oAauXQpJQA7gYG66qQQUODuyiezcN7Xr/e2tq6C3wQ7cLJLkiggPgkQQduoKnBQxl5zPXHJqbvifYAc/rJ0htMWfUM8QSxeCQtF1VT7bp4lBwf5mPNqWRzyMHLDdj2XOSElByLRNLNQD5hVsqpWrvTyaaagfIUF88V7NOAjgxItaiCqigjzo5aF2EglwdygrhqXfnMWlpx1T7InOU2976xZ/Vui2n1xGfTP9q6drytrQ382zBpQwRyXII5bsCEqugqF77HRQrkCS7yBNRybqzo0ACjHP20YR9aGZI3NGiXhKtAPEkhxfIxLihmRTUtslA8U2oGmB1ODnp5TQK2h9euCt60Ek0Bm8OzUQVwHTk1JWVYoDzRLBvKf2tAd8dtxx5BhsyyGeQZRFWGOAr1ZoZwEAtH+DYzGb0C/oxnuSM3e4f3j46O9oMPon6c9EMCBcQnCTpwA00NHsrwlfv3D0+/fNjzMXNu/BXLaXycadu6ZMbuuEr41qCceXrpPsaFozKX69oDZi+gQwMmRNXYrKpGZdakPWCokADa42XBkAEMDVg+JYuBNC9pmsaDu6SsmstKmiMjAZPFh8lLnR5TiItaZmzptbP7SkBnL3NfOLK5JHTk2tZTt58vCd0+KmDffoF4ysuYT5Z9yqA3P0yZWTwZPsnJYlhQRF5RpYBqsj3AHIlpFUgoLopxLsGnsuJkpCEWTvC8GOGSoqwGwNiNZ8PieUHT37nlO7MXerj7jrxCNJcOlIDSOVW49Yprpu0B8x7u6bWff36jvLpwYA2UxqtEozKf9Eb4lKBM6p0bF1VULiZJChcICFxCTHqVQLPCRwRVCXDpLK9y0aggqDIvc9DyOIvZHqA9vzz6vtU/8Pc3H7nMXb59qiR0+93c8x8dLA19lLv1d9fXZ0xLmVWe5se/2MD9eRVTWWB7MlIqGLgoS2wsBm1MUgI5m02m+EQsoSgJYFra48r5SFyW5LiixNl2NhIEeZhlY0lEKUkGJ3wnVHRauv2l6eH9/f1ftY5GR4enb0LbMzjwhNU0MDh081Zg8MO3v10CevvDvyq3Xm6bKZ6ysoVfhgsSxyoLhgY+p8PJirwoZRw8H2bDkhji+YyDBQweURj0WiCTRMkhiaDgcKBcZDMOEZMUkkQWuRWKimfJ9B8nzKE0dtODJI8ZdaNg5Pmt5L49n/Ue5U4NHjt4YJ3FdOD494YuKB/s/dulDZbTpUuvfjD1lZfazhUZuemDn4KRGzAZGTBxybA+TQPfcUZzaEAxoP8gjAh88SHYroVAWzisIYdDBuUaJvgA7BoqKp4r02/s3gRmFtt2oQA0sAAJFREXM7YRBroOsrbpN1AmOkGx9fo39gwf5X48cPCFkT746esjOUhOj/SdBh/E7UPVPv1ADSQlPHrtaXRl38iJdccH//CD77566amNXYT8XX4/LXT5u4oTavGbK8al9K6NG17be7GIeKrB8IBMAE2h/dArUeTKdjr/c2c28fcYtoe64670Trz+kxbzdB5P8dfQST6Z7RMGuq6ezPrzmeiETS3XV+8H4nli3Uj3yZWW0snuEwcHoHg2dO2k+MN+tx8csOaGRQhETGGLOzAuMSC/Dk2MbvN3UKBiBFbs9zdt6fB3fee1veeBeMZnQr0a2sNAZ515rYHDCm8p8rpidxzZHUdXiS5/a2JTy5qHcEQzHNwMB0FDOQ6ARoOhEU4jjZiWzyRR0xatqb++ehSJB/z/WR88EPlw4oMECj7IIAk6cANNDR7K6uBz2LqTIwcGLiDxQCRCNzoRynCTG5dgjhswoSq6Cp1N5MImUkOnuwa2btn51Pf3BoF4yvM3zlfmeUuhLpXrK3XqrCS0Uqdg3tOwvHfPppaHFlVUNOqhAXEIQfqCmbxprqKxBem7Zv3dc4URWxBHEKxvJeIBnTP4VfiIx4n6q8ivCDmwSMLSXxdtdph4LP61sb52X91KXTxbmlYscLsJwC2Bu6XwtxTZcwWG7sTIuAT7lgDhUiRc3IZktXNjoXgwSH8lXQesg/STdW4j3d3dJy2j7tMjB/LFo2sPUJ7Oxk5IjaAACRVhpRMzOgkDXQdZnfoNlIlOUDTE07eSZUM+RwgrRggnIUigEIIMkqADN9DU4KHMB5/jMImnw20CuCVwtxT+luLiEuhOjIxLsG8JEC5FwsVtUKM6DO0xpqWzLKQaOL7uZyespBfWHUerRPPWWC9/C2tPlUXaU1WgPe0l0x73AjfBW6dQ6xR6nQKruzHoOr6K4K4TEHaKwu6mJbfbT7Tn3FzXWB87dtxSOlZkjbUtHnTbgmLimX2HwtDQoLU0NHTz48Ldcct7J7B4KiwST4W5c6sj370V4oFTAygePHLraFqxAloMizq3FVv0ocE5fX/Pc+sfLk5PPsddW/9D6+nhR83Rr2oN23MfiedCacTTYQwNykjsuOZlnh5PTw9Kejy45IFnTwO3FRZxswfxe3rwRR58Mebqd2EWeRh+iP5QT4/++GWFseNs7bmT9qxa+uSXFi4uRgurH+WeraRtY2OLx2BCy2Mox1xUIyniESY+F5MG+tyxVTA42Uzbs6jRtISGhE6nC2vICpt5NKY6XWOj31BlxFSvomsFqe3x4UWRZIWeA8+gnWSuTObQ9MANNDV4DjzLRksqTbbHvcDAQiHIKBQphUKozMcYKRhEhcCkEMwUCppCAVaK2p7ZdmbvgJ5T3fOl+7pIqRq3Vet3MYzuTiMPqTaFEiZ3VjKP5INV2p3bTO0xBtaHZwlOtoN50LSN07Rxs5xuiCyj/HJjlyXZDqpvpTT2fEJWLfOI52t25zbXzm22ec8OxmVadWFaZ1FG1y9UUn6ZsSiCvLzTVz4YSzQgqxyIxx653VfisW3PHW3PbLvjbPHY4rE7N9v22OKxO7f/sc7Nnvf883nPnYIyu0o471lvz3vszs3u3Oyhga09tvbY01JbPLZ47IG1PbC2B9b/H0MDsoh36RVbPAXiGZ8DIhX0ltaa0IVMeEKVFKenWl9baoD/EJQiHeHHgCJCi4WRtzQPU8e2Pfa8x+7c7JGbPbC2xWOLxxbPv2F7KnBc3hLYHvi9h5yG1WXNx0EAAA2sSURBVLHa9tTgpvtyYN1wBU5L56A9VfOeeQbXrNaejJOVMKBgCbQHlB94oGaO2vOtgoH1klmgXncw5ZUlGFh7CgfWc9EekHT+4sUXD82rqLJae8DBa3IkKzn0TX3Wac/8ppqab545cx9qz7/WuVVV/PxX7/zp11A+VnduPjYoIEDBUAk6t/lv/i4rRN6ssVY8/222p6rq0DvcbwTv7w91Wm97MsG4LAe5GJ+xXDz/aO96Y6M4rvja7HEcf/Y25hL7iIEDHDu+EgM5Dpxg8OUDxogaGmgtOziK5NRYASQuKTIW5EOhVIKkaaREQQ2VQCpYbewCIeBCUUoaMKVUkESEpClSpJiokDqJKpF+aL40nZn3ZnbP9sHZ3rX37PfYnZ198+bdrH/MzJu3MzuTm8/+vd4cNDzDP4n35qBcohNaLpjXz7ecOtW22I3GrW7Png3HP8gUngG4RCf/7sSNowOtPZZLdDb/jM6wT4Hvu3jxbqZBbdtf6o9N2PRe5M3fOG4aXMmZtHHjJfHhLedNg8nNf/5HhMEzOMO64tDNef3RzehfzfZo/2lDorI+m5Nl1Ljlbuo6Nb625UjkSFuu84b1lZxLG96OvFF3ZaILpsGUi4Pte/LDReHq/ilcYs5IlzYkqum9OVlm8Jzv6mrLbbkQeW+T4/Dw75fUvVHyrkDHeXiaM4VHrY6zLV4sWNM/dTeYPd1rnKfWCnMw457aTV1dLbUMniNttY6Pe565VHc20lnnkteg+WLmjVvvcU/6pb9rzC/ZmMjhvkf362U1gxn35G46dyrXncaNtW11JyLv1mHFcdprMITawy23qBEy2MECIwQxdglFmeX2Pk8TKSLkqSAUAmHgqlzAQmUiMaSUhlROrXxQXoPatuuRN9vOX48cG++4abBxz4nIiQ0T1deDHK899ZnVnuKBeg1ceR0XHszruNzxxyLnjl2oP8faNqfh2XPULOGfrX8yJ8eFxm1/88XCQVtuIzwVBD7akgk8uaxhq490scqTWe15InN4Jv7tBP9q/dtnJ7kBz+Q5+49enJJh7en3k0fDPBVkMGtLWdBSe+RCy3jnPdbsgM8CQu/jdN9TPG7K75vHFQ+u78kWj/XiCYtzx7e0oLvaaY81fBZw46Rn3Hnfsx+S7l57+kwFyRaPtXjds3gxvvEZnXMNvFV7BtT3DPht6RPZ97Y0i/uesTBTx1u1h+DJDnhoKkivxo1m6hA8BA/BQ/AQPGMSHhr30LiHDOvhmiU6Bhq37PW5Ue2h2kO1h2pPFnmsaeH8nT4z7o2F8zTuoWEpwUPwjCZ4yHLztOVGXwVJZxp466sgBA+9Lc3OvmcE51gTPHeHpzLNCoWgeysUZtFUkEwbt0RP05n2jnZ2sKC9A2Ls0rFl/T/Nr9dv4ayOdgh5Kgh1gDBwVS5goTKR2KGUdsicZw6uK6Tak2HtORQ2h51K+qyOI3jSwJOf6GlPVvVHySZWe5r6TxsKJc9Q7ekXnsn99j3dI9f3pAxLXdq3lPU92bRvaZ9h6Z22lWWWG2cZQQh5KggZIAxclQtYqEwkGkqpIXOG/OV9l19l26bMaBpMnePcpszjmJ0xgHHPsH4VhO/6Ox2qghO1J6VxY//lF+TkLBCUA4GoEYKbI24XyAMSZGjxxEVI2uHhW5qPu8ehLc3vGTdn+QB8bsP9tnQhqz73inpwL4twElF+Mx0Y05Eh5DhrusogmeJk0ZnTvrIZ1nzLeWjcHoJA1CQWeQiSIF0wRIIMLZ64gNB9ryp41jKjeqo4p4r94qdCjF8hAUjcCilxFqNgMd5NLS6W+fr51Ks33pbuPDBt4cKZC2dy4hFOIiq4wJiJDCHHWTNVBskUJ4tOe/Crh58DeF594D5H6YEVLyt4lnNatAhQYFeI8StnLkISt0JKnItQcBHeFUPa8uLly9cu8eInj7off33p9w4ceNA5OvCjnU9xeLZvfXnfvhUr2MFO/g+CNLQvPc9K2vfDp38B8Dy2ZPXq1WvX8pMTu0KMXyEBSNwKKXGuRsHVeLcW0vhlyWPLdmzu9Nw0xH9dfWrpj3c6SUsffv3xF8zXnn9x6yNPO0yPbH3x+T+c/HTzJ8uW/cBp+ukn2965weDRvDANEeYa5BdWvvKnj6/+2lG6+vFzr3SYL3zz7ec/d5o+/3blN7efXPnbzdt2KNq7Y8d/VCwt7bWn702Vhti2be9sP/nos3Pxz+eNuQZryv977VcO07Vru9eZX+z+6LuXHKfvPto9+/JL2z/d9TPHadeulSsv3/6f0eidFwp54aLqGQkXaIZZmHBFcaK6/vjlkx/cOH36dCc72MmJXSHGr50iAUjcCilxdqJgJ96dhjTBu/HLk5eP3/6JN+CBxi0vcWtVwWzHqWDVh2aPG4qZ6vtv1d9+1CW6Hak8HLL6Hg80bqvArwQuIXAK4a2O7iaVrCNHeZpSmcrvpOuavt48yAYN6F3SJR+9VgHpqdIx0KVPSiYHbDwojBQP6pXhm4efdYUOR6tn8wrjobel3eBXApcQOIXABQSeIHQ4gRMJOcrTlMq0+Z2i+kGzSo8G0bsURCGUNAzpqQpiEJQ+KZls2HioBcWjemt1+VvRuZKi4lDxNBSd21ss2iuV01uHABEPwVMJRYDckB+kQcIvRTVZAFuhUpm2Igb1JnMLKz8WxI9CKKlp8qH8GPhl8WWyZuOhFhQ3ODw6r/6NrJNobIRs7AoxfoUEIHErpMTZiIKNeKc1oobGRr+FiIeGpa7AYwA8mivwFCQAHr/11JqlWBbOL39UFt/2SFKn33py+HPM90ztkT63SvArBfBxAgHpPAJPEDqcwImEHOVpSmXa/E4+Bs8Z9mzoXQqgEEr6/dJTFcAgIH1SMtlv40FhpHhQL2C1R7N5rJQvy2/J4U8GbMW3PZLUGbCeXFylm81DE6ncbNzcqT2tI157hm1rP24aGJo0BdHyAzsPzD20KsFSRI4yJ1OZNuMyJOAJaWhCaiiEkj6fNEc1DDRpeMpkn42HWlA8JOAJ2sxSZbD6LDn8Sc1WfNsjSZ2a9eTg40I/jocMa9f6njNumQZjou8heMg0yCrTIECmAZkGA3zf45JpwL0GWW8aeOCzE1R7PFl7yDQYu5Yb1R6qPaMaHtcN6y1uGdatw+ZzKxiRzcnIsM649mj68G9ORn1PhvBURMvyyvLyRJBXBrEyfgZjZpPBIyK5TPDz8kCoDISBq3IBC5WBEqW0TOXM77M5GcGTDp5D4ZJZ4RpG4Rp+CYdFLMzPmkKzWtzwFBGGhWRNGGPhMHBVLmDBDSpRSsM1Sv2s3suvsg8eV02DVgue/OqGilg8Fo+LIB6DWIyfpQ1mTymPiOSY4MfjIBQDYeCqXMBCZaBEKY1ZOWPDAs8osdw8sPSX4EkPjwcWzhM8NCwlpw7BQ/CQz40aN6o95HPL0Oc2YmtLaSLV2J1IRX0PmQYED5kGNO4heAgegofgIXhoWEpzrD0wx5rgGbtT4Klxo76H4CF4CB6Ch3xu5HMjeKhxo8aN4CF4CB6Ch5ZfkVOHfG4jBU+rHvIFfexggS8IMXYJwhYXIc4K+iDkqSAUBGHgqlzAQmUiMaiUBmVOI1AeJp9bxo1bug1ifHqFWysUaqjvyRSexIffb1rfHzV92WN+nSZtSPR+xwwalma8Ou7O24gNy+ZkVHvSwZOf6GlKViWrqkRQlYRYkp+4OVkSkpOCD9uLYSyZBK7KBSxUBkqU0qTKuaXP5mRUe8be6rhRAs9oXR1HLlHyWBM8BA85dcipQzN1yGNN8BA8BA/BQzN1yHKj2kO1h2oPwUPwUONGlhvBQ40b+dzomzquf1OHGjdq3KhxI9OAag/VHhqWEjwED8FD8JBpQKYB1R5q3AieO8ND+5amfInXa42bK/AYAI8v2+DJ7z3HOhQ0guxgQdCAGLsYsDouyllGEEKeCkIGCANX5QIWKhOJhlJqyJwh/82+jZumyzn1OIUeJszDvHmcng9T7pGj5uWnMm2z9DXWuHXoPjkXX0chlAwE5Lx+HQNdzuCXyQEbDwojxX1iGqLfNr9fzfwPWHL4k7qt+LZHkjp168lBW8r2Sl5YHZdonT+vzHGaF02a6wwXFDPVvorqfx9yRXVZXnmi276+59Zn9/dPnzWYsXRpQ6JVpg0en15WWNQwywVqSJjVrihmVGjWzHKLTPvmZA0lJUUlJTzgl6IiESvid0UzEoUyXgIcISniIAxclQtYcAMZi5TSIszJgkKz0l575s8W25nhbme4uRneigtunAaboSFH7ZiWyoxbN+xfqW2XtDjyUTIWkzuuxTGIy73VZHLMxoPCSMl4rLTU2qFNZVOKZeHicVUYfBzrkaROVBiT8VjpH7/Qfapfv1Mddqf6MsX5uqbg8QdSOheH+h7dyul436Ortt2NvocdfmXIBwK2R0npe1RJHO57RKptNMBMeLFgC9dz4fItvBUXXBoGy72Qo9aEpTLVCjHDyhkKqYVjhlSIPxNSC8/wgAQZWjwojJRUq8/U2jK16ixkyeFPGrbi2x5J6pQKbdqCOPTiQRCt2T7fNRAxH8Qd/K4B/JZmjTWlNe/ssNRv5XR8WOpX4wrHh6VW8VGPVfBe4x5VEmfHPbYiEzzehgcHimog6uCwVLNyOj4s1dT+OI4PS63iox6r4L3271ElcXb/HluR/w9E8NskepZDiQAAAABJRU5ErkJggg=="></td>
<td>
<pre data-language="cpp">QImage image(3, 3, QImage::Format_Indexed8);
QRgb value;

value = qRgb(122, 163, 39); // 0xff7aa327
image.setColor(0, value);

value = qRgb(237, 187, 51); // 0xffedba31
image.setColor(1, value);

value = qRgb(189, 149, 39); // 0xffbd9527
image.setColor(2, value);

image.setPixel(0, 1, 0);
image.setPixel(1, 0, 0);
image.setPixel(1, 1, 2);
image.setPixel(2, 1, 1);</pre> </td>
</tr> </table> <p>For images with more than 8-bit per color-channel. The methods <a href="qimage#setPixelColor">setPixelColor</a>() and <a href="qimage#pixelColor">pixelColor</a>() can be used to set and get with <a href="qcolor">QColor</a> values.</p> <p>QImage also provide the <a href="qimage#scanLine">scanLine</a>() function which returns a pointer to the pixel data at the scanline with the given index, and the <a href="qimage#bits">bits</a>() function which returns a pointer to the first pixel data (this is equivalent to <code>scanLine(0)</code>).</p>  <h3 id="image-formats">Image Formats
</h3> <p>Each pixel stored in a QImage is represented by an integer. The size of the integer varies depending on the format. QImage supports several image formats described by the <a href="qimage#Format-enum">Format</a> enum.</p> <p>Monochrome images are stored using 1-bit indexes into a color table with at most two colors. There are two different types of monochrome images: big endian (MSB first) or little endian (LSB first) bit order.</p> <p>8-bit images are stored using 8-bit indexes into a color table, i.e. they have a single byte per pixel. The color table is a <a href="qvector">QVector</a>&lt;<a href="qcolor#QRgb-typedef">QRgb</a>&gt;, and the <a href="qcolor#QRgb-typedef">QRgb</a> typedef is equivalent to an unsigned int containing an ARGB quadruplet on the format 0xAARRGGBB.</p> <p>32-bit images have no color table; instead, each pixel contains an <a href="qcolor#QRgb-typedef">QRgb</a> value. There are three different types of 32-bit images storing RGB (i.e. 0xffRRGGBB), ARGB and premultiplied ARGB values respectively. In the premultiplied format the red, green, and blue channels are multiplied by the alpha component divided by 255.</p> <p>An image's format can be retrieved using the <a href="qimage#format">format</a>() function. Use the <a href="qimage#convertToFormat">convertToFormat</a>() functions to convert an image into another format. The <a href="qimage#allGray">allGray</a>() and <a href="qimage#isGrayscale">isGrayscale</a>() functions tell whether a color image can safely be converted to a grayscale image.</p>  <h3 id="image-transformations">Image Transformations
</h3> <p>QImage supports a number of functions for creating a new image that is a transformed version of the original: The <a href="qimage#createAlphaMask">createAlphaMask</a>() function builds and returns a 1-bpp mask from the alpha buffer in this image, and the <a href="qimage#createHeuristicMask">createHeuristicMask</a>() function creates and returns a 1-bpp heuristic mask for this image. The latter function works by selecting a color from one of the corners, then chipping away pixels of that color starting at all the edges.</p> <p>The <a href="qimage#mirrored">mirrored</a>() function returns a mirror of the image in the desired direction, the <a href="qimage#scaled">scaled</a>() returns a copy of the image scaled to a rectangle of the desired measures, and the <a href="qimage#rgbSwapped">rgbSwapped</a>() function constructs a BGR image from a RGB image.</p> <p>The <a href="qimage#scaledToWidth">scaledToWidth</a>() and <a href="qimage#scaledToHeight">scaledToHeight</a>() functions return scaled copies of the image.</p> <p>The transformed() function returns a copy of the image that is transformed with the given transformation matrix and transformation mode: Internally, the transformation matrix is adjusted to compensate for unwanted translation, i.e. transformed() returns the smallest image containing all transformed points of the original image. The static trueMatrix() function returns the actual matrix used for transforming the image.</p> <p>There are also functions for changing attributes of an image in-place:</p> <table class="generic"> <thead><tr class="qt-style">
<th>Function</th>
<th>Description</th>
</tr></thead> <tr class="odd" valign="top">
<td>
<a href="qimage#setDotsPerMeterX">setDotsPerMeterX</a>()</td>
<td>Defines the aspect ratio by setting the number of pixels that fit horizontally in a physical meter.</td>
</tr> <tr class="even" valign="top">
<td>
<a href="qimage#setDotsPerMeterY">setDotsPerMeterY</a>()</td>
<td>Defines the aspect ratio by setting the number of pixels that fit vertically in a physical meter.</td>
</tr> <tr class="odd" valign="top">
<td>
<a href="qimage#fill">fill</a>()</td>
<td>Fills the entire image with the given pixel value.</td>
</tr> <tr class="even" valign="top">
<td>
<a href="qimage#invertPixels">invertPixels</a>()</td>
<td>Inverts all pixel values in the image using the given <a href="qimage#InvertMode-enum">InvertMode</a> value.</td>
</tr> <tr class="odd" valign="top">
<td>
<a href="qimage#setColorTable">setColorTable</a>()</td>
<td>Sets the color table used to translate color indexes. Only monochrome and 8-bit formats.</td>
</tr> <tr class="even" valign="top">
<td>
<a href="qimage#setColorCount">setColorCount</a>()</td>
<td>Resizes the color table. Only monochrome and 8-bit formats.</td>
</tr> </table>  <p><b>See also </b><a href="qimagereader">QImageReader</a>, <a href="qimagewriter">QImageWriter</a>, <a href="qpixmap">QPixmap</a>, <a href="qsvgrenderer">QSvgRenderer</a>, <a href="https://doc.qt.io/qt-5.15/qtwidgets-painting-imagecomposition-example.html">Image Composition Example</a>, <a href="https://doc.qt.io/qt-5.15/qtwidgets-widgets-imageviewer-example.html">Image Viewer Example</a>, <a href="https://doc.qt.io/qt-5.15/qtwidgets-widgets-scribble-example.html">Scribble Example</a>, and <a href="https://doc.qt.io/qt-5.15/qtwidgets-itemviews-pixelator-example.html">Pixelator Example</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="fn" id="Format-enum">
enum QImage::<span class="name">Format</span>
</h3> <p>The following image formats are available in Qt. See the notes after the table.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_Invalid</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">The image is invalid.</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_Mono</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">The image is stored using 1-bit per pixel. Bytes are packed with the most significant bit (MSB) first.</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_MonoLSB</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">The image is stored using 1-bit per pixel. Bytes are packed with the less significant bit (LSB) first.</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_Indexed8</code></td>
<td class="topAlign tblval"><code>3</code></td>
<td class="topAlign">The image is stored using 8-bit indexes into a colormap.</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_RGB32</code></td>
<td class="topAlign tblval"><code>4</code></td>
<td class="topAlign">The image is stored using a 32-bit RGB format (0xffRRGGBB).</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_ARGB32</code></td>
<td class="topAlign tblval"><code>5</code></td>
<td class="topAlign">The image is stored using a 32-bit ARGB format (0xAARRGGBB).</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_ARGB32_Premultiplied</code></td>
<td class="topAlign tblval"><code>6</code></td>
<td class="topAlign">The image is stored using a premultiplied 32-bit ARGB format (0xAARRGGBB), i.e. the red, green, and blue channels are multiplied by the alpha component divided by 255. (If RR, GG, or BB has a higher value than the alpha channel, the results are undefined.) Certain operations (such as image composition using alpha blending) are faster using premultiplied ARGB32 than with plain ARGB32.</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_RGB16</code></td>
<td class="topAlign tblval"><code>7</code></td>
<td class="topAlign">The image is stored using a 16-bit RGB format (5-6-5).</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_ARGB8565_Premultiplied</code></td>
<td class="topAlign tblval"><code>8</code></td>
<td class="topAlign">The image is stored using a premultiplied 24-bit ARGB format (8-5-6-5).</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_RGB666</code></td>
<td class="topAlign tblval"><code>9</code></td>
<td class="topAlign">The image is stored using a 24-bit RGB format (6-6-6). The unused most significant bits is always zero.</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_ARGB6666_Premultiplied</code></td>
<td class="topAlign tblval"><code>10</code></td>
<td class="topAlign">The image is stored using a premultiplied 24-bit ARGB format (6-6-6-6).</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_RGB555</code></td>
<td class="topAlign tblval"><code>11</code></td>
<td class="topAlign">The image is stored using a 16-bit RGB format (5-5-5). The unused most significant bit is always zero.</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_ARGB8555_Premultiplied</code></td>
<td class="topAlign tblval"><code>12</code></td>
<td class="topAlign">The image is stored using a premultiplied 24-bit ARGB format (8-5-5-5).</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_RGB888</code></td>
<td class="topAlign tblval"><code>13</code></td>
<td class="topAlign">The image is stored using a 24-bit RGB format (8-8-8).</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_RGB444</code></td>
<td class="topAlign tblval"><code>14</code></td>
<td class="topAlign">The image is stored using a 16-bit RGB format (4-4-4). The unused bits are always zero.</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_ARGB4444_Premultiplied</code></td>
<td class="topAlign tblval"><code>15</code></td>
<td class="topAlign">The image is stored using a premultiplied 16-bit ARGB format (4-4-4-4).</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_RGBX8888</code></td>
<td class="topAlign tblval"><code>16</code></td>
<td class="topAlign">The image is stored using a 32-bit byte-ordered RGB(x) format (8-8-8-8). This is the same as the Format_RGBA8888 except alpha must always be 255. (added in Qt 5.2)</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_RGBA8888</code></td>
<td class="topAlign tblval"><code>17</code></td>
<td class="topAlign">The image is stored using a 32-bit byte-ordered RGBA format (8-8-8-8). Unlike ARGB32 this is a byte-ordered format, which means the 32bit encoding differs between big endian and little endian architectures, being respectively (0xRRGGBBAA) and (0xAABBGGRR). The order of the colors is the same on any architecture if read as bytes 0xRR,0xGG,0xBB,0xAA. (added in Qt 5.2)</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_RGBA8888_Premultiplied</code></td>
<td class="topAlign tblval"><code>18</code></td>
<td class="topAlign">The image is stored using a premultiplied 32-bit byte-ordered RGBA format (8-8-8-8). (added in Qt 5.2)</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_BGR30</code></td>
<td class="topAlign tblval"><code>19</code></td>
<td class="topAlign">The image is stored using a 32-bit BGR format (x-10-10-10). (added in Qt 5.4)</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_A2BGR30_Premultiplied</code></td>
<td class="topAlign tblval"><code>20</code></td>
<td class="topAlign">The image is stored using a 32-bit premultiplied ABGR format (2-10-10-10). (added in Qt 5.4)</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_RGB30</code></td>
<td class="topAlign tblval"><code>21</code></td>
<td class="topAlign">The image is stored using a 32-bit RGB format (x-10-10-10). (added in Qt 5.4)</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_A2RGB30_Premultiplied</code></td>
<td class="topAlign tblval"><code>22</code></td>
<td class="topAlign">The image is stored using a 32-bit premultiplied ARGB format (2-10-10-10). (added in Qt 5.4)</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_Alpha8</code></td>
<td class="topAlign tblval"><code>23</code></td>
<td class="topAlign">The image is stored using an 8-bit alpha only format. (added in Qt 5.5)</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_Grayscale8</code></td>
<td class="topAlign tblval"><code>24</code></td>
<td class="topAlign">The image is stored using an 8-bit grayscale format. (added in Qt 5.5)</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_Grayscale16</code></td>
<td class="topAlign tblval"><code>28</code></td>
<td class="topAlign">The image is stored using an 16-bit grayscale format. (added in Qt 5.13)</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_RGBX64</code></td>
<td class="topAlign tblval"><code>25</code></td>
<td class="topAlign">The image is stored using a 64-bit halfword-ordered RGB(x) format (16-16-16-16). This is the same as the Format_RGBA64 except alpha must always be 65535. (added in Qt 5.12)</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_RGBA64</code></td>
<td class="topAlign tblval"><code>26</code></td>
<td class="topAlign">The image is stored using a 64-bit halfword-ordered RGBA format (16-16-16-16). (added in Qt 5.12)</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_RGBA64_Premultiplied</code></td>
<td class="topAlign tblval"><code>27</code></td>
<td class="topAlign">The image is stored using a premultiplied 64-bit halfword-ordered RGBA format (16-16-16-16). (added in Qt 5.12)</td>
</tr> <tr>
<td class="topAlign"><code>QImage::Format_BGR888</code></td>
<td class="topAlign tblval"><code>29</code></td>
<td class="topAlign">The image is stored using a 24-bit BGR format. (added in Qt 5.14)</td>
</tr> </table> <p><b>Note: </b>Drawing into a <a href="qimage">QImage</a> with QImage::Format_Indexed8 is not supported.</p> <p><b>Note: </b>Avoid most rendering directly to most of these formats using <a href="qpainter">QPainter</a>. Rendering is best optimized to the <code>Format_RGB32</code> and <code>Format_ARGB32_Premultiplied</code> formats, and secondarily for rendering to the <code>Format_RGB16</code>, <code>Format_RGBX8888</code>, <code>Format_RGBA8888_Premultiplied</code>, <code>Format_RGBX64</code> and <code>Format_RGBA64_Premultiplied</code> formats</p> <p><b>See also </b><a href="qimage#format">format</a>() and <a href="qimage#convertToFormat">convertToFormat</a>().</p>   <h3 class="fn" id="InvertMode-enum">
enum QImage::<span class="name">InvertMode</span>
</h3> <p>This enum type is used to describe how pixel values should be inverted in the <a href="qimage#invertPixels">invertPixels</a>() function.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QImage::InvertRgb</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">Invert only the RGB values and leave the alpha channel unchanged.</td>
</tr> <tr>
<td class="topAlign"><code>QImage::InvertRgba</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">Invert all channels, including the alpha channel.</td>
</tr> </table> <p><b>See also </b><a href="qimage#invertPixels">invertPixels</a>().</p>    <h2>Member Function Documentation</h2>  <div class="fngroup"> <h3 class="fn fngroupitem" id="rgbSwapped-1">
<span class="type"><a href="qimage#QImage">QImage</a></span> &amp;&amp;QImage::<span class="name">rgbSwapped</span>() &amp;&amp;
</h3>
<h3 class="fn fngroupitem" id="rgbSwapped">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">rgbSwapped</span>() const &amp;
</h3>
</div> <p>Returns a <a href="qimage">QImage</a> in which the values of the red and blue components of all pixels have been swapped, effectively converting an RGB image to an BGR image.</p> <p>The original <a href="qimage">QImage</a> is not changed.</p> <p><b>See also </b><a href="qimage#image-transformations">Image Transformations</a>.</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="mirrored-1">
<span class="type"><a href="qimage#QImage">QImage</a></span> &amp;&amp;QImage::<span class="name">mirrored</span>(<span class="type">bool</span> <i>horizontal</i> = false, <span class="type">bool</span> <i>vertical</i> = true) &amp;&amp;
</h3>
<h3 class="fn fngroupitem" id="mirrored">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">mirrored</span>(<span class="type">bool</span> <i>horizontal</i> = false, <span class="type">bool</span> <i>vertical</i> = true) const &amp;
</h3>
</div> <p>Returns a mirror of the image, mirrored in the horizontal and/or the vertical direction depending on whether <i>horizontal</i> and <i>vertical</i> are set to true or false.</p> <p>Note that the original image is not changed.</p> <p><b>See also </b><a href="qimage#image-transformations">Image Transformations</a>.</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="convertToFormat-1">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">convertToFormat</span>(<span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> <i>format</i>, <span class="type"><a href="qt#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor) &amp;&amp;
</h3>
<h3 class="fn fngroupitem" id="convertToFormat">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">convertToFormat</span>(<span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> <i>format</i>, <span class="type"><a href="qt#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor) const &amp;
</h3>
</div> <p>Returns a copy of the image in the given <i>format</i>.</p> <p>The specified image conversion <i>flags</i> control how the image data is handled during the conversion process.</p> <p><b>See also </b><a href="qimage#image-formats">Image Formats</a>.</p>   <h3 class="fn" id="QImage-10">
QImage::<span class="name">QImage</span>(<span class="type"><a href="qimage#QImage">QImage</a></span> &amp;&amp;<i>other</i>)
</h3> <p>Move-constructs a QImage instance, making it point at the same object that <i>other</i> was pointing to.</p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="QImage-9">
QImage::<span class="name">QImage</span>(const <span class="type"><a href="qimage#QImage">QImage</a></span> &amp;<i>image</i>)
</h3> <p>Constructs a shallow copy of the given <i>image</i>.</p> <p>For more information about shallow copies, see the <a href="implicit-sharing">Implicit Data Sharing</a> documentation.</p> <p><b>See also </b><a href="qimage#copy">copy</a>().</p>   <h3 class="fn" id="QImage-8">
QImage::<span class="name">QImage</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>fileName</i>, const <span class="type">char</span> *<i>format</i> = nullptr)
</h3> <p>Constructs an image and tries to load the image from the file with the given <i>fileName</i>.</p> <p>The loader attempts to read the image using the specified <i>format</i>. If the <i>format</i> is not specified (which is the default), it is auto-detected based on the file's suffix and header. For details, see {<a href="qimagereader#setAutoDetectImageFormat">QImageReader::setAutoDetectImageFormat</a>()}{<a href="qimagereader">QImageReader</a>}.</p> <p>If the loading of the image failed, this object is a null image.</p> <p>The file name can either refer to an actual file on disk or to one of the application's embedded resources. See the <a href="resources">Resource System</a> overview for details on how to embed images and other resource files in the application's executable.</p> <p><b>See also </b><a href="qimage#isNull">isNull</a>() and <a href="qimage#reading-and-writing-image-files">Reading and Writing Image Files</a>.</p>   <h3 class="fn" id="QImage-7">
QImage::<span class="name">QImage</span>(const <span class="type">char</span> *const [] <i>xpm</i>)
</h3> <p>Constructs an image from the given <i>xpm</i> image.</p> <p>Make sure that the image is a valid XPM image. Errors are silently ignored.</p> <p>Note that it's possible to squeeze the XPM variable a little bit by using an unusual declaration:</p> <pre data-language="cpp">static const char * const start_xpm[] = {
    "16 15 8 1",
    "a c #cec6bd",
....</pre> <p>The extra <code>const</code> makes the entire definition read-only, which is slightly more efficient (e.g., when the code is in a shared library) and able to be stored in ROM with the application.</p>   <h3 class="fn" id="QImage-6">
QImage::<span class="name">QImage</span>(const <span class="type"><a href="qtglobal#uchar-typedef">uchar</a></span> *<i>data</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>bytesPerLine</i>, <span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> <i>format</i>, <span class="type"><a href="qimage#QImageCleanupFunction-typedef">QImageCleanupFunction</a></span> <i>cleanupFunction</i> = nullptr, <span class="type">void</span> *<i>cleanupInfo</i> = nullptr)
</h3> <p>Constructs an image with the given <i>width</i>, <i>height</i> and <i>format</i>, that uses an existing memory buffer, <i>data</i>. The <i>width</i> and <i>height</i> must be specified in pixels. <i>bytesPerLine</i> specifies the number of bytes per line (stride).</p> <p>The buffer must remain valid throughout the life of the QImage and all copies that have not been modified or otherwise detached from the original buffer. The image does not delete the buffer at destruction. You can provide a function pointer <i>cleanupFunction</i> along with an extra pointer <i>cleanupInfo</i> that will be called when the last copy is destroyed.</p> <p>If <i>format</i> is an indexed color format, the image color table is initially empty and must be sufficiently expanded with <a href="qimage#setColorCount">setColorCount</a>() or <a href="qimage#setColorTable">setColorTable</a>() before the image is used.</p> <p>Unlike the similar QImage constructor that takes a non-const data buffer, this version will never alter the contents of the buffer. For example, calling <a href="qimage#bits">QImage::bits</a>() will return a deep copy of the image, rather than the buffer passed to the constructor. This allows for the efficiency of constructing a QImage from raw data, without the possibility of the raw data being changed.</p>   <h3 class="fn" id="QImage-5">
QImage::<span class="name">QImage</span>(<span class="type"><a href="qtglobal#uchar-typedef">uchar</a></span> *<i>data</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">int</span> <i>bytesPerLine</i>, <span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> <i>format</i>, <span class="type"><a href="qimage#QImageCleanupFunction-typedef">QImageCleanupFunction</a></span> <i>cleanupFunction</i> = nullptr, <span class="type">void</span> *<i>cleanupInfo</i> = nullptr)
</h3> <p>Constructs an image with the given <i>width</i>, <i>height</i> and <i>format</i>, that uses an existing memory buffer, <i>data</i>. The <i>width</i> and <i>height</i> must be specified in pixels. <i>bytesPerLine</i> specifies the number of bytes per line (stride).</p> <p>The buffer must remain valid throughout the life of the QImage and all copies that have not been modified or otherwise detached from the original buffer. The image does not delete the buffer at destruction. You can provide a function pointer <i>cleanupFunction</i> along with an extra pointer <i>cleanupInfo</i> that will be called when the last copy is destroyed.</p> <p>If <i>format</i> is an indexed color format, the image color table is initially empty and must be sufficiently expanded with <a href="qimage#setColorCount">setColorCount</a>() or <a href="qimage#setColorTable">setColorTable</a>() before the image is used.</p>   <h3 class="fn" id="QImage-4">
QImage::<span class="name">QImage</span>(const <span class="type"><a href="qtglobal#uchar-typedef">uchar</a></span> *<i>data</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> <i>format</i>, <span class="type"><a href="qimage#QImageCleanupFunction-typedef">QImageCleanupFunction</a></span> <i>cleanupFunction</i> = nullptr, <span class="type">void</span> *<i>cleanupInfo</i> = nullptr)
</h3> <p>Constructs an image with the given <i>width</i>, <i>height</i> and <i>format</i>, that uses an existing read-only memory buffer, <i>data</i>. The <i>width</i> and <i>height</i> must be specified in pixels, <i>data</i> must be 32-bit aligned, and each scanline of data in the image must also be 32-bit aligned.</p> <p>The buffer must remain valid throughout the life of the QImage and all copies that have not been modified or otherwise detached from the original buffer. The image does not delete the buffer at destruction. You can provide a function pointer <i>cleanupFunction</i> along with an extra pointer <i>cleanupInfo</i> that will be called when the last copy is destroyed.</p> <p>If <i>format</i> is an indexed color format, the image color table is initially empty and must be sufficiently expanded with <a href="qimage#setColorCount">setColorCount</a>() or <a href="qimage#setColorTable">setColorTable</a>() before the image is used.</p> <p>Unlike the similar QImage constructor that takes a non-const data buffer, this version will never alter the contents of the buffer. For example, calling <a href="qimage#bits">QImage::bits</a>() will return a deep copy of the image, rather than the buffer passed to the constructor. This allows for the efficiency of constructing a QImage from raw data, without the possibility of the raw data being changed.</p>   <h3 class="fn" id="QImage-3">
QImage::<span class="name">QImage</span>(<span class="type"><a href="qtglobal#uchar-typedef">uchar</a></span> *<i>data</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> <i>format</i>, <span class="type"><a href="qimage#QImageCleanupFunction-typedef">QImageCleanupFunction</a></span> <i>cleanupFunction</i> = nullptr, <span class="type">void</span> *<i>cleanupInfo</i> = nullptr)
</h3> <p>Constructs an image with the given <i>width</i>, <i>height</i> and <i>format</i>, that uses an existing memory buffer, <i>data</i>. The <i>width</i> and <i>height</i> must be specified in pixels, <i>data</i> must be 32-bit aligned, and each scanline of data in the image must also be 32-bit aligned.</p> <p>The buffer must remain valid throughout the life of the QImage and all copies that have not been modified or otherwise detached from the original buffer. The image does not delete the buffer at destruction. You can provide a function pointer <i>cleanupFunction</i> along with an extra pointer <i>cleanupInfo</i> that will be called when the last copy is destroyed.</p> <p>If <i>format</i> is an indexed color format, the image color table is initially empty and must be sufficiently expanded with <a href="qimage#setColorCount">setColorCount</a>() or <a href="qimage#setColorTable">setColorTable</a>() before the image is used.</p>   <h3 class="fn" id="QImage-2">
QImage::<span class="name">QImage</span>(<span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> <i>format</i>)
</h3> <p>Constructs an image with the given <i>width</i>, <i>height</i> and <i>format</i>.</p> <p>A <a href="qimage#isNull">null</a> image will be returned if memory cannot be allocated.</p> <p><b>Warning:</b> This will create a QImage with uninitialized data. Call <a href="qimage#fill">fill</a>() to fill the image with an appropriate pixel value before drawing onto it with <a href="qpainter">QPainter</a>.</p>   <h3 class="fn" id="QImage-1">
QImage::<span class="name">QImage</span>(const <span class="type"><a href="qsize">QSize</a></span> &amp;<i>size</i>, <span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> <i>format</i>)
</h3> <p>Constructs an image with the given <i>size</i> and <i>format</i>.</p> <p>A <a href="qimage#isNull">null</a> image is returned if memory cannot be allocated.</p> <p><b>Warning:</b> This will create a QImage with uninitialized data. Call <a href="qimage#fill">fill</a>() to fill the image with an appropriate pixel value before drawing onto it with <a href="qpainter">QPainter</a>.</p>   <h3 class="fn" id="QImage">
QImage::<span class="name">QImage</span>()
</h3> <p>Constructs a null image.</p> <p><b>See also </b><a href="qimage#isNull">isNull</a>().</p>   <h3 class="fn" id="operator-eq-1">
<span class="type"><a href="qimage#QImage">QImage</a></span> &amp;QImage::<span class="name">operator=</span>(<span class="type"><a href="qimage#QImage">QImage</a></span> &amp;&amp;<i>other</i>)
</h3> <p>Move-assigns <i>other</i> to this <a href="qimage">QImage</a> instance.</p> <p>This function was introduced in Qt 5.2.</p>   <h3 class="fn" id="operator-eq">
<span class="type"><a href="qimage#QImage">QImage</a></span> &amp;QImage::<span class="name">operator=</span>(const <span class="type"><a href="qimage#QImage">QImage</a></span> &amp;<i>image</i>)
</h3> <p>Assigns a shallow copy of the given <i>image</i> to this image and returns a reference to this image.</p> <p>For more information about shallow copies, see the <a href="implicit-sharing">Implicit Data Sharing</a> documentation.</p> <p><b>See also </b><a href="qimage#copy">copy</a>() and <a href="qimage#QImage">QImage</a>().</p>   <h3 class="fn" id="dtor.QImage">
<code>[virtual] </code>QImage::<span class="name">~QImage</span>()
</h3> <p>Destroys the image and cleans up.</p>   <h3 class="fn" id="allGray">
<span class="type">bool</span> QImage::<span class="name">allGray</span>() const
</h3> <p>Returns <code>true</code> if all the colors in the image are shades of gray (i.e. their red, green and blue components are equal); otherwise false.</p> <p>Note that this function is slow for images without color table.</p> <p><b>See also </b><a href="qimage#isGrayscale">isGrayscale</a>().</p>   <h3 class="fn" id="applyColorTransform">
<span class="type">void</span> QImage::<span class="name">applyColorTransform</span>(const <span class="type"><a href="qcolortransform">QColorTransform</a></span> &amp;<i>transform</i>)
</h3> <p>Applies the color transformation <i>transform</i> to all pixels in the image.</p> <p>This function was introduced in Qt 5.14.</p>   <h3 class="fn" id="bitPlaneCount">
<span class="type">int</span> QImage::<span class="name">bitPlaneCount</span>() const
</h3> <p>Returns the number of bit planes in the image.</p> <p>The number of bit planes is the number of bits of color and transparency information for each pixel. This is different from (i.e. smaller than) the depth when the image format contains unused bits.</p> <p>This function was introduced in Qt 4.7.</p> <p><b>See also </b><a href="qimage#depth">depth</a>(), <a href="qimage#format">format</a>(), and <a href="qimage#image-formats">Image Formats</a>.</p>   <h3 class="fn" id="bits">
<span class="type"><a href="qtglobal#uchar-typedef">uchar</a></span> *QImage::<span class="name">bits</span>()
</h3> <p>Returns a pointer to the first pixel data. This is equivalent to <a href="qimage#scanLine">scanLine</a>(0).</p> <p>Note that <a href="qimage">QImage</a> uses <a href="implicit-sharing">implicit data sharing</a>. This function performs a deep copy of the shared pixel data, thus ensuring that this <a href="qimage">QImage</a> is the only one using the current return value.</p> <p><b>See also </b><a href="qimage#scanLine">scanLine</a>(), <a href="qimage#sizeInBytes">sizeInBytes</a>(), and <a href="qimage#constBits">constBits</a>().</p>   <h3 class="fn" id="bits-1">
const <span class="type"><a href="qtglobal#uchar-typedef">uchar</a></span> *QImage::<span class="name">bits</span>() const
</h3> <p>This is an overloaded function.</p> <p>Note that <a href="qimage">QImage</a> uses <a href="implicit-sharing">implicit data sharing</a>, but this function does <i>not</i> perform a deep copy of the shared pixel data, because the returned data is const.</p>   <h3 class="fn" id="bytesPerLine">
<span class="type">int</span> QImage::<span class="name">bytesPerLine</span>() const
</h3> <p>Returns the number of bytes per image scanline.</p> <p>This is equivalent to <a href="qimage#sizeInBytes">sizeInBytes</a>() / <a href="qimage#height">height</a>() if <a href="qimage#height">height</a>() is non-zero.</p> <p><b>See also </b><a href="qimage#scanLine">scanLine</a>().</p>   <h3 class="fn" id="cacheKey">
<span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> QImage::<span class="name">cacheKey</span>() const
</h3> <p>Returns a number that identifies the contents of this <a href="qimage">QImage</a> object. Distinct <a href="qimage">QImage</a> objects can only have the same key if they refer to the same contents.</p> <p>The key will change when the image is altered.</p>   <h3 class="fn" id="color">
<span class="type"><a href="qcolor#QRgb-typedef">QRgb</a></span> QImage::<span class="name">color</span>(<span class="type">int</span> <i>i</i>) const
</h3> <p>Returns the color in the color table at index <i>i</i>. The first color is at index 0.</p> <p>The colors in an image's color table are specified as ARGB quadruplets (<a href="qcolor#QRgb-typedef">QRgb</a>). Use the <a href="qcolor#qAlpha">qAlpha</a>(), <a href="qcolor#qRed">qRed</a>(), <a href="qcolor#qGreen">qGreen</a>(), and <a href="qcolor#qBlue">qBlue</a>() functions to get the color value components.</p> <p><b>See also </b><a href="qimage#setColor">setColor</a>(), <a href="qimage#pixelIndex">pixelIndex</a>(), and <a href="qimage#pixel-manipulation">Pixel Manipulation</a>.</p>   <h3 class="fn" id="colorCount">
<span class="type">int</span> QImage::<span class="name">colorCount</span>() const
</h3> <p>Returns the size of the color table for the image.</p> <p>Notice that colorCount() returns 0 for 32-bpp images because these images do not use color tables, but instead encode pixel values as ARGB quadruplets.</p> <p>This function was introduced in Qt 4.6.</p> <p><b>See also </b><a href="qimage#setColorCount">setColorCount</a>() and <a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="colorSpace">
<span class="type"><a href="qcolorspace">QColorSpace</a></span> QImage::<span class="name">colorSpace</span>() const
</h3> <p>Returns the color space of the image if a color space is defined.</p> <p>This function was introduced in Qt 5.14.</p> <p><b>See also </b><a href="qimage#setColorSpace">setColorSpace</a>().</p>   <h3 class="fn" id="colorTable">
<span class="type"><a href="qvector">QVector</a></span>&lt;<span class="type"><a href="qcolor#QRgb-typedef">QRgb</a></span>&gt; QImage::<span class="name">colorTable</span>() const
</h3> <p>Returns a list of the colors contained in the image's color table, or an empty list if the image does not have a color table</p> <p><b>See also </b><a href="qimage#setColorTable">setColorTable</a>(), <a href="qimage#colorCount">colorCount</a>(), and <a href="qimage#color">color</a>().</p>   <h3 class="fn" id="constBits">
const <span class="type"><a href="qtglobal#uchar-typedef">uchar</a></span> *QImage::<span class="name">constBits</span>() const
</h3> <p>Returns a pointer to the first pixel data.</p> <p>Note that <a href="qimage">QImage</a> uses <a href="implicit-sharing">implicit data sharing</a>, but this function does <i>not</i> perform a deep copy of the shared pixel data, because the returned data is const.</p> <p>This function was introduced in Qt 4.7.</p> <p><b>See also </b><a href="qimage#bits">bits</a>() and <a href="qimage#constScanLine">constScanLine</a>().</p>   <h3 class="fn" id="constScanLine">
const <span class="type"><a href="qtglobal#uchar-typedef">uchar</a></span> *QImage::<span class="name">constScanLine</span>(<span class="type">int</span> <i>i</i>) const
</h3> <p>Returns a pointer to the pixel data at the scanline with index <i>i</i>. The first scanline is at index 0.</p> <p>The scanline data is as minimum 32-bit aligned. For 64-bit formats it follows the native alignment of 64-bit integers (64-bit for most platforms, but notably 32-bit on i386).</p> <p>Note that <a href="qimage">QImage</a> uses <a href="implicit-sharing">implicit data sharing</a>, but this function does <i>not</i> perform a deep copy of the shared pixel data, because the returned data is const.</p> <p>This function was introduced in Qt 4.7.</p> <p><b>See also </b><a href="qimage#scanLine">scanLine</a>() and <a href="qimage#constBits">constBits</a>().</p>   <h3 class="fn" id="convertTo">
<span class="type">void</span> QImage::<span class="name">convertTo</span>(<span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> <i>format</i>, <span class="type"><a href="qt#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor)
</h3> <p>Detach and convert the image to the given <i>format</i> in place.</p> <p>The specified image conversion <i>flags</i> control how the image data is handled during the conversion process.</p> <p>This function was introduced in Qt 5.13.</p> <p><b>See also </b><a href="qimage#convertToFormat">convertToFormat</a>().</p>   <h3 class="fn" id="convertToColorSpace">
<span class="type">void</span> QImage::<span class="name">convertToColorSpace</span>(const <span class="type"><a href="qcolorspace">QColorSpace</a></span> &amp;<i>colorSpace</i>)
</h3> <p>Converts the image to <i>colorSpace</i>.</p> <p>If the image has no valid color space, the method does nothing.</p> <p>This function was introduced in Qt 5.14.</p> <p><b>See also </b><a href="qimage#convertedToColorSpace">convertedToColorSpace</a>() and <a href="qimage#setColorSpace">setColorSpace</a>().</p>   <h3 class="fn" id="convertToFormat-2">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">convertToFormat</span>(<span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> <i>format</i>, const <span class="type"><a href="qvector">QVector</a></span>&lt;<span class="type"><a href="qcolor#QRgb-typedef">QRgb</a></span>&gt; &amp;<i>colorTable</i>, <span class="type"><a href="qt#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor) const
</h3> <p>This is an overloaded function.</p> <p>Returns a copy of the image converted to the given <i>format</i>, using the specified <i>colorTable</i>.</p> <p>Conversion from RGB formats to indexed formats is a slow operation and will use a straightforward nearest color approach, with no dithering.</p>   <h3 class="fn" id="convertedToColorSpace">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">convertedToColorSpace</span>(const <span class="type"><a href="qcolorspace">QColorSpace</a></span> &amp;<i>colorSpace</i>) const
</h3> <p>Returns the image converted to <i>colorSpace</i>.</p> <p>If the image has no valid color space, a null <a href="qimage">QImage</a> is returned.</p> <p>This function was introduced in Qt 5.14.</p> <p><b>See also </b><a href="qimage#convertToColorSpace">convertToColorSpace</a>().</p>   <h3 class="fn" id="copy">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">copy</span>(const <span class="type"><a href="qrect">QRect</a></span> &amp;<i>rectangle</i> = QRect()) const
</h3> <p>Returns a sub-area of the image as a new image.</p> <p>The returned image is copied from the position (<i>rectangle</i>.x(), <i>rectangle</i>.y()) in this image, and will always have the size of the given <i>rectangle</i>.</p> <p>In areas beyond this image, pixels are set to 0. For 32-bit RGB images, this means black; for 32-bit ARGB images, this means transparent black; for 8-bit images, this means the color with index 0 in the color table which can be anything; for 1-bit images, this means <a href="qt#GlobalColor-enum">Qt::color0</a>.</p> <p>If the given <i>rectangle</i> is a null rectangle the entire image is copied.</p> <p><b>See also </b><a href="qimage#QImage">QImage</a>().</p>   <h3 class="fn" id="copy-1">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">copy</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>) const
</h3> <p>This is an overloaded function.</p> <p>The returned image is copied from the position (<i>x</i>, <i>y</i>) in this image, and will always have the given <i>width</i> and <i>height</i>. In areas beyond this image, pixels are set to 0.</p>   <h3 class="fn" id="createAlphaMask">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">createAlphaMask</span>(<span class="type"><a href="qt#ImageConversionFlag-enum">Qt::ImageConversionFlags</a></span> <i>flags</i> = Qt::AutoColor) const
</h3> <p>Builds and returns a 1-bpp mask from the alpha buffer in this image. Returns a null image if the image's format is <a href="qimage#Format-enum">QImage::Format_RGB32</a>.</p> <p>The <i>flags</i> argument is a bitwise-OR of the <a href="qt#ImageConversionFlag-enum">Qt::ImageConversionFlags</a>, and controls the conversion process. Passing 0 for flags sets all the default options.</p> <p>The returned image has little-endian bit order (i.e. the image's format is <a href="qimage#Format-enum">QImage::Format_MonoLSB</a>), which you can convert to big-endian (<a href="qimage#Format-enum">QImage::Format_Mono</a>) using the <a href="qimage#convertToFormat">convertToFormat</a>() function.</p> <p><b>See also </b><a href="qimage#createHeuristicMask">createHeuristicMask</a>() and <a href="qimage#image-transformations">Image Transformations</a>.</p>   <h3 class="fn" id="createHeuristicMask">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">createHeuristicMask</span>(<span class="type">bool</span> <i>clipTight</i> = true) const
</h3> <p>Creates and returns a 1-bpp heuristic mask for this image.</p> <p>The function works by selecting a color from one of the corners, then chipping away pixels of that color starting at all the edges. The four corners vote for which color is to be masked away. In case of a draw (this generally means that this function is not applicable to the image), the result is arbitrary.</p> <p>The returned image has little-endian bit order (i.e. the image's format is <a href="qimage#Format-enum">QImage::Format_MonoLSB</a>), which you can convert to big-endian (<a href="qimage#Format-enum">QImage::Format_Mono</a>) using the <a href="qimage#convertToFormat">convertToFormat</a>() function.</p> <p>If <i>clipTight</i> is true (the default) the mask is just large enough to cover the pixels; otherwise, the mask is larger than the data pixels.</p> <p>Note that this function disregards the alpha buffer.</p> <p><b>See also </b><a href="qimage#createAlphaMask">createAlphaMask</a>() and <a href="qimage#image-transformations">Image Transformations</a>.</p>   <h3 class="fn" id="createMaskFromColor">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">createMaskFromColor</span>(<span class="type"><a href="qcolor#QRgb-typedef">QRgb</a></span> <i>color</i>, <span class="type"><a href="qt#MaskMode-enum">Qt::MaskMode</a></span> <i>mode</i> = Qt::MaskInColor) const
</h3> <p>Creates and returns a mask for this image based on the given <i>color</i> value. If the <i>mode</i> is MaskInColor (the default value), all pixels matching <i>color</i> will be opaque pixels in the mask. If <i>mode</i> is MaskOutColor, all pixels matching the given color will be transparent.</p> <p><b>See also </b><a href="qimage#createAlphaMask">createAlphaMask</a>() and <a href="qimage#createHeuristicMask">createHeuristicMask</a>().</p>   <h3 class="fn" id="depth">
<span class="type">int</span> QImage::<span class="name">depth</span>() const
</h3> <p>Returns the depth of the image.</p> <p>The image depth is the number of bits used to store a single pixel, also called bits per pixel (bpp).</p> <p>The supported depths are 1, 8, 16, 24, 32 and 64.</p> <p><b>See also </b><a href="qimage#bitPlaneCount">bitPlaneCount</a>(), <a href="qimage#convertToFormat">convertToFormat</a>(), <a href="qimage#image-formats">Image Formats</a>, and <a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="devicePixelRatio">
<span class="type"><a href="qtglobal#qreal-typedef">qreal</a></span> QImage::<span class="name">devicePixelRatio</span>() const
</h3> <p>Returns the device pixel ratio for the image. This is the ratio between <i>device pixels</i> and <i>device independent pixels</i>.</p> <p>Use this function when calculating layout geometry based on the image size: <a href="qsize">QSize</a> layoutSize = image.<a href="qimage#size">size</a>() / image.devicePixelRatio()</p> <p>The default value is 1.0.</p> <p><b>See also </b><a href="qimage#setDevicePixelRatio">setDevicePixelRatio</a>() and <a href="qimagereader">QImageReader</a>.</p>   <h3 class="fn" id="dotsPerMeterX">
<span class="type">int</span> QImage::<span class="name">dotsPerMeterX</span>() const
</h3> <p>Returns the number of pixels that fit horizontally in a physical meter. Together with <a href="qimage#dotsPerMeterY">dotsPerMeterY</a>(), this number defines the intended scale and aspect ratio of the image.</p> <p><b>See also </b><a href="qimage#setDotsPerMeterX">setDotsPerMeterX</a>() and <a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="dotsPerMeterY">
<span class="type">int</span> QImage::<span class="name">dotsPerMeterY</span>() const
</h3> <p>Returns the number of pixels that fit vertically in a physical meter. Together with <a href="qimage#dotsPerMeterX">dotsPerMeterX</a>(), this number defines the intended scale and aspect ratio of the image.</p> <p><b>See also </b><a href="qimage#setDotsPerMeterY">setDotsPerMeterY</a>() and <a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="fill">
<span class="type">void</span> QImage::<span class="name">fill</span>(<span class="type"><a href="qtglobal#uint-typedef">uint</a></span> <i>pixelValue</i>)
</h3> <p>Fills the entire image with the given <i>pixelValue</i>.</p> <p>If the depth of this image is 1, only the lowest bit is used. If you say fill(0), fill(2), etc., the image is filled with 0s. If you say fill(1), fill(3), etc., the image is filled with 1s. If the depth is 8, the lowest 8 bits are used and if the depth is 16 the lowest 16 bits are used.</p> <p>Note: <a href="qimage#pixel">QImage::pixel</a>() returns the color of the pixel at the given coordinates while QColor::pixel() returns the pixel value of the underlying window system (essentially an index value), so normally you will want to use <a href="qimage#pixel">QImage::pixel</a>() to use a color from an existing image or <a href="qcolor#rgb">QColor::rgb</a>() to use a specific color.</p> <p><b>See also </b><a href="qimage#depth">depth</a>() and <a href="qimage#image-transformations">Image Transformations</a>.</p>   <h3 class="fn" id="fill-1">
<span class="type">void</span> QImage::<span class="name">fill</span>(const <span class="type"><a href="qcolor">QColor</a></span> &amp;<i>color</i>)
</h3> <p>This is an overloaded function.</p> <p>Fills the entire image with the given <i>color</i>.</p> <p>If the depth of the image is 1, the image will be filled with 1 if <i>color</i> equals <a href="qt#GlobalColor-enum">Qt::color1</a>; it will otherwise be filled with 0.</p> <p>If the depth of the image is 8, the image will be filled with the index corresponding the <i>color</i> in the color table if present; it will otherwise be filled with 0.</p> <p>This function was introduced in Qt 4.8.</p>   <h3 class="fn" id="fill-2">
<span class="type">void</span> QImage::<span class="name">fill</span>(<span class="type"><a href="qt#GlobalColor-enum">Qt::GlobalColor</a></span> <i>color</i>)
</h3> <p>This is an overloaded function.</p> <p>Fills the image with the given <i>color</i>, described as a standard global color.</p> <p>This function was introduced in Qt 4.8.</p>   <h3 class="fn" id="format">
<span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> QImage::<span class="name">format</span>() const
</h3> <p>Returns the format of the image.</p> <p><b>See also </b><a href="qimage#image-formats">Image Formats</a>.</p>   <h3 class="fn" id="fromData">
<code>[static] </code><span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">fromData</span>(const <span class="type"><a href="qtglobal#uchar-typedef">uchar</a></span> *<i>data</i>, <span class="type">int</span> <i>size</i>, const <span class="type">char</span> *<i>format</i> = nullptr)
</h3> <p>Constructs a <a href="qimage">QImage</a> from the first <i>size</i> bytes of the given binary <i>data</i>. The loader attempts to read the image using the specified <i>format</i>. If <i>format</i> is not specified (which is the default), the loader probes the data for a header to guess the file format.</p> <p>If <i>format</i> is specified, it must be one of the values returned by <a href="qimagereader#supportedImageFormats">QImageReader::supportedImageFormats</a>().</p> <p>If the loading of the image fails, the image returned will be a null image.</p> <p><b>See also </b><a href="qimage#load">load</a>(), <a href="qimage#save">save</a>(), and <a href="qimage#reading-and-writing-image-files">Reading and Writing Image Files</a>.</p>   <h3 class="fn" id="fromData-1">
<code>[static] </code><span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">fromData</span>(const <span class="type"><a href="qbytearray">QByteArray</a></span> &amp;<i>data</i>, const <span class="type">char</span> *<i>format</i> = nullptr)
</h3> <p>This is an overloaded function.</p> <p>Loads an image from the given <a href="qbytearray">QByteArray</a> <i>data</i>.</p>   <h3 class="fn" id="hasAlphaChannel">
<span class="type">bool</span> QImage::<span class="name">hasAlphaChannel</span>() const
</h3> <p>Returns <code>true</code> if the image has a format that respects the alpha channel, otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="height">
<span class="type">int</span> QImage::<span class="name">height</span>() const
</h3> <p>Returns the height of the image.</p> <p><b>See also </b><a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="invertPixels">
<span class="type">void</span> QImage::<span class="name">invertPixels</span>(<span class="type"><a href="qimage#InvertMode-enum">QImage::InvertMode</a></span> <i>mode</i> = InvertRgb)
</h3> <p>Inverts all pixel values in the image.</p> <p>The given invert <i>mode</i> only have a meaning when the image's depth is 32. The default <i>mode</i> is <a href="qimage#InvertMode-enum">InvertRgb</a>, which leaves the alpha channel unchanged. If the <i>mode</i> is <a href="qimage#InvertMode-enum">InvertRgba</a>, the alpha bits are also inverted.</p> <p>Inverting an 8-bit image means to replace all pixels using color index <i>i</i> with a pixel using color index 255 minus <i>i</i>. The same is the case for a 1-bit image. Note that the color table is <i>not</i> changed.</p> <p>If the image has a premultiplied alpha channel, the image is first converted to an unpremultiplied image format to be inverted and then converted back.</p> <p><b>See also </b><a href="qimage#image-transformations">Image Transformations</a>.</p>   <h3 class="fn" id="isGrayscale">
<span class="type">bool</span> QImage::<span class="name">isGrayscale</span>() const
</h3> <p>For 32-bit images, this function is equivalent to <a href="qimage#allGray">allGray</a>().</p> <p>For color indexed images, this function returns <code>true</code> if color(i) is <a href="qcolor#QRgb-typedef">QRgb</a>(i, i, i) for all indexes of the color table; otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qimage#allGray">allGray</a>() and <a href="qimage#image-formats">Image Formats</a>.</p>   <h3 class="fn" id="isNull">
<span class="type">bool</span> QImage::<span class="name">isNull</span>() const
</h3> <p>Returns <code>true</code> if it is a null image, otherwise returns <code>false</code>.</p> <p>A null image has all parameters set to zero and no allocated data.</p>   <h3 class="fn" id="load">
<span class="type">bool</span> QImage::<span class="name">load</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>fileName</i>, const <span class="type">char</span> *<i>format</i> = nullptr)
</h3> <p>Loads an image from the file with the given <i>fileName</i>. Returns <code>true</code> if the image was successfully loaded; otherwise invalidates the image and returns <code>false</code>.</p> <p>The loader attempts to read the image using the specified <i>format</i>, e.g., PNG or JPG. If <i>format</i> is not specified (which is the default), it is auto-detected based on the file's suffix and header. For details, see <a href="qimagereader#setAutoDetectImageFormat">QImageReader::setAutoDetectImageFormat</a>().</p> <p>The file name can either refer to an actual file on disk or to one of the application's embedded resources. See the <a href="resources">Resource System</a> overview for details on how to embed images and other resource files in the application's executable.</p> <p><b>See also </b><a href="qimage#reading-and-writing-image-files">Reading and Writing Image Files</a>.</p>   <h3 class="fn" id="load-1">
<span class="type">bool</span> QImage::<span class="name">load</span>(<span class="type"><a href="qiodevice">QIODevice</a></span> *<i>device</i>, const <span class="type">char</span> *<i>format</i>)
</h3> <p>This is an overloaded function.</p> <p>This function reads a <a href="qimage">QImage</a> from the given <i>device</i>. This can, for example, be used to load an image directly into a <a href="qbytearray">QByteArray</a>.</p>   <h3 class="fn" id="loadFromData">
<span class="type">bool</span> QImage::<span class="name">loadFromData</span>(const <span class="type"><a href="qtglobal#uchar-typedef">uchar</a></span> *<i>data</i>, <span class="type">int</span> <i>len</i>, const <span class="type">char</span> *<i>format</i> = nullptr)
</h3> <p>Loads an image from the first <i>len</i> bytes of the given binary <i>data</i>. Returns <code>true</code> if the image was successfully loaded; otherwise invalidates the image and returns <code>false</code>.</p> <p>The loader attempts to read the image using the specified <i>format</i>, e.g., PNG or JPG. If <i>format</i> is not specified (which is the default), the loader probes the file for a header to guess the file format.</p> <p><b>See also </b><a href="qimage#reading-and-writing-image-files">Reading and Writing Image Files</a>.</p>   <h3 class="fn" id="loadFromData-1">
<span class="type">bool</span> QImage::<span class="name">loadFromData</span>(const <span class="type"><a href="qbytearray">QByteArray</a></span> &amp;<i>data</i>, const <span class="type">char</span> *<i>format</i> = nullptr)
</h3> <p>This is an overloaded function.</p> <p>Loads an image from the given <a href="qbytearray">QByteArray</a> <i>data</i>.</p>   <h3 class="fn" id="offset">
<span class="type"><a href="qpoint">QPoint</a></span> QImage::<span class="name">offset</span>() const
</h3> <p>Returns the number of pixels by which the image is intended to be offset by when positioning relative to other images.</p> <p><b>See also </b><a href="qimage#setOffset">setOffset</a>() and <a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="pixel">
<span class="type"><a href="qcolor#QRgb-typedef">QRgb</a></span> QImage::<span class="name">pixel</span>(const <span class="type"><a href="qpoint">QPoint</a></span> &amp;<i>position</i>) const
</h3> <p>Returns the color of the pixel at the given <i>position</i>.</p> <p>If the <i>position</i> is not valid, the results are undefined.</p> <p><b>Warning:</b> This function is expensive when used for massive pixel manipulations. Use <a href="qimage#constBits">constBits</a>() or <a href="qimage#constScanLine">constScanLine</a>() when many pixels needs to be read.</p> <p><b>See also </b><a href="qimage#setPixel">setPixel</a>(), <a href="qimage#valid">valid</a>(), <a href="qimage#constBits">constBits</a>(), <a href="qimage#constScanLine">constScanLine</a>(), and <a href="qimage#pixel-manipulation">Pixel Manipulation</a>.</p>   <h3 class="fn" id="pixel-1">
<span class="type"><a href="qcolor#QRgb-typedef">QRgb</a></span> QImage::<span class="name">pixel</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns the color of the pixel at coordinates (<i>x</i>, <i>y</i>).</p>   <h3 class="fn" id="pixelColor">
<span class="type"><a href="qcolor">QColor</a></span> QImage::<span class="name">pixelColor</span>(const <span class="type"><a href="qpoint">QPoint</a></span> &amp;<i>position</i>) const
</h3> <p>Returns the color of the pixel at the given <i>position</i> as a <a href="qcolor">QColor</a>.</p> <p>If the <i>position</i> is not valid, an invalid <a href="qcolor">QColor</a> is returned.</p> <p><b>Warning:</b> This function is expensive when used for massive pixel manipulations. Use <a href="qimage#constBits">constBits</a>() or <a href="qimage#constScanLine">constScanLine</a>() when many pixels needs to be read.</p> <p>This function was introduced in Qt 5.6.</p> <p><b>See also </b><a href="qimage#setPixelColor">setPixelColor</a>(), <a href="qimage#setPixel">setPixel</a>(), <a href="qimage#valid">valid</a>(), <a href="qimage#constBits">constBits</a>(), <a href="qimage#constScanLine">constScanLine</a>(), and <a href="qimage#pixel-manipulation">Pixel Manipulation</a>.</p>   <h3 class="fn" id="pixelColor-1">
<span class="type"><a href="qcolor">QColor</a></span> QImage::<span class="name">pixelColor</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns the color of the pixel at coordinates (<i>x</i>, <i>y</i>) as a <a href="qcolor">QColor</a>.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="pixelFormat">
<span class="type"><a href="qpixelformat">QPixelFormat</a></span> QImage::<span class="name">pixelFormat</span>() const
</h3> <p>Returns the <a href="qimage#Format-enum">QImage::Format</a> as a <a href="qpixelformat">QPixelFormat</a></p>   <h3 class="fn" id="pixelIndex">
<span class="type">int</span> QImage::<span class="name">pixelIndex</span>(const <span class="type"><a href="qpoint">QPoint</a></span> &amp;<i>position</i>) const
</h3> <p>Returns the pixel index at the given <i>position</i>.</p> <p>If <i>position</i> is not valid, or if the image is not a paletted image (<a href="qimage#depth">depth</a>() &gt; 8), the results are undefined.</p> <p><b>See also </b><a href="qimage#valid">valid</a>(), <a href="qimage#depth">depth</a>(), and <a href="qimage#pixel-manipulation">Pixel Manipulation</a>.</p>   <h3 class="fn" id="pixelIndex-1">
<span class="type">int</span> QImage::<span class="name">pixelIndex</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns the pixel index at (<i>x</i>, <i>y</i>).</p>   <h3 class="fn" id="rect">
<span class="type"><a href="qrect">QRect</a></span> QImage::<span class="name">rect</span>() const
</h3> <p>Returns the enclosing rectangle (0, 0, <a href="qimage#width">width</a>(), <a href="qimage#height">height</a>()) of the image.</p> <p><b>See also </b><a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="reinterpretAsFormat">
<span class="type">bool</span> QImage::<span class="name">reinterpretAsFormat</span>(<span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> <i>format</i>)
</h3> <p>Changes the format of the image to <i>format</i> without changing the data. Only works between formats of the same depth.</p> <p>Returns <code>true</code> if successful.</p> <p>This function can be used to change images with alpha-channels to their corresponding opaque formats if the data is known to be opaque-only, or to change the format of a given image buffer before overwriting it with new data.</p> <p><b>Warning:</b> The function does not check if the image data is valid in the new format and will still return <code>true</code> if the depths are compatible. Operations on an image with invalid data are undefined.</p> <p><b>Warning:</b> If the image is not detached, this will cause the data to be copied.</p> <p>This function was introduced in Qt 5.9.</p> <p><b>See also </b><a href="qimage#hasAlphaChannel">hasAlphaChannel</a>() and <a href="qimage#convertToFormat">convertToFormat</a>().</p>   <h3 class="fn" id="save">
<span class="type">bool</span> QImage::<span class="name">save</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>fileName</i>, const <span class="type">char</span> *<i>format</i> = nullptr, <span class="type">int</span> <i>quality</i> = -1) const
</h3> <p>Saves the image to the file with the given <i>fileName</i>, using the given image file <i>format</i> and <i>quality</i> factor. If <i>format</i> is <code>nullptr</code>, <a href="qimage">QImage</a> will attempt to guess the format by looking at <i>fileName</i>'s suffix.</p> <p>The <i>quality</i> factor must be in the range 0 to 100 or -1. Specify 0 to obtain small compressed files, 100 for large uncompressed files, and -1 (the default) to use the default settings.</p> <p>Returns <code>true</code> if the image was successfully saved; otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qimage#reading-and-writing-image-files">Reading and Writing Image Files</a>.</p>   <h3 class="fn" id="save-1">
<span class="type">bool</span> QImage::<span class="name">save</span>(<span class="type"><a href="qiodevice">QIODevice</a></span> *<i>device</i>, const <span class="type">char</span> *<i>format</i> = nullptr, <span class="type">int</span> <i>quality</i> = -1) const
</h3> <p>This is an overloaded function.</p> <p>This function writes a <a href="qimage">QImage</a> to the given <i>device</i>.</p> <p>This can, for example, be used to save an image directly into a <a href="qbytearray">QByteArray</a>:</p> <pre data-language="cpp">        QImage image;
        QByteArray ba;
        QBuffer buffer(&amp;ba);
        buffer.open(QIODevice::WriteOnly);
        image.save(&amp;buffer, "PNG"); // writes image into ba in PNG format</pre>   <h3 class="fn" id="scaled">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">scaled</span>(const <span class="type"><a href="qsize">QSize</a></span> &amp;<i>size</i>, <span class="type"><a href="qt#AspectRatioMode-enum">Qt::AspectRatioMode</a></span> <i>aspectRatioMode</i> = Qt::IgnoreAspectRatio, <span class="type"><a href="qt#TransformationMode-enum">Qt::TransformationMode</a></span> <i>transformMode</i> = Qt::FastTransformation) const
</h3> <p>Returns a copy of the image scaled to a rectangle defined by the given <i>size</i> according to the given <i>aspectRatioMode</i> and <i>transformMode</i>.</p> <p class="centerAlign"><img alt="" src="data:image/png;base64,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"></p>
<ul> <li>If <i>aspectRatioMode</i> is <a href="qt#AspectRatioMode-enum">Qt::IgnoreAspectRatio</a>, the image is scaled to <i>size</i>.</li> <li>If <i>aspectRatioMode</i> is <a href="qt#AspectRatioMode-enum">Qt::KeepAspectRatio</a>, the image is scaled to a rectangle as large as possible inside <i>size</i>, preserving the aspect ratio.</li> <li>If <i>aspectRatioMode</i> is <a href="qt#AspectRatioMode-enum">Qt::KeepAspectRatioByExpanding</a>, the image is scaled to a rectangle as small as possible outside <i>size</i>, preserving the aspect ratio.</li> </ul> <p>If the given <i>size</i> is empty, this function returns a null image.</p> <p><b>See also </b><a href="qimage#isNull">isNull</a>() and <a href="qimage#image-transformations">Image Transformations</a>.</p>   <h3 class="fn" id="scaled-1">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">scaled</span>(<span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type"><a href="qt#AspectRatioMode-enum">Qt::AspectRatioMode</a></span> <i>aspectRatioMode</i> = Qt::IgnoreAspectRatio, <span class="type"><a href="qt#TransformationMode-enum">Qt::TransformationMode</a></span> <i>transformMode</i> = Qt::FastTransformation) const
</h3> <p>This is an overloaded function.</p> <p>Returns a copy of the image scaled to a rectangle with the given <i>width</i> and <i>height</i> according to the given <i>aspectRatioMode</i> and <i>transformMode</i>.</p> <p>If either the <i>width</i> or the <i>height</i> is zero or negative, this function returns a null image.</p>   <h3 class="fn" id="scaledToHeight">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">scaledToHeight</span>(<span class="type">int</span> <i>height</i>, <span class="type"><a href="qt#TransformationMode-enum">Qt::TransformationMode</a></span> <i>mode</i> = Qt::FastTransformation) const
</h3> <p>Returns a scaled copy of the image. The returned image is scaled to the given <i>height</i> using the specified transformation <i>mode</i>.</p> <p>This function automatically calculates the width of the image so that the ratio of the image is preserved.</p> <p>If the given <i>height</i> is 0 or negative, a null image is returned.</p> <p><b>See also </b><a href="qimage#image-transformations">Image Transformations</a>.</p>   <h3 class="fn" id="scaledToWidth">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">scaledToWidth</span>(<span class="type">int</span> <i>width</i>, <span class="type"><a href="qt#TransformationMode-enum">Qt::TransformationMode</a></span> <i>mode</i> = Qt::FastTransformation) const
</h3> <p>Returns a scaled copy of the image. The returned image is scaled to the given <i>width</i> using the specified transformation <i>mode</i>.</p> <p>This function automatically calculates the height of the image so that its aspect ratio is preserved.</p> <p>If the given <i>width</i> is 0 or negative, a null image is returned.</p> <p><b>See also </b><a href="qimage#image-transformations">Image Transformations</a>.</p>   <h3 class="fn" id="scanLine">
<span class="type"><a href="qtglobal#uchar-typedef">uchar</a></span> *QImage::<span class="name">scanLine</span>(<span class="type">int</span> <i>i</i>)
</h3> <p>Returns a pointer to the pixel data at the scanline with index <i>i</i>. The first scanline is at index 0.</p> <p>The scanline data is as minimum 32-bit aligned. For 64-bit formats it follows the native alignment of 64-bit integers (64-bit for most platforms, but notably 32-bit on i386).</p> <p><b>Warning:</b> If you are accessing 32-bpp image data, cast the returned pointer to <code>QRgb*</code> (<a href="qcolor#QRgb-typedef">QRgb</a> has a 32-bit size) and use it to read/write the pixel value. You cannot use the <code>uchar*</code> pointer directly, because the pixel format depends on the byte order on the underlying platform. Use <a href="qcolor#qRed">qRed</a>(), <a href="qcolor#qGreen">qGreen</a>(), <a href="qcolor#qBlue">qBlue</a>(), and <a href="qcolor#qAlpha">qAlpha</a>() to access the pixels.</p> <p><b>See also </b><a href="qimage#bytesPerLine">bytesPerLine</a>(), <a href="qimage#bits">bits</a>(), <a href="qimage#pixel-manipulation">Pixel Manipulation</a>, and <a href="qimage#constScanLine">constScanLine</a>().</p>   <h3 class="fn" id="scanLine-1">
const <span class="type"><a href="qtglobal#uchar-typedef">uchar</a></span> *QImage::<span class="name">scanLine</span>(<span class="type">int</span> <i>i</i>) const
</h3> <p>This is an overloaded function.</p>   <h3 class="fn" id="setAlphaChannel">
<span class="type">void</span> QImage::<span class="name">setAlphaChannel</span>(const <span class="type"><a href="qimage#QImage">QImage</a></span> &amp;<i>alphaChannel</i>)
</h3> <p>Sets the alpha channel of this image to the given <i>alphaChannel</i>.</p> <p>If <i>alphaChannel</i> is an 8 bit alpha image, the alpha values are used directly. Otherwise, <i>alphaChannel</i> is converted to 8 bit grayscale and the intensity of the pixel values is used.</p> <p>If the image already has an alpha channel, the existing alpha channel is multiplied with the new one. If the image doesn't have an alpha channel it will be converted to a format that does.</p> <p>The operation is similar to painting <i>alphaChannel</i> as an alpha image over this image using <code>QPainter::CompositionMode_DestinationIn</code>.</p> <p><b>See also </b><a href="qimage#hasAlphaChannel">hasAlphaChannel</a>(), <a href="https://doc.qt.io/qt-5.15/qimage-obsolete.html#alphaChannel">alphaChannel</a>(), <a href="qimage#image-transformations">Image Transformations</a>, and <a href="qimage#image-formats">Image Formats</a>.</p>   <h3 class="fn" id="setColor">
<span class="type">void</span> QImage::<span class="name">setColor</span>(<span class="type">int</span> <i>index</i>, <span class="type"><a href="qcolor#QRgb-typedef">QRgb</a></span> <i>colorValue</i>)
</h3> <p>Sets the color at the given <i>index</i> in the color table, to the given to <i>colorValue</i>. The color value is an ARGB quadruplet.</p> <p>If <i>index</i> is outside the current size of the color table, it is expanded with <a href="qimage#setColorCount">setColorCount</a>().</p> <p><b>See also </b><a href="qimage#color">color</a>(), <a href="qimage#colorCount">colorCount</a>(), <a href="qimage#setColorTable">setColorTable</a>(), and <a href="qimage#pixel-manipulation">Pixel Manipulation</a>.</p>   <h3 class="fn" id="setColorCount">
<span class="type">void</span> QImage::<span class="name">setColorCount</span>(<span class="type">int</span> <i>colorCount</i>)
</h3> <p>Resizes the color table to contain <i>colorCount</i> entries.</p> <p>If the color table is expanded, all the extra colors will be set to transparent (i.e <a href="qcolor#qRgba">qRgba</a>(0, 0, 0, 0)).</p> <p>When the image is used, the color table must be large enough to have entries for all the pixel/index values present in the image, otherwise the results are undefined.</p> <p>This function was introduced in Qt 4.6.</p> <p><b>See also </b><a href="qimage#colorCount">colorCount</a>(), <a href="qimage#colorTable">colorTable</a>(), <a href="qimage#setColor">setColor</a>(), and <a href="qimage#image-transformations">Image Transformations</a>.</p>   <h3 class="fn" id="setColorSpace">
<span class="type">void</span> QImage::<span class="name">setColorSpace</span>(const <span class="type"><a href="qcolorspace">QColorSpace</a></span> &amp;<i>colorSpace</i>)
</h3> <p>Sets the image color space to <i>colorSpace</i> without performing any conversions on image data.</p> <p>This function was introduced in Qt 5.14.</p> <p><b>See also </b><a href="qimage#colorSpace">colorSpace</a>().</p>   <h3 class="fn" id="setColorTable">
<span class="type">void</span> QImage::<span class="name">setColorTable</span>(const <span class="type"><a href="qvector">QVector</a></span>&lt;<span class="type"><a href="qcolor#QRgb-typedef">QRgb</a></span>&gt; <i>colors</i>)
</h3> <p>Sets the color table used to translate color indexes to <a href="qcolor#QRgb-typedef">QRgb</a> values, to the specified <i>colors</i>.</p> <p>When the image is used, the color table must be large enough to have entries for all the pixel/index values present in the image, otherwise the results are undefined.</p> <p><b>See also </b><a href="qimage#colorTable">colorTable</a>(), <a href="qimage#setColor">setColor</a>(), and <a href="qimage#image-transformations">Image Transformations</a>.</p>   <h3 class="fn" id="setDevicePixelRatio">
<span class="type">void</span> QImage::<span class="name">setDevicePixelRatio</span>(<span class="type"><a href="qtglobal#qreal-typedef">qreal</a></span> <i>scaleFactor</i>)
</h3> <p>Sets the device pixel ratio for the image. This is the ratio between image pixels and device-independent pixels.</p> <p>The default <i>scaleFactor</i> is 1.0. Setting it to something else has two effects:</p> <p>QPainters that are opened on the image will be scaled. For example, painting on a 200x200 image if with a ratio of 2.0 will result in effective (device-independent) painting bounds of 100x100.</p> <p>Code paths in Qt that calculate layout geometry based on the image size will take the ratio into account: <a href="qsize">QSize</a> layoutSize = image.<a href="qimage#size">size</a>() / image.<a href="qimage#devicePixelRatio">devicePixelRatio</a>() The net effect of this is that the image is displayed as high-DPI image rather than a large image (see <a href="qpainter#drawing-high-resolution-versions-of-pixmaps-and-images">Drawing High Resolution Versions of Pixmaps and Images</a>).</p> <p><b>See also </b><a href="qimage#devicePixelRatio">devicePixelRatio</a>().</p>   <h3 class="fn" id="setDotsPerMeterX">
<span class="type">void</span> QImage::<span class="name">setDotsPerMeterX</span>(<span class="type">int</span> <i>x</i>)
</h3> <p>Sets the number of pixels that fit horizontally in a physical meter, to <i>x</i>.</p> <p>Together with <a href="qimage#dotsPerMeterY">dotsPerMeterY</a>(), this number defines the intended scale and aspect ratio of the image, and determines the scale at which <a href="qpainter">QPainter</a> will draw graphics on the image. It does not change the scale or aspect ratio of the image when it is rendered on other paint devices.</p> <p><b>See also </b><a href="qimage#dotsPerMeterX">dotsPerMeterX</a>() and <a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="setDotsPerMeterY">
<span class="type">void</span> QImage::<span class="name">setDotsPerMeterY</span>(<span class="type">int</span> <i>y</i>)
</h3> <p>Sets the number of pixels that fit vertically in a physical meter, to <i>y</i>.</p> <p>Together with <a href="qimage#dotsPerMeterX">dotsPerMeterX</a>(), this number defines the intended scale and aspect ratio of the image, and determines the scale at which <a href="qpainter">QPainter</a> will draw graphics on the image. It does not change the scale or aspect ratio of the image when it is rendered on other paint devices.</p> <p><b>See also </b><a href="qimage#dotsPerMeterY">dotsPerMeterY</a>() and <a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="setOffset">
<span class="type">void</span> QImage::<span class="name">setOffset</span>(const <span class="type"><a href="qpoint">QPoint</a></span> &amp;<i>offset</i>)
</h3> <p>Sets the number of pixels by which the image is intended to be offset by when positioning relative to other images, to <i>offset</i>.</p> <p><b>See also </b><a href="qimage#offset">offset</a>() and <a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="setPixel">
<span class="type">void</span> QImage::<span class="name">setPixel</span>(const <span class="type"><a href="qpoint">QPoint</a></span> &amp;<i>position</i>, <span class="type"><a href="qtglobal#uint-typedef">uint</a></span> <i>index_or_rgb</i>)
</h3> <p>Sets the pixel index or color at the given <i>position</i> to <i>index_or_rgb</i>.</p> <p>If the image's format is either monochrome or paletted, the given <i>index_or_rgb</i> value must be an index in the image's color table, otherwise the parameter must be a <a href="qcolor#QRgb-typedef">QRgb</a> value.</p> <p>If <i>position</i> is not a valid coordinate pair in the image, or if <i>index_or_rgb</i> &gt;= <a href="qimage#colorCount">colorCount</a>() in the case of monochrome and paletted images, the result is undefined.</p> <p><b>Warning:</b> This function is expensive due to the call of the internal <code>detach()</code> function called within; if performance is a concern, we recommend the use of <a href="qimage#scanLine">scanLine</a>() or <a href="qimage#bits">bits</a>() to access pixel data directly.</p> <p><b>See also </b><a href="qimage#pixel">pixel</a>() and <a href="qimage#pixel-manipulation">Pixel Manipulation</a>.</p>   <h3 class="fn" id="setPixel-1">
<span class="type">void</span> QImage::<span class="name">setPixel</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>, <span class="type"><a href="qtglobal#uint-typedef">uint</a></span> <i>index_or_rgb</i>)
</h3> <p>This is an overloaded function.</p> <p>Sets the pixel index or color at (<i>x</i>, <i>y</i>) to <i>index_or_rgb</i>.</p>   <h3 class="fn" id="setPixelColor">
<span class="type">void</span> QImage::<span class="name">setPixelColor</span>(const <span class="type"><a href="qpoint">QPoint</a></span> &amp;<i>position</i>, const <span class="type"><a href="qcolor">QColor</a></span> &amp;<i>color</i>)
</h3> <p>Sets the color at the given <i>position</i> to <i>color</i>.</p> <p>If <i>position</i> is not a valid coordinate pair in the image, or the image's format is either monochrome or paletted, the result is undefined.</p> <p><b>Warning:</b> This function is expensive due to the call of the internal <code>detach()</code> function called within; if performance is a concern, we recommend the use of <a href="qimage#scanLine">scanLine</a>() or <a href="qimage#bits">bits</a>() to access pixel data directly.</p> <p>This function was introduced in Qt 5.6.</p> <p><b>See also </b><a href="qimage#pixelColor">pixelColor</a>(), <a href="qimage#pixel">pixel</a>(), <a href="qimage#bits">bits</a>(), <a href="qimage#scanLine">scanLine</a>(), and <a href="qimage#pixel-manipulation">Pixel Manipulation</a>.</p>   <h3 class="fn" id="setPixelColor-1">
<span class="type">void</span> QImage::<span class="name">setPixelColor</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>, const <span class="type"><a href="qcolor">QColor</a></span> &amp;<i>color</i>)
</h3> <p>This is an overloaded function.</p> <p>Sets the pixel color at (<i>x</i>, <i>y</i>) to <i>color</i>.</p> <p>This function was introduced in Qt 5.6.</p>   <h3 class="fn" id="setText">
<span class="type">void</span> QImage::<span class="name">setText</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>key</i>, const <span class="type"><a href="qstring">QString</a></span> &amp;<i>text</i>)
</h3> <p>Sets the image text to the given <i>text</i> and associate it with the given <i>key</i>.</p> <p>If you just want to store a single text block (i.e., a "comment" or just a description), you can either pass an empty key, or use a generic key like "Description".</p> <p>The image text is embedded into the image data when you call <a href="qimage#save">save</a>() or <a href="qimagewriter#write">QImageWriter::write</a>().</p> <p>Not all image formats support embedded text. You can find out if a specific image or format supports embedding text by using <a href="qimagewriter#supportsOption">QImageWriter::supportsOption</a>(). We give an example:</p> <pre data-language="cpp">    QImageWriter writer;
    writer.setFormat("png");
    if (writer.supportsOption(QImageIOHandler::Description))
        qDebug() &lt;&lt; "Png supports embedded text";</pre> <p>You can use <a href="qimagewriter#supportedImageFormats">QImageWriter::supportedImageFormats</a>() to find out which image formats are available to you.</p> <p><b>See also </b><a href="qimage#text">text</a>() and <a href="qimage#textKeys">textKeys</a>().</p>   <h3 class="fn" id="size">
<span class="type"><a href="qsize">QSize</a></span> QImage::<span class="name">size</span>() const
</h3> <p>Returns the size of the image, i.e. its <a href="qimage#width">width</a>() and <a href="qimage#height">height</a>().</p> <p><b>See also </b><a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="sizeInBytes">
<span class="type">qsizetype</span> QImage::<span class="name">sizeInBytes</span>() const
</h3> <p>Returns the image data size in bytes.</p> <p>This function was introduced in Qt 5.10.</p> <p><b>See also </b><a href="https://doc.qt.io/qt-5.15/qimage-obsolete.html#byteCount">byteCount</a>(), <a href="qimage#bytesPerLine">bytesPerLine</a>(), <a href="qimage#bits">bits</a>(), and <a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="smoothScaled">
<code>[protected] </code><span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">smoothScaled</span>(<span class="type">int</span> <i>w</i>, <span class="type">int</span> <i>h</i>) const
</h3> <p>Returns a smoothly scaled copy of the image. The returned image has a size of width <i>w</i> by height <i>h</i> pixels.</p>   <h3 class="fn" id="swap">
<span class="type">void</span> QImage::<span class="name">swap</span>(<span class="type"><a href="qimage#QImage">QImage</a></span> &amp;<i>other</i>)
</h3> <p>Swaps image <i>other</i> with this image. This operation is very fast and never fails.</p> <p>This function was introduced in Qt 4.8.</p>   <h3 class="fn" id="text">
<span class="type"><a href="qstring">QString</a></span> QImage::<span class="name">text</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>key</i> = QString()) const
</h3> <p>Returns the image text associated with the given <i>key</i>. If the specified <i>key</i> is an empty string, the whole image text is returned, with each key-text pair separated by a newline.</p> <p><b>See also </b><a href="qimage#setText">setText</a>() and <a href="qimage#textKeys">textKeys</a>().</p>   <h3 class="fn" id="textKeys">
<span class="type"><a href="qstringlist">QStringList</a></span> QImage::<span class="name">textKeys</span>() const
</h3> <p>Returns the text keys for this image.</p> <p>You can use these keys with <a href="qimage#text">text</a>() to list the image text for a certain key.</p> <p><b>See also </b><a href="qimage#text">text</a>().</p>   <h3 class="fn" id="toCGImage">
<span class="type">CGImageRef</span> QImage::<span class="name">toCGImage</span>() const
</h3> <p>Creates a <code>CGImage</code> equivalent to this <a href="qimage">QImage</a>. Returns a <code>CGImageRef</code> handle.</p> <p>The returned CGImageRef partakes in the <a href="qimage">QImage</a> implicit sharing, and holds a reference to the <a href="qimage">QImage</a> data. CGImage is immutable and will never detach the <a href="qimage">QImage</a>. Writing to the <a href="qimage">QImage</a> will detach as usual.</p> <p>This function is fast, and does not copy or convert image data.</p> <p>The following image formats are supported, and will be mapped to a corresponding native image type:</p> <table class="generic"> <thead><tr class="qt-style">
<th>Qt</th>
<th>CoreGraphics</th>
</tr></thead> <tr class="odd" valign="top">
<td><a href="qimage#Format-enum">Format_ARGB32</a></td>
<td>kCGImageAlphaFirst | kCGBitmapByteOrder32Host</td>
</tr> <tr class="even" valign="top">
<td><a href="qimage#Format-enum">Format_RGB32</a></td>
<td>kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host</td>
</tr> <tr class="odd" valign="top">
<td><a href="qimage#Format-enum">Format_RGBA8888_Premultiplied</a></td>
<td>kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big</td>
</tr> <tr class="even" valign="top">
<td><a href="qimage#Format-enum">Format_RGBA8888</a></td>
<td>kCGImageAlphaLast | kCGBitmapByteOrder32Big</td>
</tr> <tr class="odd" valign="top">
<td><a href="qimage#Format-enum">Format_RGBX8888</a></td>
<td>kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big</td>
</tr> <tr class="even" valign="top">
<td><a href="qimage#Format-enum">Format_ARGB32_Premultiplied</a></td>
<td>kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host</td>
</tr> </table> <p>Other formats are not supported; this function returns a null CGImageRef for those cases. Users of this function may then convert the <a href="qimage">QImage</a> to a supported formate first, for example <a href="qimage#Format-enum">Format_ARGB32_Premultiplied</a>.</p> <p>The CGImageRef color space is set to the sRGB color space.</p> <p><b>See also </b><a href="qtmac#toNSImage">QtMac::toNSImage</a>().</p>   <h3 class="fn" id="toImageFormat">
<code>[static] </code><span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> QImage::<span class="name">toImageFormat</span>(<span class="type"><a href="qpixelformat">QPixelFormat</a></span> <i>format</i>)
</h3> <p>Converts <i>format</i> into a <a href="qimage#Format-enum">QImage::Format</a></p>   <h3 class="fn" id="toPixelFormat">
<code>[static] </code><span class="type"><a href="qpixelformat">QPixelFormat</a></span> QImage::<span class="name">toPixelFormat</span>(<span class="type"><a href="qimage#Format-enum">QImage::Format</a></span> <i>format</i>)
</h3> <p>Converts <i>format</i> into a <a href="qpixelformat">QPixelFormat</a></p>   <h3 class="fn" id="transformed-1">
<span class="type"><a href="qimage#QImage">QImage</a></span> QImage::<span class="name">transformed</span>(const <span class="type"><a href="qtransform">QTransform</a></span> &amp;<i>matrix</i>, <span class="type"><a href="qt#TransformationMode-enum">Qt::TransformationMode</a></span> <i>mode</i> = Qt::FastTransformation) const
</h3> <p>Returns a copy of the image that is transformed using the given transformation <i>matrix</i> and transformation <i>mode</i>.</p> <p>The returned image will normally have the same {Image Formats}{format} as the original image. However, a complex transformation may result in an image where not all pixels are covered by the transformed pixels of the original image. In such cases, those background pixels will be assigned a transparent color value, and the transformed image will be given a format with an alpha channel, even if the orginal image did not have that.</p> <p>The transformation <i>matrix</i> is internally adjusted to compensate for unwanted translation; i.e. the image produced is the smallest image that contains all the transformed points of the original image. Use the trueMatrix() function to retrieve the actual matrix used for transforming an image.</p> <p>Unlike the other overload, this function can be used to perform perspective transformations on images.</p> <p><b>See also </b><a href="https://doc.qt.io/qt-5.15/qimage-obsolete.html#trueMatrix">trueMatrix</a>() and <a href="qimage#image-transformations">Image Transformations</a>.</p>   <h3 class="fn" id="trueMatrix-1">
<code>[static] </code><span class="type"><a href="qtransform">QTransform</a></span> QImage::<span class="name">trueMatrix</span>(const <span class="type"><a href="qtransform">QTransform</a></span> &amp;<i>matrix</i>, <span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>)
</h3> <p>Returns the actual matrix used for transforming an image with the given <i>width</i>, <i>height</i> and <i>matrix</i>.</p> <p>When transforming an image using the transformed() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. transformed() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.</p> <p>Unlike the other overload, this function creates transformation matrices that can be used to perform perspective transformations on images.</p> <p><b>See also </b><a href="https://doc.qt.io/qt-5.15/qimage-obsolete.html#transformed">transformed</a>() and <a href="qimage#image-transformations">Image Transformations</a>.</p>   <h3 class="fn" id="valid">
<span class="type">bool</span> QImage::<span class="name">valid</span>(const <span class="type"><a href="qpoint">QPoint</a></span> &amp;<i>pos</i>) const
</h3> <p>Returns <code>true</code> if <i>pos</i> is a valid coordinate pair within the image; otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qimage#rect">rect</a>() and <a href="qrect#contains">QRect::contains</a>().</p>   <h3 class="fn" id="valid-1">
<span class="type">bool</span> QImage::<span class="name">valid</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns <code>true</code> if <a href="qpoint">QPoint</a>(<i>x</i>, <i>y</i>) is a valid coordinate pair within the image; otherwise returns <code>false</code>.</p>   <h3 class="fn" id="width">
<span class="type">int</span> QImage::<span class="name">width</span>() const
</h3> <p>Returns the width of the image.</p> <p><b>See also </b><a href="qimage#image-information">Image Information</a>.</p>   <h3 class="fn" id="operator-QVariant">
<span class="type"><a href="qvariant">QVariant</a></span> QImage::<span class="name">operator QVariant</span>() const
</h3> <p>Returns the image as a <a href="qvariant">QVariant</a>.</p>   <h3 class="fn" id="operator-not-eq">
<span class="type">bool</span> QImage::<span class="name">operator!=</span>(const <span class="type"><a href="qimage#QImage">QImage</a></span> &amp;<i>image</i>) const
</h3> <p>Returns <code>true</code> if this image and the given <i>image</i> have different contents; otherwise returns <code>false</code>.</p> <p>The comparison can be slow, unless there is some obvious difference, such as different widths, in which case the function will return quickly.</p> <p><b>See also </b><a href="qimage#operator-eq">operator=</a>().</p>   <h3 class="fn" id="operator-eq-eq">
<span class="type">bool</span> QImage::<span class="name">operator==</span>(const <span class="type"><a href="qimage#QImage">QImage</a></span> &amp;<i>image</i>) const
</h3> <p>Returns <code>true</code> if this image and the given <i>image</i> have the same contents; otherwise returns <code>false</code>.</p> <p>The comparison can be slow, unless there is some obvious difference (e.g. different size or format), in which case the function will return quickly.</p> <p><b>See also </b><a href="qimage#operator-eq">operator=</a>().</p>   <div class="relnonmem"> <h2>Related Non-Members</h2>  <h3 class="fn" id="QImageCleanupFunction-typedef">
typedef <span class="name">QImageCleanupFunction</span>
</h3> <p>A function with the following signature that can be used to implement basic image memory management:</p> <pre data-language="cpp">void myImageCleanupHandler(void *info);</pre> <p>This typedef was introduced in Qt 5.0.</p>   <h3 class="fn" id="operator-lt-lt-21">
<span class="type"><a href="qdatastream">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="qdatastream">QDataStream</a></span> &amp;<i>stream</i>, const <span class="type"><a href="qimage#QImage">QImage</a></span> &amp;<i>image</i>)
</h3> <p>Writes the given <i>image</i> to the given <i>stream</i> as a PNG image, or as a BMP image if the stream's version is 1. Note that writing the stream to a file will not produce a valid image file.</p> <p><b>See also </b><a href="qimage#save">QImage::save</a>() and <a href="datastreamformat">Serializing Qt Data Types</a>.</p>   <h3 class="fn" id="operator-gt-gt">
<span class="type"><a href="qdatastream">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="qdatastream">QDataStream</a></span> &amp;<i>stream</i>, <span class="type"><a href="qimage#QImage">QImage</a></span> &amp;<i>image</i>)
</h3> <p>Reads an image from the given <i>stream</i> and stores it in the given <i>image</i>.</p> <p><b>See also </b><a href="qimage#load">QImage::load</a>() and <a href="datastreamformat">Serializing Qt Data Types</a>.</p>  </div>
<div class="_attribution">
  <p class="_attribution-p">
    Â© The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-5.15/qimage.html" class="_attribution-link">https://doc.qt.io/qt-5.15/qimage.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
