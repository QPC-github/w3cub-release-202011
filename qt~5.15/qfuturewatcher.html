
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>QFutureWatcher (Class) - Qt 5.15 - W3cubDocs</title>
  
  <meta name="description" content=" The QFutureWatcher class allows monitoring a QFuture using signals and slots. More... ">
  <meta name="keywords" content="qfuturewatcher, class, qt, qt~5.15">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/qt~5.15/qfuturewatcher.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/qt~5.15.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt~5.15/" class="_nav-link" title="" style="margin-left:0;">Qt 5.15</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">QFutureWatcher Class</h1> <span class="small-subtitle">template &lt;typename T&gt; class QFutureWatcher</span>  <p>The QFutureWatcher class allows monitoring a <a href="qfuture">QFuture</a> using signals and slots. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QFutureWatcher&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 4.4</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> <a href="qobject">QObject</a>
</td>
</tr>
</table>
<p>This class was introduced in Qt 4.4.</p> <ul> <li><a href="https://doc.qt.io/qt-5.15/qfuturewatcher-members.html">List of all members, including inherited members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="threads-reentrancy">reentrant</a>.</p>  <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#QFutureWatcher">QFutureWatcher</a></b>(QObject *<i>parent</i> = nullptr)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#dtor.QFutureWatcher">~QFutureWatcher</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#future">future</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#isCanceled">isCanceled</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#isFinished">isFinished</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#isPaused">isPaused</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#isRunning">isRunning</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#isStarted">isStarted</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#progressMaximum">progressMaximum</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#progressMinimum">progressMinimum</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QString </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#progressText">progressText</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#progressValue">progressValue</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#result">result</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> T </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#resultAt">resultAt</a></b>(int <i>index</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#setFuture">setFuture</a></b>(const QFuture&lt;T&gt; &amp;<i>future</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#setPendingResultsLimit">setPendingResultsLimit</a></b>(int <i>limit</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#waitForFinished">waitForFinished</a></b>()</td>
</tr> </table>  <h2 id="public-slots">Public Slots
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#cancel">cancel</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#pause">pause</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#resume">resume</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#setPaused">setPaused</a></b>(bool <i>paused</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#togglePaused">togglePaused</a></b>()</td>
</tr> </table>  <h2 id="signals">Signals
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#canceled">canceled</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#finished">finished</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#paused">paused</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#progressRangeChanged">progressRangeChanged</a></b>(int <i>minimum</i>, int <i>maximum</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#progressTextChanged">progressTextChanged</a></b>(const QString &amp;<i>progressText</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#progressValueChanged">progressValueChanged</a></b>(int <i>progressValue</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#resultReadyAt">resultReadyAt</a></b>(int <i>index</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#resultsReadyAt">resultsReadyAt</a></b>(int <i>beginIndex</i>, int <i>endIndex</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#resumed">resumed</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qfuturewatcher#started">started</a></b>()</td>
</tr> </table>    <h2 id="details">Detailed Description
</h2> <p>QFutureWatcher provides information and notifications about a <a href="qfuture">QFuture</a>. Use the <a href="qfuturewatcher#setFuture">setFuture</a>() function to start watching a particular <a href="qfuture">QFuture</a>. The <a href="qfuturewatcher#future">future</a>() function returns the future set with <a href="qfuturewatcher#setFuture">setFuture</a>().</p> <p>For convenience, several of <a href="qfuture">QFuture</a>'s functions are also available in QFutureWatcher: <a href="qfuturewatcher#progressValue">progressValue</a>(), <a href="qfuturewatcher#progressMinimum">progressMinimum</a>(), <a href="qfuturewatcher#progressMaximum">progressMaximum</a>(), <a href="qfuturewatcher#progressText">progressText</a>(), <a href="qfuturewatcher#isStarted">isStarted</a>(), <a href="qfuturewatcher#isFinished">isFinished</a>(), <a href="qfuturewatcher#isRunning">isRunning</a>(), <a href="qfuturewatcher#isCanceled">isCanceled</a>(), <a href="qfuturewatcher#isPaused">isPaused</a>(), <a href="qfuturewatcher#waitForFinished">waitForFinished</a>(), <a href="qfuturewatcher#result">result</a>(), and <a href="qfuturewatcher#resultAt">resultAt</a>(). The <a href="qfuturewatcher#cancel">cancel</a>(), <a href="qfuturewatcher#setPaused">setPaused</a>(), <a href="qfuturewatcher#pause">pause</a>(), <a href="qfuturewatcher#resume">resume</a>(), and <a href="qfuturewatcher#togglePaused">togglePaused</a>() functions are slots in QFutureWatcher.</p> <p>Status changes are reported via the <a href="qfuturewatcher#started">started</a>(), <a href="qfuturewatcher#finished">finished</a>(), <a href="qfuturewatcher#canceled">canceled</a>(), <a href="qfuturewatcher#paused">paused</a>(), <a href="qfuturewatcher#resumed">resumed</a>(), <a href="qfuturewatcher#resultReadyAt">resultReadyAt</a>(), and <a href="qfuturewatcher#resultsReadyAt">resultsReadyAt</a>() signals. Progress information is provided from the <a href="qfuturewatcher#progressRangeChanged">progressRangeChanged</a>(), void <a href="qfuturewatcher#progressValueChanged">progressValueChanged</a>(), and <a href="qfuturewatcher#progressTextChanged">progressTextChanged</a>() signals.</p> <p>Throttling control is provided by the <a href="qfuturewatcher#setPendingResultsLimit">setPendingResultsLimit</a>() function. When the number of pending <a href="qfuturewatcher#resultReadyAt">resultReadyAt</a>() or <a href="qfuturewatcher#resultsReadyAt">resultsReadyAt</a>() signals exceeds the limit, the computation represented by the future will be throttled automatically. The computation will resume once the number of pending signals drops below the limit.</p> <p>Example: Starting a computation and getting a slot callback when it's finished:</p> <pre data-language="cpp">// Instantiate the objects and connect to the finished signal.
MyClass myObject;
QFutureWatcher&lt;int&gt; watcher;
connect(&amp;watcher, &amp;QFutureWatcher&lt;int&gt;::finished, &amp;myObject, &amp;MyClass::handleFinished);

// Start the computation.
QFuture&lt;int&gt; future = QtConcurrent::run(...);
watcher.setFuture(future);</pre> <p>Be aware that not all running asynchronous computations can be canceled or paused. For example, the future returned by <a href="qtconcurrent#run">QtConcurrent::run</a>() cannot be canceled; but the future returned by <a href="qtconcurrent#mappedReduced">QtConcurrent::mappedReduced</a>() can.</p> <p>QFutureWatcher&lt;void&gt; is specialized to not contain any of the result fetching functions. Any <a href="qfuture">QFuture</a>&lt;T&gt; can be watched by a QFutureWatcher&lt;void&gt; as well. This is useful if only status or progress information is needed; not the actual result data.</p>  <p><b>See also </b><a href="qfuture">QFuture</a> and <a href="qtconcurrent-index">Qt Concurrent</a>.</p>   <h2>Member Function Documentation</h2>  <h3 class="fn" id="QFutureWatcher">
QFutureWatcher::<span class="name">QFutureWatcher</span>(<span class="type"><a href="qobject#QObject">QObject</a></span> *<i>parent</i> = nullptr)
</h3> <p>Constructs a new QFutureWatcher with the given <i>parent</i>. Until a future is set with <a href="qfuturewatcher#setFuture">setFuture</a>(), the functions <a href="qfuturewatcher#isStarted">isStarted</a>(), <a href="qfuturewatcher#isCanceled">isCanceled</a>(), and <a href="qfuturewatcher#isFinished">isFinished</a>() return <code>true</code>.</p>   <h3 class="fn" id="cancel">
<code>[slot] </code><span class="type">void</span> QFutureWatcher::<span class="name">cancel</span>()
</h3> <p>Cancels the asynchronous computation represented by the <a href="qfuturewatcher#future">future</a>(). Note that the cancelation is asynchronous. Use <a href="qfuturewatcher#waitForFinished">waitForFinished</a>() after calling cancel() when you need synchronous cancelation.</p> <p>Currently available results may still be accessed on a canceled <a href="qfuture">QFuture</a>, but new results will <i>not</i> become available after calling this function. Also, this <a href="qfuturewatcher">QFutureWatcher</a> will not deliver progress and result ready signals once canceled. This includes the <a href="qfuturewatcher#progressValueChanged">progressValueChanged</a>(), <a href="qfuturewatcher#progressRangeChanged">progressRangeChanged</a>(), <a href="qfuturewatcher#progressTextChanged">progressTextChanged</a>(), <a href="qfuturewatcher#resultReadyAt">resultReadyAt</a>(), and <a href="qfuturewatcher#resultsReadyAt">resultsReadyAt</a>() signals.</p> <p>Be aware that not all running asynchronous computations can be canceled. For example, the <a href="qfuture">QFuture</a> returned by <a href="qtconcurrent#run">QtConcurrent::run</a>() cannot be canceled; but the <a href="qfuture">QFuture</a> returned by <a href="qtconcurrent#mappedReduced">QtConcurrent::mappedReduced</a>() can.</p>   <h3 class="fn" id="canceled">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">canceled</span>()
</h3> <p>This signal is emitted if the watched future is canceled.</p>   <h3 class="fn" id="finished">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">finished</span>()
</h3> <p>This signal is emitted when the watched future finishes.</p>   <h3 class="fn" id="pause">
<code>[slot] </code><span class="type">void</span> QFutureWatcher::<span class="name">pause</span>()
</h3> <p>Pauses the asynchronous computation represented by the <a href="qfuturewatcher#future">future</a>(). This is a convenience method that simply calls <a href="qfuturewatcher#setPaused">setPaused</a>(true).</p> <p><b>See also </b><a href="qfuturewatcher#resume">resume</a>().</p>   <h3 class="fn" id="paused">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">paused</span>()
</h3> <p>This signal is emitted when the watched future is paused.</p> <p><b>See also </b><a href="qfuturewatcher#setPaused">setPaused</a>().</p>   <h3 class="fn" id="progressRangeChanged">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">progressRangeChanged</span>(<span class="type">int</span> <i>minimum</i>, <span class="type">int</span> <i>maximum</i>)
</h3> <p>The progress range for the watched future has changed to <i>minimum</i> and <i>maximum</i></p>   <h3 class="fn" id="progressTextChanged">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">progressTextChanged</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>progressText</i>)
</h3> <p>This signal is emitted when the watched future reports textual progress information, <i>progressText</i>.</p>   <h3 class="fn" id="progressValueChanged">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">progressValueChanged</span>(<span class="type">int</span> <i>progressValue</i>)
</h3> <p>This signal is emitted when the watched future reports progress, <i>progressValue</i> gives the current progress. In order to avoid overloading the GUI event loop, <a href="qfuturewatcher">QFutureWatcher</a> limits the progress signal emission rate. This means that listeners connected to this slot might not get all progress reports the future makes. The last progress update (where <i>progressValue</i> equals the maximum value) will always be delivered.</p>   <h3 class="fn" id="resultReadyAt">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">resultReadyAt</span>(<span class="type">int</span> <i>index</i>)
</h3> <p>This signal is emitted when the watched future reports a ready result at <i>index</i>. If the future reports multiple results, the index will indicate which one it is. Results can be reported out-of-order. To get the result, call <a href="qfuturewatcher#resultAt">resultAt</a>(index);</p>   <h3 class="fn" id="resultsReadyAt">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">resultsReadyAt</span>(<span class="type">int</span> <i>beginIndex</i>, <span class="type">int</span> <i>endIndex</i>)
</h3> <p>This signal is emitted when the watched future reports ready results. The results are indexed from <i>beginIndex</i> to <i>endIndex</i>.</p>   <h3 class="fn" id="resume">
<code>[slot] </code><span class="type">void</span> QFutureWatcher::<span class="name">resume</span>()
</h3> <p>Resumes the asynchronous computation represented by the <a href="qfuturewatcher#future">future</a>(). This is a convenience method that simply calls <a href="qfuturewatcher#setPaused">setPaused</a>(false).</p> <p><b>See also </b><a href="qfuturewatcher#pause">pause</a>().</p>   <h3 class="fn" id="resumed">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">resumed</span>()
</h3> <p>This signal is emitted when the watched future is resumed.</p>   <h3 class="fn" id="setPaused">
<code>[slot] </code><span class="type">void</span> QFutureWatcher::<span class="name">setPaused</span>(<span class="type">bool</span> <i>paused</i>)
</h3> <p>If <i>paused</i> is true, this function pauses the asynchronous computation represented by the <a href="qfuturewatcher#future">future</a>(). If the computation is already paused, this function does nothing. This <a href="qfuturewatcher">QFutureWatcher</a> will stop delivering progress and result ready signals while the future is paused. Signal delivery will continue once the computation is resumed.</p> <p>If <i>paused</i> is false, this function resumes the asynchronous computation. If the computation was not previously paused, this function does nothing.</p> <p>Be aware that not all computations can be paused. For example, the <a href="qfuture">QFuture</a> returned by <a href="qtconcurrent#run">QtConcurrent::run</a>() cannot be paused; but the <a href="qfuture">QFuture</a> returned by <a href="qtconcurrent#mappedReduced">QtConcurrent::mappedReduced</a>() can.</p> <p><b>See also </b><a href="qfuturewatcher#paused">paused</a>(), <a href="qfuturewatcher#pause">pause</a>(), <a href="qfuturewatcher#resume">resume</a>(), and <a href="qfuturewatcher#togglePaused">togglePaused</a>().</p>   <h3 class="fn" id="started">
<code>[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">started</span>()
</h3> <p>This signal is emitted when this <a href="qfuturewatcher">QFutureWatcher</a> starts watching the future set with <a href="qfuturewatcher#setFuture">setFuture</a>().</p>   <h3 class="fn" id="togglePaused">
<code>[slot] </code><span class="type">void</span> QFutureWatcher::<span class="name">togglePaused</span>()
</h3> <p>Toggles the paused state of the asynchronous computation. In other words, if the computation is currently paused, calling this function resumes it; if the computation is running, it becomes paused. This is a convenience method for calling <a href="qfuturewatcher#setPaused">setPaused</a>(!<a href="qfuturewatcher#isPaused">isPaused</a>()).</p> <p><b>See also </b><a href="qfuturewatcher#setPaused">setPaused</a>(), <a href="qfuturewatcher#pause">pause</a>(), and <a href="qfuturewatcher#resume">resume</a>().</p>   <h3 class="fn" id="dtor.QFutureWatcher">
<code>[virtual] </code>QFutureWatcher::<span class="name">~QFutureWatcher</span>()
</h3> <p>Destroys the <a href="qfuturewatcher">QFutureWatcher</a>.</p>   <h3 class="fn" id="future">
<span class="type"><a href="qfuture">QFuture</a></span>&lt;<span class="type">T</span>&gt; QFutureWatcher::<span class="name">future</span>() const
</h3> <p>Returns the watched future.</p> <p><b>See also </b><a href="qfuturewatcher#setFuture">setFuture</a>().</p>   <h3 class="fn" id="isCanceled">
<span class="type">bool</span> QFutureWatcher::<span class="name">isCanceled</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation has been canceled with the <a href="qfuturewatcher#cancel">cancel</a>() function, or if no future has been set; otherwise returns <code>false</code>.</p> <p>Be aware that the computation may still be running even though this function returns <code>true</code>. See <a href="qfuturewatcher#cancel">cancel</a>() for more details.</p>   <h3 class="fn" id="isFinished">
<span class="type">bool</span> QFutureWatcher::<span class="name">isFinished</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation represented by the <a href="qfuturewatcher#future">future</a>() has finished, or if no future has been set; otherwise returns <code>false</code>.</p>   <h3 class="fn" id="isPaused">
<span class="type">bool</span> QFutureWatcher::<span class="name">isPaused</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation has been paused with the <a href="qfuturewatcher#pause">pause</a>() function; otherwise returns <code>false</code>.</p> <p>Be aware that the computation may still be running even though this function returns <code>true</code>. See <a href="qfuturewatcher#setPaused">setPaused</a>() for more details.</p> <p><b>See also </b><a href="qfuturewatcher#setPaused">setPaused</a>() and <a href="qfuturewatcher#togglePaused">togglePaused</a>().</p>   <h3 class="fn" id="isRunning">
<span class="type">bool</span> QFutureWatcher::<span class="name">isRunning</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation represented by the <a href="qfuturewatcher#future">future</a>() is currently running; otherwise returns <code>false</code>.</p>   <h3 class="fn" id="isStarted">
<span class="type">bool</span> QFutureWatcher::<span class="name">isStarted</span>() const
</h3> <p>Returns <code>true</code> if the asynchronous computation represented by the <a href="qfuturewatcher#future">future</a>() has been started, or if no future has been set; otherwise returns <code>false</code>.</p>   <h3 class="fn" id="progressMaximum">
<span class="type">int</span> QFutureWatcher::<span class="name">progressMaximum</span>() const
</h3> <p>Returns the maximum <a href="qfuturewatcher#progressValue">progressValue</a>().</p> <p><b>See also </b><a href="qfuturewatcher#progressValue">progressValue</a>() and <a href="qfuturewatcher#progressMinimum">progressMinimum</a>().</p>   <h3 class="fn" id="progressMinimum">
<span class="type">int</span> QFutureWatcher::<span class="name">progressMinimum</span>() const
</h3> <p>Returns the minimum <a href="qfuturewatcher#progressValue">progressValue</a>().</p> <p><b>See also </b><a href="qfuturewatcher#progressValue">progressValue</a>() and <a href="qfuturewatcher#progressMaximum">progressMaximum</a>().</p>   <h3 class="fn" id="progressText">
<span class="type"><a href="qstring">QString</a></span> QFutureWatcher::<span class="name">progressText</span>() const
</h3> <p>Returns the (optional) textual representation of the progress as reported by the asynchronous computation.</p> <p>Be aware that not all computations provide a textual representation of the progress, and as such, this function may return an empty string.</p>   <h3 class="fn" id="progressValue">
<span class="type">int</span> QFutureWatcher::<span class="name">progressValue</span>() const
</h3> <p>Returns the current progress value, which is between the <a href="qfuturewatcher#progressMinimum">progressMinimum</a>() and <a href="qfuturewatcher#progressMaximum">progressMaximum</a>().</p> <p><b>See also </b><a href="qfuturewatcher#progressMinimum">progressMinimum</a>() and <a href="qfuturewatcher#progressMaximum">progressMaximum</a>().</p>   <h3 class="fn" id="result">
<span class="type">T</span> QFutureWatcher::<span class="name">result</span>() const
</h3> <p>Returns the first result in the <a href="qfuturewatcher#future">future</a>(). If the result is not immediately available, this function will block and wait for the result to become available. This is a convenience method for calling <a href="qfuturewatcher#resultAt">resultAt</a>(0).</p> <p><b>See also </b><a href="qfuturewatcher#resultAt">resultAt</a>().</p>   <h3 class="fn" id="resultAt">
<span class="type">T</span> QFutureWatcher::<span class="name">resultAt</span>(<span class="type">int</span> <i>index</i>) const
</h3> <p>Returns the result at <i>index</i> in the <a href="qfuturewatcher#future">future</a>(). If the result is not immediately available, this function will block and wait for the result to become available.</p> <p><b>See also </b><a href="qfuturewatcher#result">result</a>().</p>   <h3 class="fn" id="setFuture">
<span class="type">void</span> QFutureWatcher::<span class="name">setFuture</span>(const <span class="type"><a href="qfuture">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>future</i>)
</h3> <p>Starts watching the given <i>future</i>.</p> <p>One of the signals might be emitted for the current state of the <i>future</i>. For example, if the future is already stopped, the finished signal will be emitted.</p> <p>To avoid a race condition, it is important to call this function <i>after</i> doing the connections.</p> <p><b>See also </b><a href="qfuturewatcher#future">future</a>().</p>   <h3 class="fn" id="setPendingResultsLimit">
<span class="type">void</span> QFutureWatcher::<span class="name">setPendingResultsLimit</span>(<span class="type">int</span> <i>limit</i>)
</h3> <p>The setPendingResultsLimit() provides throttling control. When the number of pending <a href="qfuturewatcher#resultReadyAt">resultReadyAt</a>() or <a href="qfuturewatcher#resultsReadyAt">resultsReadyAt</a>() signals exceeds the <i>limit</i>, the computation represented by the future will be throttled automatically. The computation will resume once the number of pending signals drops below the <i>limit</i>.</p>   <h3 class="fn" id="waitForFinished">
<span class="type">void</span> QFutureWatcher::<span class="name">waitForFinished</span>()
</h3> <p>Waits for the asynchronous computation to finish (including <a href="qfuturewatcher#cancel">cancel</a>()ed computations).</p>
<div class="_attribution">
  <p class="_attribution-p">
    © The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-5.15/qfuturewatcher.html" class="_attribution-link">https://doc.qt.io/qt-5.15/qfuturewatcher.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
