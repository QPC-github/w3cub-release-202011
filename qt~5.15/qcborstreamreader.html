
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>QCborStreamReader (Class) - Qt 5.15 - W3cubDocs</title>
  
  <meta name="description" content=" The QCborStreamReader class is a simple CBOR stream decoder, operating on either a QByteArray or QIODevice. More... ">
  <meta name="keywords" content="qcborstreamreader, class, qt, qt~5.15">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/qt~5.15/qcborstreamreader.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/qt~5.15.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt~5.15/" class="_nav-link" title="" style="margin-left:0;">Qt 5.15</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">QCborStreamReader Class</h1>  <p>The QCborStreamReader class is a simple CBOR stream decoder, operating on either a <a href="qbytearray">QByteArray</a> or <a href="qiodevice">QIODevice</a>. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QCborStreamReader&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.12</td>
</tr>
</table>
<p>This class was introduced in Qt 5.12.</p> <ul> <li><a href="https://doc.qt.io/qt-5.15/qcborstreamreader-members.html">List of all members, including inherited members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="threads-reentrancy">reentrant</a>.</p>  <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> struct </td>
<td class="memItemRight bottomAlign"><b><a href="qcborstreamreader-stringresult">StringResult</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#StringResultCode-enum">StringResultCode</a></b> { EndOfString, Ok, Error }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#Type-enum">Type</a></b> { UnsignedInteger, NegativeInteger, ByteArray, ByteString, String, â€¦, Invalid }</td>
</tr> </table>  <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#QCborStreamReader-4">QCborStreamReader</a></b>(QIODevice *<i>device</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#QCborStreamReader-3">QCborStreamReader</a></b>(const QByteArray &amp;<i>data</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#QCborStreamReader-2">QCborStreamReader</a></b>(const quint8 *<i>data</i>, qsizetype <i>len</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#QCborStreamReader-1">QCborStreamReader</a></b>(const char *<i>data</i>, qsizetype <i>len</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#QCborStreamReader">QCborStreamReader</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#dtor.QCborStreamReader">~QCborStreamReader</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#addData">addData</a></b>(const QByteArray &amp;<i>data</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#addData-1">addData</a></b>(const char *<i>data</i>, qsizetype <i>len</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#addData-2">addData</a></b>(const quint8 *<i>data</i>, qsizetype <i>len</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#clear">clear</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#containerDepth">containerDepth</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qint64 </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#currentOffset">currentOffset</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#currentStringChunkSize">currentStringChunkSize</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QIODevice *</td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#device">device</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#enterContainer">enterContainer</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#hasNext">hasNext</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isArray">isArray</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isBool">isBool</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isByteArray">isByteArray</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isContainer">isContainer</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isDouble">isDouble</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isFalse">isFalse</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isFloat16">isFloat16</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isFloat">isFloat</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isInteger">isInteger</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isInvalid">isInvalid</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isLengthKnown">isLengthKnown</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isMap">isMap</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isNegativeInteger">isNegativeInteger</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isNull">isNull</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isSimpleType">isSimpleType</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isSimpleType-1">isSimpleType</a></b>(QCborSimpleType <i>st</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isString">isString</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isTag">isTag</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isTrue">isTrue</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isUndefined">isUndefined</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isUnsignedInteger">isUnsignedInteger</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#isValid">isValid</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborError </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#lastError">lastError</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#leaveContainer">leaveContainer</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> quint64 </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#length">length</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#next">next</a></b>(int <i>maxRecursion</i> = 10000)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborStreamReader::Type </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#parentContainerType">parentContainerType</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> StringResult&lt;QByteArray&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#readByteArray">readByteArray</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> StringResult&lt;QString&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#readString">readString</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> StringResult&lt;qsizetype&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#readStringChunk">readStringChunk</a></b>(char *<i>ptr</i>, qsizetype <i>maxlen</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#reparse">reparse</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#reset">reset</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#setDevice">setDevice</a></b>(QIODevice *<i>device</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#toBool">toBool</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> double </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#toDouble">toDouble</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qfloat16 </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#toFloat16">toFloat16</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> float </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#toFloat">toFloat</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qint64 </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#toInteger">toInteger</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborNegativeInteger </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#toNegativeInteger">toNegativeInteger</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborSimpleType </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#toSimpleType">toSimpleType</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborTag </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#toTag">toTag</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> quint64 </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#toUnsignedInteger">toUnsignedInteger</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborStreamReader::Type </td>
<td class="memItemRight bottomAlign">
<b><a href="qcborstreamreader#type">type</a></b>() const</td>
</tr> </table>    <h2 id="details">Detailed Description
</h2> <p>This class can be used to decode a stream of CBOR content directly from either a <a href="qbytearray">QByteArray</a> or a <a href="qiodevice">QIODevice</a>. CBOR is the Concise Binary Object Representation, a very compact form of binary data encoding that is compatible with JSON. It was created by the IETF Constrained RESTful Environments (CoRE) WG, which has used it in many new RFCs. It is meant to be used alongside the <a href="https://tools.ietf.org/html/rfc7252">CoAP protocol</a>.</p> <p>QCborStreamReader provides a StAX-like API, similar to that of <a href="qxmlstreamreader">QXmlStreamReader</a>. Using it requires a bit of knowledge of CBOR encoding. For a simpler API, see <a href="qcborvalue">QCborValue</a> and especially the decoding function <a href="qcborvalue#fromCbor">QCborValue::fromCbor</a>().</p> <p>Typically, one creates a QCborStreamReader by passing the source <a href="qbytearray">QByteArray</a> or <a href="qiodevice">QIODevice</a> as a parameter to the constructor, then pop elements off the stream if there were no errors in decoding. There are three kinds of CBOR types:</p> <table class="generic"> <thead><tr class="qt-style">
<th>Kind</th>
<th>Types</th>
<th>Behavior</th>
</tr></thead> <tr class="odd" valign="top">
<td>Fixed-width</td>
<td>Integers, Tags, Simple types, Floating point</td>
<td>Value is pre-parsed by QCborStreamReader, so accessor functions are <code>const</code>. Must call <a href="qcborstreamreader#next">next</a>() to advance.</td>
</tr> <tr class="even" valign="top">
<td>Strings</td>
<td>Byte arrays, Text strings</td>
<td>Length (if known) is pre-parsed, but the string itself is not. The accessor functions are not const and may allocate memory. Once called, the accessor functions automatically advance to the next element.</td>
</tr> <tr class="odd" valign="top">
<td>Containers</td>
<td>Arrays, Maps</td>
<td>Length (if known) is pre-parsed. To access the elements, you must call <a href="qcborstreamreader#enterContainer">enterContainer</a>(), read all elements, then call <a href="qcborstreamreader#leaveContainer">leaveContainer</a>(). That function advances to the next element.</td>
</tr> </table> <p>So a processor function typically looks like this:</p> <pre data-language="cpp">   void handleStream(QCborStreamReader &amp;reader)
   {
       switch (reader.type())
       case QCborStreamReader::UnsignedInteger:
       case QCborStreamReader::NegativeInteger:
       case QCborStreamReader::SimpleType:
       case QCborStreamReader::Float16:
       case QCborStreamReader::Float:
       case QCborStreamReader::Double:
           handleFixedWidth(reader);
           reader.next();
           break;
       case QCborStreamReader::ByteArray:
       case QCborStreamReader::String:
           handleString(reader);
           break;
       case QCborStreamReader::Array:
       case QCborStreamReader::Map:
           reader.enterContainer();
           while (reader.lastError() == QCborError::NoError)
               handleStream(reader);
           if (reader.lastError() == QCborError::NoError)
               reader.leaveContainer();
       }
   }</pre>  <h3 id="cbor-support">CBOR support
</h3> <p>The following table lists the CBOR features that QCborStreamReader supports.</p> <table class="generic"> <thead><tr class="qt-style">
<th>Feature</th>
<th>Support</th>
</tr></thead> <tr class="odd" valign="top">
<td>Unsigned numbers</td>
<td>Yes (full range)</td>
</tr> <tr class="even" valign="top">
<td>Negative numbers</td>
<td>Yes (full range)</td>
</tr> <tr class="odd" valign="top">
<td>Byte strings</td>
<td>Yes</td>
</tr> <tr class="even" valign="top">
<td>Text strings</td>
<td>Yes</td>
</tr> <tr class="odd" valign="top">
<td>Chunked strings</td>
<td>Yes</td>
</tr> <tr class="even" valign="top">
<td>Tags</td>
<td>Yes (arbitrary)</td>
</tr> <tr class="odd" valign="top">
<td>Booleans</td>
<td>Yes</td>
</tr> <tr class="even" valign="top">
<td>Null</td>
<td>Yes</td>
</tr> <tr class="odd" valign="top">
<td>Undefined</td>
<td>Yes</td>
</tr> <tr class="even" valign="top">
<td>Arbitrary simple values</td>
<td>Yes</td>
</tr> <tr class="odd" valign="top">
<td>Half-precision float (16-bit)</td>
<td>Yes</td>
</tr> <tr class="even" valign="top">
<td>Single-precision float (32-bit)</td>
<td>Yes</td>
</tr> <tr class="odd" valign="top">
<td>Double-precision float (64-bit)</td>
<td>Yes</td>
</tr> <tr class="even" valign="top">
<td>Infinities and NaN floating point</td>
<td>Yes</td>
</tr> <tr class="odd" valign="top">
<td>Determinate-length arrays and maps</td>
<td>Yes</td>
</tr> <tr class="even" valign="top">
<td>Indeterminate-length arrays and maps</td>
<td>Yes</td>
</tr> <tr class="odd" valign="top">
<td>Map key types other than strings and integers</td>
<td>Yes (arbitrary)</td>
</tr> </table>  <h3 id="dealing-with-invalid-or-incomplete-cbor-streams">Dealing with invalid or incomplete CBOR streams
</h3> <p>QCborStreamReader is capable of detecting corrupt input on its own. The library it uses has been extensively tested against invalid input of any kind and is quite able to report errors. If any is detected, QCborStreamReader will set <a href="qcborstreamreader#lastError">lastError</a>() to a value besides <a href="qcborerror#Code-enum">QCborError::NoError</a>, indicating which situation was detected.</p> <p>Most errors detected by QCborStreamReader during normal item parsing are not recoverable. The code using QCborStreamReader may opt to handle the data that was properly decoded or it can opt to discard the entire data.</p> <p>The only recoverable error is <a href="qcborerror#Code-enum">QCborError::EndOfFile</a>, which indicates that more data is required in order to complete the parsing. This situation is useful when data is being read from an asynchronous source, such as a pipe (<a href="qprocess">QProcess</a>) or a socket (<a href="qtcpsocket">QTcpSocket</a>, <a href="qudpsocket">QUdpSocket</a>, <a href="qnetworkreply">QNetworkReply</a>, etc.). When more data arrives, the surrounding code needs to call either <a href="qcborstreamreader#addData">addData</a>(), if parsing from a <a href="qbytearray">QByteArray</a>, or <a href="qcborstreamreader#reparse">reparse</a>(), if it is instead reading directly a the QIDOevice that now has more data available (see <a href="qcborstreamreader#setDevice">setDevice</a>()).</p>  <p><b>See also </b><a href="qcborstreamwriter">QCborStreamWriter</a>, <a href="qcborvalue">QCborValue</a>, and <a href="qxmlstreamreader">QXmlStreamReader</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="fn" id="StringResultCode-enum">
enum QCborStreamReader::<span class="name">StringResultCode</span>
</h3> <p>This enum is returned by <a href="qcborstreamreader#readString">readString</a>() and <a href="qcborstreamreader#readByteArray">readByteArray</a>() and is used to indicate what the status of the parsing is.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::EndOfString</code></td>
<td class="topAlign tblval"><code>0</code></td>
<td class="topAlign">The parsing for the string is complete, with no error.</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::Ok</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">The function returned data; there was no error.</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::Error</code></td>
<td class="topAlign tblval"><code>-1</code></td>
<td class="topAlign">Parsing failed with an error.</td>
</tr> </table>   <h3 class="fn" id="Type-enum">
enum QCborStreamReader::<span class="name">Type</span>
</h3> <p>This enumeration contains all possible CBOR types as decoded by <a href="qcborstreamreader">QCborStreamReader</a>. CBOR has 7 major types, plus a number of simple types carrying no value, and floating point values.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::UnsignedInteger</code></td>
<td class="topAlign tblval"><code>0x00</code></td>
<td class="topAlign">(Major type 0) Ranges from 0 to 2<sup>64</sup> - 1 (18,446,744,073,709,551,616)</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::NegativeInteger</code></td>
<td class="topAlign tblval"><code>0x20</code></td>
<td class="topAlign">(Major type 1) Ranges from -1 to -2<sup>64</sup> (-18,446,744,073,709,551,616)</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::ByteArray</code></td>
<td class="topAlign tblval"><code>ByteString</code></td>
<td class="topAlign">(Major type 2) Arbitrary binary data.</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::ByteString</code></td>
<td class="topAlign tblval"><code>0x40</code></td>
<td class="topAlign">An alias to ByteArray.</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::String</code></td>
<td class="topAlign tblval"><code>TextString</code></td>
<td class="topAlign">(Major type 3) Unicode text, possibly containing NULs.</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::TextString</code></td>
<td class="topAlign tblval"><code>0x60</code></td>
<td class="topAlign">An alias to String</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::Array</code></td>
<td class="topAlign tblval"><code>0x80</code></td>
<td class="topAlign">(Major type 4) Array of heterogeneous items.</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::Map</code></td>
<td class="topAlign tblval"><code>0xa0</code></td>
<td class="topAlign">(Major type 5) Map/dictionary of heterogeneous items.</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::Tag</code></td>
<td class="topAlign tblval"><code>0xc0</code></td>
<td class="topAlign">(Major type 6) Numbers giving further semantic value to generic CBOR items. See <a href="qtcborcommon#QCborTag-enum">QCborTag</a> for more information.</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::SimpleType</code></td>
<td class="topAlign tblval"><code>0xe0</code></td>
<td class="topAlign">(Major type 7) Types carrying no further value. Includes booleans (true and false), null, undefined.</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::Float16</code></td>
<td class="topAlign tblval"><code>HalfFloat</code></td>
<td class="topAlign">IEEE 754 half-precision floating point (<code>qfloat16</code>).</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::HalfFloat</code></td>
<td class="topAlign tblval"><code>0xf9</code></td>
<td class="topAlign">An alias to Float16.</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::Float</code></td>
<td class="topAlign tblval"><code>0xfa</code></td>
<td class="topAlign">IEEE 754 single-precision floating point (<code>float</code>).</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::Double</code></td>
<td class="topAlign tblval"><code>0xfb</code></td>
<td class="topAlign">IEEE 754 double-precision floating point (<code>double</code>).</td>
</tr> <tr>
<td class="topAlign"><code>QCborStreamReader::Invalid</code></td>
<td class="topAlign tblval"><code>0xff</code></td>
<td class="topAlign">Not a valid type, either due to parsing error or due to reaching the end of an array or map.</td>
</tr> </table>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QCborStreamReader-4">
QCborStreamReader::<span class="name">QCborStreamReader</span>(<span class="type"><a href="qiodevice">QIODevice</a></span> *<i>device</i>)
</h3> <p>This is an overloaded function.</p> <p>Creates a QCborStreamReader object that will parse the CBOR stream found by reading from <i>device</i>. QCborStreamReader does not take ownership of <i>device</i>, so it must remain valid until this oject is destroyed.</p>   <h3 class="fn" id="QCborStreamReader-3">
QCborStreamReader::<span class="name">QCborStreamReader</span>(const <span class="type"><a href="qbytearray">QByteArray</a></span> &amp;<i>data</i>)
</h3> <p>This is an overloaded function.</p> <p>Creates a QCborStreamReader object that will parse the CBOR stream found in <i>data</i>.</p>   <h3 class="fn" id="QCborStreamReader-2">
QCborStreamReader::<span class="name">QCborStreamReader</span>(const <span class="type"><a href="qtglobal#quint8-typedef">quint8</a></span> *<i>data</i>, <span class="type">qsizetype</span> <i>len</i>)
</h3> <p>This is an overloaded function.</p> <p>Creates a QCborStreamReader object with <i>len</i> bytes of data starting at <i>data</i>. The pointer must remain valid until QCborStreamReader is destroyed.</p>   <h3 class="fn" id="QCborStreamReader-1">
QCborStreamReader::<span class="name">QCborStreamReader</span>(const <span class="type">char</span> *<i>data</i>, <span class="type">qsizetype</span> <i>len</i>)
</h3> <p>This is an overloaded function.</p> <p>Creates a QCborStreamReader object with <i>len</i> bytes of data starting at <i>data</i>. The pointer must remain valid until QCborStreamReader is destroyed.</p>   <h3 class="fn" id="QCborStreamReader">
QCborStreamReader::<span class="name">QCborStreamReader</span>()
</h3> <p>Creates a QCborStreamReader object with no source data. After construction, QCborStreamReader will report an error parsing.</p> <p>You can add more data by calling <a href="qcborstreamreader#addData">addData</a>() or by setting a different source device using <a href="qcborstreamreader#setDevice">setDevice</a>().</p> <p><b>See also </b><a href="qcborstreamreader#addData">addData</a>() and <a href="qcborstreamreader#isValid">isValid</a>().</p>   <h3 class="fn" id="dtor.QCborStreamReader">
QCborStreamReader::<span class="name">~QCborStreamReader</span>()
</h3> <p>Destroys this <a href="qcborstreamreader">QCborStreamReader</a> object and frees any associated resources.</p>   <h3 class="fn" id="addData">
<span class="type">void</span> QCborStreamReader::<span class="name">addData</span>(const <span class="type"><a href="qbytearray">QByteArray</a></span> &amp;<i>data</i>)
</h3> <p>Adds <i>data</i> to the CBOR stream and reparses the current element. This function is useful if the end of the data was previously reached while processing the stream, but now more data is available.</p>   <h3 class="fn" id="addData-1">
<span class="type">void</span> QCborStreamReader::<span class="name">addData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type">qsizetype</span> <i>len</i>)
</h3> <p>This is an overloaded function.</p> <p>Adds <i>len</i> bytes of data starting at <i>data</i> to the CBOR stream and reparses the current element. This function is useful if the end of the data was previously reached while processing the stream, but now more data is available.</p>   <h3 class="fn" id="addData-2">
<span class="type">void</span> QCborStreamReader::<span class="name">addData</span>(const <span class="type"><a href="qtglobal#quint8-typedef">quint8</a></span> *<i>data</i>, <span class="type">qsizetype</span> <i>len</i>)
</h3> <p>This is an overloaded function.</p> <p>Adds <i>len</i> bytes of data starting at <i>data</i> to the CBOR stream and reparses the current element. This function is useful if the end of the data was previously reached while processing the stream, but now more data is available.</p>   <h3 class="fn" id="clear">
<span class="type">void</span> QCborStreamReader::<span class="name">clear</span>()
</h3> <p>Clears the decoder state and resets the input source data to an empty byte array. After this function is called, <a href="qcborstreamreader">QCborStreamReader</a> will be indicating an error parsing.</p> <p>Call <a href="qcborstreamreader#addData">addData</a>() to add more data to be parsed.</p> <p><b>See also </b><a href="qcborstreamreader#reset">reset</a>() and <a href="qcborstreamreader#setDevice">setDevice</a>().</p>   <h3 class="fn" id="containerDepth">
<span class="type">int</span> QCborStreamReader::<span class="name">containerDepth</span>() const
</h3> <p>Returns the number of containers that this stream has entered with <a href="qcborstreamreader#enterContainer">enterContainer</a>() but not yet left.</p> <p><b>See also </b><a href="qcborstreamreader#enterContainer">enterContainer</a>() and <a href="qcborstreamreader#leaveContainer">leaveContainer</a>().</p>   <h3 class="fn" id="currentOffset">
<span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> QCborStreamReader::<span class="name">currentOffset</span>() const
</h3> <p>Returns the offset in the input stream of the item currently being decoded. The current offset is the number of decoded bytes so far only if the source data is a <a href="qbytearray">QByteArray</a> or it is a <a href="qiodevice">QIODevice</a> that was positioned at its beginning when decoding started.</p> <p><b>See also </b><a href="qcborstreamreader#reset">reset</a>(), <a href="qcborstreamreader#clear">clear</a>(), and <a href="qcborstreamreader#device">device</a>().</p>   <h3 class="fn" id="currentStringChunkSize">
<span class="type">qsizetype</span> QCborStreamReader::<span class="name">currentStringChunkSize</span>() const
</h3> <p>Returns the size of the current text or byte string chunk. If the CBOR stream contains a non-chunked string (that is, if <a href="qcborstreamreader#isLengthKnown">isLengthKnown</a>() returns <code>true</code>), this function returns the size of the entire string, the same as <a href="qcborstreamreader#length">length</a>().</p> <p>This function is useful to pre-allocate the buffer whose pointer can be passed to <a href="qcborstreamreader#readStringChunk">readStringChunk</a>() later.</p> <p><b>See also </b><a href="qcborstreamreader#readString">readString</a>(), <a href="qcborstreamreader#readByteArray">readByteArray</a>(), and <a href="qcborstreamreader#readStringChunk">readStringChunk</a>().</p>   <h3 class="fn" id="device">
<span class="type"><a href="qiodevice">QIODevice</a></span> *QCborStreamReader::<span class="name">device</span>() const
</h3> <p>Returns the <a href="qiodevice">QIODevice</a> that was set with either <a href="qcborstreamreader#setDevice">setDevice</a>() or the <a href="qcborstreamreader">QCborStreamReader</a> constructor. If this object was reading from a <a href="qbytearray">QByteArray</a>, this function returns nullptr instead.</p> <p><b>See also </b><a href="qcborstreamreader#setDevice">setDevice</a>().</p>   <h3 class="fn" id="enterContainer">
<span class="type">bool</span> QCborStreamReader::<span class="name">enterContainer</span>()
</h3> <p>Enters the array or map that is the current item and prepares for iterating the elements contained in the container. Returns true if entering the container succeeded, false otherwise (usually, a parsing error). Each call to enterContainer() must be paired with a call to <a href="qcborstreamreader#leaveContainer">leaveContainer</a>().</p> <p>This function may only be called if the current item is an array or a map (that is, if <a href="qcborstreamreader#isArray">isArray</a>(), <a href="qcborstreamreader#isMap">isMap</a>() or <a href="qcborstreamreader#isContainer">isContainer</a>() is true). Calling it in any other condition is an error.</p> <p><b>See also </b><a href="qcborstreamreader#leaveContainer">leaveContainer</a>(), <a href="qcborstreamreader#isContainer">isContainer</a>(), <a href="qcborstreamreader#isArray">isArray</a>(), and <a href="qcborstreamreader#isMap">isMap</a>().</p>   <h3 class="fn" id="hasNext">
<span class="type">bool</span> QCborStreamReader::<span class="name">hasNext</span>() const
</h3> <p>Returns true if there are more items to be decoded in the current container or false of we've reached its end. If we're parsing the root element, hasNext() returning false indicates the parsing is complete; otherwise, if the container depth is non-zero, then the outer code needs to call <a href="qcborstreamreader#leaveContainer">leaveContainer</a>().</p> <p><b>See also </b><a href="qcborstreamreader#parentContainerType">parentContainerType</a>(), <a href="qcborstreamreader#containerDepth">containerDepth</a>(), and <a href="qcborstreamreader#leaveContainer">leaveContainer</a>().</p>   <h3 class="fn" id="isArray">
<span class="type">bool</span> QCborStreamReader::<span class="name">isArray</span>() const
</h3> <p>Returns true if the type of the current element is an array (that is, if <a href="qcborstreamreader#type">type</a>() returns <a href="qcborstreamreader#Type-enum">QCborStreamReader::Array</a>). If this function returns true, you may call <a href="qcborstreamreader#enterContainer">enterContainer</a>() to begin parsing that container.</p> <p>When the current element is an array, you may also call <a href="qcborstreamreader#isLengthKnown">isLengthKnown</a>() to find out if the array's size is explicit in the CBOR stream. If it is, that size can be obtained by calling <a href="qcborstreamreader#length">length</a>().</p> <p>The following example pre-allocates a <a href="qvariant#QVariantList-typedef">QVariantList</a> given the array's size for more efficient decoding:</p> <pre data-language="cpp">   QVariantList populateFromCbor(QCborStreamReader &amp;reader)
   {
       QVariantList list;
       if (reader.isLengthKnown())
           list.reserve(reader.length());

       reader.enterContainer();
       while (reader.lastError() == QCborError::NoError &amp;&amp; reader.hasNext())
           list.append(readOneElement(reader));
       if (reader.lastError() == QCborError::NoError)
           reader.leaveContainer();
   }</pre> <p><b>Note: </b>The code above does not validate that the length is a sensible value. If the input stream reports that the length is 1 billion elements, the above function will try to allocate some 16 GB or more of RAM, which can lead to a crash.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#isMap">isMap</a>(), <a href="qcborstreamreader#isLengthKnown">isLengthKnown</a>(), <a href="qcborstreamreader#length">length</a>(), <a href="qcborstreamreader#enterContainer">enterContainer</a>(), and <a href="qcborstreamreader#leaveContainer">leaveContainer</a>().</p>   <h3 class="fn" id="isBool">
<span class="type">bool</span> QCborStreamReader::<span class="name">isBool</span>() const
</h3> <p>Returns true if the current element is a boolean value (<code>true</code> or <code>false</code>), false if it is anything else. If this function returns true, you may call <a href="qcborstreamreader#toBool">toBool</a>() to retrieve the value of the boolean. You may also call <a href="qcborstreamreader#toSimpleType">toSimpleType</a>() and compare to either QCborSimpleValue::True or QCborSimpleValue::False.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#isFalse">isFalse</a>(), <a href="qcborstreamreader#isTrue">isTrue</a>(), <a href="qcborstreamreader#toBool">toBool</a>(), <a href="qcborstreamreader#isSimpleType">isSimpleType</a>(), and <a href="qcborstreamreader#toSimpleType">toSimpleType</a>().</p>   <h3 class="fn" id="isByteArray">
<span class="type">bool</span> QCborStreamReader::<span class="name">isByteArray</span>() const
</h3> <p>Returns true if the type of the current element is a byte array (that is, if <a href="qcborstreamreader#type">type</a>() returns <a href="qcborstreamreader#Type-enum">QCborStreamReader::ByteArray</a>). If this function returns true, you may call <a href="qcborstreamreader#readByteArray">readByteArray</a>() to read that data.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#readByteArray">readByteArray</a>(), and <a href="qcborstreamreader#isString">isString</a>().</p>   <h3 class="fn" id="isContainer">
<span class="type">bool</span> QCborStreamReader::<span class="name">isContainer</span>() const
</h3> <p>Returns true if the current element is a container (that is, an array or a map), false if it is anything else. If the current element is a container, the <a href="qcborstreamreader#isLengthKnown">isLengthKnown</a>() function may be used to find out if the container's size is explicit in the stream and, if so, <a href="qcborstreamreader#length">length</a>() can be used to get that size.</p> <p>More importantly, for a container, the <a href="qcborstreamreader#enterContainer">enterContainer</a>() function is available to begin iterating through the elements contained therein.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#isArray">isArray</a>(), <a href="qcborstreamreader#isMap">isMap</a>(), <a href="qcborstreamreader#isLengthKnown">isLengthKnown</a>(), <a href="qcborstreamreader#length">length</a>(), <a href="qcborstreamreader#enterContainer">enterContainer</a>(), <a href="qcborstreamreader#leaveContainer">leaveContainer</a>(), and <a href="qcborstreamreader#containerDepth">containerDepth</a>().</p>   <h3 class="fn" id="isDouble">
<span class="type">bool</span> QCborStreamReader::<span class="name">isDouble</span>() const
</h3> <p>Returns true if the type of the current element is an IEEE 754 double-precision floating point (that is, if <a href="qcborstreamreader#type">type</a>() returns <a href="qcborstreamreader#Type-enum">QCborStreamReader::Double</a>). If this function returns true, you may call <a href="qcborstreamreader#toDouble">toDouble</a>() to read that data.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#toDouble">toDouble</a>(), <a href="qcborstreamreader#isFloat16">isFloat16</a>(), and <a href="qcborstreamreader#isFloat">isFloat</a>().</p>   <h3 class="fn" id="isFalse">
<span class="type">bool</span> QCborStreamReader::<span class="name">isFalse</span>() const
</h3> <p>Returns true if the current element is the <code>false</code> value, false if it is anything else.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#isTrue">isTrue</a>(), <a href="qcborstreamreader#isBool">isBool</a>(), <a href="qcborstreamreader#toBool">toBool</a>(), <a href="qcborstreamreader#isSimpleType">isSimpleType</a>(), and <a href="qcborstreamreader#toSimpleType">toSimpleType</a>().</p>   <h3 class="fn" id="isFloat16">
<span class="type">bool</span> QCborStreamReader::<span class="name">isFloat16</span>() const
</h3> <p>Returns true if the type of the current element is an IEEE 754 half-precision floating point (that is, if <a href="qcborstreamreader#type">type</a>() returns <a href="qcborstreamreader#Type-enum">QCborStreamReader::Float16</a>). If this function returns true, you may call <a href="qcborstreamreader#toFloat16">toFloat16</a>() to read that data.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#toFloat16">toFloat16</a>(), <a href="qcborstreamreader#isFloat">isFloat</a>(), and <a href="qcborstreamreader#isDouble">isDouble</a>().</p>   <h3 class="fn" id="isFloat">
<span class="type">bool</span> QCborStreamReader::<span class="name">isFloat</span>() const
</h3> <p>Returns true if the type of the current element is an IEEE 754 single-precision floating point (that is, if <a href="qcborstreamreader#type">type</a>() returns <a href="qcborstreamreader#Type-enum">QCborStreamReader::Float</a>). If this function returns true, you may call <a href="qcborstreamreader#toFloat">toFloat</a>() to read that data.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#toFloat">toFloat</a>(), <a href="qcborstreamreader#isFloat16">isFloat16</a>(), and <a href="qcborstreamreader#isDouble">isDouble</a>().</p>   <h3 class="fn" id="isInteger">
<span class="type">bool</span> QCborStreamReader::<span class="name">isInteger</span>() const
</h3> <p>Returns true if the type of the current element is either an unsigned integer or a negative one (that is, if <a href="qcborstreamreader#type">type</a>() returns <a href="qcborstreamreader#Type-enum">QCborStreamReader::UnsignedInteger</a> or <a href="qcborstreamreader#Type-enum">QCborStreamReader::NegativeInteger</a>). If this function returns true, you may call <a href="qcborstreamreader#toInteger">toInteger</a>() to read that value.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#toInteger">toInteger</a>(), <a href="qcborstreamreader#toUnsignedInteger">toUnsignedInteger</a>(), <a href="qcborstreamreader#toNegativeInteger">toNegativeInteger</a>(), <a href="qcborstreamreader#isUnsignedInteger">isUnsignedInteger</a>(), and <a href="qcborstreamreader#isNegativeInteger">isNegativeInteger</a>().</p>   <h3 class="fn" id="isInvalid">
<span class="type">bool</span> QCborStreamReader::<span class="name">isInvalid</span>() const
</h3> <p>Returns true if the current element is invalid, false otherwise. The current element may be invalid if there was a decoding error or we've just parsed the last element in an array or map.</p> <p><b>Note: </b>This function is not to be confused with <a href="qcborstreamreader#isNull">isNull</a>(). Null is a normal CBOR type that must be handled by the application.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>() and <a href="qcborstreamreader#isValid">isValid</a>().</p>   <h3 class="fn" id="isLengthKnown">
<span class="type">bool</span> QCborStreamReader::<span class="name">isLengthKnown</span>() const
</h3> <p>Returns true if the length of the current array, map, byte array or string is known (explicit in the CBOR stream), false otherwise. This function should only be called if the element is one of those.</p> <p>If the length is known, it may be obtained by calling <a href="qcborstreamreader#length">length</a>().</p> <p>If the length of a map or an array is not known, it is implied by the number of elements present in the stream. <a href="qcborstreamreader">QCborStreamReader</a> has no API to calculate the length in that condition.</p> <p>Strings and byte arrays may also have indeterminate length (that is, they may be transmitted in multiple chunks). Those cannot currently be created with <a href="qcborstreamwriter">QCborStreamWriter</a>, but they could be with other encoders, so <a href="qcborstreamreader">QCborStreamReader</a> supports them.</p> <p><b>See also </b><a href="qcborstreamreader#length">length</a>(), <a href="qcborstreamwriter#startArray">QCborStreamWriter::startArray</a>(), and <a href="qcborstreamwriter#startMap">QCborStreamWriter::startMap</a>().</p>   <h3 class="fn" id="isMap">
<span class="type">bool</span> QCborStreamReader::<span class="name">isMap</span>() const
</h3> <p>Returns true if the type of the current element is a map (that is, if <a href="qcborstreamreader#type">type</a>() returns <a href="qcborstreamreader#Type-enum">QCborStreamReader::Map</a>). If this function returns true, you may call <a href="qcborstreamreader#enterContainer">enterContainer</a>() to begin parsing that container.</p> <p>When the current element is a map, you may also call <a href="qcborstreamreader#isLengthKnown">isLengthKnown</a>() to find out if the map's size is explicit in the CBOR stream. If it is, that size can be obtained by calling <a href="qcborstreamreader#length">length</a>().</p> <p>The following example pre-allocates a <a href="qvariant#QVariantMap-typedef">QVariantMap</a> given the map's size for more efficient decoding:</p> <pre data-language="cpp">   QVariantMap populateFromCbor(QCborStreamReader &amp;reader)
   {
       QVariantMap map;
       if (reader.isLengthKnown())
           map.reserve(reader.length());

       reader.enterContainer();
       while (reader.lastError() == QCborError::NoError &amp;&amp; reader.hasNext()) {
           QString key = readElementAsString(reader);
           map.insert(key, readOneElement(reader));
       }
       if (reader.lastError() == QCborError::NoError)
           reader.leaveContainer();
   }</pre> <p>The example above uses a function called <code>readElementAsString</code> to read the map's keys and obtain a string. That is because CBOR maps may contain any type as keys, not just strings. User code needs to either perform this conversion, reject non-string keys, or instead use a different container besides <a href="qvariant#QVariantMap-typedef">QVariantMap</a> and <a href="qvariant#QVariantHash-typedef">QVariantHash</a>. For example, if the map is expected to contain integer keys, which is recommended as it reduces stream size and parsing, the correct container would be <code>\l{QMap}&lt;int, QVariant&gt;</code> or <code>\l{QHash}&lt;int, QVariant&gt;</code>.</p> <p><b>Note: </b>The code above does not validate that the length is a sensible value. If the input stream reports that the length is 1 billion elements, the above function will try to allocate some 24 GB or more of RAM, which can lead to a crash.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#isArray">isArray</a>(), <a href="qcborstreamreader#isLengthKnown">isLengthKnown</a>(), <a href="qcborstreamreader#length">length</a>(), <a href="qcborstreamreader#enterContainer">enterContainer</a>(), and <a href="qcborstreamreader#leaveContainer">leaveContainer</a>().</p>   <h3 class="fn" id="isNegativeInteger">
<span class="type">bool</span> QCborStreamReader::<span class="name">isNegativeInteger</span>() const
</h3> <p>Returns true if the type of the current element is a negative integer (that is if <a href="qcborstreamreader#type">type</a>() returns <a href="qcborstreamreader#Type-enum">QCborStreamReader::NegativeInteger</a>). If this function returns true, you may call <a href="qcborstreamreader#toNegativeInteger">toNegativeInteger</a>() or <a href="qcborstreamreader#toInteger">toInteger</a>() to read that value.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#toNegativeInteger">toNegativeInteger</a>(), <a href="qcborstreamreader#toInteger">toInteger</a>(), <a href="qcborstreamreader#isInteger">isInteger</a>(), and <a href="qcborstreamreader#isUnsignedInteger">isUnsignedInteger</a>().</p>   <h3 class="fn" id="isNull">
<span class="type">bool</span> QCborStreamReader::<span class="name">isNull</span>() const
</h3> <p>Returns true if the current element is the <code>null</code> value, false if it is anything else. Null values may be used to indicate the absence of some optional data.</p> <p><b>Note: </b>This function is not the opposite of <a href="qcborstreamreader#isValid">isValid</a>(). A Null value is a valid CBOR value.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#isSimpleType">isSimpleType</a>(), and <a href="qcborstreamreader#toSimpleType">toSimpleType</a>().</p>   <h3 class="fn" id="isSimpleType">
<span class="type">bool</span> QCborStreamReader::<span class="name">isSimpleType</span>() const
</h3> <p>Returns true if the type of the current element is any CBOR simple type, including a boolean value (true and false) as well as null and undefined. To find out which simple type this is, call <a href="qcborstreamreader#toSimpleType">toSimpleType</a>(). Alternatively, to test for one specific simple type, call the overload that takes a <a href="qtcborcommon#QCborSimpleType-enum">QCborSimpleType</a> parameter.</p> <p>CBOR simple types are types that do not carry extra value. There are 255 possibilities, but there are currently only four values that have defined meaning. Code is not expected to cope with unknown simple types and may simply discard the stream as invalid if it finds an unknown one.</p> <p><b>See also </b><a href="qtcborcommon#QCborSimpleType-enum">QCborSimpleType</a>, <a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#isSimpleType-1">isSimpleType</a>(QCborSimpleType), and <a href="qcborstreamreader#toSimpleType">toSimpleType</a>().</p>   <h3 class="fn" id="isSimpleType-1">
<span class="type">bool</span> QCborStreamReader::<span class="name">isSimpleType</span>(<span class="type"><a href="qtcborcommon#QCborSimpleType-enum">QCborSimpleType</a></span> <i>st</i>) const
</h3> <p>Returns true if the type of the current element is the simple type <i>st</i>, false otherwise. If this function returns true, then <a href="qcborstreamreader#toSimpleType">toSimpleType</a>() will return <i>st</i>.</p> <p>CBOR simple types are types that do not carry extra value. There are 255 possibilities, but there are currently only four values that have defined meaning. Code is not expected to cope with unknown simple types and may simply discard the stream as invalid if it finds an unknown one.</p> <p><b>See also </b><a href="qtcborcommon#QCborSimpleType-enum">QCborSimpleType</a>, <a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#isSimpleType">isSimpleType</a>(), and <a href="qcborstreamreader#toSimpleType">toSimpleType</a>().</p>   <h3 class="fn" id="isString">
<span class="type">bool</span> QCborStreamReader::<span class="name">isString</span>() const
</h3> <p>Returns true if the type of the current element is a text string (that is, if <a href="qcborstreamreader#type">type</a>() returns <a href="qcborstreamreader#Type-enum">QCborStreamReader::String</a>). If this function returns true, you may call <a href="qcborstreamreader#readString">readString</a>() to read that data.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#readString">readString</a>(), and <a href="qcborstreamreader#isByteArray">isByteArray</a>().</p>   <h3 class="fn" id="isTag">
<span class="type">bool</span> QCborStreamReader::<span class="name">isTag</span>() const
</h3> <p>Returns true if the type of the current element is a CBOR tag (that is, if <a href="qcborstreamreader#type">type</a>() returns <a href="qcborstreamreader#Type-enum">QCborStreamReader::Tag</a>). If this function returns true, you may call <a href="qcborstreamreader#toTag">toTag</a>() to read that data.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>() and <a href="qcborstreamreader#toTag">toTag</a>().</p>   <h3 class="fn" id="isTrue">
<span class="type">bool</span> QCborStreamReader::<span class="name">isTrue</span>() const
</h3> <p>Returns true if the current element is the <code>true</code> value, false if it is anything else.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#isFalse">isFalse</a>(), <a href="qcborstreamreader#isBool">isBool</a>(), <a href="qcborstreamreader#toBool">toBool</a>(), <a href="qcborstreamreader#isSimpleType">isSimpleType</a>(), and <a href="qcborstreamreader#toSimpleType">toSimpleType</a>().</p>   <h3 class="fn" id="isUndefined">
<span class="type">bool</span> QCborStreamReader::<span class="name">isUndefined</span>() const
</h3> <p>Returns true if the current element is the <code>undefined</code> value, false if it is anything else. Undefined values may be encoded to indicate that some conversion failed or was not possible when creating the stream. <a href="qcborstreamreader">QCborStreamReader</a> never performs any replacement and this function will only return true if the stream contains an explicit undefined value.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#isSimpleType">isSimpleType</a>(), and <a href="qcborstreamreader#toSimpleType">toSimpleType</a>().</p>   <h3 class="fn" id="isUnsignedInteger">
<span class="type">bool</span> QCborStreamReader::<span class="name">isUnsignedInteger</span>() const
</h3> <p>Returns true if the type of the current element is an unsigned integer (that is if <a href="qcborstreamreader#type">type</a>() returns <a href="qcborstreamreader#Type-enum">QCborStreamReader::UnsignedInteger</a>). If this function returns true, you may call <a href="qcborstreamreader#toUnsignedInteger">toUnsignedInteger</a>() or <a href="qcborstreamreader#toInteger">toInteger</a>() to read that value.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#toUnsignedInteger">toUnsignedInteger</a>(), <a href="qcborstreamreader#toInteger">toInteger</a>(), <a href="qcborstreamreader#isInteger">isInteger</a>(), and <a href="qcborstreamreader#isNegativeInteger">isNegativeInteger</a>().</p>   <h3 class="fn" id="isValid">
<span class="type">bool</span> QCborStreamReader::<span class="name">isValid</span>() const
</h3> <p>Returns true if the current element is valid, false otherwise. The current element may be invalid if there was a decoding error or we've just parsed the last element in an array or map.</p> <p><b>Note: </b>This function is not the opposite of <a href="qcborstreamreader#isNull">isNull</a>(). Null is a normal CBOR type that must be handled by the application.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>() and <a href="qcborstreamreader#isInvalid">isInvalid</a>().</p>   <h3 class="fn" id="lastError">
<span class="type"><a href="qcborerror">QCborError</a></span> QCborStreamReader::<span class="name">lastError</span>()
</h3> <p>Returns the last error in decoding the stream, if any. If no error was encountered, this returns an <a href="qcborerror#Code-enum">QCborError::NoError</a>.</p> <p><b>See also </b><a href="qcborstreamreader#isValid">isValid</a>().</p>   <h3 class="fn" id="leaveContainer">
<span class="type">bool</span> QCborStreamReader::<span class="name">leaveContainer</span>()
</h3> <p>Leaves the array or map whose items were being processed and positions the decoder at the next item after the end of the container. Returns true if leaving the container succeeded, false otherwise (usually, a parsing error). Each call to <a href="qcborstreamreader#enterContainer">enterContainer</a>() must be paired with a call to leaveContainer().</p> <p>This function may only be called if <a href="qcborstreamreader#hasNext">hasNext</a>() has returned false and <a href="qcborstreamreader#containerDepth">containerDepth</a>() is not zero. Calling it in any other condition is an error.</p> <p><b>See also </b><a href="qcborstreamreader#enterContainer">enterContainer</a>(), <a href="qcborstreamreader#parentContainerType">parentContainerType</a>(), and <a href="qcborstreamreader#containerDepth">containerDepth</a>().</p>   <h3 class="fn" id="length">
<span class="type"><a href="qtglobal#quint64-typedef">quint64</a></span> QCborStreamReader::<span class="name">length</span>() const
</h3> <p>Returns the length of the string or byte array, or the number of items in an array or the number, of item pairs in a map, if known. This function must not be called if the length is unknown (that is, if <a href="qcborstreamreader#isLengthKnown">isLengthKnown</a>() returned false). It is an error to do that and it will cause <a href="qcborstreamreader">QCborStreamReader</a> to stop parsing the input stream.</p> <p><b>See also </b><a href="qcborstreamreader#isLengthKnown">isLengthKnown</a>(), <a href="qcborstreamwriter#startArray">QCborStreamWriter::startArray</a>(), and <a href="qcborstreamwriter#startMap">QCborStreamWriter::startMap</a>().</p>   <h3 class="fn" id="next">
<span class="type">bool</span> QCborStreamReader::<span class="name">next</span>(<span class="type">int</span> <i>maxRecursion</i> = 10000)
</h3> <p>Advance the CBOR stream decoding one element. You should usually call this function when parsing fixed-width basic elements (that is, integers, simple values, tags and floating point values). But this function can be called when the current item is a string, array or map too and it will skip over that entire element, including all contained elements.</p> <p>This function returns true if advancing was successful, false otherwise. It may fail if the stream is corrupt, incomplete or if the nesting level of arrays and maps exceeds <i>maxRecursion</i>. Calling this function when <a href="qcborstreamreader#hasNext">hasNext</a>() has returned false is also an error. If this function returns false, <a href="qcborstreamreader#lastError">lastError</a>() will return the error code detailing what the failure was.</p> <p><b>See also </b><a href="qcborstreamreader#lastError">lastError</a>(), <a href="qcborstreamreader#isValid">isValid</a>(), and <a href="qcborstreamreader#hasNext">hasNext</a>().</p>   <h3 class="fn" id="parentContainerType">
<span class="type"><a href="qcborstreamreader#Type-enum">QCborStreamReader::Type</a></span> QCborStreamReader::<span class="name">parentContainerType</span>() const
</h3> <p>Returns either <a href="qcborstreamreader#Type-enum">QCborStreamReader::Array</a> or <a href="qcborstreamreader#Type-enum">QCborStreamReader::Map</a>, indicating whether the container that contains the current item was an array or map, respectively. If we're currently parsing the root element, this function returns <a href="qcborstreamreader#Type-enum">QCborStreamReader::Invalid</a>.</p> <p><b>See also </b><a href="qcborstreamreader#containerDepth">containerDepth</a>() and <a href="qcborstreamreader#enterContainer">enterContainer</a>().</p>   <h3 class="fn" id="readByteArray">
<span class="type"><a href="qcborstreamreader-stringresult">StringResult</a></span>&lt;<span class="type"><a href="qbytearray">QByteArray</a></span>&gt; QCborStreamReader::<span class="name">readByteArray</span>()
</h3> <p>Decodes one byte array chunk from the CBOR string and returns it. This function is used for both regular and chunked contents, so the caller must always loop around calling this function, even if <a href="qcborstreamreader#isLengthKnown">isLengthKnown</a>() has is true. The typical use of this function is as follows:</p> <pre data-language="cpp">   QBytearray decodeBytearray(QCborStreamReader &amp;reader)
   {
       QBytearray result;
       auto r = reader.readBytearray();
       while (r.code == QCborStreamReader::Ok) {
           result += r.data;
           r = reader.readByteArray();
       }

       if (r.code == QCborStreamReader::Error) {
           // handle error condition
           result.clear();
       }
       return result;
   }</pre> <p>This function does not perform any type conversions, including from integers or from strings. Therefore, it may only be called if <a href="qcborstreamreader#isByteArray">isByteArray</a>() is true; calling it in any other condition is an error.</p> <p><b>See also </b><a href="qcborstreamreader#readString">readString</a>(), <a href="qcborstreamreader#isByteArray">isByteArray</a>(), and <a href="qcborstreamreader#readStringChunk">readStringChunk</a>().</p>   <h3 class="fn" id="readString">
<span class="type"><a href="qcborstreamreader-stringresult">StringResult</a></span>&lt;<span class="type"><a href="qstring">QString</a></span>&gt; QCborStreamReader::<span class="name">readString</span>()
</h3> <p>Decodes one string chunk from the CBOR string and returns it. This function is used for both regular and chunked string contents, so the caller must always loop around calling this function, even if <a href="qcborstreamreader#isLengthKnown">isLengthKnown</a>() has is true. The typical use of this function is as follows:</p> <pre data-language="cpp">   QString decodeString(QCborStreamReader &amp;reader)
   {
       QString result;
       auto r = reader.readString();
       while (r.code == QCborStreamReader::Ok) {
           result += r.data;
           r = reader.readString();
       }

       if (r.code == QCborStreamReader::Error) {
           // handle error condition
           result.clear();
       }
       return result;
   }</pre> <p>This function does not perform any type conversions, including from integers or from byte arrays. Therefore, it may only be called if <a href="qcborstreamreader#isString">isString</a>() returned true; calling it in any other condition is an error.</p> <p><b>See also </b><a href="qcborstreamreader#readByteArray">readByteArray</a>(), <a href="qcborstreamreader#isString">isString</a>(), and <a href="qcborstreamreader#readStringChunk">readStringChunk</a>().</p>   <h3 class="fn" id="readStringChunk">
<span class="type"><a href="qcborstreamreader-stringresult">StringResult</a></span>&lt;<span class="type">qsizetype</span>&gt; QCborStreamReader::<span class="name">readStringChunk</span>(<span class="type">char</span> *<i>ptr</i>, <span class="type">qsizetype</span> <i>maxlen</i>)
</h3> <p>Reads the current string chunk into the buffer pointed to by <i>ptr</i>, whose size is <i>maxlen</i>. This function returns a <a href="qcborstreamreader-stringresult">StringResult</a> object, with the number of bytes copied into <i>ptr</i> saved in the <code>\l</code> <a href="qcborstreamreader-stringresult#data-var">StringResult::data</a> member. The <code>\l</code> <a href="qcborstreamreader-stringresult#status-var">StringResult::status</a> member indicates whether there was an error reading the string, whether data was copied or whether this was the last chunk.</p> <p>This function can be called for both <a href="qcborstreamreader#Type-enum">String</a> and <a href="qcborstreamreader#Type-enum">ByteArray</a> types. For the latter, this function will read the same data that <a href="qcborstreamreader#readByteArray">readByteArray</a>() would have returned. For strings, it returns the UTF-8 equivalent of the <a href="qstring">QString</a> that would have been returned.</p> <p>This function is usually used alongside <a href="qcborstreamreader#currentStringChunkSize">currentStringChunkSize</a>() in a loop. For example:</p> <pre data-language="cpp">    QCborStreamReader&lt;qsizetype&gt; result;
    do {
        qsizetype size = reader.currentStringChunkSize();
        qsizetype oldsize = buffer.size();
        buffer.resize(oldsize + size);
        result = reader.readStringChunk(buffer.data() + oldsize, size);
    } while (result.status() == QCborStreamReader::Ok);</pre> <p>Unlike <a href="qcborstreamreader#readByteArray">readByteArray</a>() and <a href="qcborstreamreader#readString">readString</a>(), this function is not limited by implementation limits of <a href="qbytearray">QByteArray</a> and <a href="qstring">QString</a>.</p> <p><b>Note: </b>This function does not perform verification that the UTF-8 contents are properly formatted. That means this function does not produce the <a href="qcborerror#Code-enum">QCborError::InvalidUtf8String</a> error, even when <a href="qcborstreamreader#readString">readString</a>() does.</p> <p><b>See also </b><a href="qcborstreamreader#currentStringChunkSize">currentStringChunkSize</a>(), <a href="qcborstreamreader#readString">readString</a>(), <a href="qcborstreamreader#readByteArray">readByteArray</a>(), <a href="qcborstreamreader#isString">isString</a>(), and <a href="qcborstreamreader#isByteArray">isByteArray</a>().</p>   <h3 class="fn" id="reparse">
<span class="type">void</span> QCborStreamReader::<span class="name">reparse</span>()
</h3> <p>Reparses the current element. This function must be called when more data becomes available in the source <a href="qiodevice">QIODevice</a> after parsing failed due to reaching the end of the input data before the end of the CBOR stream.</p> <p>When reading from QByteArray(), the <a href="qcborstreamreader#addData">addData</a>() function automatically calls this function. Calling it when the reading had not failed is a no-op.</p>   <h3 class="fn" id="reset">
<span class="type">void</span> QCborStreamReader::<span class="name">reset</span>()
</h3> <p>Resets the source back to the beginning and clears the decoder state. If the source data was a <a href="qbytearray">QByteArray</a>, <a href="qcborstreamreader">QCborStreamReader</a> will restart from the beginning of the array.</p> <p>If the source data is a <a href="qiodevice">QIODevice</a>, this function will call <a href="qiodevice#reset">QIODevice::reset</a>(), which will seek to byte position 0. If the CBOR stream is not found at the beginning of the device (e.g., beginning of a file), then this function will likely do the wrong thing. Instead, position the <a href="qiodevice">QIODevice</a> to the right offset and call <a href="qcborstreamreader#setDevice">setDevice</a>().</p> <p><b>See also </b><a href="qcborstreamreader#clear">clear</a>() and <a href="qcborstreamreader#setDevice">setDevice</a>().</p>   <h3 class="fn" id="setDevice">
<span class="type">void</span> QCborStreamReader::<span class="name">setDevice</span>(<span class="type"><a href="qiodevice">QIODevice</a></span> *<i>device</i>)
</h3> <p>Sets the source of data to <i>device</i>, resetting the decoder to its initial state.</p> <p><b>See also </b><a href="qcborstreamreader#device">device</a>().</p>   <h3 class="fn" id="toBool">
<span class="type">bool</span> QCborStreamReader::<span class="name">toBool</span>() const
</h3> <p>Returns the boolean value of the current element.</p> <p>This function does not perform any type conversions, including from integer. Therefore, it may only be called if <a href="qcborstreamreader#isTrue">isTrue</a>(), <a href="qcborstreamreader#isFalse">isFalse</a>() or <a href="qcborstreamreader#isBool">isBool</a>() returned true; calling it in any other condition is an error.</p> <p><b>See also </b><a href="qcborstreamreader#isBool">isBool</a>(), <a href="qcborstreamreader#isTrue">isTrue</a>(), <a href="qcborstreamreader#isFalse">isFalse</a>(), and <a href="qcborstreamreader#toInteger">toInteger</a>().</p>   <h3 class="fn" id="toDouble">
<span class="type">double</span> QCborStreamReader::<span class="name">toDouble</span>() const
</h3> <p>Returns the 64-bit double-precision floating point value of the current element.</p> <p>This function does not perform any type conversions, including from other floating point types or from integer values. Therefore, it may only be called if <a href="qcborstreamreader#isDouble">isDouble</a>() is true; calling it in any other condition is an error.</p> <p><b>See also </b><a href="qcborstreamreader#isDouble">isDouble</a>(), <a href="qcborstreamreader#toFloat16">toFloat16</a>(), and <a href="qcborstreamreader#toFloat">toFloat</a>().</p>   <h3 class="fn" id="toFloat16">
<span class="type"><a href="qfloat16">qfloat16</a></span> QCborStreamReader::<span class="name">toFloat16</span>() const
</h3> <p>Returns the 16-bit half-precision floating point value of the current element.</p> <p>This function does not perform any type conversions, including from other floating point types or from integer values. Therefore, it may only be called if <a href="qcborstreamreader#isFloat16">isFloat16</a>() is true; calling it in any other condition is an error.</p> <p><b>See also </b><a href="qcborstreamreader#isFloat16">isFloat16</a>(), <a href="qcborstreamreader#toFloat">toFloat</a>(), and <a href="qcborstreamreader#toDouble">toDouble</a>().</p>   <h3 class="fn" id="toFloat">
<span class="type">float</span> QCborStreamReader::<span class="name">toFloat</span>() const
</h3> <p>Returns the 32-bit single-precision floating point value of the current element.</p> <p>This function does not perform any type conversions, including from other floating point types or from integer values. Therefore, it may only be called if <a href="qcborstreamreader#isFloat">isFloat</a>() is true; calling it in any other condition is an error.</p> <p><b>See also </b><a href="qcborstreamreader#isFloat">isFloat</a>(), <a href="qcborstreamreader#toFloat16">toFloat16</a>(), and <a href="qcborstreamreader#toDouble">toDouble</a>().</p>   <h3 class="fn" id="toInteger">
<span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> QCborStreamReader::<span class="name">toInteger</span>() const
</h3> <p>Returns the integer value of the current element, be it negative, positive or zero. If the value is larger than 2<sup>63</sup> - 1 or smaller than -2<sup>63</sup>, the returned value will overflow and will have an incorrect sign. If handling those values is required, use <a href="qcborstreamreader#toUnsignedInteger">toUnsignedInteger</a>() or <a href="qcborstreamreader#toNegativeInteger">toNegativeInteger</a>() instead.</p> <p>This function does not perform any type conversions, including from boolean or CBOR tag. Therefore, it may only be called if <a href="qcborstreamreader#isInteger">isInteger</a>() is true; calling it in any other condition is an error.</p> <p><b>See also </b><a href="qcborstreamreader#isInteger">isInteger</a>(), <a href="qcborstreamreader#toUnsignedInteger">toUnsignedInteger</a>(), and <a href="qcborstreamreader#toNegativeInteger">toNegativeInteger</a>().</p>   <h3 class="fn" id="toNegativeInteger">
<span class="type">QCborNegativeInteger</span> QCborStreamReader::<span class="name">toNegativeInteger</span>() const
</h3> <p>Returns the negative integer value of the current element. QCborNegativeValue is a 64-bit unsigned integer containing the absolute value of the negative number that was stored in the CBOR stream. Additionally, QCborNegativeValue(0) represents the number -2<sup>64</sup>.</p> <p>This function does not perform any type conversions, including from boolean or CBOR tag. Therefore, it may only be called if <a href="qcborstreamreader#isNegativeInteger">isNegativeInteger</a>() is true; calling it in any other condition is an error.</p> <p>This function may be used to obtain numbers beyond the range of the return type of <a href="qcborstreamreader#toInteger">toInteger</a>(). However, use of negative numbers smaller than -2<sup>63</sup> is extremely discouraged.</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#toInteger">toInteger</a>(), <a href="qcborstreamreader#isNegativeInteger">isNegativeInteger</a>(), and <a href="qcborstreamreader#isUnsignedInteger">isUnsignedInteger</a>().</p>   <h3 class="fn" id="toSimpleType">
<span class="type"><a href="qtcborcommon#QCborSimpleType-enum">QCborSimpleType</a></span> QCborStreamReader::<span class="name">toSimpleType</span>() const
</h3> <p>Returns value of the current simple type.</p> <p>This function does not perform any type conversions, including from integer. Therefore, it may only be called if <a href="qcborstreamreader#isSimpleType">isSimpleType</a>() is true; calling it in any other condition is an error.</p> <p><b>See also </b><a href="qcborstreamreader#isSimpleType">isSimpleType</a>(), <a href="qcborstreamreader#isTrue">isTrue</a>(), <a href="qcborstreamreader#isFalse">isFalse</a>(), <a href="qcborstreamreader#isBool">isBool</a>(), <a href="qcborstreamreader#isNull">isNull</a>(), and <a href="qcborstreamreader#isUndefined">isUndefined</a>().</p>   <h3 class="fn" id="toTag">
<span class="type"><a href="qtcborcommon#QCborTag-enum">QCborTag</a></span> QCborStreamReader::<span class="name">toTag</span>() const
</h3> <p>Returns the tag value of the current element.</p> <p>This function does not perform any type conversions, including from integer. Therefore, it may only be called if <a href="qcborstreamreader#isTag">isTag</a>() is true; calling it in any other condition is an error.</p> <p>Tags are 64-bit numbers attached to generic CBOR types that give them further meaning. For a list of known tags, see the <a href="qtcborcommon#QCborKnownTags-enum">QCborKnownTags</a> enumeration.</p> <p><b>See also </b><a href="qcborstreamreader#isTag">isTag</a>(), <a href="qcborstreamreader#toInteger">toInteger</a>(), and <a href="qtcborcommon#QCborKnownTags-enum">QCborKnownTags</a>.</p>   <h3 class="fn" id="toUnsignedInteger">
<span class="type"><a href="qtglobal#quint64-typedef">quint64</a></span> QCborStreamReader::<span class="name">toUnsignedInteger</span>() const
</h3> <p>Returns the unsigned integer value of the current element.</p> <p>This function does not perform any type conversions, including from boolean or CBOR tag. Therefore, it may only be called if <a href="qcborstreamreader#isUnsignedInteger">isUnsignedInteger</a>() is true; calling it in any other condition is an error.</p> <p>This function may be used to obtain numbers beyond the range of the return type of <a href="qcborstreamreader#toInteger">toInteger</a>().</p> <p><b>See also </b><a href="qcborstreamreader#type">type</a>(), <a href="qcborstreamreader#toInteger">toInteger</a>(), <a href="qcborstreamreader#isUnsignedInteger">isUnsignedInteger</a>(), and <a href="qcborstreamreader#isNegativeInteger">isNegativeInteger</a>().</p>   <h3 class="fn" id="type">
<span class="type"><a href="qcborstreamreader#Type-enum">QCborStreamReader::Type</a></span> QCborStreamReader::<span class="name">type</span>() const
</h3> <p>Returns the type of the current element. It is one of the valid types or Invalid.</p> <p><b>See also </b><a href="qcborstreamreader#isValid">isValid</a>(), <a href="qcborstreamreader#isUnsignedInteger">isUnsignedInteger</a>(), <a href="qcborstreamreader#isNegativeInteger">isNegativeInteger</a>(), <a href="qcborstreamreader#isInteger">isInteger</a>(), <a href="qcborstreamreader#isByteArray">isByteArray</a>(), <a href="qcborstreamreader#isString">isString</a>(), <a href="qcborstreamreader#isArray">isArray</a>(), <a href="qcborstreamreader#isMap">isMap</a>(), <a href="qcborstreamreader#isTag">isTag</a>(), <a href="qcborstreamreader#isSimpleType">isSimpleType</a>(), <a href="qcborstreamreader#isBool">isBool</a>(), <a href="qcborstreamreader#isFalse">isFalse</a>(), <a href="qcborstreamreader#isTrue">isTrue</a>(), <a href="qcborstreamreader#isNull">isNull</a>(), <a href="qcborstreamreader#isUndefined">isUndefined</a>(), <a href="qcborstreamreader#isFloat16">isFloat16</a>(), <a href="qcborstreamreader#isFloat">isFloat</a>(), and <a href="qcborstreamreader#isDouble">isDouble</a>().</p>
<div class="_attribution">
  <p class="_attribution-p">
    Â© The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-5.15/qcborstreamreader.html" class="_attribution-link">https://doc.qt.io/qt-5.15/qcborstreamreader.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
