
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>QXmlQuery (Class) - Qt 5.15 - W3cubDocs</title>
  
  <meta name="description" content=" The QXmlQuery class performs XQueries on XML data, or on non-XML data modeled to look like XML. More... ">
  <meta name="keywords" content="qxmlquery, class, qt, qt~5.15">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/qt~5.15/qxmlquery.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/qt~5.15.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt~5.15/" class="_nav-link" title="" style="margin-left:0;">Qt 5.15</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">QXmlQuery Class</h1>  <p>The QXmlQuery class performs XQueries on XML data, or on non-XML data modeled to look like XML. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QXmlQuery&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += xmlpatterns</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 4.4</td>
</tr>
</table>
<p>This class was introduced in Qt 4.4.</p> <ul> <li><a href="https://doc.qt.io/qt-5.15/qxmlquery-members.html">List of all members, including inherited members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="threads-reentrancy">reentrant</a>.</p>  <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#QueryLanguage-enum">QueryLanguage</a></b> { XQuery10, XSLT20 }</td>
</tr> </table>  <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#QXmlQuery-3">QXmlQuery</a></b>(QXmlQuery::QueryLanguage <i>queryLanguage</i>, const QXmlNamePool &amp;<i>np</i> = QXmlNamePool())</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#QXmlQuery-2">QXmlQuery</a></b>(const QXmlNamePool &amp;<i>np</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#QXmlQuery-1">QXmlQuery</a></b>(const QXmlQuery &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#QXmlQuery">QXmlQuery</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QXmlQuery &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#operator-eq">operator=</a></b>(const QXmlQuery &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#dtor.QXmlQuery">~QXmlQuery</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#bindVariable">bindVariable</a></b>(const QXmlName &amp;<i>name</i>, const QXmlItem &amp;<i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#bindVariable-1">bindVariable</a></b>(const QString &amp;<i>localName</i>, const QXmlItem &amp;<i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#bindVariable-2">bindVariable</a></b>(const QXmlName &amp;<i>name</i>, QIODevice *<i>device</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#bindVariable-3">bindVariable</a></b>(const QString &amp;<i>localName</i>, QIODevice *<i>device</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#bindVariable-4">bindVariable</a></b>(const QXmlName &amp;<i>name</i>, const QXmlQuery &amp;<i>query</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#bindVariable-5">bindVariable</a></b>(const QString &amp;<i>localName</i>, const QXmlQuery &amp;<i>query</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#evaluateTo">evaluateTo</a></b>(QXmlResultItems *<i>result</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#evaluateTo-1">evaluateTo</a></b>(QAbstractXmlReceiver *<i>callback</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#evaluateTo-2">evaluateTo</a></b>(QStringList *<i>target</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#evaluateTo-3">evaluateTo</a></b>(QIODevice *<i>target</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#evaluateTo-4">evaluateTo</a></b>(QString *<i>output</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QXmlName </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#initialTemplateName">initialTemplateName</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#isValid">isValid</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QAbstractMessageHandler *</td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#messageHandler">messageHandler</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QXmlNamePool </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#namePool">namePool</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QNetworkAccessManager *</td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#networkAccessManager">networkAccessManager</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QXmlQuery::QueryLanguage </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#queryLanguage">queryLanguage</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#setFocus">setFocus</a></b>(const QXmlItem &amp;<i>item</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#setFocus-1">setFocus</a></b>(const QUrl &amp;<i>documentURI</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#setFocus-2">setFocus</a></b>(QIODevice *<i>document</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#setFocus-3">setFocus</a></b>(const QString &amp;<i>focus</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#setInitialTemplateName">setInitialTemplateName</a></b>(const QXmlName &amp;<i>name</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#setInitialTemplateName-1">setInitialTemplateName</a></b>(const QString &amp;<i>localName</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#setMessageHandler">setMessageHandler</a></b>(QAbstractMessageHandler *<i>aMessageHandler</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#setNetworkAccessManager">setNetworkAccessManager</a></b>(QNetworkAccessManager *<i>newManager</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#setQuery">setQuery</a></b>(QIODevice *<i>sourceCode</i>, const QUrl &amp;<i>documentURI</i> = QUrl())</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#setQuery-1">setQuery</a></b>(const QString &amp;<i>sourceCode</i>, const QUrl &amp;<i>documentURI</i> = QUrl())</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#setQuery-2">setQuery</a></b>(const QUrl &amp;<i>queryURI</i>, const QUrl &amp;<i>baseURI</i> = QUrl())</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#setUriResolver">setUriResolver</a></b>(const QAbstractUriResolver *<i>resolver</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const QAbstractUriResolver *</td>
<td class="memItemRight bottomAlign">
<b><a href="qxmlquery#uriResolver">uriResolver</a></b>() const</td>
</tr> </table>    <h2 id="details">Detailed Description
</h2> <p>The QXmlQuery class compiles and executes queries written in the <a href="http://www.w3.org/TR/xquery/">XQuery language</a>. QXmlQuery is typically used to query XML data, but it can also query non-XML data that has been modeled to look like XML.</p> <p>Using QXmlQuery to query XML data, as in the snippet below, is simple because it can use the built-in <a href="qabstractxmlnodemodel">XML data model</a> as its delegate to the underlying query engine for traversing the data. The built-in data model is specified in <a href="http://www.w3.org/TR/xpath-datamodel/">XQuery 1.0 and XPath 2.0 Data Model</a>.</p> <pre data-language="cpp">QXmlQuery query;
query.setQuery("doc('index.html')/html/body/p[1]");

QXmlSerializer serializer(query, myOutputDevice);
query.evaluateTo(&amp;serializer);</pre> <p>The example uses QXmlQuery to match the first paragraph of an XML document and then <a href="qxmlserializer">output the result</a> to a device as XML.</p> <p>Using QXmlQuery to query <i>non-XML</i> data requires writing a subclass of <a href="qabstractxmlnodemodel">QAbstractXmlNodeModel</a> to use as a replacement for the built-in XML data model. The custom data model will be able to traverse the non-XML data as required by the <a href="qabstractxmlnodemodel">QAbstractXmlNodeModel</a> interface. An instance of this custom data model then becomes the delegate used by the query engine to traverse the non-XML data. For an example of how to use QXmlQuery to query non-XML data, see the documentation for <a href="qabstractxmlnodemodel">QAbstractXmlNodeModel</a>.</p>  <h3 id="running-xqueries">Running XQueries
</h3> <p>To run a query set up with QXmlQuery, call one of the evaluation functions.</p> <ul> <li>
<a href="qxmlquery#evaluateTo">evaluateTo</a>(<a href="qabstractxmlreceiver">QAbstractXmlReceiver</a> *) is called with a pointer to an XML <a href="qabstractxmlreceiver">receiver</a>, which receives the query results as a sequence of callbacks. The receiver callback class is like the callback class used for translating the output of a SAX parser. <a href="qxmlserializer">QXmlSerializer</a>, for example, is a receiver callback class for translating the sequence of callbacks for output as unformatted XML text.</li> </ul> <ul> <li>
<a href="qxmlquery#evaluateTo">evaluateTo</a>(<a href="qxmlresultitems">QXmlResultItems</a> *) is called with a pointer to an iterator for an empty sequence of query <a href="qxmlresultitems">result items</a>. The Java-like iterator allows the query results to be accessed sequentially.</li> </ul> <ul> <li>
<a href="qxmlquery#evaluateTo">evaluateTo</a>(<a href="qstringlist">QStringList</a> *) is like <a href="qxmlquery#evaluateTo">evaluateTo</a>(<a href="qxmlresultitems">QXmlResultItems</a> *), but the query must evaluate to a sequence of strings.</li> </ul>  <h3 id="running-xpath-expressions">Running XPath Expressions
</h3> <p>The XPath language is a subset of the <a href="xmlprocessing">XQuery</a> language, so running an XPath expression is the same as running an <a href="xmlprocessing">XQuery</a> query. Pass the XPath expression to QXmlQuery using <a href="qxmlquery#setQuery">setQuery</a>().</p>  <h3 id="running-xslt-stylesheets">Running XSLT Stylesheets
</h3> <p>Running an XSLT stylesheet is like running an <a href="xmlprocessing">XQuery</a>, except that when you construct your QXmlQuery, you must pass <a href="qxmlquery#QueryLanguage-enum">QXmlQuery::XSLT20</a> to tell QXmlQuery to interpret whatever it gets from <a href="qxmlquery#setQuery">setQuery</a>() as an XSLT stylesheet instead of as an <a href="xmlprocessing">XQuery</a>. You must also set the input document by calling <a href="qxmlquery#setFocus">setFocus</a>().</p> <pre data-language="cpp">    QXmlQuery query(QXmlQuery::XSLT20);
    query.setFocus(QUrl("myInput.xml"));
    query.setQuery(QUrl("myStylesheet.xsl"));
    query.evaluateTo(out);</pre> <p><b>Note: </b>Currently, <a href="qxmlquery#setFocus">setFocus</a>() must be called <i>before</i> <a href="qxmlquery#setQuery">setQuery</a>() when using XSLT.</p> <p>Another way to run an XSLT stylesheet is to use the <code>xmlpatterns</code> command line utility.</p> <pre data-language="cpp">xmlpatterns myStylesheet.xsl myInput.xml</pre> <p><b>Note: </b>For the current release, XSLT support should be considered experimental. See section <a href="xmlprocessing#xslt-2-0">XSLT conformance</a> for details.</p> <p>Stylesheet parameters are bound using <a href="qxmlquery#bindVariable">bindVariable</a>().</p>  <h3 id="binding-a-query-to-a-starting-node">Binding A Query To A Starting Node
</h3> <p>When a query is run on XML data, as in the snippet above, the <code>doc()</code> function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the <a href="qxmlquery#bindVariable">bindVariable</a>() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the <a href="xmlprocessing">XQuery</a> text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for <a href="qabstractxmlnodemodel">QAbstractXmlNodeModel</a>.</p>  <h3 id="reentrancy-and-thread-safety">Reentrancy and Thread-Safety
</h3> <p>QXmlQuery is reentrant but not thread-safe. It is safe to use the QxmlQuery copy constructor to create a copy of a query and run the same query multiple times. Behind the scenes, QXmlQuery will reuse resources such as opened files and compiled queries to the extent possible. But it is not safe to use the same instance of QXmlQuery in multiple threads.</p>  <h3 id="error-handling">Error Handling
</h3> <p>Errors can occur during query evaluation. Examples include type errors and file loading errors. When an error occurs:</p> <ul> <li>The error message is sent to the <a href="qxmlquery#messageHandler">messageHandler</a>().</li> <li>
<a href="qxmlresultitems#hasError">QXmlResultItems::hasError</a>() will return <code>true</code>, or <a href="qxmlquery#evaluateTo">evaluateTo</a>() will return <code>false</code>;</li> <li>The results of the evaluation are undefined.</li> </ul>  <h3 id="resource-management">Resource Management
</h3> <p>When a query runs, it parses documents, allocating internal data structures to hold them, and it may load other resources over the network. It reuses these allocated resources when possible, to avoid having to reload and reparse them.</p> <p>When <a href="qxmlquery#setQuery">setQuery</a>() is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of QXmlQuery for each query text.</p> <p>Once a document has been parsed, its internal representation is maintained in the QXmlQuery instance and shared among multiple QXmlQuery instances.</p> <p>An instance of <a href="qcoreapplication">QCoreApplication</a> must exist before QXmlQuery can be used.</p>  <h3 id="event-handling">Event Handling
</h3> <p>When QXmlQuery accesses resources (e.g., calling <code>fn:doc()</code> to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when QXmlQuery accesses resources, create your QXmlQuery instance in a separate thread.</p>    <h2>Member Type Documentation</h2>  <h3 class="fn" id="QueryLanguage-enum">
enum QXmlQuery::<span class="name">QueryLanguage</span>
</h3> <p>Specifies whether you want <a href="qxmlquery">QXmlQuery</a> to interpret the input to <a href="qxmlquery#setQuery">setQuery</a>() as an <a href="xmlprocessing">XQuery</a> or as an XSLT stylesheet.</p> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QXmlQuery::XQuery10</code></td>
<td class="topAlign tblval"><code>1</code></td>
<td class="topAlign">
<a href="xmlprocessing">XQuery</a> 1.0.</td>
</tr> <tr>
<td class="topAlign"><code>QXmlQuery::XSLT20</code></td>
<td class="topAlign tblval"><code>2</code></td>
<td class="topAlign">XSLT 2.0 The selector, the restricted XPath pattern found in W3C XML Schema 1.1 for uniqueness contraints. Apart from restricting the syntax, the type check stage for the expression assumes a sequence of nodes to be the focus. The field, the restricted XPath pattern found in W3C XML Schema 1.1 for uniqueness contraints. Apart from restricting the syntax, the type check stage for the expression assumes a sequence of nodes to be the focus. Signifies XPath 2.0. Has no effect in the public API, it's used internally. As With XmlSchema11IdentityConstraintSelector and XmlSchema11IdentityConstraintField, the type check stage for the expression assumes a sequence of nodes to be the focus.</td>
</tr> </table> <p>This enum was introduced or modified in Qt 4.5.</p> <p><b>See also </b><a href="qxmlquery#setQuery">setQuery</a>().</p>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="QXmlQuery-3">
QXmlQuery::<span class="name">QXmlQuery</span>(<span class="type"><a href="qxmlquery#QueryLanguage-enum">QXmlQuery::QueryLanguage</a></span> <i>queryLanguage</i>, const <span class="type"><a href="qxmlnamepool">QXmlNamePool</a></span> &amp;<i>np</i> = QXmlNamePool())
</h3> <p>Constructs a query that will be used to run Xqueries or XSL-T stylesheets, depending on the value of <i>queryLanguage</i>. It will use <i>np</i> as its name pool.</p> <p><b>Note: </b>If your QXmlQuery will process XSL-T stylesheets, this constructor must be used. The default constructor can only create instances of QXmlQuery for running XQueries.</p> <p><b>Note: </b>The XSL-T support in this release is considered experimental. See the <a href="xmlprocessing#xslt-2-0">XSLT conformance</a> for details.</p> <p>This function was introduced in Qt 4.5.</p> <p><b>See also </b><a href="qxmlquery#queryLanguage">queryLanguage</a>().</p>   <h3 class="fn" id="QXmlQuery-2">
QXmlQuery::<span class="name">QXmlQuery</span>(const <span class="type"><a href="qxmlnamepool">QXmlNamePool</a></span> &amp;<i>np</i>)
</h3> <p>Constructs a query that will use <i>np</i> as its name pool. The query cannot be evaluated until <a href="qxmlquery#setQuery">setQuery</a>() has been called.</p>   <h3 class="fn" id="QXmlQuery-1">
QXmlQuery::<span class="name">QXmlQuery</span>(const <span class="type"><a href="qxmlquery#QXmlQuery">QXmlQuery</a></span> &amp;<i>other</i>)
</h3> <p>Constructs a QXmlQuery that is a copy of <i>other</i>. The new instance will share resources with the existing query to the extent possible.</p>   <h3 class="fn" id="QXmlQuery">
QXmlQuery::<span class="name">QXmlQuery</span>()
</h3> <p>Constructs an invalid, empty query that cannot be used until <a href="qxmlquery#setQuery">setQuery</a>() is called.</p> <p><b>Note: </b>This constructor must not be used if you intend to use this QXmlQuery to process XSL-T stylesheets. The other constructor must be used in that case.</p>   <h3 class="fn" id="operator-eq">
<span class="type"><a href="qxmlquery#QXmlQuery">QXmlQuery</a></span> &amp;QXmlQuery::<span class="name">operator=</span>(const <span class="type"><a href="qxmlquery#QXmlQuery">QXmlQuery</a></span> &amp;<i>other</i>)
</h3> <p>Assigns <i>other</i> to this <a href="qxmlquery">QXmlQuery</a> instance.</p>   <h3 class="fn" id="dtor.QXmlQuery">
QXmlQuery::<span class="name">~QXmlQuery</span>()
</h3> <p>Destroys this <a href="qxmlquery">QXmlQuery</a>.</p>   <h3 class="fn" id="bindVariable">
<span class="type">void</span> QXmlQuery::<span class="name">bindVariable</span>(const <span class="type"><a href="qxmlname">QXmlName</a></span> &amp;<i>name</i>, const <span class="type"><a href="qxmlitem">QXmlItem</a></span> &amp;<i>value</i>)
</h3> <p>Binds the variable <i>name</i> to the <i>value</i> so that $<i>name</i> can be used from within the query to refer to the <i>value</i>.</p> <p><i>name</i> must not be <i>null</i>. <i>name</i>.isNull() must return false. If <i>name</i> has already been bound by a previous bindVariable() call, its previous binding will be overridden.</p> <p>If <i>value</i> is null so that <i>value</i>.isNull() returns true, and <i>name</i> already has a binding, the effect is to remove the existing binding for <i>name</i>.</p> <p>To bind a value of type <a href="qstring">QString</a> or <a href="qurl">QUrl</a>, wrap the value in a <a href="qvariant">QVariant</a> such that <a href="qxmlitem">QXmlItem</a>'s <a href="qvariant">QVariant</a> constructor is called.</p> <p>All strings processed by the query must be valid <a href="xmlprocessing">XQuery</a> strings, which means they must contain only XML 1.0 characters. However, this requirement is not checked. If the query processes an invalid string, the behavior is undefined.</p> <p><b>See also </b><a href="qvariant#isValid">QVariant::isValid</a>(), <a href="xmlprocessing#qtxdm">How QVariant maps to XQuery's Data Model</a>, and <a href="qxmlitem#isNull">QXmlItem::isNull</a>().</p>   <h3 class="fn" id="bindVariable-1">
<span class="type">void</span> QXmlQuery::<span class="name">bindVariable</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>localName</i>, const <span class="type"><a href="qxmlitem">QXmlItem</a></span> &amp;<i>value</i>)
</h3> <p>This is an overloaded function.</p> <p>This function constructs a <a href="qxmlname">QXmlName</a> from <i>localName</i> using the query's <a href="qxmlnamepool">namespace</a>. The function then behaves as the overloaded function. It is equivalent to the following snippet.</p> <pre data-language="cpp">    QXmlNamePool namePool(query.namePool());
    query.bindVariable(QXmlName(namePool, localName), value);</pre>   <h3 class="fn" id="bindVariable-2">
<span class="type">void</span> QXmlQuery::<span class="name">bindVariable</span>(const <span class="type"><a href="qxmlname">QXmlName</a></span> &amp;<i>name</i>, <span class="type"><a href="qiodevice">QIODevice</a></span> *<i>device</i>)
</h3> <p>Binds the variable <i>name</i> to the <i>device</i> so that $<i>name</i> can be used from within the query to refer to the <i>device</i>. The <a href="qiodevice">QIODevice</a> <i>device</i> is exposed to the query as a URI of type <code>xs:anyURI</code>, which can be passed to the <code>fn:doc()</code> function to be read. E.g., this function can be used to pass an XML document in memory to <code>fn:doc</code>.</p> <pre data-language="cpp">    QByteArray myDocument;
    QBuffer buffer(&amp;myDocument); // This is a QIODevice.
    buffer.open(QIODevice::ReadOnly);
    QXmlQuery query;
    query.bindVariable("myDocument", &amp;buffer);
    query.setQuery("doc($myDocument)");</pre> <p>The caller must ensure that <i>device</i> has been opened with at least <a href="qiodevice#OpenModeFlag-enum">QIODevice::ReadOnly</a> prior to this binding. Otherwise, behavior is undefined.</p> <p>If the query will access an XML document contained in a <a href="qstring">QString</a>, use a <a href="qbuffer">QBuffer</a> as shown in the following snippet. Suppose <i>myQString</i> contains <code>&lt;document&gt;content&lt;/document&gt;</code></p> <pre data-language="cpp">    QBuffer device;
    device.setData(myQString.toUtf8());
    device.open(QIODevice::ReadOnly);

    QXmlQuery query;
    query.setQuery("doc($inputDocument)/query[theDocument]");
    query.bindVariable("inputDocument", &amp;device);</pre> <p><i>name</i> must not be <i>null</i>. <i>name</i>.isNull() must return false. If <i>name</i> has already been bound, its previous binding will be overridden. The URI that <i>name</i> evaluates to is arbitrary and may change.</p> <p>If the type of the variable binding changes (e.g., if a previous binding by the same name was a <a href="qvariant">QVariant</a>, or if there was no previous binding), <a href="qxmlquery#isValid">isValid</a>() will return <code>false</code>, and recompilation of the query text is required. To recompile the query, call <a href="qxmlquery#setQuery">setQuery</a>(). For this reason, bindVariable() should be called before <a href="qxmlquery#setQuery">setQuery</a>(), if possible.</p> <p><b>Note: </b><i>device</i> must not be deleted while this <a href="qxmlquery">QXmlQuery</a> exists.</p>   <h3 class="fn" id="bindVariable-3">
<span class="type">void</span> QXmlQuery::<span class="name">bindVariable</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>localName</i>, <span class="type"><a href="qiodevice">QIODevice</a></span> *<i>device</i>)
</h3> <p>This is an overloaded function.</p> <p>If <i>localName</i> is a valid <a href="qxmlname#isNCName">NCName</a>, this function is equivalent to the following snippet.</p> <pre data-language="cpp">    QXmlNamePool namePool(query.namePool());
    query.bindVariable(QXmlName(namePool, localName), device);</pre> <p>A <a href="qxmlname">QXmlName</a> is constructed from <i>localName</i>, and is passed to the appropriate overload along with <i>device</i>.</p> <p><b>See also </b><a href="qxmlname#isNCName">QXmlName::isNCName</a>().</p>   <h3 class="fn" id="bindVariable-4">
<span class="type">void</span> QXmlQuery::<span class="name">bindVariable</span>(const <span class="type"><a href="qxmlname">QXmlName</a></span> &amp;<i>name</i>, const <span class="type"><a href="qxmlquery#QXmlQuery">QXmlQuery</a></span> &amp;<i>query</i>)
</h3> <p>Binds the result of the query <i>query</i>, to a variable by name <i>name</i>.</p> <p>Evaluation of <i>query</i> will be commenced when this function is called.</p> <p>If <i>query</i> is invalid, behavior is undefined. <i>query</i> will be copied.</p> <p>This function was introduced in Qt 4.5.</p> <p><b>See also </b><a href="qxmlquery#isValid">isValid</a>().</p>   <h3 class="fn" id="bindVariable-5">
<span class="type">void</span> QXmlQuery::<span class="name">bindVariable</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>localName</i>, const <span class="type"><a href="qxmlquery#QXmlQuery">QXmlQuery</a></span> &amp;<i>query</i>)
</h3> <p>This is an overloaded function.</p> <p>Has the same behavior and effects as the function being overloaded, but takes the variable name <i>localName</i> as a <a href="qstring">QString</a>. <i>query</i> is used as in the overloaded function.</p> <p>This function was introduced in Qt 4.5.</p>   <h3 class="fn" id="evaluateTo">
<span class="type">void</span> QXmlQuery::<span class="name">evaluateTo</span>(<span class="type"><a href="qxmlresultitems">QXmlResultItems</a></span> *<i>result</i>) const
</h3> <p>Starts the evaluation and makes it available in <i>result</i>. If <i>result</i> is null, the behavior is undefined. The evaluation takes place incrementally (lazy evaluation), as the caller uses <a href="qxmlresultitems#next">QXmlResultItems::next</a>() to get the next result.</p> <p><b>See also </b><a href="qxmlresultitems#next">QXmlResultItems::next</a>().</p>   <h3 class="fn" id="evaluateTo-1">
<span class="type">bool</span> QXmlQuery::<span class="name">evaluateTo</span>(<span class="type"><a href="qabstractxmlreceiver">QAbstractXmlReceiver</a></span> *<i>callback</i>) const
</h3> <p>Evaluates this query and sends the result as a sequence of callbacks to the <a href="qabstractxmlreceiver">receiver</a> <i>callback</i>. <a href="qxmlquery">QXmlQuery</a> does not take ownership of <i>callback</i>.</p> <p>If an error occurs during the evaluation, error messages are sent to <a href="qxmlquery#messageHandler">messageHandler</a>() and <code>false</code> is returned.</p> <p>If this query <a href="qxmlquery#isValid">is invalid</a>, <code>false</code> is returned and the behavior is undefined. If <i>callback</i> is null, behavior is undefined.</p> <p><b>See also </b><a href="qabstractxmlreceiver">QAbstractXmlReceiver</a> and <a href="qxmlquery#isValid">isValid</a>().</p>   <h3 class="fn" id="evaluateTo-2">
<span class="type">bool</span> QXmlQuery::<span class="name">evaluateTo</span>(<span class="type"><a href="qstringlist">QStringList</a></span> *<i>target</i>) const
</h3> <p>Attempts to evaluate the query and returns the results in the <i>target</i> <a href="qstringlist">string list</a>.</p> <p>If the query <a href="qxmlquery#isValid">is valid</a> and the evaluation succeeds, true is returned. Otherwise, false is returned and the contents of <i>target</i> are undefined.</p> <p>The query must evaluate to a sequence of <code>xs:string</code> values. If the query does not evaluate to a sequence of strings, the values can often be converted by adding a call to <code>string()</code> at the end of the <a href="xmlprocessing">XQuery</a>.</p> <p>If <i>target</i> is null, the behavior is undefined.</p>   <h3 class="fn" id="evaluateTo-3">
<span class="type">bool</span> QXmlQuery::<span class="name">evaluateTo</span>(<span class="type"><a href="qiodevice">QIODevice</a></span> *<i>target</i>) const
</h3> <p>Evaluates the query or stylesheet, and writes the output to <i>target</i>.</p> <p><a href="qxmlserializer">QXmlSerializer</a> is used to write the output to <i>target</i>. In a future release, it is expected that this function will be changed to respect serialization options set in the stylesheet.</p> <p>If an error occurs during the evaluation, error messages are sent to <a href="qxmlquery#messageHandler">messageHandler</a>() and <code>false</code> is returned.</p> <p>If <i>target</i> is <code>null</code>, or is not opened in at least <a href="qiodevice#OpenModeFlag-enum">QIODevice::WriteOnly</a> mode, the behavior is undefined. <a href="qxmlquery">QXmlQuery</a> does not take ownership of <i>target</i>.</p> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 4.5.</p>   <h3 class="fn" id="evaluateTo-4">
<span class="type">bool</span> QXmlQuery::<span class="name">evaluateTo</span>(<span class="type"><a href="qstring">QString</a></span> *<i>output</i>) const
</h3> <p>Evaluates the query, and serializes the output as XML to <i>output</i>.</p> <p>If an error occurs during the evaluation, error messages are sent to <a href="qxmlquery#messageHandler">messageHandler</a>(), the content of <i>output</i> is undefined and <code>false</code> is returned, otherwise <code>true</code> is returned.</p> <p>If <i>output</i> is <code>null</code> behavior is undefined. <a href="qxmlquery">QXmlQuery</a> does not take ownership of <i>output</i>.</p> <p>Internally, the class <a href="qxmlformatter">QXmlFormatter</a> is used for this.</p> <p>This function was introduced in Qt 4.5.</p>   <h3 class="fn" id="initialTemplateName">
<span class="type"><a href="qxmlname">QXmlName</a></span> QXmlQuery::<span class="name">initialTemplateName</span>() const
</h3> <p>Returns the name of the XSL-T stylesheet template that the processor will call first when running an XSL-T stylesheet. This function only applies when using <a href="qxmlquery">QXmlQuery</a> to process XSL-T stylesheets. By default, no initial template is set. In that case, a default constructed <a href="qxmlname">QXmlName</a> is returned.</p> <p>This function was introduced in Qt 4.5.</p> <p><b>See also </b><a href="qxmlquery#setInitialTemplateName">setInitialTemplateName</a>().</p>   <h3 class="fn" id="isValid">
<span class="type">bool</span> QXmlQuery::<span class="name">isValid</span>() const
</h3> <p>Returns true if this query is valid. Examples of invalid queries are ones that contain syntax errors or that have not had <a href="qxmlquery#setQuery">setQuery</a>() called for them yet.</p>   <h3 class="fn" id="messageHandler">
<span class="type"><a href="qabstractmessagehandler">QAbstractMessageHandler</a></span> *QXmlQuery::<span class="name">messageHandler</span>() const
</h3> <p>Returns the message handler that handles compile and runtime messages for this <a href="qxmlquery">QXmlQuery</a>.</p> <p><b>See also </b><a href="qxmlquery#setMessageHandler">setMessageHandler</a>().</p>   <h3 class="fn" id="namePool">
<span class="type"><a href="qxmlnamepool">QXmlNamePool</a></span> QXmlQuery::<span class="name">namePool</span>() const
</h3> <p>Returns the name pool used by this <a href="qxmlquery">QXmlQuery</a> for constructing <a href="qxmlname">names</a>. There is no setter for the name pool, because mixing name pools causes errors due to name confusion.</p>   <h3 class="fn" id="networkAccessManager">
<span class="type">QNetworkAccessManager</span> *QXmlQuery::<span class="name">networkAccessManager</span>() const
</h3> <p>Returns the network manager, or 0 if it has not been set.</p> <p>This function was introduced in Qt 4.5.</p> <p><b>See also </b><a href="qxmlquery#setNetworkAccessManager">setNetworkAccessManager</a>().</p>   <h3 class="fn" id="queryLanguage">
<span class="type"><a href="qxmlquery#QueryLanguage-enum">QXmlQuery::QueryLanguage</a></span> QXmlQuery::<span class="name">queryLanguage</span>() const
</h3> <p>Returns a value indicating what this <a href="qxmlquery">QXmlQuery</a> is being used for. The default is <a href="qxmlquery#QueryLanguage-enum">QXmlQuery::XQuery10</a>, which means the <a href="qxmlquery">QXmlQuery</a> is being used for running <a href="xmlprocessing">XQuery</a> and XPath queries. <a href="qxmlquery#QueryLanguage-enum">QXmlQuery::XSLT20</a> can also be returned, which indicates the <a href="qxmlquery">QXmlQuery</a> is for running XSL-T spreadsheets.</p> <p>This function was introduced in Qt 4.5.</p>   <h3 class="fn" id="setFocus">
<span class="type">void</span> QXmlQuery::<span class="name">setFocus</span>(const <span class="type"><a href="qxmlitem">QXmlItem</a></span> &amp;<i>item</i>)
</h3> <p>Sets the focus to <i>item</i>. The focus is the set of items that the context item expression and path expressions navigate from. For example, in the expression <i>p/span</i>, the element that <i>p</i> evaluates to is the focus for the following expression, <i>span</i>.</p> <p>The focus can be accessed using the context item expression, i.e., dot (".").</p> <p>By default, the focus is not set and is undefined. It will therefore result in a dynamic error, <code>XPDY0002</code>, if the focus is attempted to be accessed. The focus must be set before the query is set with <a href="qxmlquery#setQuery">setQuery</a>().</p> <p>There is no behavior defined for setting an item which is null.</p>   <h3 class="fn" id="setFocus-1">
<span class="type">bool</span> QXmlQuery::<span class="name">setFocus</span>(const <span class="type"><a href="qurl">QUrl</a></span> &amp;<i>documentURI</i>)
</h3> <p>This is an overloaded function.</p> <p>Sets the focus to be the document located at <i>documentURI</i> and returns true. If <i>documentURI</i> cannot be loaded, false is returned. It is undefined at what time the document may be loaded. When loading the document, the message handler and URI resolver set on this <a href="qxmlquery">QXmlQuery</a> are used.</p> <p>If <i>documentURI</i> is empty or is not a valid URI, the behavior of this function is undefined.</p> <p>This function was introduced in Qt 4.5.</p>   <h3 class="fn" id="setFocus-2">
<span class="type">bool</span> QXmlQuery::<span class="name">setFocus</span>(<span class="type"><a href="qiodevice">QIODevice</a></span> *<i>document</i>)
</h3> <p>Sets the focus to be the <i>document</i> read from the <a href="qiodevice">QIODevice</a> and returns true. If <i>document</i> cannot be loaded, false is returned.</p> <p><a href="qxmlquery">QXmlQuery</a> does not take ownership of <i>document</i>. The user guarantees that a document is available from the <i>document</i> device and that the document is not empty. The device must be opened in at least read-only mode. <i>document</i> must stay in scope as long as the current query is active.</p> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 4.5.</p>   <h3 class="fn" id="setFocus-3">
<span class="type">bool</span> QXmlQuery::<span class="name">setFocus</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>focus</i>)
</h3> <p>This function behaves identically to calling the setFocus() overload with a <a href="qiodevice">QIODevice</a> whose content is <i>focus</i> encoded as UTF-8. That is, <i>focus</i> is treated as if it contained an XML document.</p> <p>Returns the same result as the overload.</p> <p>This is an overloaded function.</p> <p>This function was introduced in Qt 4.6.</p>   <h3 class="fn" id="setInitialTemplateName">
<span class="type">void</span> QXmlQuery::<span class="name">setInitialTemplateName</span>(const <span class="type"><a href="qxmlname">QXmlName</a></span> &amp;<i>name</i>)
</h3> <p>Sets the <i>name</i> of the initial template. The initial template is the one the processor calls first, instead of attempting to match a template to the context node (if any). If an initial template is not set, the standard order of template invocation will be used.</p> <p>This function only applies when using <a href="qxmlquery">QXmlQuery</a> to process XSL-T stylesheets. The name becomes part of the compiled stylesheet. Therefore, this function must be called before calling <a href="qxmlquery#setQuery">setQuery</a>().</p> <p>If the stylesheet has no template named <i>name</i>, the processor will use the standard order of template invocation.</p> <p>This function was introduced in Qt 4.5.</p> <p><b>See also </b><a href="qxmlquery#initialTemplateName">initialTemplateName</a>().</p>   <h3 class="fn" id="setInitialTemplateName-1">
<span class="type">void</span> QXmlQuery::<span class="name">setInitialTemplateName</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>localName</i>)
</h3> <p>This is an overloaded function.</p> <p>Sets the name of the initial template to <i>localName</i>, which must be a valid <a href="qxmlname#localName">local name</a>. The initial template is the one the processor calls first, instead of attempting to match a template to the context node (if any). If an initial template is not set, the standard order of template invocation will be used.</p> <p>This function only applies when using <a href="qxmlquery">QXmlQuery</a> to process XSL-T stylesheets. The name becomes part of the compiled stylesheet. Therefore, this function must be called before calling <a href="qxmlquery#setQuery">setQuery</a>().</p> <p>If <i>localName</i> is not a valid <a href="qxmlname#localName">local name</a>, the effect is undefined. If the stylesheet has no template named <i>localName</i>, the processor will use the standard order of template invocation.</p> <p>This function was introduced in Qt 4.5.</p> <p><b>See also </b><a href="qxmlquery#initialTemplateName">initialTemplateName</a>().</p>   <h3 class="fn" id="setMessageHandler">
<span class="type">void</span> QXmlQuery::<span class="name">setMessageHandler</span>(<span class="type"><a href="qabstractmessagehandler">QAbstractMessageHandler</a></span> *<i>aMessageHandler</i>)
</h3> <p>Changes the <a href="qabstractmessagehandler">message handler</a> for this <a href="qxmlquery">QXmlQuery</a> to <i>aMessageHandler</i>. The query sends all compile and runtime messages to this message handler. <a href="qxmlquery">QXmlQuery</a> does not take ownership of <i>aMessageHandler</i>.</p> <p>Normally, the default message handler is sufficient. It writes compile and runtime messages to <i>stderr</i>. The default message handler includes color codes if <i>stderr</i> can render colors.</p> <p>Note that changing the message handler after the query has been compiled has no effect, i.e. the query uses the same message handler at runtime that it uses at compile time.</p> <p>When <a href="qxmlquery">QXmlQuery</a> calls <a href="qabstractmessagehandler#message">QAbstractMessageHandler::message</a>(), the arguments are as follows:</p> <table class="generic"> <thead><tr class="qt-style">
<th>message() argument</th>
<th>Semantics</th>
</tr></thead> <tr class="odd" valign="top">
<td>
<a href="qtglobal#QtMsgType-enum">QtMsgType</a> type</td>
<td>Only <a href="qtglobal#QtMsgType-enum">QtWarningMsg</a> and <a href="qtglobal#QtMsgType-enum">QtFatalMsg</a> are used. The former identifies a compile or runtime warning, while the latter identifies a dynamic or static error.</td>
</tr> <tr class="even" valign="top">
<td>const <a href="qstring">QString</a> &amp; description</td>
<td>An XHTML document which is the actual message. It is translated into the current language.</td>
</tr> <tr class="odd" valign="top">
<td>const <a href="qurl">QUrl</a> &amp;identifier</td>
<td>Identifies the error with a URI, where the fragment is the error code, and the rest of the URI is the error namespace.</td>
</tr> <tr class="even" valign="top">
<td>const <a href="qsourcelocation">QSourceLocation</a> &amp; sourceLocation</td>
<td>Identifies where the error occurred.</td>
</tr> </table> <p><b>See also </b><a href="qxmlquery#messageHandler">messageHandler</a>().</p>   <h3 class="fn" id="setNetworkAccessManager">
<span class="type">void</span> QXmlQuery::<span class="name">setNetworkAccessManager</span>(<span class="type">QNetworkAccessManager</span> *<i>newManager</i>)
</h3> <p>Sets the network manager to <i>newManager</i>. <a href="qxmlquery">QXmlQuery</a> does not take ownership of <i>newManager</i>.</p> <p>This function was introduced in Qt 4.5.</p> <p><b>See also </b><a href="qxmlquery#networkAccessManager">networkAccessManager</a>().</p>   <h3 class="fn" id="setQuery">
<span class="type">void</span> QXmlQuery::<span class="name">setQuery</span>(<span class="type"><a href="qiodevice">QIODevice</a></span> *<i>sourceCode</i>, const <span class="type"><a href="qurl">QUrl</a></span> &amp;<i>documentURI</i> = QUrl())
</h3> <p>Sets this <a href="qxmlquery">QXmlQuery</a> to an <a href="xmlprocessing">XQuery</a> read from the <i>sourceCode</i> device. The device must have been opened with at least <a href="qiodevice#OpenModeFlag-enum">QIODevice::ReadOnly</a>.</p> <p><i>documentURI</i> represents the query obtained from the <i>sourceCode</i> device. It is the base URI of the static context, as defined in the <a href="http://www.w3.org/TR/xquery/">XQuery language</a>. It is used internally to resolve relative URIs that appear in the query, and for message reporting. <i>documentURI</i> can be empty. If it is empty, the <a href="qcoreapplication#applicationFilePath">application file path</a> is used. If it is not empty, it may be either relative or absolute. If it is relative, it is resolved itself against the <a href="qcoreapplication#applicationFilePath">application file path</a> before it is used. If <i>documentURI</i> is neither a valid URI nor empty, the result is undefined.</p> <p>If the query contains a static error (e.g. syntax error), an error message is sent to the <a href="qxmlquery#messageHandler">messageHandler</a>(), and <a href="qxmlquery#isValid">isValid</a>() will return <i>false</i>.</p> <p>Variables must be bound before setQuery() is called.</p> <p>The encoding of the <a href="xmlprocessing">XQuery</a> in <i>sourceCode</i> is detected internally using the rules for setting and detecting encoding of <a href="xmlprocessing">XQuery</a> files, which are explained in the <a href="http://www.w3.org/TR/xquery/">XQuery language</a>.</p> <p>If <i>sourceCode</i> is <code>null</code> or not readable, or if <i>documentURI</i> is not a valid URI, behavior is undefined.</p> <p><b>See also </b><a href="qxmlquery#isValid">isValid</a>().</p>   <h3 class="fn" id="setQuery-1">
<span class="type">void</span> QXmlQuery::<span class="name">setQuery</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>sourceCode</i>, const <span class="type"><a href="qurl">QUrl</a></span> &amp;<i>documentURI</i> = QUrl())
</h3> <p>This is an overloaded function.</p> <p>The behavior and requirements of this function are the same as for setQuery(<a href="qiodevice">QIODevice</a>*, const <a href="qurl">QUrl</a>&amp;), after the <a href="xmlprocessing">XQuery</a> has been read from the IO device into a string. Because <i>sourceCode</i> is already a Unicode string, detection of its encoding is unnecessary.</p>   <h3 class="fn" id="setQuery-2">
<span class="type">void</span> QXmlQuery::<span class="name">setQuery</span>(const <span class="type"><a href="qurl">QUrl</a></span> &amp;<i>queryURI</i>, const <span class="type"><a href="qurl">QUrl</a></span> &amp;<i>baseURI</i> = QUrl())
</h3> <p>Sets this <a href="qxmlquery">QXmlQuery</a> to the <a href="xmlprocessing">XQuery</a> read from the <i>queryURI</i>. Use <a href="qxmlquery#isValid">isValid</a>() after calling this function. If an error occurred reading <i>queryURI</i>, e.g., the query does not exist, cannot be read, or is invalid, <a href="qxmlquery#isValid">isValid</a>() will return <i>false</i>.</p> <p>The supported URI schemes are the same as those in the <a href="xmlprocessing">XQuery</a> function <code>fn:doc</code>, except that queryURI can be the object of a variable binding.</p> <p><i>baseURI</i> is the Base URI of the static context, as defined in the <a href="http://www.w3.org/TR/xquery/">XQuery language</a>. It is used internally to resolve relative URIs that appear in the query, and for message reporting. If <i>baseURI</i> is empty, <i>queryURI</i> is used. Otherwise, <i>baseURI</i> is used, and it is resolved against the <a href="qcoreapplication#applicationFilePath">application file path</a> if it is relative.</p> <p>If <i>queryURI</i> is empty or invalid, or if <i>baseURI</i> is invalid, the behavior of this function is undefined.</p>   <h3 class="fn" id="setUriResolver">
<span class="type">void</span> QXmlQuery::<span class="name">setUriResolver</span>(const <span class="type"><a href="qabstracturiresolver">QAbstractUriResolver</a></span> *<i>resolver</i>)
</h3> <p>Sets the URI resolver to <i>resolver</i>. <a href="qxmlquery">QXmlQuery</a> does not take ownership of <i>resolver</i>.</p> <p><b>See also </b><a href="qxmlquery#uriResolver">uriResolver</a>().</p>   <h3 class="fn" id="uriResolver">
const <span class="type"><a href="qabstracturiresolver">QAbstractUriResolver</a></span> *QXmlQuery::<span class="name">uriResolver</span>() const
</h3> <p>Returns the query's URI resolver. If no URI resolver has been set, Qt XML Patterns will use the URIs in queries as they are.</p> <p>The URI resolver provides a level of abstraction, or <i>polymorphic URIs</i>. A resolver can rewrite <i>logical</i> URIs to physical ones, or it can translate obsolete or invalid URIs to valid ones.</p> <p>Qt XML Patterns calls the URI resolver for all URIs it encounters, except for namespaces. Specifically, all builtin functions that deal with URIs (<code>fn:doc()</code>, and <code>fn:doc-available()</code>).</p> <p>In the case of <code>fn:doc()</code>, the absolute URI is the base URI in the static context (which most likely is the location of the query). Rather than use the URI the user specified, the return value of <a href="qabstracturiresolver#resolve">QAbstractUriResolver::resolve</a>() will be used.</p> <p>When Qt XML Patterns calls <a href="qabstracturiresolver#resolve">QAbstractUriResolver::resolve</a>() the absolute URI is the URI mandated by the <a href="xmlprocessing">XQuery</a> language, and the relative URI is the URI specified by the user.</p> <p><b>See also </b><a href="qxmlquery#setUriResolver">setUriResolver</a>().</p>
<div class="_attribution">
  <p class="_attribution-p">
    © The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-5.15/qxmlquery.html" class="_attribution-link">https://doc.qt.io/qt-5.15/qxmlquery.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
