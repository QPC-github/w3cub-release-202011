
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>QCborMap (Class) - Qt 5.15 - W3cubDocs</title>
  
  <meta name="description" content=" The QCborMap class is used to hold an associative container representable in CBOR. More... ">
  <meta name="keywords" content="qcbormap, class, qt, qt~5.15">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/qt~5.15/qcbormap.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/qt~5.15.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt~5.15/" class="_nav-link" title="" style="margin-left:0;">Qt 5.15</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">QCborMap Class</h1>  <p>The QCborMap class is used to hold an associative container representable in CBOR. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QCborMap&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.12</td>
</tr>
</table>
<p>This class was introduced in Qt 5.12.</p> <ul> <li><a href="https://doc.qt.io/qt-5.15/qcbormap-members.html">List of all members, including inherited members</a></li> </ul> <p><b>Note:</b> All functions in this class are <a href="threads-reentrancy">reentrant</a>.</p>  <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> class </td>
<td class="memItemRight bottomAlign"><b><a href="qcbormap-constiterator">ConstIterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> class </td>
<td class="memItemRight bottomAlign"><b><a href="qcbormap-iterator">Iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> typedef </td>
<td class="memItemRight bottomAlign"><b><a href="qcbormap#const_iterator-typedef">const_iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> typedef </td>
<td class="memItemRight bottomAlign"><b><a href="qcbormap#iterator-typedef">iterator</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> typedef </td>
<td class="memItemRight bottomAlign"><b><a href="qcbormap#key_type-typedef">key_type</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> typedef </td>
<td class="memItemRight bottomAlign"><b><a href="qcbormap#mapped_type-typedef">mapped_type</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> typedef </td>
<td class="memItemRight bottomAlign"><b><a href="qcbormap#size_type-typedef">size_type</a></b></td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> typedef </td>
<td class="memItemRight bottomAlign"><b><a href="qcbormap#value_type-typedef">value_type</a></b></td>
</tr> </table>  <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#QCborMap-2">QCborMap</a></b>(std::initializer_list&lt;value_type&gt; <i>args</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#QCborMap-1">QCborMap</a></b>(const QCborMap &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#QCborMap">QCborMap</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap &amp;</td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#operator-eq">operator=</a></b>(const QCborMap &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#dtor.QCborMap">~QCborMap</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#begin">begin</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#begin-1">begin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#cbegin">cbegin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#cend">cend</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#clear">clear</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> int </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#compare">compare</a></b>(const QCborMap &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#constBegin">constBegin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#constEnd">constEnd</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#constFind">constFind</a></b>(qint64 <i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#constFind-1">constFind</a></b>(QLatin1String <i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#constFind-2">constFind</a></b>(const QString &amp;<i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#constFind-3">constFind</a></b>(const QCborValue &amp;<i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#contains">contains</a></b>(qint64 <i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#contains-1">contains</a></b>(QLatin1String <i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#contains-2">contains</a></b>(const QString &amp;<i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#contains-3">contains</a></b>(const QCborValue &amp;<i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#empty">empty</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#end">end</a></b>()</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#end-1">end</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#erase">erase</a></b>(QCborMap::const_iterator <i>it</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#erase-1">erase</a></b>(QCborMap::iterator <i>it</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#extract">extract</a></b>(QCborMap::iterator <i>it</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#extract-1">extract</a></b>(QCborMap::const_iterator <i>it</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#find">find</a></b>(qint64 <i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#find-1">find</a></b>(QLatin1String <i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#find-2">find</a></b>(const QString &amp;<i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#find-3">find</a></b>(const QCborValue &amp;<i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#find-4">find</a></b>(qint64 <i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#find-5">find</a></b>(QLatin1String <i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#find-6">find</a></b>(const QString &amp;<i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#find-7">find</a></b>(const QCborValue &amp;<i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#insert">insert</a></b>(qint64 <i>key</i>, const QCborValue &amp;<i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#insert-1">insert</a></b>(QLatin1String <i>key</i>, const QCborValue &amp;<i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#insert-2">insert</a></b>(const QString &amp;<i>key</i>, const QCborValue &amp;<i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#insert-3">insert</a></b>(const QCborValue &amp;<i>key</i>, const QCborValue &amp;<i>value</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#insert-4">insert</a></b>(QCborMap::value_type <i>v</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#isEmpty">isEmpty</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QVector&lt;QCborValue&gt; </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#keys">keys</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#remove">remove</a></b>(qint64 <i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#remove-1">remove</a></b>(QLatin1String <i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#remove-2">remove</a></b>(const QString &amp;<i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#remove-3">remove</a></b>(const QCborValue &amp;<i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> qsizetype </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#size">size</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#swap">swap</a></b>(QCborMap &amp;<i>other</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#take">take</a></b>(qint64 <i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#take-1">take</a></b>(QLatin1String <i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#take-2">take</a></b>(const QString &amp;<i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#take-3">take</a></b>(const QCborValue &amp;<i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#toCborValue">toCborValue</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QJsonObject </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#toJsonObject">toJsonObject</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QVariantHash </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#toVariantHash">toVariantHash</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QVariantMap </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#toVariantMap">toVariantMap</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#value">value</a></b>(qint64 <i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#value-1">value</a></b>(QLatin1String <i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#value-2">value</a></b>(const QString &amp;<i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#value-3">value</a></b>(const QCborValue &amp;<i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#operator-not-eq">operator!=</a></b>(const QCborMap &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#operator-lt">operator&lt;</a></b>(const QCborMap &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#operator-eq-eq">operator==</a></b>(const QCborMap &amp;<i>other</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#operator-5b-5d">operator[]</a></b>(qint64 <i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#operator-5b-5d-1">operator[]</a></b>(QLatin1String <i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#operator-5b-5d-2">operator[]</a></b>(const QString &amp;<i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> const QCborValue </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#operator-5b-5d-3">operator[]</a></b>(const QCborValue &amp;<i>key</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValueRef </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#operator-5b-5d-5">operator[]</a></b>(qint64 <i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValueRef </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#operator-5b-5d-6">operator[]</a></b>(QLatin1String <i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValueRef </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#operator-5b-5d-7">operator[]</a></b>(const QString &amp;<i>key</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborValueRef </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#operator-5b-5d-8">operator[]</a></b>(const QCborValue &amp;<i>key</i>)</td>
</tr> </table>  <h2 id="static-public-members">Static Public Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#fromJsonObject">fromJsonObject</a></b>(const QJsonObject &amp;<i>obj</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#fromVariantHash">fromVariantHash</a></b>(const QVariantHash &amp;<i>hash</i>)</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QCborMap </td>
<td class="memItemRight bottomAlign">
<b><a href="qcbormap#fromVariantMap">fromVariantMap</a></b>(const QVariantMap &amp;<i>map</i>)</td>
</tr> </table>    <h2 id="details">Detailed Description
</h2> <p>This class can be used to hold an associative container in CBOR, a map between a key and a value type. CBOR is the Concise Binary Object Representation, a very compact form of binary data encoding that is a superset of JSON. It was created by the IETF Constrained RESTful Environments (CoRE) WG, which has used it in many new RFCs. It is meant to be used alongside the <a href="https://tools.ietf.org/html/rfc7252">CoAP protocol</a>.</p> <p>Unlike JSON and <a href="qvariant#QVariantMap-typedef">QVariantMap</a>, CBOR map keys can be of any type, not just strings. For that reason, QCborMap is effectively a map between <a href="qcborvalue">QCborValue</a> keys to <a href="qcborvalue">QCborValue</a> value elements.</p> <p>However, for all member functions that take a key parameter, QCborMap provides overloads that will work efficiently with integers and strings. In fact, the use of integer keys is encouraged, since they occupy fewer bytes to transmit and are simpler to encode and decode. Newer protocols designed by the IETF CoRE WG to work specifically with CBOR are known to use them.</p> <p>QCborMap is not sorted, because of that, searching for keys has linear complexity (O(n)). QCborMap actually keeps the elements in the order that they were inserted, which means that it is possible to make sorted QCborMaps by carefully inserting elements in sorted order. CBOR does not require sorting, but recommends it.</p> <p>QCborMap can also be converted to and from <a href="qvariant#QVariantMap-typedef">QVariantMap</a> and <a href="qjsonobject">QJsonObject</a>. However, when performing the conversion, any non-string keys will be stringified using a one-way method that the conversion back to QCborMap will not undo.</p>  <p><b>See also </b><a href="qcborarray">QCborArray</a>, <a href="qcborvalue">QCborValue</a>, <a href="qjsondocument">QJsonDocument</a>, and <a href="qvariant#QVariantMap-typedef">QVariantMap</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="fn" id="const_iterator-typedef">
typedef QCborMap::<span class="name">const_iterator</span>
</h3> <p>A synonym for <a href="qcbormap-constiterator">QCborMap::ConstIterator</a></p>   <h3 class="fn" id="iterator-typedef">
typedef QCborMap::<span class="name">iterator</span>
</h3> <p>A synonym for <a href="qcbormap-iterator">QCborMap::Iterator</a>.</p>   <h3 class="fn" id="key_type-typedef">
typedef QCborMap::<span class="name">key_type</span>
</h3> <p>The key type for this map. Since <a href="qcbormap">QCborMap</a> keys can be any CBOR type, this is a <a href="qcborvalue">QCborValue</a>.</p>   <h3 class="fn" id="mapped_type-typedef">
typedef QCborMap::<span class="name">mapped_type</span>
</h3> <p>The type that is mapped to (the value), that is, a <a href="qcborvalue">QCborValue</a>.</p>   <h3 class="fn" id="size_type-typedef">
typedef QCborMap::<span class="name">size_type</span>
</h3> <p>The type that <a href="qcbormap">QCborMap</a> uses for sizes.</p>   <h3 class="fn" id="value_type-typedef">
typedef QCborMap::<span class="name">value_type</span>
</h3> <p>The value that is stored in this container: a pair of QCborValues</p>    <h2>Member Function Documentation</h2>  <div class="fngroup"> <h3 class="fn fngroupitem" id="extract-1">
<span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">extract</span>(<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> <i>it</i>)
</h3>
<h3 class="fn fngroupitem" id="extract">
<span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">extract</span>(<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> <i>it</i>)
</h3>
</div> <p>Extracts a value from the map at the position indicated by iterator <i>it</i> and returns the value so extracted.</p> <p><b>See also </b><a href="qcbormap#insert">insert</a>(), <a href="qcbormap#erase">erase</a>(), <a href="qcbormap#take">take</a>(), and <a href="qcbormap#remove">remove</a>().</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="find-3">
<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> QCborMap::<span class="name">find</span>(const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>key</i>)
</h3>
<h3 class="fn fngroupitem" id="find-7">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">find</span>(const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>key</i>) const
</h3>
</div> <p>This is an overloaded function.</p> <p>Returns a map iterator to the key-value pair whose key is <i>key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap#end">end</a>().</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will find. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>value(qint64), value(<a href="qlatin1string">QLatin1String</a>), value(const <a href="qstring">QString</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#value-3">value</a>(const QCborValue &amp;), <a href="qcbormap#operator-5b-5d-3">operator[]</a>(const QCborValue &amp;), <a href="qcbormap#constFind-3">constFind</a>(const QCborValue &amp;), <a href="qcbormap#remove-3">remove</a>(const QCborValue &amp;), and <a href="qcbormap#contains-3">contains</a>(const QCborValue &amp;).</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="find-2">
<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> QCborMap::<span class="name">find</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>key</i>)
</h3>
<h3 class="fn fngroupitem" id="find-6">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">find</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>key</i>) const
</h3>
</div> <p>This is an overloaded function.</p> <p>Returns a map iterator to the key-value pair whose key is <i>key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap#end">end</a>().</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will find. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>value(qint64), value(<a href="qlatin1string">QLatin1String</a>), value(const <a href="qcborvalue">QCborValue</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#value-2">value</a>(const QString &amp;), <a href="qcbormap#operator-5b-5d-2">operator[]</a>(const QString &amp;), <a href="qcbormap#constFind-2">constFind</a>(const QString &amp;), <a href="qcbormap#remove-2">remove</a>(const QString &amp;), and <a href="qcbormap#contains-2">contains</a>(const QString &amp;).</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="find-1">
<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> QCborMap::<span class="name">find</span>(<span class="type"><a href="qlatin1string">QLatin1String</a></span> <i>key</i>)
</h3>
<h3 class="fn fngroupitem" id="find-5">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">find</span>(<span class="type"><a href="qlatin1string">QLatin1String</a></span> <i>key</i>) const
</h3>
</div> <p>This is an overloaded function.</p> <p>Returns a map iterator to the key-value pair whose key is <i>key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap#end">end</a>().</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will find. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>value(qint64), value(const <a href="qstring">QString</a> &amp;), value(const <a href="qcborvalue">QCborValue</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#value-1">value</a>(QLatin1String), <a href="qcbormap#operator-5b-5d-1">operator[]</a>(QLatin1String), <a href="qcbormap#constFind-1">constFind</a>(QLatin1String), <a href="qcbormap#remove-1">remove</a>(QLatin1String), and <a href="qcbormap#contains-1">contains</a>(QLatin1String).</p>   <div class="fngroup"> <h3 class="fn fngroupitem" id="find">
<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> QCborMap::<span class="name">find</span>(<span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> <i>key</i>)
</h3>
<h3 class="fn fngroupitem" id="find-4">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">find</span>(<span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> <i>key</i>) const
</h3>
</div> <p>Returns a map iterator to the key-value pair whose key is <i>key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap#end">end</a>().</p> <p>CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will find. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>value(<a href="qlatin1string">QLatin1String</a>), value(const <a href="qstring">QString</a> &amp;), value(const <a href="qcborvalue">QCborValue</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#value">value</a>(qint64), <a href="qcbormap#operator-5b-5d">operator[]</a>(qint64), <a href="qcbormap#constFind">constFind</a>(qint64), <a href="qcbormap#remove">remove</a>(qint64), and <a href="qcbormap#contains">contains</a>(qint64).</p>   <h3 class="fn" id="QCborMap-2">
QCborMap::<span class="name">QCborMap</span>(<span class="type">std::initializer_list</span>&lt;<span class="type"><a href="qcbormap#value_type-typedef">value_type</a></span>&gt; <i>args</i>)
</h3> <p>Constructs a QCborMap with items from a brace-initialization list found in <i>args</i>, as in the following example:</p> <pre data-language="cpp">QCborMap map = {
    {0, "Hello"},
    {1, "World"},
    {"foo", nullptr},
    {"bar", QCborArray{0, 1, 2, 3, 4}}
};</pre>   <h3 class="fn" id="QCborMap-1">
QCborMap::<span class="name">QCborMap</span>(const <span class="type"><a href="qcbormap#QCborMap">QCborMap</a></span> &amp;<i>other</i>)
</h3> <p>Creates a QCborMap object that is a copy of <i>other</i>.</p>   <h3 class="fn" id="QCborMap">
QCborMap::<span class="name">QCborMap</span>()
</h3> <p>Constructs an empty CBOR Map object.</p> <p><b>See also </b><a href="qcbormap#isEmpty">isEmpty</a>().</p>   <h3 class="fn" id="operator-eq">
<span class="type"><a href="qcbormap#QCborMap">QCborMap</a></span> &amp;QCborMap::<span class="name">operator=</span>(const <span class="type"><a href="qcbormap#QCborMap">QCborMap</a></span> &amp;<i>other</i>)
</h3> <p>Replaces the contents of this object with a copy of <i>other</i>, then returns a reference to this object.</p>   <h3 class="fn" id="dtor.QCborMap">
QCborMap::<span class="name">~QCborMap</span>()
</h3> <p>Destroys this <a href="qcbormap">QCborMap</a> object and frees any associated resources it owns.</p>   <h3 class="fn" id="begin">
<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> QCborMap::<span class="name">begin</span>()
</h3> <p>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <a href="qcbormap#end">end</a>().</p> <p><b>See also </b><a href="qcbormap#constBegin">constBegin</a>() and <a href="qcbormap#end">end</a>().</p>   <h3 class="fn" id="begin-1">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">begin</span>() const
</h3> <p>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <a href="qcbormap#constEnd">constEnd</a>().</p> <p><b>See also </b><a href="qcbormap#begin">begin</a>() and <a href="qcbormap#constEnd">constEnd</a>().</p>   <h3 class="fn" id="cbegin">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">cbegin</span>() const
</h3> <p>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <a href="qcbormap#constEnd">constEnd</a>().</p> <p><b>See also </b><a href="qcbormap#begin">begin</a>() and <a href="qcbormap#constEnd">constEnd</a>().</p>   <h3 class="fn" id="cend">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">cend</span>() const
</h3> <p>Returns a map iterator representing an element just past the last element in the map.</p> <p><b>See also </b><a href="qcbormap#begin">begin</a>(), <a href="qcbormap#constBegin">constBegin</a>(), <a href="qcbormap#find">find</a>(), and <a href="qcbormap#constFind">constFind</a>().</p>   <h3 class="fn" id="clear">
<span class="type">void</span> QCborMap::<span class="name">clear</span>()
</h3> <p>Empties this map.</p> <p><b>See also </b><a href="qcbormap#isEmpty">isEmpty</a>().</p>   <h3 class="fn" id="compare">
<span class="type">int</span> QCborMap::<span class="name">compare</span>(const <span class="type"><a href="qcbormap#QCborMap">QCborMap</a></span> &amp;<i>other</i>) const
</h3> <p>Compares this map and <i>other</i>, comparing each element in sequence, and returns an integer that indicates whether this map should be sorted prior to (if the result is negative) or after <i>other</i> (if the result is positive). If this function returns 0, the two maps are equal and contain the same elements.</p> <p>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</p> <p>For more information on CBOR sorting order, see <a href="qcborvalue#compare">QCborValue::compare</a>().</p> <p><b>See also </b><a href="qcborvalue#compare">QCborValue::compare</a>(), <a href="qcborarray#compare">QCborArray::compare</a>(), and <a href="qcbormap#operator-eq-eq">operator==</a>().</p>   <h3 class="fn" id="constBegin">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constBegin</span>() const
</h3> <p>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <a href="qcbormap#constEnd">constEnd</a>().</p> <p><b>See also </b><a href="qcbormap#begin">begin</a>() and <a href="qcbormap#constEnd">constEnd</a>().</p>   <h3 class="fn" id="constEnd">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constEnd</span>() const
</h3> <p>Returns a map iterator representing an element just past the last element in the map.</p> <p><b>See also </b><a href="qcbormap#begin">begin</a>(), <a href="qcbormap#constBegin">constBegin</a>(), <a href="qcbormap#find">find</a>(), and <a href="qcbormap#constFind">constFind</a>().</p>   <h3 class="fn" id="constFind">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constFind</span>(<span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> <i>key</i>) const
</h3> <p>Returns a map iterator to the key-value pair whose key is <i>key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap#constEnd">constEnd</a>().</p> <p>CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will find. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>value(<a href="qlatin1string">QLatin1String</a>), value(const <a href="qstring">QString</a> &amp;), value(const <a href="qcborvalue">QCborValue</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#value">value</a>(qint64), <a href="qcbormap#operator-5b-5d">operator[]</a>(qint64), <a href="qcbormap#find">find</a>(qint64), <a href="qcbormap#remove">remove</a>(qint64), and <a href="qcbormap#contains">contains</a>(qint64).</p>   <h3 class="fn" id="constFind-1">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constFind</span>(<span class="type"><a href="qlatin1string">QLatin1String</a></span> <i>key</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns a map iterator to the key-value pair whose key is <i>key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap#constEnd">constEnd</a>().</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will find. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>value(qint64), value(const <a href="qstring">QString</a> &amp;), value(const <a href="qcborvalue">QCborValue</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#value-1">value</a>(QLatin1String), <a href="qcbormap#operator-5b-5d-1">operator[]</a>(QLatin1String), <a href="qcbormap#find-1">find</a>(QLatin1String), <a href="qcbormap#remove-1">remove</a>(QLatin1String), and <a href="qcbormap#contains-1">contains</a>(QLatin1String).</p>   <h3 class="fn" id="constFind-2">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constFind</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>key</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns a map iterator to the key-value pair whose key is <i>key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap#constEnd">constEnd</a>().</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will find. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>value(qint64), value(<a href="qlatin1string">QLatin1String</a>), value(const <a href="qcborvalue">QCborValue</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#value-2">value</a>(const QString &amp;), <a href="qcbormap#operator-5b-5d-2">operator[]</a>(const QString &amp;), <a href="qcbormap#find-2">find</a>(const QString &amp;), <a href="qcbormap#remove-2">remove</a>(const QString &amp;), and <a href="qcbormap#contains-2">contains</a>(const QString &amp;).</p>   <h3 class="fn" id="constFind-3">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constFind</span>(const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>key</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns a map iterator to the key-value pair whose key is <i>key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="qcbormap#constEnd">constEnd</a>().</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will find. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p><b>See also </b><a href="qcbormap#value-3">value</a>(const QCborValue &amp;), <a href="qcbormap#operator-5b-5d-3">operator[]</a>(const QCborValue &amp;), <a href="qcbormap#find-3">find</a>(const QCborValue &amp;), <a href="qcbormap#remove-3">remove</a>(const QCborValue &amp;), <a href="qcbormap#contains-3">contains</a>(const QCborValue &amp;), <a href="qcbormap#value">value</a>(qint64), <a href="qcbormap#value-1">value</a>(QLatin1String), and <a href="qcbormap#value-2">value</a>(const QString &amp;).</p>   <h3 class="fn" id="contains">
<span class="type">bool</span> QCborMap::<span class="name">contains</span>(<span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> <i>key</i>) const
</h3> <p>Returns true if this map contains a key-value pair identified by key <i>key</i>. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p> <p><b>See also </b><a href="qcbormap#value">value</a>(qint64), <a href="qcbormap#operator-5b-5d">operator[]</a>(qint64), <a href="qcbormap#find">find</a>(qint64), <a href="qcbormap#remove">remove</a>(qint64), <a href="qcbormap#contains-1">contains</a>(QLatin1String), <a href="qcbormap#remove-2">remove</a>(const QString &amp;), and <a href="qcbormap#remove-3">remove</a>(const QCborValue &amp;).</p>   <h3 class="fn" id="contains-1">
<span class="type">bool</span> QCborMap::<span class="name">contains</span>(<span class="type"><a href="qlatin1string">QLatin1String</a></span> <i>key</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns true if this map contains a key-value pair identified by key <i>key</i>.</p> <p><b>See also </b><a href="qcbormap#value-1">value</a>(QLatin1String), <a href="qcbormap#operator-5b-5d-1">operator[]</a>(QLatin1String), <a href="qcbormap#find-1">find</a>(QLatin1String), <a href="qcbormap#remove-1">remove</a>(QLatin1String), <a href="qcbormap#contains">contains</a>(qint64), <a href="qcbormap#remove-2">remove</a>(const QString &amp;), and <a href="qcbormap#remove-3">remove</a>(const QCborValue &amp;).</p>   <h3 class="fn" id="contains-2">
<span class="type">bool</span> QCborMap::<span class="name">contains</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>key</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns true if this map contains a key-value pair identified by key <i>key</i>.</p> <p><b>See also </b><a href="qcbormap#value-2">value</a>(const QString &amp;), <a href="qcbormap#operator-5b-5d-2">operator[]</a>(const QString &amp;), <a href="qcbormap#find-2">find</a>(const QString &amp;), <a href="qcbormap#remove-2">remove</a>(const QString &amp;), <a href="qcbormap#contains">contains</a>(qint64), <a href="qcbormap#remove-1">remove</a>(QLatin1String), and <a href="qcbormap#remove-3">remove</a>(const QCborValue &amp;).</p>   <h3 class="fn" id="contains-3">
<span class="type">bool</span> QCborMap::<span class="name">contains</span>(const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>key</i>) const
</h3> <p>Returns true if this map contains a key-value pair identified by key <i>key</i>.</p> <p><b>See also </b><a href="qcbormap#value-3">value</a>(const QCborValue &amp;), <a href="qcbormap#operator-5b-5d-3">operator[]</a>(const QCborValue &amp;), <a href="qcbormap#find-3">find</a>(const QCborValue &amp;), <a href="qcbormap#remove-3">remove</a>(const QCborValue &amp;), <a href="qcbormap#contains">contains</a>(qint64), <a href="qcbormap#remove-1">remove</a>(QLatin1String), and <a href="qcbormap#remove-2">remove</a>(const QString &amp;).</p>   <h3 class="fn" id="empty">
<span class="type">bool</span> QCborMap::<span class="name">empty</span>() const
</h3> <p>Synonym for <a href="qcbormap#isEmpty">isEmpty</a>(). This function is provided for compatibility with generic code that uses the Standard Library API.</p> <p>Returns true if this map is empty (<a href="qcbormap#size">size</a>() == 0).</p> <p><b>See also </b><a href="qcbormap#isEmpty">isEmpty</a>() and <a href="qcbormap#size">size</a>().</p>   <h3 class="fn" id="end">
<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> QCborMap::<span class="name">end</span>()
</h3> <p>Returns a map iterator representing an element just past the last element in the map.</p> <p><b>See also </b><a href="qcbormap#begin">begin</a>(), <a href="qcbormap#constBegin">constBegin</a>(), <a href="qcbormap#find">find</a>(), and <a href="qcbormap#constFind">constFind</a>().</p>   <h3 class="fn" id="end-1">
<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> QCborMap::<span class="name">end</span>() const
</h3> <p>Returns a map iterator representing an element just past the last element in the map.</p> <p><b>See also </b><a href="qcbormap#begin">begin</a>(), <a href="qcbormap#constBegin">constBegin</a>(), <a href="qcbormap#find">find</a>(), and <a href="qcbormap#constFind">constFind</a>().</p>   <h3 class="fn" id="erase">
<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> QCborMap::<span class="name">erase</span>(<span class="type"><a href="qcbormap#const_iterator-typedef">QCborMap::const_iterator</a></span> <i>it</i>)
</h3> <p>Removes the key-value pair pointed to by the map iterator <i>it</i> and returns a pointer to the next element, after removal.</p> <p><b>See also </b><a href="qcbormap#remove">remove</a>(), <a href="qcbormap#begin">begin</a>(), <a href="qcbormap#end">end</a>(), <a href="qcbormap#insert">insert</a>(), and <a href="qcbormap#extract">extract</a>().</p>   <h3 class="fn" id="erase-1">
<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> QCborMap::<span class="name">erase</span>(<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> <i>it</i>)
</h3> <p>This is an overloaded function.</p> <p>Removes the key-value pair pointed to by the map iterator <i>it</i> and returns a pointer to the next element, after removal.</p> <p><b>See also </b><a href="qcbormap#remove">remove</a>(), <a href="qcbormap#begin">begin</a>(), <a href="qcbormap#end">end</a>(), and <a href="qcbormap#insert">insert</a>().</p>   <h3 class="fn" id="fromJsonObject">
<code>[static] </code><span class="type"><a href="qcbormap#QCborMap">QCborMap</a></span> QCborMap::<span class="name">fromJsonObject</span>(const <span class="type"><a href="qjsonobject">QJsonObject</a></span> &amp;<i>obj</i>)
</h3> <p>Converts all JSON items found in the <i>obj</i> object to CBOR using QCborValue::fromJson(), and returns the map composed of those elements.</p> <p>This conversion is lossless, as the CBOR type system is a superset of JSON's. Moreover, the map returned by this function can be converted back to the original <i>obj</i> by using <a href="qcbormap#toJsonObject">toJsonObject</a>().</p> <p><b>See also </b><a href="qcbormap#toJsonObject">toJsonObject</a>(), <a href="qcbormap#toVariantMap">toVariantMap</a>(), <a href="qcborvalue#fromJsonValue">QCborValue::fromJsonValue</a>(), and <a href="qcborarray#fromJsonArray">QCborArray::fromJsonArray</a>().</p>   <h3 class="fn" id="fromVariantHash">
<code>[static] </code><span class="type"><a href="qcbormap#QCborMap">QCborMap</a></span> QCborMap::<span class="name">fromVariantHash</span>(const <span class="type"><a href="qvariant#QVariantHash-typedef">QVariantHash</a></span> &amp;<i>hash</i>)
</h3> <p>Converts all the items in <i>hash</i> to CBOR using <a href="qcborvalue#fromVariant">QCborValue::fromVariant</a>() and returns the map composed of those elements.</p> <p>Conversion from <a href="qvariant">QVariant</a> is not completely lossless. Please see the documentation in <a href="qcborvalue#fromVariant">QCborValue::fromVariant</a>() for more information.</p> <p><b>See also </b><a href="qcbormap#toVariantHash">toVariantHash</a>(), <a href="qcbormap#fromVariantMap">fromVariantMap</a>(), <a href="qcbormap#fromJsonObject">fromJsonObject</a>(), and <a href="qcborvalue#fromVariant">QCborValue::fromVariant</a>().</p>   <h3 class="fn" id="fromVariantMap">
<code>[static] </code><span class="type"><a href="qcbormap#QCborMap">QCborMap</a></span> QCborMap::<span class="name">fromVariantMap</span>(const <span class="type"><a href="qvariant#QVariantMap-typedef">QVariantMap</a></span> &amp;<i>map</i>)
</h3> <p>Converts all the items in <i>map</i> to CBOR using <a href="qcborvalue#fromVariant">QCborValue::fromVariant</a>() and returns the map composed of those elements.</p> <p>Conversion from <a href="qvariant">QVariant</a> is not completely lossless. Please see the documentation in <a href="qcborvalue#fromVariant">QCborValue::fromVariant</a>() for more information.</p> <p><b>See also </b><a href="qcbormap#toVariantMap">toVariantMap</a>(), <a href="qcbormap#fromVariantHash">fromVariantHash</a>(), <a href="qcbormap#fromJsonObject">fromJsonObject</a>(), and <a href="qcborvalue#fromVariant">QCborValue::fromVariant</a>().</p>   <h3 class="fn" id="insert">
<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(<span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> <i>key</i>, const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>value</i>)
</h3> <p>This is an overloaded function.</p> <p>Inserts the key <i>key</i> and value <i>value</i> into this map and returns a map iterator pointing to the newly inserted pair.</p> <p>If the map already had a key equal to <i>key</i>, its value will be overwritten by <i>value</i>.</p> <p><b>See also </b><a href="qcbormap#erase">erase</a>(), <a href="qcbormap#remove">remove</a>(qint64), <a href="qcbormap#value">value</a>(qint64), <a href="qcbormap#operator-5b-5d">operator[]</a>(qint64), <a href="qcbormap#find">find</a>(qint64), <a href="qcbormap#contains">contains</a>(qint64), <a href="qcbormap#take">take</a>(qint64), and <a href="qcbormap#extract">extract</a>().</p>   <h3 class="fn" id="insert-1">
<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(<span class="type"><a href="qlatin1string">QLatin1String</a></span> <i>key</i>, const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>value</i>)
</h3> <p>This is an overloaded function.</p> <p>Inserts the key <i>key</i> and value <i>value</i> into this map and returns a map iterator pointing to the newly inserted pair.</p> <p>If the map already had a key equal to <i>key</i>, its value will be overwritten by <i>value</i>.</p> <p><b>See also </b><a href="qcbormap#erase">erase</a>(), <a href="qcbormap#remove-1">remove</a>(QLatin1String), <a href="qcbormap#value-1">value</a>(QLatin1String), <a href="qcbormap#operator-5b-5d-1">operator[]</a>(QLatin1String), <a href="qcbormap#find-1">find</a>(QLatin1String), <a href="qcbormap#contains-1">contains</a>(QLatin1String), <a href="qcbormap#take-1">take</a>(QLatin1String), and <a href="qcbormap#extract">extract</a>().</p>   <h3 class="fn" id="insert-2">
<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>key</i>, const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>value</i>)
</h3> <p>This is an overloaded function.</p> <p>Inserts the key <i>key</i> and value <i>value</i> into this map and returns a map iterator pointing to the newly inserted pair.</p> <p>If the map already had a key equal to <i>key</i>, its value will be overwritten by <i>value</i>.</p> <p><b>See also </b><a href="qcbormap#erase">erase</a>(), <a href="qcbormap#remove-2">remove</a>(const QString &amp;), <a href="qcbormap#value-2">value</a>(const QString &amp;), <a href="qcbormap#operator-5b-5d-2">operator[]</a>(const QString &amp;), <a href="qcbormap#find-2">find</a>(const QString &amp;), <a href="qcbormap#contains-2">contains</a>(const QString &amp;), <a href="qcbormap#take-2">take</a>(const QString &amp;), and <a href="qcbormap#extract">extract</a>().</p>   <h3 class="fn" id="insert-3">
<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>key</i>, const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>value</i>)
</h3> <p>This is an overloaded function.</p> <p>Inserts the key <i>key</i> and value <i>value</i> into this map and returns a map iterator pointing to the newly inserted pair.</p> <p>If the map already had a key equal to <i>key</i>, its value will be overwritten by <i>value</i>.</p> <p><b>See also </b><a href="qcbormap#erase">erase</a>(), <a href="qcbormap#remove-3">remove</a>(const QCborValue &amp;), <a href="qcbormap#value-3">value</a>(const QCborValue &amp;), <a href="qcbormap#operator-5b-5d-3">operator[]</a>(const QCborValue &amp;), <a href="qcbormap#find-3">find</a>(const QCborValue &amp;), <a href="qcbormap#contains-3">contains</a>(const QCborValue &amp;), <a href="qcbormap#take-3">take</a>(const QCborValue &amp;), and <a href="qcbormap#extract">extract</a>().</p>   <h3 class="fn" id="insert-4">
<span class="type"><a href="qcbormap#iterator-typedef">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(<span class="type"><a href="qcbormap#value_type-typedef">QCborMap::value_type</a></span> <i>v</i>)
</h3> <p>This is an overloaded function.</p> <p>Inserts the key-value pair in <i>v</i> into this map and returns a map iterator pointing to the newly inserted pair.</p> <p>If the map already had a key equal to <code>v.first</code>, its value will be overwritten by <code>v.second</code>.</p> <p><b>See also </b><a href="qcbormap#operator-5b-5d">operator[]</a>, <a href="qcbormap#erase">erase</a>(), and <a href="qcbormap#extract">extract</a>().</p>   <h3 class="fn" id="isEmpty">
<span class="type">bool</span> QCborMap::<span class="name">isEmpty</span>() const
</h3> <p>Returns true if this map is empty (that is, <a href="qcbormap#size">size</a>() is 0).</p> <p><b>See also </b><a href="qcbormap#size">size</a>() and <a href="qcbormap#clear">clear</a>().</p>   <h3 class="fn" id="keys">
<span class="type"><a href="qvector">QVector</a></span>&lt;<span class="type"><a href="qcborvalue">QCborValue</a></span>&gt; QCborMap::<span class="name">keys</span>() const
</h3> <p>Returns a list of all keys in this map.</p> <p><b>See also </b><a href="qmap#keys">QMap::keys</a>() and <a href="qhash#keys">QHash::keys</a>().</p>   <h3 class="fn" id="remove">
<span class="type">void</span> QCborMap::<span class="name">remove</span>(<span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> <i>key</i>)
</h3> <p>Removes the key <i>key</i> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will remove. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>remove(<a href="qlatin1string">QLatin1String</a>), remove(const <a href="qstring">QString</a> &amp;), remove(const <a href="qcborvalue">QCborValue</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#value">value</a>(qint64), <a href="qcbormap#operator-5b-5d">operator[]</a>(qint64), <a href="qcbormap#find">find</a>(qint64), and <a href="qcbormap#contains">contains</a>(qint64).</p>   <h3 class="fn" id="remove-1">
<span class="type">void</span> QCborMap::<span class="name">remove</span>(<span class="type"><a href="qlatin1string">QLatin1String</a></span> <i>key</i>)
</h3> <p>This is an overloaded function.</p> <p>Removes the key <i>key</i> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will remove. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>remove(qint64), remove(const <a href="qstring">QString</a> &amp;), remove(const <a href="qcborvalue">QCborValue</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#value-1">value</a>(QLatin1String), <a href="qcbormap#operator-5b-5d-1">operator[]</a>(QLatin1String), <a href="qcbormap#find-1">find</a>(QLatin1String), and <a href="qcbormap#contains-1">contains</a>(QLatin1String).</p>   <h3 class="fn" id="remove-2">
<span class="type">void</span> QCborMap::<span class="name">remove</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>key</i>)
</h3> <p>This is an overloaded function.</p> <p>Removes the key <i>key</i> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will remove. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>remove(qint64), remove(<a href="qlatin1string">QLatin1String</a>), remove(const <a href="qcborvalue">QCborValue</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#value-2">value</a>(const QString &amp;), <a href="qcbormap#operator-5b-5d-2">operator[]</a>(const QString &amp;), <a href="qcbormap#find-2">find</a>(const QString &amp;), and <a href="qcbormap#contains-2">contains</a>(const QString &amp;).</p>   <h3 class="fn" id="remove-3">
<span class="type">void</span> QCborMap::<span class="name">remove</span>(const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>key</i>)
</h3> <p>Removes the key <i>key</i> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will remove. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>remove(qint64), remove(<a href="qlatin1string">QLatin1String</a>), remove(const <a href="qstring">QString</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#value-3">value</a>(const QCborValue &amp;), <a href="qcbormap#operator-5b-5d-3">operator[]</a>(const QCborValue &amp;), <a href="qcbormap#find-3">find</a>(const QCborValue &amp;), and <a href="qcbormap#contains-3">contains</a>(const QCborValue &amp;).</p>   <h3 class="fn" id="size">
<span class="type">qsizetype</span> QCborMap::<span class="name">size</span>() const
</h3> <p>Returns the number of elements in this map.</p> <p><b>See also </b><a href="qcbormap#isEmpty">isEmpty</a>().</p>   <h3 class="fn" id="swap">
<span class="type">void</span> QCborMap::<span class="name">swap</span>(<span class="type"><a href="qcbormap#QCborMap">QCborMap</a></span> &amp;<i>other</i>)
</h3> <p>Swaps the contents of this map and <i>other</i>.</p>   <h3 class="fn" id="take">
<span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">take</span>(<span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> <i>key</i>)
</h3> <p>Removes the key <i>key</i> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will remove. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p><b>See also </b><a href="qcbormap#value">value</a>(qint64), <a href="qcbormap#operator-5b-5d">operator[]</a>(qint64), <a href="qcbormap#find">find</a>(qint64), <a href="qcbormap#contains">contains</a>(qint64), <a href="qcbormap#take-1">take</a>(QLatin1String), <a href="qcbormap#take-2">take</a>(const QString &amp;), <a href="qcbormap#take-3">take</a>(const QCborValue &amp;), and <a href="qcbormap#insert">insert</a>().</p>   <h3 class="fn" id="take-1">
<span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">take</span>(<span class="type"><a href="qlatin1string">QLatin1String</a></span> <i>key</i>)
</h3> <p>Removes the key <i>key</i> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will remove. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p><b>See also </b><a href="qcbormap#value-1">value</a>(QLatin1String), <a href="qcbormap#operator-5b-5d-1">operator[]</a>(QLatin1String), <a href="qcbormap#find-1">find</a>(QLatin1String), <a href="qcbormap#contains-1">contains</a>(QLatin1String), <a href="qcbormap#take">take</a>(qint64), <a href="qcbormap#take-2">take</a>(const QString &amp;), <a href="qcbormap#take-3">take</a>(const QCborValue &amp;), and <a href="qcbormap#insert">insert</a>().</p>   <h3 class="fn" id="take-2">
<span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">take</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>key</i>)
</h3> <p>Removes the key <i>key</i> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will remove. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p><b>See also </b><a href="qcbormap#value-2">value</a>(const QString &amp;), <a href="qcbormap#operator-5b-5d-2">operator[]</a>(const QString &amp;), <a href="qcbormap#find-2">find</a>(const QString &amp;), <a href="qcbormap#contains-2">contains</a>(const QString &amp;), <a href="qcbormap#take-1">take</a>(QLatin1String), <a href="qcbormap#take">take</a>(qint64), <a href="qcbormap#take-3">take</a>(const QCborValue &amp;), and <a href="qcbormap#insert">insert</a>().</p>   <h3 class="fn" id="take-3">
<span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">take</span>(const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>key</i>)
</h3> <p>Removes the key <i>key</i> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will remove. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p><b>See also </b><a href="qcbormap#value-3">value</a>(const QCborValue &amp;), <a href="qcbormap#operator-5b-5d-3">operator[]</a>(const QCborValue &amp;), <a href="qcbormap#find-3">find</a>(const QCborValue &amp;), <a href="qcbormap#contains-3">contains</a>(const QCborValue &amp;), <a href="qcbormap#take-1">take</a>(QLatin1String), <a href="qcbormap#take-2">take</a>(const QString &amp;), <a href="qcbormap#take">take</a>(qint64), and <a href="qcbormap#insert">insert</a>().</p>   <h3 class="fn" id="toCborValue">
<span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">toCborValue</span>() const
</h3> <p>Explicitly constructs a <a href="qcborvalue">QCborValue</a> object that represents this map. This function is usually not necessary since <a href="qcborvalue">QCborValue</a> has a constructor for <a href="qcbormap">QCborMap</a>, so the conversion is implicit.</p> <p>Converting <a href="qcbormap">QCborMap</a> to <a href="qcborvalue">QCborValue</a> allows it to be used in any context where QCborValues can be used, including as keys and mapped types in <a href="qcbormap">QCborMap</a>, as well as <a href="qcborvalue#toCbor">QCborValue::toCbor</a>().</p> <p><b>See also </b><a href="qcborvalue#QCborValue-14">QCborValue::QCborValue</a>(const QCborMap &amp;).</p>   <h3 class="fn" id="toJsonObject">
<span class="type"><a href="qjsonobject">QJsonObject</a></span> QCborMap::<span class="name">toJsonObject</span>() const
</h3> <p>Recursively converts every <a href="qcborvalue">QCborValue</a> value in this map to JSON using <a href="qcborvalue#toJsonValue">QCborValue::toJsonValue</a>() and creates a string key for all keys that aren't strings, then returns the corresponding <a href="qjsonobject">QJsonObject</a> composed of those associations.</p> <p>Please note that CBOR contains a richer and wider type set than JSON, so some information may be lost in this conversion. For more details on what conversions are applied, see <a href="qcborvalue#toJsonValue">QCborValue::toJsonValue</a>().</p>  <h6 id="map-key-conversion-to-string">Map key conversion to string
</h6> <p>JSON objects are defined as having string keys, unlike CBOR, so the conversion of a <a href="qcbormap">QCborMap</a> to <a href="qjsonobject">QJsonObject</a> will imply a step of "stringification" of the key values. The conversion will use the special handling of tags and extended types from above and will also convert the rest of the types as follows:</p> <table class="generic"> <thead><tr class="qt-style">
<th>Type</th>
<th>Transformation</th>
</tr></thead> <tr class="odd" valign="top">
<td>Bool</td>
<td>"true" and "false"</td>
</tr> <tr class="even" valign="top">
<td>Null</td>
<td>"null"</td>
</tr> <tr class="odd" valign="top">
<td>Undefined</td>
<td>"undefined"</td>
</tr> <tr class="even" valign="top">
<td>Integer</td>
<td>The decimal string form of the number</td>
</tr> <tr class="odd" valign="top">
<td>Double</td>
<td>The decimal string form of the number</td>
</tr> <tr class="even" valign="top">
<td>Byte array</td>
<td>Unless tagged differently (see above), encoded as Base64url</td>
</tr> <tr class="odd" valign="top">
<td>Array</td>
<td>Replaced by the compact form of its <a href="qcborvalue#toDiagnosticNotation">Diagnostic notation</a>
</td>
</tr> <tr class="even" valign="top">
<td>Map</td>
<td>Replaced by the compact form of its <a href="qcborvalue#toDiagnosticNotation">Diagnostic notation</a>
</td>
</tr> <tr class="odd" valign="top">
<td>Tags and extended types</td>
<td>Tag number is dropped and the tagged value is converted to string</td>
</tr> </table> <p><b>See also </b><a href="qcbormap#fromJsonObject">fromJsonObject</a>(), <a href="qcborvalue#toJsonValue">QCborValue::toJsonValue</a>(), <a href="qcborarray#toJsonArray">QCborArray::toJsonArray</a>(), and <a href="qcbormap#toVariantMap">toVariantMap</a>().</p>   <h3 class="fn" id="toVariantHash">
<span class="type"><a href="qvariant#QVariantHash-typedef">QVariantHash</a></span> QCborMap::<span class="name">toVariantHash</span>() const
</h3> <p>Converts the CBOR values to <a href="qvariant">QVariant</a> using <a href="qcborvalue#toVariant">QCborValue::toVariant</a>() and "stringifies" all the CBOR keys in this map, returning the <a href="qvariant#QVariantHash-typedef">QVariantHash</a> that results from that association list.</p> <p>QVariantMaps have string keys, unlike CBOR, so the conversion of a <a href="qcbormap">QCborMap</a> to <a href="qvariant#QVariantMap-typedef">QVariantMap</a> will imply a step of "stringification" of the key values. See <a href="qcbormap#toJsonObject">QCborMap::toJsonObject</a>() for details.</p> <p>In addition, the conversion to <a href="qvariant">QVariant</a> is not completely lossless. Please see the documentation in <a href="qcborvalue#toVariant">QCborValue::toVariant</a>() for more information.</p> <p><b>See also </b><a href="qcbormap#fromVariantHash">fromVariantHash</a>(), <a href="qcbormap#toVariantMap">toVariantMap</a>(), <a href="qcbormap#toJsonObject">toJsonObject</a>(), <a href="qcborvalue#toVariant">QCborValue::toVariant</a>(), and <a href="qcborarray#toVariantList">QCborArray::toVariantList</a>().</p>   <h3 class="fn" id="toVariantMap">
<span class="type"><a href="qvariant#QVariantMap-typedef">QVariantMap</a></span> QCborMap::<span class="name">toVariantMap</span>() const
</h3> <p>Converts the CBOR values to <a href="qvariant">QVariant</a> using <a href="qcborvalue#toVariant">QCborValue::toVariant</a>() and "stringifies" all the CBOR keys in this map, returning the <a href="qvariant#QVariantMap-typedef">QVariantMap</a> that results from that association list.</p> <p>QVariantMaps have string keys, unlike CBOR, so the conversion of a <a href="qcbormap">QCborMap</a> to <a href="qvariant#QVariantMap-typedef">QVariantMap</a> will imply a step of "stringification" of the key values. See <a href="qcbormap#toJsonObject">QCborMap::toJsonObject</a>() for details.</p> <p>In addition, the conversion to <a href="qvariant">QVariant</a> is not completely lossless. Please see the documentation in <a href="qcborvalue#toVariant">QCborValue::toVariant</a>() for more information.</p> <p><b>See also </b><a href="qcbormap#fromVariantMap">fromVariantMap</a>(), <a href="qcbormap#toVariantHash">toVariantHash</a>(), <a href="qcbormap#toJsonObject">toJsonObject</a>(), <a href="qcborvalue#toVariant">QCborValue::toVariant</a>(), and <a href="qcborarray#toVariantList">QCborArray::toVariantList</a>().</p>   <h3 class="fn" id="value">
<span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">value</span>(<span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> <i>key</i>) const
</h3> <p>Returns the <a href="qcborvalue">QCborValue</a> element in this map that corresponds to key <i>key</i>, if there is one. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p> <p>If the map does not contain key <i>key</i>, this function returns a <a href="qcborvalue">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one the return from function will reference. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>value(<a href="qlatin1string">QLatin1String</a>), value(const <a href="qstring">QString</a> &amp;), value(const <a href="qcborvalue">QCborValue</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#operator-5b-5d">operator[]</a>(qint64), <a href="qcbormap#find">find</a>(qint64), <a href="qcbormap#constFind">constFind</a>(qint64), <a href="qcbormap#remove">remove</a>(qint64), and <a href="qcbormap#contains">contains</a>(qint64).</p>   <h3 class="fn" id="value-1">
<span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">value</span>(<span class="type"><a href="qlatin1string">QLatin1String</a></span> <i>key</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns the <a href="qcborvalue">QCborValue</a> element in this map that corresponds to key <i>key</i>, if there is one.</p> <p>If the map does not contain key <i>key</i>, this function returns a <a href="qcborvalue">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will return. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>value(qint64), value(const <a href="qstring">QString</a> &amp;), value(const <a href="qcborvalue">QCborValue</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#operator-5b-5d-1">operator[]</a>(QLatin1String), <a href="qcbormap#find-1">find</a>(QLatin1String), <a href="qcbormap#constFind-1">constFind</a>(QLatin1String), <a href="qcbormap#remove-1">remove</a>(QLatin1String), and <a href="qcbormap#contains-1">contains</a>(QLatin1String).</p>   <h3 class="fn" id="value-2">
<span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">value</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>key</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns the <a href="qcborvalue">QCborValue</a> element in this map that corresponds to key <i>key</i>, if there is one.</p> <p>If the map does not contain key <i>key</i>, this function returns a <a href="qcborvalue">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will return. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>value(qint64), value(<a href="qlatin1string">QLatin1String</a>), value(const <a href="qcborvalue">QCborValue</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#operator-5b-5d-2">operator[]</a>(const QString &amp;), <a href="qcbormap#find-2">find</a>(const QString &amp;), <a href="qcbormap#constFind-2">constFind</a>(const QString &amp;), <a href="qcbormap#remove-2">remove</a>(const QString &amp;), and <a href="qcbormap#contains-2">contains</a>(const QString &amp;).</p>   <h3 class="fn" id="value-3">
<span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">value</span>(const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>key</i>) const
</h3> <p>Returns the <a href="qcborvalue">QCborValue</a> element in this map that corresponds to key <i>key</i>, if there is one.</p> <p>If the map does not contain key <i>key</i>, this function returns a <a href="qcborvalue">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will return. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>value(qint64), value(<a href="qlatin1string">QLatin1String</a>), value(const <a href="qstring">QString</a> &amp;)</p> <p><b>See also </b><a href="qcbormap#operator-5b-5d-3">operator[]</a>(const QCborValue &amp;), <a href="qcbormap#find-3">find</a>(const QCborValue &amp;), <a href="qcbormap#constFind-3">constFind</a>(const QCborValue &amp;), <a href="qcbormap#remove-3">remove</a>(const QCborValue &amp;), and <a href="qcbormap#contains-3">contains</a>(const QCborValue &amp;).</p>   <h3 class="fn" id="operator-not-eq">
<span class="type">bool</span> QCborMap::<span class="name">operator!=</span>(const <span class="type"><a href="qcbormap#QCborMap">QCborMap</a></span> &amp;<i>other</i>) const
</h3> <p>Compares this map and <i>other</i>, comparing each element in sequence, and returns true if the two maps contains any different elements or elements in different orders, false otherwise.</p> <p>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</p> <p>For more information on CBOR equality in Qt, see, <a href="qcborvalue#compare">QCborValue::compare</a>().</p> <p><b>See also </b><a href="qcbormap#compare">compare</a>(), <a href="qcborvalue#operator-eq-eq">QCborValue::operator==</a>(), <a href="qcbormap#operator-eq-eq">QCborMap::operator==</a>(), <a href="qcbormap#operator-eq-eq">operator==</a>(), and <a href="qcbormap#operator-lt">operator&lt;</a>().</p>   <h3 class="fn" id="operator-lt">
<span class="type">bool</span> QCborMap::<span class="name">operator&lt;</span>(const <span class="type"><a href="qcbormap#QCborMap">QCborMap</a></span> &amp;<i>other</i>) const
</h3> <p>Compares this map and <i>other</i>, comparing each element in sequence, and returns true if this map should be sorted before <i>other</i>, false otherwise.</p> <p>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</p> <p>For more information on CBOR sorting order, see <a href="qcborvalue#compare">QCborValue::compare</a>().</p> <p><b>See also </b><a href="qcbormap#compare">compare</a>(), <a href="qcborvalue#operator-eq-eq">QCborValue::operator==</a>(), <a href="qcbormap#operator-eq-eq">QCborMap::operator==</a>(), <a href="qcbormap#operator-eq-eq">operator==</a>(), and <a href="qcbormap#operator-not-eq">operator!=</a>().</p>   <h3 class="fn" id="operator-eq-eq">
<span class="type">bool</span> QCborMap::<span class="name">operator==</span>(const <span class="type"><a href="qcbormap#QCborMap">QCborMap</a></span> &amp;<i>other</i>) const
</h3> <p>Compares this map and <i>other</i>, comparing each element in sequence, and returns true if the two maps contains the same elements in the same order, false otherwise.</p> <p>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</p> <p>For more information on CBOR equality in Qt, see, <a href="qcborvalue#compare">QCborValue::compare</a>().</p> <p><b>See also </b><a href="qcbormap#compare">compare</a>(), <a href="qcborvalue#operator-eq-eq">QCborValue::operator==</a>(), QCborMap::operator==(), <a href="qcbormap#operator-not-eq">operator!=</a>(), and <a href="qcbormap#operator-lt">operator&lt;</a>().</p>   <h3 class="fn" id="operator-5b-5d">
const <span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">operator[]</span>(<span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> <i>key</i>) const
</h3> <p>Returns the <a href="qcborvalue">QCborValue</a> element in this map that corresponds to key <i>key</i>, if there is one. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p> <p>If the map does not contain key <i>key</i>, this function returns a <a href="qcborvalue">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will return. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>operator[](<a href="qlatin1string">QLatin1String</a>), operator[](const <a href="qstring">QString</a> &amp;), operator[](const QCborOperator[] &amp;)</p> <p><b>See also </b><a href="qcbormap#value">value</a>(qint64), <a href="qcbormap#find">find</a>(qint64), <a href="qcbormap#constFind">constFind</a>(qint64), <a href="qcbormap#remove">remove</a>(qint64), and <a href="qcbormap#contains">contains</a>(qint64).</p>   <h3 class="fn" id="operator-5b-5d-1">
const <span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">operator[]</span>(<span class="type"><a href="qlatin1string">QLatin1String</a></span> <i>key</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns the <a href="qcborvalue">QCborValue</a> element in this map that corresponds to key <i>key</i>, if there is one.</p> <p>If the map does not contain key <i>key</i>, this function returns a <a href="qcborvalue">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will return. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>operator[](qint64), operator[](const <a href="qstring">QString</a> &amp;), operator[](const QCborOperator[] &amp;)</p> <p><b>See also </b><a href="qcbormap#value-1">value</a>(QLatin1String), <a href="qcbormap#find-1">find</a>(QLatin1String), <a href="qcbormap#constFind-1">constFind</a>(QLatin1String), <a href="qcbormap#remove-1">remove</a>(QLatin1String), and <a href="qcbormap#contains-1">contains</a>(QLatin1String).</p>   <h3 class="fn" id="operator-5b-5d-2">
const <span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">operator[]</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>key</i>) const
</h3> <p>This is an overloaded function.</p> <p>Returns the <a href="qcborvalue">QCborValue</a> element in this map that corresponds to key <i>key</i>, if there is one.</p> <p>If the map does not contain key <i>key</i>, this function returns a <a href="qcborvalue">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will return. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>operator[](qint64), operator[](<a href="qlatin1string">QLatin1String</a>), operator[](const QCborOperator[] &amp;)</p> <p><b>See also </b><a href="qcbormap#value-2">value</a>(const QString &amp;), <a href="qcbormap#find-2">find</a>(const QString &amp;), <a href="qcbormap#constFind-2">constFind</a>(const QString &amp;), <a href="qcbormap#remove-2">remove</a>(const QString &amp;), and <a href="qcbormap#contains-2">contains</a>(const QString &amp;).</p>   <h3 class="fn" id="operator-5b-5d-3">
const <span class="type"><a href="qcborvalue">QCborValue</a></span> QCborMap::<span class="name">operator[]</span>(const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>key</i>) const
</h3> <p>Returns the <a href="qcborvalue">QCborValue</a> element in this map that corresponds to key <i>key</i>, if there is one.</p> <p>If the map does not contain key <i>key</i>, this function returns a <a href="qcborvalue">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one this function will return. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p>operator[](qint64), operator[](<a href="qlatin1string">QLatin1String</a>), operator[](const QCborOperator[] &amp;)</p> <p><b>See also </b><a href="qcbormap#value-3">value</a>(const QCborValue &amp;), <a href="qcbormap#find-3">find</a>(const QCborValue &amp;), <a href="qcbormap#constFind-3">constFind</a>(const QCborValue &amp;), <a href="qcbormap#remove-3">remove</a>(const QCborValue &amp;), and <a href="qcbormap#contains-3">contains</a>(const QCborValue &amp;).</p>   <h3 class="fn" id="operator-5b-5d-5">
<span class="type"><a href="qcborvalueref">QCborValueRef</a></span> QCborMap::<span class="name">operator[]</span>(<span class="type"><a href="qtglobal#qint64-typedef">qint64</a></span> <i>key</i>)
</h3> <p>Returns a <a href="qcborvalue#qcborvalueref">QCborValueRef</a> to the value in this map that corresponds to key <i>key</i>. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p> <p><a href="qcborvalue#qcborvalueref">QCborValueRef</a> has the exact same API as <a href="qcborvalue">QCborValue</a>, with one important difference: if you assign new values to it, this map will be updated with that new value.</p> <p>If the map did not have a key equal to <i>key</i>, one is inserted and this function returns a reference to the new value, which will be a <a href="qcborvalue">QCborValue</a> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one the return will reference. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p><b>See also </b><a href="qcbormap#value">value</a>(qint64), <a href="qcbormap#find">find</a>(qint64), <a href="qcbormap#contains">contains</a>(qint64), <a href="qcbormap#remove">remove</a>(qint64), <a href="qcbormap#operator-5b-5d-1">operator[]</a>(QLatin1String), <a href="qcbormap#operator-5b-5d-2">operator[]</a>(const QString &amp;), and <a href="qcbormap#operator-5b-5d-3">operator[]</a>(const QCborValue &amp;).</p>   <h3 class="fn" id="operator-5b-5d-6">
<span class="type"><a href="qcborvalueref">QCborValueRef</a></span> QCborMap::<span class="name">operator[]</span>(<span class="type"><a href="qlatin1string">QLatin1String</a></span> <i>key</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a <a href="qcborvalue#qcborvalueref">QCborValueRef</a> to the value in this map that corresponds to key <i>key</i>.</p> <p><a href="qcborvalue#qcborvalueref">QCborValueRef</a> has the exact same API as <a href="qcborvalue">QCborValue</a>, with one important difference: if you assign new values to it, this map will be updated with that new value.</p> <p>If the map did not have a key equal to <i>key</i>, one is inserted and this function returns a reference to the new value, which will be a <a href="qcborvalue">QCborValue</a> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one the return will reference. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p><b>See also </b><a href="qcbormap#value-1">value</a>(QLatin1String), <a href="qcbormap#find-1">find</a>(QLatin1String), <a href="qcbormap#contains-1">contains</a>(QLatin1String), <a href="qcbormap#remove-1">remove</a>(QLatin1String), <a href="qcbormap#operator-5b-5d">operator[]</a>(qint64), <a href="qcbormap#operator-5b-5d-2">operator[]</a>(const QString &amp;), and <a href="qcbormap#operator-5b-5d-3">operator[]</a>(const QCborValue &amp;).</p>   <h3 class="fn" id="operator-5b-5d-7">
<span class="type"><a href="qcborvalueref">QCborValueRef</a></span> QCborMap::<span class="name">operator[]</span>(const <span class="type"><a href="qstring">QString</a></span> &amp;<i>key</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a <a href="qcborvalue#qcborvalueref">QCborValueRef</a> to the value in this map that corresponds to key <i>key</i>.</p> <p><a href="qcborvalue#qcborvalueref">QCborValueRef</a> has the exact same API as <a href="qcborvalue">QCborValue</a>, with one important difference: if you assign new values to it, this map will be updated with that new value.</p> <p>If the map did not have a key equal to <i>key</i>, one is inserted and this function returns a reference to the new value, which will be a <a href="qcborvalue">QCborValue</a> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one the return will reference. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p><b>See also </b><a href="qcbormap#value-2">value</a>(const QString &amp;), <a href="qcbormap#find-2">find</a>(const QString &amp;), <a href="qcbormap#contains-2">contains</a>(const QString &amp;), <a href="qcbormap#remove-2">remove</a>(const QString &amp;), <a href="qcbormap#operator-5b-5d">operator[]</a>(qint64), <a href="qcbormap#operator-5b-5d-1">operator[]</a>(QLatin1String), and <a href="qcbormap#operator-5b-5d-3">operator[]</a>(const QCborValue &amp;).</p>   <h3 class="fn" id="operator-5b-5d-8">
<span class="type"><a href="qcborvalueref">QCborValueRef</a></span> QCborMap::<span class="name">operator[]</span>(const <span class="type"><a href="qcborvalue">QCborValue</a></span> &amp;<i>key</i>)
</h3> <p>This is an overloaded function.</p> <p>Returns a <a href="qcborvalue#qcborvalueref">QCborValueRef</a> to the value in this map that corresponds to key <i>key</i>.</p> <p><a href="qcborvalue#qcborvalueref">QCborValueRef</a> has the exact same API as <a href="qcborvalue">QCborValue</a>, with one important difference: if you assign new values to it, this map will be updated with that new value.</p> <p>If the map did not have a key equal to <i>key</i>, one is inserted and this function returns a reference to the new value, which will be a <a href="qcborvalue">QCborValue</a> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p> <p>If the map contains more than one key equal to <i>key</i>, it is undefined which one the return will reference. <a href="qcbormap">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p> <p><b>See also </b><a href="qcbormap#value-3">value</a>(const QCborValue &amp;), <a href="qcbormap#find-3">find</a>(const QCborValue &amp;), <a href="qcbormap#contains-3">contains</a>(const QCborValue &amp;), <a href="qcbormap#remove-3">remove</a>(const QCborValue &amp;), <a href="qcbormap#operator-5b-5d">operator[]</a>(qint64), <a href="qcbormap#operator-5b-5d-1">operator[]</a>(QLatin1String), and <a href="qcbormap#operator-5b-5d-2">operator[]</a>(const QString &amp;).</p>
<div class="_attribution">
  <p class="_attribution-p">
    © The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-5.15/qcbormap.html" class="_attribution-link">https://doc.qt.io/qt-5.15/qcbormap.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
