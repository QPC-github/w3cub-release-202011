
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>QVideoFilterRunnable (Class) - Qt 5.15 - W3cubDocs</title>
  
  <meta name="description" content="The QVideoFilterRunnable class represents the implementation of a filter that owns all graphics and computational resources, and performs the actual &hellip;">
  <meta name="keywords" content="qvideofilterrunnable, class, qt, qt~5.15">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/qt~5.15/qvideofilterrunnable.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/qt~5.15.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt~5.15/" class="_nav-link" title="" style="margin-left:0;">Qt 5.15</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">QVideoFilterRunnable Class</h1>  <p>The QVideoFilterRunnable class represents the implementation of a filter that owns all graphics and computational resources, and performs the actual filtering or calculations. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QVideoFilterRunnable&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += multimedia</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 5.5</td>
</tr>
</table>
<p>This class was introduced in Qt 5.5.</p> <ul> <li><a href="https://doc.qt.io/qt-5.15/qvideofilterrunnable-members.html">List of all members, including inherited members</a></li> </ul>  <h2 id="public-types">Public Types
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> enum </td>
<td class="memItemRight bottomAlign">
<b><a href="qvideofilterrunnable#RunFlag-enum">RunFlag</a></b> { LastInChain }</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> flags </td>
<td class="memItemRight bottomAlign"><b><a href="qvideofilterrunnable#RunFlag-enum">RunFlags</a></b></td>
</tr> </table>  <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> virtual QVideoFrame </td>
<td class="memItemRight bottomAlign">
<b><a href="qvideofilterrunnable#run">run</a></b>(QVideoFrame *<i>input</i>, const QVideoSurfaceFormat &amp;<i>surfaceFormat</i>, QVideoFilterRunnable::RunFlags <i>flags</i>) = 0</td>
</tr> </table>    <h2 id="details">Detailed Description
</h2> <p>Video filters are split into <a href="qabstractvideofilter">QAbstractVideoFilter</a> and corresponding QVideoFilterRunnable instances, similar to <a href="qquickitem">QQuickItem</a> and <a href="qsgnode">QSGNode</a>. This is necessary to support threaded rendering scenarios. When using the threaded render loop of the Qt Quick scene graph, all rendering happens on a dedicated thread. QVideoFilterRunnable instances always live on this thread and all its functions, <a href="qvideofilterrunnable#run">run</a>(), the constructor, and the destructor, are guaranteed to be invoked on that thread with the OpenGL context bound. <a href="qabstractvideofilter">QAbstractVideoFilter</a> instances live on the main (GUI) thread, like any other <a href="qobject">QObject</a> and <a href="qquickitem">QQuickItem</a> instances created from QML.</p> <p>Once created, QVideoFilterRunnable instances are managed by Qt Multimedia and will be automatically destroyed and recreated when necessary, for example when the scene graph is invalidated or the <a href="qquickwindow">QQuickWindow</a> changes or is closed. Creation happens via the <a href="qabstractvideofilter#createFilterRunnable">QAbstractVideoFilter::createFilterRunnable</a>() factory function.</p>  <p><b>See also </b><a href="qabstractvideofilter">QAbstractVideoFilter</a>.</p>   <h2>Member Type Documentation</h2>  <h3 class="flags" id="RunFlag-enum">
enum QVideoFilterRunnable::<span class="name">RunFlag</span>flags QVideoFilterRunnable::<span class="name">RunFlags</span>
</h3> <table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr> <tr>
<td class="topAlign"><code>QVideoFilterRunnable::LastInChain</code></td>
<td class="topAlign tblval"><code>0x01</code></td>
<td class="topAlign">Indicates that the filter runnable's associated <a href="qabstractvideofilter">QAbstractVideoFilter</a> is the last in the corresponding <a href="qml-qtmultimedia-videooutput">VideoOutput</a> type's filters list, meaning that the returned frame is the one that is going to be presented to the scene graph without invoking any further filters.</td>
</tr> </table> <p>The RunFlags type is a typedef for <a href="qflags">QFlags</a>&lt;RunFlag&gt;. It stores an OR combination of RunFlag values.</p>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="run">
<code>[pure virtual] </code><span class="type"><a href="qvideoframe">QVideoFrame</a></span> QVideoFilterRunnable::<span class="name">run</span>(<span class="type"><a href="qvideoframe">QVideoFrame</a></span> *<i>input</i>, const <span class="type"><a href="qvideosurfaceformat">QVideoSurfaceFormat</a></span> &amp;<i>surfaceFormat</i>, <span class="type"><a href="qvideofilterrunnable#RunFlag-enum">QVideoFilterRunnable::RunFlags</a></span> <i>flags</i>)
</h3> <p>Reimplement this function to perform filtering or computation on the <i>input</i> video frame. Like the constructor and destructor, this function is always called on the render thread with the OpenGL context bound.</p> <p>Implementations that do not modify the video frame can simply return <i>input</i>.</p> <p>It is safe to access properties of the associated <a href="qabstractvideofilter">QAbstractVideoFilter</a> instance from this function.</p> <p><i>input</i> will not be mapped, it is up to this function to call <a href="qvideoframe#map">QVideoFrame::map</a>() and <a href="qvideoframe#unmap">QVideoFrame::unmap</a>() as necessary.</p> <p><i>surfaceFormat</i> provides additional information, for example it can be used to determine which way is up in the input image as that is important for filters to operate on multiple platforms with multiple cameras.</p> <p><i>flags</i> contains additional information about the filter's invocation. For example the <a href="qvideofilterrunnable#RunFlag-enum">LastInChain</a> flag indicates that the filter is the last in a <a href="qml-qtmultimedia-videooutput">VideoOutput</a>'s associated filter list. This can be very useful in cases where multiple filters are chained together and the work is performed on image data in some custom format (for example a format specific to some computer vision framework). To avoid conversion on every filter in the chain, all intermediate filters can return a <a href="qvideoframe">QVideoFrame</a> hosting data in the custom format. Only the last, where the flag is set, returns a <a href="qvideoframe">QVideoFrame</a> in a format compatible with Qt.</p> <p>Filters that want to expose the results of their computation to Javascript code in QML can declare their own custom signals in the <a href="qabstractvideofilter">QAbstractVideoFilter</a> subclass to indicate the completion of the operation. For filters that only calculate some results and do not modify the video frame, it is also possible to operate asynchronously. They can queue the necessary operations using the compute API and return from this function without emitting any signals. The signal indicating the completion is then emitted only when the compute API indicates that the operations were done and the results are available. Note that it is strongly recommended to represent the filter's output data as a separate instance of <a href="qjsvalue">QJSValue</a> or a <a href="qobject">QObject</a>-derived class which is passed as a parameter to the signal and becomes exposed to the Javascript engine. In case of <a href="qobject">QObject</a> the ownership of this object is controlled by the standard QML rules: if it has no parent, ownership is transferred to the Javascript engine, otherwise it stays with the emitter. Note that the signal connection may be queued,for example when using the threaded render loop of Qt Quick, and so the object must stay valid for a longer time, destroying it right after calling this function is not safe. Using a dedicated results object is guaranteed to be safe even when using threaded rendering. The same is not necessarily true for properties on the <a href="qabstractvideofilter">QAbstractVideoFilter</a> instance itself: properties can safely be read in run() since the gui thread is blocked during that time but writing may become problematic.</p> <p><b>Note: </b>Avoid time consuming operations in this function as they block the entire rendering of the application.</p> <p><b>Note: </b>The handleType() and pixelFormat() of <i>input</i> is completely up to the video decoding backend on the platform in use. On some platforms different forms of input are used depending on the graphics stack. For example, when playing back videos on Windows with the WMF backend, <a href="qvideoframe">QVideoFrame</a> contains OpenGL-wrapped Direct3D textures in case of using ANGLE, but regular pixel data when using desktop OpenGL (opengl32.dll). Similarly, the video file format will often decide if the data is RGB or YUV, but this may also depend on the decoder and the configuration in use. The returned video frame does not have to be in the same format as the input, for example a filter with an input of a <a href="qvideoframe">QVideoFrame</a> backed by system memory can output a <a href="qvideoframe">QVideoFrame</a> with an OpenGL texture handle.</p> <p><b>See also </b><a href="qvideoframe">QVideoFrame</a> and <a href="qvideosurfaceformat">QVideoSurfaceFormat</a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-5.15/qvideofilterrunnable.html" class="_attribution-link">https://doc.qt.io/qt-5.15/qvideofilterrunnable.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
