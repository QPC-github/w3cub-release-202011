
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>API - Jinja 2.11 - W3cubDocs</title>
  
  <meta name="description" content="This document describes the API to Jinja and not the template language (for that, see Template Designer Documentation). It will be most useful as &hellip;">
  <meta name="keywords" content="api, jinja, jinja~2.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/jinja~2.11/api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/jinja~2.11.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/jinja~2.11/" class="_nav-link" title="" style="margin-left:0;">Jinja 2.11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1>API</h1> <p>This document describes the API to Jinja and not the template language (for that, see <a class="reference internal" href="../templates/index"><span class="doc">Template Designer Documentation</span></a>). It will be most useful as reference to those implementing the template interface to the application and not those who are creating Jinja templates.</p>  <h2 id="basics">Basics</h2> <p>Jinja uses a central object called the template <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code>Environment</code></a>. Instances of this class are used to store the configuration and global objects, and are used to load templates from the file system or other locations. Even if you are creating templates from strings by using the constructor of <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code>Template</code></a> class, an environment is created automatically for you, albeit a shared one.</p> <p>Most applications will create one <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code>Environment</code></a> object on application initialization and use that to load templates. In some cases however, it’s useful to have multiple environments side by side, if different configurations are in use.</p> <p>The simplest way to configure Jinja to load templates for your application looks roughly like this:</p> <pre data-language="python">from jinja2 import Environment, PackageLoader, select_autoescape
env = Environment(
    loader=PackageLoader('yourapplication', 'templates'),
    autoescape=select_autoescape(['html', 'xml'])
)
</pre> <p>This will create a template environment with the default settings and a loader that looks up the templates in the <code>templates</code> folder inside the <code>yourapplication</code> python package. Different loaders are available and you can also write your own if you want to load templates from a database or other resources. This also enables autoescaping for HTML and XML files.</p> <p>To load a template from this environment you just have to call the <code>get_template()</code> method which then returns the loaded <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code>Template</code></a>:</p> <pre data-language="python">template = env.get_template('mytemplate.html')
</pre> <p>To render it with some variables, just call the <code>render()</code> method:</p> <pre data-language="python">print(template.render(the='variables', go='here'))
</pre> <p>Using a template loader rather than passing strings to <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code>Template</code></a> or <a class="reference internal" href="#jinja2.Environment.from_string" title="jinja2.Environment.from_string"><code>Environment.from_string()</code></a> has multiple advantages. Besides being a lot easier to use it also enables template inheritance.</p> <div class="admonition-notes-on-autoescaping admonition"> <p class="admonition-title">Notes on Autoescaping</p> <p>In future versions of Jinja we might enable autoescaping by default for security reasons. As such you are encouraged to explicitly configure autoescaping now instead of relying on the default.</p> </div>   <h2 id="unicode">Unicode</h2> <p>Jinja is using Unicode internally which means that you have to pass Unicode objects to the render function or bytestrings that only consist of ASCII characters. Additionally newlines are normalized to one end of line sequence which is per default UNIX style (<code>\n</code>).</p> <p>Python 2.x supports two ways of representing string objects. One is the <code>str</code> type and the other is the <code>unicode</code> type, both of which extend a type called <code>basestring</code>. Unfortunately the default is <code>str</code> which should not be used to store text based information unless only ASCII characters are used. With Python 2.6 it is possible to make <code>unicode</code> the default on a per module level and with Python 3 it will be the default.</p> <p>To explicitly use a Unicode string you have to prefix the string literal with a <code>u</code>: <code>u'Hänsel und Gretel sagen Hallo'</code>. That way Python will store the string as Unicode by decoding the string with the character encoding from the current Python module. If no encoding is specified this defaults to ‘ASCII’ which means that you can’t use any non ASCII identifier.</p> <p>To set a better module encoding add the following comment to the first or second line of the Python module using the Unicode literal:</p> <pre data-language="python"># -*- coding: utf-8 -*-
</pre> <p>We recommend utf-8 as Encoding for Python modules and templates as it’s possible to represent every Unicode character in utf-8 and because it’s backwards compatible to ASCII. For Jinja the default encoding of templates is assumed to be utf-8.</p> <p>It is not possible to use Jinja to process non-Unicode data. The reason for this is that Jinja uses Unicode already on the language level. For example Jinja treats the non-breaking space as valid whitespace inside expressions which requires knowledge of the encoding or operating on an Unicode string.</p> <p>For more details about Unicode in Python have a look at the excellent <a class="reference external" href="https://docs.python.org/3/howto/unicode.html">Unicode documentation</a>.</p> <p>Another important thing is how Jinja is handling string literals in templates. A naive implementation would be using Unicode strings for all string literals but it turned out in the past that this is problematic as some libraries are typechecking against <code>str</code> explicitly. For example <code>datetime.strftime</code> does not accept Unicode arguments. To not break it completely Jinja is returning <code>str</code> for strings that fit into ASCII and for everything else <code>unicode</code>:</p> <pre data-language="python">&gt;&gt;&gt; m = Template(u"{% set a, b = 'foo', 'föö' %}").module
&gt;&gt;&gt; m.a
'foo'
&gt;&gt;&gt; m.b
u'f\xf6\xf6'
</pre>   <h2 id="high-level-api">High Level API</h2> <p>The high-level API is the API you will use in the application to load and render Jinja templates. The <a class="reference internal" href="#low-level-api"><span class="std std-ref">Low Level API</span></a> on the other side is only useful if you want to dig deeper into Jinja or <a class="reference internal" href="../extensions/index#jinja-extensions"><span class="std std-ref">develop extensions</span></a>.</p> <dl class="class"> <dt id="jinja2.Environment">
<code>class jinja2.Environment([options])</code> </dt> <dd>
<p>The core component of Jinja is the <code>Environment</code>. It contains important shared variables like configuration, filters, tests, globals and others. Instances of this class may be modified if they are not shared and if no template was loaded so far. Modifications on environments after the first template was loaded will lead to surprising effects and undefined behavior.</p> <p>Here are the possible initialization parameters:</p>  <dl> <dt>
<code>block_start_string</code> </dt>
<dd>
<p>The string marking the beginning of a block. Defaults to <code>'{%'</code>.</p> </dd> <dt>
<code>block_end_string</code> </dt>
<dd>
<p>The string marking the end of a block. Defaults to <code>'%}'</code>.</p> </dd> <dt>
<code>variable_start_string</code> </dt>
<dd>
<p>The string marking the beginning of a print statement. Defaults to <code>'{{'</code>.</p> </dd> <dt>
<code>variable_end_string</code> </dt>
<dd>
<p>The string marking the end of a print statement. Defaults to <code>'}}'</code>.</p> </dd> <dt>
<code>comment_start_string</code> </dt>
<dd>
<p>The string marking the beginning of a comment. Defaults to <code>'{#'</code>.</p> </dd> <dt>
<code>comment_end_string</code> </dt>
<dd>
<p>The string marking the end of a comment. Defaults to <code>'#}'</code>.</p> </dd> <dt>
<code>line_statement_prefix</code> </dt>
<dd>
<p>If given and a string, this will be used as prefix for line based statements. See also <a class="reference internal" href="../templates/index#line-statements"><span class="std std-ref">Line Statements</span></a>.</p> </dd> <dt>
<code>line_comment_prefix</code> </dt>
<dd>
<p>If given and a string, this will be used as prefix for line based comments. See also <a class="reference internal" href="../templates/index#line-statements"><span class="std std-ref">Line Statements</span></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.2.</span></p> </div> </details>
</dd> <dt>
<code>trim_blocks</code> </dt>
<dd>
<p>If this is set to <code>True</code> the first newline after a block is removed (block, not variable tag!). Defaults to <code>False</code>.</p> </dd> <dt>
<code>lstrip_blocks</code> </dt>
<dd>
<p>If this is set to <code>True</code> leading spaces and tabs are stripped from the start of a line to a block. Defaults to <code>False</code>.</p> </dd> <dt>
<code>newline_sequence</code> </dt>
<dd>
<p>The sequence that starts a newline. Must be one of <code>'\r'</code>, <code>'\n'</code> or <code>'\r\n'</code>. The default is <code>'\n'</code> which is a useful default for Linux and OS X systems as well as web applications.</p> </dd> <dt>
<code>keep_trailing_newline</code> </dt>
<dd>
<p>Preserve the trailing newline when rendering templates. The default is <code>False</code>, which causes a single newline, if present, to be stripped from the end of the template.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> </details>
</dd> <dt>
<code>extensions</code> </dt>
<dd>
<p>List of Jinja extensions to use. This can either be import paths as strings or extension classes. For more information have a look at <a class="reference internal" href="../extensions/index#jinja-extensions"><span class="std std-ref">the extensions documentation</span></a>.</p> </dd> <dt>
<code>optimized</code> </dt>
<dd>
<p>should the optimizer be enabled? Default is <code>True</code>.</p> </dd> <dt>
<code>undefined</code> </dt>
<dd>
<p><a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code>Undefined</code></a> or a subclass of it that is used to represent undefined values in the template.</p> </dd> <dt>
<code>finalize</code> </dt>
<dd>
<p>A callable that can be used to process the result of a variable expression before it is output. For example one can convert <code>None</code> implicitly into an empty string here.</p> </dd> <dt>
<code>autoescape</code> </dt>
<dd>
<p>If set to <code>True</code> the XML/HTML autoescaping feature is enabled by default. For more details about autoescaping see <code>Markup</code>. As of Jinja 2.4 this can also be a callable that is passed the template name and has to return <code>True</code> or <code>False</code> depending on autoescape should be enabled by default.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.4: </span><code>autoescape</code> can now be a function</p> </div> </details>
</dd> <dt>
<code>loader</code> </dt>
<dd>
<p>The template loader for this environment.</p> </dd> <dt>
<code>cache_size</code> </dt>
<dd>
<p>The size of the cache. Per default this is <code>400</code> which means that if more than 400 templates are loaded the loader will clean out the least recently used template. If the cache size is set to <code>0</code> templates are recompiled all the time, if the cache size is <code>-1</code> the cache will not be cleaned.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.8: </span>The cache size was increased to 400 from a low 50.</p> </div> </details>
</dd> <dt>
<code>auto_reload</code> </dt>
<dd>
<p>Some loaders load templates from locations where the template sources may change (ie: file system or database). If <code>auto_reload</code> is set to <code>True</code> (default) every time a template is requested the loader checks if the source changed and if yes, it will reload the template. For higher performance it’s possible to disable that.</p> </dd> <dt>
<code>bytecode_cache</code> </dt>
<dd>
<p>If set to a bytecode cache object, this object will provide a cache for the internal Jinja bytecode so that templates don’t have to be parsed if they were not changed.</p> <p>See <a class="reference internal" href="#bytecode-cache"><span class="std std-ref">Bytecode Cache</span></a> for more information.</p> </dd> <dt>
<code>enable_async</code> </dt>
<dd>
<p>If set to true this enables async template execution which allows you to take advantage of newer Python features. This requires Python 3.6 or later.</p> </dd> </dl>  <dl class="attribute"> <dt id="jinja2.Environment.shared">
<code>shared</code> </dt> <dd>
<p>If a template was created by using the <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code>Template</code></a> constructor an environment is created automatically. These environments are created as shared environments which means that multiple templates may have the same anonymous environment. For all shared environments this attribute is <code>True</code>, else <code>False</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Environment.sandboxed">
<code>sandboxed</code> </dt> <dd>
<p>If the environment is sandboxed this attribute is <code>True</code>. For the sandbox mode have a look at the documentation for the <a class="reference internal" href="../sandbox/index#jinja2.sandbox.SandboxedEnvironment" title="jinja2.sandbox.SandboxedEnvironment"><code>SandboxedEnvironment</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Environment.filters">
<code>filters</code> </dt> <dd>
<p>A dict of filters for this environment. As long as no template was loaded it’s safe to add new filters or remove old. For custom filters see <a class="reference internal" href="#writing-filters"><span class="std std-ref">Custom Filters</span></a>. For valid filter names have a look at <a class="reference internal" href="#identifier-naming"><span class="std std-ref">Notes on Identifiers</span></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Environment.tests">
<code>tests</code> </dt> <dd>
<p>A dict of test functions for this environment. As long as no template was loaded it’s safe to modify this dict. For custom tests see <a class="reference internal" href="#writing-tests"><span class="std std-ref">Custom Tests</span></a>. For valid test names have a look at <a class="reference internal" href="#identifier-naming"><span class="std std-ref">Notes on Identifiers</span></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Environment.globals">
<code>globals</code> </dt> <dd>
<p>A dict of global variables. These variables are always available in a template. As long as no template was loaded it’s safe to modify this dict. For more details see <a class="reference internal" href="#global-namespace"><span class="std std-ref">The Global Namespace</span></a>. For valid object names have a look at <a class="reference internal" href="#identifier-naming"><span class="std std-ref">Notes on Identifiers</span></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Environment.policies">
<code>policies</code> </dt> <dd>
<p>A dictionary with <a class="reference internal" href="#policies"><span class="std std-ref">Policies</span></a>. These can be reconfigured to change the runtime behavior or certain template features. Usually these are security related.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Environment.code_generator_class">
<code>code_generator_class</code> </dt> <dd>
<p>The class used for code generation. This should not be changed in most cases, unless you need to modify the Python code a template compiles to.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Environment.context_class">
<code>context_class</code> </dt> <dd>
<p>The context used for templates. This should not be changed in most cases, unless you need to modify internals of how template variables are handled. For details, see <a class="reference internal" href="#jinja2.runtime.Context" title="jinja2.runtime.Context"><code>Context</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.overlay">
<code>overlay([options])</code> </dt> <dd>
<p>Create a new overlay environment that shares all the data with the current environment except for cache and the overridden attributes. Extensions cannot be removed for an overlayed environment. An overlayed environment automatically gets all the extensions of the environment it is linked to plus optional extra extensions.</p> <p>Creating overlays should happen after the initial environment was set up completely. Not all attributes are truly linked, some are just copied over so modifications on the original environment may not shine through.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.undefined">
<code>undefined([hint, obj, name, exc])</code> </dt> <dd>
<p>Creates a new <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code>Undefined</code></a> object for <code>name</code>. This is useful for filters or functions that may return undefined objects for some operations. All parameters except of <code>hint</code> should be provided as keyword parameters for better readability. The <code>hint</code> is used as error message for the exception if provided, otherwise the error message will be generated from <code>obj</code> and <code>name</code> automatically. The exception provided as <code>exc</code> is raised if something with the generated undefined object is done that the undefined object does not allow. The default exception is <a class="reference internal" href="#jinja2.UndefinedError" title="jinja2.UndefinedError"><code>UndefinedError</code></a>. If a <code>hint</code> is provided the <code>name</code> may be omitted.</p> <p>The most common way to create an undefined object is by providing a name only:</p> <pre data-language="python">return environment.undefined(name='some_name')
</pre> <p>This means that the name <code>some_name</code> is not defined. If the name was from an attribute of an object it makes sense to tell the undefined object the holder object to improve the error message:</p> <pre data-language="python">if not hasattr(obj, 'attr'):
    return environment.undefined(obj=obj, name='attr')
</pre> <p>For a more complex example you can provide a hint. For example the <a class="reference internal" href="../templates/index#first" title="first"><code>first()</code></a> filter creates an undefined object that way:</p> <pre data-language="python">return environment.undefined('no first item, sequence was empty')
</pre> <p>If it the <code>name</code> or <code>obj</code> is known (for example because an attribute was accessed) it should be passed to the undefined object, even if a custom <code>hint</code> is provided. This gives undefined objects the possibility to enhance the error message.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.add_extension">
<code>add_extension(extension)</code> </dt> <dd>
<p>Adds an extension after the environment was created.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.5.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.compile_expression">
<code>compile_expression(source, undefined_to_none=True)</code> </dt> <dd>
<p>A handy helper method that returns a callable that accepts keyword arguments that appear as variables in the expression. If called it returns the result of the expression.</p> <p>This is useful if applications want to use the same rules as Jinja in template “configuration files” or similar situations.</p> <p>Example usage:</p> <pre data-language="python">&gt;&gt;&gt; env = Environment()
&gt;&gt;&gt; expr = env.compile_expression('foo == 42')
&gt;&gt;&gt; expr(foo=23)
False
&gt;&gt;&gt; expr(foo=42)
True
</pre> <p>Per default the return value is converted to <code>None</code> if the expression returns an undefined value. This can be changed by setting <code>undefined_to_none</code> to <code>False</code>.</p> <pre data-language="python">&gt;&gt;&gt; env.compile_expression('var')() is None
True
&gt;&gt;&gt; env.compile_expression('var', undefined_to_none=False)()
Undefined
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.1.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.compile_templates">
<code>compile_templates(target, extensions=None, filter_func=None, zip='deflated', log_function=None, ignore_errors=True, py_compile=False)</code> </dt> <dd>
<p>Finds all the templates the loader can find, compiles them and stores them in <code>target</code>. If <code>zip</code> is <code>None</code>, instead of in a zipfile, the templates will be stored in a directory. By default a deflate zip algorithm is used. To switch to the stored algorithm, <code>zip</code> can be set to <code>'stored'</code>.</p> <p><code>extensions</code> and <code>filter_func</code> are passed to <a class="reference internal" href="#jinja2.Environment.list_templates" title="jinja2.Environment.list_templates"><code>list_templates()</code></a>. Each template returned will be compiled to the target folder or zipfile.</p> <p>By default template compilation errors are ignored. In case a log function is provided, errors are logged. If you want template syntax errors to abort the compilation you can set <code>ignore_errors</code> to <code>False</code> and you will get an exception on syntax errors.</p> <p>If <code>py_compile</code> is set to <code>True</code> .pyc files will be written to the target instead of standard .py files. This flag does not do anything on pypy and Python 3 where pyc files are not picked up by itself and don’t give much benefit.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.extend">
<code>extend(**attributes)</code> </dt> <dd>
<p>Add the items to the instance of the environment if they do not exist yet. This is used by <a class="reference internal" href="../extensions/index#writing-extensions"><span class="std std-ref">extensions</span></a> to register callbacks and configuration values without breaking inheritance.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.from_string">
<code>from_string(source, globals=None, template_class=None)</code> </dt> <dd>
<p>Load a template from a string. This parses the source given and returns a <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code>Template</code></a> object.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.get_or_select_template">
<code>get_or_select_template(template_name_or_list, parent=None, globals=None)</code> </dt> <dd>
<p>Does a typecheck and dispatches to <a class="reference internal" href="#jinja2.Environment.select_template" title="jinja2.Environment.select_template"><code>select_template()</code></a> if an iterable of template names is given, otherwise to <a class="reference internal" href="#jinja2.Environment.get_template" title="jinja2.Environment.get_template"><code>get_template()</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.get_template">
<code>get_template(name, parent=None, globals=None)</code> </dt> <dd>
<p>Load a template from the loader. If a loader is configured this method asks the loader for the template and returns a <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code>Template</code></a>. If the <code>parent</code> parameter is not <code>None</code>, <a class="reference internal" href="#jinja2.Environment.join_path" title="jinja2.Environment.join_path"><code>join_path()</code></a> is called to get the real template name before loading.</p> <p>The <code>globals</code> parameter can be used to provide template wide globals. These variables are available in the context at render time.</p> <p>If the template does not exist a <a class="reference internal" href="#jinja2.TemplateNotFound" title="jinja2.TemplateNotFound"><code>TemplateNotFound</code></a> exception is raised.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.4: </span>If <code>name</code> is a <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code>Template</code></a> object it is returned from the function unchanged.</p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.join_path">
<code>join_path(template, parent)</code> </dt> <dd>
<p>Join a template with the parent. By default all the lookups are relative to the loader root so this method returns the <code>template</code> parameter unchanged, but if the paths should be relative to the parent template, this function can be used to calculate the real template name.</p> <p>Subclasses may override this method and implement template path joining here.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.list_templates">
<code>list_templates(extensions=None, filter_func=None)</code> </dt> <dd>
<p>Returns a list of templates for this environment. This requires that the loader supports the loader’s <code>list_templates()</code> method.</p> <p>If there are other files in the template folder besides the actual templates, the returned list can be filtered. There are two ways: either <code>extensions</code> is set to a list of file extensions for templates, or a <code>filter_func</code> can be provided which is a callable that is passed a template name and should return <code>True</code> if it should end up in the result list.</p> <p>If the loader does not support that, a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.8)"><code>TypeError</code></a> is raised.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> </details>
</dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.select_template">
<code>select_template(names, parent=None, globals=None)</code> </dt> <dd>
<p>Works like <a class="reference internal" href="#jinja2.Environment.get_template" title="jinja2.Environment.get_template"><code>get_template()</code></a> but tries a number of templates before it fails. If it cannot find any of the templates, it will raise a <a class="reference internal" href="#jinja2.TemplatesNotFound" title="jinja2.TemplatesNotFound"><code>TemplatesNotFound</code></a> exception.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.11: </span>If names is <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code>Undefined</code></a>, an <a class="reference internal" href="#jinja2.UndefinedError" title="jinja2.UndefinedError"><code>UndefinedError</code></a> is raised instead. If no templates were found and names contains <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code>Undefined</code></a>, the message is more helpful.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.4: </span>If <code>names</code> contains a <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code>Template</code></a> object it is returned from the function unchanged.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> </details>
</dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.Template">
<code>class jinja2.Template</code> </dt> <dd>
<p>The central template object. This class represents a compiled template and is used to evaluate it.</p> <p>Normally the template object is generated from an <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code>Environment</code></a> but it also has a constructor that makes it possible to create a template instance directly using the constructor. It takes the same arguments as the environment constructor but it’s not possible to specify a loader.</p> <p>Every template object has a few methods and members that are guaranteed to exist. However it’s important that a template object should be considered immutable. Modifications on the object are not supported.</p> <p>Template objects created from the constructor rather than an environment do have an <code>environment</code> attribute that points to a temporary environment that is probably shared with other templates created with the constructor and compatible settings.</p> <pre data-language="python">&gt;&gt;&gt; template = Template('Hello {{ name }}!')
&gt;&gt;&gt; template.render(name='John Doe') == u'Hello John Doe!'
True
&gt;&gt;&gt; stream = template.stream(name='John Doe')
&gt;&gt;&gt; next(stream) == u'Hello John Doe!'
True
&gt;&gt;&gt; next(stream)
Traceback (most recent call last):
    ...
StopIteration
</pre> <dl class="attribute"> <dt id="jinja2.Template.globals">
<code>globals</code> </dt> <dd>
<p>The dict with the globals of that template. It’s unsafe to modify this dict as it may be shared with other templates or the environment that loaded the template.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Template.name">
<code>name</code> </dt> <dd>
<p>The loading name of the template. If the template was loaded from a string this is <code>None</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Template.filename">
<code>filename</code> </dt> <dd>
<p>The filename of the template on the file system if it was loaded from there. Otherwise this is <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Template.render">
<code>render([context])</code> </dt> <dd>
<p>This method accepts the same arguments as the <code>dict</code> constructor: A dict, a dict subclass or some keyword arguments. If no arguments are given the context will be empty. These two calls do the same:</p> <pre data-language="python">template.render(knights='that say nih')
template.render({'knights': 'that say nih'})
</pre> <p>This will return the rendered template as unicode string.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Template.generate">
<code>generate([context])</code> </dt> <dd>
<p>For very large templates it can be useful to not render the whole template at once but evaluate each statement after another and yield piece for piece. This method basically does exactly that and returns a generator that yields one item after another as unicode strings.</p> <p>It accepts the same arguments as <a class="reference internal" href="#jinja2.Template.render" title="jinja2.Template.render"><code>render()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Template.stream">
<code>stream([context])</code> </dt> <dd>
<p>Works exactly like <a class="reference internal" href="#jinja2.Template.generate" title="jinja2.Template.generate"><code>generate()</code></a> but returns a <code>TemplateStream</code>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Template.render_async">
<code>render_async([context])</code> </dt> <dd>
<p>This works similar to <a class="reference internal" href="#jinja2.Template.render" title="jinja2.Template.render"><code>render()</code></a> but returns a coroutine that when awaited returns the entire rendered template string. This requires the async feature to be enabled.</p> <p>Example usage:</p> <pre data-language="python">await template.render_async(knights='that say nih; asynchronously')
</pre> </dd>
</dl> <dl class="method"> <dt id="jinja2.Template.generate_async">
<code>generate_async([context])</code> </dt> <dd>
<p>An async version of <a class="reference internal" href="#jinja2.Template.generate" title="jinja2.Template.generate"><code>generate()</code></a>. Works very similarly but returns an async iterator instead.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Template.make_module">
<code>make_module(vars=None, shared=False, locals=None)</code> </dt> <dd>
<p>This method works like the <a class="reference internal" href="#jinja2.Template.module" title="jinja2.Template.module"><code>module</code></a> attribute when called without arguments but it will evaluate the template on every call rather than caching it. It’s also possible to provide a dict which is then used as context. The arguments are the same as for the <a class="reference internal" href="#jinja2.Template.new_context" title="jinja2.Template.new_context"><code>new_context()</code></a> method.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Template.module">
<code>property module</code> </dt> <dd>
<p>The template as module. This is used for imports in the template runtime but is also useful if one wants to access exported template variables from the Python layer:</p> <pre data-language="python">&gt;&gt;&gt; t = Template('{% macro foo() %}42{% endmacro %}23')
&gt;&gt;&gt; str(t.module)
'23'
&gt;&gt;&gt; t.module.foo() == u'42'
True
</pre> <p>This attribute is not available if async mode is enabled.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.environment.TemplateStream">
<code>class jinja2.environment.TemplateStream</code> </dt> <dd>
<p>A template stream works pretty much like an ordinary python generator but it can buffer multiple items to reduce the number of total iterations. Per default the output is unbuffered which means that for every unbuffered instruction in the template one unicode string is yielded.</p> <p>If buffering is enabled with a buffer size of 5, five items are combined into a new unicode string. This is mainly useful if you are streaming big templates to a client via WSGI which flushes after each iteration.</p> <dl class="method"> <dt id="jinja2.environment.TemplateStream.disable_buffering">
<code>disable_buffering()</code> </dt> <dd>
<p>Disable the output buffering.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.environment.TemplateStream.dump">
<code>dump(fp, encoding=None, errors='strict')</code> </dt> <dd>
<p>Dump the complete stream into a file or file-like object. Per default unicode strings are written, if you want to encode before writing specify an <code>encoding</code>.</p> <p>Example usage:</p> <pre data-language="python">Template('Hello {{ name }}!').stream(name='foo').dump('hello.html')
</pre> </dd>
</dl> <dl class="method"> <dt id="jinja2.environment.TemplateStream.enable_buffering">
<code>enable_buffering(size=5)</code> </dt> <dd>
<p>Enable buffering. Buffer <code>size</code> items before yielding them.</p> </dd>
</dl> </dd>
</dl>   <h2 id="autoescaping">Autoescaping</h2> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.4.</span></p> </div> </details><p>Jinja now comes with autoescaping support. As of Jinja 2.9 the autoescape extension is removed and built-in. However autoescaping is not yet enabled by default though this will most likely change in the future. It’s recommended to configure a sensible default for autoescaping. This makes it possible to enable and disable autoescaping on a per-template basis (HTML versus text for instance).</p> <dl class="function"> <dt id="jinja2.select_autoescape">
<code>jinja2.select_autoescape(enabled_extensions=('html', 'htm', 'xml'), disabled_extensions=(), default_for_string=True, default=False)</code> </dt> <dd>
<p>Intelligently sets the initial value of autoescaping based on the filename of the template. This is the recommended way to configure autoescaping if you do not want to write a custom function yourself.</p> <p>If you want to enable it for all templates created from strings or for all templates with <code>.html</code> and <code>.xml</code> extensions:</p> <pre data-language="python">from jinja2 import Environment, select_autoescape
env = Environment(autoescape=select_autoescape(
    enabled_extensions=('html', 'xml'),
    default_for_string=True,
))
</pre> <p>Example configuration to turn it on at all times except if the template ends with <code>.txt</code>:</p> <pre data-language="python">from jinja2 import Environment, select_autoescape
env = Environment(autoescape=select_autoescape(
    disabled_extensions=('txt',),
    default_for_string=True,
    default=True,
))
</pre> <p>The <code>enabled_extensions</code> is an iterable of all the extensions that autoescaping should be enabled for. Likewise <code>disabled_extensions</code> is a list of all templates it should be disabled for. If a template is loaded from a string then the default from <code>default_for_string</code> is used. If nothing matches then the initial value of autoescaping is set to the value of <code>default</code>.</p> <p>For security reasons this function operates case insensitive.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.9.</span></p> </div> </details>
</dd>
</dl> <p>Here a recommended setup that enables autoescaping for templates ending in <code>'.html'</code>, <code>'.htm'</code> and <code>'.xml'</code> and disabling it by default for all other extensions. You can use the <a class="reference internal" href="#jinja2.select_autoescape" title="jinja2.select_autoescape"><code>select_autoescape()</code></a> function for this:</p> <pre data-language="python">from jinja2 import Environment, PackageLoader, select_autoescape
env = Environment(autoescape=select_autoescape(['html', 'htm', 'xml']),
                  loader=PackageLoader('mypackage'))
</pre> <p>The <code>select_autoescape()</code> function returns a function that works roughly like this:</p> <pre data-language="python">def autoescape(template_name):
    if template_name is None:
        return False
    if template_name.endswith(('.html', '.htm', '.xml'))
</pre> <p>When implementing a guessing autoescape function, make sure you also accept <code>None</code> as valid template name. This will be passed when generating templates from strings. You should always configure autoescaping as defaults in the future might change.</p> <p>Inside the templates the behaviour can be temporarily changed by using the <code>autoescape</code> block (see <a class="reference internal" href="../templates/index#autoescape-overrides"><span class="std std-ref">Autoescape Overrides</span></a>).</p>   <h2 id="identifier-naming">Notes on Identifiers</h2> <p id="notes-on-identifiers">Jinja uses Python naming rules. Valid identifiers can be any combination of Unicode characters accepted by Python.</p> <p>Filters and tests are looked up in separate namespaces and have slightly modified identifier syntax. Filters and tests may contain dots to group filters and tests by topic. For example it’s perfectly valid to add a function into the filter dict and call it <code>to.unicode</code>. The regular expression for filter and test identifiers is <code>[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)*`</code>.</p>   <h2 id="undefined-types">Undefined Types</h2> <p>These classes can be used as undefined types. The <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code>Environment</code></a> constructor takes an <code>undefined</code> parameter that can be one of those classes or a custom subclass of <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code>Undefined</code></a>. Whenever the template engine is unable to look up a name or access an attribute one of those objects is created and returned. Some operations on undefined values are then allowed, others fail.</p> <p>The closest to regular Python behavior is the <a class="reference internal" href="#jinja2.StrictUndefined" title="jinja2.StrictUndefined"><code>StrictUndefined</code></a> which disallows all operations beside testing if it’s an undefined object.</p> <dl class="class"> <dt id="jinja2.Undefined">
<code>class jinja2.Undefined</code> </dt> <dd>
<p>The default undefined type. This undefined type can be printed and iterated over, but every other access will raise an <a class="reference internal" href="#jinja2.UndefinedError" title="jinja2.UndefinedError"><code>UndefinedError</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; foo = Undefined(name='foo')
&gt;&gt;&gt; str(foo)
''
&gt;&gt;&gt; not foo
True
&gt;&gt;&gt; foo + 42
Traceback (most recent call last):
  ...
jinja2.exceptions.UndefinedError: 'foo' is undefined
</pre> <dl class="attribute"> <dt id="jinja2.Undefined._undefined_hint">
<code>_undefined_hint</code> </dt> <dd>
<p>Either <code>None</code> or an unicode string with the error message for the undefined object.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Undefined._undefined_obj">
<code>_undefined_obj</code> </dt> <dd>
<p>Either <code>None</code> or the owner object that caused the undefined object to be created (for example because an attribute does not exist).</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Undefined._undefined_name">
<code>_undefined_name</code> </dt> <dd>
<p>The name for the undefined variable / attribute or just <code>None</code> if no such information exists.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Undefined._undefined_exception">
<code>_undefined_exception</code> </dt> <dd>
<p>The exception that the undefined object wants to raise. This is usually one of <a class="reference internal" href="#jinja2.UndefinedError" title="jinja2.UndefinedError"><code>UndefinedError</code></a> or <code>SecurityError</code>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Undefined._fail_with_undefined_error">
<code>_fail_with_undefined_error(*args, **kwargs)</code> </dt> <dd>
<p>When called with any arguments this method raises <a class="reference internal" href="#jinja2.Undefined._undefined_exception" title="jinja2.Undefined._undefined_exception"><code>_undefined_exception</code></a> with an error message generated from the undefined hints stored on the undefined object.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.ChainableUndefined">
<code>class jinja2.ChainableUndefined</code> </dt> <dd>
<p>An undefined that is chainable, where both <code>__getattr__</code> and <code>__getitem__</code> return itself rather than raising an <a class="reference internal" href="#jinja2.UndefinedError" title="jinja2.UndefinedError"><code>UndefinedError</code></a>.</p> <pre data-language="python">&gt;&gt;&gt; foo = ChainableUndefined(name='foo')
&gt;&gt;&gt; str(foo.bar['baz'])
''
&gt;&gt;&gt; foo.bar['baz'] + 42
Traceback (most recent call last):
  ...
jinja2.exceptions.UndefinedError: 'foo' is undefined
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.11.0.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="jinja2.DebugUndefined">
<code>class jinja2.DebugUndefined</code> </dt> <dd>
<p>An undefined that returns the debug info when printed.</p> <pre data-language="python">&gt;&gt;&gt; foo = DebugUndefined(name='foo')
&gt;&gt;&gt; str(foo)
'{{ foo }}'
&gt;&gt;&gt; not foo
True
&gt;&gt;&gt; foo + 42
Traceback (most recent call last):
  ...
jinja2.exceptions.UndefinedError: 'foo' is undefined
</pre> </dd>
</dl> <dl class="class"> <dt id="jinja2.StrictUndefined">
<code>class jinja2.StrictUndefined</code> </dt> <dd>
<p>An undefined that barks on print and iteration as well as boolean tests and all kinds of comparisons. In other words: you can do nothing with it except checking if it’s defined using the <code>defined</code> test.</p> <pre data-language="python">&gt;&gt;&gt; foo = StrictUndefined(name='foo')
&gt;&gt;&gt; str(foo)
Traceback (most recent call last):
  ...
jinja2.exceptions.UndefinedError: 'foo' is undefined
&gt;&gt;&gt; not foo
Traceback (most recent call last):
  ...
jinja2.exceptions.UndefinedError: 'foo' is undefined
&gt;&gt;&gt; foo + 42
Traceback (most recent call last):
  ...
jinja2.exceptions.UndefinedError: 'foo' is undefined
</pre> </dd>
</dl> <p>There is also a factory function that can decorate undefined objects to implement logging on failures:</p> <dl class="function"> <dt id="jinja2.make_logging_undefined">
<code>jinja2.make_logging_undefined(logger=None, base=None)</code> </dt> <dd>
<p>Given a logger object this returns a new undefined class that will log certain failures. It will log iterations and printing. If no logger is given a default logger is created.</p> <p>Example:</p> <pre data-language="python">logger = logging.getLogger(__name__)
LoggingUndefined = make_logging_undefined(
    logger=logger,
    base=Undefined
)
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.8.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>logger</strong> – the logger to use. If not provided, a default logger is created.</li> <li>
<strong>base</strong> – the base class to add logging functionality to. This defaults to <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code>Undefined</code></a>.</li> </ul> </dd> </dl> </dd>
</dl> <p>Undefined objects are created by calling <a class="reference internal" href="../templates/index#undefined" title="undefined"><code>undefined</code></a>.</p> <div class="admonition-implementation admonition"> <p class="admonition-title">Implementation</p> <p><a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code>Undefined</code></a> objects are implemented by overriding the special <code>__underscore__</code> methods. For example the default <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code>Undefined</code></a> class implements <code>__unicode__</code> in a way that it returns an empty string, however <code>__int__</code> and others still fail with an exception. To allow conversion to int by returning <code>0</code> you can implement your own:</p> <pre data-language="python">class NullUndefined(Undefined):
    def __int__(self):
        return 0
    def __float__(self):
        return 0.0
</pre> <p>To disallow a method, just override it and raise <a class="reference internal" href="#jinja2.Undefined._undefined_exception" title="jinja2.Undefined._undefined_exception"><code>_undefined_exception</code></a>. Because this is a very common idiom in undefined objects there is the helper method <a class="reference internal" href="#jinja2.Undefined._fail_with_undefined_error" title="jinja2.Undefined._fail_with_undefined_error"><code>_fail_with_undefined_error()</code></a> that does the error raising automatically. Here a class that works like the regular <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code>Undefined</code></a> but chokes on iteration:</p> <pre data-language="python">class NonIterableUndefined(Undefined):
    __iter__ = Undefined._fail_with_undefined_error
</pre> </div>   <h2 id="the-context">The Context</h2> <dl class="class"> <dt id="jinja2.runtime.Context">
<code>class jinja2.runtime.Context</code> </dt> <dd>
<p>The template context holds the variables of a template. It stores the values passed to the template and also the names the template exports. Creating instances is neither supported nor useful as it’s created automatically at various stages of the template evaluation and should not be created by hand.</p> <p>The context is immutable. Modifications on <a class="reference internal" href="#jinja2.runtime.Context.parent" title="jinja2.runtime.Context.parent"><code>parent</code></a> <strong>must not</strong> happen and modifications on <a class="reference internal" href="#jinja2.runtime.Context.vars" title="jinja2.runtime.Context.vars"><code>vars</code></a> are allowed from generated template code only. Template filters and global functions marked as <code>contextfunction()</code>s get the active context passed as first argument and are allowed to access the context read-only.</p> <p>The template context supports read only dict operations (<code>get</code>, <code>keys</code>, <code>values</code>, <code>items</code>, <code>iterkeys</code>, <code>itervalues</code>, <code>iteritems</code>, <code>__getitem__</code>, <code>__contains__</code>). Additionally there is a <a class="reference internal" href="#jinja2.runtime.Context.resolve" title="jinja2.runtime.Context.resolve"><code>resolve()</code></a> method that doesn’t fail with a <code>KeyError</code> but returns an <code>Undefined</code> object for missing variables.</p> <dl class="attribute"> <dt id="jinja2.runtime.Context.parent">
<code>parent</code> </dt> <dd>
<p>A dict of read only, global variables the template looks up. These can either come from another <a class="reference internal" href="#jinja2.runtime.Context" title="jinja2.runtime.Context"><code>Context</code></a>, from the <code>Environment.globals</code> or <code>Template.globals</code> or points to a dict created by combining the globals with the variables passed to the render function. It must not be altered.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.runtime.Context.vars">
<code>vars</code> </dt> <dd>
<p>The template local variables. This list contains environment and context functions from the <a class="reference internal" href="#jinja2.runtime.Context.parent" title="jinja2.runtime.Context.parent"><code>parent</code></a> scope as well as local modifications and exported variables from the template. The template will modify this dict during template evaluation but filters and context functions are not allowed to modify it.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.runtime.Context.environment">
<code>environment</code> </dt> <dd>
<p>The environment that loaded the template.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.runtime.Context.exported_vars">
<code>exported_vars</code> </dt> <dd>
<p>This set contains all the names the template exports. The values for the names are in the <a class="reference internal" href="#jinja2.runtime.Context.vars" title="jinja2.runtime.Context.vars"><code>vars</code></a> dict. In order to get a copy of the exported variables as dict, <a class="reference internal" href="#jinja2.runtime.Context.get_exported" title="jinja2.runtime.Context.get_exported"><code>get_exported()</code></a> can be used.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.runtime.Context.name">
<code>name</code> </dt> <dd>
<p>The load name of the template owning this context.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.runtime.Context.blocks">
<code>blocks</code> </dt> <dd>
<p>A dict with the current mapping of blocks in the template. The keys in this dict are the names of the blocks, and the values a list of blocks registered. The last item in each list is the current active block (latest in the inheritance chain).</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.runtime.Context.eval_ctx">
<code>eval_ctx</code> </dt> <dd>
<p>The current <a class="reference internal" href="#eval-context"><span class="std std-ref">Evaluation Context</span></a>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.runtime.Context.call">
<code>call(callable, *args, **kwargs)</code> </dt> <dd>
<p>Call the callable with the arguments and keyword arguments provided but inject the active context or environment as first argument if the callable is a <code>contextfunction()</code> or <code>environmentfunction()</code>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.runtime.Context.get_all">
<code>get_all()</code> </dt> <dd>
<p>Return the complete context as dict including the exported variables. For optimizations reasons this might not return an actual copy so be careful with using it.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.runtime.Context.get_exported">
<code>get_exported()</code> </dt> <dd>
<p>Get a new dict with the exported variables.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.runtime.Context.resolve">
<code>resolve(key)</code> </dt> <dd>
<p>Looks up a variable like <code>__getitem__</code> or <code>get</code> but returns an <code>Undefined</code> object with the name of the name looked up.</p> </dd>
</dl> </dd>
</dl> <div class="admonition-implementation admonition"> <p class="admonition-title">Implementation</p> <p>Context is immutable for the same reason Python’s frame locals are immutable inside functions. Both Jinja and Python are not using the context / frame locals as data storage for variables but only as primary data source.</p> <p>When a template accesses a variable the template does not define, Jinja looks up the variable in the context, after that the variable is treated as if it was defined in the template.</p> </div>   <h2 id="id1">Loaders</h2> <p id="loaders">Loaders are responsible for loading templates from a resource such as the file system. The environment will keep the compiled modules in memory like Python’s <code>sys.modules</code>. Unlike <code>sys.modules</code> however this cache is limited in size by default and templates are automatically reloaded. All loaders are subclasses of <a class="reference internal" href="#jinja2.BaseLoader" title="jinja2.BaseLoader"><code>BaseLoader</code></a>. If you want to create your own loader, subclass <a class="reference internal" href="#jinja2.BaseLoader" title="jinja2.BaseLoader"><code>BaseLoader</code></a> and override <code>get_source</code>.</p> <dl class="class"> <dt id="jinja2.BaseLoader">
<code>class jinja2.BaseLoader</code> </dt> <dd>
<p>Baseclass for all loaders. Subclass this and override <code>get_source</code> to implement a custom loading mechanism. The environment provides a <code>get_template</code> method that calls the loader’s <code>load</code> method to get the <a class="reference internal" href="#jinja2.Template" title="jinja2.Template"><code>Template</code></a> object.</p> <p>A very basic example for a loader that looks up templates on the file system could look like this:</p> <pre data-language="python">from jinja2 import BaseLoader, TemplateNotFound
from os.path import join, exists, getmtime

class MyLoader(BaseLoader):

    def __init__(self, path):
        self.path = path

    def get_source(self, environment, template):
        path = join(self.path, template)
        if not exists(path):
            raise TemplateNotFound(template)
        mtime = getmtime(path)
        with file(path) as f:
            source = f.read().decode('utf-8')
        return source, path, lambda: mtime == getmtime(path)
</pre> <dl class="method"> <dt id="jinja2.BaseLoader.get_source">
<code>get_source(environment, template)</code> </dt> <dd>
<p>Get the template source, filename and reload helper for a template. It’s passed the environment and template name and has to return a tuple in the form <code>(source, filename, uptodate)</code> or raise a <code>TemplateNotFound</code> error if it can’t locate the template.</p> <p>The source part of the returned tuple must be the source of the template as unicode string or a ASCII bytestring. The filename should be the name of the file on the filesystem if it was loaded from there, otherwise <code>None</code>. The filename is used by python for the tracebacks if no loader extension is used.</p> <p>The last item in the tuple is the <code>uptodate</code> function. If auto reloading is enabled it’s always called to check if the template changed. No arguments are passed so the function must store the old state somewhere (for example in a closure). If it returns <code>False</code> the template will be reloaded.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.BaseLoader.load">
<code>load(environment, name, globals=None)</code> </dt> <dd>
<p>Loads a template. This method looks up the template in the cache or loads one by calling <a class="reference internal" href="#jinja2.BaseLoader.get_source" title="jinja2.BaseLoader.get_source"><code>get_source()</code></a>. Subclasses should not override this method as loaders working on collections of other loaders (such as <a class="reference internal" href="#jinja2.PrefixLoader" title="jinja2.PrefixLoader"><code>PrefixLoader</code></a> or <a class="reference internal" href="#jinja2.ChoiceLoader" title="jinja2.ChoiceLoader"><code>ChoiceLoader</code></a>) will not call this method but <code>get_source</code> directly.</p> </dd>
</dl> </dd>
</dl> <p>Here a list of the builtin loaders Jinja provides:</p> <dl class="class"> <dt id="jinja2.FileSystemLoader">
<code>class jinja2.FileSystemLoader(searchpath, encoding='utf-8', followlinks=False)</code> </dt> <dd>
<p>Loads templates from the file system. This loader can find templates in folders on the file system and is the preferred way to load them.</p> <p>The loader takes the path to the templates as string, or if multiple locations are wanted a list of them which is then looked up in the given order:</p> <pre data-language="python">&gt;&gt;&gt; loader = FileSystemLoader('/path/to/templates')
&gt;&gt;&gt; loader = FileSystemLoader(['/path/to/templates', '/other/path'])
</pre> <p>Per default the template encoding is <code>'utf-8'</code> which can be changed by setting the <code>encoding</code> parameter to something else.</p> <p>To follow symbolic links, set the <em>followlinks</em> parameter to <code>True</code>:</p> <pre data-language="python">&gt;&gt;&gt; loader = FileSystemLoader('/path/to/templates', followlinks=True)
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.8: </span>The <code>followlinks</code> parameter was added.</p> </div> </details>
</dd>
</dl> <dl class="class"> <dt id="jinja2.PackageLoader">
<code>class jinja2.PackageLoader(package_name, package_path='templates', encoding='utf-8')</code> </dt> <dd>
<p>Load templates from python eggs or packages. It is constructed with the name of the python package and the path to the templates in that package:</p> <pre data-language="python">loader = PackageLoader('mypackage', 'views')
</pre> <p>If the package path is not given, <code>'templates'</code> is assumed.</p> <p>Per default the template encoding is <code>'utf-8'</code> which can be changed by setting the <code>encoding</code> parameter to something else. Due to the nature of eggs it’s only possible to reload templates if the package was loaded from the file system and not a zip file.</p> </dd>
</dl> <dl class="class"> <dt id="jinja2.DictLoader">
<code>class jinja2.DictLoader(mapping)</code> </dt> <dd>
<p>Loads a template from a python dict. It’s passed a dict of unicode strings bound to template names. This loader is useful for unittesting:</p> <pre data-language="python">&gt;&gt;&gt; loader = DictLoader({'index.html': 'source here'})
</pre> <p>Because auto reloading is rarely useful this is disabled per default.</p> </dd>
</dl> <dl class="class"> <dt id="jinja2.FunctionLoader">
<code>class jinja2.FunctionLoader(load_func)</code> </dt> <dd>
<p>A loader that is passed a function which does the loading. The function receives the name of the template and has to return either an unicode string with the template source, a tuple in the form <code>(source,
filename, uptodatefunc)</code> or <code>None</code> if the template does not exist.</p> <pre data-language="python">&gt;&gt;&gt; def load_template(name):
...     if name == 'index.html':
...         return '...'
...
&gt;&gt;&gt; loader = FunctionLoader(load_template)
</pre> <p>The <code>uptodatefunc</code> is a function that is called if autoreload is enabled and has to return <code>True</code> if the template is still up to date. For more details have a look at <a class="reference internal" href="#jinja2.BaseLoader.get_source" title="jinja2.BaseLoader.get_source"><code>BaseLoader.get_source()</code></a> which has the same return value.</p> </dd>
</dl> <dl class="class"> <dt id="jinja2.PrefixLoader">
<code>class jinja2.PrefixLoader(mapping, delimiter='/')</code> </dt> <dd>
<p>A loader that is passed a dict of loaders where each loader is bound to a prefix. The prefix is delimited from the template by a slash per default, which can be changed by setting the <code>delimiter</code> argument to something else:</p> <pre data-language="python">loader = PrefixLoader({
    'app1':     PackageLoader('mypackage.app1'),
    'app2':     PackageLoader('mypackage.app2')
})
</pre> <p>By loading <code>'app1/index.html'</code> the file from the app1 package is loaded, by loading <code>'app2/index.html'</code> the file from the second.</p> </dd>
</dl> <dl class="class"> <dt id="jinja2.ChoiceLoader">
<code>class jinja2.ChoiceLoader(loaders)</code> </dt> <dd>
<p>This loader works like the <code>PrefixLoader</code> just that no prefix is specified. If a template could not be found by one loader the next one is tried.</p> <pre data-language="python">&gt;&gt;&gt; loader = ChoiceLoader([
...     FileSystemLoader('/path/to/user/templates'),
...     FileSystemLoader('/path/to/system/templates')
... ])
</pre> <p>This is useful if you want to allow users to override builtin templates from a different location.</p> </dd>
</dl> <dl class="class"> <dt id="jinja2.ModuleLoader">
<code>class jinja2.ModuleLoader(path)</code> </dt> <dd>
<p>This loader loads templates from precompiled templates.</p> <p>Example usage:</p> <pre data-language="python">&gt;&gt;&gt; loader = ChoiceLoader([
...     ModuleLoader('/path/to/compiled/templates'),
...     FileSystemLoader('/path/to/templates')
... ])
</pre> <p>Templates can be precompiled with <a class="reference internal" href="#jinja2.Environment.compile_templates" title="jinja2.Environment.compile_templates"><code>Environment.compile_templates()</code></a>.</p> </dd>
</dl>   <h2 id="id2">Bytecode Cache</h2> <p id="bytecode-cache">Jinja 2.1 and higher support external bytecode caching. Bytecode caches make it possible to store the generated bytecode on the file system or a different location to avoid parsing the templates on first use.</p> <p>This is especially useful if you have a web application that is initialized on the first request and Jinja compiles many templates at once which slows down the application.</p> <p>To use a bytecode cache, instantiate it and pass it to the <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code>Environment</code></a>.</p> <dl class="class"> <dt id="jinja2.BytecodeCache">
<code>class jinja2.BytecodeCache</code> </dt> <dd>
<p>To implement your own bytecode cache you have to subclass this class and override <a class="reference internal" href="#jinja2.BytecodeCache.load_bytecode" title="jinja2.BytecodeCache.load_bytecode"><code>load_bytecode()</code></a> and <a class="reference internal" href="#jinja2.BytecodeCache.dump_bytecode" title="jinja2.BytecodeCache.dump_bytecode"><code>dump_bytecode()</code></a>. Both of these methods are passed a <a class="reference internal" href="#jinja2.bccache.Bucket" title="jinja2.bccache.Bucket"><code>Bucket</code></a>.</p> <p>A very basic bytecode cache that saves the bytecode on the file system:</p> <pre data-language="python">from os import path

class MyCache(BytecodeCache):

    def __init__(self, directory):
        self.directory = directory

    def load_bytecode(self, bucket):
        filename = path.join(self.directory, bucket.key)
        if path.exists(filename):
            with open(filename, 'rb') as f:
                bucket.load_bytecode(f)

    def dump_bytecode(self, bucket):
        filename = path.join(self.directory, bucket.key)
        with open(filename, 'wb') as f:
            bucket.write_bytecode(f)
</pre> <p>A more advanced version of a filesystem based bytecode cache is part of Jinja.</p> <dl class="method"> <dt id="jinja2.BytecodeCache.clear">
<code>clear()</code> </dt> <dd>
<p>Clears the cache. This method is not used by Jinja but should be implemented to allow applications to clear the bytecode cache used by a particular environment.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.BytecodeCache.dump_bytecode">
<code>dump_bytecode(bucket)</code> </dt> <dd>
<p>Subclasses have to override this method to write the bytecode from a bucket back to the cache. If it unable to do so it must not fail silently but raise an exception.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.BytecodeCache.load_bytecode">
<code>load_bytecode(bucket)</code> </dt> <dd>
<p>Subclasses have to override this method to load bytecode into a bucket. If they are not able to find code in the cache for the bucket, it must not do anything.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="jinja2.bccache.Bucket">
<code>class jinja2.bccache.Bucket(environment, key, checksum)</code> </dt> <dd>
<p>Buckets are used to store the bytecode for one template. It’s created and initialized by the bytecode cache and passed to the loading functions.</p> <p>The buckets get an internal checksum from the cache assigned and use this to automatically reject outdated cache material. Individual bytecode cache subclasses don’t have to care about cache invalidation.</p> <dl class="attribute"> <dt id="jinja2.bccache.Bucket.environment">
<code>environment</code> </dt> <dd>
<p>The <code>Environment</code> that created the bucket.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.bccache.Bucket.key">
<code>key</code> </dt> <dd>
<p>The unique cache key for this bucket</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.bccache.Bucket.code">
<code>code</code> </dt> <dd>
<p>The bytecode if it’s loaded, otherwise <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.bccache.Bucket.bytecode_from_string">
<code>bytecode_from_string(string)</code> </dt> <dd>
<p>Load bytecode from a string.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.bccache.Bucket.bytecode_to_string">
<code>bytecode_to_string()</code> </dt> <dd>
<p>Return the bytecode as string.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.bccache.Bucket.load_bytecode">
<code>load_bytecode(f)</code> </dt> <dd>
<p>Loads bytecode from a file or file like object.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.bccache.Bucket.reset">
<code>reset()</code> </dt> <dd>
<p>Resets the bucket (unloads the bytecode).</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.bccache.Bucket.write_bytecode">
<code>write_bytecode(f)</code> </dt> <dd>
<p>Dump the bytecode into the file or file like object passed.</p> </dd>
</dl> </dd>
</dl> <p>Builtin bytecode caches:</p> <dl class="class"> <dt id="jinja2.FileSystemBytecodeCache">
<code>class jinja2.FileSystemBytecodeCache(directory=None, pattern='__jinja2_%s.cache')</code> </dt> <dd>
<p>A bytecode cache that stores bytecode on the filesystem. It accepts two arguments: The directory where the cache items are stored and a pattern string that is used to build the filename.</p> <p>If no directory is specified a default cache directory is selected. On Windows the user’s temp directory is used, on UNIX systems a directory is created for the user in the system temp directory.</p> <p>The pattern can be used to have multiple separate caches operate on the same directory. The default pattern is <code>'__jinja2_%s.cache'</code>. <code>%s</code> is replaced with the cache key.</p> <pre data-language="python">&gt;&gt;&gt; bcc = FileSystemBytecodeCache('/tmp/jinja_cache', '%s.cache')
</pre> <p>This bytecode cache supports clearing of the cache using the clear method.</p> </dd>
</dl> <dl class="class"> <dt id="jinja2.MemcachedBytecodeCache">
<code>class jinja2.MemcachedBytecodeCache(client, prefix='jinja2/bytecode/', timeout=None, ignore_memcache_errors=True)</code> </dt> <dd>
<p>This class implements a bytecode cache that uses a memcache cache for storing the information. It does not enforce a specific memcache library (tummy’s memcache or cmemcache) but will accept any class that provides the minimal interface required.</p> <p>Libraries compatible with this class:</p> <ul class="simple"> <li><a class="reference external" href="https://github.com/pallets/cachelib">cachelib</a></li> <li><a class="reference external" href="https://pypi.org/project/python-memcached/">python-memcached</a></li> </ul> <p>(Unfortunately the django cache interface is not compatible because it does not support storing binary data, only unicode. You can however pass the underlying cache client to the bytecode cache which is available as <code>django.core.cache.cache._client</code>.)</p> <p>The minimal interface for the client passed to the constructor is this:</p> <dl class="class"> <dt id="jinja2.MemcachedBytecodeCache.MinimalClientInterface">
<code>class MinimalClientInterface</code> </dt> <dd>
<dl class="method"> <dt id="jinja2.MemcachedBytecodeCache.MinimalClientInterface.set">
<code>set(key, value[, timeout])</code> </dt> <dd>
<p>Stores the bytecode in the cache. <code>value</code> is a string and <code>timeout</code> the timeout of the key. If timeout is not provided a default timeout or no timeout should be assumed, if it’s provided it’s an integer with the number of seconds the cache item should exist.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.MemcachedBytecodeCache.MinimalClientInterface.get">
<code>get(key)</code> </dt> <dd>
<p>Returns the value for the cache key. If the item does not exist in the cache the return value must be <code>None</code>.</p> </dd>
</dl> </dd>
</dl> <p>The other arguments to the constructor are the prefix for all keys that is added before the actual cache key and the timeout for the bytecode in the cache system. We recommend a high (or no) timeout.</p> <p>This bytecode cache does not support clearing of used items in the cache. The clear method is a no-operation function.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.7: </span>Added support for ignoring memcache errors through the <code>ignore_memcache_errors</code> parameter.</p> </div> </details>
</dd>
</dl>   <h2 id="async-support">Async Support</h2> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.9.</span></p> </div> </details><p>Jinja supports the Python <code>async</code> and <code>await</code> syntax. For the template designer, this support (when enabled) is entirely transparent, templates continue to look exactly the same. However, developers should be aware of the implementation as it affects what types of APIs you can use.</p> <p>By default, async support is disabled. Enabling it will cause the environment to compile different code behind the scenes in order to handle async and sync code in an asyncio event loop. This has the following implications:</p> <ul class="simple"> <li>Template rendering requires an event loop to be available to the current thread. <a class="reference external" href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.get_event_loop" title="(in Python v3.8)"><code>asyncio.get_event_loop()</code></a> must return an event loop.</li> <li>The compiled code uses <code>await</code> for functions and attributes, and uses <code>async for</code> loops. In order to support using both async and sync functions in this context, a small wrapper is placed around all calls and access, which add overhead compared to purely async code.</li> <li>Sync methods and filters become wrappers around their corresponding async implementations where needed. For example, <code>render</code> invokes <code>async_render</code>, and <code>|map</code> supports async iterables.</li> </ul> <p>Awaitable objects can be returned from functions in templates and any function call in a template will automatically await the result. The <code>await</code> you would normally add in Python is implied. For example, you can provide a method that asynchronously loads data from a database, and from the template designer’s point of view it can be called like any other function.</p>   <h2 id="id3">Policies</h2> <p id="policies">Starting with Jinja 2.9 policies can be configured on the environment which can slightly influence how filters and other template constructs behave. They can be configured with the <a class="reference internal" href="#jinja2.Environment.policies" title="jinja2.Environment.policies"><code>policies</code></a> attribute.</p> <p>Example:</p> <pre data-language="python">env.policies['urlize.rel'] = 'nofollow noopener'
</pre> <dl class="simple"> <dt>
<code>compiler.ascii_str:</code> </dt>
<dd>
<p>This boolean controls on Python 2 if Jinja should store ASCII only literals as bytestring instead of unicode strings. This used to be always enabled for Jinja versions below 2.9 and now can be changed. Traditionally it was done this way since some APIs in Python 2 failed badly for unicode strings (for instance the datetime strftime API). Now however sometimes the inverse is true (for instance str.format). If this is set to False then all strings are stored as unicode internally.</p> </dd> <dt>
<code>truncate.leeway:</code> </dt>
<dd>
<p>Configures the leeway default for the <code>truncate</code> filter. Leeway as introduced in 2.9 but to restore compatibility with older templates it can be configured to <code>0</code> to get the old behavior back. The default is <code>5</code>.</p> </dd> <dt>
<code>urlize.rel:</code> </dt>
<dd>
<p>A string that defines the items for the <code>rel</code> attribute of generated links with the <code>urlize</code> filter. These items are always added. The default is <code>noopener</code>.</p> </dd> <dt>
<code>urlize.target:</code> </dt>
<dd>
<p>The default target that is issued for links from the <code>urlize</code> filter if no other target is defined by the call explicitly.</p> </dd> <dt>
<code>json.dumps_function:</code> </dt>
<dd>
<p>If this is set to a value other than <code>None</code> then the <code>tojson</code> filter will dump with this function instead of the default one. Note that this function should accept arbitrary extra arguments which might be passed in the future from the filter. Currently the only argument that might be passed is <code>indent</code>. The default dump function is <code>json.dumps</code>.</p> </dd> <dt>
<code>json.dumps_kwargs:</code> </dt>
<dd>
<p>Keyword arguments to be passed to the dump function. The default is <code>{'sort_keys': True}</code>.</p> </dd> </dl> <dl class="simple" id="ext-i18n-trimmed"> <dt>
<code>ext.i18n.trimmed:</code> </dt>
<dd>
<p>If this is set to <code>True</code>, <code>{% trans %}</code> blocks of the <a class="reference internal" href="../extensions/index#i18n-extension"><span class="std std-ref">i18n Extension</span></a> will always unify linebreaks and surrounding whitespace as if the <code>trimmed</code> modifier was used.</p> </dd> </dl>   <h2 id="utilities">Utilities</h2> <p>These helper functions and classes are useful if you add custom filters or functions to a Jinja environment.</p> <dl class="function"> <dt id="jinja2.environmentfilter">
<code>jinja2.environmentfilter(f)</code> </dt> <dd>
<p>Decorator for marking environment dependent filters. The current <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code>Environment</code></a> is passed to the filter as first argument.</p> </dd>
</dl> <dl class="function"> <dt id="jinja2.contextfilter">
<code>jinja2.contextfilter(f)</code> </dt> <dd>
<p>Decorator for marking context dependent filters. The current <code>Context</code> will be passed as first argument.</p> </dd>
</dl> <dl class="function"> <dt id="jinja2.evalcontextfilter">
<code>jinja2.evalcontextfilter(f)</code> </dt> <dd>
<p>Decorator for marking eval-context dependent filters. An eval context object is passed as first argument. For more information about the eval context, see <a class="reference internal" href="#eval-context"><span class="std std-ref">Evaluation Context</span></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="jinja2.environmentfunction">
<code>jinja2.environmentfunction(f)</code> </dt> <dd>
<p>This decorator can be used to mark a function or method as environment callable. This decorator works exactly like the <a class="reference internal" href="#jinja2.contextfunction" title="jinja2.contextfunction"><code>contextfunction()</code></a> decorator just that the first argument is the active <a class="reference internal" href="#jinja2.Environment" title="jinja2.Environment"><code>Environment</code></a> and not context.</p> </dd>
</dl> <dl class="function"> <dt id="jinja2.contextfunction">
<code>jinja2.contextfunction(f)</code> </dt> <dd>
<p>This decorator can be used to mark a function or method context callable. A context callable is passed the active <code>Context</code> as first argument when called from the template. This is useful if a function wants to get access to the context or functions provided on the context object. For example a function that returns a sorted list of template variables the current template exports could look like this:</p> <pre data-language="python">@contextfunction
def get_exported_names(context):
    return sorted(context.exported_vars)
</pre> </dd>
</dl> <dl class="function"> <dt id="jinja2.evalcontextfunction">
<code>jinja2.evalcontextfunction(f)</code> </dt> <dd>
<p>This decorator can be used to mark a function or method as an eval context callable. This is similar to the <a class="reference internal" href="#jinja2.contextfunction" title="jinja2.contextfunction"><code>contextfunction()</code></a> but instead of passing the context, an evaluation context object is passed. For more information about the eval context, see <a class="reference internal" href="#eval-context"><span class="std std-ref">Evaluation Context</span></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="jinja2.escape">
<code>jinja2.escape(s)</code> </dt> <dd>
<p>Convert the characters <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>'</code>, and <code>"</code> in string <code>s</code> to HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. This function will not escaped objects that do have an HTML representation such as already escaped data.</p> <p>The return value is a <a class="reference internal" href="#jinja2.Markup" title="jinja2.Markup"><code>Markup</code></a> string.</p> </dd>
</dl> <dl class="function"> <dt id="jinja2.clear_caches">
<code>jinja2.clear_caches()</code> </dt> <dd>
<p>Jinja keeps internal caches for environments and lexers. These are used so that Jinja doesn’t have to recreate environments and lexers all the time. Normally you don’t have to care about that but if you are measuring memory consumption you may want to clean the caches.</p> </dd>
</dl> <dl class="function"> <dt id="jinja2.is_undefined">
<code>jinja2.is_undefined(obj)</code> </dt> <dd>
<p>Check if the object passed is undefined. This does nothing more than performing an instance check against <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code>Undefined</code></a> but looks nicer. This can be used for custom filters or tests that want to react to undefined variables. For example a custom default filter can look like this:</p> <pre data-language="python">def default(var, default=''):
    if is_undefined(var):
        return default
    return var
</pre> </dd>
</dl> <dl class="class"> <dt id="jinja2.Markup">
<code>class jinja2.Markup([string])</code> </dt> <dd>
<p>A string that is ready to be safely inserted into an HTML or XML document, either because it was escaped or because it was marked safe.</p> <p>Passing an object to the constructor converts it to text and wraps it to mark it safe without escaping. To escape the text, use the <a class="reference internal" href="../templates/index#escape" title="escape"><code>escape()</code></a> class method instead.</p> <pre data-language="python">&gt;&gt;&gt; Markup('Hello, &lt;em&gt;World&lt;/em&gt;!')
Markup('Hello, &lt;em&gt;World&lt;/em&gt;!')
&gt;&gt;&gt; Markup(42)
Markup('42')
&gt;&gt;&gt; Markup.escape('Hello, &lt;em&gt;World&lt;/em&gt;!')
Markup('Hello &amp;lt;em&amp;gt;World&amp;lt;/em&amp;gt;!')
</pre> <p>This implements the <code>__html__()</code> interface that some frameworks use. Passing an object that implements <code>__html__()</code> will wrap the output of that method, marking it safe.</p> <pre data-language="python">&gt;&gt;&gt; class Foo:
...     def __html__(self):
...         return '&lt;a href="/foo"&gt;foo&lt;/a&gt;'
...
&gt;&gt;&gt; Markup(Foo())
Markup('&lt;a href="/foo"&gt;foo&lt;/a&gt;')
</pre> <p>This is a subclass of the text type (<code>str</code> in Python 3, <code>unicode</code> in Python 2). It has the same methods as that type, but all methods escape their arguments and return a <code>Markup</code> instance.</p> <pre data-language="python">&gt;&gt;&gt; Markup('&lt;em&gt;%s&lt;/em&gt;') % 'foo &amp; bar'
Markup('&lt;em&gt;foo &amp;amp; bar&lt;/em&gt;')
&gt;&gt;&gt; Markup('&lt;em&gt;Hello&lt;/em&gt; ') + '&lt;foo&gt;'
Markup('&lt;em&gt;Hello&lt;/em&gt; &amp;lt;foo&amp;gt;')
</pre> <dl class="method"> <dt id="jinja2.Markup.escape">
<code>classmethod escape(s)</code> </dt> <dd>
<p>Escape a string. Calls <a class="reference internal" href="../templates/index#escape" title="escape"><code>escape()</code></a> and ensures that for subclasses the correct type is returned.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Markup.striptags">
<code>striptags()</code> </dt> <dd>
<p><a class="reference internal" href="#jinja2.Markup.unescape" title="jinja2.Markup.unescape"><code>unescape()</code></a> the markup, remove tags, and normalize whitespace to single spaces.</p> <pre data-language="python">&gt;&gt;&gt; Markup('Main &amp;raquo;        &lt;em&gt;About&lt;/em&gt;').striptags()
'Main » About'
</pre> </dd>
</dl> <dl class="method"> <dt id="jinja2.Markup.unescape">
<code>unescape()</code> </dt> <dd>
<p>Convert escaped markup back into a text string. This replaces HTML entities with the characters they represent.</p> <pre data-language="python">&gt;&gt;&gt; Markup('Main &amp;raquo; &lt;em&gt;About&lt;/em&gt;').unescape()
'Main » &lt;em&gt;About&lt;/em&gt;'
</pre> </dd>
</dl> </dd>
</dl> <div class="admonition-note admonition"> <p class="admonition-title">Note</p> <p>The Jinja <a class="reference internal" href="#jinja2.Markup" title="jinja2.Markup"><code>Markup</code></a> class is compatible with at least Pylons and Genshi. It’s expected that more template engines and framework will pick up the <code>__html__</code> concept soon.</p> </div>   <h2 id="exceptions">Exceptions</h2> <dl class="exception"> <dt id="jinja2.TemplateError">
<code>exception jinja2.TemplateError(message=None)</code> </dt> <dd>
<p>Baseclass for all template errors.</p> </dd>
</dl> <dl class="exception"> <dt id="jinja2.UndefinedError">
<code>exception jinja2.UndefinedError(message=None)</code> </dt> <dd>
<p>Raised if a template tries to operate on <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code>Undefined</code></a>.</p> </dd>
</dl> <dl class="exception"> <dt id="jinja2.TemplateNotFound">
<code>exception jinja2.TemplateNotFound(name, message=None)</code> </dt> <dd>
<p>Raised if a template does not exist.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.11: </span>If the given name is <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code>Undefined</code></a> and no message was provided, an <a class="reference internal" href="#jinja2.UndefinedError" title="jinja2.UndefinedError"><code>UndefinedError</code></a> is raised.</p> </div> </dd>
</dl> <dl class="exception"> <dt id="jinja2.TemplatesNotFound">
<code>exception jinja2.TemplatesNotFound(names=(), message=None)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#jinja2.TemplateNotFound" title="jinja2.TemplateNotFound"><code>TemplateNotFound</code></a> but raised if multiple templates are selected. This is a subclass of <a class="reference internal" href="#jinja2.TemplateNotFound" title="jinja2.TemplateNotFound"><code>TemplateNotFound</code></a> exception, so just catching the base exception will catch both.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.11: </span>If a name in the list of names is <a class="reference internal" href="#jinja2.Undefined" title="jinja2.Undefined"><code>Undefined</code></a>, a message about it being undefined is shown rather than the empty string.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.2.</span></p> </div> </details>
</dd>
</dl> <dl class="exception"> <dt id="jinja2.TemplateSyntaxError">
<code>exception jinja2.TemplateSyntaxError(message, lineno, name=None, filename=None)</code> </dt> <dd>
<p>Raised to tell the user that there is a problem with the template.</p> <dl class="attribute"> <dt id="jinja2.TemplateSyntaxError.message">
<code>message</code> </dt> <dd>
<p>The error message as utf-8 bytestring.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.TemplateSyntaxError.lineno">
<code>lineno</code> </dt> <dd>
<p>The line number where the error occurred</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.TemplateSyntaxError.name">
<code>name</code> </dt> <dd>
<p>The load name for the template as unicode string.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.TemplateSyntaxError.filename">
<code>filename</code> </dt> <dd>
<p>The filename that loaded the template as bytestring in the encoding of the file system (most likely utf-8 or mbcs on Windows systems).</p> </dd>
</dl> <p>The reason why the filename and error message are bytestrings and not unicode strings is that Python 2.x is not using unicode for exceptions and tracebacks as well as the compiler. This will change with Python 3.</p> </dd>
</dl> <dl class="exception"> <dt id="jinja2.TemplateRuntimeError">
<code>exception jinja2.TemplateRuntimeError(message=None)</code> </dt> <dd>
<p>A generic runtime error in the template engine. Under some situations Jinja may raise this exception.</p> </dd>
</dl> <dl class="exception"> <dt id="jinja2.TemplateAssertionError">
<code>exception jinja2.TemplateAssertionError(message, lineno, name=None, filename=None)</code> </dt> <dd>
<p>Like a template syntax error, but covers cases where something in the template caused an error at compile time that wasn’t necessarily caused by a syntax error. However it’s a direct subclass of <a class="reference internal" href="#jinja2.TemplateSyntaxError" title="jinja2.TemplateSyntaxError"><code>TemplateSyntaxError</code></a> and has the same attributes.</p> </dd>
</dl>   <h2 id="writing-filters">Custom Filters</h2> <p id="custom-filters">Custom filters are just regular Python functions that take the left side of the filter as first argument and the arguments passed to the filter as extra arguments or keyword arguments.</p> <p>For example in the filter <code>{{ 42|myfilter(23) }}</code> the function would be called with <code>myfilter(42, 23)</code>. Here for example a simple filter that can be applied to datetime objects to format them:</p> <pre data-language="python">def datetimeformat(value, format='%H:%M / %d-%m-%Y'):
    return value.strftime(format)
</pre> <p>You can register it on the template environment by updating the <a class="reference internal" href="#jinja2.Environment.filters" title="jinja2.Environment.filters"><code>filters</code></a> dict on the environment:</p> <pre data-language="python">environment.filters['datetimeformat'] = datetimeformat
</pre> <p>Inside the template it can then be used as follows:</p> <pre data-language="jinja">written on: {{ article.pub_date|datetimeformat }}
publication date: {{ article.pub_date|datetimeformat('%d-%m-%Y') }}
</pre> <p>Filters can also be passed the current template context or environment. This is useful if a filter wants to return an undefined value or check the current <code>autoescape</code> setting. For this purpose three decorators exist: <a class="reference internal" href="#jinja2.environmentfilter" title="jinja2.environmentfilter"><code>environmentfilter()</code></a>, <a class="reference internal" href="#jinja2.contextfilter" title="jinja2.contextfilter"><code>contextfilter()</code></a> and <a class="reference internal" href="#jinja2.evalcontextfilter" title="jinja2.evalcontextfilter"><code>evalcontextfilter()</code></a>.</p> <p>Here a small example filter that breaks a text into HTML line breaks and paragraphs and marks the return value as safe HTML string if autoescaping is enabled:</p> <pre data-language="python">import re
from jinja2 import evalcontextfilter, Markup, escape

_paragraph_re = re.compile(r'(?:\r\n|\r(?!\n)|\n){2,}')

@evalcontextfilter
def nl2br(eval_ctx, value):
    result = u'\n\n'.join(u'&lt;p&gt;%s&lt;/p&gt;' % p.replace('\n', Markup('&lt;br&gt;\n'))
                          for p in _paragraph_re.split(escape(value)))
    if eval_ctx.autoescape:
        result = Markup(result)
    return result
</pre> <p>Context filters work the same just that the first argument is the current active <code>Context</code> rather than the environment.</p>   <h2 id="eval-context">Evaluation Context</h2> <p id="evaluation-context">The evaluation context (short eval context or eval ctx) is a new object introduced in Jinja 2.4 that makes it possible to activate and deactivate compiled features at runtime.</p> <p>Currently it is only used to enable and disable the automatic escaping but can be used for extensions as well.</p> <p>In previous Jinja versions filters and functions were marked as environment callables in order to check for the autoescape status from the environment. In new versions it’s encouraged to check the setting from the evaluation context instead.</p> <p>Previous versions:</p> <pre data-language="python">@environmentfilter
def filter(env, value):
    result = do_something(value)
    if env.autoescape:
        result = Markup(result)
    return result
</pre> <p>In new versions you can either use a <a class="reference internal" href="#jinja2.contextfilter" title="jinja2.contextfilter"><code>contextfilter()</code></a> and access the evaluation context from the actual context, or use a <a class="reference internal" href="#jinja2.evalcontextfilter" title="jinja2.evalcontextfilter"><code>evalcontextfilter()</code></a> which directly passes the evaluation context to the function:</p> <pre data-language="python">@contextfilter
def filter(context, value):
    result = do_something(value)
    if context.eval_ctx.autoescape:
        result = Markup(result)
    return result

@evalcontextfilter
def filter(eval_ctx, value):
    result = do_something(value)
    if eval_ctx.autoescape:
        result = Markup(result)
    return result
</pre> <p>The evaluation context must not be modified at runtime. Modifications must only happen with a <a class="reference internal" href="../extensions/index#jinja2.nodes.EvalContextModifier" title="jinja2.nodes.EvalContextModifier"><code>nodes.EvalContextModifier</code></a> and <a class="reference internal" href="../extensions/index#jinja2.nodes.ScopedEvalContextModifier" title="jinja2.nodes.ScopedEvalContextModifier"><code>nodes.ScopedEvalContextModifier</code></a> from an extension, not on the eval context object itself.</p> <dl class="class"> <dt id="jinja2.nodes.EvalContext">
<code>class jinja2.nodes.EvalContext(environment, template_name=None)</code> </dt> <dd>
<p>Holds evaluation time information. Custom attributes can be attached to it in extensions.</p> <dl class="attribute"> <dt id="jinja2.nodes.EvalContext.autoescape">
<code>autoescape</code> </dt> <dd>
<p><code>True</code> or <code>False</code> depending on if autoescaping is active or not.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.nodes.EvalContext.volatile">
<code>volatile</code> </dt> <dd>
<p><code>True</code> if the compiler cannot evaluate some expressions at compile time. At runtime this should always be <code>False</code>.</p> </dd>
</dl> </dd>
</dl>   <h2 id="writing-tests">Custom Tests</h2> <p id="custom-tests">Tests work like filters just that there is no way for a test to get access to the environment or context and that they can’t be chained. The return value of a test should be <code>True</code> or <code>False</code>. The purpose of a test is to give the template designers the possibility to perform type and conformability checks.</p> <p>Here a simple test that checks if a variable is a prime number:</p> <pre data-language="python">import math

def is_prime(n):
    if n == 2:
        return True
    for i in range(2, int(math.ceil(math.sqrt(n))) + 1):
        if n % i == 0:
            return False
    return True
</pre> <p>You can register it on the template environment by updating the <a class="reference internal" href="#jinja2.Environment.tests" title="jinja2.Environment.tests"><code>tests</code></a> dict on the environment:</p> <pre data-language="python">environment.tests['prime'] = is_prime
</pre> <p>A template designer can then use the test like this:</p> <pre data-language="jinja">{% if 42 is prime %}
    42 is a prime number
{% else %}
    42 is not a prime number
{% endif %}
</pre>   <h2 id="global-namespace">The Global Namespace</h2> <p id="the-global-namespace">Variables stored in the <a class="reference internal" href="#jinja2.Environment.globals" title="jinja2.Environment.globals"><code>Environment.globals</code></a> dict are special as they are available for imported templates too, even if they are imported without context. This is the place where you can put variables and functions that should be available all the time. Additionally <a class="reference internal" href="#jinja2.Template.globals" title="jinja2.Template.globals"><code>Template.globals</code></a> exist that are variables available to a specific template that are available to all <a class="reference internal" href="#jinja2.Template.render" title="jinja2.Template.render"><code>render()</code></a> calls.</p>   <h2 id="id4">Low Level API</h2> <p id="low-level-api">The low level API exposes functionality that can be useful to understand some implementation details, debugging purposes or advanced <a class="reference internal" href="../extensions/index#jinja-extensions"><span class="std std-ref">extension</span></a> techniques. Unless you know exactly what you are doing we don’t recommend using any of those.</p> <dl class="method"> <dt id="jinja2.Environment.lex">
<code>Environment.lex(source, name=None, filename=None)</code> </dt> <dd>
<p>Lex the given sourcecode and return a generator that yields tokens as tuples in the form <code>(lineno, token_type, value)</code>. This can be useful for <a class="reference internal" href="../extensions/index#writing-extensions"><span class="std std-ref">extension development</span></a> and debugging templates.</p> <p>This does not perform preprocessing. If you want the preprocessing of the extensions to be applied you have to filter source through the <a class="reference internal" href="#jinja2.Environment.preprocess" title="jinja2.Environment.preprocess"><code>preprocess()</code></a> method.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.parse">
<code>Environment.parse(source, name=None, filename=None)</code> </dt> <dd>
<p>Parse the sourcecode and return the abstract syntax tree. This tree of nodes is used by the compiler to convert the template into executable source- or bytecode. This is useful for debugging or to extract information from templates.</p> <p>If you are <a class="reference internal" href="../extensions/index#writing-extensions"><span class="std std-ref">developing Jinja extensions</span></a> this gives you a good overview of the node tree generated.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Environment.preprocess">
<code>Environment.preprocess(source, name=None, filename=None)</code> </dt> <dd>
<p>Preprocesses the source with all extensions. This is automatically called for all parsing and compiling methods but <em>not</em> for <a class="reference internal" href="#jinja2.Environment.lex" title="jinja2.Environment.lex"><code>lex()</code></a> because there you usually only want the actual source tokenized.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Template.new_context">
<code>Template.new_context(vars=None, shared=False, locals=None)</code> </dt> <dd>
<p>Create a new <code>Context</code> for this template. The vars provided will be passed to the template. Per default the globals are added to the context. If shared is set to <code>True</code> the data is passed as is to the context without adding the globals.</p> <p><code>locals</code> can be a dict of local variables for internal usage.</p> </dd>
</dl> <dl class="method"> <dt id="jinja2.Template.root_render_func">
<code>Template.root_render_func(context)</code> </dt> <dd>
<p>This is the low level render function. It’s passed a <code>Context</code> that has to be created by <a class="reference internal" href="#jinja2.Template.new_context" title="jinja2.Template.new_context"><code>new_context()</code></a> of the same template or a compatible template. This render function is generated by the compiler from the template code and returns a generator that yields unicode strings.</p> <p>If an exception in the template code happens the template engine will not rewrite the exception but pass through the original one. As a matter of fact this function should only be called from within a <a class="reference internal" href="#jinja2.Template.render" title="jinja2.Template.render"><code>render()</code></a> / <a class="reference internal" href="#jinja2.Template.generate" title="jinja2.Template.generate"><code>generate()</code></a> / <a class="reference internal" href="#jinja2.Template.stream" title="jinja2.Template.stream"><code>stream()</code></a> call.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Template.blocks">
<code>Template.blocks</code> </dt> <dd>
<p>A dict of block render functions. Each of these functions works exactly like the <a class="reference internal" href="#jinja2.Template.root_render_func" title="jinja2.Template.root_render_func"><code>root_render_func()</code></a> with the same limitations.</p> </dd>
</dl> <dl class="attribute"> <dt id="jinja2.Template.is_up_to_date">
<code>Template.is_up_to_date</code> </dt> <dd>
<p>This attribute is <code>False</code> if there is a newer version of the template available, otherwise <code>True</code>.</p> </dd>
</dl> <div class="admonition-note admonition"> <p class="admonition-title">Note</p> <p>The low-level API is fragile. Future Jinja versions will try not to change it in a backwards incompatible way but modifications in the Jinja core may shine through. For example if Jinja introduces a new AST node in later versions that may be returned by <a class="reference internal" href="#jinja2.Environment.parse" title="jinja2.Environment.parse"><code>parse()</code></a>.</p> </div>   <h2 id="the-meta-api">The Meta API</h2> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 2.2.</span></p> </div> </details><p>The meta API returns some information about abstract syntax trees that could help applications to implement more advanced template concepts. All the functions of the meta API operate on an abstract syntax tree as returned by the <a class="reference internal" href="#jinja2.Environment.parse" title="jinja2.Environment.parse"><code>Environment.parse()</code></a> method.</p> <dl class="function"> <dt id="jinja2.meta.find_undeclared_variables">
<code>jinja2.meta.find_undeclared_variables(ast)</code> </dt> <dd>
<p>Returns a set of all variables in the AST that will be looked up from the context at runtime. Because at compile time it’s not known which variables will be used depending on the path the execution takes at runtime, all variables are returned.</p> <pre data-language="python">&gt;&gt;&gt; from jinja2 import Environment, meta
&gt;&gt;&gt; env = Environment()
&gt;&gt;&gt; ast = env.parse('{% set foo = 42 %}{{ bar + foo }}')
&gt;&gt;&gt; meta.find_undeclared_variables(ast) == set(['bar'])
True
</pre> <div class="admonition-implementation admonition"> <p class="admonition-title">Implementation</p> <p>Internally the code generator is used for finding undeclared variables. This is good to know because the code generator might raise a <code>TemplateAssertionError</code> during compilation and as a matter of fact this function can currently raise that exception as well.</p> </div> </dd>
</dl> <dl class="function"> <dt id="jinja2.meta.find_referenced_templates">
<code>jinja2.meta.find_referenced_templates(ast)</code> </dt> <dd>
<p>Finds all the referenced templates from the AST. This will return an iterator over all the hardcoded template extensions, inclusions and imports. If dynamic inheritance or inclusion is used, <code>None</code> will be yielded.</p> <pre data-language="python">&gt;&gt;&gt; from jinja2 import Environment, meta
&gt;&gt;&gt; env = Environment()
&gt;&gt;&gt; ast = env.parse('{% extends "layout.html" %}{% include helper %}')
&gt;&gt;&gt; list(meta.find_referenced_templates(ast))
['layout.html', None]
</pre> <p>This function is useful for dependency tracking. For example if you want to rebuild parts of the website after a layout template has changed.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2020 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://jinja.palletsprojects.com/en/2.11.x/api/" class="_attribution-link">https://jinja.palletsprojects.com/en/2.11.x/api/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
