
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Route2 - Cypress - W3cubDocs</title>
  
  <meta name="description" content=" This is an experimental feature. In order to use it, you must set the experimentalNetworkStubbing configuration option to true. ">
  <meta name="keywords" content="route, comparison, usage, examples, see, also, cypress">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cypress/api/commands/route2.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/cypress.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cypress/" class="_nav-link" title="" style="margin-left:0;">Cypress</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _cypress">
				
				
<h1 class="article-title" itemprop="name">route2</h1>  <div class="article-content" itemprop="articleBody"> <blockquote class="note warning">
<p> <strong>This is an experimental feature. In order to use it, you must set the <a href="https://docs.cypress.io/guides/references/experiments.html"><code>experimentalNetworkStubbing</code></a> configuration option to <code>true</code>.</strong></p> </blockquote> <p>Use <code>cy.route2()</code> to manage the behavior of HTTP requests at the network layer.</p> <p>With <code>cy.route2()</code>, you can:</p> <ul> <li>stub or spy on any type of HTTP request.</li> <li>
<a href="#Intercepting-a-request">modify an HTTP request's body, headers, and URL</a> before it is sent to the destination server.</li> <li>stub the response to an HTTP request, either dynamically or statically.</li> <li>
<a href="#Intercepting-a-response">modify real HTTP responses</a>, changing the body, headers, or HTTP status code before they are received by the browser.</li> <li>and much more - <code>cy.route2()</code> gives full access to all HTTP requests at all stages.</li> </ul> <h1 id="Comparison-to-cy-route" class="article-heading">
Comparison to <code>cy.route()</code>
</h1>
<p>Unlike <a href="route"><code>cy.route()</code></a>, <code>cy.route2()</code>:</p> <ul> <li>can intercept all types of network requests including Fetch API, page loads, XMLHttpRequests, resource loads, etc.</li> <li>does not require calling <a href="server"><code>cy.server()</code></a> before use - in fact, <code>cy.server()</code> does not influence <code>cy.route2()</code> at all.</li> <li>does not have method set to <code>GET</code> by default</li> </ul> <h1 id="Usage" class="article-heading">
Usage
</h1>
<pre class=" language-ts" data-language="javascript">cy.route2(url, routeHandler?)
cy.route2(method, url, routeHandler?)
cy.route2(routeMatcher, routeHandler?)
</pre> <h2 id="Arguments" class="article-heading">
Arguments
</h2>
<h3 id="url-string-RegExp" class="article-heading">
<strong> url</strong> <strong><em>(<code>string | RegExp</code>)</em></strong>
</h3>
<p>Specify the URL to match. See the documentation for <a href="#routeMatcher-RouteMatcher">`routeMatcher`</a> to see how URLs are matched.</p> <pre class=" language-ts" data-language="javascript">cy.route2('http://example.com/widgets')
cy.route2('http://example.com/widgets', { fixture: 'widgets.json' })
</pre> <h3 id="method-string" class="article-heading">
<strong> method</strong> <strong><em>(<code>string</code>)</em></strong>
</h3>
<p>Specify the HTTP method to match on.</p> <pre class=" language-ts" data-language="javascript">cy.route2('POST', 'http://example.com/widgets', {
  statusCode: 200,
  body: 'it worked!'
})
</pre> <h3 id="routeMatcher-RouteMatcher" class="article-heading">
<strong> routeMatcher</strong> <strong><em>(<code>RouteMatcher</code>)</em></strong>
</h3>
<p><code>routeMatcher</code> is an object used to match which incoming HTTP requests will be handled by this route.</p> <p>All properties are optional. All properties that are set must match for the route to handle a request. If a <code>string</code> is passed to any property, it will be glob-matched against the request using <a href="https://github.com/isaacs/minimatch" target="_blank" rel="noopener"><code>minimatch</code></a>.The available <code>routeMatcher</code> properties are listed below:</p> <pre class=" language-ts" data-language="javascript">{
  /**
   * Match against the username and password used in HTTP Basic authentication.
   */
  auth?: { username: string | RegExp, password: string | RegExp }
  /**
   * Match against HTTP headers on the request.
   */
  headers?: {
    [name: string]: string | RegExp
  }
  /**
   * Match against the requested HTTP hostname.
   */
  hostname?: string | RegExp
  /**
   * If 'true', only HTTPS requests will be matched.
   * If 'false', only HTTP requests will be matched.
   */
  https?: boolean
  /**
   * Match against the request's HTTP method.
   * @default '*'
   */
  method?: string | RegExp
  /**
   * Match on request path after the hostname, including query params.
   */
  path?: string | RegExp
  /**
   * Matches like 'path', but without query params.
   */
  pathname?: string | RegExp
  /**
   * Match based on requested port, or pass an array of ports
   * to match against any in that array.
   */
  port?: number | number[]
  /**
   * Match on parsed querystring parameters.
   */
  query?: {
    [key: string]: string | RegExp
  }
  /**
   * Match against the full request URL.
   * If a string is passed, it will be used as a substring match,
   * not an equality match.
   */
  url?: string | RegExp
}
</pre> <p><code>routeMatcher</code> usage examples:</p> <pre class=" language-ts" data-language="javascript">cy.route2({
  pathname: '/search',
  query: {
    q: 'some terms'
  }
}).as('searchForTerms')
// this 'cy.wait' will only resolve once a request is made to '/search'
// with the query paramater 'q=some+terms'
cy.wait('@searchForTerms')

cy.route2({
  // this RegExp matches any URL beginning with 'http://api.example.com/widgets'
  url: /^http:\/\/api\.example\.com\/widgets/
  headers: {
    'x-requested-with': 'exampleClient'
  }
}, (req) =&gt; {
  // only requests to URLs starting with 'http://api.example.com/widgets'
  // having the header 'x-requested-with: exampleClient' will be received
})
</pre> <h3 id="routeHandler-string-object-Function-StaticResponse" class="article-heading">
<strong> routeHandler</strong> <strong><em>(<code>string | object | Function | StaticResponse</code>)</em></strong>
</h3>
<p>The <code>routeHandler</code> defines what will happen with a request if the <a href="#routeMatcher-RouteMatcher">`routeMatcher`</a> matches. It can be used to <a href="#Stubbing-a-response">statically define a response</a> for matching requests, or a function can be passed to <a href="#Intercepting-a-request">dynamically intercept the outgoing request</a>.</p> <ul> <li>If a <strong>string</strong> is passed, requests to the route will be fulfilled with that string as the body. Passing <code>"foo"</code> is equivalent to using a <code>StaticResponse</code> object with <code>{ body: "foo" }</code>.</li> <li>If a <strong><code>StaticResponse</code> object</strong> is passed, requests to the route will be fulfilled with a response using the values supplied in the <code>StaticResponse</code>. A <code>StaticResponse</code> can define the body of the response, as well as the headers, HTTP status code, and more. See <a href="#With-a-StaticResponse-object">Stubbing a response with a `StaticResponse` object</a> for an example of how this is used.</li> <li>If an <strong>object with no <code>StaticResponse</code> keys</strong> is passed, it will be sent as a JSON response body. For example, passing <code>{ foo: 'bar' }</code> is equivalent to passing <code>{ body: { foo: 'bar' } }</code>.</li> <li>If a <strong>function callback</strong> is passed, it will be called whenever a request matching this route is received, with the first parameter being the request object. From inside the callback, you can modify the outgoing request, send a response, access the real response, and much more. See <a href="#Intercepting-a-request">Intercepting a request</a> and <a href="#Intercepting-a-response">Intercepting a response</a> for examples of dynamic interception.</li> </ul> <h2 id="Yields" class="article-heading">
Yields 
</h2>
<ul> <li>
<code>cy.route2()</code> yields <code>null</code>.</li> <li>
<code>cy.route2()</code> can be aliased, but otherwise cannot be chained further.</li> <li>Waiting on an aliased <code>cy.route2()</code> route using <a href="wait"><code>cy.wait()</code></a> will yield an object that contains information about the matching request/response cycle. See <a href="#Using-the-yielded-object">Using the yielded object</a> for examples of how to use this object.</li> </ul> <h1 id="Examples" class="article-heading">
Examples
</h1>
<h2 id="Waiting-on-a-request" class="article-heading">
Waiting on a request
</h2>
<p>Use <a href="wait"><code>cy.wait()</code></a> with <code>cy.route2()</code> aliases to wait for the request/response cycle to complete.</p> <h3 id="With-URL" class="article-heading">
With URL
</h3>
<pre class=" language-js" data-language="javascript">cy.route2('http://example.com/settings').as('getSettings')
// once a request to http://example.com/settings responds, this 'cy.wait' will resolve
cy.wait('@getSettings')
</pre> <h3 id="With" class="article-heading">
With <a href="#routeMatcher-RouteMatcher">`RouteMatcher`</a>
</h3>
<pre class=" language-js" data-language="javascript">cy.route2({
  url: 'http://example.com/search',
  query: { q: 'expected terms' },
}).as('search')

// once any type of request to http://example.com/search with a querystring containing
// 'q=expected+terms' responds, this 'cy.wait' will resolve
cy.wait('@search')
</pre> <h3 id="Using-the-yielded-object" class="article-heading">
Using the yielded object
</h3>
<p>Using <a href="wait"><code>cy.wait()</code></a> on a <code>cy.route2()</code> route alias yields an object which represents the request/response cycle:</p> <pre class=" language-js" data-language="javascript">cy.wait('@someRoute').then((request) =&gt; {
  // 'request' is an object with properties 'id', 'request' and 'response'
})
</pre> <p>You can chain <a href="its"><code>.its()</code></a> and <a href="should"><code>.should()</code></a> to assert against request/response cycles:</p> <pre class=" language-js" data-language="javascript">// assert that a request to this route was made with a body that included 'user'
cy.wait('@someRoute').its('request.body').should('include', 'user')

// assert that a request to this route received a response with HTTP status 500
cy.wait('@someRoute').its('response.statusCode').should('eq', 500)

// assert that a request to this route received a response body that includes 'id'
cy.wait('@someRoute').its('response.body').should('include', 'id')
</pre> <h3 id="Aliasing-individual-requests" class="article-heading">
Aliasing individual requests
</h3>
<p>Aliases can be set on a per-request basis by setting the <code>alias</code> property of the intercepted request:</p> <pre class=" language-js" data-language="javascript">cy.route2('POST', '/graphql', (req) =&gt; {
  if (req.body.includes('mutation')) {
    req.alias = 'gqlMutation'
  }
})

// assert that a matching request has been made
cy.wait('@gqlMutation')
</pre> <h2 id="Stubbing-a-response" class="article-heading">
Stubbing a response
</h2>
<h3 id="With-a-string" class="article-heading">
With a string
</h3>
<pre class=" language-js" data-language="javascript">// requests to '/update' will be fulfilled with a body of "success"
cy.route2('/update', 'success')
</pre> <h3 id="With-a-fixture" class="article-heading">
With a fixture
</h3>
<pre class=" language-js" data-language="javascript">// requests to '/users.json' will be fulfilled
// with the contents of the "users.json" fixture
cy.route2('/users.json', { fixture: 'users.json' })
</pre> <h3 id="With-a-StaticResponse-object" class="article-heading">
With a <code>StaticResponse</code> object
</h3>
<p>A <code>StaticResponse</code> object represents a response to an HTTP request, and can be used to stub routes:</p> <pre class=" language-js" data-language="javascript">const staticResponse = { /* some StaticResponse properties here... */ }

cy.route2('/projects', staticResponse)
</pre> <p>Here are the available properties on <code>StaticResponse</code>:</p> <pre class=" language-ts" data-language="javascript">{
  /**
   * Serve a fixture as the response body.
   */
  fixture?: string
  /**
   * Serve a static string/JSON object as the response body.
   */
  body?: string | object | object[]
  /**
   * HTTP headers to accompany the response.
   * @default {}
   */
  headers?: { [key: string]: string }
  /**
   * The HTTP status code to send.
   * @default 200
   */
  statusCode?: number
  /**
   * If 'forceNetworkError' is truthy, Cypress will destroy the browser connection
   * and send no response. Useful for simulating a server that is not reachable.
   * Must not be set in combination with other options.
   */
  forceNetworkError?: boolean
  /**
   * Milliseconds to delay before the response is sent.
   */
  delayMs?: number
  /**
   * Kilobits per second to send 'body'.
   */
  throttleKbps?: number
}
</pre> <h2 id="Intercepting-a-request" class="article-heading">
Intercepting a request
</h2>
<h3 id="Asserting-on-a-request" class="article-heading">
Asserting on a request
</h3>
<pre class=" language-js" data-language="javascript">cy.route2('POST', '/organization', (req) =&gt; {
  expect(req.body).to.include('Acme Company')
})
</pre> <h3 id="Modifying-an-outgoing-request" class="article-heading">
Modifying an outgoing request
</h3>
<p>You can use the route callback to modify the request before it is sent.</p> <pre class=" language-js" data-language="javascript">cy.route2('POST', '/login', (req) =&gt; {
  // set the request body to something different before it's sent to the destination
  req.body = 'username=janelane&amp;password=secret123'
})
</pre> <h3 id="Dynamically-stubbing-a-response" class="article-heading">
Dynamically stubbing a response
</h3>
<p>You can use the <code>req.reply()</code> function to dynamically control the response to a request.</p> <pre class=" language-js" data-language="javascript">cy.route2('/billing', (req) =&gt; {
  // functions on 'req' can be used to dynamically respond to a request here

  // send the request to the destination server
  req.reply()

  // respond to the request with a JSON object
  req.reply({ plan: 'starter' })

  // send the request to the destination server, and intercept the response
  req.reply((res) =&gt; {
    // 'res' represents the real destination's response
    // See "Intercepting a response" for more details and examples
  })
})
</pre> <p>The available functions on <code>req</code> are:</p> <pre class=" language-ts" data-language="javascript">{
  /**
   * Destroy the request and respond with a network error.
   */
  destroy(): void
  /**
   * Control the response to this request.
   * If a function is passed, the request will be sent outgoing,
   * and the function will be called with the response from the upstream server.
   * If a 'StaticResponse' is passed, it will be used as the response
   * and no request will be made to the upstream server.
   */
  reply(interceptor?: StaticResponse | HttpResponseInterceptor): void
  /**
   * Shortcut to reply to the request with a body and optional headers.
   */
  reply(body: string | object, headers?: { [key: string]: string }): void
  /**
   * Shortcut to reply to the request with an HTTP status code
   * and optional body and headers.
   */
  reply(status: number, body?: string | object, headers?: { [key: string]: string }): void
  /**
   * Respond to this request with a redirect to a new 'location'.
   * @param statusCode HTTP status code to redirect with. Default: 302
   */
  redirect(location: string, statusCode?: number): void
}
</pre> <h3 id="Returning-a-Promise" class="article-heading">
Returning a Promise
</h3>
<p>If a Promise is returned from the route callback, it will be awaited before continuing with the request.</p> <pre class=" language-js" data-language="javascript">cy.route2('POST', '/login', (req) =&gt; {
  // you could asynchronously fetch test data...
  return getLoginCredentials()
  .then((credentials) =&gt; {
    // ...and then, use it to supplement the outgoing request
    req.headers['authorization'] = credentials
  })
})
</pre> <h3 id="Passing-a-request-to-the-next-route-handler" class="article-heading">
Passing a request to the next route handler
</h3>
<p>If <code>req.reply()</code> is not explicitly called inside of a route callback, requests will pass to the next route callback until none are left.</p> <pre class=" language-js" data-language="javascript">// you could have a top-level route2 that sets an auth token on all requests
cy.route2('http://api.company.com/', (req) =&gt; {
  req.headers['authorization'] = `token ${token}`
})

// and then another route2 that more narrowly asserts on certain requests
cy.route2('POST', 'http://api.company.com/widgets', (req) =&gt; {
  expect(req.body).to.include('analytics')
})

// a POST request to http://api.company.com/widgets would hit both
// of those callbacks in order then it would be sent out
// with the modified request headers to the real destination
</pre> <h2 id="Intercepting-a-response" class="article-heading">
Intercepting a response
</h2>
<p>Inside of a callback passed to <code>req.reply()</code>, you can access the destination server’s real response.</p> <pre class=" language-js" data-language="javascript">cy.route2('/integrations', (req) =&gt; {
  // req.reply() with a callback will send the request to the destination server
  req.reply((res) =&gt; {
    // 'res' represents the real destination response
    // you can manipulate 'res' before it's sent to the browser
  })
})
</pre> <h3 id="Asserting-on-a-response" class="article-heading">
Asserting on a response
</h3>
<pre class=" language-js" data-language="javascript">cy.route2('/projects', (req) =&gt; {
  req.reply((res) =&gt; {
    expect(res.body).to.include('My Project')
  })
})
</pre> <h3 id="Returning-a-Promise-1" class="article-heading">
Returning a Promise
</h3>
<p>If a Promise is returned from the route callback, it will be awaited before sending the response to the browser.</p> <pre class=" language-js" data-language="javascript">cy.route2('/users', (req) =&gt; {
  req.reply((res) =&gt; {
    // the response will not be sent to the browser until 'waitForSomething()' resolves
    return waitForSomething()
  })
})
</pre> <h3 id="Modifying-an-incoming-response" class="article-heading">
Modifying an incoming response
</h3>
<p>You can use the <code>res.send()</code> function to dynamically control the incoming response. Also, any modifications to <code>res</code> will be persisted when the response is sent to the browser.</p> <p><code>res.send()</code> is implicitly called after the <code>req.reply</code> callback finishes if it has not already been called.</p> <pre class=" language-js" data-language="javascript">cy.route2('/notification', (req) =&gt; {
  req.reply((res) =&gt; {
    // replaces 'res.body' with "Success" and sends the response to the browser
    res.send('Success')

    // sends a fixture body instead of the existing 'res.body'
    res.send({ fixture: 'success.json' })

    // delays the response by 1000ms
    res.delay(1000)

    // throttles the response to 64kbps
    res.throttle(64)
  })
})
</pre> <p>The available functions on <code>res</code> are:</p> <pre class=" language-ts" data-language="javascript">{
  /**
    * Continue the HTTP response, merging the supplied values with the real response.
    */
  send(status: number, body?: string | number | object, headers?: { [key: string]: string }): void
  send(body: string | object, headers?: { [key: string]: string }): void
  send(staticResponse: StaticResponse): void
  /**
    * Continue the HTTP response to the browser,
    * including any modifications made to 'res'.
    */
  send(): void
  /**
    * Wait for 'delayMs' milliseconds before sending the response to the client.
    */
  delay: (delayMs: number) =&gt; IncomingHttpResponse
  /**
    * Serve the response at 'throttleKbps' kilobytes per second.
    */
  throttle: (throttleKbps: number) =&gt; IncomingHttpResponse
}
</pre> <h1 id="See-also" class="article-heading">
See also
</h1>
<ul> <li><a href="https://github.com/cypress-io/cypress-example-recipes#stubbing-and-spying" target="_blank" rel="noopener"><code>cy.route2()</code> example recipes with real-world examples</a></li> <li>
<a href="https://glebbahmutov.com/blog/cy-route-vs-route2/" target="_blank" rel="noopener"><code>cy.route</code> vs <code>cy.route2</code></a> blog post</li> <li>
<a href="https://glebbahmutov.com/blog/smart-graphql-stubbing/" target="_blank" rel="noopener">Smart GraphQL Stubbing in Cypress</a> blog post</li> <li>
<a href="https://github.com/cypress-io/cypress/issues?q=is%3Aissue+is%3Aopen+label%3Apkg%2Fnet-stubbing" target="_blank" rel="noopener">open issues for <code>experimentalNetworkStubbing</code></a> and <a href="https://github.com/cypress-io/cypress/issues?q=is%3Aissue+is%3Aclosed+label%3Apkg%2Fnet-stubbing" target="_blank" rel="noopener">closed issues for <code>experimentalNetworkStubbing</code></a> </li> </ul> </div> <div class="_attribution">
  <p class="_attribution-p">
    © 2020 Cypress.io<br>Licensed under the MIT License.<br>
    <a href="https://docs.cypress.io/api/commands/route2.html" class="_attribution-link">https://docs.cypress.io/api/commands/route2.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
