
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Query Expressions - Django 1.11 - W3cubDocs</title>
  
  <meta name="description" content="Query expressions describe a value or a computation that can be used as part of an update, create, filter, order by, annotation, or aggregate. There &hellip;">
  <meta name="keywords" content="query, expressions, django, django~1.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/django~1.11/ref/models/expressions.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/django~1.11.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/django~1.11/" class="_nav-link" title="" style="margin-left:0;">Django 1.11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="query-expressions">Query Expressions</h1> <p id="s-query-expressions">Query expressions describe a value or a computation that can be used as part of an update, create, filter, order by, annotation, or aggregate. There are a number of built-in expressions (documented below) that can be used to help you write queries. Expressions can be combined, or in some cases nested, to form more complex computations.</p>  <h2 id="supported-arithmetic">Supported arithmetic</h2> <p id="s-supported-arithmetic">Django supports addition, subtraction, multiplication, division, modulo arithmetic, and the power operator on query expressions, using Python constants, variables, and even other expressions.</p>   <h2 id="some-examples">Some examples</h2> <pre data-language="python" id="s-some-examples">from django.db.models import F, Count, Value
from django.db.models.functions import Length, Upper

# Find companies that have more employees than chairs.
Company.objects.filter(num_employees__gt=F('num_chairs'))

# Find companies that have at least twice as many employees
# as chairs. Both the querysets below are equivalent.
Company.objects.filter(num_employees__gt=F('num_chairs') * 2)
Company.objects.filter(
    num_employees__gt=F('num_chairs') + F('num_chairs'))

# How many chairs are needed for each company to seat all employees?
&gt;&gt;&gt; company = Company.objects.filter(
...    num_employees__gt=F('num_chairs')).annotate(
...    chairs_needed=F('num_employees') - F('num_chairs')).first()
&gt;&gt;&gt; company.num_employees
120
&gt;&gt;&gt; company.num_chairs
50
&gt;&gt;&gt; company.chairs_needed
70

# Create a new company using expressions.
&gt;&gt;&gt; company = Company.objects.create(name='Google', ticker=Upper(Value('goog')))
# Be sure to refresh it if you need to access the field.
&gt;&gt;&gt; company.refresh_from_db()
&gt;&gt;&gt; company.ticker
'GOOG'

# Annotate models with an aggregated value. Both forms
# below are equivalent.
Company.objects.annotate(num_products=Count('products'))
Company.objects.annotate(num_products=Count(F('products')))

# Aggregates can contain complex computations also
Company.objects.annotate(num_offerings=Count(F('products') + F('services')))

# Expressions can also be used in order_by()
Company.objects.order_by(Length('name').asc())
Company.objects.order_by(Length('name').desc())
</pre>   <h2 id="built-in-expressions">Built-in Expressions</h2> <div class="admonition note" id="s-built-in-expressions"> <p class="first admonition-title">Note</p> <p class="last">These expressions are defined in <code>django.db.models.expressions</code> and <code>django.db.models.aggregates</code>, but for convenience they’re available and usually imported from <a class="reference internal" href="../../topics/db/models#module-django.db.models" title="django.db.models"><code>django.db.models</code></a>.</p> </div>  <h3 id="f-expressions">
<code>F()</code> expressions</h3> <dl class="class" id="s-f-expressions"> <dt id="django.db.models.F">
<code>class F</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.11/_modules/django/db/models/expressions/#F"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>An <code>F()</code> object represents the value of a model field or annotated column. It makes it possible to refer to model field values and perform database operations using them without actually having to pull them out of the database into Python memory.</p> <p>Instead, Django uses the <code>F()</code> object to generate an SQL expression that describes the required operation at the database level.</p> <p>This is easiest to understand through an example. Normally, one might do something like this:</p> <pre data-language="python"># Tintin filed a news story!
reporter = Reporters.objects.get(name='Tintin')
reporter.stories_filed += 1
reporter.save()
</pre> <p>Here, we have pulled the value of <code>reporter.stories_filed</code> from the database into memory and manipulated it using familiar Python operators, and then saved the object back to the database. But instead we could also have done:</p> <pre data-language="python">from django.db.models import F

reporter = Reporters.objects.get(name='Tintin')
reporter.stories_filed = F('stories_filed') + 1
reporter.save()
</pre> <p>Although <code>reporter.stories_filed = F('stories_filed') + 1</code> looks like a normal Python assignment of value to an instance attribute, in fact it’s an SQL construct describing an operation on the database.</p> <p>When Django encounters an instance of <code>F()</code>, it overrides the standard Python operators to create an encapsulated SQL expression; in this case, one which instructs the database to increment the database field represented by <code>reporter.stories_filed</code>.</p> <p>Whatever value is or was on <code>reporter.stories_filed</code>, Python never gets to know about it - it is dealt with entirely by the database. All Python does, through Django’s <code>F()</code> class, is create the SQL syntax to refer to the field and describe the operation.</p> <p>To access the new value saved this way, the object must be reloaded:</p> <pre data-language="python">reporter = Reporters.objects.get(pk=reporter.pk)
# Or, more succinctly:
reporter.refresh_from_db()
</pre> <p>As well as being used in operations on single instances as above, <code>F()</code> can be used on <code>QuerySets</code> of object instances, with <code>update()</code>. This reduces the two queries we were using above - the <code>get()</code> and the <a class="reference internal" href="instances#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a> - to just one:</p> <pre data-language="python">reporter = Reporters.objects.filter(name='Tintin')
reporter.update(stories_filed=F('stories_filed') + 1)
</pre> <p>We can also use <a class="reference internal" href="querysets#django.db.models.query.QuerySet.update" title="django.db.models.query.QuerySet.update"><code>update()</code></a> to increment the field value on multiple objects - which could be very much faster than pulling them all into Python from the database, looping over them, incrementing the field value of each one, and saving each one back to the database:</p> <pre data-language="python">Reporter.objects.all().update(stories_filed=F('stories_filed') + 1)
</pre> <p><code>F()</code> therefore can offer performance advantages by:</p> <ul class="simple"> <li>getting the database, rather than Python, to do work</li> <li>reducing the number of queries some operations require</li> </ul>  <h4 id="id1">Avoiding race conditions using <code>F()</code>
</h4> <p id="s-avoiding-race-conditions-using-f">Another useful benefit of <code>F()</code> is that having the database - rather than Python - update a field’s value avoids a <em>race condition</em>.</p> <p>If two Python threads execute the code in the first example above, one thread could retrieve, increment, and save a field’s value after the other has retrieved it from the database. The value that the second thread saves will be based on the original value; the work of the first thread will simply be lost.</p> <p>If the database is responsible for updating the field, the process is more robust: it will only ever update the field based on the value of the field in the database when the <a class="reference internal" href="instances#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a> or <code>update()</code> is executed, rather than based on its value when the instance was retrieved.</p>   <h4 id="f-assignments-persist-after-model-save">
<code>F()</code> assignments persist after <code>Model.save()</code>
</h4> <p id="s-f-assignments-persist-after-model-save"><code>F()</code> objects assigned to model fields persist after saving the model instance and will be applied on each <a class="reference internal" href="instances#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>. For example:</p> <pre data-language="python">reporter = Reporters.objects.get(name='Tintin')
reporter.stories_filed = F('stories_filed') + 1
reporter.save()

reporter.name = 'Tintin Jr.'
reporter.save()
</pre> <p><code>stories_filed</code> will be updated twice in this case. If it’s initially <code>1</code>, the final value will be <code>3</code>.</p>   <h4 id="using-f-in-filters">Using <code>F()</code> in filters</h4> <p id="s-using-f-in-filters"><code>F()</code> is also very useful in <code>QuerySet</code> filters, where they make it possible to filter a set of objects against criteria based on their field values, rather than on Python values.</p> <p>This is documented in <a class="reference internal" href="../../topics/db/queries#using-f-expressions-in-filters"><span class="std std-ref">using F() expressions in queries</span></a>.</p>   <h4 id="id2">Using <code>F()</code> with annotations</h4> <p id="s-using-f-with-annotations"><code>F()</code> can be used to create dynamic fields on your models by combining different fields with arithmetic:</p> <pre data-language="python">company = Company.objects.annotate(
    chairs_needed=F('num_employees') - F('num_chairs'))
</pre> <p>If the fields that you’re combining are of different types you’ll need to tell Django what kind of field will be returned. Since <code>F()</code> does not directly support <code>output_field</code> you will need to wrap the expression with <a class="reference internal" href="#django.db.models.ExpressionWrapper" title="django.db.models.ExpressionWrapper"><code>ExpressionWrapper</code></a>:</p> <pre data-language="python">from django.db.models import DateTimeField, ExpressionWrapper, F

Ticket.objects.annotate(
    expires=ExpressionWrapper(
        F('active_at') + F('duration'), output_field=DateTimeField()))
</pre> <p>When referencing relational fields such as <code>ForeignKey</code>, <code>F()</code> returns the primary key value rather than a model instance:</p> <pre data-language="python">&gt;&gt; car = Company.objects.annotate(built_by=F('manufacturer'))[0]
&gt;&gt; car.manufacturer
&lt;Manufacturer: Toyota&gt;
&gt;&gt; car.built_by
3
</pre>    <h3 id="id3">
<code>Func()</code> expressions</h3> <p id="s-func-expressions"><code>Func()</code> expressions are the base type of all expressions that involve database functions like <code>COALESCE</code> and <code>LOWER</code>, or aggregates like <code>SUM</code>. They can be used directly:</p> <pre data-language="python">from django.db.models import Func, F

queryset.annotate(field_lower=Func(F('field'), function='LOWER'))
</pre> <p>or they can be used to build a library of database functions:</p> <pre data-language="python">class Lower(Func):
    function = 'LOWER'

queryset.annotate(field_lower=Lower('field'))
</pre> <p>But both cases will result in a queryset where each model is annotated with an extra attribute <code>field_lower</code> produced, roughly, from the following SQL:</p> <pre data-language="python">SELECT
    ...
    LOWER("db_table"."field") as "field_lower"
</pre> <p>See <a class="reference internal" href="database-functions"><span class="doc">Database Functions</span></a> for a list of built-in database functions.</p> <p>The <code>Func</code> API is as follows:</p> <dl class="class"> <dt id="django.db.models.Func">
<code>class Func(*expressions, **extra)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.11/_modules/django/db/models/expressions/#Func"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="attribute"> <dt id="django.db.models.Func.function">
<code>function</code> </dt> <dd>
<p>A class attribute describing the function that will be generated. Specifically, the <code>function</code> will be interpolated as the <code>function</code> placeholder within <a class="reference internal" href="#django.db.models.Func.template" title="django.db.models.Func.template"><code>template</code></a>. Defaults to <code>None</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.db.models.Func.template">
<code>template</code> </dt> <dd>
<p>A class attribute, as a format string, that describes the SQL that is generated for this function. Defaults to <code>'%(function)s(%(expressions)s)'</code>.</p> <p>If you’re constructing SQL like <code>strftime('%W', 'date')</code> and need a literal <code>%</code> character in the query, quadruple it (<code>%%%%</code>) in the <code>template</code> attribute because the string is interpolated twice: once during the template interpolation in <code>as_sql()</code> and once in the SQL interpolation with the query parameters in the database cursor.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.db.models.Func.arg_joiner">
<code>arg_joiner</code> </dt> <dd>
<p>A class attribute that denotes the character used to join the list of <code>expressions</code> together. Defaults to <code>', '</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.db.models.Func.arity">
<code>arity</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 1.10.</span> </div> <p>A class attribute that denotes the number of arguments the function accepts. If this attribute is set and the function is called with a different number of expressions, <code>TypeError</code> will be raised. Defaults to <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="django.db.models.Func.as_sql">
<code>as_sql(compiler, connection, function=None, template=None, arg_joiner=None, **extra_context)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.11/_modules/django/db/models/expressions/#Func.as_sql"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates the SQL for the database function.</p> <p>The <code>as_vendor()</code> methods should use the <code>function</code>, <code>template</code>, <code>arg_joiner</code>, and any other <code>**extra_context</code> parameters to customize the SQL as needed. For example:</p> <pre data-language="python">class ConcatPair(Func):
    ...
    function = 'CONCAT'
    ...

    def as_mysql(self, compiler, connection):
        return super(ConcatPair, self).as_sql(
            compiler, connection,
            function='CONCAT_WS',
            template="%(function)s('', %(expressions)s)",
        )
</pre> <div class="versionchanged"> <span class="title">Changed in Django 1.10:</span> <p>Support for the <code>arg_joiner</code> and <code>**extra_context</code> parameters was added.</p> </div> </dd>
</dl> </dd>
</dl> <p>The <code>*expressions</code> argument is a list of positional expressions that the function will be applied to. The expressions will be converted to strings, joined together with <code>arg_joiner</code>, and then interpolated into the <code>template</code> as the <code>expressions</code> placeholder.</p> <p>Positional arguments can be expressions or Python values. Strings are assumed to be column references and will be wrapped in <code>F()</code> expressions while other values will be wrapped in <code>Value()</code> expressions.</p> <p>The <code>**extra</code> kwargs are <code>key=value</code> pairs that can be interpolated into the <code>template</code> attribute. The <code>function</code>, <code>template</code>, and <code>arg_joiner</code> keywords can be used to replace the attributes of the same name without having to define your own class. <code>output_field</code> can be used to define the expected return type.</p>   <h3 id="aggregate-expressions">
<code>Aggregate()</code> expressions</h3> <p id="s-aggregate-expressions">An aggregate expression is a special case of a <a class="reference internal" href="#func-expressions"><span class="std std-ref">Func() expression</span></a> that informs the query that a <code>GROUP BY</code> clause is required. All of the <a class="reference internal" href="querysets#aggregation-functions"><span class="std std-ref">aggregate functions</span></a>, like <code>Sum()</code> and <code>Count()</code>, inherit from <code>Aggregate()</code>.</p> <p>Since <code>Aggregate</code>s are expressions and wrap expressions, you can represent some complex computations:</p> <pre data-language="python">from django.db.models import Count

Company.objects.annotate(
    managers_required=(Count('num_employees') / 4) + Count('num_managers'))
</pre> <p>The <code>Aggregate</code> API is as follows:</p> <dl class="class"> <dt id="django.db.models.Aggregate">
<code>class Aggregate(expression, output_field=None, **extra)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.11/_modules/django/db/models/aggregates/#Aggregate"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="attribute"> <dt id="django.db.models.Aggregate.template">
<code>template</code> </dt> <dd>
<p>A class attribute, as a format string, that describes the SQL that is generated for this aggregate. Defaults to <code>'%(function)s( %(expressions)s )'</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.db.models.Aggregate.function">
<code>function</code> </dt> <dd>
<p>A class attribute describing the aggregate function that will be generated. Specifically, the <code>function</code> will be interpolated as the <code>function</code> placeholder within <a class="reference internal" href="#django.db.models.Aggregate.template" title="django.db.models.Aggregate.template"><code>template</code></a>. Defaults to <code>None</code>.</p> </dd>
</dl> </dd>
</dl> <p>The <code>expression</code> argument can be the name of a field on the model, or another expression. It will be converted to a string and used as the <code>expressions</code> placeholder within the <code>template</code>.</p> <p>The <code>output_field</code> argument requires a model field instance, like <code>IntegerField()</code> or <code>BooleanField()</code>, into which Django will load the value after it’s retrieved from the database. Usually no arguments are needed when instantiating the model field as any arguments relating to data validation (<code>max_length</code>, <code>max_digits</code>, etc.) will not be enforced on the expression’s output value.</p> <p>Note that <code>output_field</code> is only required when Django is unable to determine what field type the result should be. Complex expressions that mix field types should define the desired <code>output_field</code>. For example, adding an <code>IntegerField()</code> and a <code>FloatField()</code> together should probably have <code>output_field=FloatField()</code> defined.</p> <p>The <code>**extra</code> kwargs are <code>key=value</code> pairs that can be interpolated into the <code>template</code> attribute.</p>   <h3 id="creating-your-own-aggregate-functions">Creating your own Aggregate Functions</h3> <p id="s-creating-your-own-aggregate-functions">Creating your own aggregate is extremely easy. At a minimum, you need to define <code>function</code>, but you can also completely customize the SQL that is generated. Here’s a brief example:</p> <pre data-language="python">from django.db.models import Aggregate

class Count(Aggregate):
    # supports COUNT(distinct field)
    function = 'COUNT'
    template = '%(function)s(%(distinct)s%(expressions)s)'

    def __init__(self, expression, distinct=False, **extra):
        super(Count, self).__init__(
            expression,
            distinct='DISTINCT ' if distinct else '',
            output_field=IntegerField(),
            **extra
        )
</pre>   <h3 id="value-expressions">
<code>Value()</code> expressions</h3> <dl class="class" id="s-value-expressions"> <dt id="django.db.models.Value">
<code>class Value(value, output_field=None)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.11/_modules/django/db/models/expressions/#Value"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>A <code>Value()</code> object represents the smallest possible component of an expression: a simple value. When you need to represent the value of an integer, boolean, or string within an expression, you can wrap that value within a <code>Value()</code>.</p> <p>You will rarely need to use <code>Value()</code> directly. When you write the expression <code>F('field') + 1</code>, Django implicitly wraps the <code>1</code> in a <code>Value()</code>, allowing simple values to be used in more complex expressions. You will need to use <code>Value()</code> when you want to pass a string to an expression. Most expressions interpret a string argument as the name of a field, like <code>Lower('name')</code>.</p> <p>The <code>value</code> argument describes the value to be included in the expression, such as <code>1</code>, <code>True</code>, or <code>None</code>. Django knows how to convert these Python values into their corresponding database type.</p> <p>The <code>output_field</code> argument should be a model field instance, like <code>IntegerField()</code> or <code>BooleanField()</code>, into which Django will load the value after it’s retrieved from the database. Usually no arguments are needed when instantiating the model field as any arguments relating to data validation (<code>max_length</code>, <code>max_digits</code>, etc.) will not be enforced on the expression’s output value.</p>   <h3 id="expressionwrapper-expressions">
<code>ExpressionWrapper()</code> expressions</h3> <dl class="class" id="s-expressionwrapper-expressions"> <dt id="django.db.models.ExpressionWrapper">
<code>class ExpressionWrapper(expression, output_field)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.11/_modules/django/db/models/expressions/#ExpressionWrapper"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p><code>ExpressionWrapper</code> simply surrounds another expression and provides access to properties, such as <code>output_field</code>, that may not be available on other expressions. <code>ExpressionWrapper</code> is necessary when using arithmetic on <code>F()</code> expressions with different types as described in <a class="reference internal" href="#using-f-with-annotations"><span class="std std-ref">Using F() with annotations</span></a>.</p>   <h3 id="conditional-expressions">Conditional expressions</h3> <p id="s-conditional-expressions">Conditional expressions allow you to use <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#if" title="(in Python v3.8)"><code>if</code></a> … <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#elif" title="(in Python v3.8)"><code>elif</code></a> … <a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#else" title="(in Python v3.8)"><code>else</code></a> logic in queries. Django natively supports SQL <code>CASE</code> expressions. For more details see <a class="reference internal" href="conditional-expressions"><span class="doc">Conditional Expressions</span></a>.</p>   <h3 id="subquery-expressions">
<code>Subquery()</code> expressions</h3> <dl class="class" id="s-subquery-expressions"> <dt id="django.db.models.Subquery">
<code>class Subquery(queryset, output_field=None)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.11/_modules/django/db/models/expressions/#Subquery"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <div class="versionadded"> <span class="title">New in Django 1.11.</span> </div> <p>You can add an explicit subquery to a <code>QuerySet</code> using the <code>Subquery</code> expression.</p> <p>For example, to annotate each post with the email address of the author of the newest comment on that post:</p> <pre data-language="python">&gt;&gt;&gt; from django.db.models import OuterRef, Subquery
&gt;&gt;&gt; newest = Comment.objects.filter(post=OuterRef('pk')).order_by('-created_at')
&gt;&gt;&gt; Post.objects.annotate(newest_commenter_email=Subquery(newest.values('email')[:1]))
</pre> <p>On PostgreSQL, the SQL looks like:</p> <pre data-language="sql">SELECT "post"."id", (
    SELECT U0."email"
    FROM "comment" U0
    WHERE U0."post_id" = ("post"."id")
    ORDER BY U0."created_at" DESC LIMIT 1
) AS "newest_commenter_email" FROM "post"
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The examples in this section are designed to show how to force Django to execute a subquery. In some cases it may be possible to write an equivalent queryset that performs the same task more clearly or efficiently.</p> </div>  <h4 id="referencing-columns-from-the-outer-queryset">Referencing columns from the outer queryset</h4> <dl class="class" id="s-referencing-columns-from-the-outer-queryset"> <dt id="django.db.models.OuterRef">
<code>class OuterRef(field)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.11/_modules/django/db/models/expressions/#OuterRef"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <div class="versionadded"> <span class="title">New in Django 1.11.</span> </div> <p>Use <code>OuterRef</code> when a queryset in a <code>Subquery</code> needs to refer to a field from the outer query. It acts like an <a class="reference internal" href="#django.db.models.F" title="django.db.models.F"><code>F</code></a> expression except that the check to see if it refers to a valid field isn’t made until the outer queryset is resolved.</p> <p>Instances of <code>OuterRef</code> may be used in conjunction with nested instances of <code>Subquery</code> to refer to a containing queryset that isn’t the immediate parent. For example, this queryset would need to be within a nested pair of <code>Subquery</code> instances to resolve correctly:</p> <pre data-language="python">&gt;&gt;&gt; Book.objects.filter(author=OuterRef(OuterRef('pk')))
</pre>   <h4 id="limiting-a-subquery-to-a-single-column">Limiting a subquery to a single column</h4> <p id="s-limiting-a-subquery-to-a-single-column">There are times when a single column must be returned from a <code>Subquery</code>, for instance, to use a <code>Subquery</code> as the target of an <code>__in</code> lookup. To return all comments for posts published within the last day:</p> <pre data-language="python">&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; from django.utils import timezone
&gt;&gt;&gt; one_day_ago = timezone.now() - timedelta(days=1)
&gt;&gt;&gt; posts = Post.objects.filter(published_at__gte=one_day_ago)
&gt;&gt;&gt; Comment.objects.filter(post__in=Subquery(posts.values('pk')))
</pre> <p>In this case, the subquery must use <a class="reference internal" href="querysets#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code>values()</code></a> to return only a single column: the primary key of the post.</p>   <h4 id="limiting-the-subquery-to-a-single-row">Limiting the subquery to a single row</h4> <p id="s-limiting-the-subquery-to-a-single-row">To prevent a subquery from returning multiple rows, a slice (<code>[:1]</code>) of the queryset is used:</p> <pre data-language="python">&gt;&gt;&gt; subquery = Subquery(newest.values('email')[:1])
&gt;&gt;&gt; Post.objects.annotate(newest_commenter_email=subquery)
</pre> <p>In this case, the subquery must only return a single column <em>and</em> a single row: the email address of the most recently created comment.</p> <p>(Using <a class="reference internal" href="querysets#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a> instead of a slice would fail because the <code>OuterRef</code> cannot be resolved until the queryset is used within a <code>Subquery</code>.)</p>   <h4 id="exists-subqueries">
<code>Exists()</code> subqueries</h4> <dl class="class" id="s-exists-subqueries"> <dt id="django.db.models.Exists">
<code>class Exists(queryset)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.11/_modules/django/db/models/expressions/#Exists"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <div class="versionadded"> <span class="title">New in Django 1.11.</span> </div> <p><code>Exists</code> is a <code>Subquery</code> subclass that uses an SQL <code>EXISTS</code> statement. In many cases it will perform better than a subquery since the database is able to stop evaluation of the subquery when a first matching row is found.</p> <p>For example, to annotate each post with whether or not it has a comment from within the last day:</p> <pre data-language="python">&gt;&gt;&gt; from django.db.models import Exists, OuterRef
&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; from django.utils import timezone
&gt;&gt;&gt; one_day_ago = timezone.now() - timedelta(days=1)
&gt;&gt;&gt; recent_comments = Comment.objects.filter(
...     post=OuterRef('pk'),
...     created_at__gte=one_day_ago,
... )
&gt;&gt;&gt; Post.objects.annotate(recent_comment=Exists(recent_comments))
</pre> <p>On PostgreSQL, the SQL looks like:</p> <pre data-language="sql">SELECT "post"."id", "post"."published_at", EXISTS(
    SELECT U0."id", U0."post_id", U0."email", U0."created_at"
    FROM "comment" U0
    WHERE (
        U0."created_at" &gt;= YYYY-MM-DD HH:MM:SS AND
        U0."post_id" = ("post"."id")
    )
) AS "recent_comment" FROM "post"
</pre> <p>It’s unnecessary to force <code>Exists</code> to refer to a single column, since the columns are discarded and a boolean result is returned. Similarly, since ordering is unimportant within an SQL <code>EXISTS</code> subquery and would only degrade performance, it’s automatically removed.</p> <p>You can query using <code>NOT EXISTS</code> with <code>~Exists()</code>.</p>   <h4 id="filtering-on-a-subquery-expression">Filtering on a <code>Subquery</code> expression</h4> <p id="s-filtering-on-a-subquery-expression">It’s not possible to filter directly using <code>Subquery</code> and <code>Exists</code>, e.g.:</p> <pre data-language="python">&gt;&gt;&gt; Post.objects.filter(Exists(recent_comments))
...
TypeError: 'Exists' object is not iterable
</pre> <p>You must filter on a subquery expression by first annotating the queryset and then filtering based on that annotation:</p> <pre data-language="python">&gt;&gt;&gt; Post.objects.annotate(
...     recent_comment=Exists(recent_comments),
... ).filter(recent_comment=True)
</pre>   <h4 id="using-aggregates-within-a-subquery-expression">Using aggregates within a <code>Subquery</code> expression</h4> <p id="s-using-aggregates-within-a-subquery-expression">Aggregates may be used within a <code>Subquery</code>, but they require a specific combination of <a class="reference internal" href="querysets#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a>, <a class="reference internal" href="querysets#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code>values()</code></a>, and <a class="reference internal" href="querysets#django.db.models.query.QuerySet.annotate" title="django.db.models.query.QuerySet.annotate"><code>annotate()</code></a> to get the subquery grouping correct.</p> <p>Assuming both models have a <code>length</code> field, to find posts where the post length is greater than the total length of all combined comments:</p> <pre data-language="python">&gt;&gt;&gt; from django.db.models import OuterRef, Subquery, Sum
&gt;&gt;&gt; comments = Comment.objects.filter(post=OuterRef('pk')).order_by().values('post')
&gt;&gt;&gt; total_comments = comments.annotate(total=Sum('length')).values('total')
&gt;&gt;&gt; Post.objects.filter(length__gt=Subquery(total_comments))
</pre> <p>The initial <code>filter(...)</code> limits the subquery to the relevant parameters. <code>order_by()</code> removes the default <a class="reference internal" href="options#django.db.models.Options.ordering" title="django.db.models.Options.ordering"><code>ordering</code></a> (if any) on the <code>Comment</code> model. <code>values('post')</code> aggregates comments by <code>Post</code>. Finally, <code>annotate(...)</code> performs the aggregation. The order in which these queryset methods are applied is important. In this case, since the subquery must be limited to a single column, <code>values('total')</code> is required.</p> <p>This is the only way to perform an aggregation within a <code>Subquery</code>, as using <a class="reference internal" href="querysets#django.db.models.query.QuerySet.aggregate" title="django.db.models.query.QuerySet.aggregate"><code>aggregate()</code></a> attempts to evaluate the queryset (and if there is an <code>OuterRef</code>, this will not be possible to resolve).</p>    <h3 id="raw-sql-expressions">Raw SQL expressions</h3> <dl class="class" id="s-raw-sql-expressions"> <dt id="django.db.models.expressions.RawSQL">
<code>class RawSQL(sql, params, output_field=None)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.11/_modules/django/db/models/expressions/#RawSQL"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>Sometimes database expressions can’t easily express a complex <code>WHERE</code> clause. In these edge cases, use the <code>RawSQL</code> expression. For example:</p> <pre data-language="python">&gt;&gt;&gt; from django.db.models.expressions import RawSQL
&gt;&gt;&gt; queryset.annotate(val=RawSQL("select col from sometable where othercol = %s", (someparam,)))
</pre> <p>These extra lookups may not be portable to different database engines (because you’re explicitly writing SQL code) and violate the DRY principle, so you should avoid them if possible.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">You should be very careful to escape any parameters that the user can control by using <code>params</code> in order to protect against <a class="reference internal" href="../../topics/security#sql-injection-protection"><span class="std std-ref">SQL injection attacks</span></a>. <code>params</code> is a required argument to force you to acknowledge that you’re not interpolating your SQL with user provided data.</p> </div>    <h2 id="technical-information">Technical Information</h2> <p id="s-technical-information">Below you’ll find technical implementation details that may be useful to library authors. The technical API and examples below will help with creating generic query expressions that can extend the built-in functionality that Django provides.</p>  <h3 id="expression-api">Expression API</h3> <p id="s-expression-api">Query expressions implement the <a class="reference internal" href="lookups#query-expression"><span class="std std-ref">query expression API</span></a>, but also expose a number of extra methods and attributes listed below. All query expressions must inherit from <code>Expression()</code> or a relevant subclass.</p> <p>When a query expression wraps another expression, it is responsible for calling the appropriate methods on the wrapped expression.</p> <dl class="class"> <dt id="django.db.models.Expression">
<code>class Expression</code> <a class="reference internal" href="https://docs.djangoproject.com/en/1.11/_modules/django/db/models/expressions/#Expression"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="attribute"> <dt id="django.db.models.Expression.contains_aggregate">
<code>contains_aggregate</code> </dt> <dd>
<p>Tells Django that this expression contains an aggregate and that a <code>GROUP BY</code> clause needs to be added to the query.</p> </dd>
</dl> <dl class="method"> <dt id="django.db.models.Expression.resolve_expression">
<code>resolve_expression(query=None, allow_joins=True, reuse=None, summarize=False, for_save=False)</code> </dt> <dd>
<p>Provides the chance to do any pre-processing or validation of the expression before it’s added to the query. <code>resolve_expression()</code> must also be called on any nested expressions. A <code>copy()</code> of <code>self</code> should be returned with any necessary transformations.</p> <p><code>query</code> is the backend query implementation.</p> <p><code>allow_joins</code> is a boolean that allows or denies the use of joins in the query.</p> <p><code>reuse</code> is a set of reusable joins for multi-join scenarios.</p> <p><code>summarize</code> is a boolean that, when <code>True</code>, signals that the query being computed is a terminal aggregate query.</p> </dd>
</dl> <dl class="method"> <dt id="django.db.models.Expression.get_source_expressions">
<code>get_source_expressions()</code> </dt> <dd>
<p>Returns an ordered list of inner expressions. For example:</p> <pre data-language="python">&gt;&gt;&gt; Sum(F('foo')).get_source_expressions()
[F('foo')]
</pre> </dd>
</dl> <dl class="method"> <dt id="django.db.models.Expression.set_source_expressions">
<code>set_source_expressions(expressions)</code> </dt> <dd>
<p>Takes a list of expressions and stores them such that <code>get_source_expressions()</code> can return them.</p> </dd>
</dl> <dl class="method"> <dt id="django.db.models.Expression.relabeled_clone">
<code>relabeled_clone(change_map)</code> </dt> <dd>
<p>Returns a clone (copy) of <code>self</code>, with any column aliases relabeled. Column aliases are renamed when subqueries are created. <code>relabeled_clone()</code> should also be called on any nested expressions and assigned to the clone.</p> <p><code>change_map</code> is a dictionary mapping old aliases to new aliases.</p> <p>Example:</p> <pre data-language="python">def relabeled_clone(self, change_map):
    clone = copy.copy(self)
    clone.expression = self.expression.relabeled_clone(change_map)
    return clone
</pre> </dd>
</dl> <dl class="method"> <dt id="django.db.models.Expression.convert_value">
<code>convert_value(value, expression, connection, context)</code> </dt> <dd>
<p>A hook allowing the expression to coerce <code>value</code> into a more appropriate type.</p> </dd>
</dl> <dl class="method"> <dt id="django.db.models.Expression.get_group_by_cols">
<code>get_group_by_cols()</code> </dt> <dd>
<p>Responsible for returning the list of columns references by this expression. <code>get_group_by_cols()</code> should be called on any nested expressions. <code>F()</code> objects, in particular, hold a reference to a column.</p> </dd>
</dl> <dl class="method"> <dt id="django.db.models.Expression.asc">
<code>asc(nulls_first=False, nulls_last=False)</code> </dt> <dd>
<p>Returns the expression ready to be sorted in ascending order.</p> <p><code>nulls_first</code> and <code>nulls_last</code> define how null values are sorted.</p> <div class="versionchanged"> <span class="title">Changed in Django 1.11:</span> <p>The <code>nulls_last</code> and <code>nulls_first</code> parameters were added.</p> </div> </dd>
</dl> <dl class="method"> <dt id="django.db.models.Expression.desc">
<code>desc(nulls_first=False, nulls_last=False)</code> </dt> <dd>
<p>Returns the expression ready to be sorted in descending order.</p> <p><code>nulls_first</code> and <code>nulls_last</code> define how null values are sorted.</p> <div class="versionchanged"> <span class="title">Changed in Django 1.11:</span> <p>The <code>nulls_first</code> and <code>nulls_last</code> parameters were added.</p> </div> </dd>
</dl> <dl class="method"> <dt id="django.db.models.Expression.reverse_ordering">
<code>reverse_ordering()</code> </dt> <dd>
<p>Returns <code>self</code> with any modifications required to reverse the sort order within an <code>order_by</code> call. As an example, an expression implementing <code>NULLS LAST</code> would change its value to be <code>NULLS FIRST</code>. Modifications are only required for expressions that implement sort order like <code>OrderBy</code>. This method is called when <a class="reference internal" href="querysets#django.db.models.query.QuerySet.reverse" title="django.db.models.query.QuerySet.reverse"><code>reverse()</code></a> is called on a queryset.</p> </dd>
</dl> </dd>
</dl>   <h3 id="writing-your-own-query-expressions">Writing your own Query Expressions</h3> <p id="s-writing-your-own-query-expressions">You can write your own query expression classes that use, and can integrate with, other query expressions. Let’s step through an example by writing an implementation of the <code>COALESCE</code> SQL function, without using the built-in <a class="reference internal" href="#func-expressions"><span class="std std-ref">Func() expressions</span></a>.</p> <p>The <code>COALESCE</code> SQL function is defined as taking a list of columns or values. It will return the first column or value that isn’t <code>NULL</code>.</p> <p>We’ll start by defining the template to be used for SQL generation and an <code>__init__()</code> method to set some attributes:</p> <pre data-language="python">import copy
from django.db.models import Expression

class Coalesce(Expression):
    template = 'COALESCE( %(expressions)s )'

    def __init__(self, expressions, output_field):
      super(Coalesce, self).__init__(output_field=output_field)
      if len(expressions) &lt; 2:
          raise ValueError('expressions must have at least 2 elements')
      for expression in expressions:
          if not hasattr(expression, 'resolve_expression'):
              raise TypeError('%r is not an Expression' % expression)
      self.expressions = expressions
</pre> <p>We do some basic validation on the parameters, including requiring at least 2 columns or values, and ensuring they are expressions. We are requiring <code>output_field</code> here so that Django knows what kind of model field to assign the eventual result to.</p> <p>Now we implement the pre-processing and validation. Since we do not have any of our own validation at this point, we just delegate to the nested expressions:</p> <pre data-language="python">def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
    c = self.copy()
    c.is_summary = summarize
    for pos, expression in enumerate(self.expressions):
        c.expressions[pos] = expression.resolve_expression(query, allow_joins, reuse, summarize, for_save)
    return c
</pre> <p>Next, we write the method responsible for generating the SQL:</p> <pre data-language="python">def as_sql(self, compiler, connection, template=None):
    sql_expressions, sql_params = [], []
    for expression in self.expressions:
        sql, params = compiler.compile(expression)
        sql_expressions.append(sql)
        sql_params.extend(params)
    template = template or self.template
    data = {'expressions': ','.join(sql_expressions)}
    return template % data, params

def as_oracle(self, compiler, connection):
    """
    Example of vendor specific handling (Oracle in this case).
    Let's make the function name lowercase.
    """
    return self.as_sql(compiler, connection, template='coalesce( %(expressions)s )')
</pre> <p><code>as_sql()</code> methods can support custom keyword arguments, allowing <code>as_vendorname()</code> methods to override data used to generate the SQL string. Using <code>as_sql()</code> keyword arguments for customization is preferable to mutating <code>self</code> within <code>as_vendorname()</code> methods as the latter can lead to errors when running on different database backends. If your class relies on class attributes to define data, consider allowing overrides in your <code>as_sql()</code> method.</p> <p>We generate the SQL for each of the <code>expressions</code> by using the <code>compiler.compile()</code> method, and join the result together with commas. Then the template is filled out with our data and the SQL and parameters are returned.</p> <p>We’ve also defined a custom implementation that is specific to the Oracle backend. The <code>as_oracle()</code> function will be called instead of <code>as_sql()</code> if the Oracle backend is in use.</p> <p>Finally, we implement the rest of the methods that allow our query expression to play nice with other query expressions:</p> <pre data-language="python">def get_source_expressions(self):
    return self.expressions

def set_source_expressions(self, expressions):
    self.expressions = expressions
</pre> <p>Let’s see how it works:</p> <pre data-language="python">&gt;&gt;&gt; from django.db.models import F, Value, CharField
&gt;&gt;&gt; qs = Company.objects.annotate(
...    tagline=Coalesce([
...        F('motto'),
...        F('ticker_name'),
...        F('description'),
...        Value('No Tagline')
...        ], output_field=CharField()))
&gt;&gt;&gt; for c in qs:
...     print("%s: %s" % (c.name, c.tagline))
...
Google: Do No Evil
Apple: AAPL
Yahoo: Internet Company
Django Software Foundation: No Tagline
</pre>   <h3 id="adding-support-in-third-party-database-backends">Adding support in third-party database backends</h3> <p id="s-adding-support-in-third-party-database-backends">If you’re using a database backend that uses a different SQL syntax for a certain function, you can add support for it by monkey patching a new method onto the function’s class.</p> <p>Let’s say we’re writing a backend for Microsoft’s SQL Server which uses the SQL <code>LEN</code> instead of <code>LENGTH</code> for the <a class="reference internal" href="database-functions#django.db.models.functions.Length" title="django.db.models.functions.Length"><code>Length</code></a> function. We’ll monkey patch a new method called <code>as_sqlserver()</code> onto the <code>Length</code> class:</p> <pre data-language="python">from django.db.models.functions import Length

def sqlserver_length(self, compiler, connection):
    return self.as_sql(compiler, connection, function='LEN')

Length.as_sqlserver = sqlserver_length
</pre> <p>You can also customize the SQL using the <code>template</code> parameter of <code>as_sql()</code>.</p> <p>We use <code>as_sqlserver()</code> because <code>django.db.connection.vendor</code> returns <code>sqlserver</code> for the backend.</p> <p>Third-party backends can register their functions in the top level <code>__init__.py</code> file of the backend package or in a top level <code>expressions.py</code> file (or package) that is imported from the top level <code>__init__.py</code>.</p> <p>For user projects wishing to patch the backend that they’re using, this code should live in an <a class="reference internal" href="../applications#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code>AppConfig.ready()</code></a> method.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/1.11/ref/models/expressions/" class="_attribution-link">https://docs.djangoproject.com/en/1.11/ref/models/expressions/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
