
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Explicit Type Conversion - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Converts between types using a combination of explicit and implicit conversions. ">
  <meta name="keywords" content="explicit, type, conversion, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/explicit_cast.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Explicit type conversion</h1>            <p>Converts between types using a combination of explicit and implicit conversions.</p>
<h3 id="Syntax">Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>(</code> <span class="t-spar">new_type</span> <code>) </code> <span class="t-spar">expression</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">new_type</span> <code>( </code> <span class="t-spar">expression</span> <code>) </code> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">new_type</span> <code>( </code> <span class="t-spar">expressions</span> <code>) </code> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">new_type</span> <code>( </code> <code>) </code> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">new_type</span> <code>{ </code> <span class="t-spar">expression-list</span><span class="t-mark">(optional)</span> <code>} </code> </td> <td> (5) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">template-name</span> <code>( </code> <span class="t-spar">expressions</span><span class="t-mark">(optional)</span> <code>) </code> </td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">template-name</span> <code>{ </code> <span class="t-spar">expressions</span><span class="t-mark">(optional)</span> <code>} </code> </td> <td> (7) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td>
</tr> 
</table> <p>Returns a value of type <code>new_type</code>.</p>
<h3 id="Explanation">Explanation</h3> <div class="t-li1">
<span class="t-li">1)</span> When the <i>C-style cast expression</i> is encountered, the compiler attempts to interpret it as the following cast expressions, in this order:</div> <div class="t-li2">
<span class="t-li">a)</span> <code><a href="const_cast" title="cpp/language/const cast">const_cast</a>&lt;new_type&gt;(expression)</code>;</div> <div class="t-li2">
<span class="t-li">b)</span> <code><a href="static_cast" title="cpp/language/static cast">static_cast</a>&lt;new_type&gt;(expression)</code>, with extensions: pointer or reference to a <a href="derived_class" title="cpp/language/derived class">derived class</a> is additionally allowed to be cast to pointer or reference to unambiguous base class (and vice versa) even if the base class is <a href="access" title="cpp/language/access">inaccessible</a> (that is, this cast ignores the private inheritance specifier). Same applies to casting <a href="pointer" title="cpp/language/pointer">pointer to member</a> to pointer to member of unambiguous non-virtual base;</div> <div class="t-li2">
<span class="t-li">c)</span> <code>static_cast</code> (with extensions) followed by <code>const_cast</code>;</div> <div class="t-li2">
<span class="t-li">d)</span> <code><a href="reinterpret_cast" title="cpp/language/reinterpret cast">reinterpret_cast</a>&lt;new_type&gt;(expression)</code>;</div> <div class="t-li2">
<span class="t-li">e)</span> <code>reinterpret_cast</code> followed by <code>const_cast</code>.</div> <div class="t-li1">
 The first choice that satisfies the requirements of the respective cast operator is selected, even if it cannot be compiled (see example). If the cast can be interpreted in more than one way as <code>static_cast</code> followed by a <code>const_cast</code>, it cannot be compiled.</div> <div class="t-li1">
 In addition, C-style cast notation is allowed to cast from, to, and between pointers to incomplete class type. If both <span class="t-spar">expression</span> and <span class="t-spar">new_type</span> are pointers to incomplete class types, it's unspecified whether static_cast or reinterpret_cast gets selected.</div> <div class="t-li1">
<span class="t-li">2)</span> The <i>functional cast expression</i> consists of a simple type specifier or a typedef specifier (in other words, a single-word type name: <code>unsigned int(expression)</code> or <code>int*(expression)</code> are not valid), followed by a single expression in parentheses. This cast expression is exactly equivalent to the corresponding C-style cast expression.</div> <div class="t-li1">
<span class="t-li">3)</span> If there are more than one expression in parentheses, <span class="t-spar">new_type</span> must be a class with a suitably declared <a href="constructor" title="cpp/language/constructor" class="mw-redirect">constructor</a>. This expression is a prvalue of type <span class="t-spar">new_type</span> <span class="t-rev-inl t-until-cxx17"><span>designating a temporary</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>whose result object is</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> <a href="direct_initialization" title="cpp/language/direct initialization">direct-initialized</a> with <span class="t-spar">expressions</span>.</div> <div class="t-li1">
<span class="t-li">4)</span> If <span class="t-spar">new_type</span> names a non-array complete object type, this expression is an prvalue of type <span class="t-spar">new_type</span>, <span class="t-rev-inl t-until-cxx17"><span>designating a temporary</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>whose result object is (possibly with added cv-qualifiers)</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> of that type. If <span class="t-spar">new_type</span> is an object type, the object is <a href="value_initialization" title="cpp/language/value initialization">value-initialized</a>. If <span class="t-spar">new_type</span> is (possibly <a href="cv" title="cpp/language/cv">cv-qualified</a>) <code>void</code>, the expression is a void prvalue <span class="t-rev-inl t-since-cxx17"><span>without a result object</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.</div> <div class="t-li1">
<span class="t-li">5)</span> A single-word type name followed by a <i>braced-init-list</i> is a prvalue of the specified type <span class="t-rev-inl t-until-cxx17"><span>designating a temporary</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>whose result object is</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> <a href="list_initialization" title="cpp/language/list initialization">direct-list-initialized</a> with the specified <i>braced-init-list</i>. If <span class="t-spar">new_type</span> is (possibly <a href="cv" title="cpp/language/cv">cv-qualified</a>) <code>void</code>, the expression is a void prvalue <span class="t-rev-inl t-since-cxx17"><span>without a result object</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.. This is the only cast expression that can create an <a href="array#Array_rvalues" title="cpp/language/array">array prvalue</a>.</div> <div class="t-li1">
<span class="t-li">6,7)</span> Same as <span class="t-v">(2-5)</span>, except first performs <a href="deduction_guide" title="cpp/language/class template argument deduction">class template argument deduction</a>, </div> <p>As with all cast expressions, the result is:</p>
<ul>
<li> an lvalue if <span class="t-spar">new_type</span> is an lvalue reference type or an rvalue reference to function type; </li>
<li> an xvalue if <span class="t-spar">new_type</span> is an rvalue reference to object type; </li>
<li> a prvalue otherwise. </li>
</ul> <h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">double f = 3.14;
unsigned int n1 = (unsigned int)f; // C-style cast
unsigned int n2 = unsigned(f);     // functional cast
 
class C1;
class C2;
C2* foo(C1* p)
{
    return (C2*)p; // casts incomplete type to incomplete type
}
 
// In this example, C-style cast is interpreted as static_cast
// even though it would work as reinterpret_cast
struct A {};
struct I1 : A {};
struct I2 : A {};
struct D : I1, I2 {};
 
int main()
{
    D* d = nullptr;
//  A* a = (A*)d;                   // compile-time error
    A* a = reinterpret_cast&lt;A*&gt;(d); // this compiles
}</pre></div> </div> <h3 id="References">References</h3>  <ul>
<li> C++11 standard (ISO/IEC 14882:2011): </li>
<ul>
<li> 5.2.3 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 5.4 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
<li> C++98 standard (ISO/IEC 14882:1998): </li>
<ul>
<li> 5.2.3 Explicit type conversion (functional notation) [expr.type.conv] </li>
<li> 5.4 Explicit type conversion (cast notation) [expr.cast] </li>
</ul>
</ul>         <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <a href="const_cast" title="cpp/language/const cast"> const_cast conversion </a> </td> <td> adds or removes const</td>
</tr> <tr class="t-dsc"> <td> <a href="static_cast" title="cpp/language/static cast"> static_cast conversion </a> </td> <td> performs basic conversions</td>
</tr> <tr class="t-dsc"> <td> <a href="dynamic_cast" title="cpp/language/dynamic cast"> dynamic_cast conversion </a> </td> <td> performs checked polymorphic conversions</td>
</tr> <tr class="t-dsc"> <td> <a href="reinterpret_cast" title="cpp/language/reinterpret cast"> reinterpret_cast conversion </a> </td> <td> performs general low-level conversions</td>
</tr> <tr class="t-dsc"> <td> <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect"> standard conversions </a> </td> <td> implicit conversions from one type to another</td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/explicit_cast" class="_attribution-link">http://en.cppreference.com/w/cpp/language/explicit_cast</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
