
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Array Declaration - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Declares an object of array type. ">
  <meta name="keywords" content="array, declaration, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/language/array.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Array declaration</h1>            <p>Declares an object of array type.</p>
<h3 id="Syntax">Syntax</h3> <p>An array declaration is any simple declaration whose <a href="declarations" title="cpp/language/declarations">declarator</a> has the form.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">noptr-declarator</span> <code>[</code> <span class="t-spar">expr</span><span class="t-mark">(optional)</span> <code>]</code> <span class="t-spar">attr</span><span class="t-mark">(optional)</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">noptr-declarator</span> </td> <td> - </td> <td> any valid <span class="t-spar">declarator</span>, but if it begins with <code>*</code>, <code>&amp;</code>, or <code>&amp;&amp;</code>, it has to be surrounded by parentheses. </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">attr</span><span class="t-mark-rev t-since-cxx11">(C++11)</span> </td> <td> - </td> <td> optional list of <a href="attributes" title="cpp/language/attributes">attributes</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">expr</span> </td> <td> - </td> <td> <span class="t-rev-inl t-until-cxx14"><span>an <a href="constant_expression" title="cpp/language/constant expression">integral constant expression</a></span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span><span class="t-rev-inl t-since-cxx14"><span>a <a href="constant_expression" title="cpp/language/constant expression">converted constant expression</a> of type <code><a href="../types/size_t" title="cpp/types/size t">std::size_t</a></code></span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>, which evaluates to a value greater than zero </td>
</tr>
</table> <p>A declaration of the form <code>T a[N];</code>, declares <code>a</code> as an array object that consists of <code>N</code> contiguously allocated objects of type <code>T</code>. The elements of an array are numbered <code>0, …, N - 1</code>, and may be accessed with the <a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript operator []</a>, as in <code>a[0]</code>, …, <code>a[N - 1]</code>.</p>
<p>Arrays can be constructed from any <a href="types" title="cpp/language/types">fundamental type</a> (except <code>void</code>), <a href="pointer" title="cpp/language/pointer">pointers</a>, <a href="pointer" title="cpp/language/pointer">pointers to members</a>, <a href="classes" title="cpp/language/classes">classes</a>, <a href="enum" title="cpp/language/enum">enumerations</a>, or from other arrays (in which case the array is said to be multi-dimensional).</p>
<p>There are no arrays of references or arrays of functions.</p>
<p>Applying <a href="cv" title="cpp/language/cv">cv-qualifiers</a> to an array type (through typedef or template type manipulation) applies the qualifiers to the element type, but any array type whose elements are of cv-qualified type is considered to have the same cv-qualification.</p>
<div class="cpp source-cpp"><pre data-language="cpp">// a and b have the same const-qualified type "array of 5 const char"
typedef const char CC;
CC a[5] = {}; 
typedef char CA[5];
const CA b = {};</pre></div> <p>When used with <a href="new" title="cpp/language/new">new[]-expression</a>, the size of an array may be zero; such an array has no elements:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int* p = new int[0]; // accessing p[0] or *p is undefined
delete[] p; // cleanup still required</pre></div> <h4 id="Assignment">Assignment</h4> <p>Objects of array type cannot be modified as a whole: even though they are <a href="value_category" title="cpp/language/value category">lvalues</a> (e.g. an address of array can be taken), they cannot appear on the left hand side of an assignment operator:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int a[3] = {1, 2, 3}, b[3] = {4, 5, 6};
int (*p)[3] = &amp;a; // okay: address of a can be taken
a = b;            // error: a is an array
struct { int c[3]; } s1, s2 = {3, 4, 5};
s1 = s2; // okay: implicity-defined copy assignment operator
         // can assign data members of array type</pre></div> <h4 id="Array-to-pointer_decay">Array-to-pointer decay</h4> <p>There is an <a href="implicit_cast" title="cpp/language/implicit cast" class="mw-redirect">implicit conversion</a> from lvalues and rvalues of array type to rvalues of pointer type: it constructs a pointer to the first element of an array. This conversion is used whenever arrays appear in context where arrays are not expected, but pointers are:</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;iterator&gt;
 
void g(int (&amp;a)[3])
{
    std::cout &lt;&lt; a[0] &lt;&lt; '\n';
}
 
void f(int* p)
{
    std::cout &lt;&lt; *p &lt;&lt; '\n';
}
 
int main()
{
    int a[3] = {1, 2, 3};
    int* p = a;
 
    std::cout &lt;&lt; sizeof a &lt;&lt; '\n'  // prints size of array
              &lt;&lt; sizeof p &lt;&lt; '\n'; // prints size of a pointer
 
    // where arrays are acceptable, but pointers aren't, only arrays may be used
    g(a); // okay: function takes an array by reference
//  g(p); // error
 
    for(int n: a)              // okay: arrays can be used in range-for loops
        std::cout &lt;&lt; n &lt;&lt; ' '; // prints elements of the array
//  for(int n: p)              // error
//      std::cout &lt;&lt; n &lt;&lt; ' ';
 
    std::iota(std::begin(a), std::end(a), 7); // okay: begin and end take arrays
//  std::iota(std::begin(p), std::end(p), 7); // error
 
    // where pointers are acceptable, but arrays aren't, both may be used:
    f(a); // okay: function takes a pointer
    f(p); // okay: function takes a pointer
 
    std::cout &lt;&lt; *a &lt;&lt; '\n' // prints the first element
              &lt;&lt; *p &lt;&lt; '\n' // same
              &lt;&lt; *(a + 1) &lt;&lt; ' ' &lt;&lt; a[1] &lt;&lt; '\n'  // prints the second element
              &lt;&lt; *(p + 1) &lt;&lt; ' ' &lt;&lt; p[1] &lt;&lt; '\n'; // same
}</pre></div> </div> <h4 id="Multidimensional_arrays">Multidimensional arrays</h4> <p>When the element type of an array is another array, it is said that the array is multidimensional:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// array of 2 arrays of 3 int each
int a[2][3] = {{1, 2, 3},  // can be viewed as a 2 × 3 matrix
               {4, 5, 6}}; // with row-major layout</pre></div> <p>Note that when array-to-pointer decay is applied, a multidimensional array is converted to a pointer to its first element (e.g., a pointer to its first row or to its first plane): array-to-pointer decay is applied only once.</p>
<div class="cpp source-cpp"><pre data-language="cpp">int a[2];            // array of 2 int
int* p1 = a;         // a decays to a pointer to the first element of a
 
int b[2][3];         // array of 2 arrays of 3 int
// int** p2 = b;     // error: b does not decay to int**
int (*p2)[3] = b;    // b decays to a pointer to the first 3-element row of b
 
int c[2][3][4];      // array of 2 arrays of 3 arrays of 4 int
// int*** p3 = c;    // error: c does not decay to int***
int (*p3)[3][4] = c; // c decays to a pointer to the first 3 × 4-element plane of c</pre></div> <h4 id="Arrays_of_unknown_bound">Arrays of unknown bound</h4> <p>If <span class="t-spar">expr</span> is omitted in the declaration of an array, the type declared is "array of unknown bound of T", which is a kind of <a href="incomplete_type" title="cpp/language/incomplete type" class="mw-redirect">incomplete type</a>, except when used in a declaration with an <a href="aggregate_initialization" title="cpp/language/aggregate initialization">aggregate initializer</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">extern int x[];      // the type of x is "array of unknown bound of int"
int a[] = {1, 2, 3}; // the type of a is "array of 3 int"</pre></div> <p>Because array elements cannot have incomplete type, multidimensional arrays cannot have unknown bound in a dimension other than the first:</p>
<div class="cpp source-cpp"><pre data-language="cpp">extern int a[][2]; // okay: array of unknown bound of arrays of 2 int
extern int b[2][]; // error: array has incomplete element type</pre></div> <p>References and pointers to arrays of unknown bound can be formed, but cannot be initialized or assigned from arrays and pointers to arrays of known bound. Note that in the C programming language, pointers to arrays of unknown bound are compatible with pointers to arrays of known bound and are thus convertible and assignable in both directions.</p>
<div class="cpp source-cpp"><pre data-language="cpp">extern int a1[];
int (&amp;r1)[] = a1;  // okay
int (*p1)[] = &amp;a1; // okay
int (*q)[2] = &amp;a1; // error (but okay in C)
 
int a2[] = {1, 2, 3};
int (&amp;r2)[] = a2;  // error
int (*p2)[] = &amp;a2; // error (but okay in C)</pre></div> <p>Pointers to arrays of unknown bound cannot participate in <a href="operator_arithmetic#Additive_operators" title="cpp/language/operator arithmetic">pointer arithmetic</a> and cannot be used on the left of the <a href="operator_member_access#Built-in_subscript_operator" title="cpp/language/operator member access">subscript operator</a>, but can be dereferenced. <span class="t-rev-inl t-until-cxx14"><span>Pointers and references to arrays of unknown bound cannot be used in <a href="function#Parameter_list" title="cpp/language/function">function parameters</a></span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span>.</p>
<h4 id="Array_rvalues">Array rvalues</h4> <p>Although arrays cannot be returned from functions by value and cannot be targets of most cast expressions, array <a href="value_category" title="cpp/language/value category">prvalues</a> may be formed by using a type alias to construct an array temporary using <a href="explicit_cast" title="cpp/language/explicit cast">brace-initialized functional cast</a>.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> Like class prvalues, array prvalues convert to xvalues by <a href="implicit_cast#Temporary_materialization" title="cpp/language/implicit conversion">temporary materialization</a> when evaluated.</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <p>Array <a href="value_category" title="cpp/language/value category">xvalues</a> may be formed directly by accessing an array member of a class rvalue or by using <code>std::move</code> or another cast or function call that returns an rvalue reference.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;utility&gt;
 
void f(int (&amp;&amp;x)[2][3])
{
    std::cout &lt;&lt; sizeof x &lt;&lt; '\n';
}
 
struct X
{
    int i[2][3];
} x;
 
template&lt;typename T&gt; using identity = T;
 
int main()
{
    std::cout &lt;&lt; sizeof X().i &lt;&lt; '\n';           // size of the array
    f(X().i);                                    // okay: binds to xvalue
//  f(x.i);                                      // error: cannot bind to lvalue
 
    int a[2][3];
    f(std::move(a));                             // okay: binds to xvalue
 
    using arr_t = int[2][3];
    f(arr_t{});                                  // okay: binds to prvalue
    f(identity&lt;int[][3]&gt;{{1, 2, 3}, {4, 5, 6}}); // okay: binds to prvalue
 
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">24
24
24
24
24</pre></div> </div> <h3 id="See_also">See also</h3>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/array" class="_attribution-link">http://en.cppreference.com/w/cpp/language/array</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
