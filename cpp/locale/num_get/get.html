
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Std&#58;&#58;num_get&#58;&#58;do_get - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Conversion occurs in three stages. ">
  <meta name="keywords" content="std, num, get, chart, inputit, do, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cpp/locale/num_get/get.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">std::num_get&lt;CharT,InputIt&gt;::get, std::num_get&lt;CharT,InputIt&gt;::do_get</h1>            <table class="t-dcl-begin">  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="12">(1)</td> <td></td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">public:
iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, bool&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, long&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, long long&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, unsigned short&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, unsigned int&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, unsigned long&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, unsigned long long&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, float&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, double&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, long double&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">iter_type get( iter_type in, iter_type end, std::ios_base&amp; str, 
               std::ios_base::iostate&amp; err, void*&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr>   <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="12">(2)</td> <td></td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">protected:
virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, bool&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, long&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, long long&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, unsigned short&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, unsigned int&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, unsigned long&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, unsigned long long&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, float&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, double&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, long double&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">virtual iter_type do_get( iter_type in, iter_type end, std::ios_base&amp; str, 
                          std::ios_base::iostate&amp; err, void*&amp; v ) const;</pre>
</td>  <td class="t-dcl-nopad"> </td> </tr>   </table> <div class="t-li1">
<span class="t-li">1)</span> Public member function, calls the member function <code>do_get</code> of the most derived class.</div> <div class="t-li1">
<span class="t-li">2)</span> Reads characters from the input iterator <code>in</code> and generates the value of the type of <code>v</code>, taking into account IO stream formatting flags from <code>str.flags()</code>, character classification rules from <code><a href="../use_facet"><span class="kw1894">std::<span class="me2">use_facet</span></span></a><span class="sy1">&lt;</span><a href="../ctype"><span class="kw1935">std::<span class="me2">ctype</span></span></a><span class="sy1">&lt;</span>charT<span class="sy1">&gt;&gt;</span><span class="br0">(</span>str.<span class="me1">getloc</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span></code>, and numeric punctuation characters from <code><a href="../use_facet"><span class="kw1894">std::<span class="me2">use_facet</span></span></a><span class="sy1">&lt;</span><a href="../numpunct"><span class="kw1958">std::<span class="me2">numpunct</span></span></a><span class="sy1">&lt;</span>charT<span class="sy1">&gt;&gt;</span><span class="br0">(</span>str.<span class="me1">getloc</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span></code>. This function is called by all formatted input stream operators such as <code><a href="../../io/cin"><span class="kw1753">std::<span class="me2">cin</span></span></a> <span class="sy1">&gt;&gt;</span> n<span class="sy4">;</span></code>.</div> <p>Conversion occurs in three stages.</p>
<h4 id="Stage_1:_conversion_specifier_selection">Stage 1: conversion specifier selection</h4> <ul><li> I/O format flags are obtained, as if by </li></ul> <dl>
<dd> <code>fmtflags basefield <span class="sy1">=</span> <span class="br0">(</span>str.<span class="me1">flags</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">&amp;</span> <a href="../../io/ios_base/fmtflags"><span class="kw1679">std::<span class="me2">ios_base</span><span class="sy4">::</span><span class="me2">basefield</span></span></a><span class="br0">)</span><span class="sy4">;</span></code> </dd>
<dd> <code>fmtflags boolalpha <span class="sy1">=</span> <span class="br0">(</span>str.<span class="me1">flags</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">&amp;</span> <a href="../../io/ios_base/fmtflags"><span class="kw1687">std::<span class="me2">ios_base</span><span class="sy4">::</span><span class="me2">boolalpha</span></span></a><span class="br0">)</span><span class="sy4">;</span></code> </dd>
</dl> <ul><li> If the type of <code>v</code> is an integer type, the the first applicable choice of the following five is selected: </li></ul> <dl>
<dd> If <code>basefield == oct</code>, will use conversion specifier <code>%o</code> </dd>
<dd> If <code>basefield == hex</code>, will use conversion specifier <code>%X</code> </dd>
<dd> If <code>basefield == 0</code>, will use conversion specifier <code>%i</code> </dd>
<dd> If the type of <code>v</code> is signed, will use conversion specifier <code>%d</code> </dd>
<dd> If the type of <code>v</code> is unsigned, will use conversion specifier <code>%u</code> </dd>
</dl> <ul>
<li> For integer types, length modifier is added to the conversion specification if necessary: <code>h</code> for <code>short</code> and <code>unsigned short</code>, <code>l</code> for <code>long</code> and <code>unsigned long</code>, <code>ll</code> for <code>long long</code> and <code>unsigned long long</code> </li>
<li> If the type of <code>v</code> is <code>float</code>, will use conversion specifier <code>%g</code> </li>
<li> If the type of <code>v</code> is <code>double</code>, will use conversion specifier <code>%lg</code> </li>
<li> If the type of <code>v</code> is <code>long double</code>, will use conversion specifier <code>%Lg</code> </li>
<li> If the type of <code>v</code> is <code>void*</code>, will use conversion specifier <code>%p</code> </li>
<li> If the type of <code>v</code> is <code>bool</code> and <code>boolalpha==0</code>, proceeds as if the type of <code>v</code> is <code>long</code>, except for the value to be stored in <code>v</code> in stage 3. </li>
<li> If the type of <code>v</code> is <code>bool</code> and <code>boolalpha!=0</code>, the following replaces stages 2 and 3: <ul>
<li> Successive characters obtained from the input iterator <code>in</code> are matched against the character sequences obtained from <code><a href="../use_facet"><span class="kw1894">std::<span class="me2">use_facet</span></span></a><span class="sy1">&lt;</span><a href="../numpunct"><span class="kw1958">std::<span class="me2">numpunct</span></span></a><span class="sy1">&lt;</span>charT<span class="sy1">&gt;&gt;</span><span class="br0">(</span>str.<span class="me1">getloc</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">falsename</span><span class="br0">(</span><span class="br0">)</span></code> and <code><a href="../use_facet"><span class="kw1894">std::<span class="me2">use_facet</span></span></a><span class="sy1">&lt;</span><a href="../numpunct"><span class="kw1958">std::<span class="me2">numpunct</span></span></a><span class="sy1">&lt;</span>charT<span class="sy1">&gt;</span> <span class="sy1">&gt;</span><span class="br0">(</span>str.<span class="me1">getloc</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">truename</span><span class="br0">(</span><span class="br0">)</span></code> only as necessary as to identify the unique match. The input iterator <code>in</code> is compared to <code>end</code> only when necessary to obtain a character. </li>
<li> If the target sequence is uniquely matched, <code>v</code> is set to the corresponding <code>bool</code> value. Otherwise <code>false</code> is stored in <code>v</code> and <code><a href="../../io/ios_base/iostate" title="cpp/io/ios base/iostate">std::ios_base::failbit</a></code> is assigned to <code>err</code>. If unique match could not be found before the input ended (<code>in==end</code>), <code>err<span class="sy3">|</span><span class="sy1">=</span><a href="../../io/ios_base/iostate"><span class="kw1698">std::<span class="me2">ios_base</span><span class="sy4">::</span><span class="me2">eofbit</span></span></a></code> is executed. </li>
</ul> </li>
</ul> <h4 id="Stage_2:_character_extraction">Stage 2: character extraction</h4> <ul>
<li> If <code>in==end</code>, Stage 2 is terminated immediately, no further characters are extracted </li>
<li> The next character is extracted from <code>in</code> as if by <code>char_type ct = *in;</code> <ul>
<li> If the character matches one of <code>"0123456789abcdefxABCDEFX+-"</code>, widened to the locale's char_type as if by <code><a href="../use_facet"><span class="kw1894">std::<span class="me2">use_facet</span></span></a><span class="sy1">&lt;</span><a href="../ctype"><span class="kw1935">std::<span class="me2">ctype</span></span></a><span class="sy1">&lt;</span>charT<span class="sy1">&gt;&gt;</span><span class="br0">(</span>str.<span class="me1">getloc</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">widen</span><span class="br0">(</span><span class="br0">)</span></code>, it is converted to the corresponding <code>char</code>. </li>
<li> If the character matches the decimal point separator (<code><a href="../use_facet"><span class="kw1894">std::<span class="me2">use_facet</span></span></a><span class="sy1">&lt;</span><a href="../numpunct"><span class="kw1958">std::<span class="me2">numpunct</span></span></a><span class="sy1">&lt;</span>charT<span class="sy1">&gt;&gt;</span><span class="br0">(</span>str.<span class="me1">getloc</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">decimal_point</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span></code>), it is replaced by <code>'.'</code>. </li>
<li> If the character matches the thousands separator (<code><a href="../use_facet"><span class="kw1894">std::<span class="me2">use_facet</span></span></a><span class="sy1">&lt;</span><a href="../numpunct"><span class="kw1958">std::<span class="me2">numpunct</span></span></a><span class="sy1">&lt;</span>charT<span class="sy1">&gt;&gt;</span><span class="br0">(</span>str.<span class="me1">getloc</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">thousands_sep</span><span class="br0">(</span><span class="br0">)</span></code>) and the thousands separation is in use at all <code><a href="../use_facet"><span class="kw1894">std::<span class="me2">use_facet</span></span></a><span class="sy1">&lt;</span><a href="../numpunct"><span class="kw1958">std::<span class="me2">numpunct</span></span></a><span class="sy1">&lt;</span>charT<span class="sy1">&gt;&gt;</span><span class="br0">(</span>str.<span class="me1">getloc</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">grouping</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">0</span></code>, then if the decimal point <code>'.'</code> has not yet been accumulated, the position of the character is remembered, but the character is otherwise ignored. If the decimal point has already been accumulated, the character is discarded and Stage 2 terminates. </li>
<li> In any case, the check is made whether the <code>char</code> obtained from the previous steps is allowed in the input field that would be parsed by <code><a href="../../io/c/scanf" title="cpp/io/c/fscanf">std::scanf</a></code> given the conversion specifier selected in Stage 1. If it is allowed, it is accumulated in a temporary buffer and Stage 2 repeats. If it is not allowed, Stage 2 terminates. </li>
</ul> </li>
</ul> <h4 id="Stage_3:_conversion_and_storage">Stage 3: conversion and storage</h4> <ul><li> The sequence of <code>char</code>s accumulated in Stage 2 is converted to a numeric value </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> The input is parsed as if by <code><a href="../../io/c/scanf" title="cpp/io/c/fscanf">std::scanf</a></code> with the conversion specifier selected in Stage 1  </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11 t-until-cxx17">
<td> The input is parsed as if by <code><a href="../../string/byte/strtol" title="cpp/string/byte/strtol">std::strtoll</a></code> for signed integer <code>v</code>, <code><a href="../../string/byte/strtoul" title="cpp/string/byte/strtoul">std::strtoull</a></code> for unsigned integer <code>v</code>, or <code><a href="../../string/byte/strtof" title="cpp/string/byte/strtof">std::strtold</a></code> for floating-point <code>v</code>  </td> <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span><br><span class="t-mark-rev t-until-cxx17">(until C++17)</span>
</td>
</tr> <tr class="t-rev t-since-cxx17">
<td> The input is parsed as if by <code><a href="../../string/byte/strtol" title="cpp/string/byte/strtol">std::strtoll</a></code> for signed integer <code>v</code>, <code><a href="../../string/byte/strtoul" title="cpp/string/byte/strtoul">std::strtoull</a></code> for unsigned integer <code>v</code>, <code><a href="../../string/byte/strtof" title="cpp/string/byte/strtof">std::strtof</a></code> for <code>float</code> <code>v</code>, <code><a href="../../string/byte/strtof" title="cpp/string/byte/strtof">std::strtod</a></code> for <code>double</code> <code>v</code>, or <code><a href="../../string/byte/strtof" title="cpp/string/byte/strtof">std::strtold</a></code> for <code>long double</code> <code>v</code>  </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <ul>
<li> If the conversion function fails to convert the entire field, the value <code>​0​</code> is stored in <code>v</code> </li>
<li> If the conversion function results in a positive value too large to fit in the type of <code>v</code>, the most positive representable value is stored in <code>v</code> </li>
<li> If the conversion function results in a negative value too large to fit in the type of <code>v</code>, the most negative representable value is stored in <code>v</code><span class="t-rev-inl t-until-cxx17"><span>, or zero for unsigned integer types.</span> <span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span> </li>
</ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> In any case, if the conversion function fails <code><a href="../../io/ios_base/iostate" title="cpp/io/ios base/iostate">std::ios_base::failbit</a></code> is assigned to <code>err</code> </li>
<li> Otherwise, the numeric result of the conversion is stored in <code>v</code> <ul><li> If the type of <code>v</code> is <code>bool</code> and boolalpha is not set, then if the value to be stored is <code>​0​</code>, <code>false</code> is stored, if the value to be stored is <code>1</code>, <code>true</code> is stored, for any other value <code><a href="../../io/ios_base/iostate" title="cpp/io/ios base/iostate">std::ios_base::failbit</a></code> is assigned to <code>err</code> and <code>true</code> is stored. </li></ul> </li>
<li> After this, digit grouping is checked. if the position of any of the thousands separators discarded in Stage 2 does not match the grouping provided by <code><a href="../use_facet"><span class="kw1894">std::<span class="me2">use_facet</span></span></a><span class="sy1">&lt;</span><a href="../numpunct"><span class="kw1958">std::<span class="me2">numpunct</span></span></a><span class="sy1">&lt;</span>charT<span class="sy1">&gt;&gt;</span><span class="br0">(</span>str.<span class="me1">getloc</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">grouping</span><span class="br0">(</span><span class="br0">)</span></code>, <code><a href="../../io/ios_base/iostate" title="cpp/io/ios base/iostate">std::ios_base::failbit</a></code> is assigned to <code>err</code>. </li>
<li> If Stage 2 was terminated by the test <code>in==end</code>, <code>err<span class="sy3">|</span><span class="sy1">=</span><a href="../../io/ios_base/iostate"><span class="kw1698">std::<span class="me2">ios_base</span><span class="sy4">::</span><span class="me2">eofbit</span></span></a></code> is executed to set the eof bit. </li>
</ul> <h3 id="Return_value">Return value</h3> <p><code>in</code>.</p>
<h3 id="Notes">Notes</h3> <p>In C++98/C++03, if an error occurs, <code>v</code> is left unchanged. In C++11, it is set to a value as described above.</p>
<p>The result of converting a negative number string into an unsigned integer was specified to produce zero until C++17, although some implementations followed the protocol of <code><a href="../../string/byte/strtoul" title="cpp/string/byte/strtoul">std::strtoull</a></code> which negates in the target type, giving <code><a href="../../types/climits"><span class="kw405">ULLONG_MAX</span></a></code> for <code>"-1"</code>, and so produce the largest value of the target type instead. As of C++17, strictly following <code><a href="../../string/byte/strtoul" title="cpp/string/byte/strtoul">std::strtoull</a></code> is the correct behavior.</p>
<p>Because stage 2 filters out characters such as 'p', 'N' or 'i', the hexadecimal floating-point numbers such as "0x1.23p-10" and the strings "NaN" or "inf" may be rejected by <code>do_get(double)</code> even if they are valid input to <code>strtod</code>: this is <a rel="nofollow" class="external text" href="http://cplusplus.github.io/LWG/lwg-active.html#2381">LWG #2381</a>.</p>
<h3 id="Example">Example</h3> <div class="t-example">
<p>An implementation of <code>operator&gt;&gt;</code> for a user-defined type.</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;locale&gt;
 
struct base { long x; };
 
template &lt;class CharT, class Traits&gt;
std::basic_istream&lt;CharT, Traits&gt;&amp;
    operator &gt;&gt;(std::basic_istream&lt;CharT, Traits&gt;&amp; is,
                base&amp; b)
{
    std::ios_base::iostate err = std::ios_base::goodbit;
    try // setting err could throw
    {
        typename std::basic_istream&lt;CharT, Traits&gt;::sentry s(is);
 
        if (s) // if stream is ready for input
        {
            std::use_facet&lt;std::num_get&lt;CharT&gt;&gt;(is.getloc()).get(is, {}, is, err, b.x);
        }
    } catch(std::ios_base::failure&amp; error)
    {
        // handle the exception
    }
    return is;
}
 
int main()
{
    base b;
 
    std::cin &gt;&gt; b;
}</pre></div> </div> <h3 id="See_also">See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../../io/basic_istream/operator_gtgt" title="cpp/io/basic istream/operator gtgt"> <span class="t-lines"><span>operator&gt;&gt;</span></span></a></div> </td> <td> extracts formatted data <br> <span class="t-mark">(public member function of <code>std::basic_istream&lt;CharT,Traits&gt;</code>)</span> </td>
</tr> </table>          <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/locale/num_get/get" class="_attribution-link">http://en.cppreference.com/w/cpp/locale/num_get/get</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
