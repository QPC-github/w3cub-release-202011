
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Working With Models - Phalcon 2 - W3cubDocs</title>
  
  <meta name="description" content="A model represents the information (data) of the application and the rules to manipulate that data. Models are primarily used for managing the rules &hellip;">
  <meta name="keywords" content="working, with, models, phalcon, phalcon~2">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/phalcon~2/reference/models.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/phalcon~2.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phalcon~2/" class="_nav-link" title="" style="margin-left:0;">Phalcon 2</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _phalcon">
				
				
<h1 id="working-with-models">Working with Models</h1> <p>A model represents the information (data) of the application and the rules to manipulate that data. Models are primarily used for managing the rules of interaction with a corresponding database table. In most cases, each table in your database will correspond to one model in your application. The bulk of your application’s business logic will be concentrated in the models.</p> <p><a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> is the base for all models in a Phalcon application. It provides database independence, basic CRUD functionality, advanced finding capabilities, and the ability to relate models to one another, among other services. <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> avoids the need of having to use SQL statements because it translates methods dynamically to the respective database engine operations.</p> <blockquote class="highlights"> <div>Models are intended to work on a database high layer of abstraction. If you need to work with databases at a lower level check out the <a class="reference internal" href="../api/phalcon_db"><em>Phalcon\Db</em></a> component documentation.</div>
</blockquote>  <h2 id="creating-models">Creating Models</h2> <p>A model is a class that extends from <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a>. It must be placed in the models directory. A model file must contain a single class; its class name should be in camel case notation:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

}
</pre> <p>The above example shows the implementation of the “Robots” model. Note that the class Robots inherits from <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a>. This component provides a great deal of functionality to models that inherit it, including basic database CRUD (Create, Read, Update, Delete) operations, data validation, as well as sophisticated search support and the ability to relate multiple models with each other.</p> <blockquote class="highlights"> <div>If you’re using PHP 5.4/5.5 it is recommended you declare each column that makes part of the model in order to save memory and reduce the memory allocation.</div>
</blockquote> <p>By default, the model “Robots” will refer to the table “robots”. If you want to manually specify another name for the mapping table, you can use the getSource() method:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    public function getSource()
    {
        return "the_robots";
    }

}
</pre> <p>The model Robots now maps to “the_robots” table. The initialize() method aids in setting up the model with a custom behavior i.e. a different table. The initialize() method is only called once during the request.</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    public function initialize()
    {
        $this-&gt;setSource("the_robots");
    }

}
</pre> <p>The initialize() method is only called once during the request, it’s intended to perform initializations that apply for all instances of the model created within the application. If you want to perform initialization tasks for every instance created you can ‘onConstruct’:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    public function onConstruct()
    {
        //...
    }

}
</pre>  <h3 id="public-properties-vs-setters-getters">Public properties vs. Setters/Getters</h3> <p>Models can be implemented with properties of public scope, meaning that each property can be read/updated from any part of the code that has instantiated that model class without any restrictions:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{
    public $id;

    public $name;

    public $price;
}
</pre> <p>By using getters and setters you can control which properties are visible publicly perform various transformations to the data (which would be impossible otherwise) and also add validation rules to the data stored in the object:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{
    protected $id;

    protected $name;

    protected $price;

    public function getId()
    {
        return $this-&gt;id;
    }

    public function setName($name)
    {
        //The name is too short?
        if (strlen($name) &lt; 10) {
            throw new \InvalidArgumentException('The name is too short');
        }
        $this-&gt;name = $name;
    }

    public function getName()
    {
        return $this-&gt;name;
    }

    public function setPrice($price)
    {
        //Negative prices aren't allowed
        if ($price &lt; 0) {
            throw new \InvalidArgumentException('Price can\'t be negative');
        }
        $this-&gt;price = $price;
    }

    public function getPrice()
    {
        //Convert the value to double before be used
        return (double) $this-&gt;price;
    }
}
</pre> <p>Public properties provide less complexity in development. However getters/setters can heavily increase the testability, extensibility and maintainability of applications. Developers can decide which strategy is more appropriate for the application they are creating. The ORM is compatible with both schemes of defining properties.</p>   <h3 id="models-in-namespaces">Models in Namespaces</h3> <p>Namespaces can be used to avoid class name collision. The mapped table is taken from the class name, in this case ‘Robots’:</p> <pre class="highlight-php" data-language="php">namespace Store\Toys;

class Robots extends \Phalcon\Mvc\Model
{

}
</pre>    <h2 id="understanding-records-to-objects">Understanding Records To Objects</h2> <p>Every instance of a model represents a row in the table. You can easily access record data by reading object properties. For example, for a table “robots” with the records:</p> <pre class="highlight-bash" data-language="bash">mysql&gt; select * from robots;
+----+------------+------------+------+
| id | name       | type       | year |
+----+------------+------------+------+
|  1 | Robotina   | mechanical | 1972 |
|  2 | Astro Boy  | mechanical | 1952 |
|  3 | Terminator | cyborg     | 2029 |
+----+------------+------------+------+
3 rows in set (0.00 sec)
</pre> <p>You could find a certain record by its primary key and then print its name:</p> <pre class="highlight-php" data-language="php">// Find record with id = 3
$robot = Robots::findFirst(3);

// Prints "Terminator"
echo $robot-&gt;name;
</pre> <p>Once the record is in memory, you can make modifications to its data and then save changes:</p> <pre class="highlight-php" data-language="php">$robot = Robots::findFirst(3);
$robot-&gt;name = "RoboCop";
$robot-&gt;save();
</pre> <p>As you can see, there is no need to use raw SQL statements. <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> provides high database abstraction for web applications.</p>   <h2 id="finding-records">Finding Records</h2> <p><a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> also offers several methods for querying records. The following examples will show you how to query one or more records from a model:</p> <pre class="highlight-php" data-language="php">// How many robots are there?
$robots = Robots::find();
echo "There are ", count($robots), "\n";

// How many mechanical robots are there?
$robots = Robots::find("type = 'mechanical'");
echo "There are ", count($robots), "\n";

// Get and print virtual robots ordered by name
$robots = Robots::find(array(
    "type = 'virtual'",
    "order" =&gt; "name"
));
foreach ($robots as $robot) {
    echo $robot-&gt;name, "\n";
}

// Get first 100 virtual robots ordered by name
$robots = Robots::find(array(
    "type = 'virtual'",
    "order" =&gt; "name",
    "limit" =&gt; 100
));
foreach ($robots as $robot) {
   echo $robot-&gt;name, "\n";
}
</pre> <p>You could also use the findFirst() method to get only the first record matching the given criteria:</p> <pre class="highlight-php" data-language="php">// What's the first robot in robots table?
$robot = Robots::findFirst();
echo "The robot name is ", $robot-&gt;name, "\n";

// What's the first mechanical robot in robots table?
$robot = Robots::findFirst("type = 'mechanical'");
echo "The first mechanical robot name is ", $robot-&gt;name, "\n";

// Get first virtual robot ordered by name
$robot = Robots::findFirst(array("type = 'virtual'", "order" =&gt; "name"));
echo "The first virtual robot name is ", $robot-&gt;name, "\n";
</pre> <p>Both find() and findFirst() methods accept an associative array specifying the search criteria:</p> <pre class="highlight-php" data-language="php">$robot = Robots::findFirst(array(
    "type = 'virtual'",
    "order" =&gt; "name DESC",
    "limit" =&gt; 30
));

$robots = Robots::find(array(
    "conditions" =&gt; "type = ?1",
    "bind"       =&gt; array(1 =&gt; "virtual")
));
</pre> <p>The available query options are:</p> <table class="docutils"> <colgroup> <col width="5%"> <col width="70%"> <col width="26%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Parameter</th> <th class="head">Description</th> <th class="head">Example</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>conditions</td> <td>Search conditions for the find operation. Is used to extract only those records that fulfill a specified criterion. By default Phalcon\Mvc\Model assumes the first parameter are the conditions.</td> <td>“conditions” =&gt; “name LIKE ‘steve%’”</td> </tr> <tr class="row-odd">
<td>columns</td> <td>Return specific columns instead of the full columns in the model. When using this option an incomplete object is returned</td> <td>“columns” =&gt; “id, name”</td> </tr> <tr class="row-even">
<td>bind</td> <td>Bind is used together with options, by replacing placeholders and escaping values thus increasing security</td> <td>“bind” =&gt; array(“status” =&gt; “A”, “type” =&gt; “some-time”)</td> </tr> <tr class="row-odd">
<td>bindTypes</td> <td>When binding parameters, you can use this parameter to define additional casting to the bound parameters increasing even more the security</td> <td>“bindTypes” =&gt; array(Column::BIND_TYPE_STR, Column::BIND_TYPE_INT)</td> </tr> <tr class="row-even">
<td>order</td> <td>Is used to sort the resultset. Use one or more fields separated by commas.</td> <td>“order” =&gt; “name DESC, status”</td> </tr> <tr class="row-odd">
<td>limit</td> <td>Limit the results of the query to results to certain range</td> <td>“limit” =&gt; 10 / “limit” =&gt; array(“number” =&gt; 10, “offset” =&gt; 5)</td> </tr> <tr class="row-even">
<td>group</td> <td>Allows to collect data across multiple records and group the results by one or more columns</td> <td>“group” =&gt; “name, status”</td> </tr> <tr class="row-odd">
<td>for_update</td> <td>With this option, <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> reads the latest available data, setting exclusive locks on each row it reads</td> <td>“for_update” =&gt; true</td> </tr> <tr class="row-even">
<td>shared_lock</td> <td>With this option, <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> reads the latest available data, setting shared locks on each row it reads</td> <td>“shared_lock” =&gt; true</td> </tr> <tr class="row-odd">
<td>cache</td> <td>Cache the resultset, reducing the continuous access to the relational system</td> <td>“cache” =&gt; array(“lifetime” =&gt; 3600, “key” =&gt; “my-find-key”)</td> </tr> <tr class="row-even">
<td>hydration</td> <td>Sets the hydration strategy to represent each returned record in the result</td> <td>“hydration” =&gt; Resultset::HYDRATE_OBJECTS</td> </tr> </tbody> </table> <p>If you prefer, there is also available a way to create queries in an object-oriented way, instead of using an array of parameters:</p> <pre class="highlight-php" data-language="php">$robots = Robots::query()
    -&gt;where("type = :type:")
    -&gt;andWhere("year &lt; 2000")
    -&gt;bind(array("type" =&gt; "mechanical"))
    -&gt;order("name")
    -&gt;execute();
</pre> <p>The static method query() returns a <a class="reference internal" href="../api/phalcon_mvc_model_criteria"><em>Phalcon\Mvc\Model\Criteria</em></a> object that is friendly with IDE autocompleters.</p> <p>All the queries are internally handled as <a class="reference internal" href="phql"><em>PHQL</em></a> queries. PHQL is a high-level, object-oriented and SQL-like language. This language provide you more features to perform queries like joining other models, define groupings, add aggregations etc.</p> <p>Lastly, there is the findFirstBy&lt;property-name&gt;() method. This method expands on the “findFirst()” method mentioned earlier. It allows you to quickly perform a retrieval from a table by using the property name in the method itself and passing it a parameter that contains the data you want to search for in that column. An example is in order, so taking our Robots model mentioned earlier :</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{
    public $id;

    public $name;

    public $price;
}
</pre> <p>We have three properties to work with here. $id, $name and $price. So, let’s say you want to retrieve the first record in the table with the name ‘Terminator’. This could be written like so :</p> <pre class="highlight-php" data-language="php">$name = "Terminator";
$robot = Robots::findFirstByName($name);

if($robot){
    $this-&gt;flash-&gt;success("The first robot with the name " . $name . " cost " . $robot-&gt;price ".");
}else{
    $this-&gt;flash-&gt;error("There were no robots found in our table with the name " . $name ".");
}
</pre> <p>Notice that we used ‘Name’ in the method call and passed the variable $name to it, which contains the name we are looking for in our table. Notice also that when we find a match with our query, all the other properties are available to us as well.</p>  <h3 id="model-resultsets">Model Resultsets</h3> <p>While findFirst() returns directly an instance of the called class (when there is data to be returned), the find() method returns a <a class="reference internal" href="../api/phalcon_mvc_model_resultset_simple"><em>Phalcon\Mvc\Model\Resultset\Simple</em></a>. This is an object that encapsulates all the functionality a resultset has like traversing, seeking specific records, counting, etc.</p> <p>These objects are more powerful than standard arrays. One of the greatest features of the <a class="reference internal" href="../api/phalcon_mvc_model_resultset"><em>Phalcon\Mvc\Model\Resultset</em></a> is that at any time there is only one record in memory. This greatly helps in memory management especially when working with large amounts of data.</p> <pre class="highlight-php" data-language="php">// Get all robots
$robots = Robots::find();

// Traversing with a foreach
foreach ($robots as $robot) {
    echo $robot-&gt;name, "\n";
}

// Traversing with a while
$robots-&gt;rewind();
while ($robots-&gt;valid()) {
    $robot = $robots-&gt;current();
    echo $robot-&gt;name, "\n";
    $robots-&gt;next();
}

// Count the resultset
echo count($robots);

// Alternative way to count the resultset
echo $robots-&gt;count();

// Move the internal cursor to the third robot
$robots-&gt;seek(2);
$robot = $robots-&gt;current();

// Access a robot by its position in the resultset
$robot = $robots[5];

// Check if there is a record in certain position
if (isset($robots[3])) {
   $robot = $robots[3];
}

// Get the first record in the resultset
$robot = $robots-&gt;getFirst();

// Get the last record
$robot = $robots-&gt;getLast();
</pre> <p>Phalcon’s resultsets emulate scrollable cursors, you can get any row just by accessing its position, or seeking the internal pointer to a specific position. Note that some database systems don’t support scrollable cursors, this forces to re-execute the query in order to rewind the cursor to the beginning and obtain the record at the requested position. Similarly, if a resultset is traversed several times, the query must be executed the same number of times.</p> <p>Storing large query results in memory could consume many resources, because of this, resultsets are obtained from the database in chunks of 32 rows reducing the need for re-execute the request in several cases also saving memory.</p> <p>Note that resultsets can be serialized and stored in a cache backend. <a class="reference internal" href="cache"><em>Phalcon\Cache</em></a> can help with that task. However, serializing data causes <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> to retrieve all the data from the database in an array, thus consuming more memory while this process takes place.</p> <pre class="highlight-php" data-language="php">// Query all records from model parts
$parts = Parts::find();

// Store the resultset into a file
file_put_contents("cache.txt", serialize($parts));

// Get parts from file
$parts = unserialize(file_get_contents("cache.txt"));

// Traverse the parts
foreach ($parts as $part) {
   echo $part-&gt;id;
}
</pre>   <h3 id="filtering-resultsets">Filtering Resultsets</h3> <p>The most efficient way to filter data is setting some search criteria, databases will use indexes set on tables to return data faster. Phalcon additionally allows you to filter the data using PHP using any resource that is not available in the database:</p> <pre class="highlight-php" data-language="php">$customers = Customers::find()-&gt;filter(function($customer) {

    //Return only customers with a valid e-mail
    if (filter_var($customer-&gt;email, FILTER_VALIDATE_EMAIL)) {
        return $customer;
    }

});
</pre>   <h3 id="binding-parameters">Binding Parameters</h3> <p>Bound parameters are also supported in <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a>. Although there is a minimal performance impact by using bound parameters, you are encouraged to use this methodology so as to eliminate the possibility of your code being subject to SQL injection attacks. Both string and integer placeholders are supported. Binding parameters can simply be achieved as follows:</p> <pre class="highlight-php" data-language="php">// Query robots binding parameters with string placeholders
$conditions = "name = :name: AND type = :type:";

//Parameters whose keys are the same as placeholders
$parameters = array(
    "name" =&gt; "Robotina",
    "type" =&gt; "maid"
);

//Perform the query
$robots = Robots::find(array(
    $conditions,
    "bind" =&gt; $parameters
));

// Query robots binding parameters with integer placeholders
$conditions = "name = ?1 AND type = ?2";
$parameters = array(1 =&gt; "Robotina", 2 =&gt; "maid");
$robots     = Robots::find(array(
    $conditions,
    "bind" =&gt; $parameters
));

// Query robots binding parameters with both string and integer placeholders
$conditions = "name = :name: AND type = ?1";

//Parameters whose keys are the same as placeholders
$parameters = array(
    "name" =&gt; "Robotina",
    1 =&gt; "maid"
);

//Perform the query
$robots = Robots::find(array(
    $conditions,
    "bind" =&gt; $parameters
));
</pre> <p>When using numeric placeholders, you will need to define them as integers i.e. 1 or 2. In this case “1” or “2” are considered strings and not numbers, so the placeholder could not be successfully replaced.</p> <p>Strings are automatically escaped using <a class="reference external" href="http://www.php.net/manual/en/pdo.prepared-statements.php">PDO</a>. This function takes into account the connection charset, so its recommended to define the correct charset in the connection parameters or in the database configuration, as a wrong charset will produce undesired effects when storing or retrieving data.</p> <p>Additionally you can set the parameter “bindTypes”, this allows defining how the parameters should be bound according to its data type:</p> <pre class="highlight-php" data-language="php">use \Phalcon\Db\Column;

//Bind parameters
$parameters = array(
    "name" =&gt; "Robotina",
    "year" =&gt; 2008
);

//Casting Types
$types = array(
    "name" =&gt; Column::BIND_PARAM_STR,
    "year" =&gt; Column::BIND_PARAM_INT
);

// Query robots binding parameters with string placeholders
$robots = Robots::find(array(
    "name = :name: AND year = :year:",
    "bind" =&gt; $parameters,
    "bindTypes" =&gt; $types
));
</pre> <blockquote class="highlights"> <div>Since the default bind-type is \Phalcon\Db\Column::BIND_PARAM_STR, there is no need to specify the “bindTypes” parameter if all of the columns are of that type.</div>
</blockquote> <p>Bound parameters are available for all query methods such as find() and findFirst() but also the calculation methods like count(), sum(), average() etc.</p>    <h2 id="initializing-preparing-fetched-records">Initializing/Preparing fetched records</h2> <p>May be the case that after obtaining a record from the database is necessary to initialise the data before being used by the rest of the application. You can implement the method ‘afterFetch’ in a model, this event will be executed just after create the instance and assign the data to it:</p> <pre class="highlight-php" data-language="php">class Robots extends Phalcon\Mvc\Model
{

    public $id;

    public $name;

    public $status;

    public function beforeSave()
    {
        //Convert the array into a string
        $this-&gt;status = join(',', $this-&gt;status);
    }

    public function afterFetch()
    {
        //Convert the string to an array
        $this-&gt;status = explode(',', $this-&gt;status);
    }
}
</pre> <p>If you use getters/setters instead of/or together with public properties, you can initialize the field once it is accessed:</p> <pre class="highlight-php" data-language="php">class Robots extends Phalcon\Mvc\Model
{
    public $id;

    public $name;

    public $status;

    public function getStatus()
    {
        return explode(',', $this-&gt;status);
    }

}
</pre>   <h2 id="relationships-between-models">Relationships between Models</h2> <p>There are four types of relationships: one-on-one, one-to-many, many-to-one and many-to-many. The relationship may be unidirectional or bidirectional, and each can be simple (a one to one model) or more complex (a combination of models). The model manager manages foreign key constraints for these relationships, the definition of these helps referential integrity as well as easy and fast access of related records to a model. Through the implementation of relations, it is easy to access data in related models from each record in a uniform way.</p>  <h3 id="unidirectional-relationships">Unidirectional relationships</h3> <p>Unidirectional relations are those that are generated in relation to one another but not vice versa.</p>   <h3 id="bidirectional-relations">Bidirectional relations</h3> <p>The bidirectional relations build relationships in both models and each model defines the inverse relationship of the other.</p>   <h3 id="defining-relationships">Defining relationships</h3> <p>In Phalcon, relationships must be defined in the initialize() method of a model. The methods belongsTo(), hasOne(), hasMany() and hasManyToMany() define the relationship between one or more fields from the current model to fields in another model. Each of these methods requires 3 parameters: local fields, referenced model, referenced fields.</p> <table class="docutils"> <colgroup> <col width="35%"> <col width="65%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Method</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>hasMany</td> <td>Defines a 1-n relationship</td> </tr> <tr class="row-odd">
<td>hasOne</td> <td>Defines a 1-1 relationship</td> </tr> <tr class="row-even">
<td>belongsTo</td> <td>Defines a n-1 relationship</td> </tr> <tr class="row-odd">
<td>hasManyToMany</td> <td>Defines a n-n relationship</td> </tr> </tbody> </table> <p>The following schema shows 3 tables whose relations will serve us as an example regarding relationships:</p> <pre class="highlight-sql" data-language="sql">CREATE TABLE `robots` (
    `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `name` varchar(70) NOT NULL,
    `type` varchar(32) NOT NULL,
    `year` int(11) NOT NULL,
    PRIMARY KEY (`id`)
);

CREATE TABLE `robots_parts` (
    `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `robots_id` int(10) NOT NULL,
    `parts_id` int(10) NOT NULL,
    `created_at` DATE NOT NULL,
    PRIMARY KEY (`id`),
    KEY `robots_id` (`robots_id`),
    KEY `parts_id` (`parts_id`)
);

CREATE TABLE `parts` (
    `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `name` varchar(70) NOT NULL,
    PRIMARY KEY (`id`)
);
</pre> <ul class="simple"> <li>The model “Robots” has many “RobotsParts”.</li> <li>The model “Parts” has many “RobotsParts”.</li> <li>The model “RobotsParts” belongs to both “Robots” and “Parts” models as a many-to-one relation.</li> <li>The model “Robots” has a relation many-to-many to “Parts” through “RobotsParts”</li> </ul> <p>Check the EER diagram to understand better the relations:</p> <div class="figure align-center"> <img alt="../_images/eer-1.png" src="https://docs.phalconphp.com/en/2.0.0/_images/eer-1.png"> </div> <p>The models with their relations could be implemented as follows:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{
    public $id;

    public $name;

    public function initialize()
    {
        $this-&gt;hasMany("id", "RobotsParts", "robots_id");
    }

}
</pre> <pre class="highlight-php" data-language="php">class Parts extends \Phalcon\Mvc\Model
{

    public $id;

    public $name;

    public function initialize()
    {
        $this-&gt;hasMany("id", "RobotsParts", "parts_id");
    }

}
</pre> <pre class="highlight-php" data-language="php">class RobotsParts extends \Phalcon\Mvc\Model
{

    public $id;

    public $robots_id;

    public $parts_id;

    public function initialize()
    {
        $this-&gt;belongsTo("robots_id", "Robots", "id");
        $this-&gt;belongsTo("parts_id", "Parts", "id");
    }

}
</pre> <p>The first parameter indicates the field of the local model used in the relationship; the second indicates the name of the referenced model and the third the field name in the referenced model. You could also use arrays to define multiple fields in the relationship.</p> <p>Many to many relationships require 3 models and define the attributes involved in the relationship:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{
    public $id;

    public $name;

    public function initialize()
    {
        $this-&gt;hasManyToMany(
            "id",
            "RobotsParts",
            "robots_id", "parts_id",
            "Parts",
            "id"
        );
    }

}
</pre>   <h3 id="taking-advantage-of-relationships">Taking advantage of relationships</h3> <p>When explicitly defining the relationships between models, it is easy to find related records for a particular record.</p> <pre class="highlight-php" data-language="php">$robot = Robots::findFirst(2);
foreach ($robot-&gt;robotsParts as $robotPart) {
    echo $robotPart-&gt;parts-&gt;name, "\n";
}
</pre> <p>Phalcon uses the magic methods __set/__get/__call to store or retrieve related data using relationships.</p> <p>By accessing an attribute with the same name as the relationship will retrieve all its related record(s).</p> <pre class="highlight-php" data-language="php">$robot = Robots::findFirst();
$robotsParts = $robot-&gt;robotsParts; // all the related records in RobotsParts
</pre> <p>Also, you can use a magic getter:</p> <pre class="highlight-php" data-language="php">$robot = Robots::findFirst();
$robotsParts = $robot-&gt;getRobotsParts(); // all the related records in RobotsParts
$robotsParts = $robot-&gt;getRobotsParts(array('limit' =&gt; 5)); // passing parameters
</pre> <p>If the called method has a “get” prefix <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> will return a findFirst()/find() result. The following example compares retrieving related results with using magic methods and without:</p> <pre class="highlight-php" data-language="php">$robot = Robots::findFirst(2);

// Robots model has a 1-n (hasMany)
// relationship to RobotsParts then
$robotsParts = $robot-&gt;robotsParts;

// Only parts that match conditions
$robotsParts = $robot-&gt;getRobotsParts("created_at = '2012-03-15'");

// Or using bound parameters
$robotsParts = $robot-&gt;getRobotsParts(array(
    "created_at = :date:",
    "bind" =&gt; array("date" =&gt; "2012-03-15")
));

$robotPart = RobotsParts::findFirst(1);

// RobotsParts model has a n-1 (belongsTo)
// relationship to RobotsParts then
$robot = $robotPart-&gt;robots;
</pre> <p>Getting related records manually:</p> <pre class="highlight-php" data-language="php">$robot = Robots::findFirst(2);

// Robots model has a 1-n (hasMany)
// relationship to RobotsParts, then
$robotsParts = RobotsParts::find("robots_id = '" . $robot-&gt;id . "'");

// Only parts that match conditions
$robotsParts = RobotsParts::find(
    "robots_id = '" . $robot-&gt;id . "' AND created_at = '2012-03-15'"
);

$robotPart = RobotsParts::findFirst(1);

// RobotsParts model has a n-1 (belongsTo)
// relationship to RobotsParts then
$robot = Robots::findFirst("id = '" . $robotPart-&gt;robots_id . "'");
</pre> <p>The prefix “get” is used to find()/findFirst() related records. Depending on the type of relation it will use ‘find’ or ‘findFirst’:</p> <table class="docutils"> <colgroup> <col width="12%"> <col width="73%"> <col width="14%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Type</th> <th class="head">Description</th> <th class="head">Implicit Method</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>Belongs-To</td> <td>Returns a model instance of the related record directly</td> <td>findFirst</td> </tr> <tr class="row-odd">
<td>Has-One</td> <td>Returns a model instance of the related record directly</td> <td>findFirst</td> </tr> <tr class="row-even">
<td>Has-Many</td> <td>Returns a collection of model instances of the referenced model</td> <td>find</td> </tr> <tr class="row-odd">
<td>Has-Many-to-Many</td> <td>Returns a collection of model instances of the referenced model, it implicitly does ‘inner joins’ with the involved models</td> <td>(complex query)</td> </tr> </tbody> </table> <p>You can also use “count” prefix to return an integer denoting the count of the related records:</p> <pre class="highlight-php" data-language="php">$robot = Robots::findFirst(2);
echo "The robot has ", $robot-&gt;countRobotsParts(), " parts\n";
</pre>   <h3 id="aliasing-relationships">Aliasing Relationships</h3> <p>To explain better how aliases work, let’s check the following example:</p> <p>Table “robots_similar” has the function to define what robots are similar to others:</p> <pre class="highlight-bash" data-language="bash">mysql&gt; desc robots_similar;
+-------------------+------------------+------+-----+---------+----------------+
| Field             | Type             | Null | Key | Default | Extra          |
+-------------------+------------------+------+-----+---------+----------------+
| id                | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| robots_id         | int(10) unsigned | NO   | MUL | NULL    |                |
| similar_robots_id | int(10) unsigned | NO   |     | NULL    |                |
+-------------------+------------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)
</pre> <p>Both “robots_id” and “similar_robots_id” have a relation to the model Robots:</p> <div class="figure align-center"> <img alt="../_images/eer-2.png" src="https://docs.phalconphp.com/en/2.0.0/_images/eer-2.png"> </div> <p>A model that maps this table and its relationships is the following:</p> <pre class="highlight-php" data-language="php">class RobotsSimilar extends Phalcon\Mvc\Model
{

    public function initialize()
    {
        $this-&gt;belongsTo('robots_id', 'Robots', 'id');
        $this-&gt;belongsTo('similar_robots_id', 'Robots', 'id');
    }

}
</pre> <p>Since both relations point to the same model (Robots), obtain the records related to the relationship could not be clear:</p> <pre class="highlight-php" data-language="php">$robotsSimilar = RobotsSimilar::findFirst();

//Returns the related record based on the column (robots_id)
//Also as is a belongsTo it's only returning one record
//but the name 'getRobots' seems to imply that return more than one
$robot = $robotsSimilar-&gt;getRobots();

//but, how to get the related record based on the column (similar_robots_id)
//if both relationships have the same name?
</pre> <p>The aliases allow us to rename both relationships to solve these problems:</p> <pre class="highlight-php" data-language="php">class RobotsSimilar extends Phalcon\Mvc\Model
{

    public function initialize()
    {
        $this-&gt;belongsTo('robots_id', 'Robots', 'id', array(
            'alias' =&gt; 'Robot'
        ));
        $this-&gt;belongsTo('similar_robots_id', 'Robots', 'id', array(
            'alias' =&gt; 'SimilarRobot'
        ));
    }

}
</pre> <p>With the aliasing we can get the related records easily:</p> <pre class="highlight-php" data-language="php">$robotsSimilar = RobotsSimilar::findFirst();

//Returns the related record based on the column (robots_id)
$robot = $robotsSimilar-&gt;getRobot();
$robot = $robotsSimilar-&gt;robot;

//Returns the related record based on the column (similar_robots_id)
$similarRobot = $robotsSimilar-&gt;getSimilarRobot();
$similarRobot = $robotsSimilar-&gt;similarRobot;
</pre>   <h3 id="magic-getters-vs-explicit-methods">Magic Getters vs. Explicit methods</h3> <p>Most IDEs and editors with auto-completion capabilities can not infer the correct types when using magic getters, instead of use the magic getters you can optionally define those methods explicitly with the corresponding docblocks helping the IDE to produce a better auto-completion:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    public $id;

    public $name;

    public function initialize()
    {
        $this-&gt;hasMany("id", "RobotsParts", "robots_id");
    }

    /**
     * Return the related "robots parts"
     *
     * @return \RobotsParts[]
     */
    public function getRobotsParts($parameters=null)
    {
        return $this-&gt;getRelated('RobotsParts', $parameters);
    }

}
</pre>    <h2 id="virtual-foreign-keys">Virtual Foreign Keys</h2> <p>By default, relationships do not act like database foreign keys, that is, if you try to insert/update a value without having a valid value in the referenced model, Phalcon will not produce a validation message. You can modify this behavior by adding a fourth parameter when defining a relationship.</p> <p>The RobotsPart model can be changed to demonstrate this feature:</p> <pre class="highlight-php" data-language="php">class RobotsParts extends \Phalcon\Mvc\Model
{

    public $id;

    public $robots_id;

    public $parts_id;

    public function initialize()
    {
        $this-&gt;belongsTo("robots_id", "Robots", "id", array(
            "foreignKey" =&gt; true
        ));

        $this-&gt;belongsTo("parts_id", "Parts", "id", array(
            "foreignKey" =&gt; array(
                "message" =&gt; "The part_id does not exist on the Parts model"
            )
        ));
    }

}
</pre> <p>If you alter a belongsTo() relationship to act as foreign key, it will validate that the values inserted/updated on those fields have a valid value on the referenced model. Similarly, if a hasMany()/hasOne() is altered it will validate that the records cannot be deleted if that record is used on a referenced model.</p> <pre class="highlight-php" data-language="php">class Parts extends \Phalcon\Mvc\Model
{

    public function initialize()
    {
        $this-&gt;hasMany("id", "RobotsParts", "parts_id", array(
            "foreignKey" =&gt; array(
                "message" =&gt; "The part cannot be deleted because other robots are using it"
            )
        ));
    }

}
</pre>  <h3 id="cascade-restrict-actions">Cascade/Restrict actions</h3> <p>Relationships that act as virtual foreign keys by default restrict the creation/update/deletion of records to maintain the integrity of data:</p> <pre class="highlight-php" data-language="php">namespace Store\Models;

use Phalcon\Mvc\Model,
    Phalcon\Mvc\Model\Relation;

class Robots extends Model
{

    public $id;

    public $name;

    public function initialize()
    {
        $this-&gt;hasMany('id', 'Store\\Models\Parts', 'robots_id', array(
            'foreignKey' =&gt; array(
                'action' =&gt; Relation::ACTION_CASCADE
            )
        ));
    }

}
</pre> <p>The above code set up to delete all the referenced records (parts) if the master record (robot) is deleted.</p>    <h2 id="generating-calculations">Generating Calculations</h2> <p>Calculations (or aggregations) are helpers for commonly used functions of database systems such as COUNT, SUM, MAX, MIN or AVG. <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> allows to use these functions directly from the exposed methods.</p> <p>Count examples:</p> <pre class="highlight-php" data-language="php">// How many employees are?
$rowcount = Employees::count();

// How many different areas are assigned to employees?
$rowcount = Employees::count(array("distinct" =&gt; "area"));

// How many employees are in the Testing area?
$rowcount = Employees::count("area = 'Testing'");

// Count employees grouping results by their area
$group = Employees::count(array("group" =&gt; "area"));
foreach ($group as $row) {
   echo "There are ", $row-&gt;rowcount, " in ", $row-&gt;area;
}

// Count employees grouping by their area and ordering the result by count
$group = Employees::count(array(
    "group" =&gt; "area",
    "order" =&gt; "rowcount"
));

// Avoid SQL injections using bound parameters
$group = Employees::count(array(
    "type &gt; ?0",
    "bind" =&gt; array($type)
));
</pre> <p>Sum examples:</p> <pre class="highlight-php" data-language="php">// How much are the salaries of all employees?
$total = Employees::sum(array("column" =&gt; "salary"));

// How much are the salaries of all employees in the Sales area?
$total = Employees::sum(array(
    "column"     =&gt; "salary",
    "conditions" =&gt; "area = 'Sales'"
));

// Generate a grouping of the salaries of each area
$group = Employees::sum(array(
    "column" =&gt; "salary",
    "group"  =&gt; "area"
));
foreach ($group as $row) {
   echo "The sum of salaries of the ", $row-&gt;area, " is ", $row-&gt;sumatory;
}

// Generate a grouping of the salaries of each area ordering
// salaries from higher to lower
$group = Employees::sum(array(
    "column" =&gt; "salary",
    "group"  =&gt; "area",
    "order"  =&gt; "sumatory DESC"
));

// Avoid SQL injections using bound parameters
$group = Employees::sum(array(
    "conditions" =&gt; "area &gt; ?0",
    "bind" =&gt; array($area)
));
</pre> <p>Average examples:</p> <pre class="highlight-php" data-language="php">// What is the average salary for all employees?
$average = Employees::average(array("column" =&gt; "salary"));

// What is the average salary for the Sales's area employees?
$average = Employees::average(array(
    "column" =&gt; "salary",
    "conditions" =&gt; "area = 'Sales'"
));

// Avoid SQL injections using bound parameters
$average = Employees::average(array(
    "column" =&gt; "age",
    "conditions" =&gt; "area &gt; ?0",
    "bind" =&gt; array($area)
));
</pre> <p>Max/Min examples:</p> <pre class="highlight-php" data-language="php">// What is the oldest age of all employees?
$age = Employees::maximum(array("column" =&gt; "age"));

// What is the oldest of employees from the Sales area?
$age = Employees::maximum(array(
    "column" =&gt; "age",
    "conditions" =&gt; "area = 'Sales'"
));

// What is the lowest salary of all employees?
$salary = Employees::minimum(array("column" =&gt; "salary"));
</pre>   <h2 id="hydration-modes">Hydration Modes</h2> <p>As mentioned above, resultsets are collections of complete objects, this means that every returned result is an object representing a row in the database. These objects can be modified and saved again to persistence:</p> <pre class="highlight-php" data-language="php">// Manipulating a resultset of complete objects
foreach (Robots::find() as $robot) {
    $robot-&gt;year = 2000;
    $robot-&gt;save();
}
</pre> <p>Sometimes records are obtained only to be presented to a user in read-only mode, in these cases it may be useful to change the way in which records are represented to facilitate their handling. The strategy used to represent objects returned in a resultset is called ‘hydration mode’:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model\Resultset;

$robots = Robots::find();

//Return every robot as an array
$robots-&gt;setHydrateMode(Resultset::HYDRATE_ARRAYS);

foreach ($robots as $robot) {
    echo $robot['year'], PHP_EOL;
}

//Return every robot as an stdClass
$robots-&gt;setHydrateMode(Resultset::HYDRATE_OBJECTS);

foreach ($robots as $robot) {
    echo $robot-&gt;year, PHP_EOL;
}

//Return every robot as a Robots instance
$robots-&gt;setHydrateMode(Resultset::HYDRATE_RECORDS);

foreach ($robots as $robot) {
    echo $robot-&gt;year, PHP_EOL;
}
</pre> <p>Hydration mode can also be passed as a parameter of ‘find’:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model\Resultset;

$robots = Robots::find(array(
    'hydration' =&gt; Resultset::HYDRATE_ARRAYS
));

foreach ($robots as $robot) {
    echo $robot['year'], PHP_EOL;
}
</pre>   <h2 id="creating-updating-records">Creating Updating/Records</h2> <p>The method Phalcon\Mvc\Model::save() allows you to create/update records according to whether they already exist in the table associated with a model. The save method is called internally by the create and update methods of <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a>. For this to work as expected it is necessary to have properly defined a primary key in the entity to determine whether a record should be updated or created.</p> <p>Also the method executes associated validators, virtual foreign keys and events that are defined in the model:</p> <pre class="highlight-php" data-language="php">$robot       = new Robots();
$robot-&gt;type = "mechanical";
$robot-&gt;name = "Astro Boy";
$robot-&gt;year = 1952;
if ($robot-&gt;save() == false) {
    echo "Umh, We can't store robots right now: \n";
    foreach ($robot-&gt;getMessages() as $message) {
        echo $message, "\n";
    }
} else {
    echo "Great, a new robot was saved successfully!";
}
</pre> <p>An array could be passed to “save” to avoid assign every column manually. Phalcon\Mvc\Model will check if there are setters implemented for the columns passed in the array giving priority to them instead of assign directly the values of the attributes:</p> <pre class="highlight-php" data-language="php">$robot = new Robots();
$robot-&gt;save(array(
    "type" =&gt; "mechanical",
    "name" =&gt; "Astro Boy",
    "year" =&gt; 1952
));
</pre> <p>Values assigned directly or via the array of attributes are escaped/sanitized according to the related attribute data type. So you can pass an insecure array without worrying about possible SQL injections:</p> <pre class="highlight-php" data-language="php">$robot = new Robots();
$robot-&gt;save($_POST);
</pre> <blockquote class="highlights"> <div>Without precautions mass assignment could allow attackers to set any database column’s value. Only use this feature if you want to permit a user to insert/update every column in the model, even if those fields are not in the submitted form.</div>
</blockquote> <p>You can set an additional parameter in ‘save’ to set a whitelist of fields that only must taken into account when doing the mass assignment:</p> <pre class="highlight-php" data-language="php">$robot = new Robots();
$robot-&gt;save($_POST, array('name', 'type'));
</pre>  <h3 id="create-update-with-confidence">Create/Update with Confidence</h3> <p>When an application has a lot of competition, we could be expecting create a record but it is actually updated. This could happen if we use Phalcon\Mvc\Model::save() to persist the records in the database. If we want to be absolutely sure that a record is created or updated, we can change the save() call with create() or update():</p> <pre class="highlight-php" data-language="php">$robot       = new Robots();
$robot-&gt;type = "mechanical";
$robot-&gt;name = "Astro Boy";
$robot-&gt;year = 1952;

//This record only must be created
if ($robot-&gt;create() == false) {
    echo "Umh, We can't store robots right now: \n";
    foreach ($robot-&gt;getMessages() as $message) {
        echo $message, "\n";
    }
} else {
    echo "Great, a new robot was created successfully!";
}
</pre> <p>These methods “create” and “update” also accept an array of values as parameter.</p>   <h3 id="auto-generated-identity-columns">Auto-generated identity columns</h3> <p>Some models may have identity columns. These columns usually are the primary key of the mapped table. <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> can recognize the identity column omitting it in the generated SQL INSERT, so the database system can generate an auto-generated value for it. Always after creating a record, the identity field will be registered with the value generated in the database system for it:</p> <pre class="highlight-php" data-language="php">$robot-&gt;save();

echo "The generated id is: ", $robot-&gt;id;
</pre> <p><a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> is able to recognize the identity column. Depending on the database system, those columns may be serial columns like in PostgreSQL or auto_increment columns in the case of MySQL.</p> <p>PostgreSQL uses sequences to generate auto-numeric values, by default, Phalcon tries to obtain the generated value from the sequence “table_field_seq”, for example: robots_id_seq, if that sequence has a different name, the method “getSequenceName” needs to be implemented:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    public function getSequenceName()
    {
        return "robots_sequence_name";
    }

}
</pre>   <h3 id="storing-related-records">Storing related records</h3> <p>Magic properties can be used to store a records and its related properties:</p> <pre class="highlight-php" data-language="php">// Create an artist
$artist = new Artists();
$artist-&gt;name = 'Shinichi Osawa';
$artist-&gt;country = 'Japan';

// Create an album
$album = new Albums();
$album-&gt;name = 'The One';
$album-&gt;artist = $artist; //Assign the artist
$album-&gt;year = 2008;

//Save both records
$album-&gt;save();
</pre> <p>Saving a record and its related records in a has-many relation:</p> <pre class="highlight-php" data-language="php">// Get an existing artist
$artist = Artists::findFirst('name = "Shinichi Osawa"');

// Create an album
$album = new Albums();
$album-&gt;name = 'The One';
$album-&gt;artist = $artist;

$songs = array();

// Create a first song
$songs[0] = new Songs();
$songs[0]-&gt;name = 'Star Guitar';
$songs[0]-&gt;duration = '5:54';

// Create a second song
$songs[1] = new Songs();
$songs[1]-&gt;name = 'Last Days';
$songs[1]-&gt;duration = '4:29';

// Assign the songs array
$album-&gt;songs = $songs;

// Save the album + its songs
$album-&gt;save();
</pre> <p>Saving the album and the artist at the same time implicitly makes use of a transaction so if anything goes wrong with saving the related records, the parent will not be saved either. Messages are passed back to the user for information regarding any errors.</p> <p>Note: Adding related entities by overloading the following methods is not possible:</p> <ul class="simple"> <li>Phalcon\Mvc\Model::beforeSave()</li> <li>Phalcon\Mvc\Model::beforeCreate()</li> <li>Phalcon\Mvc\Model::beforeUpdate()</li> </ul> <p>You need to overload Phalcon\Mvc\Model::save() for this to work from within a model.</p>   <h3 id="validation-messages">Validation Messages</h3> <p><a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> has a messaging subsystem that provides a flexible way to output or store the validation messages generated during the insert/update processes.</p> <p>Each message consists of an instance of the class <a class="reference internal" href="../api/phalcon_mvc_model_message"><em>Phalcon\Mvc\Model\Message</em></a>. The set of messages generated can be retrieved with the method getMessages(). Each message provides extended information like the field name that generated the message or the message type:</p> <pre class="highlight-php" data-language="php">if ($robot-&gt;save() == false) {
    foreach ($robot-&gt;getMessages() as $message) {
        echo "Message: ", $message-&gt;getMessage();
        echo "Field: ", $message-&gt;getField();
        echo "Type: ", $message-&gt;getType();
    }
}
</pre> <p><a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> can generate the following types of validation messages:</p> <table class="docutils"> <colgroup> <col width="14%"> <col width="86%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Type</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>PresenceOf</td> <td>Generated when a field with a non-null attribute on the database is trying to insert/update a null value</td> </tr> <tr class="row-odd">
<td>ConstraintViolation</td> <td>Generated when a field part of a virtual foreign key is trying to insert/update a value that doesn’t exist in the referenced model</td> </tr> <tr class="row-even">
<td>InvalidValue</td> <td>Generated when a validator failed because of an invalid value</td> </tr> <tr class="row-odd">
<td>InvalidCreateAttempt</td> <td>Produced when a record is attempted to be created but it already exists</td> </tr> <tr class="row-even">
<td>InvalidUpdateAttempt</td> <td>Produced when a record is attempted to be updated but it doesn’t exist</td> </tr> </tbody> </table> <p>The method getMessages() can be overridden in a model to replace/translate the default messages generated automatically by the ORM:</p> <pre class="highlight-php" data-language="php">class Robots extends Phalcon\Mvc\Model
{
    public function getMessages()
    {
        $messages = array();
        foreach (parent::getMessages() as $message) {
            switch ($message-&gt;getType()) {
                case 'InvalidCreateAttempt':
                    $messages[] = 'The record cannot be created because it already exists';
                    break;
                case 'InvalidUpdateAttempt':
                    $messages[] = 'The record cannot be updated because it already exists';
                    break;
                case 'PresenceOf':
                    $messages[] = 'The field ' . $message-&gt;getField() . ' is mandatory';
                    break;
            }
        }
        return $messages;
    }
}
</pre>   <h3 id="events-and-events-manager">Events and Events Manager</h3> <p>Models allow you to implement events that will be thrown when performing an insert/update/delete. They help define business rules for a certain model. The following are the events supported by <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> and their order of execution:</p> <table class="docutils"> <colgroup> <col width="10%"> <col width="13%"> <col width="12%"> <col width="66%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Operation</th> <th class="head">Name</th> <th class="head">Can stop operation?</th> <th class="head">Explanation</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>Inserting/Updating</td> <td>beforeValidation</td> <td>YES</td> <td>Is executed before the fields are validated for not nulls/empty strings or foreign keys</td> </tr> <tr class="row-odd">
<td>Inserting</td> <td>beforeValidationOnCreate</td> <td>YES</td> <td>Is executed before the fields are validated for not nulls/empty strings or foreign keys when an insertion operation is being made</td> </tr> <tr class="row-even">
<td>Updating</td> <td>beforeValidationOnUpdate</td> <td>YES</td> <td>Is executed before the fields are validated for not nulls/empty strings or foreign keys when an updating operation is being made</td> </tr> <tr class="row-odd">
<td>Inserting/Updating</td> <td>onValidationFails</td> <td>YES (already stopped)</td> <td>Is executed after an integrity validator fails</td> </tr> <tr class="row-even">
<td>Inserting</td> <td>afterValidationOnCreate</td> <td>YES</td> <td>Is executed after the fields are validated for not nulls/empty strings or foreign keys when an insertion operation is being made</td> </tr> <tr class="row-odd">
<td>Updating</td> <td>afterValidationOnUpdate</td> <td>YES</td> <td>Is executed after the fields are validated for not nulls/empty strings or foreign keys when an updating operation is being made</td> </tr> <tr class="row-even">
<td>Inserting/Updating</td> <td>afterValidation</td> <td>YES</td> <td>Is executed after the fields are validated for not nulls/empty strings or foreign keys</td> </tr> <tr class="row-odd">
<td>Inserting/Updating</td> <td>beforeSave</td> <td>YES</td> <td>Runs before the required operation over the database system</td> </tr> <tr class="row-even">
<td>Updating</td> <td>beforeUpdate</td> <td>YES</td> <td>Runs before the required operation over the database system only when an updating operation is being made</td> </tr> <tr class="row-odd">
<td>Inserting</td> <td>beforeCreate</td> <td>YES</td> <td>Runs before the required operation over the database system only when an inserting operation is being made</td> </tr> <tr class="row-even">
<td>Updating</td> <td>afterUpdate</td> <td>NO</td> <td>Runs after the required operation over the database system only when an updating operation is being made</td> </tr> <tr class="row-odd">
<td>Inserting</td> <td>afterCreate</td> <td>NO</td> <td>Runs after the required operation over the database system only when an inserting operation is being made</td> </tr> <tr class="row-even">
<td>Inserting/Updating</td> <td>afterSave</td> <td>NO</td> <td>Runs after the required operation over the database system</td> </tr> </tbody> </table>   <h3 id="implementing-events-in-the-model-s-class">Implementing Events in the Model’s class</h3> <p>The easier way to make a model react to events is implement a method with the same name of the event in the model’s class:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    public function beforeValidationOnCreate()
    {
        echo "This is executed before creating a Robot!";
    }

}
</pre> <p>Events can be useful to assign values before performing an operation, for example:</p> <pre class="highlight-php" data-language="php">class Products extends \Phalcon\Mvc\Model
{

    public function beforeCreate()
    {
        //Set the creation date
        $this-&gt;created_at = date('Y-m-d H:i:s');
    }

    public function beforeUpdate()
    {
        //Set the modification date
        $this-&gt;modified_in = date('Y-m-d H:i:s');
    }

}
</pre>   <h3 id="using-a-custom-events-manager">Using a custom Events Manager</h3> <p>Additionally, this component is integrated with <a class="reference internal" href="../api/phalcon_events_manager"><em>Phalcon\Events\Manager</em></a>, this means we can create listeners that run when an event is triggered.</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model,
    Phalcon\Events\Manager as EventsManager;

class Robots extends Model
{

    public function initialize()
    {

        $eventsManager = new EventsManager();

        //Attach an anonymous function as a listener for "model" events
        $eventsManager-&gt;attach('model', function($event, $robot) {
            if ($event-&gt;getType() == 'beforeSave') {
                if ($robot-&gt;name == 'Scooby Doo') {
                    echo "Scooby Doo isn't a robot!";
                    return false;
                }
            }
            return true;
        });

        //Attach the events manager to the event
        $this-&gt;setEventsManager($eventsManager);
    }

}
</pre> <p>In the example given above, EventsManager only acts as a bridge between an object and a listener (the anonymous function). Events will be fired to the listener when ‘robots’ are saved:</p> <pre class="highlight-php" data-language="php">$robot = new Robots();
$robot-&gt;name = 'Scooby Doo';
$robot-&gt;year = 1969;
$robot-&gt;save();
</pre> <p>If we want all objects created in our application use the same EventsManager, then we need to assign it to the Models Manager:</p> <pre class="highlight-php" data-language="php">//Registering the modelsManager service
$di-&gt;setShared('modelsManager', function() {

    $eventsManager = new \Phalcon\Events\Manager();

    //Attach an anonymous function as a listener for "model" events
    $eventsManager-&gt;attach('model', function($event, $model){

        //Catch events produced by the Robots model
        if (get_class($model) == 'Robots') {

            if ($event-&gt;getType() == 'beforeSave') {
                if ($model-&gt;name == 'Scooby Doo') {
                    echo "Scooby Doo isn't a robot!";
                    return false;
                }
            }

        }
        return true;
    });

    //Setting a default EventsManager
    $modelsManager = new ModelsManager();
    $modelsManager-&gt;setEventsManager($eventsManager);
    return $modelsManager;
});
</pre> <p>If a listener returns false that will stop the operation that is executing currently.</p>   <h3 id="implementing-a-business-rule">Implementing a Business Rule</h3> <p>When an insert, update or delete is executed, the model verifies if there are any methods with the names of the events listed in the table above.</p> <p>We recommend that validation methods are declared protected to prevent that business logic implementation from being exposed publicly.</p> <p>The following example implements an event that validates the year cannot be smaller than 0 on update or insert:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    public function beforeSave()
    {
        if ($this-&gt;year &lt; 0) {
            echo "Year cannot be smaller than zero!";
            return false;
        }
    }

}
</pre> <p>Some events return false as an indication to stop the current operation. If an event doesn’t return anything, <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> will assume a true value.</p>   <h3 id="validating-data-integrity">Validating Data Integrity</h3> <p><a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> provides several events to validate data and implement business rules. The special “validation” event allows us to call built-in validators over the record. Phalcon exposes a few built-in validators that can be used at this stage of validation.</p> <p>The following example shows how to use it:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model\Validator\InclusionIn,
    Phalcon\Mvc\Model\Validator\Uniqueness;

class Robots extends \Phalcon\Mvc\Model
{

    public function validation()
    {

        $this-&gt;validate(new InclusionIn(
            array(
                "field"  =&gt; "type",
                "domain" =&gt; array("Mechanical", "Virtual")
            )
        ));

        $this-&gt;validate(new Uniqueness(
            array(
                "field"   =&gt; "name",
                "message" =&gt; "The robot name must be unique"
            )
        ));

        return $this-&gt;validationHasFailed() != true;
    }

}
</pre> <p>The above example performs a validation using the built-in validator “InclusionIn”. It checks the value of the field “type” in a domain list. If the value is not included in the method then the validator will fail and return false. The following built-in validators are available:</p> <table class="docutils"> <colgroup> <col width="6%"> <col width="67%"> <col width="28%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Name</th> <th class="head">Explanation</th> <th class="head">Example</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>PresenceOf</td> <td>Validates that a field’s value isn’t null or empty string. This validator is automatically added based on the attributes marked as not null on the mapped table</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_validator_presenceof"><em>Example</em></a></td> </tr> <tr class="row-odd">
<td>Email</td> <td>Validates that field contains a valid email format</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_validator_email"><em>Example</em></a></td> </tr> <tr class="row-even">
<td>ExclusionIn</td> <td>Validates that a value is not within a list of possible values</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_validator_exclusionin"><em>Example</em></a></td> </tr> <tr class="row-odd">
<td>InclusionIn</td> <td>Validates that a value is within a list of possible values</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_validator_inclusionin"><em>Example</em></a></td> </tr> <tr class="row-even">
<td>Numericality</td> <td>Validates that a field has a numeric format</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_validator_numericality"><em>Example</em></a></td> </tr> <tr class="row-odd">
<td>Regex</td> <td>Validates that the value of a field matches a regular expression</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_validator_regex"><em>Example</em></a></td> </tr> <tr class="row-even">
<td>Uniqueness</td> <td>Validates that a field or a combination of a set of fields are not present more than once in the existing records of the related table</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_validator_uniqueness"><em>Example</em></a></td> </tr> <tr class="row-odd">
<td>StringLength</td> <td>Validates the length of a string</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_validator_stringlength"><em>Example</em></a></td> </tr> <tr class="row-even">
<td>Url</td> <td>Validates that a value has a valid URL format</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_validator_url"><em>Example</em></a></td> </tr> </tbody> </table> <p>In addition to the built-in validators, you can create your own validators:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model\Validator,
    Phalcon\Mvc\Model\ValidatorInterface;

class MaxMinValidator extends Validator implements ValidatorInterface
{

    public function validate($model)
    {
        $field = $this-&gt;getOption('field');

        $min = $this-&gt;getOption('min');
        $max = $this-&gt;getOption('max');

        $value = $model-&gt;$field;

        if ($min &lt;= $value &amp;&amp; $value &lt;= $max) {
            $this-&gt;appendMessage(
                "The field doesn't have the right range of values",
                $field,
                "MaxMinValidator"
            );
            return false;
        }
        return true;
    }

}
</pre> <p>Adding the validator to a model:</p> <pre class="highlight-php" data-language="php">class Customers extends \Phalcon\Mvc\Model
{

    public function validation()
    {
        $this-&gt;validate(new MaxMinValidator(
            array(
                "field"  =&gt; "price",
                "min" =&gt; 10,
                "max" =&gt; 100
            )
        ));
        if ($this-&gt;validationHasFailed() == true) {
            return false;
        }
    }

}
</pre> <p>The idea of creating validators is make them reusable between several models. A validator can also be as simple as:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model,
    Phalcon\Mvc\Model\Message;

class Robots extends Model
{

    public function validation()
    {
        if ($this-&gt;type == "Old") {
            $message = new Message(
                "Sorry, old robots are not allowed anymore",
                "type",
                "MyType"
            );
            $this-&gt;appendMessage($message);
            return false;
        }
        return true;
    }

}
</pre>   <h3 id="avoiding-sql-injections">Avoiding SQL injections</h3> <p>Every value assigned to a model attribute is escaped depending of its data type. A developer doesn’t need to escape manually each value before storing it on the database. Phalcon uses internally the <a class="reference external" href="http://php.net/manual/en/pdostatement.bindparam.php">bound parameters</a> capability provided by PDO to automatically escape every value to be stored in the database.</p> <pre class="highlight-bash" data-language="bash">mysql&gt; desc products;
+------------------+------------------+------+-----+---------+----------------+
| Field            | Type             | Null | Key | Default | Extra          |
+------------------+------------------+------+-----+---------+----------------+
| id               | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| product_types_id | int(10) unsigned | NO   | MUL | NULL    |                |
| name             | varchar(70)      | NO   |     | NULL    |                |
| price            | decimal(16,2)    | NO   |     | NULL    |                |
| active           | char(1)          | YES  |     | NULL    |                |
+------------------+------------------+------+-----+---------+----------------+
5 rows in set (0.00 sec)
</pre> <p>If we use just PDO to store a record in a secure way, we need to write the following code:</p> <pre class="highlight-php" data-language="php">$productTypesId = 1;
$name = 'Artichoke';
$price = 10.5;
$active = 'Y';

$sql = 'INSERT INTO products VALUES (null, :productTypesId, :name, :price, :active)';
$sth = $dbh-&gt;prepare($sql);

$sth-&gt;bindParam(':productTypesId', $productTypesId, PDO::PARAM_INT);
$sth-&gt;bindParam(':name', $name, PDO::PARAM_STR, 70);
$sth-&gt;bindParam(':price', doubleval($price));
$sth-&gt;bindParam(':active', $active, PDO::PARAM_STR, 1);

$sth-&gt;execute();
</pre> <p>The good news is that Phalcon do this for you automatically:</p> <pre class="highlight-php" data-language="php">$product = new Products();
$product-&gt;product_types_id = 1;
$product-&gt;name = 'Artichoke';
$product-&gt;price = 10.5;
$product-&gt;active = 'Y';
$product-&gt;create();
</pre>    <h2 id="skipping-columns">Skipping Columns</h2> <p>To tell Phalcon\Mvc\Model that always omits some fields in the creation and/or update of records in order to delegate the database system the assignation of the values by a trigger or a default:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    public function initialize()
    {
        //Skips fields/columns on both INSERT/UPDATE operations
        $this-&gt;skipAttributes(array('year', 'price'));

        //Skips only when inserting
        $this-&gt;skipAttributesOnCreate(array('created_at'));

        //Skips only when updating
        $this-&gt;skipAttributesOnUpdate(array('modified_in'));
    }

}
</pre> <p>This will ignore globally these fields on each INSERT/UPDATE operation on the whole application. If you want to ignore different attributes on different INSERT/UPDATE operations, you can specify the second parameter (boolean) - true for replacement. Forcing a default value can be done in the following way:</p> <pre class="highlight-php" data-language="php">$robot = new Robots();
$robot-&gt;name = 'Bender';
$robot-&gt;year = 1999;
$robot-&gt;created_at = new \Phalcon\Db\RawValue('default');
$robot-&gt;create();
</pre> <p>A callback also can be used to create a conditional assignment of automatic default values:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model,
    Phalcon\Db\RawValue;

class Robots extends Model
{
    public function beforeCreate()
    {
        if ($this-&gt;price &gt; 10000) {
            $this-&gt;type = new RawValue('default');
        }
    }
}
</pre> <blockquote class="highlights"> <div>Never use a \Phalcon\Db\RawValue to assign external data (such as user input) or variable data. The value of these fields is ignored when binding parameters to the query. So it could be used to attack the application injecting SQL.</div>
</blockquote>  <h3 id="dynamic-update">Dynamic Update</h3> <p>SQL UPDATE statements are by default created with every column defined in the model (full all-field SQL update). You can change specific models to make dynamic updates, in this case, just the fields that had changed are used to create the final SQL statement.</p> <p>In some cases this could improve the performance by reducing the traffic between the application and the database server, this specially helps when the table has blob/text fields:</p> <pre class="highlight-php" data-language="php">class Robots extends Phalcon\Mvc\Model
{
    public function initialize()
    {
        $this-&gt;useDynamicUpdate(true);
    }
}
</pre>    <h2 id="deleting-records">Deleting Records</h2> <p>The method Phalcon\Mvc\Model::delete() allows to delete a record. You can use it as follows:</p> <pre class="highlight-php" data-language="php">$robot = Robots::findFirst(11);
if ($robot != false) {
    if ($robot-&gt;delete() == false) {
        echo "Sorry, we can't delete the robot right now: \n";
        foreach ($robot-&gt;getMessages() as $message) {
            echo $message, "\n";
        }
    } else {
        echo "The robot was deleted successfully!";
    }
}
</pre> <p>You can also delete many records by traversing a resultset with a foreach:</p> <pre class="highlight-php" data-language="php">foreach (Robots::find("type='mechanical'") as $robot) {
    if ($robot-&gt;delete() == false) {
        echo "Sorry, we can't delete the robot right now: \n";
        foreach ($robot-&gt;getMessages() as $message) {
            echo $message, "\n";
        }
    } else {
        echo "The robot was deleted successfully!";
    }
}
</pre> <p>The following events are available to define custom business rules that can be executed when a delete operation is performed:</p> <table class="docutils"> <colgroup> <col width="13%"> <col width="16%"> <col width="24%"> <col width="48%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Operation</th> <th class="head">Name</th> <th class="head">Can stop operation?</th> <th class="head">Explanation</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>Deleting</td> <td>beforeDelete</td> <td>YES</td> <td>Runs before the delete operation is made</td> </tr> <tr class="row-odd">
<td>Deleting</td> <td>afterDelete</td> <td>NO</td> <td>Runs after the delete operation was made</td> </tr> </tbody> </table> <p>With the above events can also define business rules in the models:</p> <pre class="highlight-php" data-language="php">class Robots extends Phalcon\Mvc\Model
{

    public function beforeDelete()
    {
        if ($this-&gt;status == 'A') {
            echo "The robot is active, it can't be deleted";
            return false;
        }
        return true;
    }

}
</pre>   <h2 id="validation-failed-events">Validation Failed Events</h2> <p>Another type of events are available when the data validation process finds any inconsistency:</p> <table class="docutils"> <colgroup> <col width="23%"> <col width="18%"> <col width="60%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Operation</th> <th class="head">Name</th> <th class="head">Explanation</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>Insert or Update</td> <td>notSave</td> <td>Triggered when the INSERT or UPDATE operation fails for any reason</td> </tr> <tr class="row-odd">
<td>Insert, Delete or Update</td> <td>onValidationFails</td> <td>Triggered when any data manipulation operation fails</td> </tr> </tbody> </table>   <h2 id="behaviors">Behaviors</h2> <p>Behaviors are shared conducts that several models may adopt in order to re-use code, the ORM provides an API to implement behaviors in your models. Also, you can use the events and callbacks as seen before as an alternative to implement Behaviors with more freedom.</p> <p>A behavior must be added in the model initializer, a model can have zero or more behaviors:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model\Behavior\Timestampable;

class Users extends \Phalcon\Mvc\Model
{
    public $id;

    public $name;

    public $created_at;

    public function initialize()
    {
        $this-&gt;addBehavior(new Timestampable(
            array(
                'beforeCreate' =&gt; array(
                    'field' =&gt; 'created_at',
                    'format' =&gt; 'Y-m-d'
                )
            )
        ));
    }

}
</pre> <p>The following built-in behaviors are provided by the framework:</p> <table class="docutils"> <colgroup> <col width="11%"> <col width="89%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Name</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>Timestampable</td> <td>Allows to automatically update a model’s attribute saving the datetime when a record is created or updated</td> </tr> <tr class="row-odd">
<td>SoftDelete</td> <td>Instead of permanently delete a record it marks the record as deleted changing the value of a flag column</td> </tr> </tbody> </table>  <h3 id="timestampable">Timestampable</h3> <p>This behavior receives an array of options, the first level key must be an event name indicating when the column must be assigned:</p> <pre class="highlight-php" data-language="php">public function initialize()
{
    $this-&gt;addBehavior(new Timestampable(
        array(
            'beforeCreate' =&gt; array(
                'field' =&gt; 'created_at',
                'format' =&gt; 'Y-m-d'
            )
        )
    ));
}
</pre> <p>Each event can have its own options, ‘field’ is the name of the column that must be updated, if ‘format’ is a string it will be used as format of the PHP’s function <a class="reference external" href="http://php.net/manual/en/function.date.php">date</a>, format can also be an anonymous function providing you the free to generate any kind timestamp:</p> <pre class="highlight-php" data-language="php">public function initialize()
{
    $this-&gt;addBehavior(new Timestampable(
        array(
            'beforeCreate' =&gt; array(
                'field' =&gt; 'created_at',
                'format' =&gt; function() {
                    $datetime = new Datetime(new DateTimeZone('Europe/Stockholm'));
                    return $datetime-&gt;format('Y-m-d H:i:sP');
                }
            )
        )
    ));
}
</pre> <p>If the option ‘format’ is omitted a timestamp using the PHP’s function <a class="reference external" href="http://php.net/manual/en/function.time.php">time</a>, will be used.</p>   <h3 id="softdelete">SoftDelete</h3> <p>This behavior can be used in the following way:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model\Behavior\SoftDelete;

class Users extends \Phalcon\Mvc\Model
{

    const DELETED = 'D';

    const NOT_DELETED = 'N';

    public $id;

    public $name;

    public $status;

    public function initialize()
    {
        $this-&gt;addBehavior(new SoftDelete(
            array(
                'field' =&gt; 'status',
                'value' =&gt; Users::DELETED
            )
        ));
    }

}
</pre> <p>This behavior accepts two options: ‘field’ and ‘value’, ‘field’ determines what field must be updated and ‘value’ the value to be deleted. Let’s pretend the table ‘users’ has the following data:</p> <pre class="highlight-bash" data-language="bash">mysql&gt; select * from users;
+----+---------+--------+
| id | name    | status |
+----+---------+--------+
|  1 | Lana    | N      |
|  2 | Brandon | N      |
+----+---------+--------+
2 rows in set (0.00 sec)
</pre> <p>If we delete any of the two records the status will be updated instead of delete the record:</p> <pre class="highlight-php" data-language="php">Users::findFirst(2)-&gt;delete();
</pre> <p>The operation will result in the following data in the table:</p> <pre class="highlight-bash" data-language="bash">mysql&gt; select * from users;
+----+---------+--------+
| id | name    | status |
+----+---------+--------+
|  1 | Lana    | N      |
|  2 | Brandon | D      |
+----+---------+--------+
2 rows in set (0.01 sec)
</pre> <p>Note that you need to specify the deleted condition in your queries to effectively ignore them as deleted records, this behavior doesn’t support that.</p>   <h3 id="creating-your-own-behaviors">Creating your own behaviors</h3> <p>The ORM provides an API to create your own behaviors. A behavior must be a class implementing the <a class="reference internal" href="../api/phalcon_mvc_model_behaviorinterface"><em>Phalcon\Mvc\Model\BehaviorInterface</em></a> Also, Phalon\Mvc\Model\Behavior provides most of the methods needed to ease the implementation of behaviors.</p> <p>The following behavior is an example, it implements the Blamable behavior which helps identify the user that is performed operations over a model:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model\Behavior;
use Phalcon\Mvc\Model\BehaviorInterface;

class Blameable extends Behavior implements BehaviorInterface
{

    public function notify($eventType, $model)
    {
        switch ($eventType) {

            case 'afterCreate':
            case 'afterDelete':
            case 'afterUpdate':


                $userName = // ... get the current user from session

                //Store in a log the username - event type and primary key
                file_put_contents(
                    'logs/blamable-log.txt',
                    $userName . ' ' . $eventType . ' ' . $model-&gt;id
                );

                break;

            default:
                /* ignore the rest of events */
        }
    }

}
</pre> <p>The former is a very simple behavior, but it illustrates how to create a behavior, now let’s add this behavior to a model:</p> <pre class="highlight-php" data-language="php">class Profiles extends \Phalcon\Mvc\Model
{

    public function initialize()
    {
        $this-&gt;addBehavior(new Blamable());
    }

}
</pre> <p>A behavior is also capable of intercept missing methods on your models:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model\Behavior,
    Phalcon\Mvc\Model\BehaviorInterface;

class Sluggable extends Behavior implements BehaviorInterface
{

    public function missingMethod($model, $method, $arguments=array())
    {
        // if the method is 'getSlug' convert the title
        if ($method == 'getSlug') {
            return Phalcon\Tag::friendlyTitle($model-&gt;title);
        }
    }

}
</pre> <p>Call that method on a model that implements Sluggable returns a SEO friendly title:</p> <pre class="highlight-php" data-language="php">$title = $post-&gt;getSlug();
</pre>   <h3 id="using-traits-as-behaviors">Using Traits as behaviors</h3> <p>Starting from PHP 5.4 you can use <a class="reference external" href="http://php.net/manual/en/language.oop5.traits.php">Traits</a> to re-use code in your classes, this is another way to implement custom behaviors. The following trait implements a simple version of the Timestampable behavior:</p> <pre class="highlight-php" data-language="php">trait MyTimestampable
{

    public function beforeCreate()
    {
        $this-&gt;created_at = date('r');
    }

    public function beforeUpdate()
    {
        $this-&gt;updated_at = date('r');
    }

}
</pre> <p>Then you can use it in your model as follows:</p> <pre class="highlight-php" data-language="php">class Products extends \Phalcon\Mvc\Model
{
    use MyTimestampable;
}
</pre>    <h2 id="transactions">Transactions</h2> <p>When a process performs multiple database operations, it is often that each step is completed successfully so that data integrity can be maintained. Transactions offer the ability to ensure that all database operations have been executed successfully before the data are committed to the database.</p> <p>Transactions in Phalcon allow you to commit all operations if they have been executed successfully or rollback all operations if something went wrong.</p>  <h3 id="manual-transactions">Manual Transactions</h3> <p>If an application only uses one connection and the transactions aren’t very complex, a transaction can be created by just moving the current connection to transaction mode, doing a rollback or commit if the operation is successfully or not:</p> <pre class="highlight-php" data-language="php">class RobotsController extends Phalcon\Mvc\Controller
{
    public function saveAction()
    {
        $this-&gt;db-&gt;begin();

        $robot = new Robots();

        $robot-&gt;name = "WALL·E";
        $robot-&gt;created_at = date("Y-m-d");
        if ($robot-&gt;save() == false) {
            $this-&gt;db-&gt;rollback();
            return;
        }

        $robotPart = new RobotParts();
        $robotPart-&gt;robots_id = $robot-&gt;id;
        $robotPart-&gt;type = "head";
        if ($robotPart-&gt;save() == false) {
            $this-&gt;db-&gt;rollback();
            return;
        }

        $this-&gt;db-&gt;commit();
    }
}
</pre>   <h3 id="implicit-transactions">Implicit Transactions</h3> <p>Existing relationships can be used to store records and their related instances, this kind of operation implicitly creates a transaction to ensure that data are correctly stored:</p> <pre class="highlight-php" data-language="php">$robotPart = new RobotParts();
$robotPart-&gt;type = "head";

$robot = new Robots();
$robot-&gt;name = "WALL·E";
$robot-&gt;created_at = date("Y-m-d");
$robot-&gt;robotPart = $robotPart;

$robot-&gt;save(); //Creates an implicit transaction to store both records
</pre>   <h3 id="isolated-transactions">Isolated Transactions</h3> <p>Isolated transactions are executed in a new connection ensuring that all the generated SQL, virtual foreign key checks and business rules are isolated from the main connection. This kind of transaction requires a transaction manager that globally manages each transaction created ensuring that they are correctly rolled back/committed before ending the request:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model\Transaction\Manager as TxManager,
    Phalcon\Mvc\Model\Transaction\Failed as TxFailed;

try {

    //Create a transaction manager
    $manager = new TxManager();

    // Request a transaction
    $transaction = $manager-&gt;get();

    $robot = new Robots();
    $robot-&gt;setTransaction($transaction);
    $robot-&gt;name = "WALL·E";
    $robot-&gt;created_at = date("Y-m-d");
    if ($robot-&gt;save() == false) {
        $transaction-&gt;rollback("Cannot save robot");
    }

    $robotPart = new RobotParts();
    $robotPart-&gt;setTransaction($transaction);
    $robotPart-&gt;robots_id = $robot-&gt;id;
    $robotPart-&gt;type = "head";
    if ($robotPart-&gt;save() == false) {
        $transaction-&gt;rollback("Cannot save robot part");
    }

    //Everything goes fine, let's commit the transaction
    $transaction-&gt;commit();

} catch(TxFailed $e) {
    echo "Failed, reason: ", $e-&gt;getMessage();
}
</pre> <p>Transactions can be used to delete many records in a consistent way:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model\Transaction\Manager as TxManager,
    Phalcon\Mvc\Model\Transaction\Failed as TxFailed;

try {

    //Create a transaction manager
    $manager = new TxManager();

    //Request a transaction
    $transaction = $manager-&gt;get();

    //Get the robots will be deleted
    foreach (Robots::find("type = 'mechanical'") as $robot) {
        $robot-&gt;setTransaction($transaction);
        if ($robot-&gt;delete() == false) {
            //Something goes wrong, we should to rollback the transaction
            foreach ($robot-&gt;getMessages() as $message) {
                $transaction-&gt;rollback($message-&gt;getMessage());
            }
        }
    }

    //Everything goes fine, let's commit the transaction
    $transaction-&gt;commit();

    echo "Robots were deleted successfully!";

} catch(TxFailed $e) {
    echo "Failed, reason: ", $e-&gt;getMessage();
}
</pre> <p>Transactions are reused no matter where the transaction object is retrieved. A new transaction is generated only when a commit() or rollback() is performed. You can use the service container to create the global transaction manager for the entire application:</p> <pre class="highlight-php" data-language="php">$di-&gt;setShared('transactions', function(){
    return new \Phalcon\Mvc\Model\Transaction\Manager();
});
</pre> <p>Then access it from a controller or view:</p> <pre class="highlight-php" data-language="php">class ProductsController extends \Phalcon\Mvc\Controller
{

    public function saveAction()
    {

        //Obtain the TransactionsManager from the services container
        $manager = $this-&gt;di-&gt;getTransactions();

        //Or
        $manager = $this-&gt;transactions;

        //Request a transaction
        $transaction = $manager-&gt;get();

        //...
    }

}
</pre> <p>While a transaction is active, the transaction manager will always return the same transaction across the application.</p>    <h2 id="independent-column-mapping">Independent Column Mapping</h2> <p>The ORM supports an independent column map, which allows the developer to use different column names in the model to the ones in the table. Phalcon will recognize the new column names and will rename them accordingly to match the respective columns in the database. This is a great feature when one needs to rename fields in the database without having to worry about all the queries in the code. A change in the column map in the model will take care of the rest. For example:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    public function columnMap()
    {
        //Keys are the real names in the table and
        //the values their names in the application
        return array(
            'id' =&gt; 'code',
            'the_name' =&gt; 'theName',
            'the_type' =&gt; 'theType',
            'the_year' =&gt; 'theYear'
        );
    }

}
</pre> <p>Then you can use the new names naturally in your code:</p> <pre class="highlight-php" data-language="php">//Find a robot by its name
$robot = Robots::findFirst("theName = 'Voltron'");
echo $robot-&gt;theName, "\n";

//Get robots ordered by type
$robot = Robots::find(array('order' =&gt; 'theType DESC'));
foreach ($robots as $robot) {
    echo 'Code: ', $robot-&gt;code, "\n";
}

//Create a robot
$robot = new Robots();
$robot-&gt;code = '10101';
$robot-&gt;theName = 'Bender';
$robot-&gt;theType = 'Industrial';
$robot-&gt;theYear = 2999;
$robot-&gt;save();
</pre> <p>Take into consideration the following the next when renaming your columns:</p> <ul class="simple"> <li>References to attributes in relationships/validators must use the new names</li> <li>Refer the real column names will result in an exception by the ORM</li> </ul> <p>The independent column map allow you to:</p> <ul class="simple"> <li>Write applications using your own conventions</li> <li>Eliminate vendor prefixes/suffixes in your code</li> <li>Change column names without change your application code</li> </ul>   <h2 id="operations-over-resultsets">Operations over Resultsets</h2> <p>If a resultset is composed of complete objects, the resultset is in the ability to perform operations on the records obtained in a simple manner:</p>  <h3 id="updating-related-records">Updating related records</h3> <p>Instead of doing this:</p> <pre class="highlight-php" data-language="php">foreach ($robots-&gt;getParts() as $part) {
    $part-&gt;stock = 100;
    $part-&gt;updated_at = time();
    if ($part-&gt;update() == false) {
        foreach ($part-&gt;getMessages() as $message) {
            echo $message;
        }
        break;
    }
}
</pre> <p>you can do this:</p> <pre class="highlight-php" data-language="php">$robots-&gt;getParts()-&gt;update(array(
    'stock' =&gt; 100,
    'updated_at' =&gt; time()
));
</pre> <p>‘update’ also accepts an anonymous function to filter what records must be updated:</p> <pre class="highlight-php" data-language="php">$data = array(
    'stock' =&gt; 100,
    'updated_at' =&gt; time()
);

//Update all the parts except these whose type is basic
$robots-&gt;getParts()-&gt;update($data, function($part) {
    if ($part-&gt;type == Part::TYPE_BASIC) {
        return false;
    }
    return true;
});
</pre>   <h3 id="deleting-related-records">Deleting related records</h3> <p>Instead of doing this:</p> <pre class="highlight-php" data-language="php">foreach ($robots-&gt;getParts() as $part) {
    if ($part-&gt;delete() == false) {
        foreach ($part-&gt;getMessages() as $message) {
            echo $message;
        }
        break;
    }
}
</pre> <p>you can do this:</p> <pre class="highlight-php" data-language="php">$robots-&gt;getParts()-&gt;delete();
</pre> <p>‘delete’ also accepts an anonymous function to filter what records must be deleted:</p> <pre class="highlight-php" data-language="php">//Delete only whose stock is greater or equal than zero
$robots-&gt;getParts()-&gt;delete(function($part) {
    if ($part-&gt;stock &lt; 0) {
        return false;
    }
    return true;
});
</pre>    <h2 id="record-snapshots">Record Snapshots</h2> <p>Specific models could be set to maintain a record snapshot when they’re queried. You can use this feature to implement auditing or just to know what fields are changed according to the data queried from the persistence:</p> <pre class="highlight-php" data-language="php">class Robots extends Phalcon\Mvc\Model
{
    public function initialize()
    {
        $this-&gt;keepSnapshots(true);
    }
}
</pre> <p>When activating this feature the application consumes a bit more of memory to keep track of the original values obtained from the persistence. In models that have this feature activated you can check what fields changed:</p> <pre class="highlight-php" data-language="php">//Get a record from the database
$robot = Robots::findFirst();

//Change a column
$robot-&gt;name = 'Other name';

var_dump($robot-&gt;getChangedFields()); // ['name']
var_dump($robot-&gt;hasChanged('name')); // true
var_dump($robot-&gt;hasChanged('type')); // false
</pre>   <h2 id="models-meta-data">Models Meta-Data</h2> <p>To speed up development <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> helps you to query fields and constraints from tables related to models. To achieve this, <a class="reference internal" href="../api/phalcon_mvc_model_metadata"><em>Phalcon\Mvc\Model\MetaData</em></a> is available to manage and cache table meta-data.</p> <p>Sometimes it is necessary to get those attributes when working with models. You can get a meta-data instance as follows:</p> <pre class="highlight-php" data-language="php">$robot = new Robots();

// Get Phalcon\Mvc\Model\Metadata instance
$metaData = $robot-&gt;getModelsMetaData();

// Get robots fields names
$attributes = $metaData-&gt;getAttributes($robot);
print_r($attributes);

// Get robots fields data types
$dataTypes = $metaData-&gt;getDataTypes($robot);
print_r($dataTypes);
</pre>  <h3 id="caching-meta-data">Caching Meta-Data</h3> <p>Once the application is in a production stage, it is not necessary to query the meta-data of the table from the database system each time you use the table. This could be done caching the meta-data using any of the following adapters:</p> <table class="docutils"> <colgroup> <col width="2%"> <col width="77%"> <col width="21%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Adapter</th> <th class="head">Description</th> <th class="head">API</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>Memory</td> <td>This adapter is the default. The meta-data is cached only during the request. When the request is completed, the meta-data are released as part of the normal memory of the request. This adapter is perfect when the application is in development so as to refresh the meta-data in each request containing the new and/or modified fields.</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_metadata_memory"><em>Phalcon\Mvc\Model\MetaData\Memory</em></a></td> </tr> <tr class="row-odd">
<td>Session</td> <td>This adapter stores meta-data in the $_SESSION superglobal. This adapter is recommended only when the application is actually using a small number of models. The meta-data are refreshed every time a new session starts. This also requires the use of session_start() to start the session before using any models.</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_metadata_session"><em>Phalcon\Mvc\Model\MetaData\Session</em></a></td> </tr> <tr class="row-even">
<td>Apc</td> <td>This adapter uses the <a class="reference external" href="http://www.php.net/manual/en/book.apc.php">Alternative PHP Cache (APC)</a> to store the table meta-data. You can specify the lifetime of the meta-data with options. This is the most recommended way to store meta-data when the application is in production stage.</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_metadata_apc"><em>Phalcon\Mvc\Model\MetaData\Apc</em></a></td> </tr> <tr class="row-odd">
<td>XCache</td> <td>This adapter uses <a class="reference external" href="http://xcache.lighttpd.net/">XCache</a> to store the table meta-data. You can specify the lifetime of the meta-data with options. This is the most recommended way to store meta-data when the application is in production stage.</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_metadata_xcache"><em>Phalcon\Mvc\Model\MetaData\Xcache</em></a></td> </tr> <tr class="row-even">
<td>Files</td> <td>This adapter uses plain files to store meta-data. By using this adapter the disk-reading is increased but the database access is reduced</td> <td><a class="reference internal" href="../api/phalcon_mvc_model_metadata_files"><em>Phalcon\Mvc\Model\MetaData\Files</em></a></td> </tr> </tbody> </table> <p>As other ORM’s dependencies, the metadata manager is requested from the services container:</p> <pre class="highlight-php" data-language="php">$di['modelsMetadata'] = function() {

    // Create a meta-data manager with APC
    $metaData = new \Phalcon\Mvc\Model\MetaData\Apc(array(
        "lifetime" =&gt; 86400,
        "prefix"   =&gt; "my-prefix"
    ));

    return $metaData;
};
</pre>   <h3 id="meta-data-strategies">Meta-Data Strategies</h3> <p>As mentioned above the default strategy to obtain the model’s meta-data is database introspection. In this strategy, the information schema is used to know the fields in a table, its primary key, nullable fields, data types, etc.</p> <p>You can change the default meta-data introspection in the following way:</p> <pre class="highlight-php" data-language="php">$di['modelsMetadata'] = function() {

    // Instantiate a meta-data adapter
    $metaData = new \Phalcon\Mvc\Model\MetaData\Apc(array(
        "lifetime" =&gt; 86400,
        "prefix"   =&gt; "my-prefix"
    ));

    //Set a custom meta-data introspection strategy
    $metaData-&gt;setStrategy(new MyInstrospectionStrategy());

    return $metaData;
};
</pre>   <h3 id="database-introspection-strategy">Database Introspection Strategy</h3> <p>This strategy doesn’t require any customization and is implicitly used by all the meta-data adapters.</p>   <h3 id="annotations-strategy">Annotations Strategy</h3> <p>This strategy makes use of <a class="reference internal" href="annotations"><em>annotations</em></a> to describe the columns in a model:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    /**
     * @Primary
     * @Identity
     * @Column(type="integer", nullable=false)
     */
    public $id;

    /**
     * @Column(type="string", length=70, nullable=false)
     */
    public $name;

    /**
     * @Column(type="string", length=32, nullable=false)
     */
    public $type;

    /**
     * @Column(type="integer", nullable=false)
     */
    public $year;

}
</pre> <p>Annotations must be placed in properties that are mapped to columns in the mapped source. Properties without the @Column annotation are handled as simple class attributes.</p> <p>The following annotations are supported:</p> <table class="docutils"> <colgroup> <col width="15%"> <col width="85%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Name</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>Primary</td> <td>Mark the field as part of the table’s primary key</td> </tr> <tr class="row-odd">
<td>Identity</td> <td>The field is an auto_increment/serial column</td> </tr> <tr class="row-even">
<td>Column</td> <td>This marks an attribute as a mapped column</td> </tr> </tbody> </table> <p>The annotation @Column supports the following parameters:</p> <table class="docutils"> <colgroup> <col width="15%"> <col width="85%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Name</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>type</td> <td>The column’s type (string, integer, decimal, boolean)</td> </tr> <tr class="row-odd">
<td>length</td> <td>The column’s length if any</td> </tr> <tr class="row-even">
<td>nullable</td> <td>Set whether the column accepts null values or not</td> </tr> </tbody> </table> <p>The annotations strategy could be set up this way:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model\MetaData\Apc as ApcMetaData,
    Phalcon\Mvc\Model\MetaData\Strategy\Annotations as StrategyAnnotations;

$di['modelsMetadata'] = function() {

    // Instantiate a meta-data adapter
    $metaData = new ApcMetaData(array(
        "lifetime" =&gt; 86400,
        "prefix"   =&gt; "my-prefix"
    ));

    //Set a custom meta-data database introspection
    $metaData-&gt;setStrategy(new StrategyAnnotations());

    return $metaData;
};
</pre>   <h3 id="manual-meta-data">Manual Meta-Data</h3> <p>Phalcon can obtain the metadata for each model automatically without the developer must set them manually using any of the introspection strategies presented above.</p> <p>The developer also has the option of define the metadata manually. This strategy overrides any strategy set in the meta-data manager. New columns added/modified/removed to/from the mapped table must be added/modified/removed also for everything to work properly.</p> <p>The following example shows how to define the meta-data manually:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Model,
    Phalcon\Db\Column,
    Phalcon\Mvc\Model\MetaData;

class Robots extends Model
{

    public function metaData()
    {
        return array(

            //Every column in the mapped table
            MetaData::MODELS_ATTRIBUTES =&gt; array(
                'id', 'name', 'type', 'year'
            ),

            //Every column part of the primary key
            MetaData::MODELS_PRIMARY_KEY =&gt; array(
                'id'
            ),

            //Every column that isn't part of the primary key
            MetaData::MODELS_NON_PRIMARY_KEY =&gt; array(
                'name', 'type', 'year'
            ),

            //Every column that doesn't allows null values
            MetaData::MODELS_NOT_NULL =&gt; array(
                'id', 'name', 'type', 'year'
            ),

            //Every column and their data types
            MetaData::MODELS_DATA_TYPES =&gt; array(
                'id' =&gt; Column::TYPE_INTEGER,
                'name' =&gt; Column::TYPE_VARCHAR,
                'type' =&gt; Column::TYPE_VARCHAR,
                'year' =&gt; Column::TYPE_INTEGER
            ),

            //The columns that have numeric data types
            MetaData::MODELS_DATA_TYPES_NUMERIC =&gt; array(
                'id' =&gt; true,
                'year' =&gt; true,
            ),

            //The identity column, use boolean false if the model doesn't have
            //an identity column
            MetaData::MODELS_IDENTITY_COLUMN =&gt; 'id',

            //How every column must be bound/casted
            MetaData::MODELS_DATA_TYPES_BIND =&gt; array(
                'id' =&gt; Column::BIND_PARAM_INT,
                'name' =&gt; Column::BIND_PARAM_STR,
                'type' =&gt; Column::BIND_PARAM_STR,
                'year' =&gt; Column::BIND_PARAM_INT,
            ),

            //Fields that must be ignored from INSERT SQL statements
            MetaData::MODELS_AUTOMATIC_DEFAULT_INSERT =&gt; array(
                'year' =&gt; true
            ),

            //Fields that must be ignored from UPDATE SQL statements
            MetaData::MODELS_AUTOMATIC_DEFAULT_UPDATE =&gt; array(
                'year' =&gt; true
            )

        );
    }

}
</pre>    <h2 id="pointing-to-a-different-schema">Pointing to a different schema</h2> <p>If a model is mapped to a table that is in a different schemas/databases than the default. You can use the getSchema method to define that:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    public function getSchema()
    {
        return "toys";
    }

}
</pre>   <h2 id="setting-multiple-databases">Setting multiple databases</h2> <p>In Phalcon, all models can belong to the same database connection or have an individual one. Actually, when <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> needs to connect to the database it requests the “db” service in the application’s services container. You can overwrite this service setting it in the initialize method:</p> <pre class="highlight-php" data-language="php">//This service returns a MySQL database
$di-&gt;set('dbMysql', function() {
     return new \Phalcon\Db\Adapter\Pdo\Mysql(array(
        "host" =&gt; "localhost",
        "username" =&gt; "root",
        "password" =&gt; "secret",
        "dbname" =&gt; "invo"
    ));
});

//This service returns a PostgreSQL database
$di-&gt;set('dbPostgres', function() {
     return new \Phalcon\Db\Adapter\Pdo\PostgreSQL(array(
        "host" =&gt; "localhost",
        "username" =&gt; "postgres",
        "password" =&gt; "",
        "dbname" =&gt; "invo"
    ));
});
</pre> <p>Then, in the Initialize method, we define the connection service for the model:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    public function initialize()
    {
        $this-&gt;setConnectionService('dbPostgres');
    }

}
</pre> <p>But Phalcon offers you more flexibility, you can define the connection that must be used to ‘read’ and for ‘write’. This is specially useful to balance the load to your databases implementing a master-slave architecture:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    public function initialize()
    {
        $this-&gt;setReadConnectionService('dbSlave');
        $this-&gt;setWriteConnectionService('dbMaster');
    }

}
</pre> <p>The ORM also provides Horizontal Sharding facilities, by allowing you to implement a ‘shard’ selection according to the current query conditions:</p> <pre class="highlight-php" data-language="php">class Robots extends Phalcon\Mvc\Model
{
    /**
     * Dynamically selects a shard
     *
     * @param array $intermediate
     * @param array $bindParams
     * @param array $bindTypes
     */
    public function selectReadConnection($intermediate, $bindParams, $bindTypes)
    {
        //Check if there is a 'where' clause in the select
        if (isset($intermediate['where'])) {

            $conditions = $intermediate['where'];

            //Choose the possible shard according to the conditions
            if ($conditions['left']['name'] == 'id') {
                $id = $conditions['right']['value'];
                if ($id &gt; 0 &amp;&amp; $id &lt; 10000) {
                    return $this-&gt;getDI()-&gt;get('dbShard1');
                }
                if ($id &gt; 10000) {
                    return $this-&gt;getDI()-&gt;get('dbShard2');
                }
            }
        }

        //Use a default shard
        return $this-&gt;getDI()-&gt;get('dbShard0');
    }

}
</pre> <p>The method ‘selectReadConnection’ is called to choose the right connection, this method intercepts any new query executed:</p> <pre class="highlight-php" data-language="php">$robot = Robots::findFirst('id = 101');
</pre>   <h2 id="logging-low-level-sql-statements">Logging Low-Level SQL Statements</h2> <p>When using high-level abstraction components such as <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> to access a database, it is difficult to understand which statements are finally sent to the database system. <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a> is supported internally by <a class="reference internal" href="../api/phalcon_db"><em>Phalcon\Db</em></a>. <a class="reference internal" href="../api/phalcon_logger"><em>Phalcon\Logger</em></a> interacts with <a class="reference internal" href="../api/phalcon_db"><em>Phalcon\Db</em></a>, providing logging capabilities on the database abstraction layer, thus allowing us to log SQL statements as they happen.</p> <pre class="highlight-php" data-language="php">use Phalcon\Logger,
    Phalcon\Db\Adapter\Pdo\Mysql as Connection,
    Phalcon\Events\Manager,
    Phalcon\Logger\Adapter\File as FileLogger;

$di-&gt;set('db', function() {

    $eventsManager = new EventsManager();

    $logger = new FileLogger("app/logs/debug.log");

    //Listen all the database events
    $eventsManager-&gt;attach('db', function($event, $connection) use ($logger) {
        if ($event-&gt;getType() == 'beforeQuery') {
            $logger-&gt;log($connection-&gt;getSQLStatement(), Logger::INFO);
        }
    });

    $connection = new Connection(array(
        "host" =&gt; "localhost",
        "username" =&gt; "root",
        "password" =&gt; "secret",
        "dbname" =&gt; "invo"
    ));

    //Assign the eventsManager to the db adapter instance
    $connection-&gt;setEventsManager($eventsManager);

    return $connection;
});
</pre> <p>As models access the default database connection, all SQL statements that are sent to the database system will be logged in the file:</p> <pre class="highlight-php" data-language="php">$robot = new Robots();
$robot-&gt;name = "Robby the Robot";
$robot-&gt;created_at = "1956-07-21";
if ($robot-&gt;save() == false) {
    echo "Cannot save robot";
}
</pre> <p>As above, the file <em>app/logs/db.log</em> will contain something like this:</p> <pre class="highlight-irc" data-language="irc">[Mon, 30 Apr 12 13:47:18 -0500][DEBUG][Resource Id #77] INSERT INTO robots
(name, created_at) VALUES ('Robby the Robot', '1956-07-21')
</pre>   <h2 id="profiling-sql-statements">Profiling SQL Statements</h2> <p>Thanks to <a class="reference internal" href="../api/phalcon_db"><em>Phalcon\Db</em></a>, the underlying component of <a class="reference internal" href="../api/phalcon_mvc_model"><em>Phalcon\Mvc\Model</em></a>, it’s possible to profile the SQL statements generated by the ORM in order to analyze the performance of database operations. With this you can diagnose performance problems and to discover bottlenecks.</p> <pre class="highlight-php" data-language="php">$di-&gt;set('profiler', function(){
    return new \Phalcon\Db\Profiler();
}, true);

$di-&gt;set('db', function() use ($di) {

    $eventsManager = new \Phalcon\Events\Manager();

    //Get a shared instance of the DbProfiler
    $profiler = $di-&gt;getProfiler();

    //Listen all the database events
    $eventsManager-&gt;attach('db', function($event, $connection) use ($profiler) {
        if ($event-&gt;getType() == 'beforeQuery') {
            $profiler-&gt;startProfile($connection-&gt;getSQLStatement());
        }
        if ($event-&gt;getType() == 'afterQuery') {
            $profiler-&gt;stopProfile();
        }
    });

    $connection = new \Phalcon\Db\Adapter\Pdo\Mysql(array(
        "host" =&gt; "localhost",
        "username" =&gt; "root",
        "password" =&gt; "secret",
        "dbname" =&gt; "invo"
    ));

    //Assign the eventsManager to the db adapter instance
    $connection-&gt;setEventsManager($eventsManager);

    return $connection;
});
</pre> <p>Profiling some queries:</p> <pre class="highlight-php" data-language="php">// Send some SQL statements to the database
Robots::find();
Robots::find(array("order" =&gt; "name"));
Robots::find(array("limit" =&gt; 30));

//Get the generated profiles from the profiler
$profiles = $di-&gt;get('profiler')-&gt;getProfiles();

foreach ($profiles as $profile) {
   echo "SQL Statement: ", $profile-&gt;getSQLStatement(), "\n";
   echo "Start Time: ", $profile-&gt;getInitialTime(), "\n";
   echo "Final Time: ", $profile-&gt;getFinalTime(), "\n";
   echo "Total Elapsed Time: ", $profile-&gt;getTotalElapsedSeconds(), "\n";
}
</pre> <p>Each generated profile contains the duration in milliseconds that each instruction takes to complete as well as the generated SQL statement.</p>   <h2 id="injecting-services-into-models">Injecting services into Models</h2> <p>You may be required to access the application services within a model, the following example explains how to do that:</p> <pre class="highlight-php" data-language="php">class Robots extends \Phalcon\Mvc\Model
{

    public function notSave()
    {
        //Obtain the flash service from the DI container
        $flash = $this-&gt;getDI()-&gt;getFlash();

        //Show validation messages
        foreach ($this-&gt;getMessages() as $message) {
            $flash-&gt;error($message);
        }
    }

}
</pre> <p>The “notSave” event is triggered every time that a “create” or “update” action fails. So we’re flashing the validation messages obtaining the “flash” service from the DI container. By doing this, we don’t have to print messages after each save.</p>   <h2 id="disabling-enabling-features">Disabling/Enabling Features</h2> <p>In the ORM we have implemented a mechanism that allow you to enable/disable specific features or options globally on the fly. According to how you use the ORM you can disable that you aren’t using. These options can also be temporarily disabled if required:</p> <pre class="highlight-php" data-language="php">\Phalcon\Mvc\Model::setup(array(
    'events' =&gt; false,
    'columnRenaming' =&gt; false
));
</pre> <p>The available options are:</p> <table class="docutils"> <colgroup> <col width="19%"> <col width="73%"> <col width="8%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Option</th> <th class="head">Description</th> <th class="head">Default</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>events</td> <td>Enables/Disables callbacks, hooks and event notifications from all the models</td> <td>true</td> </tr> <tr class="row-odd">
<td>columnRenaming</td> <td>Enables/Disables the column renaming</td> <td>true</td> </tr> <tr class="row-even">
<td>notNullValidations</td> <td>The ORM automatically validate the not null columns present in the mapped table</td> <td>true</td> </tr> <tr class="row-odd">
<td>virtualForeignKeys</td> <td>Enables/Disables the virtual foreign keys</td> <td>true</td> </tr> <tr class="row-even">
<td>phqlLiterals</td> <td>Enables/Disables literals in the PHQL parser</td> <td>true</td> </tr> </tbody> </table>   <h2 id="stand-alone-component">Stand-Alone component</h2> <p>Using <a class="reference internal" href="models"><em>Phalcon\Mvc\Model</em></a> in a stand-alone mode can be demonstrated below:</p> <pre class="highlight-php" data-language="php">use Phalcon\DI,
    Phalcon\Db\Adapter\Pdo\Sqlite as Connection,
    Phalcon\Mvc\Model\Manager as ModelsManager,
    Phalcon\Mvc\Model\Metadata\Memory as MetaData,
    Phalcon\Mvc\Model;

$di = new DI();

//Setup a connection
$di-&gt;set('db', new Connection(array(
    "dbname" =&gt; "sample.db"
)));

//Set a models manager
$di-&gt;set('modelsManager', new ModelsManager());

//Use the memory meta-data adapter or other
$di-&gt;set('modelsMetadata', new MetaData());

//Create a model
class Robots extends Model
{

}

//Use the model
echo Robots::count();
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011–2016 Phalcon Framework Team<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://docs.phalconphp.com/en/2.0.0/reference/models.html" class="_attribution-link">https://docs.phalconphp.com/en/2.0.0/reference/models.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
