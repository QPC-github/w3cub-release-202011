
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Sprite - Pygame - W3cubDocs</title>
  
  <meta name="description" content="This module contains several simple classes to be used within games. There is the main Sprite class and several Group classes that contain Sprites. &hellip;">
  <meta name="keywords" content="pygame, sprite, dirtysprite, group, renderplain, renderclear, renderupdates, layeredupdates, layereddirty">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/pygame/ref/sprite.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/pygame.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/pygame/" class="_nav-link" title="" style="margin-left:0;">Pygame</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="title module" data-name="pygame.sprite"> <span class="pre">pygame.sprite</span>
</h1> <blockquote class="line-block"> <div class="line"><span class="summaryline">pygame module with basic game object classes</span></div> </blockquote>  <p>This module contains several simple classes to be used within games. There is the main Sprite class and several Group classes that contain Sprites. The use of these classes is entirely optional when using pygame. The classes are fairly lightweight and only provide a starting place for the code that is common to most games.</p> <p>The Sprite class is intended to be used as a base class for the different types of objects in the game. There is also a base Group class that simply stores sprites. A game could create new types of Group classes that operate on specially customized Sprite instances they contain.</p> <p>The basic Sprite class can draw the Sprites it contains to a Surface. The <code class="docutils literal notranslate"><span class="pre">Group.draw()</span></code> method requires that each Sprite have a <code class="docutils literal notranslate"><span class="pre">Surface.image</span></code> attribute and a <code class="docutils literal notranslate"><span class="pre">Surface.rect</span></code>. The <code class="docutils literal notranslate"><span class="pre">Group.clear()</span></code> method requires these same attributes, and can be used to erase all the Sprites with background. There are also more advanced Groups: <code class="docutils literal notranslate"><span class="pre">pygame.sprite.RenderUpdates()</span></code> and <code class="docutils literal notranslate"><span class="pre">pygame.sprite.OrderedUpdates()</span></code>.</p> <p>Lastly, this module contains several collision functions. These help find sprites inside multiple groups that have intersecting bounding rectangles. To find the collisions, the Sprites are required to have a <code class="docutils literal notranslate"><span class="pre">Surface.rect</span></code> attribute assigned.</p> <p>The groups are designed for high efficiency in removing and adding Sprites to them. They also allow cheap testing to see if a Sprite already exists in a Group. A given Sprite can exist in any number of groups. A game could use some groups to control object rendering, and a completely separate set of groups to control interaction or player movement. Instead of adding type attributes or bools to a derived Sprite class, consider keeping the Sprites inside organized Groups. This will allow for easier lookup later in the game.</p> <p>Sprites and Groups manage their relationships with the <code class="docutils literal notranslate"><span class="pre">add()</span></code> and <code class="docutils literal notranslate"><span class="pre">remove()</span></code> methods. These methods can accept a single or multiple targets for membership. The default initializers for these classes also takes a single or list of targets for initial membership. It is safe to repeatedly add and remove the same Sprite from a Group.</p> <p>While it is possible to design sprite and group classes that don't derive from the Sprite and AbstractGroup classes below, it is strongly recommended that you extend those when you add a Sprite or Group class.</p> <p>Sprites are not thread safe. So lock them yourself if using threads.</p> <dl class="definition class"> <h1 class="title" id="pygame.sprite.Sprite" data-name="pygame.sprite.Sprite"> pygame.sprite.Sprite</h1> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Simple base class for visible game objects.</span></div> <div class="line"><code class="signature">Sprite(*groups) -&gt; Sprite</code></div> </blockquote>  <p>The base class for visible game objects. Derived classes will want to override the <code class="docutils literal notranslate"><span class="pre">Sprite.update()</span></code> and assign a <code class="docutils literal notranslate"><span class="pre">Sprite.image</span></code> and <code class="docutils literal notranslate"><span class="pre">Sprite.rect</span></code> attributes. The initializer can accept any number of Group instances to be added to.</p> <p>When subclassing the Sprite, be sure to call the base initializer before adding the Sprite to Groups. For example:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Block</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="p">):</span>

    <span class="c1"># Constructor. Pass in the color of the block,</span>
    <span class="c1"># and its x and y position</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
       <span class="c1"># Call the parent class (Sprite) constructor</span>
       <span class="n">pygame</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

       <span class="c1"># Create an image of the block, and fill it with a color.</span>
       <span class="c1"># This could also be an image loaded from the disk.</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">([</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">])</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>

       <span class="c1"># Fetch the rectangle object that has the dimensions of the image</span>
       <span class="c1"># Update the position of this object by setting the values of rect.x and rect.y</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">rect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">get_rect</span><span class="p">()</span>
</pre></div> </div> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Sprite.update" data-name="update()">
<code class="signature">update(*args) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">method to control sprite behavior</span></div>  </blockquote> <p>The default implementation of this method does nothing; it's just a convenient "hook" that you can override. This method is called by <code class="docutils literal notranslate"><span class="pre">Group.update()</span></code> with whatever arguments you give it.</p> <p>There is no need to use this method if not using the convenience method by the same name in the Group class.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Sprite.add" data-name="add()">
<code class="signature">add(*groups) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">add the sprite to groups</span></div>  </blockquote> <p>Any number of Group instances can be passed as arguments. The Sprite will be added to the Groups it is not already a member of.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Sprite.remove" data-name="remove()">
<code class="signature">remove(*groups) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">remove the sprite from groups</span></div>  </blockquote> <p>Any number of Group instances can be passed as arguments. The Sprite will be removed from the Groups it is currently a member of.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Sprite.kill" data-name="kill()">
<code class="signature">kill() -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">remove the Sprite from all Groups</span></div>  </blockquote> <p>The Sprite is removed from all the Groups that contain it. This won't change anything about the state of the Sprite. It is possible to continue to use the Sprite after this method has been called, including adding it to Groups.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Sprite.alive" data-name="alive()">
<code class="signature">alive() -&gt; bool</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">does the sprite belong to any groups</span></div>  </blockquote> <p>Returns True when the Sprite belongs to one or more Groups.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Sprite.groups" data-name="groups()">
<code class="signature">groups() -&gt; group_list</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">list of Groups that contain this Sprite</span></div>  </blockquote> <p>Return a list of all the Groups that contain this Sprite.</p> </dd>
</dl> </dd>
</dl> <dl class="definition class"> <h1 class="title" id="pygame.sprite.DirtySprite" data-name="pygame.sprite.DirtySprite"> pygame.sprite.DirtySprite</h1> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">A subclass of Sprite with more attributes and features.</span></div> <div class="line"><code class="signature">DirtySprite(*groups) -&gt; DirtySprite</code></div> </blockquote> <p>Extra DirtySprite attributes with their default values:</p> <p>dirty = 1</p> <pre class="language-python" data-language="python">if set to 1, it is repainted and then set to 0 again
if set to 2 then it is always dirty ( repainted each frame,
flag is not reset)
0 means that it is not dirty and therefore not repainted again
</pre> <p>blendmode = 0</p> <pre class="language-python" data-language="python">its the special_flags argument of blit, blendmodes
</pre> <p>source_rect = None</p> <pre class="language-python" data-language="python">source rect to use, remember that it is relative to
topleft (0,0) of self.image
</pre> <p>visible = 1</p> <pre class="language-python" data-language="python">normally 1, if set to 0 it will not be repainted
(you must set it dirty too to be erased from screen)
</pre> <p>layer = 0</p> <pre class="language-python" data-language="python">(READONLY value, it is read when adding it to the
LayeredDirty, for details see doc of LayeredDirty)
</pre> </dd>
</dl> <dl class="definition class"> <h1 class="title" id="pygame.sprite.Group" data-name="pygame.sprite.Group"> pygame.sprite.Group</h1> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">A container class to hold and manage multiple Sprite objects.</span></div> <div class="line"><code class="signature">Group(*sprites) -&gt; Group</code></div> </blockquote>  <p>A simple container for Sprite objects. This class can be inherited to create containers with more specific behaviors. The constructor takes any number of Sprite arguments to add to the Group. The group supports the following standard Python operations:</p> <pre class="language-python" data-language="python">in      test if a Sprite is contained
len     the number of Sprites contained
bool    test if any Sprites are contained
iter    iterate through all the Sprites
</pre> <p>The Sprites in the Group are not ordered, so drawing and iterating the Sprites is in no particular order.</p> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Group.sprites" data-name="sprites()">
<code class="signature">sprites() -&gt; sprite_list</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">list of the Sprites this Group contains</span></div>  </blockquote> <p>Return a list of all the Sprites this group contains. You can also get an iterator from the group, but you cannot iterator over a Group while modifying it.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Group.copy" data-name="copy()">
<code class="signature">copy() -&gt; Group</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">duplicate the Group</span></div>  </blockquote> <p>Creates a new Group with all the same Sprites as the original. If you have subclassed Group, the new object will have the same (sub-)class as the original. This only works if the derived class's constructor takes the same arguments as the Group class's.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Group.add" data-name="add()">
<code class="signature">add(*sprites) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">add Sprites to this Group</span></div>  </blockquote> <p>Add any number of Sprites to this Group. This will only add Sprites that are not already members of the Group.</p> <p>Each sprite argument can also be a iterator containing Sprites.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Group.remove" data-name="remove()">
<code class="signature">remove(*sprites) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">remove Sprites from the Group</span></div>  </blockquote> <p>Remove any number of Sprites from the Group. This will only remove Sprites that are already members of the Group.</p> <p>Each sprite argument can also be a iterator containing Sprites.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Group.has" data-name="has()">
<code class="signature">has(*sprites) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">test if a Group contains Sprites</span></div>  </blockquote> <p>Return True if the Group contains all of the given sprites. This is similar to using the "in" operator on the Group ("if sprite in group: ..."), which tests if a single Sprite belongs to a Group.</p> <p>Each sprite argument can also be a iterator containing Sprites.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Group.update" data-name="update()">
<code class="signature">update(*args) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">call the update method on contained Sprites</span></div>  </blockquote> <p>Calls the <code class="docutils literal notranslate"><span class="pre">update()</span></code> method on all Sprites in the Group. The base Sprite class has an update method that takes any number of arguments and does nothing. The arguments passed to <code class="docutils literal notranslate"><span class="pre">Group.update()</span></code> will be passed to each Sprite.</p> <p>There is no way to get the return value from the <code class="docutils literal notranslate"><span class="pre">Sprite.update()</span></code> methods.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Group.draw" data-name="draw()">
<code class="signature">draw(Surface) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">blit the Sprite images</span></div>  </blockquote> <p>Draws the contained Sprites to the Surface argument. This uses the <code class="docutils literal notranslate"><span class="pre">Sprite.image</span></code> attribute for the source surface, and <code class="docutils literal notranslate"><span class="pre">Sprite.rect</span></code> for the position.</p> <p>The Group does not keep sprites in any order, so the draw order is arbitrary.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Group.clear" data-name="clear()">
<code class="signature">clear(Surface_dest, background) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">draw a background over the Sprites</span></div>  </blockquote> <p>Erases the Sprites used in the last <code class="docutils literal notranslate"><span class="pre">Group.draw()</span></code> call. The destination Surface is cleared by filling the drawn Sprite positions with the background.</p> <p>The background is usually a Surface image the same dimensions as the destination Surface. However, it can also be a callback function that takes two arguments; the destination Surface and an area to clear. The background callback function will be called several times each clear.</p> <p>Here is an example callback that will clear the Sprites with solid red:</p> <pre class="language-python" data-language="python">def clear_callback(surf, rect):
    color = 255, 0, 0
    surf.fill(color, rect)
</pre> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.Group.empty" data-name="empty()">
<code class="signature">empty() -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">remove all Sprites</span></div>  </blockquote> <p>Removes all Sprites from this Group.</p> </dd>
</dl> </dd>
</dl> <dl class="definition class"> <h1 class="title" id="pygame.sprite.RenderPlain" data-name="pygame.sprite.RenderPlain"> pygame.sprite.RenderPlain</h1> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Same as pygame.sprite.Group</span></div> </blockquote> <p>This class is an alias to <code class="docutils literal notranslate"><span class="pre">pygame.sprite.Group()</span></code>. It has no additional functionality.</p> </dd>
</dl> <dl class="definition class"> <h1 class="title" id="pygame.sprite.RenderClear" data-name="pygame.sprite.RenderClear"> pygame.sprite.RenderClear</h1> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Same as pygame.sprite.Group</span></div> </blockquote> <p>This class is an alias to <code class="docutils literal notranslate"><span class="pre">pygame.sprite.Group()</span></code>. It has no additional functionality.</p> </dd>
</dl> <dl class="definition class"> <h1 class="title" id="pygame.sprite.RenderUpdates" data-name="pygame.sprite.RenderUpdates"> pygame.sprite.RenderUpdates</h1> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Group sub-class that tracks dirty updates.</span></div> <div class="line"><code class="signature">RenderUpdates(*sprites) -&gt; RenderUpdates</code></div> </blockquote>  <p>This class is derived from <code class="docutils literal notranslate"><span class="pre">pygame.sprite.Group()</span></code>. It has an extended <code class="docutils literal notranslate"><span class="pre">draw()</span></code> method that tracks the changed areas of the screen.</p> <dl class="definition method"> <h3 class="title" id="pygame.sprite.RenderUpdates.draw" data-name="draw()">
<code class="signature">draw(surface) -&gt; Rect_list</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">blit the Sprite images and track changed areas</span></div>  </blockquote> <p>Draws all the Sprites to the surface, the same as <code class="docutils literal notranslate"><span class="pre">Group.draw()</span></code>. This method also returns a list of Rectangular areas on the screen that have been changed. The returned changes include areas of the screen that have been affected by previous <code class="docutils literal notranslate"><span class="pre">Group.clear()</span></code> calls.</p> <p>The returned Rect list should be passed to <code class="docutils literal notranslate"><span class="pre">pygame.display.update()</span></code>. This will help performance on software driven display modes. This type of updating is usually only helpful on destinations with non-animating backgrounds.</p> </dd>
</dl> </dd>
</dl> <dl class="definition function"> <h3 class="title" id="pygame.sprite.OrderedUpdates" data-name="pygame.sprite.OrderedUpdates()">
<code class="signature">OrderedUpdates(*spites) -&gt; OrderedUpdates</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">RenderUpdates sub-class that draws Sprites in order of addition.</span></div>  </blockquote> <p>This class derives from <code class="docutils literal notranslate"><span class="pre">pygame.sprite.RenderUpdates()</span></code>. It maintains the order in which the Sprites were added to the Group for rendering. This makes adding and removing Sprites from the Group a little slower than regular Groups.</p> </dd>
</dl> <dl class="definition class"> <h1 class="title" id="pygame.sprite.LayeredUpdates" data-name="pygame.sprite.LayeredUpdates"> pygame.sprite.LayeredUpdates</h1> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">LayeredUpdates is a sprite group that handles layers and draws like OrderedUpdates.</span></div> <div class="line"><code class="signature">LayeredUpdates(*spites, **kwargs) -&gt; LayeredUpdates</code></div> </blockquote>  <p>This group is fully compatible with <a class="tooltip reference internal" href="#pygame.sprite.Sprite" title=""><code class="xref py py-class docutils literal notranslate"><span class="pre">pygame.sprite.Sprite</span></code></a>.</p> <p>You can set the default layer through kwargs using 'default_layer' and an integer for the layer. The default layer is 0.</p> <p>If the sprite you add has an attribute layer then that layer will be used. If the **kwarg contains 'layer' then the sprites passed will be added to that layer (overriding the <code class="docutils literal notranslate"><span class="pre">sprite.layer</span></code> attribute). If neither sprite has attribute layer nor **kwarg then the default layer is used to add the sprites.</p> <div class="versionadded"> <p><span class="versionmodified">New in pygame 1.8.</span></p> </div> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.add" data-name="add()">
<code class="signature">add(*sprites, **kwargs) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">add a sprite or sequence of sprites to a group</span></div>  </blockquote> <p>If the <code class="docutils literal notranslate"><span class="pre">sprite(s)</span></code> have an attribute layer then that is used for the layer. If **kwargs contains 'layer' then the <code class="docutils literal notranslate"><span class="pre">sprite(s)</span></code> will be added to that argument (overriding the sprite layer attribute). If neither is passed then the <code class="docutils literal notranslate"><span class="pre">sprite(s)</span></code> will be added to the default layer.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.sprites" data-name="sprites()">
<code class="signature">sprites() -&gt; sprites</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">returns a ordered list of sprites (first back, last top).</span></div>  </blockquote> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.draw" data-name="draw()">
<code class="signature">draw(surface) -&gt; Rect_list</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">draw all sprites in the right order onto the passed surface.</span></div>  </blockquote> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.get_sprites_at" data-name="get_sprites_at()">
<code class="signature">get_sprites_at(pos) -&gt; colliding_sprites</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">returns a list with all sprites at that position.</span></div>  </blockquote> <p>Bottom sprites first, top last.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.get_sprite" data-name="get_sprite()">
<code class="signature">get_sprite(idx) -&gt; sprite</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">returns the sprite at the index idx from the groups sprites</span></div>  </blockquote> <p>Raises IndexOutOfBounds if the idx is not within range.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.remove_sprites_of_layer" data-name="remove_sprites_of_layer()">
<code class="signature">remove_sprites_of_layer(layer_nr) -&gt; sprites</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">removes all sprites from a layer and returns them as a list.</span></div>  </blockquote> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.layers" data-name="layers()">
<code class="signature">layers() -&gt; layers</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">returns a list of layers defined (unique), sorted from bottom up.</span></div>  </blockquote> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.change_layer" data-name="change_layer()">
<code class="signature">change_layer(sprite, new_layer) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">changes the layer of the sprite</span></div>  </blockquote> <p>sprite must have been added to the renderer. It is not checked.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.get_layer_of_sprite" data-name="get_layer_of_sprite()">
<code class="signature">get_layer_of_sprite(sprite) -&gt; layer</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">returns the layer that sprite is currently in.</span></div>  </blockquote> <p>If the sprite is not found then it will return the default layer.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.get_top_layer" data-name="get_top_layer()">
<code class="signature">get_top_layer() -&gt; layer</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">returns the top layer</span></div>  </blockquote> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.get_bottom_layer" data-name="get_bottom_layer()">
<code class="signature">get_bottom_layer() -&gt; layer</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">returns the bottom layer</span></div>  </blockquote> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.move_to_front" data-name="move_to_front()">
<code class="signature">move_to_front(sprite) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">brings the sprite to front layer</span></div>  </blockquote> <p>Brings the sprite to front, changing sprite layer to topmost layer (added at the end of that layer).</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.move_to_back" data-name="move_to_back()">
<code class="signature">move_to_back(sprite) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">moves the sprite to the bottom layer</span></div>  </blockquote> <p>Moves the sprite to the bottom layer, moving it behind all other layers and adding one additional layer.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.get_top_sprite" data-name="get_top_sprite()">
<code class="signature">get_top_sprite() -&gt; Sprite</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">returns the topmost sprite</span></div>  </blockquote> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.get_sprites_from_layer" data-name="get_sprites_from_layer()">
<code class="signature">get_sprites_from_layer(layer) -&gt; sprites</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">returns all sprites from a layer, ordered by how they where added</span></div>  </blockquote> <p>Returns all sprites from a layer, ordered by how they where added. It uses linear search and the sprites are not removed from layer.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredUpdates.switch_layer" data-name="switch_layer()">
<code class="signature">switch_layer(layer1_nr, layer2_nr) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">switches the sprites from layer1 to layer2</span></div>  </blockquote> <p>The layers number must exist, it is not checked.</p> </dd>
</dl> </dd>
</dl> <dl class="definition class"> <h1 class="title" id="pygame.sprite.LayeredDirty" data-name="pygame.sprite.LayeredDirty"> pygame.sprite.LayeredDirty</h1> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">LayeredDirty group is for DirtySprite objects. Subclasses LayeredUpdates.</span></div> <div class="line"><code class="signature">LayeredDirty(*spites, **kwargs) -&gt; LayeredDirty</code></div> </blockquote>  <p>This group requires <a class="tooltip reference internal" href="#pygame.sprite.DirtySprite" title=""><code class="xref py py-class docutils literal notranslate"><span class="pre">pygame.sprite.DirtySprite</span></code></a> or any sprite that has the following attributes:</p> <pre class="language-python" data-language="python">image, rect, dirty, visible, blendmode (see doc of DirtySprite).
</pre> <p>It uses the dirty flag technique and is therefore faster than the <a class="tooltip reference internal" href="#pygame.sprite.RenderUpdates" title=""><code class="xref py py-class docutils literal notranslate"><span class="pre">pygame.sprite.RenderUpdates</span></code></a> if you have many static sprites. It also switches automatically between dirty rect update and full screen drawing, so you do no have to worry what would be faster.</p> <p>Same as for the <a class="tooltip reference internal" href="#pygame.sprite.Group" title=""><code class="xref py py-class docutils literal notranslate"><span class="pre">pygame.sprite.Group</span></code></a>. You can specify some additional attributes through kwargs:</p> <pre class="language-python" data-language="python">_use_update: True/False   default is False
_default_layer: default layer where sprites without a layer are added.
_time_threshold: threshold time for switching between dirty rect mode
    and fullscreen mode, defaults to 1000./80  == 1000./fps
</pre> <div class="versionadded"> <p><span class="versionmodified">New in pygame 1.8.</span></p> </div> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredDirty.draw" data-name="draw()">
<code class="signature">draw(surface, bgd=None) -&gt; Rect_list</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">draw all sprites in the right order onto the passed surface.</span></div>  </blockquote> <p>You can pass the background too. If a background is already set, then the bgd argument has no effect.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredDirty.clear" data-name="clear()">
<code class="signature">clear(surface, bgd) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">used to set background</span></div>  </blockquote> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredDirty.repaint_rect" data-name="repaint_rect()">
<code class="signature">repaint_rect(screen_rect) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">repaints the given area</span></div>  </blockquote> <p>screen_rect is in screen coordinates.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredDirty.set_clip" data-name="set_clip()">
<code class="signature">set_clip(screen_rect=None) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">clip the area where to draw. Just pass None (default) to reset the clip</span></div>  </blockquote> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredDirty.get_clip" data-name="get_clip()">
<code class="signature">get_clip() -&gt; Rect</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">clip the area where to draw. Just pass None (default) to reset the clip</span></div>  </blockquote> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredDirty.change_layer" data-name="change_layer()">
<code class="signature">change_layer(sprite, new_layer) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">changes the layer of the sprite</span></div>  </blockquote> <p>sprite must have been added to the renderer. It is not checked.</p> </dd>
</dl> <dl class="definition method"> <h3 class="title" id="pygame.sprite.LayeredDirty.set_timing_treshold" data-name="set_timing_treshold()">
<code class="signature">set_timing_treshold(time_ms) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">sets the threshold in milliseconds</span></div>  </blockquote> <p>Default is 1000./80 where 80 is the fps I want to switch to full screen mode. This method's name is a typo and should be fixed.</p> </dd>
</dl> </dd>
</dl> <dl class="definition function"> <h3 class="title" id="pygame.sprite.GroupSingle" data-name="pygame.sprite.GroupSingle()">
<code class="signature">GroupSingle(sprite=None) -&gt; GroupSingle</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Group container that holds a single sprite.</span></div>  </blockquote> <p>The GroupSingle container only holds a single Sprite. When a new Sprite is added, the old one is removed.</p> <p>There is a special property, <code class="docutils literal notranslate"><span class="pre">GroupSingle.sprite</span></code>, that accesses the Sprite that this Group contains. It can be None when the Group is empty. The property can also be assigned to add a Sprite into the GroupSingle container.</p> </dd>
</dl> <dl class="definition function"> <h3 class="title" id="pygame.sprite.spritecollide" data-name="pygame.sprite.spritecollide()">
<code class="signature">spritecollide(sprite, group, dokill, collided = None) -&gt; Sprite_list</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Find sprites in a group that intersect another sprite.</span></div>  </blockquote> <p>Return a list containing all Sprites in a Group that intersect with another Sprite. Intersection is determined by comparing the <code class="docutils literal notranslate"><span class="pre">Sprite.rect</span></code> attribute of each Sprite.</p> <p>The dokill argument is a bool. If set to True, all Sprites that collide will be removed from the Group.</p> <p>The collided argument is a callback function used to calculate if two sprites are colliding. it should take two sprites as values, and return a bool value indicating if they are colliding. If collided is not passed, all sprites must have a "rect" value, which is a rectangle of the sprite area, which will be used to calculate the collision.</p> <p>collided callables:</p> <pre class="language-python" data-language="python">collide_rect, collide_rect_ratio, collide_circle,
collide_circle_ratio, collide_mask
</pre> <p>Example:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre><span class="c1"># See if the Sprite block has collided with anything in the Group block_list</span>
<span class="c1"># The True flag will remove the sprite in block_list</span>
<span class="n">blocks_hit_list</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">spritecollide</span><span class="p">(</span><span class="n">player</span><span class="p">,</span> <span class="n">block_list</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

<span class="c1"># Check the list of colliding sprites, and add one to the score for each one</span>
<span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks_hit_list</span><span class="p">:</span>
    <span class="n">score</span> <span class="o">+=</span><span class="mi">1</span>
</pre></div> </div> </dd>
</dl> <dl class="definition function"> <h3 class="title" id="pygame.sprite.collide_rect" data-name="pygame.sprite.collide_rect()">
<code class="signature">collide_rect(left, right) -&gt; bool</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Collision detection between two sprites, using rects.</span></div>  </blockquote> <p>Tests for collision between two sprites. Uses the pygame rect colliderect function to calculate the collision. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a "rect" attributes.</p> <div class="versionadded"> <p><span class="versionmodified">New in pygame 1.8.</span></p> </div> </dd>
</dl> <dl class="definition function"> <h3 class="title" id="pygame.sprite.collide_rect_ratio" data-name="pygame.sprite.collide_rect_ratio()">
<code class="signature">collide_rect_ratio(ratio) -&gt; collided_callable</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Collision detection between two sprites, using rects scaled to a ratio.</span></div>  </blockquote> <p>A callable class that checks for collisions between two sprites, using a scaled version of the sprites rects.</p> <p>Is created with a ratio, the instance is then intended to be passed as a collided callback function to the *collide functions.</p> <p>A ratio is a floating point number - 1.0 is the same size, 2.0 is twice as big, and 0.5 is half the size.</p> <div class="versionadded"> <p><span class="versionmodified">New in pygame 1.8.1.</span></p> </div> </dd>
</dl> <dl class="definition function"> <h3 class="title" id="pygame.sprite.collide_circle" data-name="pygame.sprite.collide_circle()">
<code class="signature">collide_circle(left, right) -&gt; bool</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Collision detection between two sprites, using circles.</span></div>  </blockquote> <p>Tests for collision between two sprites, by testing to see if two circles centered on the sprites overlap. If the sprites have a "radius" attribute, that is used to create the circle, otherwise a circle is created that is big enough to completely enclose the sprites rect as given by the "rect" attribute. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a "rect" and an optional "radius" attribute.</p> <div class="versionadded"> <p><span class="versionmodified">New in pygame 1.8.1.</span></p> </div> </dd>
</dl> <dl class="definition function"> <h3 class="title" id="pygame.sprite.collide_circle_ratio" data-name="pygame.sprite.collide_circle_ratio()">
<code class="signature">collide_circle_ratio(ratio) -&gt; collided_callable</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Collision detection between two sprites, using circles scaled to a ratio.</span></div>  </blockquote> <p>A callable class that checks for collisions between two sprites, using a scaled version of the sprites radius.</p> <p>Is created with a floating point ratio, the instance is then intended to be passed as a collided callback function to the *collide functions.</p> <p>A ratio is a floating point number - 1.0 is the same size, 2.0 is twice as big, and 0.5 is half the size.</p> <p>The created callable tests for collision between two sprites, by testing to see if two circles centered on the sprites overlap, after scaling the circles radius by the stored ratio. If the sprites have a "radius" attribute, that is used to create the circle, otherwise a circle is created that is big enough to completely enclose the sprites rect as given by the "rect" attribute. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a "rect" and an optional "radius" attribute.</p> <div class="versionadded"> <p><span class="versionmodified">New in pygame 1.8.1.</span></p> </div> </dd>
</dl> <dl class="definition function"> <h3 class="title" id="pygame.sprite.collide_mask" data-name="pygame.sprite.collide_mask()">
<code class="signature">collide_mask(SpriteLeft, SpriteRight) -&gt; point</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Collision detection between two sprites, using masks.</span></div>  </blockquote> <p>Returns first point on the mask where the masks collided, or None if there was no collision.</p> <p>Tests for collision between two sprites, by testing if their bitmasks overlap. If the sprites have a "mask" attribute, that is used as the mask, otherwise a mask is created from the sprite image. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a "rect" and an optional "mask" attribute.</p> <p>You should consider creating a mask for your sprite at load time if you are going to check collisions many times. This will increase the performance, otherwise this can be an expensive function because it will create the masks each time you check for collisions.</p> <pre class="language-python" data-language="python">sprite.mask = pygame.mask.from_surface(sprite.image)
</pre> <div class="versionadded"> <p><span class="versionmodified">New in pygame 1.8.0.</span></p> </div> </dd>
</dl> <dl class="definition function"> <h3 class="title" id="pygame.sprite.groupcollide" data-name="pygame.sprite.groupcollide()">
<code class="signature">groupcollide(group1, group2, dokill1, dokill2, collided = None) -&gt; Sprite_dict</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Find all sprites that collide between two groups.</span></div>  </blockquote> <p>This will find collisions between all the Sprites in two groups. Collision is determined by comparing the <code class="docutils literal notranslate"><span class="pre">Sprite.rect</span></code> attribute of each Sprite or by using the collided function if it is not None.</p> <p>Every Sprite inside group1 is added to the return dictionary. The value for each item is the list of Sprites in group2 that intersect.</p> <p>If either dokill argument is True, the colliding Sprites will be removed from their respective Group.</p> <p>The collided argument is a callback function used to calculate if two sprites are colliding. It should take two sprites as values and return a bool value indicating if they are colliding. If collided is not passed, then all sprites must have a "rect" value, which is a rectangle of the sprite area, which will be used to calculate the collision.</p> </dd>
</dl> <dl class="definition function"> <h3 class="title" id="pygame.sprite.spritecollideany" data-name="pygame.sprite.spritecollideany()">
<code class="signature">spritecollideany(sprite, group, collided = None) -&gt; Sprite</code><br><code class="signature">spritecollideany(sprite, group, collided = None) -&gt; None</code><br>
</h3> <dd>
<blockquote class="line-block"> <div class="line"><span class="summaryline">Simple test if a sprite intersects anything in a group.</span></div> <div class="line"> Collision with the returned sprite.</div> <div class="line"> No collision</div> </blockquote> <p>If the sprite collides with any single sprite in the group, a single sprite from the group is returned. On no collision None is returned.</p> <p>If you don't need all the features of the <code class="docutils literal notranslate"><span class="pre">pygame.sprite.spritecollide()</span></code> function, this function will be a bit quicker.</p> <p>The collided argument is a callback function used to calculate if two sprites are colliding. It should take two sprites as values and return a bool value indicating if they are colliding. If collided is not passed, then all sprites must have a "rect" value, which is a rectangle of the sprite area, which will be used to calculate the collision.</p> </dd>
</dl>   <br><br> <hr> <a href="https://github.com/pygame/pygame/edit/master/docs/reST/ref/sprite.rst" rel="nofollow">Edit on GitHub</a><div class="_attribution">
  <p class="_attribution-p">
    © Pygame Developers.<br>Licensed under the GNU LGPL License version 2.1.<br>
    <a href="https://www.pygame.org/docs/ref/sprite.html" class="_attribution-link">https://www.pygame.org/docs/ref/sprite.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
