
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>StatefulSet Basics - Kubernetes - W3cubDocs</title>
  
  <meta name="description" content="This tutorial provides an introduction to managing applications with StatefulSets. It demonstrates how to create, delete, scale, and update the Pods &hellip;">
  <meta name="keywords" content="statefulset, basics, kubernetes">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/kubernetes/tutorials/stateful-application/basic-stateful-set/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-60a6449bb52e9968d95c133a29f066ffcb8dbe4f077d4022e51c991ce30bf256c8e19c508207a4193c414ffd0414826564317669b0f27f9f85c1cb21b84e097e.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/kubernetes.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/kubernetes/" class="_nav-link" title="" style="margin-left:0;">Kubernetes</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _kubernetes">
				
				
<h1>StatefulSet Basics</h1>  <p>This tutorial provides an introduction to managing applications with <a class="glossary-tooltip" title="Manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod." data-toggle="tooltip" data-placement="top" href="../../../concepts/workloads/controllers/statefulset/index" target="_blank" aria-label="StatefulSets">StatefulSets</a>. It demonstrates how to create, delete, scale, and update the Pods of StatefulSets.</p> <h2 id="before-you-begin">Before you begin</h2> <p>Before you begin this tutorial, you should familiarize yourself with the following Kubernetes concepts:</p> <ul> <li><a href="../../../concepts/workloads/pods/index">Pods</a></li> <li><a href="../../../concepts/services-networking/dns-pod-service/index">Cluster DNS</a></li> <li><a href="../../../concepts/services-networking/service/index#headless-services">Headless Services</a></li> <li><a href="../../../concepts/storage/persistent-volumes/index">PersistentVolumes</a></li> <li><a href="https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/">PersistentVolume Provisioning</a></li> <li><a href="../../../concepts/workloads/controllers/statefulset/index">StatefulSets</a></li> <li>The <a href="../../../reference/kubectl/kubectl/index">kubectl</a> command line tool</li> </ul> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> This tutorial assumes that your cluster is configured to dynamically provision PersistentVolumes. If your cluster is not configured to do so, you will have to manually provision two 1 GiB volumes prior to starting this tutorial. </div> <h2 id="objectives">Objectives</h2> <p>StatefulSets are intended to be used with stateful applications and distributed systems. However, the administration of stateful applications and distributed systems on Kubernetes is a broad, complex topic. In order to demonstrate the basic features of a StatefulSet, and not to conflate the former topic with the latter, you will deploy a simple web application using a StatefulSet.</p> <p>After this tutorial, you will be familiar with the following.</p> <ul> <li>How to create a StatefulSet</li> <li>How a StatefulSet manages its Pods</li> <li>How to delete a StatefulSet</li> <li>How to scale a StatefulSet</li> <li>How to update a StatefulSet's Pods</li> </ul>  <h2 id="creating-a-statefulset">Creating a StatefulSet</h2> <p>Begin by creating a StatefulSet using the example below. It is similar to the example presented in the <a href="../../../concepts/workloads/controllers/statefulset/index">StatefulSets</a> concept. It creates a <a href="../../../concepts/services-networking/service/index#headless-services">headless Service</a>, <code>nginx</code>, to publish the IP addresses of Pods in the StatefulSet, <code>web</code>.</p> <pre class="highlight" data-language="">application/web/web.yaml</pre> <p>Download the example above, and save it to a file named <code>web.yaml</code></p> <p>You will need to use two terminal windows. In the first terminal, use <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/#get"><code>kubectl get</code></a> to watch the creation of the StatefulSet's Pods.</p> <pre class="highlight" data-language="shell">kubectl get pods -w -l app=nginx
</pre>
<p>In the second terminal, use <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/#apply"><code>kubectl apply</code></a> to create the headless Service and StatefulSet defined in <code>web.yaml</code>.</p> <pre class="highlight" data-language="shell">kubectl apply -f web.yaml
</pre>
<pre><code>service/nginx created
statefulset.apps/web created
</code></pre>
<p>The command above creates two Pods, each running an <a href="https://www.nginx.com">NGINX</a> webserver. Get the <code>nginx</code> Service...</p> <pre class="highlight" data-language="shell">kubectl get service nginx
</pre>
<pre><code>NAME      TYPE         CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
nginx     ClusterIP    None         &lt;none&gt;        80/TCP    12s
</code></pre>
<p>...then get the <code>web</code> StatefulSet, to verify that both were created successfully:</p> <pre class="highlight" data-language="shell">kubectl get statefulset web
</pre>
<pre><code>NAME      DESIRED   CURRENT   AGE
web       2         1         20s
</code></pre>
<h3 id="ordered-pod-creation">Ordered Pod Creation</h3> <p>For a StatefulSet with <em>n</em> replicas, when Pods are being deployed, they are created sequentially, ordered from <em>{0..n-1}</em>. Examine the output of the <code>kubectl get</code> command in the first terminal. Eventually, the output will look like the example below.</p> <pre class="highlight" data-language="shell">kubectl get pods -w -l app=nginx
</pre>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     0/1       Pending   0          0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         19s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         18s
</code></pre>
<p>Notice that the <code>web-1</code> Pod is not launched until the <code>web-0</code> Pod is <em>Running</em> (see <a href="../../../concepts/workloads/pods/pod-lifecycle/index#pod-phase">Pod Phase</a>) and <em>Ready</em> (see <code>type</code> in <a href="../../../concepts/workloads/pods/pod-lifecycle/index#pod-conditions">Pod Conditions</a>).</p> <h2 id="pods-in-a-statefulset">Pods in a StatefulSet</h2> <p>Pods in a StatefulSet have a unique ordinal index and a stable network identity.</p> <h3 id="examining-the-pod-s-ordinal-index">Examining the Pod's Ordinal Index</h3> <p>Get the StatefulSet's Pods:</p> <pre class="highlight" data-language="shell">kubectl get pods -l app=nginx
</pre>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          1m
web-1     1/1       Running   0          1m
</code></pre>
<p>As mentioned in the <a href="../../../concepts/workloads/controllers/statefulset/index">StatefulSets</a> concept, the Pods in a StatefulSet have a sticky, unique identity. This identity is based on a unique ordinal index that is assigned to each Pod by the StatefulSet <a class="glossary-tooltip" title="A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state." data-toggle="tooltip" data-placement="top" href="../../../concepts/architecture/controller/index" target="_blank" aria-label="controller">controller</a>.<br> The Pods' names take the form <code>&lt;statefulset name&gt;-&lt;ordinal index&gt;</code>. Since the <code>web</code> StatefulSet has two replicas, it creates two Pods, <code>web-0</code> and <code>web-1</code>.</p> <h3 id="using-stable-network-identities">Using Stable Network Identities</h3> <p>Each Pod has a stable hostname based on its ordinal index. Use <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/#exec"><code>kubectl exec</code></a> to execute the <code>hostname</code> command in each Pod:</p> <pre class="highlight" data-language="shell">for i in 0 1; do kubectl exec "web-$i" -- sh -c 'hostname'; done
</pre>
<pre><code>web-0
web-1
</code></pre>
<p>Use <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/#run"><code>kubectl run</code></a> to execute a container that provides the <code>nslookup</code> command from the <code>dnsutils</code> package. Using <code>nslookup</code> on the Pods' hostnames, you can examine their in-cluster DNS addresses:</p> <pre class="highlight" data-language="shell">kubectl run -i --tty --image busybox:1.28 dns-test --restart=Never --rm
</pre>
<p>which starts a new shell. In that new shell, run:</p> <pre class="highlight" data-language="shell"># Run this in the dns-test container shell
nslookup web-0.nginx
</pre>
<p>The output is similar to:</p> <pre><code>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-0.nginx
Address 1: 10.244.1.6

nslookup web-1.nginx
Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-1.nginx
Address 1: 10.244.2.6
</code></pre>
<p>(and now exit the container shell: <code>exit</code>)</p> <p>The CNAME of the headless service points to SRV records (one for each Pod that is Running and Ready). The SRV records point to A record entries that contain the Pods' IP addresses.</p> <p>In one terminal, watch the StatefulSet's Pods:</p> <pre class="highlight" data-language="shell">kubectl get pod -w -l app=nginx
</pre>
<p>In a second terminal, use <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/#delete"><code>kubectl delete</code></a> to delete all the Pods in the StatefulSet:</p> <pre class="highlight" data-language="shell">kubectl delete pod -l app=nginx
</pre>
<pre><code>pod "web-0" deleted
pod "web-1" deleted
</code></pre>
<p>Wait for the StatefulSet to restart them, and for both Pods to transition to Running and Ready:</p> <pre class="highlight" data-language="shell">kubectl get pod -w -l app=nginx
</pre>
<pre><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     0/1       ContainerCreating   0          0s
NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          2s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         34s
</code></pre>
<p>Use <code>kubectl exec</code> and <code>kubectl run</code> to view the Pods' hostnames and in-cluster DNS entries. First, view the Pods' hostnames:</p> <pre class="highlight" data-language="shell">for i in 0 1; do kubectl exec web-$i -- sh -c 'hostname'; done
</pre>
<pre><code>web-0
web-1
</code></pre>
<p>then, run:</p> <pre><code>kubectl run -i --tty --image busybox:1.28 dns-test --restart=Never --rm /bin/sh
</code></pre>
<p>which starts a new shell.<br> In that new shell, run:</p> <pre class="highlight" data-language="shell"># Run this in the dns-test container shell
nslookup web-0.nginx
</pre>
<p>The output is similar to:</p> <pre><code>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-0.nginx
Address 1: 10.244.1.7

nslookup web-1.nginx
Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-1.nginx
Address 1: 10.244.2.8
</code></pre>
<p>(and now exit the container shell: <code>exit</code>)</p> <p>The Pods' ordinals, hostnames, SRV records, and A record names have not changed, but the IP addresses associated with the Pods may have changed. In the cluster used for this tutorial, they have. This is why it is important not to configure other applications to connect to Pods in a StatefulSet by IP address.</p> <p>If you need to find and connect to the active members of a StatefulSet, you should query the CNAME of the headless Service (<code>nginx.default.svc.cluster.local</code>). The SRV records associated with the CNAME will contain only the Pods in the StatefulSet that are Running and Ready.</p> <p>If your application already implements connection logic that tests for liveness and readiness, you can use the SRV records of the Pods ( <code>web-0.nginx.default.svc.cluster.local</code>, <code>web-1.nginx.default.svc.cluster.local</code>), as they are stable, and your application will be able to discover the Pods' addresses when they transition to Running and Ready.</p> <h3 id="writing-to-stable-storage">Writing to Stable Storage</h3> <p>Get the PersistentVolumeClaims for <code>web-0</code> and <code>web-1</code>:</p> <pre class="highlight" data-language="shell">kubectl get pvc -l app=nginx
</pre>
<p>The output is similar to:</p> <pre><code>NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           48s
www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           48s
</code></pre>
<p>The StatefulSet controller created two <a class="glossary-tooltip" title="Claims storage resources defined in a PersistentVolume so that it can be mounted as a volume in a container." data-toggle="tooltip" data-placement="top" href="../../../concepts/storage/persistent-volumes/index" target="_blank" aria-label="PersistentVolumeClaims">PersistentVolumeClaims</a> that are bound to two <a class="glossary-tooltip" title="An API object that represents a piece of storage in the cluster. Available as a general, pluggable resource that persists beyond the lifecycle of any individual Pod." data-toggle="tooltip" data-placement="top" href="../../../concepts/storage/persistent-volumes/index" target="_blank" aria-label="PersistentVolumes">PersistentVolumes</a>.</p> <p>As the cluster used in this tutorial is configured to dynamically provision PersistentVolumes, the PersistentVolumes were created and bound automatically.</p> <p>The NGINX webserver, by default, serves an index file from <code>/usr/share/nginx/html/index.html</code>. The <code>volumeMounts</code> field in the StatefulSet's <code>spec</code> ensures that the <code>/usr/share/nginx/html</code> directory is backed by a PersistentVolume.</p> <p>Write the Pods' hostnames to their <code>index.html</code> files and verify that the NGINX webservers serve the hostnames:</p> <pre class="highlight" data-language="shell">for i in 0 1; do kubectl exec "web-$i" -- sh -c 'echo "$(hostname)" &gt; /usr/share/nginx/html/index.html'; done

for i in 0 1; do kubectl exec -i -t "web-$i" -- curl http://localhost/; done
</pre>
<pre><code>web-0
web-1
</code></pre>
<div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> <p>If you instead see <strong>403 Forbidden</strong> responses for the above curl command, you will need to fix the permissions of the directory mounted by the <code>volumeMounts</code> (due to a <a href="https://github.com/kubernetes/kubernetes/issues/2630">bug when using hostPath volumes</a>), by running:</p> <p><code>for i in 0 1; do kubectl exec web-$i -- chmod 755 /usr/share/nginx/html; done</code></p> <p>before retrying the <code>curl</code> command above.</p> </div> <p>In one terminal, watch the StatefulSet's Pods:</p> <pre class="highlight" data-language="shell">kubectl get pod -w -l app=nginx
</pre>
<p>In a second terminal, delete all of the StatefulSet's Pods:</p> <pre class="highlight" data-language="shell">kubectl delete pod -l app=nginx
</pre>
<pre><code>pod "web-0" deleted
pod "web-1" deleted
</code></pre>
<p>Examine the output of the <code>kubectl get</code> command in the first terminal, and wait for all of the Pods to transition to Running and Ready.</p> <pre class="highlight" data-language="shell">kubectl get pod -w -l app=nginx
</pre>
<pre><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     0/1       ContainerCreating   0          0s
NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          2s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         34s
</code></pre>
<p>Verify the web servers continue to serve their hostnames:</p> <pre><code>for i in 0 1; do kubectl exec -i -t "web-$i" -- curl http://localhost/; done
</code></pre>
<pre><code>web-0
web-1
</code></pre>
<p>Even though <code>web-0</code> and <code>web-1</code> were rescheduled, they continue to serve their hostnames because the PersistentVolumes associated with their PersistentVolumeClaims are remounted to their <code>volumeMounts</code>. No matter what node <code>web-0</code>and <code>web-1</code> are scheduled on, their PersistentVolumes will be mounted to the appropriate mount points.</p> <h2 id="scaling-a-statefulset">Scaling a StatefulSet</h2> <p>Scaling a StatefulSet refers to increasing or decreasing the number of replicas. This is accomplished by updating the <code>replicas</code> field. You can use either <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/#scale"><code>kubectl scale</code></a> or <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/#patch"><code>kubectl patch</code></a> to scale a StatefulSet.</p> <h3 id="scaling-up">Scaling Up</h3> <p>In one terminal window, watch the Pods in the StatefulSet:</p> <pre class="highlight" data-language="shell">kubectl get pods -w -l app=nginx
</pre>
<p>In another terminal window, use <code>kubectl scale</code> to scale the number of replicas to 5:</p> <pre class="highlight" data-language="shell">kubectl scale sts web --replicas=5
</pre>
<pre><code>statefulset.apps/web scaled
</code></pre>
<p>Examine the output of the <code>kubectl get</code> command in the first terminal, and wait for the three additional Pods to transition to Running and Ready.</p> <pre class="highlight" data-language="shell">kubectl get pods -w -l app=nginx
</pre>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          2h
web-1     1/1       Running   0          2h
NAME      READY     STATUS    RESTARTS   AGE
web-2     0/1       Pending   0          0s
web-2     0/1       Pending   0         0s
web-2     0/1       ContainerCreating   0         0s
web-2     1/1       Running   0         19s
web-3     0/1       Pending   0         0s
web-3     0/1       Pending   0         0s
web-3     0/1       ContainerCreating   0         0s
web-3     1/1       Running   0         18s
web-4     0/1       Pending   0         0s
web-4     0/1       Pending   0         0s
web-4     0/1       ContainerCreating   0         0s
web-4     1/1       Running   0         19s
</code></pre>
<p>The StatefulSet controller scaled the number of replicas. As with <a href="#ordered-pod-creation">StatefulSet creation</a>, the StatefulSet controller created each Pod sequentially with respect to its ordinal index, and it waited for each Pod's predecessor to be Running and Ready before launching the subsequent Pod.</p> <h3 id="scaling-down">Scaling Down</h3> <p>In one terminal, watch the StatefulSet's Pods:</p> <pre class="highlight" data-language="shell">kubectl get pods -w -l app=nginx
</pre>
<p>In another terminal, use <code>kubectl patch</code> to scale the StatefulSet back down to three replicas:</p> <pre class="highlight" data-language="shell">kubectl patch sts web -p '{"spec":{"replicas":3}}'
</pre>
<pre><code>statefulset.apps/web patched
</code></pre>
<p>Wait for <code>web-4</code> and <code>web-3</code> to transition to Terminating.</p> <pre class="highlight" data-language="shell">kubectl get pods -w -l app=nginx
</pre>
<pre><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          3h
web-1     1/1       Running             0          3h
web-2     1/1       Running             0          55s
web-3     1/1       Running             0          36s
web-4     0/1       ContainerCreating   0          18s
NAME      READY     STATUS    RESTARTS   AGE
web-4     1/1       Running   0          19s
web-4     1/1       Terminating   0         24s
web-4     1/1       Terminating   0         24s
web-3     1/1       Terminating   0         42s
web-3     1/1       Terminating   0         42s
</code></pre>
<h3 id="ordered-pod-termination">Ordered Pod Termination</h3> <p>The controller deleted one Pod at a time, in reverse order with respect to its ordinal index, and it waited for each to be completely shutdown before deleting the next.</p> <p>Get the StatefulSet's PersistentVolumeClaims:</p> <pre class="highlight" data-language="shell">kubectl get pvc -l app=nginx
</pre>
<pre><code>NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-2   Bound     pvc-e1125b27-b508-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-3   Bound     pvc-e1176df6-b508-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-4   Bound     pvc-e11bb5f8-b508-11e6-932f-42010a800002   1Gi        RWO           13h

</code></pre>
<p>There are still five PersistentVolumeClaims and five PersistentVolumes. When exploring a Pod's <a href="#writing-to-stable-storage">stable storage</a>, we saw that the PersistentVolumes mounted to the Pods of a StatefulSet are not deleted when the StatefulSet's Pods are deleted. This is still true when Pod deletion is caused by scaling the StatefulSet down.</p> <h2 id="updating-statefulsets">Updating StatefulSets</h2> <p>In Kubernetes 1.7 and later, the StatefulSet controller supports automated updates. The strategy used is determined by the <code>spec.updateStrategy</code> field of the StatefulSet API Object. This feature can be used to upgrade the container images, resource requests and/or limits, labels, and annotations of the Pods in a StatefulSet. There are two valid update strategies, <code>RollingUpdate</code> and <code>OnDelete</code>.</p> <p><code>RollingUpdate</code> update strategy is the default for StatefulSets.</p> <h3 id="rolling-update">Rolling Update</h3> <p>The <code>RollingUpdate</code> update strategy will update all Pods in a StatefulSet, in reverse ordinal order, while respecting the StatefulSet guarantees.</p> <p>Patch the <code>web</code> StatefulSet to apply the <code>RollingUpdate</code> update strategy:</p> <pre class="highlight" data-language="shell">kubectl patch statefulset web -p '{"spec":{"updateStrategy":{"type":"RollingUpdate"}}}'
</pre>
<pre><code>statefulset.apps/web patched
</code></pre>
<p>In one terminal window, patch the <code>web</code> StatefulSet to change the container image again:</p> <pre class="highlight" data-language="shell">kubectl patch statefulset web --type='json' -p='[{"op": "replace", "path": "/spec/template/spec/containers/0/image", "value":"gcr.io/google_containers/nginx-slim:0.8"}]'
</pre>
<pre><code>statefulset.apps/web patched
</code></pre>
<p>In another terminal, watch the Pods in the StatefulSet:</p> <pre class="highlight" data-language="shell">kubectl get pod -l app=nginx -w
</pre>
<p>The output is similar to:</p> <pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          7m
web-1     1/1       Running   0          7m
web-2     1/1       Running   0          8m
web-2     1/1       Terminating   0         8m
web-2     1/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Pending   0         0s
web-2     0/1       Pending   0         0s
web-2     0/1       ContainerCreating   0         0s
web-2     1/1       Running   0         19s
web-1     1/1       Terminating   0         8m
web-1     0/1       Terminating   0         8m
web-1     0/1       Terminating   0         8m
web-1     0/1       Terminating   0         8m
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         6s
web-0     1/1       Terminating   0         7m
web-0     1/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Pending   0         0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         10s
</code></pre>
<p>The Pods in the StatefulSet are updated in reverse ordinal order. The StatefulSet controller terminates each Pod, and waits for it to transition to Running and Ready prior to updating the next Pod. Note that, even though the StatefulSet controller will not proceed to update the next Pod until its ordinal successor is Running and Ready, it will restore any Pod that fails during the update to its current version.</p> <p>Pods that have already received the update will be restored to the updated version, and Pods that have not yet received the update will be restored to the previous version. In this way, the controller attempts to continue to keep the application healthy and the update consistent in the presence of intermittent failures.</p> <p>Get the Pods to view their container images:</p> <pre class="highlight" data-language="shell">for p in 0 1 2; do kubectl get pod "web-$p" --template '{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}'; echo; done
</pre>
<pre><code>k8s.gcr.io/nginx-slim:0.8
k8s.gcr.io/nginx-slim:0.8
k8s.gcr.io/nginx-slim:0.8

</code></pre>
<p>All the Pods in the StatefulSet are now running the previous container image.</p> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> You can also use <code>kubectl rollout status sts/&lt;name&gt;</code> to view the status of a rolling update to a StatefulSet </div> <h4 id="staging-an-update">Staging an Update</h4> <p>You can stage an update to a StatefulSet by using the <code>partition</code> parameter of the <code>RollingUpdate</code> update strategy. A staged update will keep all of the Pods in the StatefulSet at the current version while allowing mutations to the StatefulSet's <code>.spec.template</code>.</p> <p>Patch the <code>web</code> StatefulSet to add a partition to the <code>updateStrategy</code> field:</p> <pre class="highlight" data-language="shell">kubectl patch statefulset web -p '{"spec":{"updateStrategy":{"type":"RollingUpdate","rollingUpdate":{"partition":3}}}}'
</pre>
<pre><code>statefulset.apps/web patched
</code></pre>
<p>Patch the StatefulSet again to change the container's image:</p> <pre class="highlight" data-language="shell">kubectl patch statefulset web --type='json' -p='[{"op": "replace", "path": "/spec/template/spec/containers/0/image", "value":"k8s.gcr.io/nginx-slim:0.7"}]'
</pre>
<pre><code>statefulset.apps/web patched
</code></pre>
<p>Delete a Pod in the StatefulSet:</p> <pre class="highlight" data-language="shell">kubectl delete pod web-2
</pre>
<pre><code>pod "web-2" deleted
</code></pre>
<p>Wait for the Pod to be Running and Ready.</p> <pre class="highlight" data-language="shell">kubectl get pod -l app=nginx -w
</pre>
<pre><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          4m
web-1     1/1       Running             0          4m
web-2     0/1       ContainerCreating   0          11s
web-2     1/1       Running   0         18s
</code></pre>
<p>Get the Pod's container image:</p> <pre class="highlight" data-language="shell">kubectl get pod web-2 --template '{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}'
</pre>
<pre><code>k8s.gcr.io/nginx-slim:0.8
</code></pre>
<p>Notice that, even though the update strategy is <code>RollingUpdate</code> the StatefulSet restored the Pod with its original container. This is because the ordinal of the Pod is less than the <code>partition</code> specified by the <code>updateStrategy</code>.</p> <h4 id="rolling-out-a-canary">Rolling Out a Canary</h4> <p>You can roll out a canary to test a modification by decrementing the <code>partition</code> you specified <a href="#staging-an-update">above</a>.</p> <p>Patch the StatefulSet to decrement the partition:</p> <pre class="highlight" data-language="shell">kubectl patch statefulset web -p '{"spec":{"updateStrategy":{"type":"RollingUpdate","rollingUpdate":{"partition":2}}}}'
</pre>
<pre><code>statefulset.apps/web patched
</code></pre>
<p>Wait for <code>web-2</code> to be Running and Ready.</p> <pre class="highlight" data-language="shell">kubectl get pod -l app=nginx -w
</pre>
<pre><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          4m
web-1     1/1       Running             0          4m
web-2     0/1       ContainerCreating   0          11s
web-2     1/1       Running   0         18s
</code></pre>
<p>Get the Pod's container:</p> <pre class="highlight" data-language="shell">kubectl get pod web-2 --template '{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}'
</pre>
<pre><code>k8s.gcr.io/nginx-slim:0.7

</code></pre>
<p>When you changed the <code>partition</code>, the StatefulSet controller automatically updated the <code>web-2</code> Pod because the Pod's ordinal was greater than or equal to the <code>partition</code>.</p> <p>Delete the <code>web-1</code> Pod:</p> <pre class="highlight" data-language="shell">kubectl delete pod web-1
</pre>
<pre><code>pod "web-1" deleted
</code></pre>
<p>Wait for the <code>web-1</code> Pod to be Running and Ready.</p> <pre class="highlight" data-language="shell">kubectl get pod -l app=nginx -w
</pre>
<p>The output is similar to:</p> <pre><code>NAME      READY     STATUS        RESTARTS   AGE
web-0     1/1       Running       0          6m
web-1     0/1       Terminating   0          6m
web-2     1/1       Running       0          2m
web-1     0/1       Terminating   0         6m
web-1     0/1       Terminating   0         6m
web-1     0/1       Terminating   0         6m
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         18s
</code></pre>
<p>Get the <code>web-1</code> Pod's container image:</p> <pre class="highlight" data-language="shell">kubectl get pod web-1 --template '{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}'
</pre>
<pre><code>k8s.gcr.io/nginx-slim:0.8
</code></pre>
<p><code>web-1</code> was restored to its original configuration because the Pod's ordinal was less than the partition. When a partition is specified, all Pods with an ordinal that is greater than or equal to the partition will be updated when the StatefulSet's <code>.spec.template</code> is updated. If a Pod that has an ordinal less than the partition is deleted or otherwise terminated, it will be restored to its original configuration.</p> <h4 id="phased-roll-outs">Phased Roll Outs</h4> <p>You can perform a phased roll out (e.g. a linear, geometric, or exponential roll out) using a partitioned rolling update in a similar manner to how you rolled out a <a href="#rolling-out-a-canary">canary</a>. To perform a phased roll out, set the <code>partition</code> to the ordinal at which you want the controller to pause the update.</p> <p>The partition is currently set to <code>2</code>. Set the partition to <code>0</code>:</p> <pre class="highlight" data-language="shell">kubectl patch statefulset web -p '{"spec":{"updateStrategy":{"type":"RollingUpdate","rollingUpdate":{"partition":0}}}}'
</pre>
<pre><code>statefulset.apps/web patched
</code></pre>
<p>Wait for all of the Pods in the StatefulSet to become Running and Ready.</p> <pre class="highlight" data-language="shell">kubectl get pod -l app=nginx -w
</pre>
<p>The output is similar to:</p> <pre><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          3m
web-1     0/1       ContainerCreating   0          11s
web-2     1/1       Running             0          2m
web-1     1/1       Running   0         18s
web-0     1/1       Terminating   0         3m
web-0     1/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Pending   0         0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         3s
</code></pre>
<p>Get the container image details for the Pods in the StatefulSet:</p> <pre class="highlight" data-language="shell">for p in 0 1 2; do kubectl get pod "web-$p" --template '{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}'; echo; done
</pre>
<pre><code>k8s.gcr.io/nginx-slim:0.7
k8s.gcr.io/nginx-slim:0.7
k8s.gcr.io/nginx-slim:0.7
</code></pre>
<p>By moving the <code>partition</code> to <code>0</code>, you allowed the StatefulSet to continue the update process.</p> <h3 id="on-delete">On Delete</h3> <p>The <code>OnDelete</code> update strategy implements the legacy (1.6 and prior) behavior, When you select this update strategy, the StatefulSet controller will not automatically update Pods when a modification is made to the StatefulSet's <code>.spec.template</code> field. This strategy can be selected by setting the <code>.spec.template.updateStrategy.type</code> to <code>OnDelete</code>.</p> <h2 id="deleting-statefulsets">Deleting StatefulSets</h2> <p>StatefulSet supports both Non-Cascading and Cascading deletion. In a Non-Cascading Delete, the StatefulSet's Pods are not deleted when the StatefulSet is deleted. In a Cascading Delete, both the StatefulSet and its Pods are deleted.</p> <h3 id="non-cascading-delete">Non-Cascading Delete</h3> <p>In one terminal window, watch the Pods in the StatefulSet.</p> <pre><code>kubectl get pods -w -l app=nginx
</code></pre>
<p>Use <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/#delete"><code>kubectl delete</code></a> to delete the StatefulSet. Make sure to supply the <code>--cascade=orphan</code> parameter to the command. This parameter tells Kubernetes to only delete the StatefulSet, and to not delete any of its Pods.</p> <pre class="highlight" data-language="shell">kubectl delete statefulset web --cascade=orphan
</pre>
<pre><code>statefulset.apps "web" deleted
</code></pre>
<p>Get the Pods, to examine their status:</p> <pre class="highlight" data-language="shell">kubectl get pods -l app=nginx
</pre>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          6m
web-1     1/1       Running   0          7m
web-2     1/1       Running   0          5m
</code></pre>
<p>Even though <code>web</code> has been deleted, all of the Pods are still Running and Ready. Delete <code>web-0</code>:</p> <pre class="highlight" data-language="shell">kubectl delete pod web-0
</pre>
<pre><code>pod "web-0" deleted
</code></pre>
<p>Get the StatefulSet's Pods:</p> <pre class="highlight" data-language="shell">kubectl get pods -l app=nginx
</pre>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-1     1/1       Running   0          10m
web-2     1/1       Running   0          7m
</code></pre>
<p>As the <code>web</code> StatefulSet has been deleted, <code>web-0</code> has not been relaunched.</p> <p>In one terminal, watch the StatefulSet's Pods.</p> <pre class="highlight" data-language="shell">kubectl get pods -w -l app=nginx
</pre>
<p>In a second terminal, recreate the StatefulSet. Note that, unless you deleted the <code>nginx</code> Service (which you should not have), you will see an error indicating that the Service already exists.</p> <pre class="highlight" data-language="shell">kubectl apply -f web.yaml
</pre>
<pre><code>statefulset.apps/web created
service/nginx unchanged
</code></pre>
<p>Ignore the error. It only indicates that an attempt was made to create the <em>nginx</em> headless Service even though that Service already exists.</p> <p>Examine the output of the <code>kubectl get</code> command running in the first terminal.</p> <pre class="highlight" data-language="shell">kubectl get pods -w -l app=nginx
</pre>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-1     1/1       Running   0          16m
web-2     1/1       Running   0          2m
NAME      READY     STATUS    RESTARTS   AGE
web-0     0/1       Pending   0          0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         18s
web-2     1/1       Terminating   0         3m
web-2     0/1       Terminating   0         3m
web-2     0/1       Terminating   0         3m
web-2     0/1       Terminating   0         3m
</code></pre>
<p>When the <code>web</code> StatefulSet was recreated, it first relaunched <code>web-0</code>. Since <code>web-1</code> was already Running and Ready, when <code>web-0</code> transitioned to Running and Ready, it adopted this Pod. Since you recreated the StatefulSet with <code>replicas</code> equal to 2, once <code>web-0</code> had been recreated, and once <code>web-1</code> had been determined to already be Running and Ready, <code>web-2</code> was terminated.</p> <p>Let's take another look at the contents of the <code>index.html</code> file served by the Pods' webservers:</p> <pre class="highlight" data-language="shell">for i in 0 1; do kubectl exec -i -t "web-$i" -- curl http://localhost/; done
</pre>
<pre><code>web-0
web-1
</code></pre>
<p>Even though you deleted both the StatefulSet and the <code>web-0</code> Pod, it still serves the hostname originally entered into its <code>index.html</code> file. This is because the StatefulSet never deletes the PersistentVolumes associated with a Pod. When you recreated the StatefulSet and it relaunched <code>web-0</code>, its original PersistentVolume was remounted.</p> <h3 id="cascading-delete">Cascading Delete</h3> <p>In one terminal window, watch the Pods in the StatefulSet.</p> <pre class="highlight" data-language="shell">kubectl get pods -w -l app=nginx
</pre>
<p>In another terminal, delete the StatefulSet again. This time, omit the <code>--cascade=orphan</code> parameter.</p> <pre class="highlight" data-language="shell">kubectl delete statefulset web
</pre>
<pre><code>statefulset.apps "web" deleted
</code></pre>
<p>Examine the output of the <code>kubectl get</code> command running in the first terminal, and wait for all of the Pods to transition to Terminating.</p> <pre class="highlight" data-language="shell">kubectl get pods -w -l app=nginx
</pre>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          11m
web-1     1/1       Running   0          27m
NAME      READY     STATUS        RESTARTS   AGE
web-0     1/1       Terminating   0          12m
web-1     1/1       Terminating   0         29m
web-0     0/1       Terminating   0         12m
web-0     0/1       Terminating   0         12m
web-0     0/1       Terminating   0         12m
web-1     0/1       Terminating   0         29m
web-1     0/1       Terminating   0         29m
web-1     0/1       Terminating   0         29m

</code></pre>
<p>As you saw in the <a href="#scaling-down">Scaling Down</a> section, the Pods are terminated one at a time, with respect to the reverse order of their ordinal indices. Before terminating a Pod, the StatefulSet controller waits for the Pod's successor to be completely terminated.</p> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> Although a cascading delete removes a StatefulSet together with its Pods, the cascade does not delete the headless Service associated with the StatefulSet. You must delete the <code>nginx</code> Service manually. </div> <pre class="highlight" data-language="shell">kubectl delete service nginx
</pre>
<pre><code>service "nginx" deleted
</code></pre>
<p>Recreate the StatefulSet and headless Service one more time:</p> <pre class="highlight" data-language="shell">kubectl apply -f web.yaml
</pre>
<pre><code>service/nginx created
statefulset.apps/web created
</code></pre>
<p>When all of the StatefulSet's Pods transition to Running and Ready, retrieve the contents of their <code>index.html</code> files:</p> <pre class="highlight" data-language="shell">for i in 0 1; do kubectl exec -i -t "web-$i" -- curl http://localhost/; done
</pre>
<pre><code>web-0
web-1
</code></pre>
<p>Even though you completely deleted the StatefulSet, and all of its Pods, the Pods are recreated with their PersistentVolumes mounted, and <code>web-0</code> and <code>web-1</code> continue to serve their hostnames.</p> <p>Finally, delete the <code>nginx</code> Service...</p> <pre class="highlight" data-language="shell">kubectl delete service nginx
</pre>
<pre><code>service "nginx" deleted
</code></pre>
<p>...and the <code>web</code> StatefulSet:</p> <pre class="highlight" data-language="shell">kubectl delete statefulset web
</pre>
<pre><code>statefulset "web" deleted
</code></pre>
<h2 id="pod-management-policy">Pod Management Policy</h2> <p>For some distributed systems, the StatefulSet ordering guarantees are unnecessary and/or undesirable. These systems require only uniqueness and identity. To address this, in Kubernetes 1.7, we introduced <code>.spec.podManagementPolicy</code> to the StatefulSet API Object.</p> <h3 id="orderedready-pod-management">OrderedReady Pod Management</h3> <p><code>OrderedReady</code> pod management is the default for StatefulSets. It tells the StatefulSet controller to respect the ordering guarantees demonstrated above.</p> <h3 id="parallel-pod-management">Parallel Pod Management</h3> <p><code>Parallel</code> pod management tells the StatefulSet controller to launch or terminate all Pods in parallel, and not to wait for Pods to become Running and Ready or completely terminated prior to launching or terminating another Pod. This option only affects the behavior for scaling operations. Updates are not affected.</p> <pre class="highlight" data-language="">application/web/web-parallel.yaml</pre> <p>Download the example above, and save it to a file named <code>web-parallel.yaml</code></p> <p>This manifest is identical to the one you downloaded above except that the <code>.spec.podManagementPolicy</code> of the <code>web</code> StatefulSet is set to <code>Parallel</code>.</p> <p>In one terminal, watch the Pods in the StatefulSet.</p> <pre class="highlight" data-language="shell">kubectl get pod -l app=nginx -w
</pre>
<p>In another terminal, create the StatefulSet and Service in the manifest:</p> <pre class="highlight" data-language="shell">kubectl apply -f web-parallel.yaml
</pre>
<pre><code>service/nginx created
statefulset.apps/web created
</code></pre>
<p>Examine the output of the <code>kubectl get</code> command that you executed in the first terminal.</p> <pre class="highlight" data-language="shell">kubectl get pod -l app=nginx -w
</pre>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     0/1       Pending   0          0s
web-0     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-1     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         10s
web-1     1/1       Running   0         10s
</code></pre>
<p>The StatefulSet controller launched both <code>web-0</code> and <code>web-1</code> at the same time.</p> <p>Keep the second terminal open, and, in another terminal window scale the StatefulSet:</p> <pre class="highlight" data-language="shell">kubectl scale statefulset/web --replicas=4
</pre>
<pre><code>statefulset.apps/web scaled
</code></pre>
<p>Examine the output of the terminal where the <code>kubectl get</code> command is running.</p> <pre><code>web-3     0/1       Pending   0         0s
web-3     0/1       Pending   0         0s
web-3     0/1       Pending   0         7s
web-3     0/1       ContainerCreating   0         7s
web-2     1/1       Running   0         10s
web-3     1/1       Running   0         26s
</code></pre>
<p>The StatefulSet launched two new Pods, and it did not wait for the first to become Running and Ready prior to launching the second.</p> <h2 id="cleaning-up">Cleaning up</h2> <p>You should have two terminals open, ready for you to run <code>kubectl</code> commands as part of cleanup.</p> <pre class="highlight" data-language="shell">kubectl delete sts web
# sts is an abbreviation for statefulset
</pre>
<p>You can watch <code>kubectl get</code> to see those Pods being deleted.</p> <pre class="highlight" data-language="shell">kubectl get pod -l app=nginx -w
</pre>
<pre><code>web-3     1/1       Terminating   0         9m
web-2     1/1       Terminating   0         9m
web-3     1/1       Terminating   0         9m
web-2     1/1       Terminating   0         9m
web-1     1/1       Terminating   0         44m
web-0     1/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-3     0/1       Terminating   0         9m
web-2     0/1       Terminating   0         9m
web-1     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-2     0/1       Terminating   0         9m
web-2     0/1       Terminating   0         9m
web-2     0/1       Terminating   0         9m
web-1     0/1       Terminating   0         44m
web-1     0/1       Terminating   0         44m
web-1     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-3     0/1       Terminating   0         9m
web-3     0/1       Terminating   0         9m
web-3     0/1       Terminating   0         9m
</code></pre>
<p>During deletion, a StatefulSet removes all Pods concurrently; it does not wait for a Pod's ordinal successor to terminate prior to deleting that Pod.</p> <p>Close the terminal where the <code>kubectl get</code> command is running and delete the <code>nginx</code> Service:</p> <pre class="highlight" data-language="shell">kubectl delete svc nginx
</pre>
<div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> <p>You also need to delete the persistent storage media for the PersistentVolumes used in this tutorial.</p> <p>Follow the necessary steps, based on your environment, storage configuration, and provisioning method, to ensure that all storage is reclaimed.</p> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2022 The Kubernetes Authors<br>Documentation Distributed under CC BY 4.0.<br>
    <a href="https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/" class="_attribution-link">https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
