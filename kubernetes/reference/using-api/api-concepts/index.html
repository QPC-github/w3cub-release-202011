
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Kubernetes API Concepts - Kubernetes - W3cubDocs</title>
  
  <meta name="description" content="The Kubernetes API is a resource-based (RESTful) programmatic interface provided via HTTP. It supports retrieving, creating, updating, and deleting &hellip;">
  <meta name="keywords" content="kubernetes, api, concepts">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/kubernetes/reference/using-api/api-concepts/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-60a6449bb52e9968d95c133a29f066ffcb8dbe4f077d4022e51c991ce30bf256c8e19c508207a4193c414ffd0414826564317669b0f27f9f85c1cb21b84e097e.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/kubernetes.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/kubernetes/" class="_nav-link" title="" style="margin-left:0;">Kubernetes</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _kubernetes">
				
				
<h1>Kubernetes API Concepts</h1>  <p>The Kubernetes API is a resource-based (RESTful) programmatic interface provided via HTTP. It supports retrieving, creating, updating, and deleting primary resources via the standard HTTP verbs (POST, PUT, PATCH, DELETE, GET).</p> <p>For some resources, the API includes additional subresources that allow fine grained authorization (such as a separating viewing details for a Pod from retrieving its logs), and can accept and serve those resources in different representations for convenience or efficiency.</p> <p>Kubernetes supports efficient change notifications on resources via <em>watches</em>. Kubernetes also provides consistent list operations so that API clients can effectively cache, track, and synchronize the state of resources.</p> <p>You can view the <a href="../../kubernetes-api/index">API reference</a> online, or read on to learn about the API in general.</p>  <h2 id="standard-api-terminology">Kubernetes API terminology</h2> <p>Kubernetes generally leverages common RESTful terminology to describe the API concepts:</p> <ul> <li>A <em>resource type</em> is the name used in the URL (<code>pods</code>, <code>namespaces</code>, <code>services</code>)</li> <li>All resource types have a concrete representation (their object schema) which is called a <em>kind</em>
</li> <li>A list of instances of a resource is known as a <em>collection</em>
</li> <li>A single instance of a resource type is called a <em>resource</em>, and also usually represents an <em>object</em>
</li> <li>For some resource types, the API includes one or more <em>sub-resources</em>, which are represented as URI paths below the resource</li> </ul> <p>Most Kubernetes API resource types are <a href="../../../concepts/overview/working-with-objects/kubernetes-objects/index#kubernetes-objects">objects</a>: they represent a concrete instance of a concept on the cluster, like a pod or namespace. A smaller number of API resource types are <em>virtual</em> in that they often represent operations on objects, rather than objects, such as a permission check (use a POST with a JSON-encoded body of <code>SubjectAccessReview</code> to the <code>subjectaccessreviews</code> resource), or the <code>eviction</code> sub-resource of a Pod (used to trigger <a href="../../../concepts/scheduling-eviction/api-eviction/index">API-initiated eviction</a>).</p> <h3 id="object-names">Object names</h3> <p>All objects you can create via the API have a unique object <a class="glossary-tooltip" title="A client-provided string that refers to an object in a resource URL, such as /api/v1/pods/some-name." data-toggle="tooltip" data-placement="top" href="../../../concepts/overview/working-with-objects/names" target="_blank" aria-label="name">name</a> to allow idempotent creation and retrieval, except that virtual resource types may not have unique names if they are not retrievable, or do not rely on idempotency. Within a <a class="glossary-tooltip" title="An abstraction used by Kubernetes to support multiple virtual clusters on the same physical cluster." data-toggle="tooltip" data-placement="top" href="../../../concepts/overview/working-with-objects/namespaces" target="_blank" aria-label="namespace">namespace</a>, only one object of a given kind can have a given name at a time. However, if you delete the object, you can make a new object with the same name. Some objects are not namespaced (for example: Nodes), and so their names must be unique across the whole cluster.</p> <h3 id="api-verbs">API verbs</h3> <p>Almost all object resource types support the standard HTTP verbs - GET, POST, PUT, PATCH, and DELETE. Kubernetes also uses its own verbs, which are often written lowercase to distinguish them from HTTP verbs.</p> <p>Kubernetes uses the term <strong>list</strong> to describe returning a <a href="#collections">collection</a> of resources to distinguish from retrieving a single resource which is usually called a <strong>get</strong>. If you sent an HTTP GET request with the <code>?watch</code> query parameter, Kubernetes calls this a <strong>watch</strong> and not a <strong>get</strong> (see <a href="#efficient-detection-of-changes">Efficient detection of changes</a> for more details).</p> <p>For PUT requests, Kubernetes internally classifies these as either <strong>create</strong> or <strong>update</strong> based on the state of the existing object. An <strong>update</strong> is different from a <strong>patch</strong>; the HTTP verb for a <strong>patch</strong> is PATCH.</p> <h2 id="resource-uris">Resource URIs</h2> <p>All resource types are either scoped by the cluster (<code>/apis/GROUP/VERSION/*</code>) or to a namespace (<code>/apis/GROUP/VERSION/namespaces/NAMESPACE/*</code>). A namespace-scoped resource type will be deleted when its namespace is deleted and access to that resource type is controlled by authorization checks on the namespace scope.</p> <p>You can also access collections of resources (for example: listing all Nodes). The following paths are used to retrieve collections and resources:</p> <ul> <li> <p>Cluster-scoped resources:</p> <ul> <li>
<code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - return the collection of resources of the resource type</li> <li>
<code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME</code> - return the resource with NAME under the resource type</li> </ul> </li> <li> <p>Namespace-scoped resources:</p> <ul> <li>
<code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - return the collection of all instances of the resource type across all namespaces</li> <li>
<code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE</code> - return collection of all instances of the resource type in NAMESPACE</li> <li>
<code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME</code> - return the instance of the resource type with NAME in NAMESPACE</li> </ul> </li> </ul> <p>Since a namespace is a cluster-scoped resource type, you can retrieve the list (“collection”) of all namespaces with <code>GET /api/v1/namespaces</code> and details about a particular namespace with <code>GET /api/v1/namespaces/NAME</code>.</p> <ul> <li>Cluster-scoped subresource: <code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE</code>
</li> <li>Namespace-scoped subresource: <code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE</code>
</li> </ul> <p>The verbs supported for each subresource will differ depending on the object - see the <a href="../../kubernetes-api/index">API reference</a> for more information. It is not possible to access sub-resources across multiple resources - generally a new virtual resource type would be used if that becomes necessary.</p> <h2 id="efficient-detection-of-changes">Efficient detection of changes</h2> <p>The Kubernetes API allows clients to make an initial request for an object or a collection, and then to track changes since that initial request: a <strong>watch</strong>. Clients can send a <strong>list</strong> or a <strong>get</strong> and then make a follow-up <strong>watch</strong> request.</p> <p>To make this change tracking possible, every Kubernetes object has a <code>resourceVersion</code> field representing the version of that resource as stored in the underlying persistence layer. When retrieving a collection of resources (either namespace or cluster scoped), the response from the API server contains a <code>resourceVersion</code> value. The client can use that <code>resourceVersion</code> to initiate a <strong>watch</strong> against the API server.</p> <p>When you send a <strong>watch</strong> request, the API server responds with a stream of changes. These changes itemize the outcome of operations (such as <strong>create</strong>, <strong>delete</strong>, and <strong>update</strong>) that occurred after the <code>resourceVersion</code> you specified as a parameter to the <strong>watch</strong> request. The overall <strong>watch</strong> mechanism allows a client to fetch the current state and then subscribe to subsequent changes, without missing any events.</p> <p>If a client <strong>watch</strong> is disconnected then that client can start a new <strong>watch</strong> from the last returned <code>resourceVersion</code>; the client could also perform a fresh <strong>get</strong> / <strong>list</strong> request and begin again. See <a href="#resource-versions">Resource Version Semantics</a> for more detail.</p> <p>For example:</p> <ol> <li> <p>List all of the pods in a given namespace.</p> <pre><code class="language-console" data-lang="console">GET /api/v1/namespaces/test/pods
---
200 OK
Content-Type: application/json

{
  "kind": "PodList",
  "apiVersion": "v1",
  "metadata": {"resourceVersion":"10245"},
  "items": [...]
}
</code></pre>
</li> <li> <p>Starting from resource version 10245, receive notifications of any API operations (such as <strong>create</strong>, <strong>delete</strong>, <strong>apply</strong> or <strong>update</strong>) that affect Pods in the <em>test</em> namespace. Each change notification is a JSON document. The HTTP response body (served as <code>application/json</code>) consists a series of JSON documents.</p> <pre><code>GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  "type": "ADDED",
  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "10596", ...}, ...}
}
{
  "type": "MODIFIED",
  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "11020", ...}, ...}
}
...
</code></pre>
</li> </ol> <p>A given Kubernetes server will only preserve a historical record of changes for a limited time. Clusters using etcd 3 preserve changes in the last 5 minutes by default. When the requested <strong>watch</strong> operations fail because the historical version of that resource is not available, clients must handle the case by recognizing the status code <code>410 Gone</code>, clearing their local cache, performing a new <strong>get</strong> or <strong>list</strong> operation, and starting the <strong>watch</strong> from the <code>resourceVersion</code> that was returned.</p> <p>For subscribing to collections, Kubernetes client libraries typically offer some form of standard tool for this <strong>list</strong>-then-<strong>watch</strong> logic. (In the Go client library, this is called a <code>Reflector</code> and is located in the <code>k8s.io/client-go/cache</code> package.)</p> <h3 id="watch-bookmarks">Watch bookmarks</h3> <p>To mitigate the impact of short history window, the Kubernetes API provides a watch event named <code>BOOKMARK</code>. It is a special kind of event to mark that all changes up to a given <code>resourceVersion</code> the client is requesting have already been sent. The document representing the <code>BOOKMARK</code> event is of the type requested by the request, but only includes a <code>.metadata.resourceVersion</code> field. For example:</p> <pre><code class="language-console" data-lang="console">GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245&amp;allowWatchBookmarks=true
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  "type": "ADDED",
  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "10596", ...}, ...}
}
...
{
  "type": "BOOKMARK",
  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "12746"} }
}
</code></pre>
<p>As a client, you can request <code>BOOKMARK</code> events by setting the <code>allowWatchBookmarks=true</code> query parameter to a <strong>watch</strong> request, but you shouldn't assume bookmarks are returned at any specific interval, nor can clients assume that the API server will send any <code>BOOKMARK</code> event even when requested.</p> <h2 id="retrieving-large-results-sets-in-chunks">Retrieving large results sets in chunks</h2> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.9 [beta]</code> </div> <p>On large clusters, retrieving the collection of some resource types may result in very large responses that can impact the server and client. For instance, a cluster may have tens of thousands of Pods, each of which is equivalent to roughly 2 KiB of encoded JSON. Retrieving all pods across all namespaces may result in a very large response (10-20MB) and consume a large amount of server resources.</p> <p>Provided that you don't explicitly disable the <code>APIListChunking</code> <a href="../../command-line-tools-reference/feature-gates/index">feature gate</a>, the Kubernetes API server supports the ability to break a single large collection request into many smaller chunks while preserving the consistency of the total request. Each chunk can be returned sequentially which reduces both the total size of the request and allows user-oriented clients to display results incrementally to improve responsiveness.</p> <p>You can request that the API server handles a <strong>list</strong> by serving single collection using pages (which Kubernetes calls <em>chunks</em>). To retrieve a single collection in chunks, two query parameters <code>limit</code> and <code>continue</code> are supported on requests against collections, and a response field <code>continue</code> is returned from all <strong>list</strong> operations in the collection's <code>metadata</code> field. A client should specify the maximum results they wish to receive in each chunk with <code>limit</code> and the server will return up to <code>limit</code> resources in the result and include a <code>continue</code> value if there are more resources in the collection.</p> <p>As an API client, you can then pass this <code>continue</code> value to the API server on the next request, to instruct the server to return the next page (<em>chunk</em>) of results. By continuing until the server returns an empty <code>continue</code> value, you can retrieve the entire collection.</p> <p>Like a <strong>watch</strong> operation, a <code>continue</code> token will expire after a short amount of time (by default 5 minutes) and return a <code>410 Gone</code> if more results cannot be returned. In this case, the client will need to start from the beginning or omit the <code>limit</code> parameter.</p> <p>For example, if there are 1,253 pods on the cluster and you wants to receive chunks of 500 pods at a time, request those chunks as follows:</p> <ol> <li> <p>List all of the pods on a cluster, retrieving up to 500 pods each time.</p> <pre><code class="language-console" data-lang="console">GET /api/v1/pods?limit=500
---
200 OK
Content-Type: application/json

{
  "kind": "PodList",
  "apiVersion": "v1",
  "metadata": {
    "resourceVersion":"10245",
    "continue": "ENCODED_CONTINUE_TOKEN",
    ...
  },
  "items": [...] // returns pods 1-500
}
</code></pre>
</li> <li> <p>Continue the previous call, retrieving the next set of 500 pods.</p> <pre><code class="language-console" data-lang="console">GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN
---
200 OK
Content-Type: application/json

{
  "kind": "PodList",
  "apiVersion": "v1",
  "metadata": {
    "resourceVersion":"10245",
    "continue": "ENCODED_CONTINUE_TOKEN_2",
    ...
  },
  "items": [...] // returns pods 501-1000
}
</code></pre>
</li> <li> <p>Continue the previous call, retrieving the last 253 pods.</p> <pre><code class="language-console" data-lang="console">GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN_2
---
200 OK
Content-Type: application/json

{
  "kind": "PodList",
  "apiVersion": "v1",
  "metadata": {
    "resourceVersion":"10245",
    "continue": "", // continue token is empty because we have reached the end of the list
    ...
  },
  "items": [...] // returns pods 1001-1253
}
</code></pre>
</li> </ol> <p>Notice that the <code>resourceVersion</code> of the collection remains constant across each request, indicating the server is showing you a consistent snapshot of the pods. Pods that are created, updated, or deleted after version <code>10245</code> would not be shown unless you make a separate <strong>list</strong> request without the <code>continue</code> token. This allows you to break large requests into smaller chunks and then perform a <strong>watch</strong> operation on the full set without missing any updates.</p> <p><code>remainingItemCount</code> is the number of subsequent items in the collection that are not included in this response. If the <strong>list</strong> request contained label or field <a class="glossary-tooltip" title="Allows users to filter a list of resources based on labels." data-toggle="tooltip" data-placement="top" href="../../../concepts/overview/working-with-objects/labels/index" target="_blank" aria-label="selectors">selectors</a> then the number of remaining items is unknown and the API server does not include a <code>remainingItemCount</code> field in its response. If the <strong>list</strong> is complete (either because it is not chunking, or because this is the last chunk), then there are no more remaining items and the API server does not include a <code>remainingItemCount</code> field in its response. The intended use of the <code>remainingItemCount</code> is estimating the size of a collection.</p> <h2 id="collections">Collections</h2> <p>In Kubernetes terminology, the response you get from a <strong>list</strong> is a <em>collection</em>. However, Kubernetes defines concrete kinds for collections of different types of resource. Collections have a kind named for the resource kind, with <code>List</code> appended.</p> <p>When you query the API for a particular type, all items returned by that query are of that type. For example, when you <strong>list</strong> Services, the collection response has <code>kind</code> set to <a href="../../kubernetes-api/service-resources/service-v1/index#ServiceList"><code>ServiceList</code></a>; each item in that collection represents a single Service. For example:</p> <pre><code>GET /api/v1/services
</code></pre>
<pre class="highlight" data-language="yaml">{
  "kind": "ServiceList",
  "apiVersion": "v1",
  "metadata": {
    "resourceVersion": "2947301"
  },
  "items": [
    {
      "metadata": {
        "name": "kubernetes",
        "namespace": "default",
...
      "metadata": {
        "name": "kube-dns",
        "namespace": "kube-system",
...
</pre>
<p>There are dozens of collection types (such as <code>PodList</code>, <code>ServiceList</code>, and <code>NodeList</code>) defined in the Kubernetes API. You can get more information about each collection type from the <a href="../../kubernetes-api/index">Kubernetes API</a> documentation.</p> <p>Some tools, such as <code>kubectl</code>, represent the Kubernetes collection mechanism slightly differently from the Kubernetes API itself. Because the output of <code>kubectl</code> might include the response from multiple <strong>list</strong> operations at the API level, <code>kubectl</code> represents a list of items using <code>kind: List</code>. For example:</p> <pre class="highlight" data-language="shell">kubectl get services -A -o yaml
</pre>
<pre class="highlight" data-language="yaml">apiVersion: v1
kind: List
metadata:
  resourceVersion: ""
  selfLink: ""
items:
- apiVersion: v1
  kind: Service
  metadata:
    creationTimestamp: "2021-06-03T14:54:12Z"
    labels:
      component: apiserver
      provider: kubernetes
    name: kubernetes
    namespace: default
...
- apiVersion: v1
  kind: Service
  metadata:
    annotations:
      prometheus.io/port: "9153"
      prometheus.io/scrape: "true"
    creationTimestamp: "2021-06-03T14:54:14Z"
    labels:
      k8s-app: kube-dns
      kubernetes.io/cluster-service: "true"
      kubernetes.io/name: CoreDNS
    name: kube-dns
    namespace: kube-system
</pre>
<div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> <p>Keep in mind that the Kubernetes API does not have a <code>kind</code> named <code>List</code>.</p> <p><code>kind: List</code> is a client-side, internal implementation detail for processing collections that might be of different kinds of object. Avoid depending on <code>kind: List</code> in automation or other code.</p> </div> <h2 id="receiving-resources-as-tables">Receiving resources as Tables</h2> <p>When you run <code>kubectl get</code>, the default output format is a simple tabular representation of one or more instances of a particular resource type. In the past, clients were required to reproduce the tabular and describe output implemented in <code>kubectl</code> to perform simple lists of objects. A few limitations of that approach include non-trivial logic when dealing with certain objects. Additionally, types provided by API aggregation or third party resources are not known at compile time. This means that generic implementations had to be in place for types unrecognized by a client.</p> <p>In order to avoid potential limitations as described above, clients may request the Table representation of objects, delegating specific details of printing to the server. The Kubernetes API implements standard HTTP content type negotiation: passing an <code>Accept</code> header containing a value of <code>application/json;as=Table;g=meta.k8s.io;v=v1</code> with a <code>GET</code> call will request that the server return objects in the Table content type.</p> <p>For example, list all of the pods on a cluster in the Table format.</p> <pre><code class="language-console" data-lang="console">GET /api/v1/pods
Accept: application/json;as=Table;g=meta.k8s.io;v=v1
---
200 OK
Content-Type: application/json

{
    "kind": "Table",
    "apiVersion": "meta.k8s.io/v1",
    ...
    "columnDefinitions": [
        ...
    ]
}
</code></pre>
<p>For API resource types that do not have a custom Table definition known to the control plane, the API server returns a default Table response that consists of the resource's <code>name</code> and <code>creationTimestamp</code> fields.</p> <pre><code class="language-console" data-lang="console">GET /apis/crd.example.com/v1alpha1/namespaces/default/resources
---
200 OK
Content-Type: application/json
...

{
    "kind": "Table",
    "apiVersion": "meta.k8s.io/v1",
    ...
    "columnDefinitions": [
        {
            "name": "Name",
            "type": "string",
            ...
        },
        {
            "name": "Created At",
            "type": "date",
            ...
        }
    ]
}
</code></pre>
<p>Not all API resource types support a Table response; for example, a <a class="glossary-tooltip" title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle="tooltip" data-placement="top" href="../../../tasks/extend-kubernetes/custom-resources/custom-resource-definitions/index" target="_blank" aria-label="CustomResourceDefinitions">CustomResourceDefinitions</a> might not define field-to-table mappings, and an APIService that <a href="../../../concepts/extend-kubernetes/api-extension/apiserver-aggregation/index">extends the core Kubernetes API</a> might not serve Table responses at all. If you are implementing a client that uses the Table information and must work against all resource types, including extensions, you should make requests that specify multiple content types in the <code>Accept</code> header. For example:</p> <pre><code class="language-console" data-lang="console">Accept: application/json;as=Table;g=meta.k8s.io;v=v1, application/json
</code></pre>
<h2 id="alternate-representations-of-resources">Alternate representations of resources</h2> <p>By default, Kubernetes returns objects serialized to JSON with content type <code>application/json</code>. This is the default serialization format for the API. However, clients may request the more efficient <a href="#protobuf-encoding">Protobuf representation</a> of these objects for better performance at scale. The Kubernetes API implements standard HTTP content type negotiation: passing an <code>Accept</code> header with a <code>GET</code> call will request that the server tries to return a response in your preferred media type, while sending an object in Protobuf to the server for a <code>PUT</code> or <code>POST</code> call means that you must set the <code>Content-Type</code> header appropriately.</p> <p>The server will return a response with a <code>Content-Type</code> header if the requested format is supported, or the <code>406 Not acceptable</code> error if none of the media types you requested are supported. All built-in resource types support the <code>application/json</code> media type.</p> <p>See the Kubernetes <a href="../../kubernetes-api/index">API reference</a> for a list of supported content types for each API.</p> <p>For example:</p> <ol> <li> <p>List all of the pods on a cluster in Protobuf format.</p> <pre><code class="language-console" data-lang="console">GET /api/v1/pods
Accept: application/vnd.kubernetes.protobuf
---
200 OK
Content-Type: application/vnd.kubernetes.protobuf

... binary encoded PodList object
</code></pre>
</li> <li> <p>Create a pod by sending Protobuf encoded data to the server, but request a response in JSON.</p> <pre><code class="language-console" data-lang="console">POST /api/v1/namespaces/test/pods
Content-Type: application/vnd.kubernetes.protobuf
Accept: application/json
... binary encoded Pod object
---
200 OK
Content-Type: application/json

{
  "kind": "Pod",
  "apiVersion": "v1",
  ...
}
</code></pre>
</li> </ol> <p>Not all API resource types support Protobuf; specifically, Protobuf isn't available for resources that are defined as <a class="glossary-tooltip" title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle="tooltip" data-placement="top" href="../../../tasks/extend-kubernetes/custom-resources/custom-resource-definitions/index" target="_blank" aria-label="CustomResourceDefinitions">CustomResourceDefinitions</a> or are served via the <a class="glossary-tooltip" title="The aggregation layer lets you install additional Kubernetes-style APIs in your cluster." data-toggle="tooltip" data-placement="top" href="../../../concepts/extend-kubernetes/api-extension/apiserver-aggregation/index" target="_blank" aria-label="aggregation layer">aggregation layer</a>. As a client, if you might need to work with extension types you should specify multiple content types in the request <code>Accept</code> header to support fallback to JSON. For example:</p> <pre><code class="language-console" data-lang="console">Accept: application/vnd.kubernetes.protobuf, application/json
</code></pre>
<h3 id="protobuf-encoding">Kubernetes Protobuf encoding</h3> <p>Kubernetes uses an envelope wrapper to encode Protobuf responses. That wrapper starts with a 4 byte magic number to help identify content in disk or in etcd as Protobuf (as opposed to JSON), and then is followed by a Protobuf encoded wrapper message, which describes the encoding and type of the underlying object and then contains the object.</p> <p>The wrapper format is:</p> <pre><code class="language-console" data-lang="console">A four byte magic number prefix:
  Bytes 0-3: "k8s\x00" [0x6b, 0x38, 0x73, 0x00]

An encoded Protobuf message with the following IDL:
  message Unknown {
    // typeMeta should have the string values for "kind" and "apiVersion" as set on the JSON object
    optional TypeMeta typeMeta = 1;

    // raw will hold the complete serialized object in protobuf. See the protobuf definitions in the client libraries for a given kind.
    optional bytes raw = 2;

    // contentEncoding is encoding used for the raw data. Unspecified means no encoding.
    optional string contentEncoding = 3;

    // contentType is the serialization method used to serialize 'raw'. Unspecified means application/vnd.kubernetes.protobuf and is usually
    // omitted.
    optional string contentType = 4;
  }

  message TypeMeta {
    // apiVersion is the group/version for this type
    optional string apiVersion = 1;
    // kind is the name of the object schema. A protobuf definition should exist for this object.
    optional string kind = 2;
  }
</code></pre>
<div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> Clients that receive a response in <code>application/vnd.kubernetes.protobuf</code> that does not match the expected prefix should reject the response, as future versions may need to alter the serialization format in an incompatible way and will do so by changing the prefix. </div> <h2 id="resource-deletion">Resource deletion</h2> <p>When you <strong>delete</strong> a resource this takes place in two phases.</p> <ol> <li><em>finalization</em></li> <li>removal</li> </ol> <pre class="highlight" data-language="yaml">{
  "kind": "ConfigMap",
  "apiVersion": "v1",
  "metadata": {
    "finalizers": {"url.io/neat-finalization", "other-url.io/my-finalizer"},
    "deletionTimestamp": nil,
  }
}
</pre>
<p>When a client first sends a <strong>delete</strong> to request removal of a resource, the <code>.metadata.deletionTimestamp</code> is set to the current time. Once the <code>.metadata.deletionTimestamp</code> is set, external controllers that act on finalizers may start performing their cleanup work at any time, in any order.</p> <p>Order is <strong>not</strong> enforced between finalizers because it would introduce significant risk of stuck <code>.metadata.finalizers</code>.</p> <p>The <code>.metadata.finalizers</code> field is shared: any actor with permission can reorder it. If the finalizer list were processed in order, then this might lead to a situation in which the component responsible for the first finalizer in the list is waiting for some signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock.</p> <p>Without enforced ordering, finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.</p> <p>Once the last finalizer is removed, the resource is actually removed from etcd.</p> <h2 id="single-resource-api">Single resource API</h2> <p>The Kubernetes API verbs <strong>get</strong>, <strong>create</strong>, <strong>apply</strong>, <strong>update</strong>, <strong>patch</strong>, <strong>delete</strong> and <strong>proxy</strong> support single resources only. These verbs with single resource support have no support for submitting multiple resources together in an ordered or unordered list or transaction.</p> <p>When clients (including kubectl) act on a set of resources, the client makes a series of single-resource API requests, then aggregates the responses if needed.</p> <p>By contrast, the Kubernetes API verbs <strong>list</strong> and <strong>watch</strong> allow getting multiple resources, and <strong>deletecollection</strong> allows deleting multiple resources.</p> <h2 id="dry-run">Dry-run</h2> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code> </div> <p>When you use HTTP verbs that can modify resources (<code>POST</code>, <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code>), you can submit your request in a <em>dry run</em> mode. Dry run mode helps to evaluate a request through the typical request stages (admission chain, validation, merge conflicts) up until persisting objects to storage. The response body for the request is as close as possible to a non-dry-run response. Kubernetes guarantees that dry-run requests will not be persisted in storage or have any other side effects.</p> <h3 id="make-a-dry-run-request">Make a dry-run request</h3> <p>Dry-run is triggered by setting the <code>dryRun</code> query parameter. This parameter is a string, working as an enum, and the only accepted values are:</p> <dl> <dt>[no value set]</dt> <dd>Allow side effects. You request this with a query string such as <code>?dryRun</code> or <code>?dryRun&amp;pretty=true</code>. The response is the final object that would have been persisted, or an error if the request could not be fulfilled.</dd> <dt><code>All</code></dt> <dd>Every stage runs as normal, except for the final storage stage where side effects are prevented.</dd> </dl> <p>When you set <code>?dryRun=All</code>, any relevant <a class="glossary-tooltip" title="A piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object." data-toggle="tooltip" data-placement="top" href="../../access-authn-authz/admission-controllers/index" target="_blank" aria-label="admission controllers">admission controllers</a> are run, validating admission controllers check the request post-mutation, merge is performed on <code>PATCH</code>, fields are defaulted, and schema validation occurs. The changes are not persisted to the underlying storage, but the final object which would have been persisted is still returned to the user, along with the normal status code.</p> <p>If the non-dry-run version of a request would trigger an admission controller that has side effects, the request will be failed rather than risk an unwanted side effect. All built in admission control plugins support dry-run. Additionally, admission webhooks can declare in their <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#webhook-v1beta1-admissionregistration-k8s-io">configuration object</a> that they do not have side effects, by setting their <code>sideEffects</code> field to <code>None</code>.</p> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> If a webhook actually does have side effects, then the <code>sideEffects</code> field should be set to "NoneOnDryRun". That change is appropriate provided that the webhook is also be modified to understand the <code>DryRun</code> field in AdmissionReview, and to prevent side effects on any request marked as dry runs. </div> <p>Here is an example dry-run request that uses <code>?dryRun=All</code>:</p> <pre><code class="language-console" data-lang="console">POST /api/v1/namespaces/test/pods?dryRun=All
Content-Type: application/json
Accept: application/json
</code></pre>
<p>The response would look the same as for non-dry-run request, but the values of some generated fields may differ.</p> <h3 id="generated-values">Generated values</h3> <p>Some values of an object are typically generated before the object is persisted. It is important not to rely upon the values of these fields set by a dry-run request, since these values will likely be different in dry-run mode from when the real request is made. Some of these fields are:</p> <ul> <li>
<code>name</code>: if <code>generateName</code> is set, <code>name</code> will have a unique random name</li> <li>
<code>creationTimestamp</code> / <code>deletionTimestamp</code>: records the time of creation/deletion</li> <li>
<code>UID</code>: <a href="../../../concepts/overview/working-with-objects/names/index#uids">uniquely identifies</a> the object and is randomly generated (non-deterministic)</li> <li>
<code>resourceVersion</code>: tracks the persisted version of the object</li> <li>Any field set by a mutating admission controller</li> <li>For the <code>Service</code> resource: Ports or IP addresses that the kube-apiserver assigns to Service objects</li> </ul> <h3 id="dry-run-authorization">Dry-run authorization</h3> <p>Authorization for dry-run and non-dry-run requests is identical. Thus, to make a dry-run request, you must be authorized to make the non-dry-run request.</p> <p>For example, to run a dry-run <strong>patch</strong> for a Deployment, you must be authorized to perform that <strong>patch</strong>. Here is an example of a rule for Kubernetes <a class="glossary-tooltip" title="Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API." data-toggle="tooltip" data-placement="top" href="../../access-authn-authz/rbac/index" target="_blank" aria-label="RBAC">RBAC</a> that allows patching Deployments:</p> <pre class="highlight" data-language="yaml">rules:
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["patch"]
</pre>
<p>See <a href="../../access-authn-authz/authorization/index">Authorization Overview</a>.</p> <h2 id="server-side-apply">Server Side Apply</h2> <p>Kubernetes' <a href="../server-side-apply/index">Server Side Apply</a> feature allows the control plane to track managed fields for newly created objects. Server Side Apply provides a clear pattern for managing field conflicts, offers server-side <code>Apply</code> and <code>Update</code> operations, and replaces the client-side functionality of <code>kubectl apply</code>.</p> <p>The API verb for Server-Side Apply is <strong>apply</strong>. See <a href="../server-side-apply/index">Server Side Apply</a> for more details.</p> <h2 id="resource-versions">Resource versions</h2> <p>Resource versions are strings that identify the server's internal version of an object. Resource versions can be used by clients to determine when objects have changed, or to express data consistency requirements when getting, listing and watching resources. Resource versions must be treated as opaque by clients and passed unmodified back to the server.</p> <p>You must not assume resource versions are numeric or collatable. API clients may only compare two resource versions for equality (this means that you must not compare resource versions for greater-than or less-than relationships).</p> <h3 id="resourceversion-in-metadata">
<code>resourceVersion</code> fields in metadata</h3> <p>Clients find resource versions in resources, including the resources from the response stream for a <strong>watch</strong>, or when using <strong>list</strong> to enumerate resources.</p> <p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#objectmeta-v1-meta">v1.meta/ObjectMeta</a> - The <code>metadata.resourceVersion</code> of a resource instance identifies the resource version the instance was last modified at.</p> <p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#listmeta-v1-meta">v1.meta/ListMeta</a> - The <code>metadata.resourceVersion</code> of a resource collection (the response to a <strong>list</strong>) identifies the resource version at which the collection was constructed.</p> <h3 id="the-resourceversion-parameter">
<code>resourceVersion</code> parameters in query strings</h3> <p>The <strong>get</strong>, <strong>list</strong>, and <strong>watch</strong> operations support the <code>resourceVersion</code> parameter. From version v1.19, Kubernetes API servers also support the <code>resourceVersionMatch</code> parameter on <em>list</em> requests.</p> <p>The API server interprets the <code>resourceVersion</code> parameter differently depending on the operation you request, and on the value of <code>resourceVersion</code>. If you set <code>resourceVersionMatch</code> then this also affects the way matching happens.</p> <h3 id="semantics-for-get-and-list">Semantics for <strong>get</strong> and <strong>list</strong>
</h3> <p>For <strong>get</strong> and <strong>list</strong>, the semantics of <code>resourceVersion</code> are:</p> <p><strong>get:</strong></p> <table> <thead> <tr> <th>resourceVersion unset</th> <th>resourceVersion="0"</th> <th>resourceVersion="{value other than 0}"</th> </tr> </thead> <tbody> <tr> <td>Most Recent</td> <td>Any</td> <td>Not older than</td> </tr> </tbody> </table> <p><strong>list:</strong></p> <p>From version v1.19, Kubernetes API servers support the <code>resourceVersionMatch</code> parameter on <em>list</em> requests. If you set both <code>resourceVersion</code> and <code>resourceVersionMatch</code>, the <code>resourceVersionMatch</code> parameter determines how the API server interprets <code>resourceVersion</code>.</p> <p>You should always set the <code>resourceVersionMatch</code> parameter when setting <code>resourceVersion</code> on a <strong>list</strong> request. However, be prepared to handle the case where the API server that responds is unaware of <code>resourceVersionMatch</code> and ignores it.</p> <p>Unless you have strong consistency requirements, using <code>resourceVersionMatch=NotOlderThan</code> and a known <code>resourceVersion</code> is preferable since it can achieve better performance and scalability of your cluster than leaving <code>resourceVersion</code> and <code>resourceVersionMatch</code> unset, which requires quorum read to be served.</p> <p>Setting the <code>resourceVersionMatch</code> parameter without setting <code>resourceVersion</code> is not valid.</p> <p>This table explains the behavior of <strong>list</strong> requests with various combinations of <code>resourceVersion</code> and <code>resourceVersionMatch</code>:</p> <table>
<caption style="display: none;">resourceVersionMatch and paging parameters for list</caption> <thead> <tr> <th>resourceVersionMatch param</th> <th>paging params</th> <th>resourceVersion not set</th> <th>resourceVersion="0"</th> <th>resourceVersion="{value other than 0}"</th> </tr> </thead> <tbody> <tr> <td><em>unset</em></td> <td><em>limit unset</em></td> <td>Most Recent</td> <td>Any</td> <td>Not older than</td> </tr> <tr> <td><em>unset</em></td> <td>limit=&lt;n&gt;, <em>continue unset</em>
</td> <td>Most Recent</td> <td>Any</td> <td>Exact</td> </tr> <tr> <td><em>unset</em></td> <td>limit=&lt;n&gt;, continue=&lt;token&gt;</td> <td>Continue Token, Exact</td> <td>Invalid, treated as Continue Token, Exact</td> <td>Invalid, HTTP <code>400 Bad Request</code>
</td> </tr> <tr> <td><code>resourceVersionMatch=Exact</code></td> <td><em>limit unset</em></td> <td>Invalid</td> <td>Invalid</td> <td>Exact</td> </tr> <tr> <td><code>resourceVersionMatch=Exact</code></td> <td>limit=&lt;n&gt;, <em>continue unset</em>
</td> <td>Invalid</td> <td>Invalid</td> <td>Exact</td> </tr> <tr> <td><code>resourceVersionMatch=NotOlderThan</code></td> <td><em>limit unset</em></td> <td>Invalid</td> <td>Any</td> <td>Not older than</td> </tr> <tr> <td><code>resourceVersionMatch=NotOlderThan</code></td> <td>limit=&lt;n&gt;, <em>continue unset</em>
</td> <td>Invalid</td> <td>Any</td> <td>Not older than</td> </tr> </tbody> </table> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> If your cluster's API server does not honor the <code>resourceVersionMatch</code> parameter, the behavior is the same as if you did not set it. </div> <p>The meaning of the <strong>get</strong> and <strong>list</strong> semantics are:</p> <dl> <dt>Any</dt> <dd>Return data at any resource version. The newest available resource version is preferred, but strong consistency is not required; data at any resource version may be served. It is possible for the request to return data at a much older resource version that the client has previously observed, particularly in high availability configurations, due to partitions or stale caches. Clients that cannot tolerate this should not use this semantic.</dd> <dt>Most recent</dt> <dd>Return data at the most recent resource version. The returned data must be consistent (in detail: served from etcd via a quorum read).</dd> <dt>Not older than</dt> <dd>Return data at least as new as the provided <code>resourceVersion</code>. The newest available data is preferred, but any data not older than the provided <code>resourceVersion</code> may be served. For <strong>list</strong> requests to servers that honor the <code>resourceVersionMatch</code> parameter, this guarantees that the collection's <code>.metadata.resourceVersion</code> is not older than the requested <code>resourceVersion</code>, but does not make any guarantee about the <code>.metadata.resourceVersion</code> of any of the items in that collection.</dd> <dt>Exact</dt> <dd>Return data at the exact resource version provided. If the provided <code>resourceVersion</code> is unavailable, the server responds with HTTP 410 "Gone". For <strong>list</strong> requests to servers that honor the <code>resourceVersionMatch</code> parameter, this guarantees that the collection's <code>.metadata.resourceVersion</code> is the same as the <code>resourceVersion</code> you requested in the query string. That guarantee does not apply to the <code>.metadata.resourceVersion</code> of any items within that collection.</dd> <dt>Continue Token, Exact</dt> <dd>Return data at the resource version of the initial paginated <strong>list</strong> call. The returned <em>continue tokens</em> are responsible for keeping track of the initially provided resource version for all paginated <strong>list</strong> calls after the initial paginated <strong>list</strong>.</dd> </dl> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> When you <strong>list</strong> resources and receive a collection response, the response includes the <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#listmeta-v1-meta">metadata</a> of the collection as well as <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#listmeta-v1-meta">object metadata</a> for each item in that collection. For individual objects found within a collection response, <code>.metadata.resourceVersion</code> tracks when that object was last updated, and not how up-to-date the object is when served. </div> <p>When using <code>resourceVersionMatch=NotOlderThan</code> and limit is set, clients must handle HTTP 410 "Gone" responses. For example, the client might retry with a newer <code>resourceVersion</code> or fall back to <code>resourceVersion=""</code>.</p> <p>When using <code>resourceVersionMatch=Exact</code> and <code>limit</code> is unset, clients must verify that the collection's <code>.metadata.resourceVersion</code> matches the requested <code>resourceVersion</code>, and handle the case where it does not. For example, the client might fall back to a request with <code>limit</code> set.</p> <h3 id="semantics-for-watch">Semantics for <strong>watch</strong>
</h3> <p>For <strong>watch</strong>, the semantics of resource version are:</p> <p><strong>watch:</strong></p> <table>
<caption style="display: none;">resourceVersion for watch</caption> <thead> <tr> <th>resourceVersion unset</th> <th>resourceVersion="0"</th> <th>resourceVersion="{value other than 0}"</th> </tr> </thead> <tbody> <tr> <td>Get State and Start at Most Recent</td> <td>Get State and Start at Any</td> <td>Start at Exact</td> </tr> </tbody> </table> <p>The meaning of those <strong>watch</strong> semantics are:</p> <dl> <dt>Get State and Start at Any</dt> <dd>
<div class="alert alert-warning caution callout" role="alert"> <strong>Caution:</strong> Watches initialized this way may return arbitrarily stale data. Please review this semantic before using it, and favor the other semantics where possible. </div> Start a <strong>watch</strong> at any resource version; the most recent resource version available is preferred, but not required. Any starting resource version is allowed. It is possible for the <strong>watch</strong> to start at a much older resource version that the client has previously observed, particularly in high availability configurations, due to partitions or stale caches. Clients that cannot tolerate this apparent rewinding should not start a <strong>watch</strong> with this semantic. To establish initial state, the <strong>watch</strong> begins with synthetic "Added" events for all resource instances that exist at the starting resource version. All following watch events are for all changes that occurred after the resource version the <strong>watch</strong> started at.</dd> <dt>Get State and Start at Most Recent</dt> <dd>Start a <strong>watch</strong> at the most recent resource version, which must be consistent (in detail: served from etcd via a quorum read). To establish initial state, the <strong>watch</strong> begins with synthetic "Added" events of all resources instances that exist at the starting resource version. All following watch events are for all changes that occurred after the resource version the <strong>watch</strong> started at.</dd> <dt>Start at Exact</dt> <dd>Start a <strong>watch</strong> at an exact resource version. The watch events are for all changes after the provided resource version. Unlike "Get State and Start at Most Recent" and "Get State and Start at Any", the <strong>watch</strong> is not started with synthetic "Added" events for the provided resource version. The client is assumed to already have the initial state at the starting resource version since the client provided the resource version.</dd> </dl> <h3 id="410-gone-responses">"410 Gone" responses</h3> <p>Servers are not required to serve all older resource versions and may return a HTTP <code>410 (Gone)</code> status code if a client requests a <code>resourceVersion</code> older than the server has retained. Clients must be able to tolerate <code>410 (Gone)</code> responses. See <a href="#efficient-detection-of-changes">Efficient detection of changes</a> for details on how to handle <code>410 (Gone)</code> responses when watching resources.</p> <p>If you request a <code>resourceVersion</code> outside the applicable limit then, depending on whether a request is served from cache or not, the API server may reply with a <code>410 Gone</code> HTTP response.</p> <h3 id="unavailable-resource-versions">Unavailable resource versions</h3> <p>Servers are not required to serve unrecognized resource versions. If you request <strong>list</strong> or <strong>get</strong> for a resource version that the API server does not recognize, then the API server may either:</p> <ul> <li>wait briefly for the resource version to become available, then timeout with a <code>504 (Gateway Timeout)</code> if the provided resource versions does not become available in a reasonable amount of time;</li> <li>respond with a <code>Retry-After</code> response header indicating how many seconds a client should wait before retrying the request.</li> </ul> <p>If you request a resource version that an API server does not recognize, the kube-apiserver additionally identifies its error responses with a "Too large resource version" message.</p> <p>If you make a <strong>watch</strong> request for an unrecognized resource version, the API server may wait indefinitely (until the request timeout) for the resource version to become available.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2022 The Kubernetes Authors<br>Documentation Distributed under CC BY 4.0.<br>
    <a href="https://kubernetes.io/docs/reference/using-api/api-concepts/" class="_attribution-link">https://kubernetes.io/docs/reference/using-api/api-concepts/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
