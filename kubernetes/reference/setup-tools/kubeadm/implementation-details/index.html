
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Implementation Details - Kubernetes - W3cubDocs</title>
  
  <meta name="description" content="kubeadm init and kubeadm join together provides a nice user experience for creating a best-practice but bare Kubernetes cluster from scratch. &hellip;">
  <meta name="keywords" content="implementation, details, kubernetes">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/kubernetes/reference/setup-tools/kubeadm/implementation-details/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/kubernetes.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/kubernetes/" class="_nav-link" title="" style="margin-left:0;">Kubernetes</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _kubernetes">
				
				
<h1>Implementation details</h1>  <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.10 [stable]</code> </div> <p><code>kubeadm init</code> and <code>kubeadm join</code> together provides a nice user experience for creating a best-practice but bare Kubernetes cluster from scratch. However, it might not be obvious <em>how</em> kubeadm does that.</p> <p>This document provides additional details on what happen under the hood, with the aim of sharing knowledge on Kubernetes cluster best practices.</p>  <h2 id="core-design-principles">Core design principles</h2> <p>The cluster that <code>kubeadm init</code> and <code>kubeadm join</code> set up should be:</p> <ul> <li>
<strong>Secure</strong>: It should adopt latest best-practices like: <ul> <li>enforcing RBAC</li> <li>using the Node Authorizer</li> <li>using secure communication between the control plane components</li> <li>using secure communication between the API server and the kubelets</li> <li>lock-down the kubelet API</li> <li>locking down access to the API for system components like the kube-proxy and CoreDNS</li> <li>locking down what a Bootstrap Token can access</li> </ul> </li> <li>
<strong>User-friendly</strong>: The user should not have to run anything more than a couple of commands: <ul> <li><code>kubeadm init</code></li> <li><code>export KUBECONFIG=/etc/kubernetes/admin.conf</code></li> <li><code>kubectl apply -f &lt;network-of-choice.yaml&gt;</code></li> <li><code>kubeadm join --token &lt;token&gt; &lt;endpoint&gt;:&lt;port&gt;</code></li> </ul> </li> <li>
<strong>Extendable</strong>: <ul> <li>It should <em>not</em> favor any particular network provider. Configuring the cluster network is out-of-scope</li> <li>It should provide the possibility to use a config file for customizing various parameters</li> </ul> </li> </ul> <h2 id="constants-and-well-known-values-and-paths">Constants and well-known values and paths</h2> <p>In order to reduce complexity and to simplify development of higher level tools that build on top of kubeadm, it uses a limited set of constant values for well-known paths and file names.</p> <p>The Kubernetes directory <code>/etc/kubernetes</code> is a constant in the application, since it is clearly the given path in a majority of cases, and the most intuitive location; other constants paths and file names are:</p> <ul> <li>
<code>/etc/kubernetes/manifests</code> as the path where kubelet should look for static Pod manifests. Names of static Pod manifests are: <ul> <li><code>etcd.yaml</code></li> <li><code>kube-apiserver.yaml</code></li> <li><code>kube-controller-manager.yaml</code></li> <li><code>kube-scheduler.yaml</code></li> </ul> </li> <li>
<code>/etc/kubernetes/</code> as the path where kubeconfig files with identities for control plane components are stored. Names of kubeconfig files are: <ul> <li>
<code>kubelet.conf</code> (<code>bootstrap-kubelet.conf</code> during TLS bootstrap)</li> <li><code>controller-manager.conf</code></li> <li><code>scheduler.conf</code></li> <li>
<code>admin.conf</code> for the cluster admin and kubeadm itself</li> </ul> </li> <li>Names of certificates and key files : <ul> <li>
<code>ca.crt</code>, <code>ca.key</code> for the Kubernetes certificate authority</li> <li>
<code>apiserver.crt</code>, <code>apiserver.key</code> for the API server certificate</li> <li>
<code>apiserver-kubelet-client.crt</code>, <code>apiserver-kubelet-client.key</code> for the client certificate used by the API server to connect to the kubelets securely</li> <li>
<code>sa.pub</code>, <code>sa.key</code> for the key used by the controller manager when signing ServiceAccount</li> <li>
<code>front-proxy-ca.crt</code>, <code>front-proxy-ca.key</code> for the front proxy certificate authority</li> <li>
<code>front-proxy-client.crt</code>, <code>front-proxy-client.key</code> for the front proxy client</li> </ul> </li> </ul> <h2 id="kubeadm-init-workflow-internal-design">kubeadm init workflow internal design</h2> <p>The <code>kubeadm init</code> <a href="../kubeadm-init/index#init-workflow">internal workflow</a> consists of a sequence of atomic work tasks to perform, as described in <code>kubeadm init</code>.</p> <p>The <a href="../kubeadm-init-phase/index"><code>kubeadm init phase</code></a> command allows users to invoke each task individually, and ultimately offers a reusable and composable API/toolbox that can be used by other Kubernetes bootstrap tools, by any IT automation tool or by an advanced user for creating custom clusters.</p> <h3 id="preflight-checks">Preflight checks</h3> <p>Kubeadm executes a set of preflight checks before starting the init, with the aim to verify preconditions and avoid common cluster startup problems. The user can skip specific preflight checks or all of them with the <code>--ignore-preflight-errors</code> option.</p> <ul> <li>[warning] If the Kubernetes version to use (specified with the <code>--kubernetes-version</code> flag) is at least one minor version higher than the kubeadm CLI version.</li> <li>Kubernetes system requirements: <ul> <li>if running on linux: <ul> <li>[error] if Kernel is older than the minimum required version</li> <li>[error] if required cgroups subsystem aren't in set up</li> </ul> </li> <li>if using docker: <ul> <li>[warning/error] if Docker service does not exist, if it is disabled, if it is not active.</li> <li>[error] if Docker endpoint does not exist or does not work</li> <li>[warning] if docker version is not in the list of validated docker versions</li> </ul> </li> <li>If using other cri engine: <ul> <li>[error] if crictl socket does not answer</li> </ul> </li> </ul> </li> <li>[error] if user is not root</li> <li>[error] if the machine hostname is not a valid DNS subdomain</li> <li>[warning] if the host name cannot be reached via network lookup</li> <li>[error] if kubelet version is lower that the minimum kubelet version supported by kubeadm (current minor -1)</li> <li>[error] if kubelet version is at least one minor higher than the required controlplane version (unsupported version skew)</li> <li>[warning] if kubelet service does not exist or if it is disabled</li> <li>[warning] if firewalld is active</li> <li>[error] if API server bindPort or ports 10250/10251/10252 are used</li> <li>[Error] if <code>/etc/kubernetes/manifest</code> folder already exists and it is not empty</li> <li>[Error] if <code>/proc/sys/net/bridge/bridge-nf-call-iptables</code> file does not exist/does not contain 1</li> <li>[Error] if advertise address is ipv6 and <code>/proc/sys/net/bridge/bridge-nf-call-ip6tables</code> does not exist/does not contain 1.</li> <li>[Error] if swap is on</li> <li>[Error] if <code>conntrack</code>, <code>ip</code>, <code>iptables</code>, <code>mount</code>, <code>nsenter</code> commands are not present in the command path</li> <li>[warning] if <code>ebtables</code>, <code>ethtool</code>, <code>socat</code>, <code>tc</code>, <code>touch</code>, <code>crictl</code> commands are not present in the command path</li> <li>[warning] if extra arg flags for API server, controller manager, scheduler contains some invalid options</li> <li>[warning] if connection to https://API.AdvertiseAddress:API.BindPort goes through proxy</li> <li>[warning] if connection to services subnet goes through proxy (only first address checked)</li> <li>[warning] if connection to Pods subnet goes through proxy (only first address checked)</li> <li>If external etcd is provided: <ul> <li>[Error] if etcd version is older than the minimum required version</li> <li>[Error] if etcd certificates or keys are specified, but not provided</li> </ul> </li> <li>If external etcd is NOT provided (and thus local etcd will be installed): <ul> <li>[Error] if ports 2379 is used</li> <li>[Error] if Etcd.DataDir folder already exists and it is not empty</li> </ul> </li> <li>If authorization mode is ABAC: <ul> <li>[Error] if abac_policy.json does not exist</li> </ul> </li> <li>If authorization mode is WebHook <ul> <li>[Error] if webhook_authz.conf does not exist</li> </ul> </li> </ul> <p>Please note that:</p> <ol> <li>Preflight checks can be invoked individually with the <a href="../kubeadm-init-phase/index#cmd-phase-preflight"><code>kubeadm init phase preflight</code></a> command</li> </ol> <h3 id="generate-the-necessary-certificates">Generate the necessary certificates</h3> <p>Kubeadm generates certificate and private key pairs for different purposes:</p> <ul> <li>A self signed certificate authority for the Kubernetes cluster saved into <code>ca.crt</code> file and <code>ca.key</code> private key file</li> <li>A serving certificate for the API server, generated using <code>ca.crt</code> as the CA, and saved into <code>apiserver.crt</code> file with its private key <code>apiserver.key</code>. This certificate should contain following alternative names: <ul> <li>The Kubernetes service's internal clusterIP (the first address in the services CIDR, e.g. <code>10.96.0.1</code> if service subnet is <code>10.96.0.0/12</code>)</li> <li>Kubernetes DNS names, e.g. <code>kubernetes.default.svc.cluster.local</code> if <code>--service-dns-domain</code> flag value is <code>cluster.local</code>, plus default DNS names <code>kubernetes.default.svc</code>, <code>kubernetes.default</code>, <code>kubernetes</code>
</li> <li>The node-name</li> <li>The <code>--apiserver-advertise-address</code>
</li> <li>Additional alternative names specified by the user</li> </ul> </li> <li>A client certificate for the API server to connect to the kubelets securely, generated using <code>ca.crt</code> as the CA and saved into <code>apiserver-kubelet-client.crt</code> file with its private key <code>apiserver-kubelet-client.key</code>. This certificate should be in the <code>system:masters</code> organization</li> <li>A private key for signing ServiceAccount Tokens saved into <code>sa.key</code> file along with its public key <code>sa.pub</code>
</li> <li>A certificate authority for the front proxy saved into <code>front-proxy-ca.crt</code> file with its key <code>front-proxy-ca.key</code>
</li> <li>A client cert for the front proxy client, generate using <code>front-proxy-ca.crt</code> as the CA and saved into <code>front-proxy-client.crt</code> file with its private key<code>front-proxy-client.key</code>
</li> </ul> <p>Certificates are stored by default in <code>/etc/kubernetes/pki</code>, but this directory is configurable using the <code>--cert-dir</code> flag.</p> <p>Please note that:</p> <ol> <li>If a given certificate and private key pair both exist, and its content is evaluated compliant with the above specs, the existing files will be used and the generation phase for the given certificate skipped. This means the user can, for example, copy an existing CA to <code>/etc/kubernetes/pki/ca.{crt,key}</code>, and then kubeadm will use those files for signing the rest of the certs. See also <a href="https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#custom-certificates">using custom certificates</a>
</li> <li>Only for the CA, it is possible to provide the <code>ca.crt</code> file but not the <code>ca.key</code> file, if all other certificates and kubeconfig files already are in place kubeadm recognize this condition and activates the ExternalCA , which also implies the <code>csrsigner</code>controller in controller-manager won't be started</li> <li>If kubeadm is running in <a href="https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#external-ca-mode">external CA mode</a>; all the certificates must be provided by the user, because kubeadm cannot generate them by itself</li> <li>In case of kubeadm is executed in the <code>--dry-run</code> mode, certificates files are written in a temporary folder</li> <li>Certificate generation can be invoked individually with the <a href="../kubeadm-init-phase/index#cmd-phase-certs"><code>kubeadm init phase certs all</code></a> command</li> </ol> <h3 id="generate-kubeconfig-files-for-control-plane-components">Generate kubeconfig files for control plane components</h3> <p>Kubeadm generates kubeconfig files with identities for control plane components:</p> <ul> <li>A kubeconfig file for the kubelet to use during TLS bootstrap - /etc/kubernetes/bootstrap-kubelet.conf. Inside this file there is a bootstrap-token or embedded client certificates for authenticating this node with the cluster. This client cert should: <ul> <li>Be in the <code>system:nodes</code> organization, as required by the <a href="../../../access-authn-authz/node/index">Node Authorization</a> module</li> <li>Have the Common Name (CN) <code>system:node:&lt;hostname-lowercased&gt;</code>
</li> </ul> </li> <li>A kubeconfig file for controller-manager, <code>/etc/kubernetes/controller-manager.conf</code>; inside this file is embedded a client certificate with controller-manager identity. This client cert should have the CN <code>system:kube-controller-manager</code>, as defined by default <a href="../../../access-authn-authz/rbac/index#core-component-roles">RBAC core components roles</a>
</li> <li>A kubeconfig file for scheduler, <code>/etc/kubernetes/scheduler.conf</code>; inside this file is embedded a client certificate with scheduler identity. This client cert should have the CN <code>system:kube-scheduler</code>, as defined by default <a href="../../../access-authn-authz/rbac/index#core-component-roles">RBAC core components roles</a>
</li> </ul> <p>Additionally, a kubeconfig file for kubeadm itself and the admin is generated and saved into the <code>/etc/kubernetes/admin.conf</code> file. The "admin" here is defined as the actual person(s) that is administering the cluster and wants to have full control (<strong>root</strong>) over the cluster. The embedded client certificate for admin should be in the <code>system:masters</code> organization, as defined by default <a href="../../../access-authn-authz/rbac/index#user-facing-roles">RBAC user facing role bindings</a>. It should also include a CN. Kubeadm uses the <code>kubernetes-admin</code> CN.</p> <p>Please note that:</p> <ol> <li>
<code>ca.crt</code> certificate is embedded in all the kubeconfig files.</li> <li>If a given kubeconfig file exists, and its content is evaluated compliant with the above specs, the existing file will be used and the generation phase for the given kubeconfig skipped</li> <li>If kubeadm is running in <a href="../kubeadm-init/index#external-ca-mode">ExternalCA mode</a>, all the required kubeconfig must be provided by the user as well, because kubeadm cannot generate any of them by itself</li> <li>In case of kubeadm is executed in the <code>--dry-run</code> mode, kubeconfig files are written in a temporary folder</li> <li>Kubeconfig files generation can be invoked individually with the <a href="../kubeadm-init-phase/index#cmd-phase-kubeconfig"><code>kubeadm init phase kubeconfig all</code></a> command</li> </ol> <h3 id="generate-static-pod-manifests-for-control-plane-components">Generate static Pod manifests for control plane components</h3> <p>Kubeadm writes static Pod manifest files for control plane components to <code>/etc/kubernetes/manifests</code>. The kubelet watches this directory for Pods to create on startup.</p> <p>Static Pod manifest share a set of common properties:</p> <ul> <li>All static Pods are deployed on <code>kube-system</code> namespace</li> <li>All static Pods get <code>tier:control-plane</code> and <code>component:{component-name}</code> labels</li> <li>All static Pods use the <code>system-node-critical</code> priority class</li> <li>
<code>hostNetwork: true</code> is set on all static Pods to allow control plane startup before a network is configured; as a consequence: <ul> <li>The <code>address</code> that the controller-manager and the scheduler use to refer the API server is <code>127.0.0.1</code>
</li> <li>If using a local etcd server, <code>etcd-servers</code> address will be set to <code>127.0.0.1:2379</code>
</li> </ul> </li> <li>Leader election is enabled for both the controller-manager and the scheduler</li> <li>Controller-manager and the scheduler will reference kubeconfig files with their respective, unique identities</li> <li>All static Pods get any extra flags specified by the user as described in <a href="../../../../setup/production-environment/tools/kubeadm/control-plane-flags/index">passing custom arguments to control plane components</a>
</li> <li>All static Pods get any extra Volumes specified by the user (Host path)</li> </ul> <p>Please note that:</p> <ol> <li>All images will be pulled from k8s.gcr.io by default. See <a href="../kubeadm-init/index#custom-images">using custom images</a> for customizing the image repository</li> <li>In case of kubeadm is executed in the <code>--dry-run</code> mode, static Pods files are written in a temporary folder</li> <li>Static Pod manifest generation for control plane components can be invoked individually with the <a href="../kubeadm-init-phase/index#cmd-phase-control-plane"><code>kubeadm init phase control-plane all</code></a> command</li> </ol> <h4 id="api-server">API server</h4> <p>The static Pod manifest for the API server is affected by following parameters provided by the users:</p> <ul> <li>The <code>apiserver-advertise-address</code> and <code>apiserver-bind-port</code> to bind to; if not provided, those value defaults to the IP address of the default network interface on the machine and port 6443</li> <li>The <code>service-cluster-ip-range</code> to use for services</li> <li>If an external etcd server is specified, the <code>etcd-servers</code> address and related TLS settings (<code>etcd-cafile</code>, <code>etcd-certfile</code>, <code>etcd-keyfile</code>); if an external etcd server is not be provided, a local etcd will be used (via host network)</li> <li>If a cloud provider is specified, the corresponding <code>--cloud-provider</code> is configured, together with the <code>--cloud-config</code> path if such file exists (this is experimental, alpha and will be removed in a future version)</li> </ul> <p>Other API server flags that are set unconditionally are:</p> <ul> <li>
<code>--insecure-port=0</code> to avoid insecure connections to the api server</li> <li>
<code>--enable-bootstrap-token-auth=true</code> to enable the <code>BootstrapTokenAuthenticator</code> authentication module. See <a href="../../../command-line-tools-reference/kubelet-tls-bootstrapping/index">TLS Bootstrapping</a> for more details</li> <li>
<code>--allow-privileged</code> to <code>true</code> (required e.g. by kube proxy)</li> <li>
<code>--requestheader-client-ca-file</code> to <code>front-proxy-ca.crt</code>
</li> <li>
<code>--enable-admission-plugins</code> to: <ul> <li>
<a href="../../../access-authn-authz/admission-controllers/index#namespacelifecycle"><code>NamespaceLifecycle</code></a> e.g. to avoid deletion of system reserved namespaces</li> <li>
<a href="../../../access-authn-authz/admission-controllers/index#limitranger"><code>LimitRanger</code></a> and <a href="../../../access-authn-authz/admission-controllers/index#resourcequota"><code>ResourceQuota</code></a> to enforce limits on namespaces</li> <li>
<a href="../../../access-authn-authz/admission-controllers/index#serviceaccount"><code>ServiceAccount</code></a> to enforce service account automation</li> <li>
<a href="../../../access-authn-authz/admission-controllers/index#persistentvolumelabel"><code>PersistentVolumeLabel</code></a> attaches region or zone labels to PersistentVolumes as defined by the cloud provider (This admission controller is deprecated and will be removed in a future version. It is not deployed by kubeadm by default with v1.9 onwards when not explicitly opting into using <code>gce</code> or <code>aws</code> as cloud providers)</li> <li>
<a href="../../../access-authn-authz/admission-controllers/index#defaultstorageclass"><code>DefaultStorageClass</code></a> to enforce default storage class on <code>PersistentVolumeClaim</code> objects</li> <li><a href="../../../access-authn-authz/admission-controllers/index#defaulttolerationseconds"><code>DefaultTolerationSeconds</code></a></li> <li>
<a href="../../../access-authn-authz/admission-controllers/index#noderestriction"><code>NodeRestriction</code></a> to limit what a kubelet can modify (e.g. only pods on this node)</li> </ul> </li> <li>
<code>--kubelet-preferred-address-types</code> to <code>InternalIP,ExternalIP,Hostname;</code> this makes <code>kubectl logs</code> and other API server-kubelet communication work in environments where the hostnames of the nodes aren't resolvable</li> <li>Flags for using certificates generated in previous steps: <ul> <li>
<code>--client-ca-file</code> to <code>ca.crt</code>
</li> <li>
<code>--tls-cert-file</code> to <code>apiserver.crt</code>
</li> <li>
<code>--tls-private-key-file</code> to <code>apiserver.key</code>
</li> <li>
<code>--kubelet-client-certificate</code> to <code>apiserver-kubelet-client.crt</code>
</li> <li>
<code>--kubelet-client-key</code> to <code>apiserver-kubelet-client.key</code>
</li> <li>
<code>--service-account-key-file</code> to <code>sa.pub</code>
</li> <li>
<code>--requestheader-client-ca-file</code> to<code>front-proxy-ca.crt</code>
</li> <li>
<code>--proxy-client-cert-file</code> to <code>front-proxy-client.crt</code>
</li> <li>
<code>--proxy-client-key-file</code> to <code>front-proxy-client.key</code>
</li> </ul> </li> <li>Other flags for securing the front proxy (<a href="../../../../concepts/extend-kubernetes/api-extension/apiserver-aggregation/index">API Aggregation</a>) communications: <ul> <li><code>--requestheader-username-headers=X-Remote-User</code></li> <li><code>--requestheader-group-headers=X-Remote-Group</code></li> <li><code>--requestheader-extra-headers-prefix=X-Remote-Extra-</code></li> <li><code>--requestheader-allowed-names=front-proxy-client</code></li> </ul> </li> </ul> <h4 id="controller-manager">Controller manager</h4> <p>The static Pod manifest for the controller manager is affected by following parameters provided by the users:</p> <ul> <li>If kubeadm is invoked specifying a <code>--pod-network-cidr</code>, the subnet manager feature required for some CNI network plugins is enabled by setting: <ul> <li><code>--allocate-node-cidrs=true</code></li> <li>
<code>--cluster-cidr</code> and <code>--node-cidr-mask-size</code> flags according to the given CIDR</li> </ul> </li> <li>If a cloud provider is specified, the corresponding <code>--cloud-provider</code> is specified, together with the <code>--cloud-config</code> path if such configuration file exists (this is experimental, alpha and will be removed in a future version)</li> </ul> <p>Other flags that are set unconditionally are:</p> <ul> <li>
<code>--controllers</code> enabling all the default controllers plus <code>BootstrapSigner</code> and <code>TokenCleaner</code> controllers for TLS bootstrap. See <a href="../../../command-line-tools-reference/kubelet-tls-bootstrapping/index">TLS Bootstrapping</a> for more details</li> <li>
<code>--use-service-account-credentials</code> to <code>true</code>
</li> <li>Flags for using certificates generated in previous steps: <ul> <li>
<code>--root-ca-file</code> to <code>ca.crt</code>
</li> <li>
<code>--cluster-signing-cert-file</code> to <code>ca.crt</code>, if External CA mode is disabled, otherwise to <code>""</code>
</li> <li>
<code>--cluster-signing-key-file</code> to <code>ca.key</code>, if External CA mode is disabled, otherwise to <code>""</code>
</li> <li>
<code>--service-account-private-key-file</code> to <code>sa.key</code>
</li> </ul> </li> </ul> <h4 id="scheduler">Scheduler</h4> <p>The static Pod manifest for the scheduler is not affected by parameters provided by the users.</p> <h3 id="generate-static-pod-manifest-for-local-etcd">Generate static Pod manifest for local etcd</h3> <p>If the user specified an external etcd this step will be skipped, otherwise kubeadm generates a static Pod manifest file for creating a local etcd instance running in a Pod with following attributes:</p> <ul> <li>listen on <code>localhost:2379</code> and use <code>HostNetwork=true</code>
</li> <li>make a <code>hostPath</code> mount out from the <code>dataDir</code> to the host's filesystem</li> <li>Any extra flags specified by the user</li> </ul> <p>Please note that:</p> <ol> <li>The etcd image will be pulled from <code>k8s.gcr.io</code> by default. See <a href="../kubeadm-init/index#custom-images">using custom images</a> for customizing the image repository</li> <li>in case of kubeadm is executed in the <code>--dry-run</code> mode, the etcd static Pod manifest is written in a temporary folder</li> <li>Static Pod manifest generation for local etcd can be invoked individually with the <a href="../kubeadm-init-phase/index#cmd-phase-etcd"><code>kubeadm init phase etcd local</code></a> command</li> </ol> <h3 id="wait-for-the-control-plane-to-come-up">Wait for the control plane to come up</h3> <p>kubeadm waits (upto 4m0s) until <code>localhost:6443/healthz</code> (kube-apiserver liveness) returns <code>ok</code>. However in order to detect deadlock conditions, kubeadm fails fast if <code>localhost:10255/healthz</code> (kubelet liveness) or <code>localhost:10255/healthz/syncloop</code> (kubelet readiness) don't return <code>ok</code> within 40s and 60s respectively.</p> <p>kubeadm relies on the kubelet to pull the control plane images and run them properly as static Pods. After the control plane is up, kubeadm completes the tasks described in following paragraphs.</p> <h3 id="save-the-kubeadm-clusterconfiguration-in-a-configmap-for-later-reference">Save the kubeadm ClusterConfiguration in a ConfigMap for later reference</h3> <p>kubeadm saves the configuration passed to <code>kubeadm init</code> in a ConfigMap named <code>kubeadm-config</code> under <code>kube-system</code> namespace.</p> <p>This will ensure that kubeadm actions executed in future (e.g <code>kubeadm upgrade</code>) will be able to determine the actual/current cluster state and make new decisions based on that data.</p> <p>Please note that:</p> <ol> <li>Before saving the ClusterConfiguration, sensitive information like the token is stripped from the configuration</li> <li>Upload of control plane node configuration can be invoked individually with the <a href="../kubeadm-init-phase/index#cmd-phase-upload-config"><code>kubeadm init phase upload-config</code></a> command</li> </ol> <h3 id="mark-the-node-as-control-plane">Mark the node as control-plane</h3> <p>As soon as the control plane is available, kubeadm executes following actions:</p> <ul> <li>Labels the node as control-plane with <code>node-role.kubernetes.io/master=""</code>
</li> <li>Taints the node with <code>node-role.kubernetes.io/master:NoSchedule</code>
</li> </ul> <p>Please note that:</p> <ol> <li>Mark control-plane phase phase can be invoked individually with the <a href="../kubeadm-init-phase/index#cmd-phase-mark-control-plane"><code>kubeadm init phase mark-control-plane</code></a> command</li> </ol> <h3 id="configure-tls-bootstrapping-for-node-joining">Configure TLS-Bootstrapping for node joining</h3> <p>Kubeadm uses <a href="../../../access-authn-authz/bootstrap-tokens/index">Authenticating with Bootstrap Tokens</a> for joining new nodes to an existing cluster; for more details see also <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md">design proposal</a>.</p> <p><code>kubeadm init</code> ensures that everything is properly configured for this process, and this includes following steps as well as setting API server and controller flags as already described in previous paragraphs. Please note that:</p> <ol> <li>TLS bootstrapping for nodes can be configured with the <a href="../kubeadm-init-phase/index#cmd-phase-bootstrap-token"><code>kubeadm init phase bootstrap-token</code></a> command, executing all the configuration steps described in following paragraphs; alternatively, each step can be invoked individually</li> </ol> <h4 id="create-a-bootstrap-token">Create a bootstrap token</h4> <p><code>kubeadm init</code> create a first bootstrap token, either generated automatically or provided by the user with the <code>--token</code> flag; as documented in bootstrap token specification, token should be saved as secrets with name <code>bootstrap-token-&lt;token-id&gt;</code> under <code>kube-system</code> namespace. Please note that:</p> <ol> <li>The default token created by <code>kubeadm init</code> will be used to validate temporary user during TLS bootstrap process; those users will be member of <code>system:bootstrappers:kubeadm:default-node-token</code> group</li> <li>The token has a limited validity, default 24 hours (the interval may be changed with the <code>—token-ttl</code> flag)</li> <li>Additional tokens can be created with the <a href="../kubeadm-token/index"><code>kubeadm token</code></a> command, that provide as well other useful functions for token management</li> </ol> <h4 id="allow-joining-nodes-to-call-csr-api">Allow joining nodes to call CSR API</h4> <p>Kubeadm ensures that users in <code>system:bootstrappers:kubeadm:default-node-token</code> group are able to access the certificate signing API.</p> <p>This is implemented by creating a ClusterRoleBinding named <code>kubeadm:kubelet-bootstrap</code> between the group above and the default RBAC role <code>system:node-bootstrapper</code>.</p> <h4 id="setup-auto-approval-for-new-bootstrap-tokens">Setup auto approval for new bootstrap tokens</h4> <p>Kubeadm ensures that the Bootstrap Token will get its CSR request automatically approved by the csrapprover controller.</p> <p>This is implemented by creating ClusterRoleBinding named <code>kubeadm:node-autoapprove-bootstrap</code> between the <code>system:bootstrappers:kubeadm:default-node-token</code> group and the default role <code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code>.</p> <p>The role <code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code> should be created as well, granting POST permission to <code>/apis/certificates.k8s.io/certificatesigningrequests/nodeclient</code>.</p> <h4 id="setup-nodes-certificate-rotation-with-auto-approval">Setup nodes certificate rotation with auto approval</h4> <p>Kubeadm ensures that certificate rotation is enabled for nodes, and that new certificate request for nodes will get its CSR request automatically approved by the csrapprover controller.</p> <p>This is implemented by creating ClusterRoleBinding named <code>kubeadm:node-autoapprove-certificate-rotation</code> between the <code>system:nodes</code> group and the default role <code>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</code>.</p> <h4 id="create-the-public-cluster-info-configmap">Create the public cluster-info ConfigMap</h4> <p>This phase creates the <code>cluster-info</code> ConfigMap in the <code>kube-public</code> namespace.</p> <p>Additionally it creates a Role and a RoleBinding granting access to the ConfigMap for unauthenticated users (i.e. users in RBAC group <code>system:unauthenticated</code>).</p> <p>Please note that:</p> <ol> <li>The access to the <code>cluster-info</code> ConfigMap <em>is not</em> rate-limited. This may or may not be a problem if you expose your cluster's API server to the internet; worst-case scenario here is a DoS attack where an attacker uses all the in-flight requests the kube-apiserver can handle to serving the <code>cluster-info</code> ConfigMap.</li> </ol> <h3 id="install-addons">Install addons</h3> <p>Kubeadm installs the internal DNS server and the kube-proxy addon components via the API server. Please note that:</p> <ol> <li>This phase can be invoked individually with the <a href="../kubeadm-init-phase/index#cmd-phase-addon"><code>kubeadm init phase addon all</code></a> command.</li> </ol> <h4 id="proxy">proxy</h4> <p>A ServiceAccount for <code>kube-proxy</code> is created in the <code>kube-system</code> namespace; then kube-proxy is deployed as a DaemonSet:</p> <ul> <li>The credentials (<code>ca.crt</code> and <code>token</code>) to the control plane come from the ServiceAccount</li> <li>The location (URL) of the API server comes from a ConfigMap</li> <li>The <code>kube-proxy</code> ServiceAccount is bound to the privileges in the <code>system:node-proxier</code> ClusterRole</li> </ul> <h4 id="dns">DNS</h4> <ul> <li>The CoreDNS service is named <code>kube-dns</code>. This is done to prevent any interruption in service when the user is switching the cluster DNS from kube-dns to CoreDNS the <code>--config</code> method described <a href="../kubeadm-init-phase/index#cmd-phase-addon">here</a>.</li> <li>A ServiceAccount for CoreDNS is created in the <code>kube-system</code> namespace.</li> <li>The <code>coredns</code> ServiceAccount is bound to the privileges in the <code>system:coredns</code> ClusterRole</li> </ul> <p>In Kubernetes version 1.21, support for using <code>kube-dns</code> with kubeadm was removed. You can use CoreDNS with kubeadm even when the related Service is named <code>kube-dns</code>.</p> <h2 id="kubeadm-join-phases-internal-design">kubeadm join phases internal design</h2> <p>Similarly to <code>kubeadm init</code>, also <code>kubeadm join</code> internal workflow consists of a sequence of atomic work tasks to perform.</p> <p>This is split into discovery (having the Node trust the Kubernetes Master) and TLS bootstrap (having the Kubernetes Master trust the Node).</p> <p>see <a href="../../../access-authn-authz/bootstrap-tokens/index">Authenticating with Bootstrap Tokens</a> or the corresponding <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md">design proposal</a>.</p> <h3 id="preflight-checks-1">Preflight checks</h3> <p><code>kubeadm</code> executes a set of preflight checks before starting the join, with the aim to verify preconditions and avoid common cluster startup problems.</p> <p>Please note that:</p> <ol> <li>
<code>kubeadm join</code> preflight checks are basically a subset <code>kubeadm init</code> preflight checks</li> <li>Starting from 1.9, kubeadm provides better support for CRI-generic functionality; in that case, docker specific controls are skipped or replaced by similar controls for crictl.</li> <li>Starting from 1.9, kubeadm provides support for joining nodes running on Windows; in that case, linux specific controls are skipped.</li> <li>In any case the user can skip specific preflight checks (or eventually all preflight checks) with the <code>--ignore-preflight-errors</code> option.</li> </ol> <h3 id="discovery-cluster-info">Discovery cluster-info</h3> <p>There are 2 main schemes for discovery. The first is to use a shared token along with the IP address of the API server. The second is to provide a file (that is a subset of the standard kubeconfig file).</p> <h4 id="shared-token-discovery">Shared token discovery</h4> <p>If <code>kubeadm join</code> is invoked with <code>--discovery-token</code>, token discovery is used; in this case the node basically retrieves the cluster CA certificates from the <code>cluster-info</code> ConfigMap in the <code>kube-public</code> namespace.</p> <p>In order to prevent "man in the middle" attacks, several steps are taken:</p> <ul> <li>First, the CA certificate is retrieved via insecure connection (this is possible because <code>kubeadm init</code> granted access to <code>cluster-info</code> users for <code>system:unauthenticated</code> )</li> <li>Then the CA certificate goes trough following validation steps: <ul> <li>Basic validation: using the token ID against a JWT signature</li> <li>Pub key validation: using provided <code>--discovery-token-ca-cert-hash</code>. This value is available in the output of <code>kubeadm init</code> or can be calculated using standard tools (the hash is calculated over the bytes of the Subject Public Key Info (SPKI) object as in RFC7469). The <code>--discovery-token-ca-cert-hash flag</code> may be repeated multiple times to allow more than one public key.</li> <li>As a additional validation, the CA certificate is retrieved via secure connection and then compared with the CA retrieved initially</li> </ul> </li> </ul> <p>Please note that:</p> <ol> <li>Pub key validation can be skipped passing <code>--discovery-token-unsafe-skip-ca-verification</code> flag; This weakens the kubeadm security model since others can potentially impersonate the Kubernetes Master.</li> </ol> <h4 id="file-https-discovery">File/https discovery</h4> <p>If <code>kubeadm join</code> is invoked with <code>--discovery-file</code>, file discovery is used; this file can be a local file or downloaded via an HTTPS URL; in case of HTTPS, the host installed CA bundle is used to verify the connection.</p> <p>With file discovery, the cluster CA certificates is provided into the file itself; in fact, the discovery file is a kubeconfig file with only <code>server</code> and <code>certificate-authority-data</code> attributes set, as described in <a href="../kubeadm-join/index#file-or-https-based-discovery"><code>kubeadm join</code></a> reference doc; when the connection with the cluster is established, kubeadm try to access the <code>cluster-info</code> ConfigMap, and if available, uses it.</p> <h2 id="tls-bootstrap">TLS Bootstrap</h2> <p>Once the cluster info are known, the file <code>bootstrap-kubelet.conf</code> is written, thus allowing kubelet to do TLS Bootstrapping.</p> <p>The TLS bootstrap mechanism uses the shared token to temporarily authenticate with the Kubernetes API server to submit a certificate signing request (CSR) for a locally created key pair.</p> <p>The request is then automatically approved and the operation completes saving <code>ca.crt</code> file and <code>kubelet.conf</code> file to be used by kubelet for joining the cluster, while<code>bootstrap-kubelet.conf</code> is deleted.</p> <p>Please note that:</p> <ul> <li>The temporary authentication is validated against the token saved during the <code>kubeadm init</code> process (or with additional tokens created with <code>kubeadm token</code>)</li> <li>The temporary authentication resolve to a user member of <code>system:bootstrappers:kubeadm:default-node-token</code> group which was granted access to CSR api during the <code>kubeadm init</code> process</li> <li>The automatic CSR approval is managed by the csrapprover controller, according with configuration done the <code>kubeadm init</code> process</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2022 The Kubernetes Authors<br>Documentation Distributed under CC BY 4.0.<br>
    <a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/implementation-details/" class="_attribution-link">https://kubernetes.io/docs/reference/setup-tools/kubeadm/implementation-details/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
