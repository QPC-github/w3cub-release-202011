
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Service - Kubernetes - W3cubDocs</title>
  
  <meta name="description" content="With Kubernetes you don&#39;t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP &hellip;">
  <meta name="keywords" content="service, kubernetes">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/kubernetes/concepts/services-networking/service/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-60a6449bb52e9968d95c133a29f066ffcb8dbe4f077d4022e51c991ce30bf256c8e19c508207a4193c414ffd0414826564317669b0f27f9f85c1cb21b84e097e.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/kubernetes.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/kubernetes/" class="_nav-link" title="" style="margin-left:0;">Kubernetes</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _kubernetes">
				
				
<h1>Service</h1>  An abstract way to expose an application running on a set of <a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." data-toggle="tooltip" data-placement="top" href="../../workloads/pods/index" target="_blank" aria-label="Pods">Pods</a> as a network service. <p>With Kubernetes you don't need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them.</p>  <h2 id="motivation">Motivation</h2> <p>Kubernetes <a class="glossary-tooltip" title="A Pod represents a set of running containers in your cluster." data-toggle="tooltip" data-placement="top" href="../../workloads/pods/index" target="_blank" aria-label="Pods">Pods</a> are created and destroyed to match the state of your cluster. Pods are nonpermanent resources. If you use a <a class="glossary-tooltip" title="Manages a replicated application on your cluster." data-toggle="tooltip" data-placement="top" href="../../workloads/controllers/deployment/index" target="_blank" aria-label="Deployment">Deployment</a> to run your app, it can create and destroy Pods dynamically.</p> <p>Each Pod gets its own IP address, however in a Deployment, the set of Pods running in one moment in time could be different from the set of Pods running that application a moment later.</p> <p>This leads to a problem: if some set of Pods (call them "backends") provides functionality to other Pods (call them "frontends") inside your cluster, how do the frontends find out and keep track of which IP address to connect to, so that the frontend can use the backend part of the workload?</p> <p>Enter <em>Services</em>.</p> <h2 id="service-resource">Service resources</h2> <p>In Kubernetes, a Service is an abstraction which defines a logical set of Pods and a policy by which to access them (sometimes this pattern is called a micro-service). The set of Pods targeted by a Service is usually determined by a <a class="glossary-tooltip" title="Allows users to filter a list of resources based on labels." data-toggle="tooltip" data-placement="top" href="../../overview/working-with-objects/labels/index" target="_blank" aria-label="selector">selector</a>. To learn about other ways to define Service endpoints, see <a href="#services-without-selectors">Services <em>without</em> selectors</a>.</p> <p>For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungibleâ€”frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves.</p> <p>The Service abstraction enables this decoupling.</p> <h3 id="cloud-native-service-discovery">Cloud-native service discovery</h3> <p>If you're able to use Kubernetes APIs for service discovery in your application, you can query the <a class="glossary-tooltip" title="Control plane component that serves the Kubernetes API." data-toggle="tooltip" data-placement="top" href="../../overview/components/index#kube-apiserver" target="_blank" aria-label="API server">API server</a> for Endpoints, that get updated whenever the set of Pods in a Service changes.</p> <p>For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.</p> <h2 id="defining-a-service">Defining a Service</h2> <p>A Service in Kubernetes is a REST object, similar to a Pod. Like all of the REST objects, you can <code>POST</code> a Service definition to the API server to create a new instance. The name of a Service object must be a valid <a href="../../overview/working-with-objects/names#rfc-1035-label-names">RFC 1035 label name</a>.</p> <p>For example, suppose you have a set of Pods where each listens on TCP port 9376 and contains a label <code>app=MyApp</code>:</p> <pre class="highlight" data-language="yaml">apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
</pre>
<p>This specification creates a new Service object named "my-service", which targets TCP port 9376 on any Pod with the <code>app=MyApp</code> label.</p> <p>Kubernetes assigns this Service an IP address (sometimes called the "cluster IP"), which is used by the Service proxies (see <a href="#virtual-ips-and-service-proxies">Virtual IPs and service proxies</a> below).</p> <p>The controller for the Service selector continuously scans for Pods that match its selector, and then POSTs any updates to an Endpoint object also named "my-service".</p> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> A Service can map <em>any</em> incoming <code>port</code> to a <code>targetPort</code>. By default and for convenience, the <code>targetPort</code> is set to the same value as the <code>port</code> field. </div> <p>Port definitions in Pods have names, and you can reference these names in the <code>targetPort</code> attribute of a Service. This works even if there is a mixture of Pods in the Service using a single configured name, with the same network protocol available via different port numbers. This offers a lot of flexibility for deploying and evolving your Services. For example, you can change the port numbers that Pods expose in the next version of your backend software, without breaking clients.</p> <p>The default protocol for Services is TCP; you can also use any other <a href="#protocol-support">supported protocol</a>.</p> <p>As many Services need to expose more than one port, Kubernetes supports multiple port definitions on a Service object. Each port definition can have the same <code>protocol</code>, or a different one.</p> <h3 id="services-without-selectors">Services without selectors</h3> <p>Services most commonly abstract access to Kubernetes Pods, but they can also abstract other kinds of backends. For example:</p> <ul> <li>You want to have an external database cluster in production, but in your test environment you use your own databases.</li> <li>You want to point your Service to a Service in a different <a class="glossary-tooltip" title="An abstraction used by Kubernetes to support multiple virtual clusters on the same physical cluster." data-toggle="tooltip" data-placement="top" href="../../overview/working-with-objects/namespaces" target="_blank" aria-label="Namespace">Namespace</a> or on another cluster.</li> <li>You are migrating a workload to Kubernetes. While evaluating the approach, you run only a portion of your backends in Kubernetes.</li> </ul> <p>In any of these scenarios you can define a Service <em>without</em> a Pod selector. For example:</p> <pre class="highlight" data-language="yaml">apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
</pre>
<p>Because this Service has no selector, the corresponding Endpoints object is not created automatically. You can manually map the Service to the network address and port where it's running, by adding an Endpoints object manually:</p> <pre class="highlight" data-language="yaml">apiVersion: v1
kind: Endpoints
metadata:
  name: my-service
subsets:
  - addresses:
      - ip: 192.0.2.42
    ports:
      - port: 9376
</pre>
<p>The name of the Endpoints object must be a valid <a href="../../overview/working-with-objects/names#dns-subdomain-names">DNS subdomain name</a>.</p> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> <p>The endpoint IPs <em>must not</em> be: loopback (127.0.0.0/8 for IPv4, ::1/128 for IPv6), or link-local (169.254.0.0/16 and 224.0.0.0/24 for IPv4, fe80::/64 for IPv6).</p> <p>Endpoint IP addresses cannot be the cluster IPs of other Kubernetes Services, because <a class="glossary-tooltip" title="kube-proxy is a network proxy that runs on each node in the cluster." data-toggle="tooltip" data-placement="top" href="../../../reference/command-line-tools-reference/kube-proxy/index" target="_blank" aria-label="kube-proxy">kube-proxy</a> doesn't support virtual IPs as a destination.</p> </div> <p>Accessing a Service without a selector works the same as if it had a selector. In the example above, traffic is routed to the single endpoint defined in the YAML: <code>192.0.2.42:9376</code> (TCP).</p> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> The Kubernetes API server does not allow proxying to endpoints that are not mapped to pods. Actions such as <code>kubectl proxy &lt;service-name&gt;</code> where the service has no selector will fail due to this constraint. This prevents the Kubernetes API server from being used as a proxy to endpoints the caller may not be authorized to access. </div> <p>An ExternalName Service is a special case of Service that does not have selectors and uses DNS names instead. For more information, see the <a href="#externalname">ExternalName</a> section later in this document.</p> <h3 id="over-capacity-endpoints">Over Capacity Endpoints</h3> <p>If an Endpoints resource has more than 1000 endpoints then a Kubernetes v1.22 (or later) cluster annotates that Endpoints with <code>endpoints.kubernetes.io/over-capacity: truncated</code>. This annotation indicates that the affected Endpoints object is over capacity and that the endpoints controller has truncated the number of endpoints to 1000.</p> <h3 id="endpointslices">EndpointSlices</h3> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code> </div> <p>EndpointSlices are an API resource that can provide a more scalable alternative to Endpoints. Although conceptually quite similar to Endpoints, EndpointSlices allow for distributing network endpoints across multiple resources. By default, an EndpointSlice is considered "full" once it reaches 100 endpoints, at which point additional EndpointSlices will be created to store any additional endpoints.</p> <p>EndpointSlices provide additional attributes and functionality which is described in detail in <a href="../endpoint-slices/index">EndpointSlices</a>.</p> <h3 id="application-protocol">Application protocol</h3> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code> </div> <p>The <code>appProtocol</code> field provides a way to specify an application protocol for each Service port. The value of this field is mirrored by the corresponding Endpoints and EndpointSlice objects.</p> <p>This field follows standard Kubernetes label syntax. Values should either be <a href="https://www.iana.org/assignments/service-names">IANA standard service names</a> or domain prefixed names such as <code>mycompany.com/my-custom-protocol</code>.</p> <h2 id="virtual-ips-and-service-proxies">Virtual IPs and service proxies</h2> <p>Every node in a Kubernetes cluster runs a <code>kube-proxy</code>. <code>kube-proxy</code> is responsible for implementing a form of virtual IP for <code>Services</code> of type other than <a href="#externalname"><code>ExternalName</code></a>.</p> <h3 id="why-not-use-round-robin-dns">Why not use round-robin DNS?</h3> <p>A question that pops up every now and then is why Kubernetes relies on proxying to forward inbound traffic to backends. What about other approaches? For example, would it be possible to configure DNS records that have multiple A values (or AAAA for IPv6), and rely on round-robin name resolution?</p> <p>There are a few reasons for using proxying for Services:</p> <ul> <li>There is a long history of DNS implementations not respecting record TTLs, and caching the results of name lookups after they should have expired.</li> <li>Some apps do DNS lookups only once and cache the results indefinitely.</li> <li>Even if apps and libraries did proper re-resolution, the low or zero TTLs on the DNS records could impose a high load on DNS that then becomes difficult to manage.</li> </ul> <p>Later in this page you can read about various kube-proxy implementations work. Overall, you should note that, when running <code>kube-proxy</code>, kernel level rules may be modified (for example, iptables rules might get created), which won't get cleaned up, in some cases until you reboot. Thus, running kube-proxy is something that should only be done by an administrator which understands the consequences of having a low level, privileged network proxying service on a computer. Although the <code>kube-proxy</code> executable supports a <code>cleanup</code> function, this function is not an official feature and thus is only available to use as-is.</p> <h3 id="configuration">Configuration</h3> <p>Note that the kube-proxy starts up in different modes, which are determined by its configuration.</p> <ul> <li>The kube-proxy's configuration is done via a ConfigMap, and the ConfigMap for kube-proxy effectively deprecates the behaviour for almost all of the flags for the kube-proxy.</li> <li>The ConfigMap for the kube-proxy does not support live reloading of configuration.</li> <li>The ConfigMap parameters for the kube-proxy cannot all be validated and verified on startup. For example, if your operating system doesn't allow you to run iptables commands, the standard kernel kube-proxy implementation will not work. Likewise, if you have an operating system which doesn't support <code>netsh</code>, it will not run in Windows userspace mode.</li> </ul> <h3 id="proxy-mode-userspace">User space proxy mode</h3> <p>In this (legacy) mode, kube-proxy watches the Kubernetes control plane for the addition and removal of Service and Endpoint objects. For each Service it opens a port (randomly chosen) on the local node. Any connections to this "proxy port" are proxied to one of the Service's backend Pods (as reported via Endpoints). kube-proxy takes the <code>SessionAffinity</code> setting of the Service into account when deciding which backend Pod to use.</p> <p>Lastly, the user-space proxy installs iptables rules which capture traffic to the Service's <code>clusterIP</code> (which is virtual) and <code>port</code>. The rules redirect that traffic to the proxy port which proxies the backend Pod.</p> <p>By default, kube-proxy in userspace mode chooses a backend via a round-robin algorithm.</p> <p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE5LjIuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIKCSBpZD0ic3ZnMiIgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvdXNyL2xvY2FsL2dvb2dsZS9ob21lL3Rob2NraW4vc3JjL2t1YmVybmV0ZXMvZG9jcy9zZXJ2aWNlc19vdmVydmlldy5wbmciIGlua3NjYXBlOmV4cG9ydC14ZHBpPSI3Ni45MTAwMDQiIGlua3NjYXBlOmV4cG9ydC15ZHBpPSI3Ni45MTAwMDQiIGlua3NjYXBlOnZlcnNpb249IjAuNDguNCByOTkzOSIgc29kaXBvZGk6ZG9jbmFtZT0ic2VydmljZXMtdXNlcnNwYWNlLW92ZXJ2aWV3LnN2ZyIgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCgkgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjAgMCA3NjMgNDI5IgoJIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDc2MyA0Mjk7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1LjE5NjU7fQoJLnN0MXtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NS4xOTY1O3N0cm9rZS1saW5lY2FwOnJvdW5kO30KCS5zdDJ7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O30KCS5zdDN7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjQuNzAzNjtzdHJva2UtbGluZWNhcDpyb3VuZDt9Cgkuc3Q0e2ZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NC4yOTI4O30KCS5zdDV7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjQuMjkyODtzdHJva2UtbGluZWNhcDpyb3VuZDt9Cgkuc3Q2e2ZpbGw6Izg1QkZGMTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7fQoJLnN0N3tmb250LWZhbWlseTonQXJpYWxNVCc7fQoJLnN0OHtmb250LXNpemU6MzJweDt9Cgkuc3Q5e2ZvbnQtc2l6ZToyNHB4O30KCS5zdDEwe2ZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS44ODE0O30KCS5zdDExe3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjg4MTQ7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7fQoJLnN0MTJ7ZmlsbDojRjFDQjg1O3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDt9Cgkuc3QxM3tmaWxsOiNCOUYxODU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO30KCS5zdDE0e2ZpbGw6I0VEQzFGODtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7fQoJLnN0MTV7ZmlsbDojRkZFNjgwO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjc3ODc7fQoJLnN0MTZ7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjkyMzk7fQoJLnN0MTd7Zm9udC1mYW1pbHk6J015cmlhZFByby1SZWd1bGFyJzt9Cgkuc3QxOHtmb250LXNpemU6NDBweDt9Cjwvc3R5bGU+Cjxzb2RpcG9kaTpuYW1lZHZpZXcgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IiBib3JkZXJvcGFjaXR5PSIxLjAiIGlkPSJiYXNlIiBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiIGlua3NjYXBlOmN4PSIyOTEuOTI1NCIgaW5rc2NhcGU6Y3k9IjM5Mi4zMDU0NSIgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IiBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIiBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIiBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4MjIiIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjAiIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTU1MiIgaW5rc2NhcGU6d2luZG93LXg9IjQ2IiBpbmtzY2FwZTp3aW5kb3cteT0iNDciIGlua3NjYXBlOnpvb209IjEuMDMxODM2OSIgcGFnZWNvbG9yPSIjZmZmZmZmIiBzaG93Z3JpZD0iZmFsc2UiPgoJPC9zb2RpcG9kaTpuYW1lZHZpZXc+CjxnIGlkPSJsYXllcjEiIGlua3NjYXBlOmdyb3VwbW9kZT0ibGF5ZXIiIGlua3NjYXBlOmxhYmVsPSJMYXllciAxIj4KCTxnIGlkPSJnNDE3OC0zLTgiIHRyYW5zZm9ybT0ibWF0cml4KDAsLTEsLTAuOTI1Nzg5NjIsMCw5MzYuNDQ0MTMsMTAyOS4yNjg2KSI+CgkJPHBhdGggaWQ9InBhdGg0MTc0LTMtNCIgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgY2xhc3M9InN0MCIgZD0iTTgxMy4xLDc0Ni4xYzAtNzEuMywwLTcxLjMsMC03MS4zIi8+CgkJCgkJCTxwYXRoIGlkPSJwYXRoNDE3Ni05LTAiIGlua3NjYXBlOmZsYXRzaWRlZD0idHJ1ZSIgaW5rc2NhcGU6cmFuZG9taXplZD0iMCIgaW5rc2NhcGU6cm91bmRlZD0iMCIgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSItMi41IiBzb2RpcG9kaTphcmcxPSIyLjYxNzk5MzkiIHNvZGlwb2RpOmFyZzI9IjMuNjY1MTkxNCIgc29kaXBvZGk6Y3g9IjMwOC44NTcxNSIgc29kaXBvZGk6Y3k9Ijc1My43OTA3NyIgc29kaXBvZGk6cjE9IjEwIiBzb2RpcG9kaTpyMj0iNSIgc29kaXBvZGk6c2lkZXM9IjMiIHNvZGlwb2RpOnR5cGU9InN0YXIiIGNsYXNzPSJzdDEiIGQ9IgoJCQlNODA0LjgsNjg0LjFsOC43LTE1bDguNywxNUg4MDQuOHoiLz4KCTwvZz4KCTxnIGlkPSJnNDMyNCIgdHJhbnNmb3JtPSJtYXRyaXgoMC45NjU5MjU4MywwLjI1ODgxOTA1LDAuMjU4ODE5MDUsLTAuOTY1OTI1ODMsLTM4LjgxMDc0NCwxMDc2LjIzOCkiPgoJCTxwYXRoIGlkPSJwYXRoNDE3NC0zLTIiIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIGNsYXNzPSJzdDIiIGQ9Ik0yMjcuOSw5NTkuN2MtMTAyLTExMy44LTEwMi0xMTMuOC0xMDItMTEzLjgiLz4KCQkKCQkJPHBhdGggaWQ9InBhdGg0MTc2LTktOSIgaW5rc2NhcGU6ZmxhdHNpZGVkPSJ0cnVlIiBpbmtzY2FwZTpyYW5kb21pemVkPSIwIiBpbmtzY2FwZTpyb3VuZGVkPSIwIiBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXk9Ii0yLjUiIHNvZGlwb2RpOmFyZzE9IjIuNjE3OTkzOSIgc29kaXBvZGk6YXJnMj0iMy42NjUxOTE0IiBzb2RpcG9kaTpjeD0iMzA4Ljg1NzE1IiBzb2RpcG9kaTpjeT0iNzUzLjc5MDc3IiBzb2RpcG9kaTpyMT0iMTAiIHNvZGlwb2RpOnIyPSI1IiBzb2RpcG9kaTpzaWRlcz0iMyIgc29kaXBvZGk6dHlwZT0ic3RhciIgY2xhc3M9InN0MyIgZD0iCgkJCU0xMTguOCw4NTIuOGwtNC44LTE4LjRsMTcuOCw2LjlMMTE4LjgsODUyLjh6Ii8+Cgk8L2c+Cgk8ZyBpZD0iZzQzMjQtOCIgdHJhbnNmb3JtPSJtYXRyaXgoLTAuOTY1OTI1ODMsMC4yNTg4MTkwNSwtMC4yNTg4MTkwNSwtMC45NjU5MjU4Myw4ODguMzI5NjQsMTA3Ni4yMzgpIj4KCQk8cGF0aCBpZD0icGF0aDQxNzQtMy0yLTciIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIGNsYXNzPSJzdDIiIGQ9Ik0yMDYuNiw5NTRjLTEwMi0xMTMuOC0xMDItMTEzLjgtMTAyLTExMy44Ii8+CgkJCgkJCTxwYXRoIGlkPSJwYXRoNDE3Ni05LTktMyIgaW5rc2NhcGU6ZmxhdHNpZGVkPSJ0cnVlIiBpbmtzY2FwZTpyYW5kb21pemVkPSIwIiBpbmtzY2FwZTpyb3VuZGVkPSIwIiBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXk9Ii0yLjUiIHNvZGlwb2RpOmFyZzE9IjIuNjE3OTkzOSIgc29kaXBvZGk6YXJnMj0iMy42NjUxOTE0IiBzb2RpcG9kaTpjeD0iMzA4Ljg1NzE1IiBzb2RpcG9kaTpjeT0iNzUzLjc5MDc3IiBzb2RpcG9kaTpyMT0iMTAiIHNvZGlwb2RpOnIyPSI1IiBzb2RpcG9kaTpzaWRlcz0iMyIgc29kaXBvZGk6dHlwZT0ic3RhciIgY2xhc3M9InN0MyIgZD0iCgkJCU05Ny42LDg0Ny4xbC00LjgtMTguNGwxNy44LDYuOUw5Ny42LDg0Ny4xeiIvPgoJPC9nPgoJPGcgaWQ9Imc0MTc4LTMtOSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTEuMzU2NjA2Niw3OS4yNDAwMTQsMTY5OS41NDMxKSI+CgkJPHBhdGggaWQ9InBhdGg0MTc0LTMtOCIgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgY2xhc3M9InN0NCIgZD0iTTM0OC4xLDExMDguOGMwLTcxLjMsMC03MS4zLDAtNzEuMyIvPgoJCQoJCQk8cGF0aCBpZD0icGF0aDQxNzYtOS01IiBpbmtzY2FwZTpmbGF0c2lkZWQ9InRydWUiIGlua3NjYXBlOnJhbmRvbWl6ZWQ9IjAiIGlua3NjYXBlOnJvdW5kZWQ9IjAiIGlua3NjYXBlOnRyYW5zZm9ybS1jZW50ZXIteT0iLTIuNSIgc29kaXBvZGk6YXJnMT0iMi42MTc5OTM5IiBzb2RpcG9kaTphcmcyPSIzLjY2NTE5MTQiIHNvZGlwb2RpOmN4PSIzMDguODU3MTUiIHNvZGlwb2RpOmN5PSI3NTMuNzkwNzciIHNvZGlwb2RpOnIxPSIxMCIgc29kaXBvZGk6cjI9IjUiIHNvZGlwb2RpOnNpZGVzPSIzIiBzb2RpcG9kaTp0eXBlPSJzdGFyIiBjbGFzcz0ic3Q1IiBkPSIKCQkJTTMzOS44LDEwNDYuOGw4LjctMTVsOC43LDE1SDMzOS44eiIvPgoJPC9nPgoJPGcgaWQ9ImczOTM3IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMS42NDM1NDQsNzE5LjczMDc0KSI+CgkJPGcgaWQ9ImczODY4IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjg4NzkyMzM3LDAsMCwxLDQzLjUwOTc1LDYuNTI1MDAwMWUtNikiPgoJCQk8cmVjdCBpZD0icmVjdDI5ODUiIHg9IjQyLjQiIHk9Ii00MTUuMSIgY2xhc3M9InN0NiIgd2lkdGg9IjIyNC4zIiBoZWlnaHQ9IjExOC42Ii8+CgkJCTxnIGlkPSJnMzg2MSI+CgkJCQk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDQ5LjA5OTEgLTM4NC4xNTQ1KSIgY2xhc3M9InN0NyBzdDgiPkJhY2tlbmQgUG9kIDE8L3RleHQ+CgkJCQk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDQ5LjUzMTMgLTM0NS4wNjY3KSIgY2xhc3M9InN0NyBzdDkiPmxhYmVsczogYXBwPU15QXBwPC90ZXh0PgoJCQkJPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSA0OS41MzEzIC0zMTUuMDY2NykiIGNsYXNzPSJzdDcgc3Q5Ij5wb3J0OiA5Mzc2PC90ZXh0PgoJCQk8L2c+CgkJPC9nPgoJCTxnIGlkPSJnMzg2OC03IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjg4NzkyMzM3LDAsMCwxLDI2Mi4wMDIzMSw2LjUyNTAwMDFlLTYpIj4KCQkJPHJlY3QgaWQ9InJlY3QyOTg1LTEiIHg9IjQyLjQiIHk9Ii00MTUuMSIgY2xhc3M9InN0NiIgd2lkdGg9IjIyNC4zIiBoZWlnaHQ9IjExOC42Ii8+CgkJCTxnIGlkPSJnMzg2MS05Ij4KCQkJCTx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgNDkuMDk5MiAtMzg0LjE1NDUpIiBjbGFzcz0ic3Q3IHN0OCI+QmFja2VuZCBQb2QgMjwvdGV4dD4KCQkJCTx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgNDkuNTMxNSAtMzQ1LjA2NjcpIiBjbGFzcz0ic3Q3IHN0OSI+bGFiZWxzOiBhcHA9TXlBcHA8L3RleHQ+CgkJCQk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDQ5LjUzMTUgLTMxNS4wNjY3KSIgY2xhc3M9InN0NyBzdDkiPnBvcnQ6IDkzNzY8L3RleHQ+CgkJCTwvZz4KCQk8L2c+CgkJPGcgaWQ9ImczODY4LTMiIHRyYW5zZm9ybT0ibWF0cml4KDAuODg3OTIzMzcsMCwwLDEsNDgwLjQ5NDg5LDYuNTI1MDAwMWUtNikiPgoJCQk8cmVjdCBpZD0icmVjdDI5ODUtMiIgeD0iNDIuNCIgeT0iLTQxNS4xIiBjbGFzcz0ic3Q2IiB3aWR0aD0iMjI0LjMiIGhlaWdodD0iMTE4LjYiLz4KCQkJPGcgaWQ9ImczODYxLTMiPgoJCQkJPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSA0OS4wOTg4IC0zODQuMTU0NSkiIGNsYXNzPSJzdDcgc3Q4Ij5CYWNrZW5kIFBvZCAzPC90ZXh0PgoJCQkJPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSA0OS41MzEgLTM0NS4wNjY3KSIgY2xhc3M9InN0NyBzdDkiPmxhYmVsczogYXBwPU15QXBwPC90ZXh0PgoJCQkJPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSA0OS41MzEgLTMxNS4wNjY3KSIgY2xhc3M9InN0NyBzdDkiPnBvcnQ6IDkzNzY8L3RleHQ+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+Cgk8ZyBpZD0iZzQxNzgtMy00IiB0cmFuc2Zvcm09Im1hdHJpeCgtMC44MzA1MjQ5LC0wLjU1Njk4MTUsMC42MjkzOTMzMiwtMC45Mzg0OTk0NSwzNjUuNTQ4NTUsMTQ4Ny44Mzk2KSI+CgkJPHBhdGggaWQ9InBhdGg0MTc0LTMtOSIgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgY2xhc3M9InN0MTAiIGQ9Ik01OTMuMSwxMTEzLjJjMC03MS4zLDAtNzEuMywwLTcxLjMiLz4KCQkKCQkJPHBhdGggaWQ9InBhdGg0MTc2LTktMSIgaW5rc2NhcGU6ZmxhdHNpZGVkPSJ0cnVlIiBpbmtzY2FwZTpyYW5kb21pemVkPSIwIiBpbmtzY2FwZTpyb3VuZGVkPSIwIiBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXk9Ii0yLjUiIHNvZGlwb2RpOmFyZzE9IjIuNjE3OTkzOSIgc29kaXBvZGk6YXJnMj0iMy42NjUxOTE0IiBzb2RpcG9kaTpjeD0iMzA4Ljg1NzE1IiBzb2RpcG9kaTpjeT0iNzUzLjc5MDc3IiBzb2RpcG9kaTpyMT0iMTAiIHNvZGlwb2RpOnIyPSI1IiBzb2RpcG9kaTpzaWRlcz0iMyIgc29kaXBvZGk6dHlwZT0ic3RhciIgY2xhc3M9InN0MTEiIGQ9IgoJCQlNNTg0LjgsMTA1MS4ybDguNy0xNWw4LjcsMTVMNTg0LjgsMTA1MS4yeiIvPgoJPC9nPgoJPGcgaWQ9Imc0MTc4LTMiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0wLjkyNTc4OTYyLC0xNzAuOTgxMzYsMTI2OC43Njk5KSI+CgkJPHBhdGggaWQ9InBhdGg0MTc0LTMiIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIGNsYXNzPSJzdDAiIGQ9Ik0zNDguMSwxMjcyLjFjMC03MS4zLDAtNzEuMywwLTcxLjMiLz4KCQkKCQkJPHBhdGggaWQ9InBhdGg0MTc2LTkiIGlua3NjYXBlOmZsYXRzaWRlZD0idHJ1ZSIgaW5rc2NhcGU6cmFuZG9taXplZD0iMCIgaW5rc2NhcGU6cm91bmRlZD0iMCIgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSItMi41IiBzb2RpcG9kaTphcmcxPSIyLjYxNzk5MzkiIHNvZGlwb2RpOmFyZzI9IjMuNjY1MTkxNCIgc29kaXBvZGk6Y3g9IjMwOC44NTcxNSIgc29kaXBvZGk6Y3k9Ijc1My43OTA3NyIgc29kaXBvZGk6cjE9IjEwIiBzb2RpcG9kaTpyMj0iNSIgc29kaXBvZGk6c2lkZXM9IjMiIHNvZGlwb2RpOnR5cGU9InN0YXIiIGNsYXNzPSJzdDEiIGQ9IgoJCQlNMzM5LjgsMTIxMC4xbDguNy0xNWw4LjcsMTVIMzM5Ljh6Ii8+Cgk8L2c+Cgk8ZyBpZD0iZzQwOTAiIHRyYW5zZm9ybT0ibWF0cml4KDAuODkwNjcwMDMsMCwwLDEsLTEzMC45NzI5NSwtMTcyLjM2Mjg2KSI+CgkJPHJlY3QgaWQ9InJlY3QyOTg1LTQiIHg9IjIzNC4xIiB5PSIyMjguNSIgY2xhc3M9InN0MTIiIHdpZHRoPSIyMjQuMyIgaGVpZ2h0PSI1OC42Ii8+CgkJPGcgaWQ9ImczODYxLTYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIxNy42MTc3LDY1Mi44MjUxNikiPgoJCQk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDc5LjkyNTEgLTM4NC4yMzQ3KSIgY2xhc3M9InN0NyBzdDgiPkNsaWVudCA8L3RleHQ+CgkJPC9nPgoJPC9nPgoJPGcgaWQ9Imc0MTY4IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjg5MDY3MDAzLDAsMCwxLDI2My42NTkyMiw3NC4yMDU0NzMpIj4KCQk8cmVjdCBpZD0icmVjdDI5ODUtNC0wIiB4PSI2My4xIiB5PSIxMTIuOCIgY2xhc3M9InN0MTMiIHdpZHRoPSIyNTAiIGhlaWdodD0iNTguNiIvPgoJCTxnIGlkPSJnMzg2MS02LTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM0Ljc0NzQzMyw1MzQuMjYyODcpIj4KCQkJPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSA3Mi44MDUyIC0zODMuNzg2NykiIGNsYXNzPSJzdDcgc3Q4Ij5rdWJlLXByb3h5PC90ZXh0PgoJCTwvZz4KCTwvZz4KCTxnIGlkPSJnNDE2OC01IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0NzguODIzMzYsMjcuMjkxOTY1KSI+CgkJPGcgaWQ9Imc0MjM4IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMi4wODc0MjksLTg2LjM0MTc3KSI+CgkJCTxyZWN0IGlkPSJyZWN0Mjk4NS00LTAtNiIgeD0iNjIuOSIgeT0iMTEyLjgiIGNsYXNzPSJzdDE0IiB3aWR0aD0iMTkxLjgiIGhlaWdodD0iNTguNiIvPgoJCQk8ZyBpZD0iZzM4NjEtNi0yLTYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM5LjEwNzQyOSw1MzQuMjYyODcpIj4KCQkJCTx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgNDcuNzEwOCAtMzg0LjE1NDQpIiBjbGFzcz0ic3Q3IHN0OCI+YXBpc2VydmVyPC90ZXh0PgoJCQk8L2c+CgkJPC9nPgoJPC9nPgoJPHBhdGggaWQ9InBhdGgzODg0IiBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiBjbGFzcz0ic3QxNSIgZD0iTTEyOS42LDE1My4xYy0xNC41LDAtMjcsOC42LTMzLDIxLjIKCQljLTUtMC45LTEwLjMtMS40LTE1LjgtMS40Yy0zNC4zLDAtNjIuMiwxOS4xLTYyLjIsNDIuNnMyNy44LDQyLjYsNjIuMiw0Mi42YzE2LjksMCwzMi4yLTQuNiw0My40LTEyLjJjNy40LDE2LjMsMzQsMjguMyw2NS43LDI4LjMKCQljMzMuNSwwLDYxLjQtMTMuNCw2Ni44LTMxLjFjMTctNS4zLDI4LjYtMTUuNywyOC42LTI3LjdjMC0xNy4zLTI0LjQtMzEuNC01NC40LTMxLjRjLTguNSwwLTE2LjUsMS4xLTIzLjYsMy4xCgkJYy0yLTEwLjUtMTQuOC0xOC42LTMwLjMtMTguNmMtNS44LDAtMTEuMiwxLjItMTUuOSwzLjFDMTU0LjgsMTYwLjYsMTQzLDE1My4xLDEyOS42LDE1My4xTDEyOS42LDE1My4xeiIvPgoJPGcgaWQ9ImczODYxLTYtMjgiIHRyYW5zZm9ybT0ibWF0cml4KDAuODkwNjcwMDMsMCwwLDEsLTMxLjA5MTgzNiw1ODcuNjc5MDQpIj4KCQk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDEwNi4wMzk2IC0zODYuMTczMikiIGNsYXNzPSJzdDcgc3Q4Ij5jbHVzdGVySVA8L3RleHQ+CgkJPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAxMDYuMDM5NiAtMzQ2LjE3MzIpIiBjbGFzcz0ic3Q3IHN0OCI+KGlwdGFibGVzKSA8L3RleHQ+Cgk8L2c+Cgk8cmVjdCBpZD0icmVjdDM4ODkiIHg9IjcuMSIgeT0iOC40IiBjbGFzcz0ic3QxNiIgd2lkdGg9IjU0NC43IiBoZWlnaHQ9IjI2Ny42Ii8+Cgk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDExLjk2OTEgNDUuMjcwNSkiIGNsYXNzPSJzdDE3IHN0MTgiPk5vZGU8L3RleHQ+CjwvZz4KPC9zdmc+Cg==" alt="Services overview diagram for userspace proxy"></p> <h3 id="proxy-mode-iptables">
<code>iptables</code> proxy mode</h3> <p>In this mode, kube-proxy watches the Kubernetes control plane for the addition and removal of Service and Endpoint objects. For each Service, it installs iptables rules, which capture traffic to the Service's <code>clusterIP</code> and <code>port</code>, and redirect that traffic to one of the Service's backend sets. For each Endpoint object, it installs iptables rules which select a backend Pod.</p> <p>By default, kube-proxy in iptables mode chooses a backend at random.</p> <p>Using iptables to handle traffic has a lower system overhead, because traffic is handled by Linux netfilter without the need to switch between userspace and the kernel space. This approach is also likely to be more reliable.</p> <p>If kube-proxy is running in iptables mode and the first Pod that's selected does not respond, the connection fails. This is different from userspace mode: in that scenario, kube-proxy would detect that the connection to the first Pod had failed and would automatically retry with a different backend Pod.</p> <p>You can use Pod <a href="../../workloads/pods/pod-lifecycle/index#container-probes">readiness probes</a> to verify that backend Pods are working OK, so that kube-proxy in iptables mode only sees backends that test out as healthy. Doing this means you avoid having traffic sent via kube-proxy to a Pod that's known to have failed.</p> <p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE5LjIuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIKCSBpZD0ic3ZnMiIgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvdXNyL2xvY2FsL2dvb2dsZS9ob21lL3Rob2NraW4vc3JjL2t1YmVybmV0ZXMvZG9jcy9zZXJ2aWNlcy11c2Vyc3BhY2Utb3ZlcnZpZXcucG5nIiBpbmtzY2FwZTpleHBvcnQteGRwaT0iNzYuOTEwMDA0IiBpbmtzY2FwZTpleHBvcnQteWRwaT0iNzYuOTEwMDA0IiBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ4LjQgcjk5MzkiIHNvZGlwb2RpOmRvY25hbWU9InNlcnZpY2VzLWlwdGFibGVzLW92ZXJ2aWV3LnN2ZyIgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCgkgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjAgMCA2NTYgNDg2IgoJIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDY1NiA0ODY7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjg0MjU7fQoJLnN0MXtmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjIuMDc4Njt9Cgkuc3Qye3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA3ODY7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7fQoJLnN0M3tmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjU7fQoJLnN0NHtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NC43MDM2O3N0cm9rZS1saW5lY2FwOnJvdW5kO30KCS5zdDV7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo0LjI5Mjg7fQoJLnN0NntzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NC4yOTI4O3N0cm9rZS1saW5lY2FwOnJvdW5kO30KCS5zdDd7ZmlsbDojODVCRkYxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDt9Cgkuc3Q4e2ZvbnQtZmFtaWx5OidBcmlhbE1UJzt9Cgkuc3Q5e2ZvbnQtc2l6ZTozMnB4O30KCS5zdDEwe2ZvbnQtc2l6ZToyNHB4O30KCS5zdDExe2ZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NS4xOTY1O30KCS5zdDEye3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1LjE5NjU7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7fQoJLnN0MTN7ZmlsbDojRjFDQjg1O3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDt9Cgkuc3QxNHtmaWxsOiNCOUYxODU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO30KCS5zdDE1e2ZpbGw6I0VEQzFGODtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7fQoJLnN0MTZ7ZmlsbDojRkZFNjgwO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjc3ODc7fQoJLnN0MTd7Zm9udC1mYW1pbHk6J015cmlhZFByby1SZWd1bGFyJzt9Cgkuc3QxOHtmb250LXNpemU6NDBweDt9Cjwvc3R5bGU+Cjxzb2RpcG9kaTpuYW1lZHZpZXcgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IiBib3JkZXJvcGFjaXR5PSIxLjAiIGlkPSJiYXNlIiBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiIGlua3NjYXBlOmN4PSIxMTUuOTIxOCIgaW5rc2NhcGU6Y3k9IjM5Mi4zMDU0NSIgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IiBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIiBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIiBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4MjIiIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjAiIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTU1MiIgaW5rc2NhcGU6d2luZG93LXg9IjIwMyIgaW5rc2NhcGU6d2luZG93LXk9IjUwIiBpbmtzY2FwZTp6b29tPSIxLjAzMTgzNjkiIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIgc2hvd2dyaWQ9ImZhbHNlIj4KCTwvc29kaXBvZGk6bmFtZWR2aWV3Pgo8ZyBpZD0ibGF5ZXIxIiBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIiBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSI+Cgk8cmVjdCBpZD0icmVjdDMxMTUiIHg9IjEwNC4zIiB5PSI3Mi41IiBjbGFzcz0ic3QwIiB3aWR0aD0iNTQ1LjgiIGhlaWdodD0iMjUzLjEiLz4KCTxnIGlkPSJnNDE3OC0zLTAiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0wLjkyNTc4OTYyLDE1LjMwMzk0OCwxMTkzLjE5OTYpIj4KCQk8cGF0aCBpZD0icGF0aDQxNzQtMy03IiBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiBjbGFzcz0ic3QxIiBkPSJNNDg1LjEsMTI2NC41YzAtNzEuMywwLTcxLjMsMC03MS4zIi8+CgkJCgkJCTxwYXRoIGlkPSJwYXRoNDE3Ni05LTEiIGlua3NjYXBlOmZsYXRzaWRlZD0idHJ1ZSIgaW5rc2NhcGU6cmFuZG9taXplZD0iMCIgaW5rc2NhcGU6cm91bmRlZD0iMCIgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSItMi41IiBzb2RpcG9kaTphcmcxPSIyLjYxNzk5MzkiIHNvZGlwb2RpOmFyZzI9IjMuNjY1MTkxNCIgc29kaXBvZGk6Y3g9IjMwOC44NTcxNSIgc29kaXBvZGk6Y3k9Ijc1My43OTA3NyIgc29kaXBvZGk6cjE9IjEwIiBzb2RpcG9kaTpyMj0iNSIgc29kaXBvZGk6c2lkZXM9IjMiIHNvZGlwb2RpOnR5cGU9InN0YXIiIGNsYXNzPSJzdDIiIGQ9IgoJCQlNNDc2LjgsMTIwMi41bDguNy0xNWw4LjcsMTVINDc2Ljh6Ii8+Cgk8L2c+CgkKCQk8ZyBpZD0iZzQxNzgtMy04IiB0cmFuc2Zvcm09Im1hdHJpeCgtMC44MzIxMjIxMSwtMS4xMjMxNTE1LDAuODk1NzAwOTIsLTAuODk0MzA3NzIsLTcyLjk0MjIwNiwxNjc4LjMxNjEpIiBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXg9Ijg0LjA5ODc0MSIgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSIxLjQ1NzI3ODdlLTA1Ij4KCQk8cGF0aCBpZD0icGF0aDQxNzQtMy00IiBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiBjbGFzcz0ic3QxIiBkPSJNNTAxLjUsMTA3NS45YzAtNzEuMywwLTcxLjMsMC03MS4zIi8+CgkJCgkJCTxwYXRoIGlkPSJwYXRoNDE3Ni05LTAiIGlua3NjYXBlOmZsYXRzaWRlZD0idHJ1ZSIgaW5rc2NhcGU6cmFuZG9taXplZD0iMCIgaW5rc2NhcGU6cm91bmRlZD0iMCIgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSItMi41IiBzb2RpcG9kaTphcmcxPSIyLjYxNzk5MzkiIHNvZGlwb2RpOmFyZzI9IjMuNjY1MTkxNCIgc29kaXBvZGk6Y3g9IjMwOC44NTcxNSIgc29kaXBvZGk6Y3k9Ijc1My43OTA3NyIgc29kaXBvZGk6cjE9IjEwIiBzb2RpcG9kaTpyMj0iNSIgc29kaXBvZGk6c2lkZXM9IjMiIHNvZGlwb2RpOnR5cGU9InN0YXIiIGNsYXNzPSJzdDIiIGQ9IgoJCQlNNDkzLjIsMTAxMy45bDguNy0xNWw4LjcsMTVMNDkzLjIsMTAxMy45eiIvPgoJPC9nPgoJPGcgaWQ9Imc0MzI0IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjk2NTkyNTgzLDAuMjU4ODE5MDUsMC4yNTg4MTkwNSwtMC45NjU5MjU4MywtMjcyLjgxMDc0LDExMjYuMjM4KSI+CgkJPHBhdGggaWQ9InBhdGg0MTc0LTMtMiIgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgY2xhc3M9InN0MyIgZD0iTTM2Miw5ODguNEMyNjAsODc0LjYsMjYwLDg3NC42LDI2MCw4NzQuNiIvPgoJCQoJCQk8cGF0aCBpZD0icGF0aDQxNzYtOS05IiBpbmtzY2FwZTpmbGF0c2lkZWQ9InRydWUiIGlua3NjYXBlOnJhbmRvbWl6ZWQ9IjAiIGlua3NjYXBlOnJvdW5kZWQ9IjAiIGlua3NjYXBlOnRyYW5zZm9ybS1jZW50ZXIteT0iLTIuNSIgc29kaXBvZGk6YXJnMT0iMi42MTc5OTM5IiBzb2RpcG9kaTphcmcyPSIzLjY2NTE5MTQiIHNvZGlwb2RpOmN4PSIzMDguODU3MTUiIHNvZGlwb2RpOmN5PSI3NTMuNzkwNzciIHNvZGlwb2RpOnIxPSIxMCIgc29kaXBvZGk6cjI9IjUiIHNvZGlwb2RpOnNpZGVzPSIzIiBzb2RpcG9kaTp0eXBlPSJzdGFyIiBjbGFzcz0ic3Q0IiBkPSIKCQkJTTI1Myw4ODEuNWwtNC44LTE4LjRsMTcuOCw2LjlMMjUzLDg4MS41eiIvPgoJPC9nPgoJPGcgaWQ9Imc0MzI0LTgiIHRyYW5zZm9ybT0ibWF0cml4KC0wLjk2NTkyNTgzLDAuMjU4ODE5MDUsLTAuMjU4ODE5MDUsLTAuOTY1OTI1ODMsNjU0LjMyOTY0LDExMjYuMjM4KSI+CgkJPHBhdGggaWQ9InBhdGg0MTc0LTMtMi03IiBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiBjbGFzcz0ic3QzIiBkPSJNNzYuMSw5MTEuOEMtMjUuOSw3OTgtMjUuOSw3OTgtMjUuOSw3OTgiLz4KCQkKCQkJPHBhdGggaWQ9InBhdGg0MTc2LTktOS0zIiBpbmtzY2FwZTpmbGF0c2lkZWQ9InRydWUiIGlua3NjYXBlOnJhbmRvbWl6ZWQ9IjAiIGlua3NjYXBlOnJvdW5kZWQ9IjAiIGlua3NjYXBlOnRyYW5zZm9ybS1jZW50ZXIteT0iLTIuNSIgc29kaXBvZGk6YXJnMT0iMi42MTc5OTM5IiBzb2RpcG9kaTphcmcyPSIzLjY2NTE5MTQiIHNvZGlwb2RpOmN4PSIzMDguODU3MTUiIHNvZGlwb2RpOmN5PSI3NTMuNzkwNzciIHNvZGlwb2RpOnIxPSIxMCIgc29kaXBvZGk6cjI9IjUiIHNvZGlwb2RpOnNpZGVzPSIzIiBzb2RpcG9kaTp0eXBlPSJzdGFyIiBjbGFzcz0ic3Q0IiBkPSIKCQkJTS0zMi45LDgwNC45bC00LjgtMTguNGwxNy44LDYuOUwtMzIuOSw4MDQuOXoiLz4KCTwvZz4KCTxnIGlkPSJnNDE3OC0zLTkiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLjM1NjYwNjYsLTE1NC43NTk5OSwxNzQ5LjU0MzEpIj4KCQk8cGF0aCBpZD0icGF0aDQxNzQtMy04IiBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiBjbGFzcz0ic3Q1IiBkPSJNNDg1LjEsMTEwMy43YzAtNzEuMywwLTcxLjMsMC03MS4zIi8+CgkJCgkJCTxwYXRoIGlkPSJwYXRoNDE3Ni05LTUiIGlua3NjYXBlOmZsYXRzaWRlZD0idHJ1ZSIgaW5rc2NhcGU6cmFuZG9taXplZD0iMCIgaW5rc2NhcGU6cm91bmRlZD0iMCIgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSItMi41IiBzb2RpcG9kaTphcmcxPSIyLjYxNzk5MzkiIHNvZGlwb2RpOmFyZzI9IjMuNjY1MTkxNCIgc29kaXBvZGk6Y3g9IjMwOC44NTcxNSIgc29kaXBvZGk6Y3k9Ijc1My43OTA3NyIgc29kaXBvZGk6cjE9IjEwIiBzb2RpcG9kaTpyMj0iNSIgc29kaXBvZGk6c2lkZXM9IjMiIHNvZGlwb2RpOnR5cGU9InN0YXIiIGNsYXNzPSJzdDYiIGQ9IgoJCQlNNDc2LjgsMTA0MS42bDguNy0xNWw4LjcsMTVINDc2Ljh6Ii8+Cgk8L2c+Cgk8ZyBpZD0iZzM5MzciIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMTIuMzU2NDYsNzY5LjczMDc0KSI+CgkJPGcgaWQ9ImczODY4IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjg4NzkyMzM3LDAsMCwxLDQzLjUwOTc1LDYuNTI1MDAwMWUtNikiPgoJCQk8cmVjdCBpZD0icmVjdDI5ODUiIHg9IjE5Ni43IiB5PSItNDA4LjEiIGNsYXNzPSJzdDciIHdpZHRoPSIyMjQuMyIgaGVpZ2h0PSIxMTguNiIvPgoJCQk8ZyBpZD0iZzM4NjEiPgoJCQkJPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAyMDMuMzkxOCAtMzc3LjE1NDUpIiBjbGFzcz0ic3Q4IHN0OSI+QmFja2VuZCBQb2QgMTwvdGV4dD4KCQkJCTx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMjAzLjgyNCAtMzM4LjA2NjcpIiBjbGFzcz0ic3Q4IHN0MTAiPmxhYmVsczogYXBwPU15QXBwPC90ZXh0PgoJCQkJPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAyMDMuODI0IC0zMDguMDY2NykiIGNsYXNzPSJzdDggc3QxMCI+cG9ydDogOTM3NjwvdGV4dD4KCQkJPC9nPgoJCTwvZz4KCQk8ZyBpZD0iZzM4NjgtNyIgdHJhbnNmb3JtPSJtYXRyaXgoMC44ODc5MjMzNywwLDAsMSwyNjIuMDAyMzEsNi41MjUwMDAxZS02KSI+CgkJCTxyZWN0IGlkPSJyZWN0Mjk4NS0xIiB4PSIxOTYuNyIgeT0iLTQwOC4xIiBjbGFzcz0ic3Q3IiB3aWR0aD0iMjI0LjMiIGhlaWdodD0iMTE4LjYiLz4KCQkJPGcgaWQ9ImczODYxLTkiPgoJCQkJPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAyMDMuMzkxOSAtMzc3LjE1NDUpIiBjbGFzcz0ic3Q4IHN0OSI+QmFja2VuZCBQb2QgMjwvdGV4dD4KCQkJCTx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMjAzLjgyNDEgLTMzOC4wNjY3KSIgY2xhc3M9InN0OCBzdDEwIj5sYWJlbHM6IGFwcD1NeUFwcDwvdGV4dD4KCQkJCTx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMjAzLjgyNDEgLTMwOC4wNjY3KSIgY2xhc3M9InN0OCBzdDEwIj5wb3J0OiA5Mzc2PC90ZXh0PgoJCQk8L2c+CgkJPC9nPgoJCTxnIGlkPSJnMzg2OC0zIiB0cmFuc2Zvcm09Im1hdHJpeCgwLjg4NzkyMzM3LDAsMCwxLDQ4MC40OTQ4OSw2LjUyNTAwMDFlLTYpIj4KCQkJPHJlY3QgaWQ9InJlY3QyOTg1LTIiIHg9IjE5Ni43IiB5PSItNDA4LjEiIGNsYXNzPSJzdDciIHdpZHRoPSIyMjQuMyIgaGVpZ2h0PSIxMTguNiIvPgoJCQk8ZyBpZD0iZzM4NjEtMyI+CgkJCQk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDIwMy4zOTIgLTM3Ny4xNTQ1KSIgY2xhc3M9InN0OCBzdDkiPkJhY2tlbmQgUG9kIDM8L3RleHQ+CgkJCQk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDIwMy44MjM3IC0zMzguMDY2NykiIGNsYXNzPSJzdDggc3QxMCI+bGFiZWxzOiBhcHA9TXlBcHA8L3RleHQ+CgkJCQk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDIwMy44MjM3IC0zMDguMDY2NykiIGNsYXNzPSJzdDggc3QxMCI+cG9ydDogOTM3NjwvdGV4dD4KCQkJPC9nPgoJCTwvZz4KCTwvZz4KCTxnIGlkPSJnNDE3OC0zIiB0cmFuc2Zvcm09Im1hdHJpeCgwLjkxMTkyNjIzLC0wLjQxMDM1NDE4LC0wLjM3OTkwMTY0LC0wLjg0NDI1MTg0LDExMy42MDQ1MywxMzg1LjQwMDkpIj4KCQk8cGF0aCBpZD0icGF0aDQxNzQtMyIgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgY2xhc3M9InN0MTEiIGQ9Ik02NjQuNiwxMTU0LjNjMC03MS4zLDAtNzEuMywwLTcxLjMiLz4KCQkKCQkJPHBhdGggaWQ9InBhdGg0MTc2LTkiIGlua3NjYXBlOmZsYXRzaWRlZD0idHJ1ZSIgaW5rc2NhcGU6cmFuZG9taXplZD0iMCIgaW5rc2NhcGU6cm91bmRlZD0iMCIgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSItMi41IiBzb2RpcG9kaTphcmcxPSIyLjYxNzk5MzkiIHNvZGlwb2RpOmFyZzI9IjMuNjY1MTkxNCIgc29kaXBvZGk6Y3g9IjMwOC44NTcxNSIgc29kaXBvZGk6Y3k9Ijc1My43OTA3NyIgc29kaXBvZGk6cjE9IjEwIiBzb2RpcG9kaTpyMj0iNSIgc29kaXBvZGk6c2lkZXM9IjMiIHNvZGlwb2RpOnR5cGU9InN0YXIiIGNsYXNzPSJzdDEyIiBkPSIKCQkJTTY1Ni4yLDEwOTIuM2w4LjctMTVsOC43LDE1SDY1Ni4yeiIvPgoJPC9nPgoJPGcgaWQ9Imc0MDkwIiB0cmFuc2Zvcm09Im1hdHJpeCgwLjg5MDY3MDAzLDAsMCwxLC0xOTQuOTcyOTUsLTE0Mi4zNjI4NikiPgoJCTxyZWN0IGlkPSJyZWN0Mjk4NS00IiB4PSIzODgiIHk9IjIzNS41IiBjbGFzcz0ic3QxMyIgd2lkdGg9IjIyNC4zIiBoZWlnaHQ9IjU4LjYiLz4KCQk8ZyBpZD0iZzM4NjEtNiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjE3LjYxNzcsNjUyLjgyNTE2KSI+CgkJCTx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMjMzLjc0MTkgLTM3Ny4yMzQ3KSIgY2xhc3M9InN0OCBzdDkiPkNsaWVudCA8L3RleHQ+CgkJPC9nPgoJPC9nPgoJPGcgaWQ9Imc0MTY4IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjg5MDY3MDAzLDAsMCwxLDE5OS42NTkyMiwtMjQuMjUxNzk4KSI+CgkJPHJlY3QgaWQ9InJlY3QyOTg1LTQtMCIgeD0iMjE2LjkiIHk9IjExOS44IiBjbGFzcz0ic3QxNCIgd2lkdGg9IjI1MCIgaGVpZ2h0PSI1OC42Ii8+CgkJPGcgaWQ9ImczODYxLTYtMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzQuNzQ3NDMzLDUzNC4yNjI4NykiPgoJCQk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDIyNi42MjIgLTM3Ni43ODY1KSIgY2xhc3M9InN0OCBzdDkiPmt1YmUtcHJveHk8L3RleHQ+CgkJPC9nPgoJPC9nPgoJPGcgaWQ9Imc0MTY4LTUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4OC4wNDMzMywtMjkuMDQxODg3KSI+CgkJPGcgaWQ9Imc0MjM4IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMi4wODc0MjksLTg2LjM0MTc3KSI+CgkJCTxyZWN0IGlkPSJyZWN0Mjk4NS00LTAtNiIgeD0iMTk5LjkiIHk9IjExOS44IiBjbGFzcz0ic3QxNSIgd2lkdGg9IjE5MS44IiBoZWlnaHQ9IjU4LjYiLz4KCQkJPGcgaWQ9ImczODYxLTYtMi02IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzOS4xMDc0MjksNTM0LjI2Mjg3KSI+CgkJCQk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDE4NC43MTA5IC0zNzcuMTU0NCkiIGNsYXNzPSJzdDggc3Q5Ij5hcGlzZXJ2ZXI8L3RleHQ+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+Cgk8cGF0aCBpZD0icGF0aDM4ODQiIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIGNsYXNzPSJzdDE2IiBkPSJNMzMyLjUsMjAyYy0xNC41LDAtMjcsOC42LTMzLDIxLjJjLTUtMC45LTEwLjMtMS40LTE1LjgtMS40CgkJYy0zNC4zLDAtNjIuMiwxOS4xLTYyLjIsNDIuNnMyNy44LDQyLjYsNjIuMiw0Mi42YzE2LjksMCwzMi4yLTQuNiw0My40LTEyLjJjNy40LDE2LjMsMzQsMjguMyw2NS43LDI4LjMKCQljMzMuNSwwLDYxLjQtMTMuNCw2Ni44LTMxLjFjMTctNS4zLDI4LjYtMTUuNywyOC42LTI3LjdjMC0xNy4zLTI0LjQtMzEuNC01NC40LTMxLjRjLTguNSwwLTE2LjUsMS4xLTIzLjYsMy4xCgkJYy0yLTEwLjUtMTQuOC0xOC42LTMwLjMtMTguNmMtNS44LDAtMTEuMiwxLjItMTUuOSwzLjFDMzU3LjcsMjA5LjUsMzQ1LjksMjAyLDMzMi41LDIwMkwzMzIuNSwyMDJ6Ii8+Cgk8ZyBpZD0iZzM4NjEtNi0yOCIgdHJhbnNmb3JtPSJtYXRyaXgoMC44OTA2NzAwMywwLDAsMSwzNC44MTAwNTIsNjI5LjYxNzMzKSI+CgkJPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAyNTkuODU2NCAtMzc5LjE3MykiIGNsYXNzPSJzdDggc3Q5Ij5jbHVzdGVySVA8L3RleHQ+CgkJPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAyNTkuODU2NCAtMzM5LjE3MykiIGNsYXNzPSJzdDggc3Q5Ij4oaXB0YWJsZXMpIDwvdGV4dD4KCTwvZz4KCTx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgNTM3LjU5NjUgMzE3LjgxNjMpIiBjbGFzcz0ic3QxNyBzdDE4Ij5Ob2RlPC90ZXh0Pgo8L2c+Cjwvc3ZnPgo=" alt="Services overview diagram for iptables proxy"></p> <h3 id="proxy-mode-ipvs">IPVS proxy mode</h3> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.11 [stable]</code> </div> <p>In <code>ipvs</code> mode, kube-proxy watches Kubernetes Services and Endpoints, calls <code>netlink</code> interface to create IPVS rules accordingly and synchronizes IPVS rules with Kubernetes Services and Endpoints periodically. This control loop ensures that IPVS status matches the desired state. When accessing a Service, IPVS directs traffic to one of the backend Pods.</p> <p>The IPVS proxy mode is based on netfilter hook function that is similar to iptables mode, but uses a hash table as the underlying data structure and works in the kernel space. That means kube-proxy in IPVS mode redirects traffic with lower latency than kube-proxy in iptables mode, with much better performance when synchronising proxy rules. Compared to the other proxy modes, IPVS mode also supports a higher throughput of network traffic.</p> <p>IPVS provides more options for balancing traffic to backend Pods; these are:</p> <ul> <li>
<code>rr</code>: round-robin</li> <li>
<code>lc</code>: least connection (smallest number of open connections)</li> <li>
<code>dh</code>: destination hashing</li> <li>
<code>sh</code>: source hashing</li> <li>
<code>sed</code>: shortest expected delay</li> <li>
<code>nq</code>: never queue</li> </ul> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> <p>To run kube-proxy in IPVS mode, you must make IPVS available on the node before starting kube-proxy.</p> <p>When kube-proxy starts in IPVS proxy mode, it verifies whether IPVS kernel modules are available. If the IPVS kernel modules are not detected, then kube-proxy falls back to running in iptables proxy mode.</p> </div> <p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxOS4yLjEsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIg0KCSBpZD0ic3ZnMiIgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvdXNyL2xvY2FsL2dvb2dsZS9ob21lL3Rob2NraW4vc3JjL2t1YmVybmV0ZXMvZG9jcy9zZXJ2aWNlcy1pcHZzLW92ZXJ2aWV3LnBuZyIgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9Ijc2LjkxMDAwNCIgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9Ijc2LjkxMDAwNCIgaW5rc2NhcGU6dmVyc2lvbj0iMC40OC40IHI5OTM5IiBzb2RpcG9kaTpkb2NuYW1lPSJzZXJ2aWNlcy1pcHZzLW92ZXJ2aWV3LnN2ZyIgeG1sbnM6Y2M9Imh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zIyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciDQoJIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgNjU2IDQ4NiINCgkgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNjU2IDQ4NjsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC44NDI1O30NCgkuc3Qxe2ZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6Mi4wNzg2O30NCgkuc3Qye3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyLjA3ODY7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7fQ0KCS5zdDN7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo1O30NCgkuc3Q0e3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo0LjcwMzY7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7fQ0KCS5zdDV7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDo0LjI5Mjg7fQ0KCS5zdDZ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjQuMjkyODtzdHJva2UtbGluZWNhcDpyb3VuZDt9DQoJLnN0N3tmaWxsOiM4NUJGRjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO30NCgkuc3Q4e2ZvbnQtZmFtaWx5OidBcmlhbE1UJzt9DQoJLnN0OXtmb250LXNpemU6MzJweDt9DQoJLnN0MTB7Zm9udC1zaXplOjI0cHg7fQ0KCS5zdDExe2ZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NS4xOTY1O30NCgkuc3QxMntzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6NS4xOTY1O3N0cm9rZS1saW5lY2FwOnJvdW5kO30NCgkuc3QxM3tmaWxsOiNGMUNCODU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO30NCgkuc3QxNHtmaWxsOiNCOUYxODU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO30NCgkuc3QxNXtmaWxsOiNFREMxRjg7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO30NCgkuc3QxNntmaWxsOiNGRkU2ODA7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuNzc4Nzt9DQoJLnN0MTd7Zm9udC1mYW1pbHk6J015cmlhZFByby1SZWd1bGFyJzt9DQoJLnN0MTh7Zm9udC1zaXplOjQwcHg7fQ0KPC9zdHlsZT4NCjxzb2RpcG9kaTpuYW1lZHZpZXcgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IiBib3JkZXJvcGFjaXR5PSIxLjAiIGlkPSJiYXNlIiBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiIGlua3NjYXBlOmN4PSIxMTUuOTIxOCIgaW5rc2NhcGU6Y3k9IjM5Mi4zMDU0NSIgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IiBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIiBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIiBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI4MjIiIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjAiIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTU1MiIgaW5rc2NhcGU6d2luZG93LXg9IjIwMyIgaW5rc2NhcGU6d2luZG93LXk9IjUwIiBpbmtzY2FwZTp6b29tPSIxLjAzMTgzNjkiIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIgc2hvd2dyaWQ9ImZhbHNlIj4NCgk8L3NvZGlwb2RpOm5hbWVkdmlldz4NCjxnIGlkPSJsYXllcjEiIGlua3NjYXBlOmdyb3VwbW9kZT0ibGF5ZXIiIGlua3NjYXBlOmxhYmVsPSJMYXllciAxIj4NCgk8cmVjdCBpZD0icmVjdDMxMTYiIGhlaWdodD0iMTA1LjgwOTk1IiB3aWR0aD0iNjQ1LjI1NzcyMyIgY2xhc3M9InN0MCIgeT0iMzUwLjM4MTU5MiIgeD0iNQkuMzE4MDk4Ii8+DQoJPHJlY3QgaWQ9InJlY3QzMTE1IiB4PSIxMDQuMyIgeT0iNzIuNSIgY2xhc3M9InN0MCIgd2lkdGg9IjU0NS44IiBoZWlnaHQ9IjI1My4xIi8+DQoJPGcgaWQ9Imc0MTc4LTMtMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsLTAuOTI1Nzg5NjIsMTUuMzAzOTQ4LDExOTMuMTk5NikiPg0KCQk8cGF0aCBpZD0icGF0aDQxNzQtMy03IiBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiBjbGFzcz0ic3QxIiBkPSJNNDg1LjEsMTI2NC41YzAtNzEuMywwLTcxLjMsMC03MS4zIi8+DQoJCQ0KCQkJPHBhdGggaWQ9InBhdGg0MTc2LTktMSIgaW5rc2NhcGU6ZmxhdHNpZGVkPSJ0cnVlIiBpbmtzY2FwZTpyYW5kb21pemVkPSIwIiBpbmtzY2FwZTpyb3VuZGVkPSIwIiBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXk9Ii0yLjUiIHNvZGlwb2RpOmFyZzE9IjIuNjE3OTkzOSIgc29kaXBvZGk6YXJnMj0iMy42NjUxOTE0IiBzb2RpcG9kaTpjeD0iMzA4Ljg1NzE1IiBzb2RpcG9kaTpjeT0iNzUzLjc5MDc3IiBzb2RpcG9kaTpyMT0iMTAiIHNvZGlwb2RpOnIyPSI1IiBzb2RpcG9kaTpzaWRlcz0iMyIgc29kaXBvZGk6dHlwZT0ic3RhciIgY2xhc3M9InN0MiIgZD0iDQoJCQlNNDc2LjgsMTIwMi41bDguNy0xNWw4LjcsMTVINDc2Ljh6Ii8+DQoJPC9nPg0KCQ0KCQk8ZyBpZD0iZzQxNzgtMy04IiB0cmFuc2Zvcm09Im1hdHJpeCgtMC44MzIxMjIxMSwtMS4xMjMxNTE1LDAuODk1NzAwOTIsLTAuODk0MzA3NzIsLTcyLjk0MjIwNiwxNjc4LjMxNjEpIiBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXg9Ijg0LjA5ODc0MSIgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSIxLjQ1NzI3ODdlLTA1Ij4NCgkJPHBhdGggaWQ9InBhdGg0MTc0LTMtNCIgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgY2xhc3M9InN0MSIgZD0iTTUwMS41LDEwNzUuOWMwLTcxLjMsMC03MS4zLDAtNzEuMyIvPg0KCQkNCgkJCTxwYXRoIGlkPSJwYXRoNDE3Ni05LTAiIGlua3NjYXBlOmZsYXRzaWRlZD0idHJ1ZSIgaW5rc2NhcGU6cmFuZG9taXplZD0iMCIgaW5rc2NhcGU6cm91bmRlZD0iMCIgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSItMi41IiBzb2RpcG9kaTphcmcxPSIyLjYxNzk5MzkiIHNvZGlwb2RpOmFyZzI9IjMuNjY1MTkxNCIgc29kaXBvZGk6Y3g9IjMwOC44NTcxNSIgc29kaXBvZGk6Y3k9Ijc1My43OTA3NyIgc29kaXBvZGk6cjE9IjEwIiBzb2RpcG9kaTpyMj0iNSIgc29kaXBvZGk6c2lkZXM9IjMiIHNvZGlwb2RpOnR5cGU9InN0YXIiIGNsYXNzPSJzdDIiIGQ9Ig0KCQkJTTQ5My4yLDEwMTMuOWw4LjctMTVsOC43LDE1TDQ5My4yLDEwMTMuOXoiLz4NCgk8L2c+DQoJPGcgaWQ9Imc0MzI0IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjk2NTkyNTgzLDAuMjU4ODE5MDUsMC4yNTg4MTkwNSwtMC45NjU5MjU4MywtMjcyLjgxMDc0LDExMjYuMjM4KSI+DQoJCTxwYXRoIGlkPSJwYXRoNDE3NC0zLTIiIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIGNsYXNzPSJzdDMiIGQ9Ik0zNjIsOTg4LjRDMjYwLDg3NC42LDI2MCw4NzQuNiwyNjAsODc0LjYiLz4NCgkJDQoJCQk8cGF0aCBpZD0icGF0aDQxNzYtOS05IiBpbmtzY2FwZTpmbGF0c2lkZWQ9InRydWUiIGlua3NjYXBlOnJhbmRvbWl6ZWQ9IjAiIGlua3NjYXBlOnJvdW5kZWQ9IjAiIGlua3NjYXBlOnRyYW5zZm9ybS1jZW50ZXIteT0iLTIuNSIgc29kaXBvZGk6YXJnMT0iMi42MTc5OTM5IiBzb2RpcG9kaTphcmcyPSIzLjY2NTE5MTQiIHNvZGlwb2RpOmN4PSIzMDguODU3MTUiIHNvZGlwb2RpOmN5PSI3NTMuNzkwNzciIHNvZGlwb2RpOnIxPSIxMCIgc29kaXBvZGk6cjI9IjUiIHNvZGlwb2RpOnNpZGVzPSIzIiBzb2RpcG9kaTp0eXBlPSJzdGFyIiBjbGFzcz0ic3Q0IiBkPSINCgkJCU0yNTMsODgxLjVsLTQuOC0xOC40bDE3LjgsNi45TDI1Myw4ODEuNXoiLz4NCgk8L2c+DQoJPGcgaWQ9Imc0MzI0LTgiIHRyYW5zZm9ybT0ibWF0cml4KC0wLjk2NTkyNTgzLDAuMjU4ODE5MDUsLTAuMjU4ODE5MDUsLTAuOTY1OTI1ODMsNjU0LjMyOTY0LDExMjYuMjM4KSI+DQoJCTxwYXRoIGlkPSJwYXRoNDE3NC0zLTItNyIgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgY2xhc3M9InN0MyIgZD0iTTc2LjEsOTExLjhDLTI1LjksNzk4LTI1LjksNzk4LTI1LjksNzk4Ii8+DQoJCQ0KCQkJPHBhdGggaWQ9InBhdGg0MTc2LTktOS0zIiBpbmtzY2FwZTpmbGF0c2lkZWQ9InRydWUiIGlua3NjYXBlOnJhbmRvbWl6ZWQ9IjAiIGlua3NjYXBlOnJvdW5kZWQ9IjAiIGlua3NjYXBlOnRyYW5zZm9ybS1jZW50ZXIteT0iLTIuNSIgc29kaXBvZGk6YXJnMT0iMi42MTc5OTM5IiBzb2RpcG9kaTphcmcyPSIzLjY2NTE5MTQiIHNvZGlwb2RpOmN4PSIzMDguODU3MTUiIHNvZGlwb2RpOmN5PSI3NTMuNzkwNzciIHNvZGlwb2RpOnIxPSIxMCIgc29kaXBvZGk6cjI9IjUiIHNvZGlwb2RpOnNpZGVzPSIzIiBzb2RpcG9kaTp0eXBlPSJzdGFyIiBjbGFzcz0ic3Q0IiBkPSINCgkJCU0tMzIuOSw4MDQuOWwtNC44LTE4LjRsMTcuOCw2LjlMLTMyLjksODA0Ljl6Ii8+DQoJPC9nPg0KCTxnIGlkPSJnNDE3OC0zLTkiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLC0xLjM1NjYwNjYsLTE1NC43NTk5OSwxNzQ5LjU0MzEpIj4NCgkJPHBhdGggaWQ9InBhdGg0MTc0LTMtOCIgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgY2xhc3M9InN0NSIgZD0iTTQ4NS4xLDExMDMuN2MwLTcxLjMsMC03MS4zLDAtNzEuMyIvPg0KCQkNCgkJCTxwYXRoIGlkPSJwYXRoNDE3Ni05LTUiIGlua3NjYXBlOmZsYXRzaWRlZD0idHJ1ZSIgaW5rc2NhcGU6cmFuZG9taXplZD0iMCIgaW5rc2NhcGU6cm91bmRlZD0iMCIgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSItMi41IiBzb2RpcG9kaTphcmcxPSIyLjYxNzk5MzkiIHNvZGlwb2RpOmFyZzI9IjMuNjY1MTkxNCIgc29kaXBvZGk6Y3g9IjMwOC44NTcxNSIgc29kaXBvZGk6Y3k9Ijc1My43OTA3NyIgc29kaXBvZGk6cjE9IjEwIiBzb2RpcG9kaTpyMj0iNSIgc29kaXBvZGk6c2lkZXM9IjMiIHNvZGlwb2RpOnR5cGU9InN0YXIiIGNsYXNzPSJzdDYiIGQ9Ig0KCQkJTTQ3Ni44LDEwNDEuNmw4LjctMTVsOC43LDE1SDQ3Ni44eiIvPg0KCTwvZz4NCgk8ZyBpZD0iZzM5MzciIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMTIuMzU2NDYsNzY5LjczMDc0KSI+DQoJCTxnIGlkPSJnMzg2OCIgdHJhbnNmb3JtPSJtYXRyaXgoMC44ODc5MjMzNywwLDAsMSw0My41MDk3NSw2LjUyNTAwMDFlLTYpIj4NCgkJCTxyZWN0IGlkPSJyZWN0Mjk4NSIgeD0iMTk2LjciIHk9Ii00MDguMSIgY2xhc3M9InN0NyIgd2lkdGg9IjIyNC4zIiBoZWlnaHQ9IjUwIi8+DQoJCQk8ZyBpZD0iZzM4NjEiPg0KCQkJCTx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMjAzLjM5MTggLTM3Ny4xNTQ1KSIgY2xhc3M9InN0OCBzdDkiPkJhY2tlbmQgUG9kIDE8L3RleHQ+DQoJCQk8L2c+DQoJCTwvZz4NCgkJPGcgaWQ9ImczODY4LTciIHRyYW5zZm9ybT0ibWF0cml4KDAuODg3OTIzMzcsMCwwLDEsMjYyLjAwMjMxLDYuNTI1MDAwMWUtNikiPg0KCQkJPHJlY3QgaWQ9InJlY3QyOTg1LTEiIHg9IjE5Ni43IiB5PSItNDA4LjEiIGNsYXNzPSJzdDciIHdpZHRoPSIyMjQuMyIgaGVpZ2h0PSI1MCIvPg0KCQkJPGcgaWQ9ImczODYxLTkiPg0KCQkJCTx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMjAzLjM5MTkgLTM3Ny4xNTQ1KSIgY2xhc3M9InN0OCBzdDkiPkJhY2tlbmQgUG9kIDI8L3RleHQ+DQoJCQk8L2c+DQoJCTwvZz4NCgkJPGcgaWQ9ImczODY4LTMiIHRyYW5zZm9ybT0ibWF0cml4KDAuODg3OTIzMzcsMCwwLDEsNDgwLjQ5NDg5LDYuNTI1MDAwMWUtNikiPg0KCQkJPHJlY3QgaWQ9InJlY3QyOTg1LTIiIHg9IjE5Ni43IiB5PSItNDA4LjEiIGNsYXNzPSJzdDciIHdpZHRoPSIyMjQuMyIgaGVpZ2h0PSI1MCIvPg0KCQkJPGcgaWQ9ImczODYxLTMiPg0KCQkJCTx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMjAzLjM5MiAtMzc3LjE1NDUpIiBjbGFzcz0ic3Q4IHN0OSI+QmFja2VuZCBQb2QgMzwvdGV4dD4NCgkJCTwvZz4NCgkJPC9nPg0KCTwvZz4NCgk8ZyBpZD0iZzQxNzgtMyIgdHJhbnNmb3JtPSJtYXRyaXgoMC45MTE5MjYyMywtMC40MTAzNTQxOCwtMC4zNzk5MDE2NCwtMC44NDQyNTE4NCwxMTMuNjA0NTMsMTM4NS40MDA5KSI+DQoJCTxwYXRoIGlkPSJwYXRoNDE3NC0zIiBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiBjbGFzcz0ic3QxMSIgZD0iTTY2NC42LDExNTQuM2MwLTcxLjMsMC03MS4zLDAtNzEuMyIvPg0KCQkNCgkJCTxwYXRoIGlkPSJwYXRoNDE3Ni05IiBpbmtzY2FwZTpmbGF0c2lkZWQ9InRydWUiIGlua3NjYXBlOnJhbmRvbWl6ZWQ9IjAiIGlua3NjYXBlOnJvdW5kZWQ9IjAiIGlua3NjYXBlOnRyYW5zZm9ybS1jZW50ZXIteT0iLTIuNSIgc29kaXBvZGk6YXJnMT0iMi42MTc5OTM5IiBzb2RpcG9kaTphcmcyPSIzLjY2NTE5MTQiIHNvZGlwb2RpOmN4PSIzMDguODU3MTUiIHNvZGlwb2RpOmN5PSI3NTMuNzkwNzciIHNvZGlwb2RpOnIxPSIxMCIgc29kaXBvZGk6cjI9IjUiIHNvZGlwb2RpOnNpZGVzPSIzIiBzb2RpcG9kaTp0eXBlPSJzdGFyIiBjbGFzcz0ic3QxMiIgZD0iDQoJCQlNNjU2LjIsMTA5Mi4zbDguNy0xNWw4LjcsMTVINjU2LjJ6Ii8+DQoJPC9nPg0KCTxnIGlkPSJnNDA5MCIgdHJhbnNmb3JtPSJtYXRyaXgoMC44OTA2NzAwMywwLDAsMSwtMTk0Ljk3Mjk1LC0xNDIuMzYyODYpIj4NCgkJPHJlY3QgaWQ9InJlY3QyOTg1LTQiIHg9IjM4OCIgeT0iMjM1LjUiIGNsYXNzPSJzdDEzIiB3aWR0aD0iMjI0LjMiIGhlaWdodD0iNTguNiIvPg0KCQk8ZyBpZD0iZzM4NjEtNiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjE3LjYxNzcsNjUyLjgyNTE2KSI+DQoJCQk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDIzMy43NDE5IC0zNzcuMjM0NykiIGNsYXNzPSJzdDggc3Q5Ij5DbGllbnQgPC90ZXh0Pg0KCQk8L2c+DQoJPC9nPg0KCTxnIGlkPSJnNDE2OCIgdHJhbnNmb3JtPSJtYXRyaXgoMC44OTA2NzAwMywwLDAsMSwxOTkuNjU5MjIsLTI0LjI1MTc5OCkiPg0KCQk8cmVjdCBpZD0icmVjdDI5ODUtNC0wIiB4PSIyMTYuOSIgeT0iMTE5LjgiIGNsYXNzPSJzdDE0IiB3aWR0aD0iMjUwIiBoZWlnaHQ9IjU4LjYiLz4NCgkJPGcgaWQ9ImczODYxLTYtMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzQuNzQ3NDMzLDUzNC4yNjI4NykiPg0KCQkJPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAyMjYuNjIyIC0zNzYuNzg2NSkiIGNsYXNzPSJzdDggc3Q5Ij5rdWJlLXByb3h5PC90ZXh0Pg0KCQk8L2c+DQoJPC9nPg0KCTxnIGlkPSJnNDE2OC01IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxODguMDQzMzMsLTI5LjA0MTg4NykiPg0KCQk8ZyBpZD0iZzQyMzgiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIyLjA4NzQyOSwtODYuMzQxNzcpIj4NCgkJCTxyZWN0IGlkPSJyZWN0Mjk4NS00LTAtNiIgeD0iMTk5LjkiIHk9IjExOS44IiBjbGFzcz0ic3QxNSIgd2lkdGg9IjE5MS44IiBoZWlnaHQ9IjU4LjYiLz4NCgkJCTxnIGlkPSJnMzg2MS02LTItNiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzkuMTA3NDI5LDUzNC4yNjI4NykiPg0KCQkJCTx0ZXh0IHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMTg0LjcxMDkgLTM3Ny4xNTQ0KSIgY2xhc3M9InN0OCBzdDkiPmFwaXNlcnZlcjwvdGV4dD4NCgkJCTwvZz4NCgkJPC9nPg0KCTwvZz4NCgk8cGF0aCBpZD0icGF0aDM4ODQiIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIGNsYXNzPSJzdDE2IiBkPSJNMzMyLjUsMjAyYy0xNC41LDAtMjcsOC42LTMzLDIxLjJjLTUtMC45LTEwLjMtMS40LTE1LjgtMS40DQoJCWMtMzQuMywwLTYyLjIsMTkuMS02Mi4yLDQyLjZzMjcuOCw0Mi42LDYyLjIsNDIuNmMxNi45LDAsMzIuMi00LjYsNDMuNC0xMi4yYzcuNCwxNi4zLDM0LDI4LjMsNjUuNywyOC4zDQoJCWMzMy41LDAsNjEuNC0xMy40LDY2LjgtMzEuMWMxNy01LjMsMjguNi0xNS43LDI4LjYtMjcuN2MwLTE3LjMtMjQuNC0zMS40LTU0LjQtMzEuNGMtOC41LDAtMTYuNSwxLjEtMjMuNiwzLjENCgkJYy0yLTEwLjUtMTQuOC0xOC42LTMwLjMtMTguNmMtNS44LDAtMTEuMiwxLjItMTUuOSwzLjFDMzU3LjcsMjA5LjUsMzQ1LjksMjAyLDMzMi41LDIwMkwzMzIuNSwyMDJ6Ii8+DQoJPGcgaWQ9ImczODYxLTYtMjgiIHRyYW5zZm9ybT0ibWF0cml4KDAuODkwNjcwMDMsMCwwLDEsMzQuODEwMDUyLDYyOS42MTczMykiPg0KCQk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDI1OS44NTY0IC0zNzkuMTczKSIgY2xhc3M9InN0OCBzdDkiPmNsdXN0ZXJJUDwvdGV4dD4NCgkJPHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAyNDAuODU2NCAtMzM5LjE3MykiIGNsYXNzPSJzdDggc3Q5IiBmaWxsPSJyZWQiPihWaXJ0dWFsIFNlcnZlcikgPC90ZXh0Pg0KCTwvZz4NCgk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDUzNy41OTY1IDMxNy44MTYzKSIgY2xhc3M9InN0MTcgc3QxOCI+Tm9kZTwvdGV4dD4NCgk8dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDIzMCA0NTApIiBjbGFzcz0ic3Q4IHN0OSIgZmlsbD0icmVkIj4oUmVhbCBTZXJ2ZXIpIDwvdGV4dD4NCjwvZz4NCjwvc3ZnPg0K" alt="Services overview diagram for IPVS proxy"></p> <p>In these proxy models, the traffic bound for the Service's IP:Port is proxied to an appropriate backend without the clients knowing anything about Kubernetes or Services or Pods.</p> <p>If you want to make sure that connections from a particular client are passed to the same Pod each time, you can select the session affinity based on the client's IP addresses by setting <code>service.spec.sessionAffinity</code> to "ClientIP" (the default is "None"). You can also set the maximum session sticky time by setting <code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code> appropriately. (the default value is 10800, which works out to be 3 hours).</p> <h2 id="multi-port-services">Multi-Port Services</h2> <p>For some Services, you need to expose more than one port. Kubernetes lets you configure multiple port definitions on a Service object. When using multiple ports for a Service, you must give all of your ports names so that these are unambiguous. For example:</p> <pre class="highlight" data-language="yaml">apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 9376
    - name: https
      protocol: TCP
      port: 443
      targetPort: 9377
</pre>
<div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> <p>As with Kubernetes <a class="glossary-tooltip" title="A client-provided string that refers to an object in a resource URL, such as /api/v1/pods/some-name." data-toggle="tooltip" data-placement="top" href="../../overview/working-with-objects/names" target="_blank" aria-label="names">names</a> in general, names for ports must only contain lowercase alphanumeric characters and <code>-</code>. Port names must also start and end with an alphanumeric character.</p> <p>For example, the names <code>123-abc</code> and <code>web</code> are valid, but <code>123_abc</code> and <code>-web</code> are not.</p> </div> <h2 id="choosing-your-own-ip-address">Choosing your own IP address</h2> <p>You can specify your own cluster IP address as part of a <code>Service</code> creation request. To do this, set the <code>.spec.clusterIP</code> field. For example, if you already have an existing DNS entry that you wish to reuse, or legacy systems that are configured for a specific IP address and difficult to re-configure.</p> <p>The IP address that you choose must be a valid IPv4 or IPv6 address from within the <code>service-cluster-ip-range</code> CIDR range that is configured for the API server. If you try to create a Service with an invalid clusterIP address value, the API server will return a 422 HTTP status code to indicate that there's a problem.</p> <h2 id="traffic-policies">Traffic policies</h2> <h3 id="external-traffic-policy">External traffic policy</h3> <p>You can set the <code>spec.externalTrafficPolicy</code> field to control how traffic from external sources is routed. Valid values are <code>Cluster</code> and <code>Local</code>. Set the field to <code>Cluster</code> to route external traffic to all ready endpoints and <code>Local</code> to only route to ready node-local endpoints. If the traffic policy is <code>Local</code> and there are are no node-local endpoints, the kube-proxy does not forward any traffic for the relevant Service.</p> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code> </div> <p>If you enable the <code>ProxyTerminatingEndpoints</code> <a href="../../../reference/command-line-tools-reference/feature-gates/index">feature gate</a> for the kube-proxy, the kube-proxy checks if the node has local endpoints and whether or not all the local endpoints are marked as terminating. If there are local endpoints and <strong>all</strong> of those are terminating, then the kube-proxy ignores any external traffic policy of <code>Local</code>. Instead, whilst the node-local endpoints remain as all terminating, the kube-proxy forwards traffic for that Service to healthy endpoints elsewhere, as if the external traffic policy were set to <code>Cluster</code>. This forwarding behavior for terminating endpoints exists to allow external load balancers to gracefully drain connections that are backed by <code>NodePort</code> Services, even when the health check node port starts to fail. Otherwise, traffic can be lost between the time a node is still in the node pool of a load balancer and traffic is being dropped during the termination period of a pod. </p>
</div> <h3 id="internal-traffic-policy">Internal traffic policy</h3> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code> </div> <p>You can set the <code>spec.internalTrafficPolicy</code> field to control how traffic from internal sources is routed. Valid values are <code>Cluster</code> and <code>Local</code>. Set the field to <code>Cluster</code> to route internal traffic to all ready endpoints and <code>Local</code> to only route to ready node-local endpoints. If the traffic policy is <code>Local</code> and there are no node-local endpoints, traffic is dropped by kube-proxy.</p> <h2 id="discovering-services">Discovering services</h2> <p>Kubernetes supports 2 primary modes of finding a Service - environment variables and DNS.</p> <h3 id="environment-variables">Environment variables</h3> <p>When a Pod is run on a Node, the kubelet adds a set of environment variables for each active Service. It supports both <a href="https://docs.docker.com/userguide/dockerlinks/">Docker links compatible</a> variables (see <a href="https://github.com/kubernetes/kubernetes/blob/dd2d12f6dc0e654c15d5db57a5f9f6ba61192726/pkg/kubelet/envvars/envvars.go#L72">makeLinkVariables</a>) and simpler <code>{SVCNAME}_SERVICE_HOST</code> and <code>{SVCNAME}_SERVICE_PORT</code> variables, where the Service name is upper-cased and dashes are converted to underscores.</p> <p>For example, the Service <code>redis-master</code> which exposes TCP port 6379 and has been allocated cluster IP address 10.0.0.11, produces the following environment variables:</p> <pre class="highlight" data-language="shell">REDIS_MASTER_SERVICE_HOST=10.0.0.11
REDIS_MASTER_SERVICE_PORT=6379
REDIS_MASTER_PORT=tcp://10.0.0.11:6379
REDIS_MASTER_PORT_6379_TCP=tcp://10.0.0.11:6379
REDIS_MASTER_PORT_6379_TCP_PROTO=tcp
REDIS_MASTER_PORT_6379_TCP_PORT=6379
REDIS_MASTER_PORT_6379_TCP_ADDR=10.0.0.11
</pre>
<div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> <p>When you have a Pod that needs to access a Service, and you are using the environment variable method to publish the port and cluster IP to the client Pods, you must create the Service <em>before</em> the client Pods come into existence. Otherwise, those client Pods won't have their environment variables populated.</p> <p>If you only use DNS to discover the cluster IP for a Service, you don't need to worry about this ordering issue.</p> </div> <h3 id="dns">DNS</h3> <p>You can (and almost always should) set up a DNS service for your Kubernetes cluster using an <a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/">add-on</a>.</p> <p>A cluster-aware DNS server, such as CoreDNS, watches the Kubernetes API for new Services and creates a set of DNS records for each one. If DNS has been enabled throughout your cluster then all Pods should automatically be able to resolve Services by their DNS name.</p> <p>For example, if you have a Service called <code>my-service</code> in a Kubernetes namespace <code>my-ns</code>, the control plane and the DNS Service acting together create a DNS record for <code>my-service.my-ns</code>. Pods in the <code>my-ns</code> namespace should be able to find the service by doing a name lookup for <code>my-service</code> (<code>my-service.my-ns</code> would also work).</p> <p>Pods in other namespaces must qualify the name as <code>my-service.my-ns</code>. These names will resolve to the cluster IP assigned for the Service.</p> <p>Kubernetes also supports DNS SRV (Service) records for named ports. If the <code>my-service.my-ns</code> Service has a port named <code>http</code> with the protocol set to <code>TCP</code>, you can do a DNS SRV query for <code>_http._tcp.my-service.my-ns</code> to discover the port number for <code>http</code>, as well as the IP address.</p> <p>The Kubernetes DNS server is the only way to access <code>ExternalName</code> Services. You can find more information about <code>ExternalName</code> resolution in <a href="../dns-pod-service/index">DNS Pods and Services</a>.</p> <h2 id="headless-services">Headless Services</h2> <p>Sometimes you don't need load-balancing and a single Service IP. In this case, you can create what are termed "headless" Services, by explicitly specifying <code>"None"</code> for the cluster IP (<code>.spec.clusterIP</code>).</p> <p>You can use a headless Service to interface with other service discovery mechanisms, without being tied to Kubernetes' implementation.</p> <p>For headless <code>Services</code>, a cluster IP is not allocated, kube-proxy does not handle these Services, and there is no load balancing or proxying done by the platform for them. How DNS is automatically configured depends on whether the Service has selectors defined:</p> <h3 id="with-selectors">With selectors</h3> <p>For headless Services that define selectors, the endpoints controller creates <code>Endpoints</code> records in the API, and modifies the DNS configuration to return A records (IP addresses) that point directly to the <code>Pods</code> backing the <code>Service</code>.</p> <h3 id="without-selectors">Without selectors</h3> <p>For headless Services that do not define selectors, the endpoints controller does not create <code>Endpoints</code> records. However, the DNS system looks for and configures either:</p> <ul> <li>CNAME records for <a href="#externalname"><code>ExternalName</code></a>-type Services.</li> <li>A records for any <code>Endpoints</code> that share a name with the Service, for all other types.</li> </ul> <h2 id="publishing-services-service-types">Publishing Services (ServiceTypes)</h2> <p>For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that's outside of your cluster.</p> <p>Kubernetes <code>ServiceTypes</code> allow you to specify what kind of Service you want. The default is <code>ClusterIP</code>.</p> <p><code>Type</code> values and their behaviors are:</p> <ul> <li>
<code>ClusterIP</code>: Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default <code>ServiceType</code>.</li> <li>
<a href="#type-nodeport"><code>NodePort</code></a>: Exposes the Service on each Node's IP at a static port (the <code>NodePort</code>). A <code>ClusterIP</code> Service, to which the <code>NodePort</code> Service routes, is automatically created. You'll be able to contact the <code>NodePort</code> Service, from outside the cluster, by requesting <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>.</li> <li>
<a href="#loadbalancer"><code>LoadBalancer</code></a>: Exposes the Service externally using a cloud provider's load balancer. <code>NodePort</code> and <code>ClusterIP</code> Services, to which the external load balancer routes, are automatically created.</li> <li>
<a href="#externalname"><code>ExternalName</code></a>: Maps the Service to the contents of the <code>externalName</code> field (e.g. <code>foo.bar.example.com</code>), by returning a <code>CNAME</code> record with its value. No proxying of any kind is set up. <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> You need either <code>kube-dns</code> version 1.7 or CoreDNS version 0.0.8 or higher to use the <code>ExternalName</code> type. </div>
</li> </ul> <p>You can also use <a href="../ingress/index">Ingress</a> to expose your Service. Ingress is not a Service type, but it acts as the entry point for your cluster. It lets you consolidate your routing rules into a single resource as it can expose multiple services under the same IP address.</p> <h3 id="type-nodeport">Type NodePort</h3> <p>If you set the <code>type</code> field to <code>NodePort</code>, the Kubernetes control plane allocates a port from a range specified by <code>--service-node-port-range</code> flag (default: 30000-32767). Each node proxies that port (the same port number on every Node) into your Service. Your Service reports the allocated port in its <code>.spec.ports[*].nodePort</code> field.</p> <p>If you want to specify particular IP(s) to proxy the port, you can set the <code>--nodeport-addresses</code> flag for kube-proxy or the equivalent <code>nodePortAddresses</code> field of the <a href="../../../reference/config-api/kube-proxy-config.v1alpha1/index">kube-proxy configuration file</a> to particular IP block(s).</p> <p>This flag takes a comma-delimited list of IP blocks (e.g. <code>10.0.0.0/8</code>, <code>192.0.2.0/25</code>) to specify IP address ranges that kube-proxy should consider as local to this node.</p> <p>For example, if you start kube-proxy with the <code>--nodeport-addresses=127.0.0.0/8</code> flag, kube-proxy only selects the loopback interface for NodePort Services. The default for <code>--nodeport-addresses</code> is an empty list. This means that kube-proxy should consider all available network interfaces for NodePort. (That's also compatible with earlier Kubernetes releases).</p> <p>If you want a specific port number, you can specify a value in the <code>nodePort</code> field. The control plane will either allocate you that port or report that the API transaction failed. This means that you need to take care of possible port collisions yourself. You also have to use a valid port number, one that's inside the range configured for NodePort use.</p> <p>Using a NodePort gives you the freedom to set up your own load balancing solution, to configure environments that are not fully supported by Kubernetes, or even to expose one or more nodes' IPs directly.</p> <p>Note that this Service is visible as <code>&lt;NodeIP&gt;:spec.ports[*].nodePort</code> and <code>.spec.clusterIP:spec.ports[*].port</code>. If the <code>--nodeport-addresses</code> flag for kube-proxy or the equivalent field in the kube-proxy configuration file is set, <code>&lt;NodeIP&gt;</code> would be filtered node IP(s).</p> <p>For example:</p> <pre class="highlight" data-language="yaml">apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: NodePort
  selector:
    app: MyApp
  ports:
      # By default and for convenience, the `targetPort` is set to the same value as the `port` field.
    - port: 80
      targetPort: 80
      # Optional field
      # By default and for convenience, the Kubernetes control plane will allocate a port from a range (default: 30000-32767)
      nodePort: 30007
</pre>
<h3 id="loadbalancer">Type LoadBalancer</h3> <p>On cloud providers which support external load balancers, setting the <code>type</code> field to <code>LoadBalancer</code> provisions a load balancer for your Service. The actual creation of the load balancer happens asynchronously, and information about the provisioned balancer is published in the Service's <code>.status.loadBalancer</code> field. For example:</p> <pre class="highlight" data-language="yaml">apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
  clusterIP: 10.0.171.239
  type: LoadBalancer
status:
  loadBalancer:
    ingress:
    - ip: 192.0.2.127
</pre>
<p>Traffic from the external load balancer is directed at the backend Pods. The cloud provider decides how it is load balanced.</p> <p>Some cloud providers allow you to specify the <code>loadBalancerIP</code>. In those cases, the load-balancer is created with the user-specified <code>loadBalancerIP</code>. If the <code>loadBalancerIP</code> field is not specified, the loadBalancer is set up with an ephemeral IP address. If you specify a <code>loadBalancerIP</code> but your cloud provider does not support the feature, the <code>loadbalancerIP</code> field that you set is ignored.</p> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> <p>On <strong>Azure</strong>, if you want to use a user-specified public type <code>loadBalancerIP</code>, you first need to create a static type public IP address resource. This public IP address resource should be in the same resource group of the other automatically created resources of the cluster. For example, <code>MC_myResourceGroup_myAKSCluster_eastus</code>.</p> <p>Specify the assigned IP address as loadBalancerIP. Ensure that you have updated the securityGroupName in the cloud provider configuration file. For information about troubleshooting <code>CreatingLoadBalancerFailed</code> permission issues see, <a href="https://docs.microsoft.com/en-us/azure/aks/static-ip">Use a static IP address with the Azure Kubernetes Service (AKS) load balancer</a> or <a href="https://github.com/Azure/AKS/issues/357">CreatingLoadBalancerFailed on AKS cluster with advanced networking</a>.</p> </div> <h4 id="load-balancers-with-mixed-protocol-types">Load balancers with mixed protocol types</h4> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code> </div> <p>By default, for LoadBalancer type of Services, when there is more than one port defined, all ports must have the same protocol, and the protocol must be one which is supported by the cloud provider.</p> <p>If the feature gate <code>MixedProtocolLBService</code> is enabled for the kube-apiserver it is allowed to use different protocols when there is more than one port defined.</p> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> The set of protocols that can be used for LoadBalancer type of Services is still defined by the cloud provider. </div> <h4 id="load-balancer-nodeport-allocation">Disabling load balancer NodePort allocation</h4> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code> </div> <p>Starting in v1.20, you can optionally disable node port allocation for a Service Type=LoadBalancer by setting the field <code>spec.allocateLoadBalancerNodePorts</code> to <code>false</code>. This should only be used for load balancer implementations that route traffic directly to pods as opposed to using node ports. By default, <code>spec.allocateLoadBalancerNodePorts</code> is <code>true</code> and type LoadBalancer Services will continue to allocate node ports. If <code>spec.allocateLoadBalancerNodePorts</code> is set to <code>false</code> on an existing Service with allocated node ports, those node ports will NOT be de-allocated automatically. You must explicitly remove the <code>nodePorts</code> entry in every Service port to de-allocate those node ports. You must enable the <code>ServiceLBNodePortControl</code> feature gate to use this field.</p> <h4 id="load-balancer-class">Specifying class of load balancer implementation</h4> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code> </div> <p><code>spec.loadBalancerClass</code> enables you to use a load balancer implementation other than the cloud provider default. This feature is available from v1.21, you must enable the <code>ServiceLoadBalancerClass</code> feature gate to use this field in v1.21, and the feature gate is enabled by default from v1.22 onwards. By default, <code>spec.loadBalancerClass</code> is <code>nil</code> and a <code>LoadBalancer</code> type of Service uses the cloud provider's default load balancer implementation if the cluster is configured with a cloud provider using the <code>--cloud-provider</code> component flag. If <code>spec.loadBalancerClass</code> is specified, it is assumed that a load balancer implementation that matches the specified class is watching for Services. Any default load balancer implementation (for example, the one provided by the cloud provider) will ignore Services that have this field set. <code>spec.loadBalancerClass</code> can be set on a Service of type <code>LoadBalancer</code> only. Once set, it cannot be changed. The value of <code>spec.loadBalancerClass</code> must be a label-style identifier, with an optional prefix such as "<code>internal-vip</code>" or "<code>example.com/internal-vip</code>". Unprefixed names are reserved for end-users.</p> <h4 id="internal-load-balancer">Internal load balancer</h4> <p>In a mixed environment it is sometimes necessary to route traffic from Services inside the same (virtual) network address block.</p> <p>In a split-horizon DNS environment you would need two Services to be able to route both external and internal traffic to your endpoints.</p> <p>To set an internal load balancer, add one of the following annotations to your Service depending on the cloud Service provider you're using.</p> <ul class="nav nav-tabs" id="service-tabs" role="tablist">
<li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#service-tabs-0" role="tab" aria-controls="service-tabs-0" aria-selected="true">Default</a></li> <li class="nav-item"><a data-toggle="tab" class="nav-link" href="#service-tabs-1" role="tab" aria-controls="service-tabs-1">GCP</a></li> <li class="nav-item"><a data-toggle="tab" class="nav-link" href="#service-tabs-2" role="tab" aria-controls="service-tabs-2">AWS</a></li> <li class="nav-item"><a data-toggle="tab" class="nav-link" href="#service-tabs-3" role="tab" aria-controls="service-tabs-3">Azure</a></li> <li class="nav-item"><a data-toggle="tab" class="nav-link" href="#service-tabs-4" role="tab" aria-controls="service-tabs-4">IBM Cloud</a></li> <li class="nav-item"><a data-toggle="tab" class="nav-link" href="#service-tabs-5" role="tab" aria-controls="service-tabs-5">OpenStack</a></li> <li class="nav-item"><a data-toggle="tab" class="nav-link" href="#service-tabs-6" role="tab" aria-controls="service-tabs-6">Baidu Cloud</a></li> <li class="nav-item"><a data-toggle="tab" class="nav-link" href="#service-tabs-7" role="tab" aria-controls="service-tabs-7">Tencent Cloud</a></li> <li class="nav-item"><a data-toggle="tab" class="nav-link" href="#service-tabs-8" role="tab" aria-controls="service-tabs-8">Alibaba Cloud</a></li>
</ul> <div class="tab-content" id="service-tabs">
<div id="service-tabs-0" class="tab-pane show active" role="tabpanel" aria-labelledby="service-tabs-0"> 
<p>Select one of the tabs.</p> </div> <div id="service-tabs-1" class="tab-pane" role="tabpanel" aria-labelledby="service-tabs-1"> 
<pre class="highlight" data-language="yaml">[...]
metadata:
    name: my-service
    annotations:
        cloud.google.com/load-balancer-type: "Internal"
[...]
</pre>
</div> <div id="service-tabs-2" class="tab-pane" role="tabpanel" aria-labelledby="service-tabs-2"> 
<pre class="highlight" data-language="yaml">[...]
metadata:
    name: my-service
    annotations:
        service.beta.kubernetes.io/aws-load-balancer-internal: "true"
[...]
</pre>
</div> <div id="service-tabs-3" class="tab-pane" role="tabpanel" aria-labelledby="service-tabs-3"> 
<pre class="highlight" data-language="yaml">[...]
metadata:
    name: my-service
    annotations:
        service.beta.kubernetes.io/azure-load-balancer-internal: "true"
[...]
</pre>
</div> <div id="service-tabs-4" class="tab-pane" role="tabpanel" aria-labelledby="service-tabs-4"> 
<pre class="highlight" data-language="yaml">[...]
metadata:
    name: my-service
    annotations:
        service.kubernetes.io/ibm-load-balancer-cloud-provider-ip-type: "private"
[...]
</pre>
</div> <div id="service-tabs-5" class="tab-pane" role="tabpanel" aria-labelledby="service-tabs-5"> 
<pre class="highlight" data-language="yaml">[...]
metadata:
    name: my-service
    annotations:
        service.beta.kubernetes.io/openstack-internal-load-balancer: "true"
[...]
</pre>
</div> <div id="service-tabs-6" class="tab-pane" role="tabpanel" aria-labelledby="service-tabs-6"> 
<pre class="highlight" data-language="yaml">[...]
metadata:
    name: my-service
    annotations:
        service.beta.kubernetes.io/cce-load-balancer-internal-vpc: "true"
[...]
</pre>
</div> <div id="service-tabs-7" class="tab-pane" role="tabpanel" aria-labelledby="service-tabs-7"> 
<pre class="highlight" data-language="yaml">[...]
metadata:
  annotations:
    service.kubernetes.io/qcloud-loadbalancer-internal-subnetid: subnet-xxxxx
[...]
</pre>
</div> <div id="service-tabs-8" class="tab-pane" role="tabpanel" aria-labelledby="service-tabs-8"> 
<pre class="highlight" data-language="yaml">[...]
metadata:
  annotations:
    service.beta.kubernetes.io/alibaba-cloud-loadbalancer-address-type: "intranet"
[...]
</pre>
</div>
</div> <h4 id="ssl-support-on-aws">TLS support on AWS</h4> <p>For partial TLS / SSL support on clusters running on AWS, you can add three annotations to a <code>LoadBalancer</code> service:</p> <pre class="highlight" data-language="yaml">metadata:
  name: my-service
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012
</pre>
<p>The first specifies the ARN of the certificate to use. It can be either a certificate from a third party issuer that was uploaded to IAM or one created within AWS Certificate Manager.</p> <pre class="highlight" data-language="yaml">metadata:
  name: my-service
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: (https|http|ssl|tcp)
</pre>
<p>The second annotation specifies which protocol a Pod speaks. For HTTPS and SSL, the ELB expects the Pod to authenticate itself over the encrypted connection, using a certificate.</p> <p>HTTP and HTTPS selects layer 7 proxying: the ELB terminates the connection with the user, parses headers, and injects the <code>X-Forwarded-For</code> header with the user's IP address (Pods only see the IP address of the ELB at the other end of its connection) when forwarding requests.</p> <p>TCP and SSL selects layer 4 proxying: the ELB forwards traffic without modifying the headers.</p> <p>In a mixed-use environment where some ports are secured and others are left unencrypted, you can use the following annotations:</p> <pre class="highlight" data-language="yaml">    metadata:
      name: my-service
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http
        service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443,8443"
</pre>
<p>In the above example, if the Service contained three ports, <code>80</code>, <code>443</code>, and <code>8443</code>, then <code>443</code> and <code>8443</code> would use the SSL certificate, but <code>80</code> would be proxied HTTP.</p> <p>From Kubernetes v1.9 onwards you can use <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-policy-table.html">predefined AWS SSL policies</a> with HTTPS or SSL listeners for your Services. To see which policies are available for use, you can use the <code>aws</code> command line tool:</p> <pre class="highlight" data-language="bash">aws elb describe-load-balancer-policies --query 'PolicyDescriptions[].PolicyName'
</pre>
<p>You can then specify any one of those policies using the "<code>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</code>" annotation; for example:</p> <pre class="highlight" data-language="yaml">    metadata:
      name: my-service
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy: "ELBSecurityPolicy-TLS-1-2-2017-01"
</pre>
<h4 id="proxy-protocol-support-on-aws">PROXY protocol support on AWS</h4> <p>To enable <a href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt">PROXY protocol</a> support for clusters running on AWS, you can use the following service annotation:</p> <pre class="highlight" data-language="yaml">    metadata:
      name: my-service
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-proxy-protocol: "*"
</pre>
<p>Since version 1.3.0, the use of this annotation applies to all ports proxied by the ELB and cannot be configured otherwise.</p> <h4 id="elb-access-logs-on-aws">ELB Access Logs on AWS</h4> <p>There are several annotations to manage access logs for ELB Services on AWS.</p> <p>The annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</code> controls whether access logs are enabled.</p> <p>The annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</code> controls the interval in minutes for publishing the access logs. You can specify an interval of either 5 or 60 minutes.</p> <p>The annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</code> controls the name of the Amazon S3 bucket where load balancer access logs are stored.</p> <p>The annotation <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</code> specifies the logical hierarchy you created for your Amazon S3 bucket.</p> <pre class="highlight" data-language="yaml">    metadata:
      name: my-service
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-access-log-enabled: "true"
        # Specifies whether access logs are enabled for the load balancer
        service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval: "60"
        # The interval for publishing the access logs. You can specify an interval of either 5 or 60 (minutes).
        service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name: "my-bucket"
        # The name of the Amazon S3 bucket where the access logs are stored
        service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix: "my-bucket-prefix/prod"
        # The logical hierarchy you created for your Amazon S3 bucket, for example `my-bucket-prefix/prod`
</pre>
<h4 id="connection-draining-on-aws">Connection Draining on AWS</h4> <p>Connection draining for Classic ELBs can be managed with the annotation <code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</code> set to the value of <code>"true"</code>. The annotation <code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</code> can also be used to set maximum time, in seconds, to keep the existing connections open before deregistering the instances.</p> <pre class="highlight" data-language="yaml">    metadata:
      name: my-service
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled: "true"
        service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout: "60"
</pre>
<h4 id="other-elb-annotations">Other ELB annotations</h4> <p>There are other annotations to manage Classic Elastic Load Balancers that are described below.</p> <pre class="highlight" data-language="yaml">    metadata:
      name: my-service
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "60"
        # The time, in seconds, that the connection is allowed to be idle (no data has been sent over the connection) before it is closed by the load balancer

        service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
        # Specifies whether cross-zone load balancing is enabled for the load balancer

        service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags: "environment=prod,owner=devops"
        # A comma-separated list of key-value pairs which will be recorded as
        # additional tags in the ELB.

        service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold: ""
        # The number of successive successful health checks required for a backend to
        # be considered healthy for traffic. Defaults to 2, must be between 2 and 10

        service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold: "3"
        # The number of unsuccessful health checks required for a backend to be
        # considered unhealthy for traffic. Defaults to 6, must be between 2 and 10

        service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval: "20"
        # The approximate interval, in seconds, between health checks of an
        # individual instance. Defaults to 10, must be between 5 and 300

        service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout: "5"
        # The amount of time, in seconds, during which no response means a failed
        # health check. This value must be less than the service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval
        # value. Defaults to 5, must be between 2 and 60

        service.beta.kubernetes.io/aws-load-balancer-security-groups: "sg-53fae93f"
        # A list of existing security groups to be configured on the ELB created. Unlike the annotation
        # service.beta.kubernetes.io/aws-load-balancer-extra-security-groups, this replaces all other security groups previously assigned to the ELB and also overrides the creation 
        # of a uniquely generated security group for this ELB.
        # The first security group ID on this list is used as a source to permit incoming traffic to target worker nodes (service traffic and health checks).
        # If multiple ELBs are configured with the same security group ID, only a single permit line will be added to the worker node security groups, that means if you delete any
        # of those ELBs it will remove the single permit line and block access for all ELBs that shared the same security group ID.
        # This can cause a cross-service outage if not used properly

        service.beta.kubernetes.io/aws-load-balancer-extra-security-groups: "sg-53fae93f,sg-42efd82e"
        #  A list of additional security groups to be added to the created ELB, this leaves the uniquely generated security group in place, this ensures that every ELB
        # has a unique security group ID and a matching permit line to allow traffic to the target worker nodes (service traffic and health checks).
        # Security groups defined here can be shared between services. 

        service.beta.kubernetes.io/aws-load-balancer-target-node-labels: "ingress-gw,gw-name=public-api"
        # A comma separated list of key-value pairs which are used
        # to select the target nodes for the load balancer
</pre>
<h4 id="aws-nlb-support">Network Load Balancer support on AWS</h4> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code> </div> <p>To use a Network Load Balancer on AWS, use the annotation <code>service.beta.kubernetes.io/aws-load-balancer-type</code> with the value set to <code>nlb</code>.</p> <pre class="highlight" data-language="yaml">    metadata:
      name: my-service
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
</pre>
<div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> NLB only works with certain instance classes; see the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-register-targets.html#register-deregister-targets">AWS documentation</a> on Elastic Load Balancing for a list of supported instance types. </div> <p>Unlike Classic Elastic Load Balancers, Network Load Balancers (NLBs) forward the client's IP address through to the node. If a Service's <code>.spec.externalTrafficPolicy</code> is set to <code>Cluster</code>, the client's IP address is not propagated to the end Pods.</p> <p>By setting <code>.spec.externalTrafficPolicy</code> to <code>Local</code>, the client IP addresses is propagated to the end Pods, but this could result in uneven distribution of traffic. Nodes without any Pods for a particular LoadBalancer Service will fail the NLB Target Group's health check on the auto-assigned <code>.spec.healthCheckNodePort</code> and not receive any traffic.</p> <p>In order to achieve even traffic, either use a DaemonSet or specify a <a href="../../scheduling-eviction/assign-pod-node/index#affinity-and-anti-affinity">pod anti-affinity</a> to not locate on the same node.</p> <p>You can also use NLB Services with the <a href="index#internal-load-balancer">internal load balancer</a> annotation.</p> <p>In order for client traffic to reach instances behind an NLB, the Node security groups are modified with the following IP rules:</p> <table> <thead> <tr> <th>Rule</th> <th>Protocol</th> <th>Port(s)</th> <th>IpRange(s)</th> <th>IpRange Description</th> </tr> </thead> <tbody> <tr> <td>Health Check</td> <td>TCP</td> <td>NodePort(s) (<code>.spec.healthCheckNodePort</code> for <code>.spec.externalTrafficPolicy = Local</code>)</td> <td>Subnet CIDR</td> <td>kubernetes.io/rule/nlb/health=&lt;loadBalancerName&gt;</td> </tr> <tr> <td>Client Traffic</td> <td>TCP</td> <td>NodePort(s)</td> <td>
<code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td> <td>kubernetes.io/rule/nlb/client=&lt;loadBalancerName&gt;</td> </tr> <tr> <td>MTU Discovery</td> <td>ICMP</td> <td>3,4</td> <td>
<code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td> <td>kubernetes.io/rule/nlb/mtu=&lt;loadBalancerName&gt;</td> </tr> </tbody> </table> <p>In order to limit which client IP's can access the Network Load Balancer, specify <code>loadBalancerSourceRanges</code>.</p> <pre class="highlight" data-language="yaml">spec:
  loadBalancerSourceRanges:
    - "143.231.0.0/16"
</pre>
<div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> If <code>.spec.loadBalancerSourceRanges</code> is not set, Kubernetes allows traffic from <code>0.0.0.0/0</code> to the Node Security Group(s). If nodes have public IP addresses, be aware that non-NLB traffic can also reach all instances in those modified security groups. </div> <p>Further documentation on annotations for Elastic IPs and other common use-cases may be found in the <a href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/service/annotations/">AWS Load Balancer Controller documentation</a>.</p> <h4 id="other-clb-annotations-on-tencent-kubernetes-engine-tke">Other CLB annotations on Tencent Kubernetes Engine (TKE)</h4> <p>There are other annotations for managing Cloud Load Balancers on TKE as shown below.</p> <pre class="highlight" data-language="yaml">    metadata:
      name: my-service
      annotations:
        # Bind Loadbalancers with specified nodes
        service.kubernetes.io/qcloud-loadbalancer-backends-label: key in (value1, value2)

        # ID of an existing load balancer
        service.kubernetes.io/tke-existed-lbidï¼šlb-6swtxxxx

        # Custom parameters for the load balancer (LB), does not support modification of LB type yet
        service.kubernetes.io/service.extensiveParameters: ""

        # Custom parameters for the LB listener
        service.kubernetes.io/service.listenerParameters: ""

        # Specifies the type of Load balancer;
        # valid values: classic (Classic Cloud Load Balancer) or application (Application Cloud Load Balancer)
        service.kubernetes.io/loadbalance-type: xxxxx

        # Specifies the public network bandwidth billing method;
        # valid values: TRAFFIC_POSTPAID_BY_HOUR(bill-by-traffic) and BANDWIDTH_POSTPAID_BY_HOUR (bill-by-bandwidth).
        service.kubernetes.io/qcloud-loadbalancer-internet-charge-type: xxxxxx

        # Specifies the bandwidth value (value range: [1,2000] Mbps).
        service.kubernetes.io/qcloud-loadbalancer-internet-max-bandwidth-out: "10"

        # When this annotation is setï¼Œthe loadbalancers will only register nodes
        # with pod running on it, otherwise all nodes will be registered.
        service.kubernetes.io/local-svc-only-bind-node-with-pod: true
</pre>
<h3 id="externalname">Type ExternalName</h3> <p>Services of type ExternalName map a Service to a DNS name, not to a typical selector such as <code>my-service</code> or <code>cassandra</code>. You specify these Services with the <code>spec.externalName</code> parameter.</p> <p>This Service definition, for example, maps the <code>my-service</code> Service in the <code>prod</code> namespace to <code>my.database.example.com</code>:</p> <pre class="highlight" data-language="yaml">apiVersion: v1
kind: Service
metadata:
  name: my-service
  namespace: prod
spec:
  type: ExternalName
  externalName: my.database.example.com
</pre>
<div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> ExternalName accepts an IPv4 address string, but as a DNS name comprised of digits, not as an IP address. ExternalNames that resemble IPv4 addresses are not resolved by CoreDNS or ingress-nginx because ExternalName is intended to specify a canonical DNS name. To hardcode an IP address, consider using <a href="#headless-services">headless Services</a>. </div> <p>When looking up the host <code>my-service.prod.svc.cluster.local</code>, the cluster DNS Service returns a <code>CNAME</code> record with the value <code>my.database.example.com</code>. Accessing <code>my-service</code> works in the same way as other Services but with the crucial difference that redirection happens at the DNS level rather than via proxying or forwarding. Should you later decide to move your database into your cluster, you can start its Pods, add appropriate selectors or endpoints, and change the Service's <code>type</code>.</p> <div class="alert alert-danger warning callout" role="alert"> <strong>Warning:</strong> <p>You may have trouble using ExternalName for some common protocols, including HTTP and HTTPS. If you use ExternalName then the hostname used by clients inside your cluster is different from the name that the ExternalName references.</p> <p>For protocols that use hostnames this difference may lead to errors or unexpected responses. HTTP requests will have a <code>Host:</code> header that the origin server does not recognize; TLS servers will not be able to provide a certificate matching the hostname that the client connected to.</p> </div> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> This section is indebted to the <a href="https://akomljen.com/kubernetes-tips-part-1/">Kubernetes Tips - Part 1</a> blog post from <a href="https://akomljen.com/">Alen Komljen</a>. </div> <h3 id="external-ips">External IPs</h3> <p>If there are external IPs that route to one or more cluster nodes, Kubernetes Services can be exposed on those <code>externalIPs</code>. Traffic that ingresses into the cluster with the external IP (as destination IP), on the Service port, will be routed to one of the Service endpoints. <code>externalIPs</code> are not managed by Kubernetes and are the responsibility of the cluster administrator.</p> <p>In the Service spec, <code>externalIPs</code> can be specified along with any of the <code>ServiceTypes</code>. In the example below, "<code>my-service</code>" can be accessed by clients on "<code>80.11.12.10:80</code>" (<code>externalIP:port</code>)</p> <pre class="highlight" data-language="yaml">apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 9376
  externalIPs:
    - 80.11.12.10
</pre>
<h2 id="shortcomings">Shortcomings</h2> <p>Using the userspace proxy for VIPs works at small to medium scale, but will not scale to very large clusters with thousands of Services. The <a href="https://github.com/kubernetes/kubernetes/issues/1107">original design proposal for portals</a> has more details on this.</p> <p>Using the userspace proxy obscures the source IP address of a packet accessing a Service. This makes some kinds of network filtering (firewalling) impossible. The iptables proxy mode does not obscure in-cluster source IPs, but it does still impact clients coming through a load balancer or node-port.</p> <p>The <code>Type</code> field is designed as nested functionality - each level adds to the previous. This is not strictly required on all cloud providers (e.g. Google Compute Engine does not need to allocate a <code>NodePort</code> to make <code>LoadBalancer</code> work, but AWS does) but the current API requires it.</p> <h2 id="the-gory-details-of-virtual-ips">Virtual IP implementation</h2> <p>The previous information should be sufficient for many people who want to use Services. However, there is a lot going on behind the scenes that may be worth understanding.</p> <h3 id="avoiding-collisions">Avoiding collisions</h3> <p>One of the primary philosophies of Kubernetes is that you should not be exposed to situations that could cause your actions to fail through no fault of your own. For the design of the Service resource, this means not making you choose your own port number if that choice might collide with someone else's choice. That is an isolation failure.</p> <p>In order to allow you to choose a port number for your Services, we must ensure that no two Services can collide. Kubernetes does that by allocating each Service its own IP address.</p> <p>To ensure each Service receives a unique IP, an internal allocator atomically updates a global allocation map in <a class="glossary-tooltip" title="Consistent and highly-available key value store used as Kubernetes' backing store for all cluster data." data-toggle="tooltip" data-placement="top" href="https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/" target="_blank" aria-label="etcd">etcd</a> prior to creating each Service. The map object must exist in the registry for Services to get IP address assignments, otherwise creations will fail with a message indicating an IP address could not be allocated.</p> <p>In the control plane, a background controller is responsible for creating that map (needed to support migrating from older versions of Kubernetes that used in-memory locking). Kubernetes also uses controllers to check for invalid assignments (eg due to administrator intervention) and for cleaning up allocated IP addresses that are no longer used by any Services.</p> <h3 id="ips-and-vips">Service IP addresses</h3> <p>Unlike Pod IP addresses, which actually route to a fixed destination, Service IPs are not actually answered by a single host. Instead, kube-proxy uses iptables (packet processing logic in Linux) to define <em>virtual</em> IP addresses which are transparently redirected as needed. When clients connect to the VIP, their traffic is automatically transported to an appropriate endpoint. The environment variables and DNS for Services are actually populated in terms of the Service's virtual IP address (and port).</p> <p>kube-proxy supports three proxy modesâ€”userspace, iptables and IPVSâ€”which each operate slightly differently.</p> <h4 id="userspace">Userspace</h4> <p>As an example, consider the image processing application described above. When the backend Service is created, the Kubernetes master assigns a virtual IP address, for example 10.0.0.1. Assuming the Service port is 1234, the Service is observed by all of the kube-proxy instances in the cluster. When a proxy sees a new Service, it opens a new random port, establishes an iptables redirect from the virtual IP address to this new port, and starts accepting connections on it.</p> <p>When a client connects to the Service's virtual IP address, the iptables rule kicks in, and redirects the packets to the proxy's own port. The "Service proxy" chooses a backend, and starts proxying traffic from the client to the backend.</p> <p>This means that Service owners can choose any port they want without risk of collision. Clients can connect to an IP and port, without being aware of which Pods they are actually accessing.</p> <h4 id="iptables">iptables</h4> <p>Again, consider the image processing application described above. When the backend Service is created, the Kubernetes control plane assigns a virtual IP address, for example 10.0.0.1. Assuming the Service port is 1234, the Service is observed by all of the kube-proxy instances in the cluster. When a proxy sees a new Service, it installs a series of iptables rules which redirect from the virtual IP address to per-Service rules. The per-Service rules link to per-Endpoint rules which redirect traffic (using destination NAT) to the backends.</p> <p>When a client connects to the Service's virtual IP address the iptables rule kicks in. A backend is chosen (either based on session affinity or randomly) and packets are redirected to the backend. Unlike the userspace proxy, packets are never copied to userspace, the kube-proxy does not have to be running for the virtual IP address to work, and Nodes see traffic arriving from the unaltered client IP address.</p> <p>This same basic flow executes when traffic comes in through a node-port or through a load-balancer, though in those cases the client IP does get altered.</p> <h4 id="ipvs">IPVS</h4> <p>iptables operations slow down dramatically in large scale cluster e.g 10,000 Services. IPVS is designed for load balancing and based on in-kernel hash tables. So you can achieve performance consistency in large number of Services from IPVS-based kube-proxy. Meanwhile, IPVS-based kube-proxy has more sophisticated load balancing algorithms (least conns, locality, weighted, persistence).</p> <h2 id="api-object">API Object</h2> <p>Service is a top-level resource in the Kubernetes REST API. You can find more details about the API object at: <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#service-v1-core">Service API object</a>.</p> <h2 id="protocol-support">Supported protocols</h2> <h3 id="tcp">TCP</h3> <p>You can use TCP for any kind of Service, and it's the default network protocol.</p> <h3 id="udp">UDP</h3> <p>You can use UDP for most Services. For type=LoadBalancer Services, UDP support depends on the cloud provider offering this facility.</p> <h3 id="sctp">SCTP</h3> <div style="margin-top: 10px; margin-bottom: 10px;"> <b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code> </div> <p>When using a network plugin that supports SCTP traffic, you can use SCTP for most Services. For type=LoadBalancer Services, SCTP support depends on the cloud provider offering this facility. (Most do not).</p> <h4 id="caveat-sctp-overview">Warnings</h4> <h5 id="caveat-sctp-multihomed">Support for multihomed SCTP associations</h5> <div class="alert alert-danger warning callout" role="alert"> <strong>Warning:</strong> <p>The support of multihomed SCTP associations requires that the CNI plugin can support the assignment of multiple interfaces and IP addresses to a Pod.</p> <p>NAT for multihomed SCTP associations requires special logic in the corresponding kernel modules.</p> </div> <h5 id="caveat-sctp-windows-os">Windows</h5> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> SCTP is not supported on Windows based nodes. </div> <h5 id="caveat-sctp-kube-proxy-userspace">Userspace kube-proxy</h5> <div class="alert alert-danger warning callout" role="alert"> <strong>Warning:</strong> The kube-proxy does not support the management of SCTP associations when it is in userspace mode. </div> <h3 id="http">HTTP</h3> <p>If your cloud provider supports it, you can use a Service in LoadBalancer mode to set up external HTTP / HTTPS reverse proxying, forwarded to the Endpoints of the Service.</p> <div class="alert alert-info note callout" role="alert"> <strong>Note:</strong> You can also use <a class="glossary-tooltip" title="An API object that manages external access to the services in a cluster, typically HTTP." data-toggle="tooltip" data-placement="top" href="../ingress/index" target="_blank" aria-label="Ingress">Ingress</a> in place of Service to expose HTTP/HTTPS Services. </div> <h3 id="proxy-protocol">PROXY protocol</h3> <p>If your cloud provider supports it, you can use a Service in LoadBalancer mode to configure a load balancer outside of Kubernetes itself, that will forward connections prefixed with <a href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt">PROXY protocol</a>.</p> <p>The load balancer will send an initial series of octets describing the incoming connection, similar to this example</p> <pre><code>PROXY TCP4 192.0.2.202 10.0.42.7 12345 7\r\n
</code></pre>
<p>followed by the data from the client.</p> <h2 id="what-s-next">What's next</h2> <ul> <li>Read <a href="../connect-applications-service/index">Connecting Applications with Services</a>
</li> <li>Read about <a href="../ingress/index">Ingress</a>
</li> <li>Read about <a href="../endpoint-slices/index">EndpointSlices</a>
</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2022 The Kubernetes Authors<br>Documentation Distributed under CC BY 4.0.<br>
    <a href="https://kubernetes.io/docs/concepts/services-networking/service/" class="_attribution-link">https://kubernetes.io/docs/concepts/services-networking/service/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
