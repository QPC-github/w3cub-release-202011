
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Advanced Types - TypeScript - W3cubDocs</title>
  
  <meta name="description" content="This page lists some of the more advanced ways in which you can model types, it works in tandem with the Utility Types doc which includes types &hellip;">
  <meta name="keywords" content="advanced, types, typescript">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/typescript/advanced-types.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/typescript.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/typescript/" class="_nav-link" title="" style="margin-left:0;">TypeScript</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<div id="___gatsby">
<div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="ms-Fabric">

<main role="main"><section id="doc-layout">
<div id="handbook-content" role="article">
<h1>Advanced Types</h1>
<article><div class="whitespace raised"><div class="markdown">
<p>This page lists some of the more advanced ways in which you can model types, it works in tandem with the <a href="utility-types">Utility Types</a> doc which includes types which are included in TypeScript and available globally.</p> <h2 id="type-guards-and-differentiating-types" style="position:relative;">Type Guards and Differentiating Types</h2> <p>Union types are useful for modeling situations when values can overlap in the types they can take on. What happens when we need to know specifically whether we have a <code>Fish</code>? A common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member. As we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.</p> <pre data-language="typescript">let pet = getSmallPet();

// You can use the 'in' operator to check
if ("swim" in pet) {
  pet.swim();
}
// However, you cannot use property access
if (pet.fly) {
Property 'fly' does not exist on type 'Fish | Bird'.
  Property 'fly' does not exist on type 'Fish'.2339Property 'fly' does not exist on type 'Fish | Bird'.
  Property 'fly' does not exist on type 'Fish'.  pet.fly();
Property 'fly' does not exist on type 'Fish | Bird'.
  Property 'fly' does not exist on type 'Fish'.2339Property 'fly' does not exist on type 'Fish | Bird'.
  Property 'fly' does not exist on type 'Fish'.}Try</pre> <p>To get the same code working via property accessors, we’ll need to use a type assertion:</p> <pre data-language="typescript">let pet = getSmallPet();
let fishPet = pet as Fish;
let birdPet = pet as Bird;

if (fishPet.swim) {
  fishPet.swim();
} else if (birdPet.fly) {
  birdPet.fly();
}Try</pre> <p>This isn’t the sort of code you would want in your codebase however.</p> <h2 id="user-defined-type-guards" style="position:relative;">User-Defined Type Guards</h2> <p>It would be much better if once we performed the check, we could know the type of <code>pet</code> within each branch.</p> <p>It just so happens that TypeScript has something called a <em>type guard</em>. A type guard is some expression that performs a runtime check that guarantees the type in some scope.</p> <h4 id="using-type-predicates" style="position:relative;">Using type predicates</h4> <p>To define a type guard, we simply need to define a function whose return type is a <em>type predicate</em>:</p> <pre data-language="typescript">function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}Try</pre> <p><code>pet is Fish</code> is our type predicate in this example. A predicate takes the form <code>parameterName is Type</code>, where <code>parameterName</code> must be the name of a parameter from the current function signature.</p> <p>Any time <code>isFish</code> is called with some variable, TypeScript will <em>narrow</em> that variable to that specific type if the original type is compatible.</p> <pre data-language="typescript">// Both calls to 'swim' and 'fly' are now okay.
let pet = getSmallPet();

if (isFish(pet)) {
  pet.swim();
} else {
  pet.fly();
}Try</pre> <p>Notice that TypeScript not only knows that <code>pet</code> is a <code>Fish</code> in the <code>if</code> branch; it also knows that in the <code>else</code> branch, you <em>don’t</em> have a <code>Fish</code>, so you must have a <code>Bird</code>.</p> <p>You may use the type guard <code>isFish</code> to filter an array of <code>Fish | Bird</code> and obtain an array of <code>Fish</code>:</p> <pre data-language="typescript">const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];
const underWater1: Fish[] = zoo.filter(isFish);
// or, equivalently
const underWater2: Fish[] = zoo.filter&lt;Fish&gt;(isFish);
const underWater3: Fish[] = zoo.filter&lt;Fish&gt;(pet =&gt; isFish(pet));
Argument of type '(pet: Fish | Bird) =&gt; boolean' is not assignable to parameter of type '(value: Fish | Bird, index: number, array: (Fish | Bird)[]) =&gt; value is Fish'.
  Signature '(pet: Fish | Bird): boolean' must be a type predicate.2345Argument of type '(pet: Fish | Bird) =&gt; boolean' is not assignable to parameter of type '(value: Fish | Bird, index: number, array: (Fish | Bird)[]) =&gt; value is Fish'.
  Signature '(pet: Fish | Bird): boolean' must be a type predicate.Try</pre> <h3 id="using-the-in-operator" style="position:relative;">Using the <code>in</code> operator</h3> <p>The <code>in</code> operator also acts as a narrowing expression for types.</p> <p>For a <code>n in x</code> expression, where <code>n</code> is a string literal or string literal type and <code>x</code> is a union type, the “true” branch narrows to types which have an optional or required property <code>n</code>, and the “false” branch narrows to types which have an optional or missing property <code>n</code>.</p> <pre data-language="typescript">function move(pet: Fish | Bird) {
  if ("swim" in pet) {
    return pet.swim();
  }
  return pet.fly();
}Try</pre> <h2 id="typeof-type-guards" style="position:relative;">
<code>typeof</code> type guards</h2> <p>Let’s go back and write the code for a version of <code>padLeft</code> which uses union types. We could write it with type predicates as follows:</p> <pre data-language="typescript">function isNumber(x: any): x is number {
  return typeof x === "number";
}

function isString(x: any): x is string {
  return typeof x === "string";
}

function padLeft(value: string, padding: string | number) {
  if (isNumber(padding)) {
    return Array(padding + 1).join(" ") + value;
  }
  if (isString(padding)) {
    return padding + value;
  }
  throw new Error(`Expected string or number, got '${padding}'.`);
}Try</pre> <p>However, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don’t need to abstract <code>typeof x === "number"</code> into its own function because TypeScript will recognize it as a type guard on its own. That means we could just write these checks inline.</p> <pre data-language="typescript">function padLeft(value: string, padding: string | number) {
  if (typeof padding === "number") {
    return Array(padding + 1).join(" ") + value;
  }
  if (typeof padding === "string") {
    return padding + value;
  }
  throw new Error(`Expected string or number, got '${padding}'.`);
}Try</pre> <p>These <em><code>typeof</code> type guards</em> are recognized in two different forms: <code>typeof v === "typename"</code> and <code>typeof v !== "typename"</code>, where <code>"typename"</code> can be one of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#Description"><code>typeof</code> operator’s return values</a> (<code>"undefined"</code>, <code>"number"</code>, <code>"string"</code>, <code>"boolean"</code>, <code>"bigint"</code>, <code>"symbol"</code>, <code>"object"</code>, or <code>"function"</code>). While TypeScript won’t stop you from comparing to other strings, the language won’t recognize those expressions as type guards.</p> <h2 id="instanceof-type-guards" style="position:relative;">
<code>instanceof</code> type guards</h2> <p>If you’ve read about <code>typeof</code> type guards and are familiar with the <code>instanceof</code> operator in JavaScript, you probably have some idea of what this section is about.</p> <p><em><code>instanceof</code> type guards</em> are a way of narrowing types using their constructor function. For instance, let’s borrow our industrial strength string-padder example from earlier:</p> <pre data-language="typescript">interface Padder {
  getPaddingString(): string;
}

class SpaceRepeatingPadder implements Padder {
  constructor(private numSpaces: number) {}
  getPaddingString() {
    return Array(this.numSpaces + 1).join(" ");
  }
}

class StringPadder implements Padder {
  constructor(private value: string) {}
  getPaddingString() {
    return this.value;
  }
}

function getRandomPadder() {
  return Math.random() &lt; 0.5
    ? new SpaceRepeatingPadder(4)
    : new StringPadder("  ");
}

let padder: Padder = getRandomPadder();
//       ^ = let padder: Padder

if (padder instanceof SpaceRepeatingPadder) {
  padder;
//       ^ = Could not get LSP result: er;&gt;
//       &lt;  /
}
if (padder instanceof StringPadder) {
  padder;
//       ^ = Could not get LSP result: er;&gt;
//       &lt;  /
}Try</pre> <p>The right side of the <code>instanceof</code> needs to be a constructor function, and TypeScript will narrow down to:</p> <ol> <li>the type of the function’s <code>prototype</code> property if its type is not <code>any</code>
</li> <li>the union of types returned by that type’s construct signatures</li> </ol> <p>in that order.</p> <h2 id="nullable-types" style="position:relative;">Nullable types</h2> <p>TypeScript has two special types, <code>null</code> and <code>undefined</code>, that have the values null and undefined respectively. We mentioned these briefly in <a href="basic-types">the Basic Types section</a>.</p> <p>By default, the type checker considers <code>null</code> and <code>undefined</code> assignable to anything. Effectively, <code>null</code> and <code>undefined</code> are valid values of every type. That means it’s not possible to <em>stop</em> them from being assigned to any type, even when you would like to prevent it. The inventor of <code>null</code>, Tony Hoare, calls this his <a href="https://wikipedia.org/wiki/Null_pointer#History">“billion dollar mistake”</a>.</p> <p>The <a href="https://www.typescriptlang.org/tsconfig#strictNullChecks"><code>--strictNullChecks</code></a> flag fixes this: when you declare a variable, it doesn’t automatically include <code>null</code> or <code>undefined</code>. You can include them explicitly using a union type:</p> <pre data-language="typescript">let exampleString = "foo";
exampleString = null;
Type 'null' is not assignable to type 'string'.2322Type 'null' is not assignable to type 'string'.
let stringOrNull: string | null = "bar";
stringOrNull = null;

stringOrNull = undefined;
Type 'undefined' is not assignable to type 'string | null'.2322Type 'undefined' is not assignable to type 'string | null'.Try</pre> <p>Note that TypeScript treats <code>null</code> and <code>undefined</code> differently in order to match JavaScript semantics. <code>string | null</code> is a different type than <code>string | undefined</code> and <code>string | undefined | null</code>.</p> <p>From TypeScript 3.7 and onwards, you can use <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining">optional chaining</a> to simplify working with nullable types.</p> <h3 id="optional-parameters-and-properties" style="position:relative;">Optional parameters and properties</h3> <p>With <a href="https://www.typescriptlang.org/tsconfig#strictNullChecks"><code>--strictNullChecks</code></a>, an optional parameter automatically adds <code>| undefined</code>:</p> <pre data-language="typescript">function f(x: number, y?: number) {
  return x + (y ?? 0);
}

f(1, 2);
f(1);
f(1, undefined);
f(1, null);
Argument of type 'null' is not assignable to parameter of type 'number | undefined'.2345Argument of type 'null' is not assignable to parameter of type 'number | undefined'.Try</pre> <p>The same is true for optional properties:</p> <pre data-language="typescript">class C {
  a: number;
  b?: number;
}

let c = new C();

c.a = 12;
c.a = undefined;
Type 'undefined' is not assignable to type 'number'.2322Type 'undefined' is not assignable to type 'number'.c.b = 13;
c.b = undefined;
c.b = null;
Type 'null' is not assignable to type 'number | undefined'.2322Type 'null' is not assignable to type 'number | undefined'.Try</pre> <h3 id="type-guards-and-type-assertions" style="position:relative;">Type guards and type assertions</h3> <p>Since nullable types are implemented with a union, you need to use a type guard to get rid of the <code>null</code>. Fortunately, this is the same code you’d write in JavaScript:</p> <pre data-language="typescript">function f(stringOrNull: string | null): string {
  if (stringOrNull === null) {
    return "default";
  } else {
    return stringOrNull;
  }
}Try</pre> <p>The <code>null</code> elimination is pretty obvious here, but you can use terser operators too:</p> <pre data-language="typescript">function f(stringOrNull: string | null): string {
  return stringOrNull ?? "default";
}Try</pre> <p>In cases where the compiler can’t eliminate <code>null</code> or <code>undefined</code>, you can use the type assertion operator to manually remove them. The syntax is postfix <code>!</code>: <code>identifier!</code> removes <code>null</code> and <code>undefined</code> from the type of <code>identifier</code>:</p> <pre data-language="typescript">interface UserAccount {
  id: number;
  email?: string;
}

const user = getUser("admin");
user.id;
Object is possibly 'undefined'.2532Object is possibly 'undefined'.
if (user) {
  user.email.length;
Object is possibly 'undefined'.2532Object is possibly 'undefined'.}

// Instead if you are sure that these objects or fields exist, the
// postfix ! lets you short circuit the nullability
user!.email!.length;Try</pre> <h2 id="type-aliases" style="position:relative;">Type Aliases</h2> <p>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you’d otherwise have to write by hand.</p> <pre data-language="typescript">type Second = number;

let timeInSecond: number = 10;
let time: Second = 10;Try</pre> <p>Aliasing doesn’t actually create a new type - it creates a new <em>name</em> to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.</p> <p>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</p> <pre data-language="typescript">tstype Container&lt;T&gt; = { value: T };</pre> <p>We can also have a type alias refer to itself in a property:</p> <pre data-language="typescript">tstype Tree&lt;T&gt; = {
  value: T;
  left?: Tree&lt;T&gt;;
  right?: Tree&lt;T&gt;;
};</pre> <p>Together with <a href="unions-and-intersections">intersection</a> types, we can make some pretty mind-bending types:</p> <pre data-language="typescript">type LinkedList&lt;Type&gt; = Type &amp; { next: LinkedList&lt;Type&gt; };

interface Person {
  name: string;
}

let people = getDriversLicenseQueue();
people.name;
people.next.name;
people.next.next.name;
people.next.next.next.name;
//                  ^ = (property) next: LinkedListTry</pre> <h2 id="interfaces-vs-type-aliases" style="position:relative;">Interfaces vs. Type Aliases</h2> <p>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</p> <p>Almost all features of an <code>interface</code> are available in <code>type</code>, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.</p> <table class="full-width-table"> <tbody> <tr> <th><code>Interface</code></th> <th><code>Type</code></th> </tr> <tr> <td> <p>Extending an interface</p> <code><pre data-language="typescript">
interface Animal {
  name: string
}
interface Bear extends Animal {
  honey: boolean
}
const bear = getBear() 
bear.name
bear.honey
        </pre></code> </td> <td> <p>Extending a type via intersections</p> <code><pre data-language="typescript">
type Animal = {
  name: string
}
type Bear = Animal &amp; { 
  honey: Boolean 
}
const bear = getBear();
bear.name;
bear.honey;
        </pre></code> </td> </tr> <tr> <td> <p>Adding new fields to an existing interface</p> <code><pre data-language="typescript">
interface Window {
  title: string
}
interface Window {
  ts: import("typescript")
}
const src = 'const a = "Hello World"';
window.ts.transpileModule(src, {});
        </pre></code> </td> <td> <p>A type cannot be changed after being created</p> <code><pre data-language="typescript">
type Window = {
  title: string
}
type Window = {
  ts: import("typescript")
}
// Error: Duplicate identifier 'Window'.
        </pre></code> </td> </tr> </tbody> </table> <p>Because an interface more closely maps how JavaScript objects work <a href="https://wikipedia.org/wiki/Open/closed_principle">by being open to extension</a>, we recommend using an interface over a type alias when possible.</p> <p>On the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</p> <h2 id="enum-member-types" style="position:relative;">Enum Member Types</h2> <p>As mentioned in <a href="enums#union-enums-and-enum-member-types">our section on enums</a>, enum members have types when every member is literal-initialized.</p> <p>Much of the time when we talk about “singleton types”, we’re referring to both enum member types as well as numeric/string literal types, though many users will use “singleton types” and “literal types” interchangeably.</p> <h2 id="polymorphic-this-types" style="position:relative;">Polymorphic <code>this</code> types</h2> <p>A polymorphic <code>this</code> type represents a type that is the <em>subtype</em> of the containing class or interface. This is called <em>F</em>-bounded polymorphism, a lot of people know it as the <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent API</a> pattern. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns <code>this</code> after each operation:</p> <pre data-language="typescript">class BasicCalculator {
  public constructor(protected value: number = 0) {}
  public currentValue(): number {
    return this.value;
  }
  public add(operand: number): this {
    this.value += operand;
    return this;
  }
  public multiply(operand: number): this {
    this.value *= operand;
    return this;
  }
  // ... other operations go here ...
}

let v = new BasicCalculator(2).multiply(5).add(1).currentValue();Try</pre> <p>Since the class uses <code>this</code> types, you can extend it and the new class can use the old methods with no changes.</p> <pre data-language="typescript">class ScientificCalculator extends BasicCalculator {
  public constructor(value = 0) {
    super(value);
  }
  public sin() {
    this.value = Math.sin(this.value);
    return this;
  }
  // ... other operations go here ...
}

let v = new ScientificCalculator(2).multiply(5).sin().add(1).currentValue();Try</pre> <p>Without <code>this</code> types, <code>ScientificCalculator</code> would not have been able to extend <code>BasicCalculator</code> and keep the fluent interface. <code>multiply</code> would have returned <code>BasicCalculator</code>, which doesn’t have the <code>sin</code> method. However, with <code>this</code> types, <code>multiply</code> returns <code>this</code>, which is <code>ScientificCalculator</code> here.</p> <h2 id="index-types" style="position:relative;">Index types</h2> <p>With index types, you can get the compiler to check code that uses dynamic property names. For example, a common JavaScript pattern is to pick a subset of properties from an object:</p> <pre data-language="typescript">jsfunction pluck(o, propertyNames) {
  return propertyNames.map((n) =&gt; o[n]);
}</pre> <p>Here’s how you would write and use this function in TypeScript, using the <strong>index type query</strong> and <strong>indexed access</strong> operators:</p> <pre data-language="typescript">function pluck&lt;T, K extends keyof T&gt;(o: T, propertyNames: K[]): T[K][] {
  return propertyNames.map((n) =&gt; o[n]);
}

interface Car {
  manufacturer: string;
  model: string;
  year: number;
}

let taxi: Car = {
  manufacturer: "Toyota",
  model: "Camry",
  year: 2014,
};

// Manufacturer and model are both of type string,
// so we can pluck them both into a typed string array
let makeAndModel: string[] = pluck(taxi, ["manufacturer", "model"]);

// If we try to pluck model and year, we get an
// array of a union type: (string | number)[]
let modelYear = pluck(taxi, ["model", "year"]);Try</pre> <p>The compiler checks that <code>manufacturer</code> and <code>model</code> are actually properties on <code>Car</code>. The example introduces a couple of new type operators. First is <code>keyof T</code>, the <strong>index type query operator</strong>. For any type <code>T</code>, <code>keyof T</code> is the union of known, public property names of <code>T</code>. For example:</p> <pre data-language="typescript">let carProps: keyof Car;
//         ^ = let carProps: "manufacturer" | "model" | "year"Try</pre> <p><code>keyof Car</code> is completely interchangeable with <code>"manufacturer" | "model" | "year"</code>. The difference is that if you add another property to <code>Car</code>, say <code>ownersAddress: string</code>, then <code>keyof Car</code> will automatically update to be <code>"manufacturer" | "model" | "year" | "ownersAddress"</code>. And you can use <code>keyof</code> in generic contexts like <code>pluck</code>, where you can’t possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to <code>pluck</code>:</p> <pre data-language="typescript">ts// error, Type '"unknown"' is not assignable to type '"manufacturer" | "model" | "year"'
pluck(taxi, ["year", "unknown"]);</pre> <p>The second operator is <code>T[K]</code>, the <strong>indexed access operator</strong>. Here, the type syntax reflects the expression syntax. That means that <code>taxi["manufacturer"]</code> has the type <code>Car["manufacturer"]</code> — which in our example is just <code>string</code>. However, just like index type queries, you can use <code>T[K]</code> in a generic context, which is where its real power comes to life. You just have to make sure that the type variable <code>K extends keyof T</code>. Here’s another example with a function named <code>getProperty</code>.</p> <pre data-language="typescript">tsfunction getProperty&lt;T, K extends keyof T&gt;(o: T, propertyName: K): T[K] {
  return o[propertyName]; // o[propertyName] is of type T[K]
}</pre> <p>In <code>getProperty</code>, <code>o: T</code> and <code>propertyName: K</code>, so that means <code>o[propertyName]: T[K]</code>. Once you return the <code>T[K]</code> result, the compiler will instantiate the actual type of the key, so the return type of <code>getProperty</code> will vary according to which property you request.</p> <pre data-language="typescript">let manufacturer: string = getProperty(taxi, "manufacturer");
let year: number = getProperty(taxi, "year");

let unknown = getProperty(taxi, "unknown");
Argument of type '"unknown"' is not assignable to parameter of type '"manufacturer" | "model" | "year"'.2345Argument of type '"unknown"' is not assignable to parameter of type '"manufacturer" | "model" | "year"'.Try</pre> <h2 id="index-types-and-index-signatures" style="position:relative;">Index types and index signatures</h2> <p><code>keyof</code> and <code>T[K]</code> interact with index signatures. An index signature parameter type must be ‘string’ or ‘number’. If you have a type with a string index signature, <code>keyof T</code> will be <code>string | number</code> (and not just <code>string</code>, since in JavaScript you can access an object property either by using strings (<code>object["42"]</code>) or numbers (<code>object[42]</code>)). And <code>T[string]</code> is just the type of the index signature:</p> <pre data-language="typescript">interface Dictionary&lt;T&gt; {
  [key: string]: T;
}
let keys: keyof Dictionary&lt;number&gt;;
//     ^ = let keys: string | number
let value: Dictionary&lt;number&gt;["foo"];
//      ^ = let value: numberTry</pre> <p>If you have a type with a number index signature, <code>keyof T</code> will just be <code>number</code>.</p> <pre data-language="typescript">interface Dictionary&lt;T&gt; {
  [key: number]: T;
}

let keys: keyof Dictionary&lt;number&gt;;
//     ^ = let keys: number
let numberValue: Dictionary&lt;number&gt;[42];
//     ^ = let numberValue: number
let value: Dictionary&lt;number&gt;["foo"];
Property 'foo' does not exist on type 'Dictionary&lt;number&gt;'.2339Property 'foo' does not exist on type 'Dictionary&lt;number&gt;'.Try</pre> <h2 id="mapped-types" style="position:relative;">Mapped types</h2> <p>A common task is to take an existing type and make each of its properties optional:</p> <pre data-language="typescript">tsinterface PersonSubset {
  name?: string;
  age?: number;
}</pre> <p>Or we might want a readonly version:</p> <pre data-language="typescript">tsinterface PersonReadonly {
  readonly name: string;
  readonly age: number;
}</pre> <p>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types — <strong>mapped types</strong>. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties optional or of a type <code>readonly</code>. Here are a couple of examples:</p> <pre data-language="typescript">type Partial&lt;T&gt; = {
  [P in keyof T]?: T[P];
};

type Readonly&lt;T&gt; = {
  readonly [P in keyof T]: T[P];
};Try</pre> <p>And to use it:</p> <pre data-language="typescript">type PersonPartial = Partial&lt;Person&gt;;
//   ^ = type PersonPartial = {
//       name?: string | undefined;
//       age?: number | undefined;
//   }
type ReadonlyPerson = Readonly&lt;Person&gt;;
//   ^ = type ReadonlyPerson = {
//       readonly name: string;
//       readonly age: number;
//   }Try</pre> <p>Note that this syntax describes a type rather than a member. If you want to add members, you can use an intersection type:</p> <pre data-language="typescript">// Use this:
type PartialWithNewMember&lt;T&gt; = {
  [P in keyof T]?: T[P];
} &amp; { newMember: boolean }

// This is an error!
type WrongPartialWithNewMember&lt;T&gt; = {
  [P in keyof T]?: T[P];
  newMember: boolean;
'boolean' only refers to a type, but is being used as a value here.'}' expected.26931005'boolean' only refers to a type, but is being used as a value here.'}' expected.}
Declaration or statement expected.1128Declaration or statement expected.Try</pre> <p>Let’s take a look at the simplest mapped type and its parts:</p> <pre data-language="typescript">type Keys = "option1" | "option2";
type Flags = { [K in Keys]: boolean };Try</pre> <p>The syntax resembles the syntax for index signatures with a <code>for .. in</code> inside. There are three parts:</p> <ol> <li>The type variable <code>K</code>, which gets bound to each property in turn.</li> <li>The string literal union <code>Keys</code>, which contains the names of properties to iterate over.</li> <li>The resulting type of the property.</li> </ol> <p>In this simple example, <code>Keys</code> is a hard-coded list of property names and the property type is always <code>boolean</code>, so this mapped type is equivalent to writing:</p> <pre data-language="typescript">type Flags = {
  option1: boolean;
  option2: boolean;
};Try</pre> <p>Real applications, however, look like <code>Readonly</code> or <code>Partial</code> above. They’re based on some existing type, and they transform the properties in some way. That’s where <code>keyof</code> and indexed access types come in:</p> <pre data-language="typescript">type NullablePerson = { [P in keyof Person]: Person[P] | null };
//   ^ = type NullablePerson = {
//       name: string | null;
//       age: number | null;
//   }
type PartialPerson = { [P in keyof Person]?: Person[P] };
//   ^ = type PartialPerson = {
//       name?: string | undefined;
//       age?: number | undefined;
//   }Try</pre> <p>But it’s more useful to have a general version.</p> <pre data-language="typescript">tstype Nullable&lt;T&gt; = { [P in keyof T]: T[P] | null };
type Partial&lt;T&gt; = { [P in keyof T]?: T[P] };</pre> <p>In these examples, the properties list is <code>keyof T</code> and the resulting type is some variant of <code>T[P]</code>. This is a good template for any general use of mapped types. That’s because this kind of transformation is <a href="https://wikipedia.org/wiki/Homomorphism">homomorphic</a>, which means that the mapping applies only to properties of <code>T</code> and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if <code>Person.name</code> was readonly, <code>Partial&lt;Person&gt;.name</code> would be readonly and optional.</p> <p>Here’s one more example, in which <code>T[P]</code> is wrapped in a <code>Proxy&lt;T&gt;</code> class:</p> <pre data-language="typescript">type Proxy&lt;T&gt; = {
  get(): T;
  set(value: T): void;
};

type Proxify&lt;T&gt; = {
  [P in keyof T]: Proxy&lt;T[P]&gt;;
};

function proxify&lt;T&gt;(o: T): Proxify&lt;T&gt; {
  // ... wrap proxies ...
}

let props = { rooms: 4 };
let proxyProps = proxify(props);
//  ^ = let proxyProps: ProxifyTry</pre> <p>Note that <code>Readonly&lt;T&gt;</code> and <code>Partial&lt;T&gt;</code> are so useful, they are included in TypeScript’s standard library along with <code>Pick</code> and <code>Record</code>:</p> <pre data-language="typescript">tstype Pick&lt;T, K extends keyof T&gt; = {
  [P in K]: T[P];
};

type Record&lt;K extends keyof any, T&gt; = {
  [P in K]: T;
};</pre> <p><code>Readonly</code>, <code>Partial</code> and <code>Pick</code> are homomorphic whereas <code>Record</code> is not. One clue that <code>Record</code> is not homomorphic is that it doesn’t take an input type to copy properties from:</p> <pre data-language="typescript">type ThreeStringProps = Record&lt;"prop1" | "prop2" | "prop3", string&gt;;Try</pre> <p>Non-homomorphic types are essentially creating new properties, so they can’t copy property modifiers from anywhere.</p> <p>Note that <code>keyof any</code> represents the type of any value that can be used as an index to an object. In otherwords, <code>keyof any</code> is currently equal to <code>string | number | symbol</code>.</p> <h2 id="inference-from-mapped-types" style="position:relative;">Inference from mapped types</h2> <p>Now that you know how to wrap the properties of a type, the next thing you’ll want to do is unwrap them. Fortunately, that’s pretty easy:</p> <pre data-language="typescript">function unproxify&lt;T&gt;(t: Proxify&lt;T&gt;): T {
  let result = {} as T;
  for (const k in t) {
    result[k] = t[k].get();
  }
  return result;
}

let originalProps = unproxify(proxyProps);
//  ^ = let originalProps: {
//      rooms: number;
//  }Try</pre> <p>Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you’ll have to give an explicit type parameter to your unwrapping function.</p> <h2 id="conditional-types" style="position:relative;">Conditional Types</h2> <p>A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</p> <pre data-language="typescript">tsT extends U ? X : Y</pre> <p>The type above means when <code>T</code> is assignable to <code>U</code> the type is <code>X</code>, otherwise the type is <code>Y</code>.</p> <p>A conditional type <code>T extends U ? X : Y</code> is either <em>resolved</em> to <code>X</code> or <code>Y</code>, or <em>deferred</em> because the condition depends on one or more type variables. When <code>T</code> or <code>U</code> contains type variables, whether to resolve to <code>X</code> or <code>Y</code>, or to defer, is determined by whether or not the type system has enough information to conclude that <code>T</code> is always assignable to <code>U</code>.</p> <p>As an example of some types that are immediately resolved, we can take a look at the following example:</p> <pre data-language="typescript">declare function f&lt;T extends boolean&gt;(x: T): T extends true ? string : number;

// Type is 'string | number'
let x = f(Math.random() &lt; 0.5);
//  ^ = let x: string | numberTry</pre> <p>Another example would be the <code>TypeName</code> type alias, which uses nested conditional types:</p> <pre data-language="typescript">type TypeName&lt;T&gt; = T extends string
  ? "string"
  : T extends number
  ? "number"
  : T extends boolean
  ? "boolean"
  : T extends undefined
  ? "undefined"
  : T extends Function
  ? "function"
  : "object";

type T0 = TypeName&lt;string&gt;;
//   ^ = type T0 = "string"
type T1 = TypeName&lt;"a"&gt;;
//   ^ = type T1 = "string"
type T2 = TypeName&lt;true&gt;;
//   ^ = type T2 = "boolean"
type T3 = TypeName&lt;() =&gt; void&gt;;
//   ^ = type T3 = "function"
type T4 = TypeName&lt;string[]&gt;;
//   ^ = type T4 = "object"Try</pre> <p>But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:</p> <pre data-language="typescript">interface Foo {
  propA: boolean;
  propB: boolean;
}

declare function f&lt;T&gt;(x: T): T extends Foo ? string : number;

function foo&lt;U&gt;(x: U) {
  // Has type 'U extends Foo ? string : number'
  let a = f(x);

  // This assignment is allowed though!
  let b: string | number = a;
}Try</pre> <p>In the above, the variable <code>a</code> has a conditional type that hasn’t yet chosen a branch. When another piece of code ends up calling <code>foo</code>, it will substitute in <code>U</code> with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</p> <p>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign <code>U extends Foo ? string : number</code> to <code>string | number</code> since no matter what the conditional evaluates to, it’s known to be either <code>string</code> or <code>number</code>.</p> <h2 id="distributive-conditional-types" style="position:relative;">Distributive conditional types</h2> <p>Conditional types in which the checked type is a naked type parameter are called <em>distributive conditional types</em>. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of <code>T extends U ? X : Y</code> with the type argument <code>A | B | C</code> for <code>T</code> is resolved as <code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>.</p> <h4 id="example" style="position:relative;">Example</h4> <pre data-language="typescript">type T5 = TypeName&lt;string | (() =&gt; void)&gt;;
//   ^ = type T5 = "string" | "function"
type T6 = TypeName&lt;string | string[] | undefined&gt;;
//   ^ = type T6 = "string" | "undefined" | "object"
type T7 = TypeName&lt;string[] | number[]&gt;;
//   ^ = type T7 = "object"Try</pre> <p>In instantiations of a distributive conditional type <code>T extends U ? X : Y</code>, references to <code>T</code> within the conditional type are resolved to individual constituents of the union type (i.e. <code>T</code> refers to the individual constituents <em>after</em> the conditional type is distributed over the union type). Furthermore, references to <code>T</code> within <code>X</code> have an additional type parameter constraint <code>U</code> (i.e. <code>T</code> is considered assignable to <code>U</code> within <code>X</code>).</p> <h4 id="example-1" style="position:relative;">Example</h4> <pre data-language="typescript">type BoxedValue&lt;T&gt; = { value: T };
type BoxedArray&lt;T&gt; = { array: T[] };
type Boxed&lt;T&gt; = T extends any[] ? BoxedArray&lt;T[number]&gt; : BoxedValue&lt;T&gt;;

type T1 = Boxed&lt;string&gt;;
//   ^ = type T1 = {
//       value: string;
//   }
type T2 = Boxed&lt;number[]&gt;;
//   ^ = type T2 = {
//       array: number[];
//   }
type T3 = Boxed&lt;string | number[]&gt;;
//   ^ = type T3 = BoxedValue | BoxedArrayTry</pre> <p>Notice that <code>T</code> has the additional constraint <code>any[]</code> within the true branch of <code>Boxed&lt;T&gt;</code> and it is therefore possible to refer to the element type of the array as <code>T[number]</code>. Also, notice how the conditional type is distributed over the union type in the last example.</p> <p>The distributive property of conditional types can conveniently be used to <em>filter</em> union types:</p> <pre data-language="typescript">// Remove types from T that are assignable to U
type Diff&lt;T, U&gt; = T extends U ? never : T;
// Remove types from T that are not assignable to U
type Filter&lt;T, U&gt; = T extends U ? T : never;

type T1 = Diff&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;;
//   ^ = type T1 = "b" | "d"
type T2 = Filter&lt;"a" | "b" | "c" | "d", "a" | "c" | "f"&gt;; // "a" | "c"
//   ^ = type T2 = "a" | "c"
type T3 = Diff&lt;string | number | (() =&gt; void), Function&gt;; // string | number
//   ^ = type T3 = string | number
type T4 = Filter&lt;string | number | (() =&gt; void), Function&gt;; // () =&gt; void
//   ^ = type T4 = () =&gt; void

// Remove null and undefined from T
type NotNullable&lt;T&gt; = Diff&lt;T, null | undefined&gt;;

type T5 = NotNullable&lt;string | number | undefined&gt;;
//   ^ = type T5 = string | number
type T6 = NotNullable&lt;string | string[] | null | undefined&gt;;
//   ^ = type T6 = string | string[]

function f1&lt;T&gt;(x: T, y: NotNullable&lt;T&gt;) {
  x = y;
  y = x;
Type 'T' is not assignable to type 'Diff&lt;T, null | undefined&gt;'.2322Type 'T' is not assignable to type 'Diff&lt;T, null | undefined&gt;'.}

function f2&lt;T extends string | undefined&gt;(x: T, y: NotNullable&lt;T&gt;) {
  x = y;
  y = x;
Type 'T' is not assignable to type 'Diff&lt;T, null | undefined&gt;'.
  Type 'string | undefined' is not assignable to type 'Diff&lt;T, null | undefined&gt;'.
    Type 'undefined' is not assignable to type 'Diff&lt;T, null | undefined&gt;'.2322Type 'T' is not assignable to type 'Diff&lt;T, null | undefined&gt;'.
  Type 'string | undefined' is not assignable to type 'Diff&lt;T, null | undefined&gt;'.
    Type 'undefined' is not assignable to type 'Diff&lt;T, null | undefined&gt;'.  let s1: string = x;
Type 'T' is not assignable to type 'string'.
  Type 'string | undefined' is not assignable to type 'string'.
    Type 'undefined' is not assignable to type 'string'.2322Type 'T' is not assignable to type 'string'.
  Type 'string | undefined' is not assignable to type 'string'.
    Type 'undefined' is not assignable to type 'string'.  let s2: string = y;
}Try</pre> <p>Conditional types are particularly useful when combined with mapped types:</p> <pre data-language="typescript">type FunctionPropertyNames&lt;T&gt; = {
  [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];
type FunctionProperties&lt;T&gt; = Pick&lt;T, FunctionPropertyNames&lt;T&gt;&gt;;

type NonFunctionPropertyNames&lt;T&gt; = {
  [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T];
type NonFunctionProperties&lt;T&gt; = Pick&lt;T, NonFunctionPropertyNames&lt;T&gt;&gt;;

interface Part {
  id: number;
  name: string;
  subparts: Part[];
  updatePart(newName: string): void;
}

type T1 = FunctionPropertyNames&lt;Part&gt;;
//   ^ = type T1 = "updatePart"
type T2 = NonFunctionPropertyNames&lt;Part&gt;;
//   ^ = type T2 = "id" | "name" | "subparts"
type T3 = FunctionProperties&lt;Part&gt;;
//   ^ = type T3 = {
//       updatePart: (newName: string) =&gt; void;
//   }
type T4 = NonFunctionProperties&lt;Part&gt;;
//   ^ = type T4 = {
//       id: number;
//       name: string;
//       subparts: Part[];
//   }Try</pre> <p>Similar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.</p> <h4 id="example-2" style="position:relative;">Example</h4> <pre data-language="typescript">type ElementType&lt;T&gt; = T extends any[] ? ElementType&lt;T[number]&gt; : T; // ErrorTry</pre> <h2 id="type-inference-in-conditional-types" style="position:relative;">Type inference in conditional types</h2> <p>Within the <code>extends</code> clause of a conditional type, it is now possible to have <code>infer</code> declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple <code>infer</code> locations for the same type variable.</p> <p>For example, the following extracts the return type of a function type:</p> <pre data-language="typescript">type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;Try</pre> <p>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</p> <pre data-language="typescript">type Unpacked&lt;T&gt; = T extends (infer U)[]
  ? U
  : T extends (...args: any[]) =&gt; infer U
  ? U
  : T extends Promise&lt;infer U&gt;
  ? U
  : T;

type T0 = Unpacked&lt;string&gt;;
//   ^ = type T0 = string
type T1 = Unpacked&lt;string[]&gt;;
//   ^ = type T1 = string
type T2 = Unpacked&lt;() =&gt; string&gt;;
//   ^ = type T2 = string
type T3 = Unpacked&lt;Promise&lt;string&gt;&gt;;
//   ^ = type T3 = string
type T4 = Unpacked&lt;Promise&lt;string&gt;[]&gt;;
//   ^ = type T4 = Promise
type T5 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;;
//   ^ = type T5 = stringTry</pre> <p>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</p> <pre data-language="typescript">type Foo&lt;T&gt; = T extends { a: infer U; b: infer U } ? U : never;

type T1 = Foo&lt;{ a: string; b: string }&gt;;
//   ^ = type T1 = string
type T2 = Foo&lt;{ a: string; b: number }&gt;;
//   ^ = type T2 = string | numberTry</pre> <p>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</p> <pre data-language="typescript">type Bar&lt;T&gt; = T extends { a: (x: infer U) =&gt; void; b: (x: infer U) =&gt; void }
  ? U
  : never;

type T1 = Bar&lt;{ a: (x: string) =&gt; void; b: (x: string) =&gt; void }&gt;;
//   ^ = type T1 = string
type T2 = Bar&lt;{ a: (x: string) =&gt; void; b: (x: number) =&gt; void }&gt;;
//   ^ = type T2 = neverTry</pre> <p>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the <em>last</em> signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.</p> <pre data-language="typescript">declare function foo(x: string): number;
declare function foo(x: number): string;
declare function foo(x: string | number): string | number;

type T1 = ReturnType&lt;typeof foo&gt;;
//   ^ = type T1 = string | numberTry</pre> <p>It is not possible to use <code>infer</code> declarations in constraint clauses for regular type parameters:</p> <pre data-language="typescript">type ReturnedType&lt;T extends (...args: any[]) =&gt; infer R&gt; = R;
'infer' declarations are only permitted in the 'extends' clause of a conditional type.Cannot find name 'R'.13382304'infer' declarations are only permitted in the 'extends' clause of a conditional type.Cannot find name 'R'.Try</pre> <p>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</p> <pre data-language="typescript">type AnyFunction = (...args: any[]) =&gt; any;
type ReturnType&lt;T extends AnyFunction&gt; = T extends (...args: any[]) =&gt; infer R
  ? R
  : any;Try</pre> <h2 id="predefined-conditional-types" style="position:relative;">Predefined conditional types</h2> <p>TypeScript adds several predefined conditional types, you can find the full list and examples in <a href="utility-types">Utility Types</a>.</p>
</div></div></article>
</div></section></main><div id="language-recommendation" style="display:none">
<p id="language-recommendation-p">MSG</p>

</div>
</div></div>

</div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012-2020 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html" class="_attribution-link">https://www.typescriptlang.org/docs/handbook/advanced-types.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
