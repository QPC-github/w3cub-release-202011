
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Caching - Webpack - W3cubDocs</title>
  
  <meta name="description" content="So we&#39;re using webpack to bundle our modular application which yields a deployable &#47;dist directory. Once the contents of &#47;dist have been &hellip;">
  <meta name="keywords" content="caching, webpack">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/webpack/guides/caching.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/webpack.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/webpack/" class="_nav-link" title="" style="margin-left:0;">webpack</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _webpack">
				
				
<h1>Caching</h1>
<blockquote class="tip"> The examples in this guide stem from <a href="getting-started">getting started</a>, <a href="output-management">output management</a> and <a href="code-splitting">code splitting</a>. </blockquote>
<p>So we're using webpack to bundle our modular application which yields a deployable <code>/dist</code> directory. Once the contents of <code>/dist</code> have been deployed to a server, clients (typically browsers) will hit that server to grab the site and its assets. The last step can be time consuming, which is why browsers use a technique called <a href="https://searchstorage.techtarget.com/definition/cache">caching</a>. This allows sites to load faster with less unnecessary network traffic, however it can also cause headaches when you need new code to be picked up.</p> <p>This guide focuses on the configuration needed to ensure files produced by webpack compilation can remain cached unless their contents has changed.</p> <h2 class="header" id="output-filenames">  Output Filenames  </h2> <p>A simple way to ensure the browser picks up changed files is by using <code>output.filename</code> <a href="../configuration/output#output-filename">substitutions</a>. The <code>[hash]</code> substitution can be used to include a build-specific hash in the filename, however it's even better to use the <code>[contenthash]</code> substitution which is the hash of the content of a file, which is different for each asset.</p> <p>Let's get our project set up using the example from <a href="getting-started">getting started</a> with the <code>plugins</code> from <a href="output-management">output management</a>, so we don't have to deal with maintaining our <code>index.html</code> file manually:</p> <p><strong>project</strong></p> <pre data-language="diff">webpack-demo
|- package.json
|- webpack.config.js
|- /dist
|- /src
  |- index.js
|- /node_modules
</pre> <p><strong>webpack.config.js</strong></p> <pre data-language="diff">  const path = require('path');
  const CleanWebpackPlugin = require('clean-webpack-plugin');
  const HtmlWebpackPlugin = require('html-webpack-plugin');

  module.exports = {
    entry: './src/index.js',
    plugins: [
      new CleanWebpackPlugin(['dist']),
      new HtmlWebpackPlugin({
-       title: 'Output Management'
+       title: 'Caching'
      })
    ],
    output: {
-     filename: 'bundle.js',
+     filename: '[name].[contenthash].js',
      path: path.resolve(__dirname, 'dist')
    }
  };
</pre> <p>Running our build script, <code>npm run build</code>, with this configuration should produce the following output:</p> <pre data-language="bash">Hash: f7a289a94c5e4cd1e566
Version: webpack 3.5.1
Time: 835ms
                       Asset       Size  Chunks                    Chunk Names
main.7e2c49a622975ebd9b7e.js     544 kB       0  [emitted]  [big]  main
                  index.html  197 bytes          [emitted]
   [0] ./src/index.js 216 bytes {0} [built]
   [2] (webpack)/buildin/global.js 509 bytes {0} [built]
   [3] (webpack)/buildin/module.js 517 bytes {0} [built]
    + 1 hidden module
Child html-webpack-plugin for "index.html":
     1 asset
       [2] (webpack)/buildin/global.js 509 bytes {0} [built]
       [3] (webpack)/buildin/module.js 517 bytes {0} [built]
        + 2 hidden modules
</pre> <p>As you can see the bundle's name now reflects its content (via the hash). If we run another build without making any changes, we'd expect that filename to stay the same. However, if we were to run it again, we may find that this is not the case:</p> <pre data-language="bash">Hash: f7a289a94c5e4cd1e566
Version: webpack 3.5.1
Time: 835ms
                       Asset       Size  Chunks                    Chunk Names
main.205199ab45963f6a62ec.js     544 kB       0  [emitted]  [big]  main
                  index.html  197 bytes          [emitted]
   [0] ./src/index.js 216 bytes {0} [built]
   [2] (webpack)/buildin/global.js 509 bytes {0} [built]
   [3] (webpack)/buildin/module.js 517 bytes {0} [built]
    + 1 hidden module
Child html-webpack-plugin for "index.html":
     1 asset
       [2] (webpack)/buildin/global.js 509 bytes {0} [built]
       [3] (webpack)/buildin/module.js 517 bytes {0} [built]
        + 2 hidden modules
</pre> <p>This is because webpack includes certain boilerplate, specifically the runtime and manifest, in the entry chunk.</p> <blockquote class="warning"> Output may differ depending on your current webpack version. Newer versions may not have all the same issues with hashing as some older versions, but we still recommend the following steps to be safe. </blockquote>
<h2 class="header" id="extracting-boilerplate">  Extracting Boilerplate  </h2> <p>As we learned in <a href="code-splitting">code splitting</a>, the <a href="../plugins/split-chunks-plugin"><code>SplitChunksPlugin</code></a> can be used to split modules out into separate bundles. webpack provides an optimization feature which does split out runtime code into a separate chunk(s) according to the options provided, simply use <a href="../configuration/optimization#optimization-runtimechunk"><code>optimization.runtimeChunk</code></a> set to <code>single</code> for creating one runtime bundle:</p> <p><strong>webpack.config.js</strong></p> <pre data-language="diff">  const path = require('path');
  const CleanWebpackPlugin = require('clean-webpack-plugin');
  const HtmlWebpackPlugin = require('html-webpack-plugin');

  module.exports = {
    entry: './src/index.js',
    plugins: [
      new CleanWebpackPlugin(['dist']),
      new HtmlWebpackPlugin({
        title: 'Caching'
    ],
    output: {
      filename: '[name].[contenthash].js',
      path: path.resolve(__dirname, 'dist')
    },
+   optimization: {
+     runtimeChunk: 'single'
+   }
  };
</pre> <p>Let's run another build to see the extracted <code>runtime</code> bundle:</p> <pre data-language="bash">Hash: 82c9c385607b2150fab2
Version: webpack 4.12.0
Time: 3027ms
                          Asset       Size  Chunks             Chunk Names
runtime.cc17ae2a94ec771e9221.js   1.42 KiB       0  [emitted]  runtime
   main.e81de2cf758ada72f306.js   69.5 KiB       1  [emitted]  main
                     index.html  275 bytes          [emitted]
[1] (webpack)/buildin/module.js 497 bytes {1} [built]
[2] (webpack)/buildin/global.js 489 bytes {1} [built]
[3] ./src/index.js 309 bytes {1} [built]
    + 1 hidden module
</pre> <p>It's also good practice to extract third-party libraries, such as <code>lodash</code> or <code>react</code>, to a separate <code>vendor</code> chunk as they are less likely to change than our local source code. This step will allow clients to request even less from the server to stay up to date. This can be done by using the <a href="../plugins/split-chunks-plugin#splitchunks-cachegroups"><code>cacheGroups</code></a> option of the <a href="../plugins/split-chunks-plugin"><code>SplitChunksPlugin</code></a> demonstrated in <a href="../plugins/split-chunks-plugin#split-chunks-example-2">Example 2 of SplitChunksPlugin</a>. Lets add <code>optimization.splitChunks</code> with <code>cacheGroups</code> with next params and build:</p> <p><strong>webpack.config.js</strong></p> <pre data-language="diff">  var path = require('path');
  const CleanWebpackPlugin = require('clean-webpack-plugin');
  const HtmlWebpackPlugin = require('html-webpack-plugin');

  module.exports = {
    entry: './src/index.js',
    plugins: [
      new CleanWebpackPlugin(['dist']),
      new HtmlWebpackPlugin({
        title: 'Caching'
      }),
    ],
    output: {
      filename: '[name].[contenthash].js',
      path: path.resolve(__dirname, 'dist')
    },
    optimization: {
-     runtimeChunk: 'single'
+     runtimeChunk: 'single',
+     splitChunks: {
+       cacheGroups: {
+         vendor: {
+           test: /[\\/]node_modules[\\/]/,
+           name: 'vendors',
+           chunks: 'all'
+         }
+       }
+     }
    }
  };
</pre> <p>Let's run another build to see our new <code>vendor</code> bundle:</p> <pre data-language="bash">Hash: 213f57fc3bb5cb47c719
Version: webpack 4.12.0
Time: 475ms
                          Asset       Size  Chunks             Chunk Names
runtime.cc17ae2a94ec771e9221.js   1.42 KiB       0  [emitted]  runtime
vendors.a42c3ca0d742766d7a28.js   69.4 KiB       1  [emitted]  vendors
   main.abf44fedb7d11d4312d7.js  240 bytes       2  [emitted]  main
                     index.html  353 bytes          [emitted]
[1] (webpack)/buildin/module.js 497 bytes {1} [built]
[2] (webpack)/buildin/global.js 489 bytes {1} [built]
[3] ./src/index.js 309 bytes {2} [built]
    + 1 hidden module
</pre> <p>We can now see that our <code>main</code> bundle does not contain <code>vendor</code> code from <code>node_modules</code> directory and is down in size to <code>240 bytes</code>!</p> <h2 class="header" id="module-identifiers">  Module Identifiers  </h2> <p>Let's add another module, <code>print.js</code>, to our project:</p> <p><strong>project</strong></p> <pre data-language="diff">webpack-demo
|- package.json
|- webpack.config.js
|- /dist
|- /src
  |- index.js
+ |- print.js
|- /node_modules
</pre> <p><strong>print.js</strong></p> <pre data-language="diff">+ export default function print(text) {
+   console.log(text);
+ };
</pre> <p><strong>src/index.js</strong></p> <pre data-language="diff">  import _ from 'lodash';
+ import Print from './print';

  function component() {
    var element = document.createElement('div');

    // Lodash, now imported by this script
    element.innerHTML = _.join(['Hello', 'webpack'], ' ');
+   element.onclick = Print.bind(null, 'Hello webpack!');

    return element;
  }

  document.body.appendChild(component());
</pre> <p>Running another build, we would expect only our <code>main</code> bundle's hash to change, however...</p> <pre data-language="bash">Hash: d38a06644fdbb898d795
Version: webpack 3.3.0
Time: 1445ms
                           Asset       Size  Chunks                    Chunk Names
  vendor.a7561fb0e9a071baadb9.js     541 kB       0  [emitted]  [big]  vendor
    main.b746e3eb72875af2caa9.js    1.22 kB       1  [emitted]         main
manifest.1400d5af64fc1b7b3a45.js    5.85 kB       2  [emitted]         manifest
                      index.html  352 bytes          [emitted]
   [1] ./src/index.js 421 bytes {1} [built]
   [2] (webpack)/buildin/global.js 509 bytes {0} [built]
   [3] (webpack)/buildin/module.js 517 bytes {0} [built]
   [4] ./src/print.js 62 bytes {1} [built]
   [5] multi lodash 28 bytes {0} [built]
    + 1 hidden module
</pre> <p>... we can see that all three have. This is because each <a href="../api/module-variables#module-id-commonjs-"><code>module.id</code></a> is incremented based on resolving order by default. Meaning when the order of resolving is changed, the IDs will be changed as well. So, to recap:</p> <ul> <li>The <code>main</code> bundle changed because of its new content.</li> <li>The <code>vendor</code> bundle changed because its <code>module.id</code> was changed.</li> <li>And, the <code>manifest</code> bundle changed because it now contains a reference to a new module.</li> </ul> <p>The first and last are expected -- it's the <code>vendor</code> hash we want to fix. Luckily, there are two plugins we can use to resolve this issue. The first is the <code>NamedModulesPlugin</code>, which will use the path to the module rather than a numerical identifier. While this plugin is useful during development for more readable output, it does take a bit longer to run. The second option is the <a href="../plugins/hashed-module-ids-plugin"><code>HashedModuleIdsPlugin</code></a>, which is recommended for production builds:</p> <p><strong>webpack.config.js</strong></p> <pre data-language="diff">  const path = require('path');
  const webpack = require('webpack');
  const CleanWebpackPlugin = require('clean-webpack-plugin');
  const HtmlWebpackPlugin = require('html-webpack-plugin');

  module.exports = {
    entry: './src/index.js',
    plugins: [
      new CleanWebpackPlugin(['dist']),
      new HtmlWebpackPlugin({
        title: 'Caching'
      }),
+      new webpack.HashedModuleIdsPlugin()
    ],
    output: {
      filename: '[name].[contenthash].js',
      path: path.resolve(__dirname, 'dist')
    },
    optimization: {
      runtimeChunk: 'single',
      splitChunks: {
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all'
          }
        }
      }
    }
  };
</pre> <p>Now, despite any new local dependencies, our <code>vendor</code> hash should stay consistent between builds:</p> <pre data-language="bash">Hash: 17c37ce65c84b8ed5eb8
Version: webpack 4.16.2
Time: 637ms
                          Asset       Size  Chunks             Chunk Names
   main.216e852f60c8829c2289.js  340 bytes       0  [emitted]  main
vendors.55e79e5927a639d21a1b.js   69.5 KiB       1  [emitted]  vendors
runtime.725a1a51ede5ae0cfde0.js   1.42 KiB       2  [emitted]  runtime
                     index.html  353 bytes          [emitted]
Entrypoint main = runtime.725a1a51ede5ae0cfde0.js vendors.55e79e5927a639d21a1b.js main.216e852f60c8829c2289.js
[YuTi] (webpack)/buildin/module.js 497 bytes {1} [built]
[tjUo] ./src/index.js + 1 modules 408 bytes {0} [built]
    | ./src/index.js 341 bytes [built]
    | ./src/print.js 62 bytes [built]
[yLpj] (webpack)/buildin/global.js 489 bytes {1} [built]
    + 1 hidden module
Child html-webpack-plugin for "index.html":
     1 asset
    Entrypoint undefined = index.html
    [YuTi] (webpack)/buildin/module.js 497 bytes {0} [built]
    [yLpj] (webpack)/buildin/global.js 489 bytes {0} [built]
        + 2 hidden modules
</pre> <p>And let's modify our <code>src/index.js</code> to temporarily remove that extra dependency:</p> <p><strong>src/index.js</strong></p> <pre data-language="diff">  import _ from 'lodash';
- import Print from './print';
+ // import Print from './print';

  function component() {
    var element = document.createElement('div');

    // Lodash, now imported by this script
    element.innerHTML = _.join(['Hello', 'webpack'], ' ');
-   element.onclick = Print.bind(null, 'Hello webpack!');
+   // element.onclick = Print.bind(null, 'Hello webpack!');

    return element;
  }

  document.body.appendChild(component());
</pre> <p>And finally run our build again:</p> <pre data-language="bash">Hash: 70fb9e00dee0bada797d
Version: webpack 4.16.2
Time: 875ms
                          Asset       Size  Chunks             Chunk Names
   main.ad717f2466ce655fff5c.js  274 bytes       0  [emitted]  main
vendors.55e79e5927a639d21a1b.js   69.5 KiB       1  [emitted]  vendors
runtime.725a1a51ede5ae0cfde0.js   1.42 KiB       2  [emitted]  runtime
                     index.html  353 bytes          [emitted]
Entrypoint main = runtime.725a1a51ede5ae0cfde0.js vendors.55e79e5927a639d21a1b.js main.ad717f2466ce655fff5c.js
[YuTi] (webpack)/buildin/module.js 497 bytes {1} [built]
[tjUo] ./src/index.js 347 bytes {0} [built]
[yLpj] (webpack)/buildin/global.js 489 bytes {1} [built]
    + 1 hidden module
Child html-webpack-plugin for "index.html":
     1 asset
    Entrypoint undefined = index.html
    [YuTi] (webpack)/buildin/module.js 497 bytes {0} [built]
    [yLpj] (webpack)/buildin/global.js 489 bytes {0} [built]
        + 2 hidden modules
</pre> <p>We can see that both builds yielded <code>55e79e5927a639d21a1b</code> in the <code>vendor</code> bundle's filename.</p> <h2 class="header" id="conclusion">  Conclusion  </h2> <p>Caching gets messy. Plain and simple. However the walk-through above should give you a running start to deploying consistent, cachable assets. See the <em>Further Reading</em> section below to learn more.</p> <h3>Further Reading</h3>
<ul><li><a href="https://github.com/webpack/webpack.js.org/issues/652">Issue 652</a></li></ul>
<div class="_attribution">
  <p class="_attribution-p">
    © JS Foundation and other contributors<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://webpack.js.org/guides/caching" class="_attribution-link">https://webpack.js.org/guides/caching</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
