
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>ParSeq - Scala 2.12 Library - W3cubDocs</title>
  
  <meta name="description" content=" A mutable variant of ParSeq. ">
  <meta name="keywords" content="trait, scala, collection, parallel, mutable, parseq, library, scala~2.12_library">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/scala~2.12_library/scala/collection/parallel/mutable/parseq.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/scala~2.12_library.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scala~2.12_library/" class="_nav-link" title="" style="margin-left:0;">Scala 2.12 Library</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _scala">
				
				
<h1>Trait scala.collection.parallel.mutable.ParSeq</h1>
<h3><span class="morelinks"><div> Companion <a href="parseq%24" title="See companion object">object ParSeq</a> </div></span></h3> <h2 id="signature"> <span class="modifier_kind">  <span class="kind">trait</span> </span> <span class="symbol"> <span class="name">ParSeq</span><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <a href="../../genseq" class="extype" name="scala.collection.GenSeq">GenSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>] with <a href="pariterable" class="extype" name="scala.collection.parallel.mutable.ParIterable">ParIterable</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>] with <a href="../parseq" class="extype" name="scala.collection.parallel.ParSeq">parallel.ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>] with <a href="../../generic/genericpartemplate" class="extype" name="scala.collection.generic.GenericParTemplate">GenericParTemplate</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>] with <a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>], <a href="../../mutable/seq" class="extype" name="scala.collection.mutable.Seq">mutable.Seq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]]</span> </span> </h2> <div id="comment" class="fullcommenttop">
<div class="comment cmt"><p>A mutable variant of <code>ParSeq</code>.</p></div>
<dl class="attributes block"> <dt>Self Type</dt>
<dd>
<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</dd>
<dt>Source</dt>
<dd><a href="https://github.com/scala/scala/tree/v2.12.9/src/library/scala/collection/parallel/mutable/ParSeq.scala#L29" target="_blank">ParSeq.scala</a></dd>
</dl>
<div class="toggleContainer block"> <span class="toggle"> Linear Supertypes </span>  </div>
<div class="toggleContainer block"> <span class="toggle"> Known Subclasses </span>  </div>
</div>  <div id="template"> <div id="allMembers"> <div id="types" class="types members"> <h2>Type Members</h2> <h3 id="scala.collection.parallel.ParIterableLike.Aggregate">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24aggregate"><span class="name">Aggregate</span></a><span class="tparams">[<span name="S">S</span>]</span><span class="result"> extends <a href="../pariterablelike%24accessor" class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">Accessor</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Aggregate.S">S</span>, <a href="../pariterablelike%24aggregate" class="extype" name="scala.collection.parallel.ParIterableLike.Aggregate">Aggregate</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Aggregate.S">S</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.BuilderOps">
<span class="modifier_kind">  <span class="kind">trait </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24builderops"><span class="name">BuilderOps</span></a><span class="tparams">[<span name="Elem">Elem</span>, <span name="To">To</span>]</span><span class="result"> extends <a href="../../../anyref" class="extype" name="scala.AnyRef">AnyRef</a></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Collect">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24collect"><span class="name">Collect</span></a><span class="tparams">[<span name="S">S</span>, <span name="That">That</span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Collect.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Collect.That">That</span>], <a href="../pariterablelike%24collect" class="extype" name="scala.collection.parallel.ParIterableLike.Collect">Collect</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Collect.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Collect.That">That</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Composite">
<span class="modifier_kind"> <span class="modifier">abstract </span> <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24composite"><span class="name">Composite</span></a><span class="tparams">[<span name="FR">FR</span>, <span name="SR">SR</span>, <span name="R">R</span>, <span name="First">First &lt;: <a href="../pariterablelike%24strictsplitterchecktask" class="extype" name="scala.collection.parallel.ParIterableLike.StrictSplitterCheckTask">StrictSplitterCheckTask</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Composite.FR">FR</span>, _]</span>, <span name="Second">Second &lt;: <a href="../pariterablelike%24strictsplitterchecktask" class="extype" name="scala.collection.parallel.ParIterableLike.StrictSplitterCheckTask">StrictSplitterCheckTask</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Composite.SR">SR</span>, _]</span>]</span><span class="result"> extends <a href="../pariterablelike%24nondivisibletask" class="extype" name="scala.collection.parallel.ParIterableLike.NonDivisibleTask">NonDivisibleTask</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Composite.R">R</span>, <a href="../pariterablelike%24composite" class="extype" name="scala.collection.parallel.ParIterableLike.Composite">Composite</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Composite.FR">FR</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Composite.SR">SR</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Composite.R">R</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Composite.First">First</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Composite.Second">Second</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Copy">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24copy"><span class="name">Copy</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="That">That</span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Copy.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Copy.That">That</span>], <a href="../pariterablelike%24copy" class="extype" name="scala.collection.parallel.ParIterableLike.Copy">Copy</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Copy.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Copy.That">That</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.CopyToArray">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24copytoarray"><span class="name">CopyToArray</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="This">This &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.Repr">Repr</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24accessor" class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">Accessor</a>[<a href="../../../unit" class="extype" name="scala.Unit">Unit</a>, <a href="../pariterablelike%24copytoarray" class="extype" name="scala.collection.parallel.ParIterableLike.CopyToArray">CopyToArray</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.CopyToArray.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.CopyToArray.This">This</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Count">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24count"><span class="name">Count</span></a><span class="result"> extends <a href="../pariterablelike%24accessor" class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">Accessor</a>[<a href="../../../int" class="extype" name="scala.Int">Int</a>, <a href="../pariterablelike%24count" class="extype" name="scala.collection.parallel.ParIterableLike.Count">Count</a>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.CreateScanTree">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24createscantree"><span class="name">CreateScanTree</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<a href="../pariterablelike%24scantree" class="extype" name="scala.collection.parallel.ParIterableLike.ScanTree">ScanTree</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.CreateScanTree.U">U</span>], <a href="../pariterablelike%24createscantree" class="extype" name="scala.collection.parallel.ParIterableLike.CreateScanTree">CreateScanTree</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.CreateScanTree.U">U</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Drop">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24drop"><span class="name">Drop</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="This">This &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.Repr">Repr</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Drop.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Drop.This">This</span>], <a href="../pariterablelike%24drop" class="extype" name="scala.collection.parallel.ParIterableLike.Drop">Drop</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Drop.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Drop.This">This</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Exists">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24exists"><span class="name">Exists</span></a><span class="result"> extends <a href="../pariterablelike%24accessor" class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">Accessor</a>[<a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a>, <a href="../pariterablelike%24exists" class="extype" name="scala.collection.parallel.ParIterableLike.Exists">Exists</a>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Filter">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24filter"><span class="name">Filter</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="This">This &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.Repr">Repr</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Filter.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Filter.This">This</span>], <a href="../pariterablelike%24filter" class="extype" name="scala.collection.parallel.ParIterableLike.Filter">Filter</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Filter.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Filter.This">This</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.FilterNot">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24filternot"><span class="name">FilterNot</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="This">This &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.Repr">Repr</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.FilterNot.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.FilterNot.This">This</span>], <a href="../pariterablelike%24filternot" class="extype" name="scala.collection.parallel.ParIterableLike.FilterNot">FilterNot</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.FilterNot.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.FilterNot.This">This</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Find">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24find"><span class="name">Find</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24accessor" class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">Accessor</a>[<a href="../../../option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Find.U">U</span>], <a href="../pariterablelike%24find" class="extype" name="scala.collection.parallel.ParIterableLike.Find">Find</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Find.U">U</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.FlatMap">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24flatmap"><span class="name">FlatMap</span></a><span class="tparams">[<span name="S">S</span>, <span name="That">That</span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.FlatMap.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.FlatMap.That">That</span>], <a href="../pariterablelike%24flatmap" class="extype" name="scala.collection.parallel.ParIterableLike.FlatMap">FlatMap</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.FlatMap.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.FlatMap.That">That</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Fold">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24fold"><span class="name">Fold</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24accessor" class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">Accessor</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Fold.U">U</span>, <a href="../pariterablelike%24fold" class="extype" name="scala.collection.parallel.ParIterableLike.Fold">Fold</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Fold.U">U</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Forall">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24forall"><span class="name">Forall</span></a><span class="result"> extends <a href="../pariterablelike%24accessor" class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">Accessor</a>[<a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a>, <a href="../pariterablelike%24forall" class="extype" name="scala.collection.parallel.ParIterableLike.Forall">Forall</a>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Foreach">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24foreach"><span class="name">Foreach</span></a><span class="tparams">[<span name="S">S</span>]</span><span class="result"> extends <a href="../pariterablelike%24accessor" class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">Accessor</a>[<a href="../../../unit" class="extype" name="scala.Unit">Unit</a>, <a href="../pariterablelike%24foreach" class="extype" name="scala.collection.parallel.ParIterableLike.Foreach">Foreach</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Foreach.S">S</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.FromScanTree">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24fromscantree"><span class="name">FromScanTree</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="That">That</span>]</span><span class="result"> extends <a href="../pariterablelike%24strictsplitterchecktask" class="extype" name="scala.collection.parallel.ParIterableLike.StrictSplitterCheckTask">StrictSplitterCheckTask</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.FromScanTree.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.FromScanTree.That">That</span>], <a href="../pariterablelike%24fromscantree" class="extype" name="scala.collection.parallel.ParIterableLike.FromScanTree">FromScanTree</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.FromScanTree.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.FromScanTree.That">That</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.GroupBy">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24groupby"><span class="name">GroupBy</span></a><span class="tparams">[<span name="K">K</span>, <span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<span class="extype" name="scala.collection.parallel.immutable.HashMapCombiner">HashMapCombiner</span>[<span class="extype" name="scala.collection.parallel.ParIterableLike.GroupBy.K">K</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.GroupBy.U">U</span>], <a href="../pariterablelike%24groupby" class="extype" name="scala.collection.parallel.ParIterableLike.GroupBy">GroupBy</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.GroupBy.K">K</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.GroupBy.U">U</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Map">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24map"><span class="name">Map</span></a><span class="tparams">[<span name="S">S</span>, <span name="That">That</span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Map.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Map.That">That</span>], <a href="../pariterablelike%24map" class="extype" name="scala.collection.parallel.ParIterableLike.Map">Map</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Map.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Map.That">That</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Max">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24max"><span class="name">Max</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24accessor" class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">Accessor</a>[<a href="../../../option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Max.U">U</span>], <a href="../pariterablelike%24max" class="extype" name="scala.collection.parallel.ParIterableLike.Max">Max</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Max.U">U</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Min">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24min"><span class="name">Min</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24accessor" class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">Accessor</a>[<a href="../../../option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Min.U">U</span>], <a href="../pariterablelike%24min" class="extype" name="scala.collection.parallel.ParIterableLike.Min">Min</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Min.U">U</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.NonDivisible">
<span class="modifier_kind">  <span class="kind">trait </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24nondivisible"><span class="name">NonDivisible</span></a><span class="tparams">[<span name="R">R</span>]</span><span class="result"> extends <a href="../pariterablelike%24nondivisibletask" class="extype" name="scala.collection.parallel.ParIterableLike.NonDivisibleTask">NonDivisibleTask</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.NonDivisible.R">R</span>, <a href="../pariterablelike%24nondivisible" class="extype" name="scala.collection.parallel.ParIterableLike.NonDivisible">NonDivisible</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.NonDivisible.R">R</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.NonDivisibleTask">
<span class="modifier_kind">  <span class="kind">trait </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24nondivisibletask"><span class="name">NonDivisibleTask</span></a><span class="tparams">[<span name="R">R</span>, <span name="Tp">Tp</span>]</span><span class="result"> extends <a href="../pariterablelike%24strictsplitterchecktask" class="extype" name="scala.collection.parallel.ParIterableLike.StrictSplitterCheckTask">StrictSplitterCheckTask</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.NonDivisibleTask.R">R</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.NonDivisibleTask.Tp">Tp</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.ParComposite">
<span class="modifier_kind"> <span class="modifier">abstract </span> <span class="kind">class </span> </span><span class="symbol"> <a title="Performs two tasks in parallel, and waits for both to finish." href="../pariterablelike%24parcomposite"><span class="name">ParComposite</span></a><span class="tparams">[<span name="FR">FR</span>, <span name="SR">SR</span>, <span name="R">R</span>, <span name="First">First &lt;: <a href="../pariterablelike%24strictsplitterchecktask" class="extype" name="scala.collection.parallel.ParIterableLike.StrictSplitterCheckTask">StrictSplitterCheckTask</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ParComposite.FR">FR</span>, _]</span>, <span name="Second">Second &lt;: <a href="../pariterablelike%24strictsplitterchecktask" class="extype" name="scala.collection.parallel.ParIterableLike.StrictSplitterCheckTask">StrictSplitterCheckTask</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ParComposite.SR">SR</span>, _]</span>]</span><span class="result"> extends <a href="../pariterablelike%24composite" class="extype" name="scala.collection.parallel.ParIterableLike.Composite">Composite</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ParComposite.FR">FR</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ParComposite.SR">SR</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ParComposite.R">R</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ParComposite.First">First</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ParComposite.Second">Second</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Performs two tasks in parallel, and waits for both to finish.</p></div>
<dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl>
</div> <h3 id="scala.collection.parallel.ParIterableLike.Partition">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24partition"><span class="name">Partition</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="This">This &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.Repr">Repr</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[(<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Partition.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Partition.This">This</span>], <a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Partition.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Partition.This">This</span>]), <a href="../pariterablelike%24partition" class="extype" name="scala.collection.parallel.ParIterableLike.Partition">Partition</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Partition.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Partition.This">This</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Product">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24product"><span class="name">Product</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24accessor" class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">Accessor</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Product.U">U</span>, <a href="../pariterablelike%24product" class="extype" name="scala.collection.parallel.ParIterableLike.Product">Product</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Product.U">U</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Reduce">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24reduce"><span class="name">Reduce</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24accessor" class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">Accessor</a>[<a href="../../../option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Reduce.U">U</span>], <a href="../pariterablelike%24reduce" class="extype" name="scala.collection.parallel.ParIterableLike.Reduce">Reduce</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Reduce.U">U</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.ResultMapping">
<span class="modifier_kind"> <span class="modifier">abstract </span> <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24resultmapping"><span class="name">ResultMapping</span></a><span class="tparams">[<span name="R">R</span>, <span name="Tp">Tp</span>, <span name="R1">R1</span>]</span><span class="result"> extends <a href="../pariterablelike%24nondivisibletask" class="extype" name="scala.collection.parallel.ParIterableLike.NonDivisibleTask">NonDivisibleTask</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ResultMapping.R1">R1</span>, <a href="../pariterablelike%24resultmapping" class="extype" name="scala.collection.parallel.ParIterableLike.ResultMapping">ResultMapping</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ResultMapping.R">R</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ResultMapping.Tp">Tp</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ResultMapping.R1">R1</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.ScanLeaf">
<span class="modifier_kind">  <span class="kind">case class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24scanleaf"><span class="name">ScanLeaf</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>]</span><span class="params">(<span name="pit">pit: <a href="../iterablesplitter" class="extype" name="scala.collection.parallel.IterableSplitter">IterableSplitter</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ScanLeaf.U">U</span>]</span>, <span name="op">op: (<span class="extype" name="scala.collection.parallel.ParIterableLike.ScanLeaf.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ScanLeaf.U">U</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.ScanLeaf.U">U</span></span>, <span name="from">from: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>, <span name="len">len: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>, <span name="prev">prev: <a href="../../../option" class="extype" name="scala.Option">Option</a>[<a href="../pariterablelike%24scanleaf" class="extype" name="scala.collection.parallel.ParIterableLike.ScanLeaf">ScanLeaf</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ScanLeaf.U">U</span>]]</span>, <span name="acc">acc: <span class="extype" name="scala.collection.parallel.ParIterableLike.ScanLeaf.U">U</span></span>)</span><span class="result"> extends <a href="../pariterablelike%24scantree" class="extype" name="scala.collection.parallel.ParIterableLike.ScanTree">ScanTree</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ScanLeaf.U">U</span>] with <a href="../../../product" class="extype" name="scala.Product">scala.Product</a> with <a href="../../../serializable" class="extype" name="scala.Serializable">Serializable</a></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.ScanNode">
<span class="modifier_kind">  <span class="kind">case class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24scannode"><span class="name">ScanNode</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>]</span><span class="params">(<span name="left">left: <a href="../pariterablelike%24scantree" class="extype" name="scala.collection.parallel.ParIterableLike.ScanTree">ScanTree</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ScanNode.U">U</span>]</span>, <span name="right">right: <a href="../pariterablelike%24scantree" class="extype" name="scala.collection.parallel.ParIterableLike.ScanTree">ScanTree</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ScanNode.U">U</span>]</span>)</span><span class="result"> extends <a href="../pariterablelike%24scantree" class="extype" name="scala.collection.parallel.ParIterableLike.ScanTree">ScanTree</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ScanNode.U">U</span>] with <a href="../../../product" class="extype" name="scala.Product">scala.Product</a> with <a href="../../../serializable" class="extype" name="scala.Serializable">Serializable</a></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.ScanTree">
<span class="modifier_kind">  <span class="kind">trait </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24scantree"><span class="name">ScanTree</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>]</span><span class="result"> extends <a href="../../../anyref" class="extype" name="scala.AnyRef">AnyRef</a></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.SeqComposite">
<span class="modifier_kind"> <span class="modifier">abstract </span> <span class="kind">class </span> </span><span class="symbol"> <a title="Sequentially performs one task after another." href="../pariterablelike%24seqcomposite"><span class="name">SeqComposite</span></a><span class="tparams">[<span name="FR">FR</span>, <span name="SR">SR</span>, <span name="R">R</span>, <span name="First">First &lt;: <a href="../pariterablelike%24strictsplitterchecktask" class="extype" name="scala.collection.parallel.ParIterableLike.StrictSplitterCheckTask">StrictSplitterCheckTask</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.SeqComposite.FR">FR</span>, _]</span>, <span name="Second">Second &lt;: <a href="../pariterablelike%24strictsplitterchecktask" class="extype" name="scala.collection.parallel.ParIterableLike.StrictSplitterCheckTask">StrictSplitterCheckTask</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.SeqComposite.SR">SR</span>, _]</span>]</span><span class="result"> extends <a href="../pariterablelike%24composite" class="extype" name="scala.collection.parallel.ParIterableLike.Composite">Composite</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.SeqComposite.FR">FR</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.SeqComposite.SR">SR</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.SeqComposite.R">R</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.SeqComposite.First">First</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.SeqComposite.Second">Second</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Sequentially performs one task after another.</p></div>
<dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl>
</div> <h3 id="scala.collection.parallel.ParIterableLike.SignallingOps">
<span class="modifier_kind">  <span class="kind">trait </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24signallingops"><span class="name">SignallingOps</span></a><span class="tparams">[<span name="PI">PI &lt;: <a href="../../generic/delegatedsignalling" class="extype" name="scala.collection.generic.DelegatedSignalling">DelegatedSignalling</a></span>]</span><span class="result"> extends <a href="../../../anyref" class="extype" name="scala.AnyRef">AnyRef</a></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Slice">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24slice"><span class="name">Slice</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="This">This &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.Repr">Repr</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Slice.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Slice.This">This</span>], <a href="../pariterablelike%24slice" class="extype" name="scala.collection.parallel.ParIterableLike.Slice">Slice</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Slice.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Slice.This">This</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Span">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24span"><span class="name">Span</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="This">This &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.Repr">Repr</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[(<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Span.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Span.This">This</span>], <a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Span.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Span.This">This</span>]), <a href="../pariterablelike%24span" class="extype" name="scala.collection.parallel.ParIterableLike.Span">Span</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Span.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Span.This">This</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.SplitAt">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24splitat"><span class="name">SplitAt</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="This">This &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.Repr">Repr</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[(<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.SplitAt.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.SplitAt.This">This</span>], <a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.SplitAt.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.SplitAt.This">This</span>]), <a href="../pariterablelike%24splitat" class="extype" name="scala.collection.parallel.ParIterableLike.SplitAt">SplitAt</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.SplitAt.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.SplitAt.This">This</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.StrictSplitterCheckTask">
<span class="modifier_kind">  <span class="kind">trait </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24strictsplitterchecktask"><span class="name">StrictSplitterCheckTask</span></a><span class="tparams">[<span name="R">R</span>, <span name="Tp">Tp</span>]</span><span class="result"> extends <a href="../task" class="extype" name="scala.collection.parallel.Task">Task</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.StrictSplitterCheckTask.R">R</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.StrictSplitterCheckTask.Tp">Tp</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Sum">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24sum"><span class="name">Sum</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24accessor" class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">Accessor</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Sum.U">U</span>, <a href="../pariterablelike%24sum" class="extype" name="scala.collection.parallel.ParIterableLike.Sum">Sum</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Sum.U">U</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.Take">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24take"><span class="name">Take</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="This">This &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.Repr">Repr</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Take.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Take.This">This</span>], <a href="../pariterablelike%24take" class="extype" name="scala.collection.parallel.ParIterableLike.Take">Take</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.Take.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.Take.This">This</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.TakeWhile">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24takewhile"><span class="name">TakeWhile</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="This">This &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.Repr">Repr</span></span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[(<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.TakeWhile.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.TakeWhile.This">This</span>], <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a>), <a href="../pariterablelike%24takewhile" class="extype" name="scala.collection.parallel.ParIterableLike.TakeWhile">TakeWhile</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.TakeWhile.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.TakeWhile.This">This</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.TaskOps">
<span class="modifier_kind">  <span class="kind">trait </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24taskops"><span class="name">TaskOps</span></a><span class="tparams">[<span name="R">R</span>, <span name="Tp">Tp</span>]</span><span class="result"> extends <a href="../../../anyref" class="extype" name="scala.AnyRef">AnyRef</a></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.ToParCollection">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24toparcollection"><span class="name">ToParCollection</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="That">That</span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ToParCollection.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ToParCollection.That">That</span>], <a href="../pariterablelike%24toparcollection" class="extype" name="scala.collection.parallel.ParIterableLike.ToParCollection">ToParCollection</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ToParCollection.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ToParCollection.That">That</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.ToParMap">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24toparmap"><span class="name">ToParMap</span></a><span class="tparams">[<span name="K">K</span>, <span name="V">V</span>, <span name="That">That</span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[(<span class="extype" name="scala.collection.parallel.ParIterableLike.ToParMap.K">K</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ToParMap.V">V</span>), <span class="extype" name="scala.collection.parallel.ParIterableLike.ToParMap.That">That</span>], <a href="../pariterablelike%24toparmap" class="extype" name="scala.collection.parallel.ParIterableLike.ToParMap">ToParMap</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ToParMap.K">K</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ToParMap.V">V</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ToParMap.That">That</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.ZipAll">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../pariterablelike%24zipall"><span class="name">ZipAll</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParIterableLike.T">T</span></span>, <span name="S">S</span>, <span name="That">That</span>]</span><span class="result"> extends <a href="../pariterablelike%24transformer" class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[(<span class="extype" name="scala.collection.parallel.ParIterableLike.ZipAll.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ZipAll.S">S</span>), <span class="extype" name="scala.collection.parallel.ParIterableLike.ZipAll.That">That</span>], <a href="../pariterablelike%24zipall" class="extype" name="scala.collection.parallel.ParIterableLike.ZipAll">ZipAll</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.ZipAll.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ZipAll.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.ZipAll.That">That</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParSeqLike.Accessor">
<span class="modifier_kind">  <span class="kind">trait </span> </span><span class="symbol"> <a title="" href="../parseqlike%24accessor"><span class="name">Accessor</span></a><span class="tparams">[<span name="R">R</span>, <span name="Tp">Tp</span>]</span><span class="result"> extends <span class="extype" name="scala.collection.parallel.ParIterableLike.Accessor">ParSeqLike.Accessor</span>[<span class="extype" name="scala.collection.parallel.ParSeqLike.Accessor.R">R</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.Accessor.Tp">Tp</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParSeqLike.Corresponds">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../parseqlike%24corresponds"><span class="name">Corresponds</span></a><span class="tparams">[<span name="S">S</span>]</span><span class="result"> extends <a href="../parseqlike%24accessor" class="extype" name="scala.collection.parallel.ParSeqLike.Accessor">Accessor</a>[<a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a>, <a href="../parseqlike%24corresponds" class="extype" name="scala.collection.parallel.ParSeqLike.Corresponds">Corresponds</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.Corresponds.S">S</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParSeqLike.Elements">
<span class="modifier_kind"> <span class="modifier">abstract </span> <span class="kind">class </span> </span><span class="symbol"> <a title="Used to iterate elements using indices" href="../parseqlike%24elements"><span class="name">Elements</span></a><span class="result"> extends <a href="../seqsplitter" class="extype" name="scala.collection.parallel.SeqSplitter">SeqSplitter</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.T">T</span>] with <a href="../../../index#BufferedIterator%5B+A%5D=scala.collection.BufferedIterator%5BA%5D" class="extmbr" name="scala.BufferedIterator">scala.BufferedIterator</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Used to iterate elements using indices</p></div>
<dl class="attributes block"> <dt>Attributes</dt>
<dd>protected </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl>
</div> <h3 id="scala.collection.parallel.ParSeqLike.IndexWhere">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../parseqlike%24indexwhere"><span class="name">IndexWhere</span></a><span class="result"> extends <a href="../parseqlike%24accessor" class="extype" name="scala.collection.parallel.ParSeqLike.Accessor">Accessor</a>[<a href="../../../int" class="extype" name="scala.Int">Int</a>, <a href="../parseqlike%24indexwhere" class="extype" name="scala.collection.parallel.ParSeqLike.IndexWhere">IndexWhere</a>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParSeqLike.LastIndexWhere">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../parseqlike%24lastindexwhere"><span class="name">LastIndexWhere</span></a><span class="result"> extends <a href="../parseqlike%24accessor" class="extype" name="scala.collection.parallel.ParSeqLike.Accessor">Accessor</a>[<a href="../../../int" class="extype" name="scala.Int">Int</a>, <a href="../parseqlike%24lastindexwhere" class="extype" name="scala.collection.parallel.ParSeqLike.LastIndexWhere">LastIndexWhere</a>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParSeqLike.Reverse">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../parseqlike%24reverse"><span class="name">Reverse</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParSeqLike.T">T</span></span>, <span name="This">This &gt;: <span class="extype" name="scala.collection.parallel.ParSeqLike.Repr">Repr</span></span>]</span><span class="result"> extends <a href="../parseqlike%24transformer" class="extype" name="scala.collection.parallel.ParSeqLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.Reverse.U">U</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.Reverse.This">This</span>], <a href="../parseqlike%24reverse" class="extype" name="scala.collection.parallel.ParSeqLike.Reverse">Reverse</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.Reverse.U">U</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.Reverse.This">This</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParSeqLike.ReverseMap">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../parseqlike%24reversemap"><span class="name">ReverseMap</span></a><span class="tparams">[<span name="S">S</span>, <span name="That">That</span>]</span><span class="result"> extends <a href="../parseqlike%24transformer" class="extype" name="scala.collection.parallel.ParSeqLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.ReverseMap.S">S</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.ReverseMap.That">That</span>], <a href="../parseqlike%24reversemap" class="extype" name="scala.collection.parallel.ParSeqLike.ReverseMap">ReverseMap</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.ReverseMap.S">S</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.ReverseMap.That">That</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParSeqLike.SameElements">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../parseqlike%24sameelements"><span class="name">SameElements</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParSeqLike.T">T</span></span>]</span><span class="result"> extends <a href="../parseqlike%24accessor" class="extype" name="scala.collection.parallel.ParSeqLike.Accessor">Accessor</a>[<a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a>, <a href="../parseqlike%24sameelements" class="extype" name="scala.collection.parallel.ParSeqLike.SameElements">SameElements</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.SameElements.U">U</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParSeqLike.SegmentLength">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../parseqlike%24segmentlength"><span class="name">SegmentLength</span></a><span class="result"> extends <a href="../parseqlike%24accessor" class="extype" name="scala.collection.parallel.ParSeqLike.Accessor">Accessor</a>[(<a href="../../../int" class="extype" name="scala.Int">Int</a>, <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a>), <a href="../parseqlike%24segmentlength" class="extype" name="scala.collection.parallel.ParSeqLike.SegmentLength">SegmentLength</a>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParSeqLike.Transformer">
<span class="modifier_kind">  <span class="kind">trait </span> </span><span class="symbol"> <a title="" href="../parseqlike%24transformer"><span class="name">Transformer</span></a><span class="tparams">[<span name="R">R</span>, <span name="Tp">Tp</span>]</span><span class="result"> extends <a href="../parseqlike%24accessor" class="extype" name="scala.collection.parallel.ParSeqLike.Accessor">Accessor</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.Transformer.R">R</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.Transformer.Tp">Tp</span>] with <span class="extype" name="scala.collection.parallel.ParIterableLike.Transformer">ParSeqLike.Transformer</span>[<span class="extype" name="scala.collection.parallel.ParSeqLike.Transformer.R">R</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.Transformer.Tp">Tp</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParSeqLike.Updated">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../parseqlike%24updated"><span class="name">Updated</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParSeqLike.T">T</span></span>, <span name="That">That</span>]</span><span class="result"> extends <a href="../parseqlike%24transformer" class="extype" name="scala.collection.parallel.ParSeqLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.Updated.U">U</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.Updated.That">That</span>], <a href="../parseqlike%24updated" class="extype" name="scala.collection.parallel.ParSeqLike.Updated">Updated</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.Updated.U">U</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.Updated.That">That</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParSeqLike.Zip">
<span class="modifier_kind">  <span class="kind">class </span> </span><span class="symbol"> <a title="" href="../parseqlike%24zip"><span class="name">Zip</span></a><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.ParSeqLike.T">T</span></span>, <span name="S">S</span>, <span name="That">That</span>]</span><span class="result"> extends <a href="../parseqlike%24transformer" class="extype" name="scala.collection.parallel.ParSeqLike.Transformer">Transformer</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[(<span class="extype" name="scala.collection.parallel.ParSeqLike.Zip.U">U</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.Zip.S">S</span>), <span class="extype" name="scala.collection.parallel.ParSeqLike.Zip.That">That</span>], <a href="../parseqlike%24zip" class="extype" name="scala.collection.parallel.ParSeqLike.Zip">Zip</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.Zip.U">U</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.Zip.S">S</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.Zip.That">That</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParIterableLike.SSCTask">
<span class="modifier_kind">  <span class="kind">type </span> </span><span class="symbol"> <span class="name">SSCTask</span><span class="tparams">[<span name="R">R</span>, <span name="Tp">Tp</span>]</span><span class="result alias"> = <a href="#StrictSplitterCheckTask%5BR,Tp%5DextendsTask%5BR,Tp%5D" class="extmbr" name="scala.collection.parallel.ParIterableLike.StrictSplitterCheckTask">StrictSplitterCheckTask</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.SSCTask.R">R</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.SSCTask.Tp">Tp</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scala.collection.parallel.ParSeqLike.SuperParIterator">
<span class="modifier_kind">  <span class="kind">type </span> </span><span class="symbol"> <span class="name">SuperParIterator</span><span class="result alias"> = <a href="../iterablesplitter" class="extype" name="scala.collection.parallel.IterableSplitter">IterableSplitter</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl></div>  </div> <div class="values members"> <h2>Abstract Value Members</h2> <h3 id="apply">
<span class="modifier_kind"> <span class="modifier">abstract </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">apply</span><span class="params">(<span name="i">i: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Selects an element by its index in the parallel iterable.</p>
<p>Example:</p>
<pre data-language="scala">scala&gt; val x = List(1, 2, 3, 4, 5)
x: List[Int] = List(1, 2, 3, 4, 5)

scala&gt; x(3)
res1: Int = 4</pre>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the element of this parallel iterable at index <code>idx</code>, where <code>0</code> indicates the first element.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseq" class="extype" name="scala.collection.parallel.ParSeq">ParSeq</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#IndexOutOfBoundsException=IndexOutOfBoundsException" class="extmbr" name="scala.IndexOutOfBoundsException"><code>IndexOutOfBoundsException</code></a> if <code>idx</code> does not satisfy <code>0 &lt;= idx &lt; length</code>.</p></span></dd>
</dl>
</div> <h3 id="length">
<span class="modifier_kind"> <span class="modifier">abstract </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">length</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>The length of the general sequence.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
<p> Note: <code>xs.length</code> and <code>xs.size</code> yield the same result. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the number of elements in this general sequence.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a></dd>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#IllegalArgumentException=IllegalArgumentException" class="extmbr" name="scala.IllegalArgumentException"><code>IllegalArgumentException</code></a> if the length of the sequence cannot be represented in an <code>Int</code>, for example, <code>(-1 to Int.MaxValue).length</code>.</p></span></dd>
</dl>
</div> <h3 id="seq">
<span class="modifier_kind"> <span class="modifier">abstract </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">seq</span><span class="result">: <a href="../../mutable/seq" class="extype" name="scala.collection.mutable.Seq">mutable.Seq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a> → <a href="pariterable" class="extype" name="scala.collection.parallel.mutable.ParIterable">ParIterable</a> → <a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../genseq" class="extype" name="scala.collection.GenSeq">GenSeq</a> → <a href="../../geniterable" class="extype" name="scala.collection.GenIterable">GenIterable</a> → <a href="../../gentraversable" class="extype" name="scala.collection.GenTraversable">GenTraversable</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a> → <a href="../../parallelizable" class="extype" name="scala.collection.Parallelizable">Parallelizable</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl></div> <h3 id="splitter">
<span class="modifier_kind"> <span class="modifier">abstract </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">splitter</span><span class="result">: <a href="../seqsplitter" class="extype" name="scala.collection.parallel.SeqSplitter">SeqSplitter</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>A more refined version of the iterator found in the <code>ParallelIterable</code> trait, this iterator can be split into arbitrary subsets of iterators. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>an iterator that can be split into subsets of precise size</p></dd>
</dl>
<dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[<a href="../index" class="extype" name="scala.collection.parallel">parallel</a>] </dd>
<dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a>
</dd>
</dl>
</div> <h3 id="update">
<span class="modifier_kind"> <span class="modifier">abstract </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">update</span><span class="params">(<span name="i">i: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>, <span name="elem">elem: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>)</span><span class="result">: <a href="../../../unit" class="extype" name="scala.Unit">Unit</a></span> </span>
</h3>      </div> <div class="values members"> <h2>Concrete Value Members</h2>  <h3 id="!=">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <a href="../../../any" class="extype" name="scala.Any">Any</a></span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Test two objects for inequality. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if !(this == that), false otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>AnyRef → <a href="../../../any" class="extype" name="scala.Any">Any</a>
</dd>
</dl>
</div> <h3 id="">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Equivalent to <code>x.hashCode</code> except for boxed numeric types and <code>null</code>. For numerics, it returns a hash value which is consistent with value equality: if two value type instances compare as true, then ## will produce the same hash value for each of them. For <code>null</code> returns a hashcode where <code>null.hashCode</code> throws a <code>NullPointerException</code>. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a hash value consistent with ==</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>AnyRef → <a href="../../../any" class="extype" name="scala.Any">Any</a>
</dd>
</dl>
</div> <h3 id="+">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span title="gt4s: $plus" class="implicit">+</span><span class="params">(<span name="other">other: <a href="../../../predef%24#String=String" class="extmbr" name="scala.Predef.String">String</a></span>)</span><span class="result">: <a href="../../../predef%24#String=String" class="extmbr" name="scala.Predef.String">String</a></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt>
<dd> This member is added by an implicit conversion from <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>] to <a href="../../../predef%24%24any2stringadd" class="extype" name="scala.Predef.any2stringadd">any2stringadd</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]] performed by method any2stringadd in <a href="../../../predef%24" class="extype" name="scala.Predef">scala.Predef</a>. </dd>
<dt>Definition Classes</dt>
<dd><a href="../../../predef%24%24any2stringadd" class="extype" name="scala.Predef.any2stringadd">any2stringadd</a></dd>
</dl></div> <h3 id="++">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span title="gt4s: $plus$plus" class="name">++</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>, <span name="That">That</span>]</span><span class="params">(<span name="that">that: <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.++.U">U</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <a href="../../generic/canbuildfrom" class="extype" name="scala.collection.generic.CanBuildFrom">CanBuildFrom</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>], <span class="extype" name="scala.collection.parallel.ParIterableLike.++.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.++.That">That</span>]</span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.++.That">That</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Returns a new parallel iterable containing the elements from the left hand operand followed by the elements from the right hand operand. The element type of the parallel iterable is the most specific superclass encompassing the element types of the two operands. </p></div>
<dl class="paramcmts block">
<dt class="tparam">That</dt>
<dd class="cmt"><p>the class of the returned collection. Where possible, <code>That</code> is the same class as the current collection class <code>Repr</code>, but this depends on the element type <code>B</code> being admissible for that class, which means that an implicit instance of type <code>CanBuildFrom[Repr, B, That]</code> is found.</p></dd>
<dt class="param">that</dt>
<dd class="cmt"><p>the traversable to append.</p></dd>
<dt class="param">bf</dt>
<dd class="cmt"><p>an implicit value of class <code>CanBuildFrom</code> which determines the result class <code>That</code> from the current representation type <code>Repr</code> and the new element type <code>B</code>.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new collection of type <code>That</code> which contains all elements of this parallel iterable followed by all elements of <code>that</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="+:">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span title="gt4s: $plus$colon" class="name">+:</span><span class="params">(<span name="elem">elem: <span class="extype" name="scala.collection.GenSeqLike.A">A</span></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.GenSeqLike.A">A</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> A copy of the mutable parallel sequence with an element prepended.</p>
<p> Note that :-ending operators are right associative (see example). A mnemonic for <code>+:</code> vs. <code>:+</code> is: the COLon goes on the COLlection side.</p>
<p> Also, the original mutable parallel sequence is not modified, so you will want to capture the result.</p>
<p> Example:</p>
<pre data-language="scala">scala&gt; val x = List(1)
x: List[Int] = List(1)

scala&gt; val y = 2 +: x
y: List[Int] = List(2, 1)

scala&gt; println(x)
List(1)</pre>
</div>
<dl class="paramcmts block">
<dt class="param">elem</dt>
<dd class="cmt"><p>the prepended element</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence consisting of <code>elem</code> followed by all elements of this mutable parallel sequence.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="-&gt;">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span title="gt4s: $minus$greater" class="implicit">-&gt;</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span class="extype" name="scala.Predef.ArrowAssoc.-&gt;.B">B</span></span>)</span><span class="result">: (<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>], <span class="extype" name="scala.Predef.ArrowAssoc.-&gt;.B">B</span>)</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt>
<dd> This member is added by an implicit conversion from <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>] to <a href="../../../predef%24%24arrowassoc" class="extype" name="scala.Predef.ArrowAssoc">ArrowAssoc</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]] performed by method ArrowAssoc in <a href="../../../predef%24" class="extype" name="scala.Predef">scala.Predef</a>. </dd>
<dt>Definition Classes</dt>
<dd><a href="../../../predef%24%24arrowassoc" class="extype" name="scala.Predef.ArrowAssoc">ArrowAssoc</a></dd>
<dt>Annotations</dt>
<dd> <span class="name">@<a href="../../../inline" class="extype" name="scala.inline">inline</a></span><span class="args">()</span> </dd>
</dl></div> <h3 id="/:">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span title="gt4s: $div$colon" class="name">/:</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="z">z: <span class="extype" name="scala.collection.parallel.ParIterableLike./:.S">S</span></span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.ParIterableLike./:.S">S</span>, <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike./:.S">S</span></span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike./:.S">S</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Applies a binary operator to a start value and all elements of this parallel iterable, going left to right.</p>
<p> Note: <code>/:</code> is alternate syntax for <code>foldLeft</code>; <code>z /: xs</code> is the same as <code>xs foldLeft z</code>.</p>
<p> Examples:</p>
<p> Note that the folding function used to compute b is equivalent to that used to compute c.</p>
<pre data-language="scala">scala&gt; val a = List(1,2,3,4)
a: List[Int] = List(1, 2, 3, 4)

scala&gt; val b = (5 /: a)(_+_)
b: Int = 15

scala&gt; val c = (5 /: a)((x,y) =&gt; x + y)
c: Int = 15</pre>
<p> Note: will not terminate for infinite-sized collections.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered. or the operator is associative and commutative. </p>
</div>
<dl class="paramcmts block">
<dt class="param">z</dt>
<dd class="cmt"><p>the start value.</p></dd>
<dt class="param">op</dt>
<dd class="cmt"><p>the binary operator.</p></dd>
<dt>returns</dt>
<dd class="cmt">
<p>the result of inserting <code>op</code> between consecutive elements of this parallel iterable, going left to right with the start value <code>z</code> on the left:</p>
<pre data-language="scala">op(...op(op(z, x_1), x_2), ..., x_n)</pre>
<p> where <code>x<sub>1</sub>, ..., x<sub>n</sub></code> are the elements of this parallel iterable.</p>
</dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id=":+">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span title="gt4s: $colon$plus" class="name">:+</span><span class="params">(<span name="elem">elem: <span class="extype" name="scala.collection.GenSeqLike.A">A</span></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.GenSeqLike.A">A</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> A copy of this mutable parallel sequence with an element appended.</p>
<p> A mnemonic for <code>+:</code> vs. <code>:+</code> is: the COLon goes on the COLlection side.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
<p> Example:</p>
<pre data-language="scala">scala&gt; val a = List(1)
a: List[Int] = List(1)

scala&gt; val b = a :+ 2
b: List[Int] = List(1, 2)

scala&gt; println(a)
List(1)</pre>
</div>
<dl class="paramcmts block">
<dt class="param">elem</dt>
<dd class="cmt"><p>the appended element</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence consisting of all elements of this mutable parallel sequence followed by <code>elem</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id=":\">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span title="gt4s: $colon$bslash" class="name">:\</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="z">z: <span class="extype" name="scala.collection.parallel.ParIterableLike.:\.S">S</span></span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.:\.S">S</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.:\.S">S</span></span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.:\.S">S</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Applies a binary operator to all elements of this parallel iterable and a start value, going right to left.</p>
<p> Note: <code>:\</code> is alternate syntax for <code>foldRight</code>; <code>xs :\ z</code> is the same as <code>xs foldRight z</code>.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered. or the operator is associative and commutative.</p>
<p> Examples:</p>
<p> Note that the folding function used to compute b is equivalent to that used to compute c.</p>
<pre data-language="scala">scala&gt; val a = List(1,2,3,4)
a: List[Int] = List(1, 2, 3, 4)

scala&gt; val b = (a :\ 5)(_+_)
b: Int = 15

scala&gt; val c = (a :\ 5)((x,y) =&gt; x + y)
c: Int = 15</pre>
</div>
<dl class="paramcmts block">
<dt class="param">z</dt>
<dd class="cmt"><p>the start value</p></dd>
<dt class="param">op</dt>
<dd class="cmt"><p>the binary operator</p></dd>
<dt>returns</dt>
<dd class="cmt">
<p>the result of inserting <code>op</code> between consecutive elements of this parallel iterable, going right to left with the start value <code>z</code> on the right:</p>
<pre data-language="scala">op(x_1, op(x_2, ... op(x_n, z)...))</pre>
<p> where <code>x<sub>1</sub>, ..., x<sub>n</sub></code> are the elements of this parallel iterable.</p>
</dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="==">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <a href="../../../any" class="extype" name="scala.Any">Any</a></span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>The expression <code>x == that</code> is equivalent to <code>if (x eq null) that eq null else x.equals(that)</code>. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the receiver object is equivalent to the argument; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>AnyRef → <a href="../../../any" class="extype" name="scala.Any">Any</a>
</dd>
</dl>
</div> <h3 id="aggregate">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">aggregate</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="z">z: ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.aggregate.S">S</span></span>)</span><span class="params">(<span name="seqop">seqop: (<span class="extype" name="scala.collection.parallel.ParIterableLike.aggregate.S">S</span>, <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.aggregate.S">S</span></span>, <span name="combop">combop: (<span class="extype" name="scala.collection.parallel.ParIterableLike.aggregate.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.aggregate.S">S</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.aggregate.S">S</span></span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.aggregate.S">S</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Aggregates the results of applying an operator to subsequent elements.</p>
<p> This is a more general form of <code>fold</code> and <code>reduce</code>. It has similar semantics, but does not require the result to be a supertype of the element type. It traverses the elements in different partitions sequentially, using <code>seqop</code> to update the result, and then applies <code>combop</code> to results from different partitions. The implementation of this operation may operate on an arbitrary number of collection partitions, so <code>combop</code> may be invoked arbitrary number of times.</p>
<p> For example, one might want to process some elements and then produce a <code>Set</code>. In this case, <code>seqop</code> would process an element and append it to the set, while <code>combop</code> would concatenate two sets from different partitions together. The initial value <code>z</code> would be an empty set.</p>
<pre data-language="scala">pc.aggregate(Set[Int]())(_ += process(_), _ ++ _)</pre>
<p> Another example is calculating geometric mean from a collection of doubles (one would typically require big doubles for this). </p>
</div>
<dl class="paramcmts block">
<dt class="tparam">S</dt>
<dd class="cmt"><p>the type of accumulated results</p></dd>
<dt class="param">z</dt>
<dd class="cmt"><p>the initial value for the accumulated result of the partition - this will typically be the neutral element for the <code>seqop</code> operator (e.g. <code>Nil</code> for list concatenation or <code>0</code> for summation) and may be evaluated more than once</p></dd>
<dt class="param">seqop</dt>
<dd class="cmt"><p>an operator used to accumulate results within a partition</p></dd>
<dt class="param">combop</dt>
<dd class="cmt"><p>an associative operator used to combine results from different partitions</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="asInstanceOf">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Cast the receiver object to be of type <code>T0</code>.</p>
<p> Note that the success of a cast at runtime is modulo Scala's erasure semantics. Therefore the expression <code>1.asInstanceOf[String]</code> will throw a <code>ClassCastException</code> at runtime, while the expression <code>List(1).asInstanceOf[List[String]]</code> will not. In the latter example, because the type argument is erased as part of compilation it is not possible to check whether the contents of the list are of the requested type. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the receiver object.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../../any" class="extype" name="scala.Any">Any</a></dd>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#ClassCastException=ClassCastException" class="extmbr" name="scala.ClassCastException"><code>ClassCastException</code></a> if the receiver object is not an instance of the erasure of type <code>T0</code>.</p></span></dd>
</dl>
</div> <h3 id="bf2seq">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">bf2seq</span><span class="tparams">[<span name="S">S</span>, <span name="That">That</span>]</span><span class="params">(<span name="bf">bf: <a href="../../generic/canbuildfrom" class="extype" name="scala.collection.generic.CanBuildFrom">CanBuildFrom</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>], <span class="extype" name="scala.collection.parallel.ParIterableLike.bf2seq.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.bf2seq.That">That</span>]</span>)</span><span class="result">: <a href="../../generic/canbuildfrom" class="extype" name="scala.collection.generic.CanBuildFrom">CanBuildFrom</a>[<a href="../../mutable/seq" class="extype" name="scala.collection.mutable.Seq">mutable.Seq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>], <span class="extype" name="scala.collection.parallel.ParIterableLike.bf2seq.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.bf2seq.That">That</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="builder2ops">
<span class="modifier_kind"> <span class="modifier">implicit </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">builder2ops</span><span class="tparams">[<span name="Elem">Elem</span>, <span name="To">To</span>]</span><span class="params">(<span name="cb">cb: <a href="../../mutable/builder" class="extype" name="scala.collection.mutable.Builder">Builder</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.builder2ops.Elem">Elem</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.builder2ops.To">To</span>]</span>)</span><span class="result">: <a href="#BuilderOps%5BElem,To%5DextendsAnyRef" class="extmbr" name="scala.collection.parallel.ParIterableLike.BuilderOps">BuilderOps</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.builder2ops.Elem">Elem</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.builder2ops.To">To</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="canEqual">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">canEqual</span><span class="params">(<span name="other">other: <a href="../../../any" class="extype" name="scala.Any">Any</a></span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="clone">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">clone</span><span class="params">()</span><span class="result">: <a href="../../../anyref" class="extype" name="scala.AnyRef">AnyRef</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Create a copy of the receiver object.</p>
<p> The default implementation of the <code>clone</code> method is platform dependent. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a copy of the receiver object.</p></dd>
</dl>
<dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[<span class="extype" name="java.lang">lang</span>] </dd>
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd> <span class="name">@<a href="../../../throws" class="extype" name="scala.throws">throws</a></span><span class="args">(<span> <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span> </span>)</span> <span class="name">@<a href="../../../native" class="extype" name="scala.native">native</a></span><span class="args">()</span> </dd>
<dt>Note</dt>
<dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd>
</dl>
</div> <h3 id="collect">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">collect</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="pf">pf: <a href="../../../partialfunction" class="extype" name="scala.PartialFunction">PartialFunction</a>[<span class="extype" name="scala.collection.GenTraversableLike.A">A</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.collect.B">B</span>]</span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.collect.B">B</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt"><p> Builds a new collection by applying a partial function to all elements of this mutable parallel sequence on which the function is defined.</p></div>
<dl class="paramcmts block">
<dt class="tparam">B</dt>
<dd class="cmt"><p>the element type of the returned collection.</p></dd>
<dt class="param">pf</dt>
<dd class="cmt"><p>the partial function which filters and maps the mutable parallel sequence.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence resulting from applying the given partial function <code>pf</code> to each element on which it is defined and collecting the results. The order of the elements is preserved.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="combinerFactory">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">combinerFactory</span><span class="tparams">[<span name="S">S</span>, <span name="That">That</span>]</span><span class="params">(<span name="cbf">cbf: () ⇒ <a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.combinerFactory.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.combinerFactory.That">That</span>]</span>)</span><span class="result">: <a href="../combinerfactory" class="extype" name="scala.collection.parallel.CombinerFactory">CombinerFactory</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.combinerFactory.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.combinerFactory.That">That</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="combinerFactory">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">combinerFactory</span><span class="result">: <a href="../combinerfactory" class="extype" name="scala.collection.parallel.CombinerFactory">CombinerFactory</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Creates a combiner factory. Each combiner factory instance is used once per invocation of a parallel transformer method for a single collection.</p>
<p> The default combiner factory creates a new combiner every time it is requested, unless the combiner is thread-safe as indicated by its <code>canBeShared</code> method. In this case, the method returns a factory which returns the same combiner each time. This is typically done for concurrent parallel collections, the combiners of which allow thread safe access. </p>
</div>
<dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl>
</div> <h3 id="companion">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">companion</span><span class="result">: <a href="../../generic/genericcompanion" class="extype" name="scala.collection.generic.GenericCompanion">GenericCompanion</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>] with <a href="../../generic/genericparcompanion" class="extype" name="scala.collection.generic.GenericParCompanion">GenericParCompanion</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>The factory companion object that builds instances of class <code>mutable.ParSeq</code>. (or its <code>Iterable</code> superclass where class <code>mutable.ParSeq</code> is not a <code>Seq</code>.) </p></div>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a> → <a href="../parseq" class="extype" name="scala.collection.parallel.ParSeq">ParSeq</a> → <a href="pariterable" class="extype" name="scala.collection.parallel.mutable.ParIterable">ParIterable</a> → <a href="../pariterable" class="extype" name="scala.collection.parallel.ParIterable">ParIterable</a> → <a href="../../generic/genericpartemplate" class="extype" name="scala.collection.generic.GenericParTemplate">GenericParTemplate</a> → <a href="../../genseq" class="extype" name="scala.collection.GenSeq">GenSeq</a> → <a href="../../geniterable" class="extype" name="scala.collection.GenIterable">GenIterable</a> → <a href="../../gentraversable" class="extype" name="scala.collection.GenTraversable">GenTraversable</a> → <a href="../../generic/generictraversabletemplate" class="extype" name="scala.collection.generic.GenericTraversableTemplate">GenericTraversableTemplate</a>
</dd>
</dl>
</div> <h3 id="copyToArray">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">copyToArray</span><span class="params">(<span name="xs">xs: <a href="../../../array" class="extype" name="scala.Array">Array</a>[<span class="extype" name="scala.collection.GenTraversableOnce.A">A</span>]</span>, <span name="start">start: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>, <span name="len">len: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="../../../unit" class="extype" name="scala.Unit">Unit</a></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Copies the elements of this mutable parallel sequence to an array. Fills the given array <code>xs</code> with at most <code>len</code> elements of this mutable parallel sequence, starting at position <code>start</code>. Copying will stop once either the end of the current mutable parallel sequence is reached, or the end of the target array is reached, or <code>len</code> elements have been copied.</p>
<p> Note: will not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt class="param">xs</dt>
<dd class="cmt"><p>the array to fill.</p></dd>
<dt class="param">start</dt>
<dd class="cmt"><p>the starting index.</p></dd>
<dt class="param">len</dt>
<dd class="cmt"><p>the maximal number of elements to copy.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="copyToArray">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">copyToArray</span><span class="params">(<span name="xs">xs: <a href="../../../array" class="extype" name="scala.Array">Array</a>[<span class="extype" name="scala.collection.GenTraversableOnce.A">A</span>]</span>, <span name="start">start: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="../../../unit" class="extype" name="scala.Unit">Unit</a></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Copies the elements of this mutable parallel sequence to an array. Fills the given array <code>xs</code> with values of this mutable parallel sequence, beginning at index <code>start</code>. Copying will stop once either the end of the current mutable parallel sequence is reached, or the end of the target array is reached.</p>
<p> Note: will not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt class="param">xs</dt>
<dd class="cmt"><p>the array to fill.</p></dd>
<dt class="param">start</dt>
<dd class="cmt"><p>the starting index.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="copyToArray">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">copyToArray</span><span class="params">(<span name="xs">xs: <a href="../../../array" class="extype" name="scala.Array">Array</a>[<span class="extype" name="scala.collection.GenTraversableOnce.A">A</span>]</span>)</span><span class="result">: <a href="../../../unit" class="extype" name="scala.Unit">Unit</a></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Copies the elements of this mutable parallel sequence to an array. Fills the given array <code>xs</code> with values of this mutable parallel sequence. Copying will stop once either the end of the current mutable parallel sequence is reached, or the end of the target array is reached.</p>
<p> Note: will not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt class="param">xs</dt>
<dd class="cmt"><p>the array to fill.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="corresponds">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">corresponds</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="that">that: <a href="../../genseq" class="extype" name="scala.collection.GenSeq">GenSeq</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.corresponds.S">S</span>]</span>)</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.corresponds.S">S</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Tests whether every element of this parallel iterable relates to the corresponding element of another parallel sequence by satisfying a test predicate.</p>
<p> This method will use <code>abort</code> signalling capabilities. This means that splitters may send and read <code>abort</code> signals.</p>
</div>
<dl class="paramcmts block">
<dt class="tparam">S</dt>
<dd class="cmt"><p>the type of the elements of <code>that</code></p></dd>
<dt class="param">that</dt>
<dd class="cmt"><p>the other parallel sequence</p></dd>
<dt class="param">p</dt>
<dd class="cmt"><p>the test predicate, which relates elements from both sequences</p></dd>
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if both parallel sequences have the same length and <code>p(x, y)</code> is <code>true</code> for all corresponding elements <code>x</code> of this parallel iterable and <code>y</code> of <code>that</code>, otherwise <code>false</code></p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
</dl>
</div> <h3 id="count">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">count</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Counts the number of elements in the parallel iterable which satisfy a predicate. </p></div>
<dl class="paramcmts block">
<dt class="param">p</dt>
<dd class="cmt"><p>the predicate used to test elements.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the number of elements satisfying the predicate <code>p</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="debugBuffer">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">debugBuffer</span><span class="result">: <a href="../../mutable/arraybuffer" class="extype" name="scala.collection.mutable.ArrayBuffer">ArrayBuffer</a>[<a href="../../../predef%24#String=String" class="extmbr" name="scala.Predef.String">String</a>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="delegatedSignalling2ops">
<span class="modifier_kind"> <span class="modifier">implicit </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">delegatedSignalling2ops</span><span class="tparams">[<span name="PI">PI &lt;: <a href="../../generic/delegatedsignalling" class="extype" name="scala.collection.generic.DelegatedSignalling">DelegatedSignalling</a></span>]</span><span class="params">(<span name="it">it: <span class="extype" name="scala.collection.parallel.ParIterableLike.delegatedSignalling2ops.PI">PI</span></span>)</span><span class="result">: <a href="#SignallingOps%5BPI&lt;:scala.collection.generic.DelegatedSignalling%5DextendsAnyRef" class="extmbr" name="scala.collection.parallel.ParIterableLike.SignallingOps">SignallingOps</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.delegatedSignalling2ops.PI">PI</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="diff">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">diff</span><span class="params">(<span name="that">that: <a href="../../genseq" class="extype" name="scala.collection.GenSeq">GenSeq</a>[<span class="extype" name="scala.collection.GenSeqLike.A">A</span>]</span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.GenSeqLike.A">A</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Computes the multiset difference between this mutable parallel sequence and another sequence.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
</div>
<dl class="paramcmts block">
<dt class="param">that</dt>
<dd class="cmt"><p>the sequence of elements to remove</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence which contains all elements of this mutable parallel sequence except some of occurrences of elements that also appear in <code>that</code>. If an element value <code>x</code> appears <i>n</i> times in <code>that</code>, then the first <i>n</i> occurrences of <code>x</code> will not form part of the result, but any following occurrences will.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="distinct">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">distinct</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Builds a new parallel iterable from this parallel iterable without any duplicate elements.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>A new parallel iterable which contains the first occurrence of every element of this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
</dl>
</div> <h3 id="down">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">down</span><span class="params">(<span name="p">p: <a href="../iterablesplitter" class="extype" name="scala.collection.parallel.IterableSplitter">IterableSplitter</a>[_]</span>)</span><span class="result">: <a href="../seqsplitter" class="extype" name="scala.collection.parallel.SeqSplitter">SeqSplitter</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a></dd>
</dl></div> <h3 id="drop">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">drop</span><span class="params">(<span name="n">n: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Selects all elements except first <i>n</i> ones.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered.</p>
</div>
<dl class="paramcmts block">
<dt class="param">n</dt>
<dd class="cmt"><p>the number of elements to drop from this parallel iterable.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a parallel iterable consisting of all elements of this parallel iterable except the first <code>n</code> ones, or else the empty parallel iterable, if this parallel iterable has less than <code>n</code> elements. If <code>n</code> is negative, don't drop any elements.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="dropWhile">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">dropWhile</span><span class="params">(<span name="pred">pred: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Drops all elements in the longest prefix of elements that satisfy the predicate, and returns a collection composed of the remaining elements.</p>
<p> This method will use <code>indexFlag</code> signalling capabilities. This means that splitters may set and read the <code>indexFlag</code> state. The index flag is initially set to maximum integer value. </p>
</div>
<dl class="paramcmts block">
<dt class="param">pred</dt>
<dd class="cmt"><p>the predicate used to test the elements</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a collection composed of all the elements after the longest prefix of elements in this parallel iterable that satisfy the predicate <code>pred</code></p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="endsWith">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">endsWith</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="that">that: <a href="../../genseq" class="extype" name="scala.collection.GenSeq">GenSeq</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.endsWith.S">S</span>]</span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Tests whether this parallel iterable ends with the given parallel sequence.</p>
<p> This method will use <code>abort</code> signalling capabilities. This means that splitters may send and read <code>abort</code> signals.</p>
</div>
<dl class="paramcmts block">
<dt class="tparam">S</dt>
<dd class="cmt"><p>the type of the elements of <code>that</code> sequence</p></dd>
<dt class="param">that</dt>
<dd class="cmt"><p>the sequence to test</p></dd>
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if this parallel iterable has <code>that</code> as a suffix, <code>false</code> otherwise</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
</dl>
</div> <h3 id="ensuring">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>, <span name="msg">msg: ⇒ <a href="../../../any" class="extype" name="scala.Any">Any</a></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt>
<dd> This member is added by an implicit conversion from <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>] to <a href="../../../predef%24%24ensuring" class="extype" name="scala.Predef.Ensuring">Ensuring</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]] performed by method Ensuring in <a href="../../../predef%24" class="extype" name="scala.Predef">scala.Predef</a>. </dd>
<dt>Definition Classes</dt>
<dd><a href="../../../predef%24%24ensuring" class="extype" name="scala.Predef.Ensuring">Ensuring</a></dd>
</dl></div> <h3 id="ensuring">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: (<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt>
<dd> This member is added by an implicit conversion from <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>] to <a href="../../../predef%24%24ensuring" class="extype" name="scala.Predef.Ensuring">Ensuring</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]] performed by method Ensuring in <a href="../../../predef%24" class="extype" name="scala.Predef">scala.Predef</a>. </dd>
<dt>Definition Classes</dt>
<dd><a href="../../../predef%24%24ensuring" class="extype" name="scala.Predef.Ensuring">Ensuring</a></dd>
</dl></div> <h3 id="ensuring">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>, <span name="msg">msg: ⇒ <a href="../../../any" class="extype" name="scala.Any">Any</a></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt>
<dd> This member is added by an implicit conversion from <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>] to <a href="../../../predef%24%24ensuring" class="extype" name="scala.Predef.Ensuring">Ensuring</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]] performed by method Ensuring in <a href="../../../predef%24" class="extype" name="scala.Predef">scala.Predef</a>. </dd>
<dt>Definition Classes</dt>
<dd><a href="../../../predef%24%24ensuring" class="extype" name="scala.Predef.Ensuring">Ensuring</a></dd>
</dl></div> <h3 id="ensuring">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="implicit">ensuring</span><span class="params">(<span name="cond">cond: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt>
<dd> This member is added by an implicit conversion from <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>] to <a href="../../../predef%24%24ensuring" class="extype" name="scala.Predef.Ensuring">Ensuring</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]] performed by method Ensuring in <a href="../../../predef%24" class="extype" name="scala.Predef">scala.Predef</a>. </dd>
<dt>Definition Classes</dt>
<dd><a href="../../../predef%24%24ensuring" class="extype" name="scala.Predef.Ensuring">Ensuring</a></dd>
</dl></div> <h3 id="eq">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <a href="../../../anyref" class="extype" name="scala.AnyRef">AnyRef</a></span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Tests whether the argument (<code>that</code>) is a reference to the receiver object (<code>this</code>).</p>
<p> The <code>eq</code> method implements an <a href="http://en.wikipedia.org/wiki/Equivalence_relation" target="_blank">equivalence relation</a> on non-null instances of <code>AnyRef</code>, and has three additional properties:</p>
<ul>
It is consistent: for any non-null instances <code>x</code> and <code>y</code> of type <code>AnyRef</code>, multiple invocations of <code>x.eq(y)</code> consistently returns <code>true</code> or consistently returns <code>false</code>.For any non-null instance <code>x</code> of type <code>AnyRef</code>, <code>x.eq(null)</code> and <code>null.eq(x)</code> returns <code>false</code>.
<code>null.eq(null)</code> returns <code>true</code>.</ul>
<p> When overriding the <code>equals</code> or <code>hashCode</code> methods, it is important to ensure that their behavior is consistent with reference equality. Therefore, if two objects are references to each other (<code>o1 eq o2</code>), they should be equal to each other (<code>o1 == o2</code>) and they should hash to the same value (<code>o1.hashCode == o2.hashCode</code>). </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the argument is a reference to the receiver object; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>AnyRef</dd>
</dl>
</div> <h3 id="equals">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">equals</span><span class="params">(<span name="that">that: <a href="../../../any" class="extype" name="scala.Any">Any</a></span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>The equals method for arbitrary sequences. Compares this sequence to some other object.</p></div>
<dl class="paramcmts block">
<dt class="param">that</dt>
<dd class="cmt"><p>The object to compare the sequence to</p></dd>
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if <code>that</code> is a sequence that has the same elements as this sequence in the same order, <code>false</code> otherwise</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a> → <a href="../../../equals" class="extype" name="scala.Equals">Equals</a> → <a href="../../../any" class="extype" name="scala.Any">Any</a>
</dd>
</dl>
</div> <h3 id="exists">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">exists</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Tests whether a predicate holds for some element of this parallel iterable.</p>
<p> This method will use <code>abort</code> signalling capabilities. This means that splitters may send and read <code>abort</code> signals.</p>
</div>
<dl class="paramcmts block">
<dt class="param">p</dt>
<dd class="cmt"><p>a predicate used to test elements</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>true if <code>p</code> holds for some element, false otherwise</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="filter">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">filter</span><span class="params">(<span name="pred">pred: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Selects all elements of this parallel iterable which satisfy a predicate. </p></div>
<dl class="paramcmts block">
<dt class="param">pred</dt>
<dd class="cmt"><p>the predicate used to test elements.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new parallel iterable consisting of all elements of this parallel iterable that satisfy the given predicate <code>p</code>. Their order may not be preserved.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="filterNot">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">filterNot</span><span class="params">(<span name="pred">pred: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Selects all elements of this parallel iterable which do not satisfy a predicate. </p></div>
<dl class="paramcmts block">
<dt class="param">pred</dt>
<dd class="cmt"><p>the predicate used to test elements.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new parallel iterable consisting of all elements of this parallel iterable that do not satisfy the given predicate <code>p</code>. Their order may not be preserved.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="finalize">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">finalize</span><span class="params">()</span><span class="result">: <a href="../../../unit" class="extype" name="scala.Unit">Unit</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Called by the garbage collector on the receiver object when there are no more references to the object.</p>
<p> The details of when and if the <code>finalize</code> method is invoked, as well as the interaction between <code>finalize</code> and non-local returns and exceptions, are all platform dependent. </p>
</div>
<dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[<span class="extype" name="java.lang">lang</span>] </dd>
<dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd> <span class="name">@<a href="../../../throws" class="extype" name="scala.throws">throws</a></span><span class="args">(<span> <span class="symbol">classOf[java.lang.Throwable]</span> </span>)</span> </dd>
<dt>Note</dt>
<dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd>
</dl>
</div> <h3 id="find">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">find</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="../../../option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Finds some element in the collection for which the predicate holds, if such an element exists. The element may not necessarily be the first such element in the iteration order.</p>
<p> If there are multiple elements obeying the predicate, the choice is nondeterministic.</p>
<p> This method will use <code>abort</code> signalling capabilities. This means that splitters may send and read <code>abort</code> signals.</p>
</div>
<dl class="paramcmts block">
<dt class="param">p</dt>
<dd class="cmt"><p>predicate used to test the elements</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>an option value with the element if such an element exists, or <code>None</code> otherwise</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="flatMap">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">flatMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.collection.GenTraversableLike.A">A</span>) ⇒ <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.flatMap.B">B</span>]</span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.flatMap.B">B</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Builds a new collection by applying a function to all elements of this mutable parallel sequence and using the elements of the resulting collections.</p>
<p> For example:</p>
<pre data-language="scala">def getWords(lines: Seq[String]): Seq[String] = lines flatMap (line =&gt; line split "\\W+")</pre>
<p> The type of the resulting collection is guided by the static type of mutable parallel sequence. This might cause unexpected results sometimes. For example:</p>
<pre data-language="scala">// lettersOf will return a Seq[Char] of likely repeated letters, instead of a Set
def lettersOf(words: Seq[String]) = words flatMap (word =&gt; word.toSet)

// lettersOf will return a Set[Char], not a Seq
def lettersOf(words: Seq[String]) = words.toSet flatMap (word =&gt; word.toSeq)

// xs will be an Iterable[Int]
val xs = Map("a" -&gt; List(11,111), "b" -&gt; List(22,222)).flatMap(_._2)

// ys will be a Map[Int, Int]
val ys = Map("a" -&gt; List(1 -&gt; 11,1 -&gt; 111), "b" -&gt; List(2 -&gt; 22,2 -&gt; 222)).flatMap(_._2)</pre>
</div>
<dl class="paramcmts block">
<dt class="tparam">B</dt>
<dd class="cmt"><p>the element type of the returned collection.</p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>the function to apply to each element.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence resulting from applying the given collection-valued function <code>f</code> to each element of this mutable parallel sequence and concatenating the results.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="flatten">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">flatten</span><span class="tparams">[<span name="B">B</span>]</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.generic.GenericTraversableTemplate.flatten.B">B</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Converts this mutable parallel sequence of traversable collections into a mutable parallel sequence formed by the elements of these traversable collections.</p>
<p> The resulting collection's type will be guided by the static type of mutable parallel sequence. For example:</p>
<pre data-language="scala">val xs = List(
           Set(1, 2, 3),
           Set(1, 2, 3)
         ).flatten
// xs == List(1, 2, 3, 1, 2, 3)

val ys = Set(
           List(1, 2, 3),
           List(3, 2, 1)
         ).flatten
// ys == Set(1, 2, 3)</pre>
</div>
<dl class="paramcmts block">
<dt class="tparam">B</dt>
<dd class="cmt"><p>the type of the elements of each traversable collection.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence resulting from concatenating all element mutable parallel sequences.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../generic/generictraversabletemplate" class="extype" name="scala.collection.generic.GenericTraversableTemplate">GenericTraversableTemplate</a></dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="fold">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">fold</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>]</span><span class="params">(<span name="z">z: <span class="extype" name="scala.collection.parallel.ParIterableLike.fold.U">U</span></span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.ParIterableLike.fold.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.fold.U">U</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.fold.U">U</span></span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.fold.U">U</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Folds the elements of this sequence using the specified associative binary operator. The order in which the elements are reduced is unspecified and may be nondeterministic.</p>
<p> Note this method has a different signature than the <code>foldLeft</code> and <code>foldRight</code> methods of the trait <code>Traversable</code>. The result of folding may only be a supertype of this parallel collection's type parameter <code>T</code>. </p>
</div>
<dl class="paramcmts block">
<dt class="tparam">U</dt>
<dd class="cmt"><p>a type parameter for the binary operator, a supertype of <code>T</code>.</p></dd>
<dt class="param">z</dt>
<dd class="cmt"><p>a neutral element for the fold operation, it may be added to the result an arbitrary number of times, not changing the result (e.g. <code>Nil</code> for list concatenation, 0 for addition, or 1 for multiplication)</p></dd>
<dt class="param">op</dt>
<dd class="cmt"><p>a binary operator that must be associative</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the result of applying fold operator <code>op</code> between all the elements and <code>z</code></p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="foldLeft">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">foldLeft</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="z">z: <span class="extype" name="scala.collection.parallel.ParIterableLike.foldLeft.S">S</span></span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.ParIterableLike.foldLeft.S">S</span>, <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.foldLeft.S">S</span></span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.foldLeft.S">S</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Applies a binary operator to a start value and all elements of this parallel iterable, going left to right.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered. or the operator is associative and commutative. </p>
</div>
<dl class="paramcmts block">
<dt class="param">z</dt>
<dd class="cmt"><p>the start value.</p></dd>
<dt class="param">op</dt>
<dd class="cmt"><p>the binary operator.</p></dd>
<dt>returns</dt>
<dd class="cmt">
<p>the result of inserting <code>op</code> between consecutive elements of this parallel iterable, going left to right with the start value <code>z</code> on the left:</p>
<pre data-language="scala">op(...op(z, x_1), x_2, ..., x_n)</pre>
<p> where <code>x<sub>1</sub>, ..., x<sub>n</sub></code> are the elements of this parallel iterable. Returns <code>z</code> if this parallel iterable is empty.</p>
</dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="foldRight">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">foldRight</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="z">z: <span class="extype" name="scala.collection.parallel.ParIterableLike.foldRight.S">S</span></span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.foldRight.S">S</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.foldRight.S">S</span></span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.foldRight.S">S</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Applies a binary operator to all elements of this parallel iterable and a start value, going right to left.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered. or the operator is associative and commutative.</p>
</div>
<dl class="paramcmts block">
<dt class="param">z</dt>
<dd class="cmt"><p>the start value.</p></dd>
<dt class="param">op</dt>
<dd class="cmt"><p>the binary operator.</p></dd>
<dt>returns</dt>
<dd class="cmt">
<p>the result of inserting <code>op</code> between consecutive elements of this parallel iterable, going right to left with the start value <code>z</code> on the right:</p>
<pre data-language="scala">op(x_1, op(x_2, ... op(x_n, z)...))</pre>
<p> where <code>x<sub>1</sub>, ..., x<sub>n</sub></code> are the elements of this parallel iterable. Returns <code>z</code> if this parallel iterable is empty.</p>
</dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="forall">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">forall</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Tests whether a predicate holds for all elements of this parallel iterable.</p>
<p> This method will use <code>abort</code> signalling capabilities. This means that splitters may send and read <code>abort</code> signals.</p>
</div>
<dl class="paramcmts block">
<dt class="param">p</dt>
<dd class="cmt"><p>a predicate used to test elements</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>true if <code>p</code> holds for all elements, false otherwise</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="foreach">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">foreach</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.foreach.U">U</span></span>)</span><span class="result">: <a href="../../../unit" class="extype" name="scala.Unit">Unit</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Applies a function <code>f</code> to all the elements of parallel iterable in an undefined order. </p></div>
<dl class="paramcmts block">
<dt class="tparam">U</dt>
<dd class="cmt"><p>the result type of the function applied to each element, which is always discarded</p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>function applied to each element</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="formatted">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="implicit">formatted</span><span class="params">(<span name="fmtstr">fmtstr: <a href="../../../predef%24#String=String" class="extmbr" name="scala.Predef.String">String</a></span>)</span><span class="result">: <a href="../../../predef%24#String=String" class="extmbr" name="scala.Predef.String">String</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Returns string formatted according to given <code>format</code> string. Format strings are as for <code>String.format</code> (@see java.lang.String.format). </p></div>
<dl class="attributes block"> <dt class="implicit">Implicit</dt>
<dd> This member is added by an implicit conversion from <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>] to <a href="../../../predef%24%24stringformat" class="extype" name="scala.Predef.StringFormat">StringFormat</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]] performed by method StringFormat in <a href="../../../predef%24" class="extype" name="scala.Predef">scala.Predef</a>. </dd>
<dt>Definition Classes</dt>
<dd><a href="../../../predef%24%24stringformat" class="extype" name="scala.Predef.StringFormat">StringFormat</a></dd>
<dt>Annotations</dt>
<dd> <span class="name">@<a href="../../../inline" class="extype" name="scala.inline">inline</a></span><span class="args">()</span> </dd>
</dl>
</div> <h3 id="genericBuilder">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">genericBuilder</span><span class="tparams">[<span name="B">B</span>]</span><span class="result">: <a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.generic.GenericParTemplate.genericBuilder.B">B</span>, <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.generic.GenericParTemplate.genericBuilder.B">B</span>]]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>The generic builder that builds instances of Traversable at arbitrary element types. </p></div>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../../generic/genericpartemplate" class="extype" name="scala.collection.generic.GenericParTemplate">GenericParTemplate</a> → <a href="../../generic/generictraversabletemplate" class="extype" name="scala.collection.generic.GenericTraversableTemplate">GenericTraversableTemplate</a>
</dd>
</dl>
</div> <h3 id="genericCombiner">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">genericCombiner</span><span class="tparams">[<span name="B">B</span>]</span><span class="result">: <a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.generic.GenericParTemplate.genericCombiner.B">B</span>, <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.generic.GenericParTemplate.genericCombiner.B">B</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../generic/genericpartemplate" class="extype" name="scala.collection.generic.GenericParTemplate">GenericParTemplate</a></dd>
</dl></div> <h3 id="getClass">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Returns the runtime class representation of the object. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a class object corresponding to the runtime type of the receiver.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>AnyRef → <a href="../../../any" class="extype" name="scala.Any">Any</a>
</dd>
<dt>Annotations</dt>
<dd> <span class="name">@<a href="../../../native" class="extype" name="scala.native">native</a></span><span class="args">()</span> </dd>
</dl>
</div> <h3 id="groupBy">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">groupBy</span><span class="tparams">[<span name="K">K</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.groupBy.K">K</span></span>)</span><span class="result">: <a href="../immutable/parmap" class="extype" name="scala.collection.parallel.immutable.ParMap">immutable.ParMap</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.groupBy.K">K</span>, <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Partitions this parallel iterable into a map of parallel iterables according to some discriminator function.</p>
<p> Note: this method is not re-implemented by views. This means when applied to a view it will always force the view and return a new parallel iterable. </p>
</div>
<dl class="paramcmts block">
<dt class="tparam">K</dt>
<dd class="cmt"><p>the type of keys returned by the discriminator function.</p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>the discriminator function.</p></dd>
<dt>returns</dt>
<dd class="cmt">
<p>A map from keys to parallel iterables such that the following invariant holds:</p>
<pre data-language="scala">(xs groupBy f)(k) = xs filter (x =&gt; f(x) == k)</pre>
<p> That is, every key <code>k</code> is bound to a parallel iterable of those elements <code>x</code> for which <code>f(x)</code> equals <code>k</code>.</p>
</dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="hasDefiniteSize">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">hasDefiniteSize</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Tests whether this parallel iterable is known to have a finite size. All strict collections are known to have finite size. For a non-strict collection such as <code>Stream</code>, the predicate returns <code><b>true</b></code> if all elements have been computed. It returns <code><b>false</b></code> if the stream is not yet evaluated to the end. Non-empty Iterators usually return <code><b>false</b></code> even if they were created from a collection with a known finite size.</p>
<p> Note: many collection methods will not work on collections of infinite sizes. The typical failure mode is an infinite loop. These methods always attempt a traversal without checking first that <code>hasDefiniteSize</code> returns <code><b>true</b></code>. However, checking <code>hasDefiniteSize</code> can provide an assurance that size is well-defined and non-termination is not a concern. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code><b>true</b></code> if this collection is known to have finite size, <code><b>false</b></code> otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="hashCode">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">hashCode</span><span class="params">()</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Hashcodes for GenSeq produce a value from the hashcodes of all the elements of the general sequence.</p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the hash code value for this object.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a> → <a href="../../../any" class="extype" name="scala.Any">Any</a>
</dd>
</dl>
</div> <h3 id="head">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">head</span><span class="result">: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Selects the first element of this parallel iterable.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered.</p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the first element of this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#NoSuchElementException=java.util.NoSuchElementException" class="extmbr" name="scala.NoSuchElementException"><code>NoSuchElementException</code></a> if the parallel iterable is empty.</p></span></dd>
</dl>
</div> <h3 id="headOption">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">headOption</span><span class="result">: <a href="../../../option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Optionally selects the first element.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered.</p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the first element of this parallel iterable if it is nonempty, <code>None</code> if it is empty.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="indexOf">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">indexOf</span><span class="params">(<span name="elem">elem: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>, <span name="from">from: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Finds index of first occurrence of some value in this mutable parallel sequence after or at some start index.</p>
<p> Note: may not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt class="param">elem</dt>
<dd class="cmt"><p>the element value to search for.</p></dd>
<dt class="param">from</dt>
<dd class="cmt"><p>the start index</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the index <code>&gt;= from</code> of the first element of this mutable parallel sequence that is equal (as determined by <code>==</code>) to <code>elem</code>, or <code>-1</code>, if none exists.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a></dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="indexOf">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">indexOf</span><span class="params">(<span name="elem">elem: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>)</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Finds index of first occurrence of some value in this mutable parallel sequence.</p>
<p> Note: may not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt class="param">elem</dt>
<dd class="cmt"><p>the element value to search for.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the index of the first element of this mutable parallel sequence that is equal (as determined by <code>==</code>) to <code>elem</code>, or <code>-1</code>, if none exists.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a></dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="indexWhere">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">indexWhere</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>, <span name="from">from: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Finds the first element satisfying some predicate.</p>
<p> This method will use <code>indexFlag</code> signalling capabilities. This means that splitters may set and read the <code>indexFlag</code> state.</p>
<p> The index flag is initially set to maximum integer value. </p>
</div>
<dl class="paramcmts block">
<dt class="param">p</dt>
<dd class="cmt"><p>the predicate used to test the elements</p></dd>
<dt class="param">from</dt>
<dd class="cmt"><p>the starting offset for the search</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the index <code>&gt;= from</code> of the first element of this parallel iterable that satisfies the predicate <code>p</code>, or <code>-1</code>, if none exists</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
</dl>
</div> <h3 id="indexWhere">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">indexWhere</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Finds index of first element satisfying some predicate.</p>
<p> Note: may not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt class="param">p</dt>
<dd class="cmt"><p>the predicate used to test elements.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the index of the first element of this general sequence that satisfies the predicate <code>p</code>, or <code>-1</code>, if none exists.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a></dd>
</dl>
</div> <h3 id="init">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">init</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Selects all elements except the last.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered.</p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a parallel iterable consisting of all elements of this parallel iterable except the last one.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#UnsupportedOperationException=UnsupportedOperationException" class="extmbr" name="scala.UnsupportedOperationException"><code>UnsupportedOperationException</code></a> if the parallel iterable is empty.</p></span></dd>
</dl>
</div> <h3 id="initTaskSupport">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">initTaskSupport</span><span class="params">()</span><span class="result">: <a href="../../../unit" class="extype" name="scala.Unit">Unit</a></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="intersect">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">intersect</span><span class="params">(<span name="that">that: <a href="../../../index#Seq%5B+A%5D=Seq%5BA%5D" class="extmbr" name="scala.Seq">scala.Seq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Computes the multiset intersection between this mutable parallel sequence and another sequence.</p>
<p> Note: may not terminate for infinite-sized collections.</p>
</div>
<dl class="paramcmts block">
<dt class="param">that</dt>
<dd class="cmt"><p>the sequence of elements to intersect with.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence which contains all elements of this mutable parallel sequence which also appear in <code>that</code>. If an element value <code>x</code> appears <i>n</i> times in <code>that</code>, then the first <i>n</i> occurrences of <code>x</code> will be retained in the result, but any following occurrences will be omitted.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="isDefinedAt">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">isDefinedAt</span><span class="params">(<span name="idx">idx: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Tests whether this general sequence contains given index.</p>
<p> The implementations of methods <code>apply</code> and <code>isDefinedAt</code> turn a <code>Seq[A]</code> into a <code>PartialFunction[Int, A]</code>. </p>
</div>
<dl class="paramcmts block">
<dt class="param">idx</dt>
<dd class="cmt"><p>the index to test</p></dd>
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if this general sequence contains an element at position <code>idx</code>, <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a></dd>
</dl>
</div> <h3 id="isEmpty">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">isEmpty</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Tests whether the parallel iterable is empty.</p>
<p> Note: Implementations in subclasses that are not repeatedly traversable must take care not to consume any elements when <code>isEmpty</code> is called. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the parallel iterable contains no elements, <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="isInstanceOf">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Test whether the dynamic type of the receiver object is <code>T0</code>.</p>
<p> Note that the result of the test is modulo Scala's erasure semantics. Therefore the expression <code>1.isInstanceOf[String]</code> will return <code>false</code>, while the expression <code>List(1).isInstanceOf[List[String]]</code> will return <code>true</code>. In the latter example, because the type argument is erased as part of compilation it is not possible to check whether the contents of the list are of the specified type. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the receiver object is an instance of erasure of type <code>T0</code>; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../../any" class="extype" name="scala.Any">Any</a></dd>
</dl>
</div> <h3 id="isStrictSplitterCollection">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">isStrictSplitterCollection</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Denotes whether this parallel collection has strict splitters.</p>
<p> This is true in general, and specific collection instances may choose to override this method. Such collections will fail to execute methods which rely on splitters being strict, i.e. returning a correct value in the <code>remaining</code> method.</p>
<p> This method helps ensure that such failures occur on method invocations, rather than later on and in unpredictable ways. </p>
</div>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl>
</div> <h3 id="isTraversableAgain">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">isTraversableAgain</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Tests whether this parallel iterable can be repeatedly traversed.</p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code></p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="iterator">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">iterator</span><span class="result">: <a href="../precisesplitter" class="extype" name="scala.collection.parallel.PreciseSplitter">PreciseSplitter</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Creates a new split iterator used to traverse the elements of this collection.</p>
<p> By default, this method is implemented in terms of the protected <code>splitter</code> method. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a split iterator</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../geniterablelike" class="extype" name="scala.collection.GenIterableLike">GenIterableLike</a>
</dd>
</dl>
</div> <h3 id="last">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">last</span><span class="result">: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Selects the last element.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered.</p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>The last element of this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#NoSuchElementException=java.util.NoSuchElementException" class="extmbr" name="scala.NoSuchElementException"><code>NoSuchElementException</code></a> If the parallel iterable is empty.</p></span></dd>
</dl>
</div> <h3 id="lastIndexOf">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">lastIndexOf</span><span class="params">(<span name="elem">elem: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>, <span name="end">end: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt"><p> Finds index of last occurrence of some value in this mutable parallel sequence before or at a given end index.</p></div>
<dl class="paramcmts block">
<dt class="param">elem</dt>
<dd class="cmt"><p>the element value to search for.</p></dd>
<dt class="param">end</dt>
<dd class="cmt"><p>the end index.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the index <code>&lt;= end</code> of the last element of this mutable parallel sequence that is equal (as determined by <code>==</code>) to <code>elem</code>, or <code>-1</code>, if none exists.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a></dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="lastIndexOf">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">lastIndexOf</span><span class="params">(<span name="elem">elem: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>)</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Finds index of last occurrence of some value in this mutable parallel sequence.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
</div>
<dl class="paramcmts block">
<dt class="param">elem</dt>
<dd class="cmt"><p>the element value to search for.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the index of the last element of this mutable parallel sequence that is equal (as determined by <code>==</code>) to <code>elem</code>, or <code>-1</code>, if none exists.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a></dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="lastIndexWhere">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">lastIndexWhere</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>, <span name="end">end: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Finds the last element satisfying some predicate.</p>
<p> This method will use <code>indexFlag</code> signalling capabilities. This means that splitters may set and read the <code>indexFlag</code> state.</p>
<p> The index flag is initially set to minimum integer value. </p>
</div>
<dl class="paramcmts block">
<dt class="param">p</dt>
<dd class="cmt"><p>the predicate used to test the elements</p></dd>
<dt class="param">end</dt>
<dd class="cmt"><p>the maximum offset for the search</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the index <code>&lt;= end</code> of the first element of this parallel iterable that satisfies the predicate <code>p</code>, or <code>-1</code>, if none exists</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
</dl>
</div> <h3 id="lastIndexWhere">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">lastIndexWhere</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Finds index of last element satisfying some predicate.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
</div>
<dl class="paramcmts block">
<dt class="param">p</dt>
<dd class="cmt"><p>the predicate used to test elements.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the index of the last element of this general sequence that satisfies the predicate <code>p</code>, or <code>-1</code>, if none exists.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a></dd>
</dl>
</div> <h3 id="lastOption">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">lastOption</span><span class="result">: <a href="../../../option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Optionally selects the last element.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered.</p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the last element of this parallel iterable$ if it is nonempty, <code>None</code> if it is empty.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="map">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">map</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.collection.GenTraversableLike.A">A</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.map.B">B</span></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.map.B">B</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt"><p> Builds a new collection by applying a function to all elements of this mutable parallel sequence.</p></div>
<dl class="paramcmts block">
<dt class="tparam">B</dt>
<dd class="cmt"><p>the element type of the returned collection.</p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>the function to apply to each element.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence resulting from applying the given function <code>f</code> to each element of this mutable parallel sequence and collecting the results.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="max">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">max</span><span class="result">: <span class="extype" name="scala.collection.GenTraversableOnce.A">A</span></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt"><p> Finds the largest element.</p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the largest element of this mutable parallel sequence.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#UnsupportedOperationException=UnsupportedOperationException" class="extmbr" name="scala.UnsupportedOperationException"><code>UnsupportedOperationException</code></a> if this mutable parallel sequence is empty.</p></span></dd>
</dl>
</div> <h3 id="maxBy">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">maxBy</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.collection.GenTraversableOnce.A">A</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.maxBy.B">B</span></span>)</span><span class="result">: <span class="extype" name="scala.collection.GenTraversableOnce.A">A</span></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt"><p> Finds the first element which yields the largest value measured by function f.</p></div>
<dl class="paramcmts block">
<dt class="tparam">B</dt>
<dd class="cmt"><p>The result type of the function f.</p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>The measuring function.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the first element of this mutable parallel sequence with the largest value measured by function f.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#UnsupportedOperationException=UnsupportedOperationException" class="extmbr" name="scala.UnsupportedOperationException"><code>UnsupportedOperationException</code></a> if this mutable parallel sequence is empty.</p></span></dd>
</dl>
</div> <h3 id="min">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">min</span><span class="result">: <span class="extype" name="scala.collection.GenTraversableOnce.A">A</span></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt"><p> Finds the smallest element.</p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the smallest element of this mutable parallel sequence</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#UnsupportedOperationException=UnsupportedOperationException" class="extmbr" name="scala.UnsupportedOperationException"><code>UnsupportedOperationException</code></a> if this mutable parallel sequence is empty.</p></span></dd>
</dl>
</div> <h3 id="minBy">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">minBy</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.collection.GenTraversableOnce.A">A</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.minBy.B">B</span></span>)</span><span class="result">: <span class="extype" name="scala.collection.GenTraversableOnce.A">A</span></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt"><p> Finds the first element which yields the smallest value measured by function f.</p></div>
<dl class="paramcmts block">
<dt class="tparam">B</dt>
<dd class="cmt"><p>The result type of the function f.</p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>The measuring function.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the first element of this mutable parallel sequence with the smallest value measured by function f.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#UnsupportedOperationException=UnsupportedOperationException" class="extmbr" name="scala.UnsupportedOperationException"><code>UnsupportedOperationException</code></a> if this mutable parallel sequence is empty.</p></span></dd>
</dl>
</div> <h3 id="mkString">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">mkString</span><span class="result">: <a href="../../../predef%24#String=String" class="extmbr" name="scala.Predef.String">String</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Displays all elements of this parallel iterable in a string. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a string representation of this parallel iterable. In the resulting string the string representations (w.r.t. the method <code>toString</code>) of all elements of this parallel iterable follow each other without any separator string.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="mkString">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">mkString</span><span class="params">(<span name="sep">sep: <a href="../../../predef%24#String=String" class="extmbr" name="scala.Predef.String">String</a></span>)</span><span class="result">: <a href="../../../predef%24#String=String" class="extmbr" name="scala.Predef.String">String</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Displays all elements of this parallel iterable in a string using a separator string. </p></div>
<dl class="paramcmts block">
<dt class="param">sep</dt>
<dd class="cmt"><p>the separator string.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a string representation of this parallel iterable. In the resulting string the string representations (w.r.t. the method <code>toString</code>) of all elements of this parallel iterable are separated by the string <code>sep</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="block">Example: <ol>

<p><code>List(1, 2, 3).mkString("|") = "1|2|3"</code></p>
</ol> </div>
</dl>
</div> <h3 id="mkString">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">mkString</span><span class="params">(<span name="start">start: <a href="../../../predef%24#String=String" class="extmbr" name="scala.Predef.String">String</a></span>, <span name="sep">sep: <a href="../../../predef%24#String=String" class="extmbr" name="scala.Predef.String">String</a></span>, <span name="end">end: <a href="../../../predef%24#String=String" class="extmbr" name="scala.Predef.String">String</a></span>)</span><span class="result">: <a href="../../../predef%24#String=String" class="extmbr" name="scala.Predef.String">String</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Displays all elements of this parallel iterable in a string using start, end, and separator strings. </p></div>
<dl class="paramcmts block">
<dt class="param">start</dt>
<dd class="cmt"><p>the starting string.</p></dd>
<dt class="param">sep</dt>
<dd class="cmt"><p>the separator string.</p></dd>
<dt class="param">end</dt>
<dd class="cmt"><p>the ending string.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a string representation of this parallel iterable. The resulting string begins with the string <code>start</code> and ends with the string <code>end</code>. Inside, the string representations (w.r.t. the method <code>toString</code>) of all elements of this parallel iterable are separated by the string <code>sep</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="block">Example: <ol>

<p><code>List(1, 2, 3).mkString("(", "; ", ")") = "(1; 2; 3)"</code></p>
</ol> </div>
</dl>
</div> <h3 id="ne">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <a href="../../../anyref" class="extype" name="scala.AnyRef">AnyRef</a></span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Equivalent to <code>!(this eq that)</code>. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the argument is not a reference to the receiver object; <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>AnyRef</dd>
</dl>
</div> <h3 id="newBuilder">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">newBuilder</span><span class="result">: <a href="../../mutable/builder" class="extype" name="scala.collection.mutable.Builder">Builder</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>The builder that builds instances of type Traversable[A] </p></div>
<dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd>
<a href="../../generic/genericpartemplate" class="extype" name="scala.collection.generic.GenericParTemplate">GenericParTemplate</a> → <a href="../../generic/generictraversabletemplate" class="extype" name="scala.collection.generic.GenericTraversableTemplate">GenericTraversableTemplate</a> → <a href="../../generic/hasnewbuilder" class="extype" name="scala.collection.generic.HasNewBuilder">HasNewBuilder</a>
</dd>
</dl>
</div> <h3 id="newCombiner">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">newCombiner</span><span class="result">: <a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd>
<a href="../../generic/genericpartemplate" class="extype" name="scala.collection.generic.GenericParTemplate">GenericParTemplate</a> → <a href="../../generic/hasnewcombiner" class="extype" name="scala.collection.generic.HasNewCombiner">HasNewCombiner</a>
</dd>
</dl></div> <h3 id="nonEmpty">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">nonEmpty</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Tests whether the parallel iterable is not empty. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if the parallel iterable contains at least one element, <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="notify">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">notify</span><span class="params">()</span><span class="result">: <a href="../../../unit" class="extype" name="scala.Unit">Unit</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Wakes up a single thread that is waiting on the receiver object's monitor. </p></div>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd> <span class="name">@<a href="../../../native" class="extype" name="scala.native">native</a></span><span class="args">()</span> </dd>
<dt>Note</dt>
<dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd>
</dl>
</div> <h3 id="notifyAll">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <a href="../../../unit" class="extype" name="scala.Unit">Unit</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Wakes up all threads that are waiting on the receiver object's monitor. </p></div>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd> <span class="name">@<a href="../../../native" class="extype" name="scala.native">native</a></span><span class="args">()</span> </dd>
<dt>Note</dt>
<dd><span class="cmt"><p>not specified by SLS as a member of AnyRef</p></span></dd>
</dl>
</div> <h3 id="padTo">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">padTo</span><span class="params">(<span name="len">len: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>, <span name="elem">elem: <span class="extype" name="scala.collection.GenSeqLike.A">A</span></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.GenSeqLike.A">A</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt"><p> A copy of this mutable parallel sequence with an element value appended until a given target length is reached.</p></div>
<dl class="paramcmts block">
<dt class="param">len</dt>
<dd class="cmt"><p>the target length</p></dd>
<dt class="param">elem</dt>
<dd class="cmt"><p>the padding value</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence consisting of all elements of this mutable parallel sequence followed by the minimal number of occurrences of <code>elem</code> so that the resulting mutable parallel sequence has a length of at least <code>len</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="par">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">par</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Returns a parallel implementation of this collection.</p>
<p> For most collection types, this method creates a new parallel collection by copying all the elements. For these collection, <code>par</code> takes linear time. Mutable collections in this category do not produce a mutable parallel collection that has the same underlying dataset, so changes in one collection will not be reflected in the other one.</p>
<p> Specific collections (e.g. <code>ParArray</code> or <code>mutable.ParHashMap</code>) override this default behaviour by creating a parallel collection which shares the same underlying dataset. For these collections, <code>par</code> takes constant or sublinear time.</p>
<p> All parallel collections return a reference to themselves. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a parallel implementation of this collection</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../customparallelizable" class="extype" name="scala.collection.CustomParallelizable">CustomParallelizable</a> → <a href="../../parallelizable" class="extype" name="scala.collection.Parallelizable">Parallelizable</a>
</dd>
</dl>
</div> <h3 id="parCombiner">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">parCombiner</span><span class="result">: <a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>The default <code>par</code> implementation uses the combiner provided by this method to create a new parallel collection. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a combiner for the parallel collection of type <code>ParRepr</code></p></dd>
</dl>
<dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd>
<a href="../../customparallelizable" class="extype" name="scala.collection.CustomParallelizable">CustomParallelizable</a> → <a href="../../parallelizable" class="extype" name="scala.collection.Parallelizable">Parallelizable</a>
</dd>
</dl>
</div> <h3 id="partition">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">partition</span><span class="params">(<span name="pred">pred: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: (<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>], <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>])</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Partitions this parallel iterable in two parallel iterables according to a predicate. </p></div>
<dl class="paramcmts block">
<dt class="param">pred</dt>
<dd class="cmt"><p>the predicate on which to partition.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a pair of parallel iterables: the first parallel iterable consists of all elements that satisfy the predicate <code>p</code> and the second parallel iterable consists of all elements that don't. The relative order of the elements in the resulting parallel iterables may not be preserved.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="patch">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">patch</span><span class="params">(<span name="from">from: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>, <span name="that">that: <a href="../../genseq" class="extype" name="scala.collection.GenSeq">GenSeq</a>[<span class="extype" name="scala.collection.GenSeqLike.A">A</span>]</span>, <span name="replaced">replaced: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.GenSeqLike.A">A</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt"><p> Produces a new mutable parallel sequence where a slice of elements in this mutable parallel sequence is replaced by another sequence.</p></div>
<dl class="paramcmts block">
<dt class="param">from</dt>
<dd class="cmt"><p>the index of the first replaced element</p></dd>
<dt class="param">replaced</dt>
<dd class="cmt"><p>the number of elements to drop in the original mutable parallel sequence</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence consisting of all elements of this mutable parallel sequence except that <code>replaced</code> elements starting from <code>from</code> are replaced by <code>patch</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="prefixLength">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">prefixLength</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Returns the length of the longest prefix whose elements all satisfy some predicate.</p>
<p> Note: may not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt class="param">p</dt>
<dd class="cmt"><p>the predicate used to test elements.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the length of the longest prefix of this general sequence such that every element of the segment satisfies the predicate <code>p</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a></dd>
</dl>
</div> <h3 id="product">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">product</span><span class="result">: <span class="extype" name="scala.collection.GenTraversableOnce.A">A</span></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt"><p> Multiplies up the elements of this collection.</p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the product of all elements in this mutable parallel sequence of numbers of type <code>Int</code>. Instead of <code>Int</code>, any other type <code>T</code> with an implicit <code>Numeric[T]</code> implementation can be used as element type of the mutable parallel sequence and as result type of <code>product</code>. Examples of such types are: <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>BigInt</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="reduce">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">reduce</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>]</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.ParIterableLike.reduce.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.reduce.U">U</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.reduce.U">U</span></span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.reduce.U">U</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Reduces the elements of this sequence using the specified associative binary operator.</p>
<p> The order in which operations are performed on elements is unspecified and may be nondeterministic.</p>
<p> Note this method has a different signature than the <code>reduceLeft</code> and <code>reduceRight</code> methods of the trait <code>Traversable</code>. The result of reducing may only be a supertype of this parallel collection's type parameter <code>T</code>. </p>
</div>
<dl class="paramcmts block">
<dt class="tparam">U</dt>
<dd class="cmt"><p>A type parameter for the binary operator, a supertype of <code>T</code>.</p></dd>
<dt class="param">op</dt>
<dd class="cmt"><p>A binary operator that must be associative.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>The result of applying reduce operator <code>op</code> between all the elements if the collection is nonempty.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#UnsupportedOperationException=UnsupportedOperationException" class="extmbr" name="scala.UnsupportedOperationException"><code>UnsupportedOperationException</code></a> if this parallel iterable is empty.</p></span></dd>
</dl>
</div> <h3 id="reduceLeft">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">reduceLeft</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>]</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.ParIterableLike.reduceLeft.U">U</span>, <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.reduceLeft.U">U</span></span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.reduceLeft.U">U</span></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="reduceLeftOption">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">reduceLeftOption</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>]</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.ParIterableLike.reduceLeftOption.U">U</span>, <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.reduceLeftOption.U">U</span></span>)</span><span class="result">: <a href="../../../option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.reduceLeftOption.U">U</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Optionally applies a binary operator to all elements of this parallel iterable, going left to right.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered. or the operator is associative and commutative. </p>
</div>
<dl class="paramcmts block">
<dt class="param">op</dt>
<dd class="cmt"><p>the binary operator.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>an option value containing the result of <code>reduceLeft(op)</code> if this parallel iterable is nonempty, <code>None</code> otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="reduceOption">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">reduceOption</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>]</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.ParIterableLike.reduceOption.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.reduceOption.U">U</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.reduceOption.U">U</span></span>)</span><span class="result">: <a href="../../../option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.reduceOption.U">U</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Optionally reduces the elements of this sequence using the specified associative binary operator.</p>
<p> The order in which operations are performed on elements is unspecified and may be nondeterministic.</p>
<p> Note this method has a different signature than the <code>reduceLeftOption</code> and <code>reduceRightOption</code> methods of the trait <code>Traversable</code>. The result of reducing may only be a supertype of this parallel collection's type parameter <code>T</code>. </p>
</div>
<dl class="paramcmts block">
<dt class="tparam">U</dt>
<dd class="cmt"><p>A type parameter for the binary operator, a supertype of <code>T</code>.</p></dd>
<dt class="param">op</dt>
<dd class="cmt"><p>A binary operator that must be associative.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>An option value containing result of applying reduce operator <code>op</code> between all the elements if the collection is nonempty, and <code>None</code> otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="reduceRight">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">reduceRight</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>]</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.reduceRight.U">U</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.reduceRight.U">U</span></span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.reduceRight.U">U</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Applies a binary operator to all elements of this parallel iterable, going right to left.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered. or the operator is associative and commutative. </p>
</div>
<dl class="paramcmts block">
<dt class="param">op</dt>
<dd class="cmt"><p>the binary operator.</p></dd>
<dt>returns</dt>
<dd class="cmt">
<p>the result of inserting <code>op</code> between consecutive elements of this parallel iterable, going right to left:</p>
<pre data-language="scala">op(x_1, op(x_2, ..., op(x_{n-1}, x_n)...))</pre>
<p> where <code>x<sub>1</sub>, ..., x<sub>n</sub></code> are the elements of this parallel iterable.</p>
</dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#UnsupportedOperationException=UnsupportedOperationException" class="extmbr" name="scala.UnsupportedOperationException"><code>UnsupportedOperationException</code></a> if this parallel iterable is empty.</p></span></dd>
</dl>
</div> <h3 id="reduceRightOption">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">reduceRightOption</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>]</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.reduceRightOption.U">U</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.reduceRightOption.U">U</span></span>)</span><span class="result">: <a href="../../../option" class="extype" name="scala.Option">Option</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.reduceRightOption.U">U</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Optionally applies a binary operator to all elements of this parallel iterable, going right to left.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered. or the operator is associative and commutative. </p>
</div>
<dl class="paramcmts block">
<dt class="param">op</dt>
<dd class="cmt"><p>the binary operator.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>an option value containing the result of <code>reduceRight(op)</code> if this parallel iterable is nonempty, <code>None</code> otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="repr">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">repr</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl></div> <h3 id="reuse">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">reuse</span><span class="tparams">[<span name="S">S</span>, <span name="That">That</span>]</span><span class="params">(<span name="oldc">oldc: <a href="../../../option" class="extype" name="scala.Option">Option</a>[<a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.reuse.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.reuse.That">That</span>]]</span>, <span name="newc">newc: <a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.reuse.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.reuse.That">That</span>]</span>)</span><span class="result">: <a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.reuse.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.reuse.That">That</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Optionally reuses an existing combiner for better performance. By default it doesn't - subclasses may override this behaviour. The provided combiner <code>oldc</code> that can potentially be reused will be either some combiner from the previous computational task, or <code>None</code> if there was no previous phase (in which case this method must return <code>newc</code>). </p></div>
<dl class="paramcmts block">
<dt class="param">oldc</dt>
<dd class="cmt"><p>The combiner that is the result of the previous task, or <code>None</code> if there was no previous task.</p></dd>
<dt class="param">newc</dt>
<dd class="cmt"><p>The new, empty combiner that can be used.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>Either <code>newc</code> or <code>oldc</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Attributes</dt>
<dd>protected </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl>
</div> <h3 id="reverse">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">reverse</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Returns new parallel iterable with elements in reversed order.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>A new parallel iterable with all elements of this parallel iterable in reversed order.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
</dl>
</div> <h3 id="reverseMap">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">reverseMap</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.collection.GenSeqLike.A">A</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParSeqLike.reverseMap.B">B</span></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.reverseMap.B">B</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Builds a new collection by applying a function to all elements of this mutable parallel sequence and collecting the results in reversed order.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
<p> Note: <code>xs.reverseMap(f)</code> is the same as <code>xs.reverse.map(f)</code> but might be more efficient.</p>
</div>
<dl class="paramcmts block">
<dt class="tparam">B</dt>
<dd class="cmt"><p>the element type of the returned collection.</p></dd>
<dt class="param">f</dt>
<dd class="cmt"><p>the function to apply to each element.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence resulting from applying the given function <code>f</code> to each element of this mutable parallel sequence and collecting the results in reversed order.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="sameElements">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">sameElements</span><span class="params">(<span name="that">that: <a href="../../geniterable" class="extype" name="scala.collection.GenIterable">GenIterable</a>[<span class="extype" name="scala.collection.GenIterableLike.A">A</span>]</span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Checks if the other iterable collection contains the same elements in the same order as this mutable parallel sequence.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
</div>
<dl class="paramcmts block">
<dt class="param">that</dt>
<dd class="cmt"><p>the collection to compare with.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p><code>true</code>, if both collections contain the same elements in the same order, <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../geniterablelike" class="extype" name="scala.collection.GenIterableLike">GenIterableLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="scan">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">scan</span><span class="params">(<span name="z">z: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Computes a prefix scan of the elements of the collection.</p>
<p> Note: The neutral element <code>z</code> may be applied more than once.</p>
</div>
<dl class="paramcmts block">
<dt class="param">z</dt>
<dd class="cmt"><p>neutral element for the operator <code>op</code></p></dd>
<dt class="param">op</dt>
<dd class="cmt"><p>the associative operator for the scan</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence containing the prefix scan of the elements in this mutable parallel sequence</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="scanBlockSize">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">scanBlockSize</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="scanLeft">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">scanLeft</span><span class="tparams">[<span name="S">S</span>, <span name="That">That</span>]</span><span class="params">(<span name="z">z: <span class="extype" name="scala.collection.parallel.ParIterableLike.scanLeft.S">S</span></span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.ParIterableLike.scanLeft.S">S</span>, <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.scanLeft.S">S</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <a href="../../generic/canbuildfrom" class="extype" name="scala.collection.generic.CanBuildFrom">CanBuildFrom</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>], <span class="extype" name="scala.collection.parallel.ParIterableLike.scanLeft.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.scanLeft.That">That</span>]</span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.scanLeft.That">That</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Produces a collection containing cumulative results of applying the operator going left to right.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered. </p>
</div>
<dl class="paramcmts block">
<dt class="tparam">That</dt>
<dd class="cmt"><p>the actual type of the resulting collection</p></dd>
<dt class="param">z</dt>
<dd class="cmt"><p>the initial value</p></dd>
<dt class="param">op</dt>
<dd class="cmt"><p>the binary operator applied to the intermediate result and the element</p></dd>
<dt class="param">bf</dt>
<dd class="cmt"><p>an implicit value of class <code>CanBuildFrom</code> which determines the result class <code>That</code> from the current representation type <code>Repr</code> and the new element type <code>B</code>.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>collection with intermediate results</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="scanRight">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">scanRight</span><span class="tparams">[<span name="S">S</span>, <span name="That">That</span>]</span><span class="params">(<span name="z">z: <span class="extype" name="scala.collection.parallel.ParIterableLike.scanRight.S">S</span></span>)</span><span class="params">(<span name="op">op: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.scanRight.S">S</span>) ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.scanRight.S">S</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="bf">bf: <a href="../../generic/canbuildfrom" class="extype" name="scala.collection.generic.CanBuildFrom">CanBuildFrom</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>], <span class="extype" name="scala.collection.parallel.ParIterableLike.scanRight.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.scanRight.That">That</span>]</span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.scanRight.That">That</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Produces a collection containing cumulative results of applying the operator going right to left. The head of the collection is the last cumulative result.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered.</p>
<p> Example:</p>
<pre data-language="scala">List(1, 2, 3, 4).scanRight(0)(_ + _) == List(10, 9, 7, 4, 0)</pre>
</div>
<dl class="paramcmts block">
<dt class="tparam">That</dt>
<dd class="cmt"><p>the actual type of the resulting collection</p></dd>
<dt class="param">z</dt>
<dd class="cmt"><p>the initial value</p></dd>
<dt class="param">op</dt>
<dd class="cmt"><p>the binary operator applied to the intermediate result and the element</p></dd>
<dt class="param">bf</dt>
<dd class="cmt"><p>an implicit value of class <code>CanBuildFrom</code> which determines the result class <code>That</code> from the current representation type <code>Repr</code> and the new element type <code>B</code>.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>collection with intermediate results</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="segmentLength">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">segmentLength</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>, <span name="from">from: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Returns the length of the longest segment of elements starting at a given position satisfying some predicate.</p>
<p> This method will use <code>indexFlag</code> signalling capabilities. This means that splitters may set and read the <code>indexFlag</code> state.</p>
<p> The index flag is initially set to maximum integer value. </p>
</div>
<dl class="paramcmts block">
<dt class="param">p</dt>
<dd class="cmt"><p>the predicate used to test the elements</p></dd>
<dt class="param">from</dt>
<dd class="cmt"><p>the starting offset for the search</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the length of the longest segment of elements starting at <code>from</code> and satisfying the predicate</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
</dl>
</div> <h3 id="sequentially">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">sequentially</span><span class="tparams">[<span name="S">S</span>, <span name="That">That &lt;: <a href="../../parallel" class="extype" name="scala.collection.Parallel">Parallel</a></span>]</span><span class="params">(<span name="b">b: (<a href="../../mutable/seq" class="extype" name="scala.collection.mutable.Seq">mutable.Seq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]) ⇒ <a href="../../parallelizable" class="extype" name="scala.collection.Parallelizable">Parallelizable</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.sequentially.S">S</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.sequentially.That">That</span>]</span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[this] </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="size">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">size</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>The size of this parallel iterable.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the number of elements in this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="sizeHintIfCheap">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">sizeHintIfCheap</span><span class="result">: <a href="../../../int" class="extype" name="scala.Int">Int</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>The size of this collection or iterator, if it can be cheaply computed </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the number of elements in this collection or iterator, or -1 if the size cannot be determined cheaply</p></dd>
</dl>
<dl class="attributes block"> <dt>Attributes</dt>
<dd>protected[<a href="../../index" class="extype" name="scala.collection">collection</a>] </dd>
<dt>Definition Classes</dt>
<dd><a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a></dd>
</dl>
</div> <h3 id="slice">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">slice</span><span class="params">(<span name="unc_from">unc_from: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>, <span name="unc_until">unc_until: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Selects an interval of elements. The returned collection is made up of all elements <code>x</code> which satisfy the invariant:</p>
<pre data-language="scala">from &lt;= indexOf(x) &lt; until</pre>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered. </p>
</div>
<dl class="paramcmts block">
<dt class="param">unc_from</dt>
<dd class="cmt"><p>the lowest index to include from this parallel iterable.</p></dd>
<dt class="param">unc_until</dt>
<dd class="cmt"><p>the lowest index to EXCLUDE from this parallel iterable.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a parallel iterable containing the elements greater than or equal to index <code>from</code> extending up to (but not including) index <code>until</code> of this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="span">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">span</span><span class="params">(<span name="pred">pred: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: (<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>], <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>])</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Splits this parallel iterable into a prefix/suffix pair according to a predicate.</p>
<p> This method will use <code>indexFlag</code> signalling capabilities. This means that splitters may set and read the <code>indexFlag</code> state. The index flag is initially set to maximum integer value. </p>
</div>
<dl class="paramcmts block">
<dt class="param">pred</dt>
<dd class="cmt"><p>the predicate used to test the elements</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a pair consisting of the longest prefix of the collection for which all the elements satisfy <code>pred</code>, and the rest of the collection</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="splitAt">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">splitAt</span><span class="params">(<span name="n">n: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: (<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>], <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>])</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Splits this parallel iterable into two at a given position. Note: <code>c splitAt n</code> is equivalent to (but possibly more efficient than) <code>(c take n, c drop n)</code>.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered. </p>
</div>
<dl class="paramcmts block">
<dt class="param">n</dt>
<dd class="cmt"><p>the position at which to split.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a pair of parallel iterables consisting of the first <code>n</code> elements of this parallel iterable, and the other elements.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="startsWith">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">startsWith</span><span class="tparams">[<span name="S">S</span>]</span><span class="params">(<span name="that">that: <a href="../../genseq" class="extype" name="scala.collection.GenSeq">GenSeq</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.startsWith.S">S</span>]</span>, <span name="offset">offset: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Tests whether this parallel iterable contains the given sequence at a given index.</p>
<p> This method will use <code>abort</code> signalling capabilities. This means that splitters may send and read <code>abort</code> signals.</p>
</div>
<dl class="paramcmts block">
<dt class="tparam">S</dt>
<dd class="cmt"><p>the element type of <code>that</code> parallel sequence</p></dd>
<dt class="param">that</dt>
<dd class="cmt"><p>the parallel sequence this sequence is being searched for</p></dd>
<dt class="param">offset</dt>
<dd class="cmt"><p>the starting offset for the search</p></dd>
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if there is a sequence <code>that</code> starting at <code>offset</code> in this sequence, <code>false</code> otherwise</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
</dl>
</div> <h3 id="startsWith">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">startsWith</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="that">that: <a href="../../genseq" class="extype" name="scala.collection.GenSeq">GenSeq</a>[<span class="extype" name="scala.collection.GenSeqLike.startsWith.B">B</span>]</span>)</span><span class="result">: <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Tests whether this general sequence starts with the given sequence. </p></div>
<dl class="paramcmts block">
<dt class="param">that</dt>
<dd class="cmt"><p>the sequence to test</p></dd>
<dt>returns</dt>
<dd class="cmt"><p><code>true</code> if this collection has <code>that</code> as a prefix, <code>false</code> otherwise.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a></dd>
</dl>
</div> <h3 id="stringPrefix">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">stringPrefix</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Defines the prefix of this object's <code>toString</code> representation. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a string representation which starts the result of <code>toString</code> applied to this parallel iterable. By default the string prefix is the simple name of the collection class parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseq" class="extype" name="scala.collection.parallel.ParSeq">ParSeq</a> → <a href="../pariterable" class="extype" name="scala.collection.parallel.ParIterable">ParIterable</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="sum">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">sum</span><span class="result">: <span class="extype" name="scala.collection.GenTraversableOnce.A">A</span></span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt"><p> Sums up the elements of this collection.</p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>the sum of all elements in this mutable parallel sequence of numbers of type <code>Int</code>. Instead of <code>Int</code>, any other type <code>T</code> with an implicit <code>Numeric[T]</code> implementation can be used as element type of the mutable parallel sequence and as result type of <code>sum</code>. Examples of such types are: <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>BigInt</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="synchronized">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd>AnyRef</dd>
</dl></div> <h3 id="tail">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">tail</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Selects all elements except the first.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered.</p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a parallel iterable consisting of all elements of this parallel iterable except the first one.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#UnsupportedOperationException=UnsupportedOperationException" class="extmbr" name="scala.UnsupportedOperationException"><code>UnsupportedOperationException</code></a> if the parallel iterable is empty.</p></span></dd>
</dl>
</div> <h3 id="take">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">take</span><span class="params">(<span name="n">n: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Selects first <i>n</i> elements.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered.</p>
</div>
<dl class="paramcmts block">
<dt class="param">n</dt>
<dd class="cmt"><p>the number of elements to take from this parallel iterable.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a parallel iterable consisting only of the first <code>n</code> elements of this parallel iterable, or else the whole parallel iterable, if it has less than <code>n</code> elements. If <code>n</code> is negative, returns an empty parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="takeWhile">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">takeWhile</span><span class="params">(<span name="pred">pred: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Takes the longest prefix of elements that satisfy the predicate.</p>
<p> This method will use <code>indexFlag</code> signalling capabilities. This means that splitters may set and read the <code>indexFlag</code> state. The index flag is initially set to maximum integer value. </p>
</div>
<dl class="paramcmts block">
<dt class="param">pred</dt>
<dd class="cmt"><p>the predicate used to test the elements</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>the longest prefix of this parallel iterable of elements that satisfy the predicate <code>pred</code></p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversablelike" class="extype" name="scala.collection.GenTraversableLike">GenTraversableLike</a>
</dd>
</dl>
</div> <h3 id="task2ops">
<span class="modifier_kind"> <span class="modifier">implicit </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">task2ops</span><span class="tparams">[<span name="R">R</span>, <span name="Tp">Tp</span>]</span><span class="params">(<span name="tsk">tsk: <a href="#SSCTask%5BR,Tp%5D=ParIterableLike.this.StrictSplitterCheckTask%5BR,Tp%5D" class="extmbr" name="scala.collection.parallel.mutable.ParSeq.SSCTask">SSCTask</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.task2ops.R">R</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.task2ops.Tp">Tp</span>]</span>)</span><span class="result">: <a href="#TaskOps%5BR,Tp%5DextendsAnyRef" class="extmbr" name="scala.collection.parallel.ParIterableLike.TaskOps">TaskOps</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.task2ops.R">R</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.task2ops.Tp">Tp</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="tasksupport">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">tasksupport</span><span class="result">: <a href="../tasksupport" class="extype" name="scala.collection.parallel.TaskSupport">TaskSupport</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>The task support object which is responsible for scheduling and load-balancing tasks to processors. </p></div>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
<dt>See also</dt>
<dd><span class="cmt"><p><a href="../tasksupport" class="extype" name="scala.collection.parallel.TaskSupport">scala.collection.parallel.TaskSupport</a></p></span></dd>
</dl>
</div> <h3 id="tasksupport_=">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span title="gt4s: tasksupport_$eq" class="name">tasksupport_=</span><span class="params">(<span name="ts">ts: <a href="../tasksupport" class="extype" name="scala.collection.parallel.TaskSupport">TaskSupport</a></span>)</span><span class="result">: <a href="../../../unit" class="extype" name="scala.Unit">Unit</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Changes the task support object which is responsible for scheduling and load-balancing tasks to processors.</p>
<p> A task support object can be changed in a parallel collection after it has been created, but only during a quiescent period, i.e. while there are no concurrent invocations to parallel collection methods.</p>
<p> Here is a way to change the task support of a parallel collection:</p>
<pre data-language="scala">import scala.collection.parallel._
val pc = mutable.ParArray(1, 2, 3)
pc.tasksupport = new ForkJoinTaskSupport(
  new java.util.concurrent.ForkJoinPool(2))</pre>
</div>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
<dt>See also</dt>
<dd><span class="cmt"><p><a href="../tasksupport" class="extype" name="scala.collection.parallel.TaskSupport">scala.collection.parallel.TaskSupport</a></p></span></dd>
</dl>
</div> <h3 id="to">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">to</span><span class="tparams">[<span name="Col">Col<span class="tparams">[<span name="_">_</span>]</span></span>]</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.to.Col">Col</span>[<span class="extype" name="scala.collection.GenTraversableOnce.A">A</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Converts this mutable parallel sequence into another by copying all elements.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
</div>
<dl class="paramcmts block">
<dt class="tparam">Col</dt>
<dd class="cmt"><p>The collection type to build.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new collection containing all elements of this mutable parallel sequence.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="toArray">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toArray</span><span class="result">: <a href="../../../array" class="extype" name="scala.Array">Array</a>[<span class="extype" name="scala.collection.GenTraversableOnce.A">A</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Converts this mutable parallel sequence to an array.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>an array containing all elements of this mutable parallel sequence. An <code>ClassTag</code> must be available for the element type of this mutable parallel sequence.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="toBuffer">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toBuffer</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>]</span><span class="result">: <a href="../../mutable/buffer" class="extype" name="scala.collection.mutable.Buffer">Buffer</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.toBuffer.U">U</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Uses the contents of this parallel iterable to create a new mutable buffer.</p>
<p> Note: will not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a buffer containing all elements of this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="toIndexedSeq">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toIndexedSeq</span><span class="result">: <a href="../../immutable/indexedseq" class="extype" name="scala.collection.immutable.IndexedSeq">immutable.IndexedSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Converts this parallel iterable to an indexed sequence.</p>
<p> Note: will not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>an indexed sequence containing all elements of this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="toIterable">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toIterable</span><span class="result">: <a href="pariterable" class="extype" name="scala.collection.parallel.mutable.ParIterable">ParIterable</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Converts this parallel iterable to an iterable collection. Note that the choice of target <code>Iterable</code> is lazy in this default implementation as this <code>TraversableOnce</code> may be lazy and unevaluated (i.e. it may be an iterator which is only traversable once).</p>
<p> Note: will not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>an <code>Iterable</code> containing all elements of this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="pariterable" class="extype" name="scala.collection.parallel.mutable.ParIterable">ParIterable</a> → <a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="toIterator">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toIterator</span><span class="result">: <a href="../../../index#Iterator%5B+A%5D=Iterator%5BA%5D" class="extmbr" name="scala.Iterator">scala.Iterator</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Returns an Iterator over the elements in this parallel iterable. Will return the same Iterator if this instance is already an Iterator.</p>
<p> Note: will not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>an Iterator containing all elements of this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="toList">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toList</span><span class="result">: <a href="../../../index#List%5B+A%5D=List%5BA%5D" class="extmbr" name="scala.List">List</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Converts this parallel iterable to a list.</p>
<p> Note: will not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a list containing all elements of this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="toMap">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toMap</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="result">: <a href="../../map" class="extype" name="scala.collection.Map">collection.Map</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.toMap.T">T</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.toMap.U">U</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Converts this mutable parallel sequence to a map. This method is unavailable unless the elements are members of Tuple2, each ((T, U)) becoming a key-value pair in the map. Duplicate keys will be overwritten by later keys: if this is an unordered collection, which key is in the resulting map is undefined.</p>
<p> Note: will not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a map of type <code>immutable.Map[T, U]</code> containing all key/value pairs of type <code>(T, U)</code> of this mutable parallel sequence.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="toParArray">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="implicit">toParArray</span><span class="result">: <a href="pararray" class="extype" name="scala.collection.parallel.mutable.ParArray">ParArray</a>[<span class="extype" name="scala.collection.parallel.CollectionsHaveToParArray.T">T</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt>
<dd> This member is added by an implicit conversion from <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>] to <a href="../package%24%24collectionshavetopararray" class="extype" name="scala.collection.parallel.CollectionsHaveToParArray">CollectionsHaveToParArray</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>], <span class="extype" name="scala.collection.parallel.CollectionsHaveToParArray.T">T</span>] performed by method CollectionsHaveToParArray in <a href="../index" class="extype" name="scala.collection.parallel">scala.collection.parallel</a>. This conversion will take place only if an implicit value of type (<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]) ⇒ <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>[<span class="extype" name="scala.collection.parallel.CollectionsHaveToParArray.T">T</span>] is in scope. </dd>
<dt>Definition Classes</dt>
<dd><a href="../package%24%24collectionshavetopararray" class="extype" name="scala.collection.parallel.CollectionsHaveToParArray">CollectionsHaveToParArray</a></dd>
</dl></div> <h3 id="toParCollection">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toParCollection</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>, <span name="That">That</span>]</span><span class="params">(<span name="cbf">cbf: () ⇒ <a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.toParCollection.U">U</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.toParCollection.That">That</span>]</span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.toParCollection.That">That</span></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="toParMap">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toParMap</span><span class="tparams">[<span name="K">K</span>, <span name="V">V</span>, <span name="That">That</span>]</span><span class="params">(<span name="cbf">cbf: () ⇒ <a href="../combiner" class="extype" name="scala.collection.parallel.Combiner">Combiner</a>[(<span class="extype" name="scala.collection.parallel.ParIterableLike.toParMap.K">K</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.toParMap.V">V</span>), <span class="extype" name="scala.collection.parallel.ParIterableLike.toParMap.That">That</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <a href="../../../predef%24%24%24less%24colon%24less" class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>, (<span class="extype" name="scala.collection.parallel.ParIterableLike.toParMap.K">K</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.toParMap.V">V</span>)]</span>)</span><span class="result">: <span class="extype" name="scala.collection.parallel.ParIterableLike.toParMap.That">That</span></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="toSeq">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toSeq</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Converts this mutable parallel sequence to a sequence. As with <code>toIterable</code>, it's lazy in this default implementation, as this <code>TraversableOnce</code> may be lazy and unevaluated.</p>
<p> Note: will not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a sequence containing all elements of this mutable parallel sequence.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a> → <a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="pariterable" class="extype" name="scala.collection.parallel.mutable.ParIterable">ParIterable</a> → <a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="toSet">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toSet</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span></span>]</span><span class="result">: <a href="../immutable/parset" class="extype" name="scala.collection.parallel.immutable.ParSet">immutable.ParSet</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.toSet.U">U</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Converts this parallel iterable to a set.</p>
<p> Note: will not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a set containing all elements of this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="toStream">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toStream</span><span class="result">: <a href="../../../index#Stream%5B+A%5D=scala.collection.immutable.Stream%5BA%5D" class="extmbr" name="scala.Stream">Stream</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Converts this parallel iterable to a stream.</p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a stream containing all elements of this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="toString">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toString</span><span class="params">()</span><span class="result">: <a href="../../../predef%24#String=String" class="extmbr" name="scala.Predef.String">String</a></span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt"><p>Creates a String representation of this object. The default representation is platform dependent. On the java platform it is the concatenation of the class name, "@", and the object's hashcode in hexadecimal. </p></div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a String representation of the object.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseq" class="extype" name="scala.collection.parallel.ParSeq">ParSeq</a> → <a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → AnyRef → <a href="../../../any" class="extype" name="scala.Any">Any</a>
</dd>
</dl>
</div> <h3 id="toTraversable">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toTraversable</span><span class="result">: <a href="../../gentraversable" class="extype" name="scala.collection.GenTraversable">GenTraversable</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Converts this parallel iterable to an unspecified Traversable. Will return the same collection if this instance is already Traversable.</p>
<p> Note: will not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a Traversable containing all elements of this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="toVector">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">toVector</span><span class="result">: <a href="../../../index#Vector%5B+A%5D=scala.collection.immutable.Vector%5BA%5D" class="extmbr" name="scala.Vector">Vector</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Converts this parallel iterable to a Vector.</p>
<p> Note: will not terminate for infinite-sized collections. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>a vector containing all elements of this parallel iterable.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>
</dd>
</dl>
</div> <h3 id="transpose">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">transpose</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="asTraversable">asTraversable: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../gentraversableonce" class="extype" name="scala.collection.GenTraversableOnce">GenTraversableOnce</a>[<span class="extype" name="scala.collection.generic.GenericTraversableTemplate.transpose.B">B</span>]</span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.generic.GenericTraversableTemplate.transpose.B">B</span>]]</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Transposes this collection of traversable collections into a collection of collections.</p>
<p> The resulting collection's type will be guided by the static type of collection. For example:</p>
<pre data-language="scala">val xs = List(
           Set(1, 2, 3),
           Set(4, 5, 6)).transpose
// xs == List(
//         List(1, 4),
//         List(2, 5),
//         List(3, 6))

val ys = Vector(
           List(1, 2, 3),
           List(4, 5, 6)).transpose
// ys == Vector(
//         Vector(1, 4),
//         Vector(2, 5),
//         Vector(3, 6))</pre>
</div>
<dl class="paramcmts block">
<dt class="tparam">B</dt>
<dd class="cmt"><p>the type of the elements of each traversable collection.</p></dd>
<dt class="param">asTraversable</dt>
<dd class="cmt"><p>an implicit conversion which asserts that the element type of this collection is a <code>Traversable</code>.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a two-dimensional collection of collections which has as <i>n</i>th row the <i>n</i>th column of this collection.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../generic/generictraversabletemplate" class="extype" name="scala.collection.generic.GenericTraversableTemplate">GenericTraversableTemplate</a></dd>
<dt>Annotations</dt>
<dd> <span class="name">@migration</span> </dd>
<dt>Migration</dt>
<dd class="cmt"><p><i>(Changed in version 2.9.0)</i> <code>transpose</code> throws an <code>IllegalArgumentException</code> if collections are not uniformly sized.</p></dd>
<dt>Exceptions thrown</dt>
<dd><span class="cmt"><p><a href="../../../index#IllegalArgumentException=IllegalArgumentException" class="extmbr" name="scala.IllegalArgumentException"><code>IllegalArgumentException</code></a> if all collections in this collection are not of the same size.</p></span></dd>
</dl>
</div> <h3 id="union">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">union</span><span class="params">(<span name="that">that: <a href="../../genseq" class="extype" name="scala.collection.GenSeq">GenSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Produces a new sequence which contains all elements of this mutable parallel sequence and also all elements of a given sequence. <code>xs union ys</code> is equivalent to <code>xs ++ ys</code>.</p>
<p> Another way to express this is that <code>xs union ys</code> computes the order-preserving multi-set union of <code>xs</code> and <code>ys</code>. <code>union</code> is hence a counter-part of <code>diff</code> and <code>intersect</code> which also work on multi-sets.</p>
<p> Note: will not terminate for infinite-sized collections.</p>
</div>
<dl class="paramcmts block">
<dt class="param">that</dt>
<dd class="cmt"><p>the sequence to add.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence which contains all elements of this mutable parallel sequence followed by all elements of <code>that</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a></dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="unzip">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">unzip</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="asPair">asPair: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ (<span class="extype" name="scala.collection.generic.GenericTraversableTemplate.unzip.A1">A1</span>, <span class="extype" name="scala.collection.generic.GenericTraversableTemplate.unzip.A2">A2</span>)</span>)</span><span class="result">: (<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.generic.GenericTraversableTemplate.unzip.A1">A1</span>], <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.generic.GenericTraversableTemplate.unzip.A2">A2</span>])</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Converts this collection of pairs into two collections of the first and second half of each pair.</p>
<pre data-language="scala">val xs = Traversable(
           (1, "one"),
           (2, "two"),
           (3, "three")).unzip
// xs == (Traversable(1, 2, 3),
//        Traversable(one, two, three))</pre>
</div>
<dl class="paramcmts block">
<dt class="tparam">A1</dt>
<dd class="cmt"><p>the type of the first half of the element pairs</p></dd>
<dt class="tparam">A2</dt>
<dd class="cmt"><p>the type of the second half of the element pairs</p></dd>
<dt class="param">asPair</dt>
<dd class="cmt"><p>an implicit conversion which asserts that the element type of this collection is a pair.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a pair of collections, containing the first, respectively second half of each element pair of this collection.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../generic/generictraversabletemplate" class="extype" name="scala.collection.generic.GenericTraversableTemplate">GenericTraversableTemplate</a></dd>
</dl>
</div> <h3 id="unzip3">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">unzip3</span><span class="tparams">[<span name="A1">A1</span>, <span name="A2">A2</span>, <span name="A3">A3</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="asTriple">asTriple: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ (<span class="extype" name="scala.collection.generic.GenericTraversableTemplate.unzip3.A1">A1</span>, <span class="extype" name="scala.collection.generic.GenericTraversableTemplate.unzip3.A2">A2</span>, <span class="extype" name="scala.collection.generic.GenericTraversableTemplate.unzip3.A3">A3</span>)</span>)</span><span class="result">: (<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.generic.GenericTraversableTemplate.unzip3.A1">A1</span>], <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.generic.GenericTraversableTemplate.unzip3.A2">A2</span>], <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.generic.GenericTraversableTemplate.unzip3.A3">A3</span>])</span> </span>
</h3>     <div class="fullcomment">
<div class="comment cmt">
<p>Converts this collection of triples into three collections of the first, second, and third element of each triple.</p>
<pre data-language="scala">val xs = Traversable(
           (1, "one", '1'),
           (2, "two", '2'),
           (3, "three", '3')).unzip3
// xs == (Traversable(1, 2, 3),
//        Traversable(one, two, three),
//        Traversable(1, 2, 3))</pre>
</div>
<dl class="paramcmts block">
<dt class="tparam">A1</dt>
<dd class="cmt"><p>the type of the first member of the element triples</p></dd>
<dt class="tparam">A2</dt>
<dd class="cmt"><p>the type of the second member of the element triples</p></dd>
<dt class="tparam">A3</dt>
<dd class="cmt"><p>the type of the third member of the element triples</p></dd>
<dt class="param">asTriple</dt>
<dd class="cmt"><p>an implicit conversion which asserts that the element type of this collection is a triple.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a triple of collections, containing the first, second, respectively third member of each element triple of this collection.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../../generic/generictraversabletemplate" class="extype" name="scala.collection.generic.GenericTraversableTemplate">GenericTraversableTemplate</a></dd>
</dl>
</div> <h3 id="updated">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">updated</span><span class="params">(<span name="index">index: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>, <span name="elem">elem: <span class="extype" name="scala.collection.GenSeqLike.A">A</span></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.GenSeqLike.A">A</span>]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt"><p> A copy of this mutable parallel sequence with one single replaced element.</p></div>
<dl class="paramcmts block">
<dt class="param">index</dt>
<dd class="cmt"><p>the position of the replacement</p></dd>
<dt class="param">elem</dt>
<dd class="cmt"><p>the replacing element</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a copy of this mutable parallel sequence with the element at position <code>index</code> replaced by <code>elem</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../../genseqlike" class="extype" name="scala.collection.GenSeqLike">GenSeqLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="wait">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">wait</span><span class="params">()</span><span class="result">: <a href="../../../unit" class="extype" name="scala.Unit">Unit</a></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd> <span class="name">@<a href="../../../throws" class="extype" name="scala.throws">throws</a></span><span class="args">(<span> <span class="defval" name="classOf[java.lang.InterruptedException]">...</span> </span>)</span> </dd>
</dl></div> <h3 id="wait">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="../../../long" class="extype" name="scala.Long">Long</a></span>, <span name="arg1">arg1: <a href="../../../int" class="extype" name="scala.Int">Int</a></span>)</span><span class="result">: <a href="../../../unit" class="extype" name="scala.Unit">Unit</a></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd> <span class="name">@<a href="../../../throws" class="extype" name="scala.throws">throws</a></span><span class="args">(<span> <span class="defval" name="classOf[java.lang.InterruptedException]">...</span> </span>)</span> </dd>
</dl></div> <h3 id="wait">
<span class="modifier_kind"> <span class="modifier">final </span> <span class="kind">def </span> </span><span class="symbol"> <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <a href="../../../long" class="extype" name="scala.Long">Long</a></span>)</span><span class="result">: <a href="../../../unit" class="extype" name="scala.Unit">Unit</a></span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd>AnyRef</dd>
<dt>Annotations</dt>
<dd> <span class="name">@<a href="../../../throws" class="extype" name="scala.throws">throws</a></span><span class="args">(<span> <span class="defval" name="classOf[java.lang.InterruptedException]">...</span> </span>)</span> <span class="name">@<a href="../../../native" class="extype" name="scala.native">native</a></span><span class="args">()</span> </dd>
</dl></div> <h3 id="withFilter">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">withFilter</span><span class="params">(<span name="pred">pred: (<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>) ⇒ <a href="../../../boolean" class="extype" name="scala.Boolean">Boolean</a></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="wrap">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">wrap</span><span class="tparams">[<span name="R">R</span>]</span><span class="params">(<span name="body">body: ⇒ <span class="extype" name="scala.collection.parallel.ParIterableLike.wrap.R">R</span></span>)</span><span class="result">: <a href="#NonDivisible%5BR%5DextendsParIterableLike.this.NonDivisibleTask%5BR,ParIterableLike.this.NonDivisible%5BR%5D%5D" class="extmbr" name="scala.collection.parallel.ParIterableLike.NonDivisible">NonDivisible</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.wrap.R">R</span>]</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt>
<dd>protected </dd>
<dt>Definition Classes</dt>
<dd><a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a></dd>
</dl></div> <h3 id="zip">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">zip</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="that">that: <a href="../../geniterable" class="extype" name="scala.collection.GenIterable">GenIterable</a>[<span class="extype" name="scala.collection.parallel.ParSeqLike.zip.B">B</span>]</span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[(<span class="extype" name="scala.collection.GenIterableLike.A">A</span>, <span class="extype" name="scala.collection.parallel.ParSeqLike.zip.B">B</span>)]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Returns a mutable parallel sequence formed from this mutable parallel sequence and another iterable collection by combining corresponding elements in pairs. If one of the two collections is longer than the other, its remaining elements are ignored.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered. </p>
</div>
<dl class="paramcmts block">
<dt class="tparam">B</dt>
<dd class="cmt"><p>the type of the second half of the returned pairs</p></dd>
<dt class="param">that</dt>
<dd class="cmt"><p>The iterable providing the second half of each result pair</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence containing pairs consisting of corresponding elements of this mutable parallel sequence and <code>that</code>. The length of the returned collection is the minimum of the lengths of this mutable parallel sequence and <code>that</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../parseqlike" class="extype" name="scala.collection.parallel.ParSeqLike">ParSeqLike</a> → <a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../geniterablelike" class="extype" name="scala.collection.GenIterableLike">GenIterableLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="zipAll">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">zipAll</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="that">that: <a href="../../iterable" class="extype" name="scala.collection.Iterable">Iterable</a>[<span class="extype" name="scala.collection.parallel.ParIterableLike.zipAll.B">B</span>]</span>, <span name="thisElem">thisElem: <span class="extype" name="scala.collection.GenIterableLike.A">A</span></span>, <span name="thatElem">thatElem: <span class="extype" name="scala.collection.parallel.ParIterableLike.zipAll.B">B</span></span>)</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[(<span class="extype" name="scala.collection.GenIterableLike.A">A</span>, <span class="extype" name="scala.collection.parallel.ParIterableLike.zipAll.B">B</span>)]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Returns a mutable parallel sequence formed from this mutable parallel sequence and another iterable collection by combining corresponding elements in pairs. If one of the two collections is shorter than the other, placeholder elements are used to extend the shorter collection to the length of the longer.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered. </p>
</div>
<dl class="paramcmts block">
<dt class="tparam">B</dt>
<dd class="cmt"><p>the type of the second half of the returned pairs</p></dd>
<dt class="param">that</dt>
<dd class="cmt"><p>The iterable providing the second half of each result pair</p></dd>
<dt class="param">thisElem</dt>
<dd class="cmt"><p>the element to be used to fill up the result if this mutable parallel sequence is shorter than <code>that</code>.</p></dd>
<dt class="param">thatElem</dt>
<dd class="cmt"><p>the element to be used to fill up the result if <code>that</code> is shorter than this mutable parallel sequence.</p></dd>
<dt>returns</dt>
<dd class="cmt"><p>a new mutable parallel sequence containing pairs consisting of corresponding elements of this mutable parallel sequence and <code>that</code>. The length of the returned collection is the maximum of the lengths of this mutable parallel sequence and <code>that</code>. If this mutable parallel sequence is shorter than <code>that</code>, <code>thisElem</code> values are used to pad the result. If <code>that</code> is shorter than this mutable parallel sequence, <code>thatElem</code> values are used to pad the result.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../geniterablelike" class="extype" name="scala.collection.GenIterableLike">GenIterableLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
</dl>
</div> <h3 id="zipWithIndex">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span class="name">zipWithIndex</span><span class="result">: <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[(<span class="extype" name="scala.collection.GenIterableLike.A">A</span>, <a href="../../../int" class="extype" name="scala.Int">Int</a>)]</span> </span>
</h3>     <div class="fullcomment">[use case] <div class="comment cmt">
<p> Zips this mutable parallel sequence with its indices.</p>
<p> Note: might return different results for different runs, unless the underlying collection type is ordered. </p>
</div>
<dl class="paramcmts block">
<dt>returns</dt>
<dd class="cmt"><p>A new mutable parallel sequence containing pairs consisting of all elements of this mutable parallel sequence paired with their index. Indices start at <code>0</code>.</p></dd>
</dl>
<dl class="attributes block"> <dt>Definition Classes</dt>
<dd>
<a href="../pariterablelike" class="extype" name="scala.collection.parallel.ParIterableLike">ParIterableLike</a> → <a href="../../geniterablelike" class="extype" name="scala.collection.GenIterableLike">GenIterableLike</a>
</dd>
<div class="full-signature-block toggleContainer"> <span class="toggle">  Full Signature </span>  </div>
<div class="block">Example: <ol>

<p> <code>List("a", "b", "c").zipWithIndex = List(("a", 0), ("b", 1), ("c", 2))</code></p>
</ol> </div>
</dl>
</div> <h3 id="→">
<span class="modifier_kind">  <span class="kind">def </span> </span><span class="symbol"> <span title="gt4s: $u2192" class="implicit">→</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span name="y">y: <span class="extype" name="scala.Predef.ArrowAssoc.→.B">B</span></span>)</span><span class="result">: (<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>], <span class="extype" name="scala.Predef.ArrowAssoc.→.B">B</span>)</span> </span>
</h3>     <div class="fullcomment"><dl class="attributes block"> <dt class="implicit">Implicit</dt>
<dd> This member is added by an implicit conversion from <a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>] to <a href="../../../predef%24%24arrowassoc" class="extype" name="scala.Predef.ArrowAssoc">ArrowAssoc</a>[<a href="parseq" class="extype" name="scala.collection.parallel.mutable.ParSeq">ParSeq</a>[<span class="extype" name="scala.collection.parallel.mutable.ParSeq.T">T</span>]] performed by method ArrowAssoc in <a href="../../../predef%24" class="extype" name="scala.Predef">scala.Predef</a>. </dd>
<dt>Definition Classes</dt>
<dd><a href="../../../predef%24%24arrowassoc" class="extype" name="scala.Predef.ArrowAssoc">ArrowAssoc</a></dd>
</dl></div>   </div>  </div>   </div> <div class="_attribution">
  <p class="_attribution-p">
    © 2002-2019 EPFL, with contributions from Lightbend.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://www.scala-lang.org/api/2.12.9/scala/collection/parallel/mutable/ParSeq.html" class="_attribution-link">https://www.scala-lang.org/api/2.12.9/scala/collection/parallel/mutable/ParSeq.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
