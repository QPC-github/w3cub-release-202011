
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Enable Profiling of R&#39;s Execution - R - W3cubDocs</title>
  
  <meta name="description" content=" Enable or disable profiling of the execution of R expressions. ">
  <meta name="keywords" content="enable, profiling, r&#39;s, execution, r">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/r/library/utils/html/rprof.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c2f2e7d1236e299f399a2d9bf4342fa70a8839fbe6eb79130546d6bf383b99636ffdf29c557090085d7c4ac34eeb5426851b42d2f4ec63cf218916cbd19aa876.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/r.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/r/" class="_nav-link" title="" style="margin-left:0;">R</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h2>
<code>Rprof</code> Enable Profiling of R's Execution</h2> <h3>Description</h3> <p>Enable or disable profiling of the execution of <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> expressions. </p> <h3>Usage</h3> <pre data-language="r">
Rprof(filename = "Rprof.out", append = FALSE, interval = 0.02,
       memory.profiling = FALSE, gc.profiling = FALSE,
       line.profiling = FALSE, filter.callframes = FALSE,
       numfiles = 100L, bufsize = 10000L)
</pre> <h3>Arguments</h3> <table summary="R argblock"> <tr valign="top">
<td><code>filename</code></td> <td> <p>The file to be used for recording the profiling results. Set to <code>NULL</code> or <code>""</code> to disable profiling. </p> </td>
</tr> <tr valign="top">
<td><code>append</code></td> <td> <p>logical: should the file be over-written or appended to? </p> </td>
</tr> <tr valign="top">
<td><code>interval</code></td> <td> <p>real: time interval between samples. </p> </td>
</tr> <tr valign="top">
<td><code>memory.profiling</code></td> <td> <p>logical: write memory use information to the file?</p> </td>
</tr> <tr valign="top">
<td><code>gc.profiling</code></td> <td> <p>logical: record whether GC is running?</p> </td>
</tr> <tr valign="top">
<td><code>line.profiling</code></td> <td> <p>logical: write line locations to the file?</p> </td>
</tr> <tr valign="top">
<td><code>filter.callframes</code></td> <td> <p>logical: filter out intervening call frames of the call tree. See the filtering out call frames section.</p> </td>
</tr> <tr valign="top">
<td><code>numfiles, bufsize</code></td> <td> <p>integers: line profiling memory allocation</p> </td>
</tr> </table> <h3>Details</h3> <p>Enabling profiling automatically disables any existing profiling to another or the same file. </p> <p>Profiling works by writing out the call stack every <code>interval</code> seconds, to the file specified. Either the <code><a href="summaryrprof">summaryRprof</a></code> function or the wrapper script <code>R CMD Rprof</code> can be used to process the output file to produce a summary of the usage; use <code>R CMD Rprof --help</code> for usage information. </p> <p>How time is measured varies by platform: </p> <dl> <dt>On Windows:</dt>
<dd> <p>Exactly what the time interval measures is subtle: it is time that the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> process is running and executing an <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> command. It is not however just CPU time, for if <code>readline()</code> is waiting for input, that counts (on Windows, but not on a Unix-alike). </p> <p>Note that the timing interval cannot be too small, for the time spent in each profiling step is added to the interval. What is feasible is machine-dependent, but 10ms seemed as small as advisable on a 1GHz machine. </p> </dd> <dt>On Unix-alikes</dt>
<dd>
<p>it is the CPU time of the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> process, so for example excludes time when <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> is waiting for input or for processes run by <code><a href="../../base/html/system">system</a></code> to return. </p> <p>Note that the timing interval cannot usefully be too small: once the timer goes off, the information is not recorded until the next timing click (probably in the range 1–10 ms). </p> </dd> </dl> <p>Functions will only be recorded in the profile log if they put a context on the call stack (see <code><a href="../../base/html/sys.parent">sys.calls</a></code>). Some <a href="../../base/html/primitive">primitive</a> functions do not do so: specifically those which are of <a href="../../base/html/typeof">type</a> <code>"special"</code> (see the ‘R Internals’ manual for more details). </p> <p>Individual statements will be recorded in the profile log if <code>line.profiling</code> is <code>TRUE</code>, and if the code being executed was parsed with source references. See <code><a href="../../base/html/parse">parse</a></code> for a discussion of source references. By default the statement locations are not shown in <code><a href="summaryrprof">summaryRprof</a></code>, but see that help page for options to enable the display. </p> <h3>Filtering Out Call Frames</h3> <p>Lazy evaluation makes the call stack more complex because intervening call frames are created between the time arguments are applied to a function, and the time they are effectively evaluated. When the call stack is represented as a tree, these intervening frames appear as sibling nodes. For instance, evaluating <code>try(EXPR)</code> produces the following call tree, at the time <code>EXPR</code> gets evaluated: </p> <pre data-language="r">
1. +-base::try(EXPR)
2. | \-base::tryCatch(...)
3. |   \-base:::tryCatchList(expr, classes, parentenv, handlers)
4. |     \-base:::tryCatchOne(expr, names, parentenv, handlers[[1L]])
5. |       \-base:::doTryCatch(return(expr), name, parentenv, handler)
6. \-EXPR
</pre> <p>Lines 2 to 5 are intervening call frames, the last of which finally triggered evaluation of <code>EXPR</code>. Setting <code>filter.callframes</code> to <code>TRUE</code> simplifies the profiler output by removing all sibling nodes of intervening frames. </p> <p>The same kind of call frame filtering is applied with <code>eval()</code> frames. When you call <code>eval()</code>, two frames are pushed on the stack to ensure a continuity between frames. Say we have these definitions: </p> <pre data-language="r">
calling &lt;- function() evaluator(quote(called()), environment())
evaluator &lt;- function(expr, env) eval(expr, env)
called &lt;- function() EXPR()
</pre> <p><code>calling()</code> calls <code>called()</code> in its own environment, via <code>eval()</code>. The latter is called indirectly through <code>evaluator()</code>. The net effect of this code is identical to just calling <code>called()</code> directly, without the intermediaries. However, the full call stack looks like this: </p> <pre data-language="r">
1. calling()
2. \-evaluator(quote(called()), environment())
3.   \-base::eval(expr, env)
4.     \-base::eval(expr, env)
5.       \-called()
6.         \-EXPR()
</pre> <p>When call frame filtering is turned on, the true calling environment of <code>called()</code> is looked up, and the filtered call stack looks like this: </p> <pre data-language="r">
1. calling()
5. \-called()
6.   \-EXPR()
</pre> <p>If the calling environment is not on the stack, the function called by <code>eval()</code> becomes a root node. Say we have: </p> <pre data-language="r">
calling &lt;- function() evaluator(quote(called()), new.env())
</pre> <p>With call frame filtering we then get the following filtered call stack: </p> <pre data-language="r">
5. called()
6. \-EXPR()
</pre> <h3>Note</h3> <dl> <dt>On Unix-alikes:</dt>
<dd> <p>Profiling is not available on all platforms. By default, support for profiling is compiled in if possible – configure <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> with <span class="option">--disable-R-profiling</span> to change this. </p> <p>As <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> profiling uses the same mechanisms as C profiling, the two cannot be used together, so do not use <code>Rprof</code> in an executable built for C-level profiling. </p> </dd> <dt>On Windows:</dt>
<dd> <p><code>filename</code> can be a UTF-8-encoded filepath that cannot be translated to the current locale. </p> </dd> </dl> <p>The profiler interrupts R asynchronously, and it cannot allocate memory to store results as it runs. This affects line profiling, which needs to store an unknown number of file pathnames. The <code>numfiles</code> and <code>bufsize</code> arguments control the size of pre-allocated buffers to hold these results: the former counts the maximum number of paths, the latter counts the numbers of bytes in them. If the profiler runs out of space it will skip recording the line information for new files, and issue a warning when <code>Rprof(NULL)</code> is called to finish profiling. </p> <h3>See Also</h3> <p>The chapter on “Tidying and profiling R code” in ‘Writing R Extensions’ (see the ‘<span class="file">doc/manual</span>’ subdirectory of the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> source tree). </p> <p><code><a href="summaryrprof">summaryRprof</a></code> to analyse the output file. </p> <p><code><a href="../../base/html/tracemem">tracemem</a></code>, <code><a href="rprofmem">Rprofmem</a></code> for other ways to track memory use. </p> <h3>Examples</h3> <pre data-language="r">
## Not run: Rprof()
## some code to be profiled
Rprof(NULL)
## some code NOT to be profiled
Rprof(append = TRUE)
## some code to be profiled
Rprof(NULL)
## ...
## Now post-process the output as described in Details

## End(Not run)</pre>
<div class="_attribution">
  <p class="_attribution-p">
    Copyright (©) 1999–2012 R Foundation for Statistical Computing.<br>Licensed under the <a href="https://www.gnu.org/copyleft/gpl.html">GNU General Public License</a>.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
