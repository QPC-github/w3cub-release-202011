
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Comparisons With Other Test Runners - Vitest - W3cubDocs</title>
  
  <meta name="description" content="Jest took over the Testing Framework space by providing out-of-the-box support for most JavaScript projects, a comfortable API (it and expect), and &hellip;">
  <meta name="keywords" content="comparisons, with, other, test, runners, vitest">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/vitest/guide/comparisons.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-f16eecbe420d8b2925d31ffbb21d05646497ecbd9515f08ffe69e9bba7332f5657accc7003c7f6c72cb4a132171acf171b359ae3bae4ae5660ddfb1718f88c67.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/vitest.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/vitest/" class="_nav-link" title="" style="margin-left:0;">Vitest</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 id="comparisons-with-other-test-runners" tabindex="-1">Comparisons with Other Test Runners </h1>
<h2 id="jest" tabindex="-1">Jest </h2>
<p><a href="https://jestjs.io/" target="_blank" rel="noreferrer">Jest</a> took over the Testing Framework space by providing out-of-the-box support for most JavaScript projects, a comfortable API (<code>it</code> and <code>expect</code>), and the full pack of testing features that most setups would require (snapshots, mocks, coverage). We are thankful to the Jest team and community for creating a delightful testing API and pushing forward a lot of the testing patterns that are now a standard in the web ecosystem. It is possible to use Jest in Vite setups. <a href="https://twitter.com/haoqunjiang" target="_blank" rel="noreferrer">@sodatea</a> is building <a href="https://github.com/sodatea/vite-jest#readme" target="_blank" rel="noreferrer">vite-jest</a>, which aims to provide first-class Vite integration for <a href="https://jestjs.io/" target="_blank" rel="noreferrer">Jest</a>. The last <a href="https://github.com/sodatea/vite-jest/blob/main/packages/vite-jest/README.md#vite-jest" target="_blank" rel="noreferrer">blockers in Jest</a> have been solved so this is a valid option for your unit tests. However, in a world where we have <a href="https://vitejs.dev" target="_blank" rel="noreferrer">Vite</a> providing support for the most common web tooling (typescript, JSX, most popular UI Frameworks), Jest represents a duplication of complexity. If your app is powered by Vite, having two different pipelines to configure and maintain is not justifiable. With Vitest you get to define the configuration for your dev, build and test environments as a single pipeline, sharing the same plugins and the same vite.config.js. Even if your library is not using Vite (for example, if it is built with esbuild or rollup), Vitest is an interesting option as it gives you a faster run for your unit tests and a jump in DX thanks to the default watch mode using Vite instant Hot Module Reload (HMR). Vitest offers compatibility with most of the Jest API and ecosystem libraries, so in most projects, it should be a drop-in replacement for Jest.</p>
<h2 id="cypress" tabindex="-1">Cypress </h2>
<p><a href="https://www.cypress.io/" target="_blank" rel="noreferrer">Cypress</a> is a browser-based test runner and a complementary tool to Vitest. If you'd like to use Cypress, we suggest using Vitest for all headless logic in your application and Cypress for all browser-based logic.</p>
<p>Cypress is known as an end-to-end testing tool, however their <a href="https://on.cypress.io/component" target="_blank" rel="noreferrer">new component test runner</a> has great support for testing Vite components and is an ideal choice to test anything that renders in a browser.</p>
<p>Browser-based runners, like Cypress and Web Test Runner, will catch issues that Vitest cannot because they use the real browser and real browser APIs.</p>
<p>Cypress's test driver is focused on determining if elements are visible, accessible, and interactive. Cypress is purpose-built for UI development and testing and its DX is centered around test driving your visual components. You see your component rendered alongside the test reporter. Once the test is complete, the component remains interactive and you can debug any failures that occur using your browser devtools.</p>
<p>In contrast, Vitest is focused on delivering the best DX possible for lightning fast, <em>headless</em> testing. Node-based runners like Vitest support various partially-implemented browser environments, like <code>jsdom</code>, which implement enough for you to quickly unit test any code that references browser APIs. The tradeoff is that these browser environments have limitations in what they can implement. For example, <a href="https://github.com/jsdom/jsdom/issues?q=is%3Aissue+is%3Aopen+sort%3Acomments-desc" target="_blank" rel="noreferrer">jsdom is missing a number of features</a> like <code>window.navigation</code> or a layout engine (<code>offsetTop</code>, etc).</p>
<p>Lastly, in contrast to the Web Test Runner, the Cypress test runner is more like an IDE than a test runner because you also see the real rendered component in the browser, along with its test results and logs.</p>
<p>Cypress has also been <a href="https://www.youtube.com/watch?v=7S5cbY8iYLk" target="_blank" rel="noreferrer">integrating Vite in their products</a>: re-building their App's UI using <a href="https://github.com/antfu/vitesse" target="_blank" rel="noreferrer">Vitesse</a> and using Vite to test drive their project's development.</p>
<p>We believe that Cypress isn't a good option for unit testing headless code, but that using Cypress (for E2E and Component Testing) and Vitest (for unit tests) would cover your app's testing needs.</p>
<h2 id="web-test-runner" tabindex="-1">Web Test Runner </h2>
<p><a href="https://modern-web.dev/docs/test-runner/overview/" target="_blank" rel="noreferrer">@web/test-runner</a> runs tests inside a headless browser, providing the same execution environment as your web application without the need for mocking out browser APIs or the DOM. This also makes it possible to debug inside a real browser using the devtools, although there is no UI shown for stepping through the test, as there is in Cypress tests. There is a watch mode, but it is not as intelligent as that of vitest, and may not always re-run the tests you want. To use @web/test-runner with a vite project, there is a <a href="https://github.com/material-svelte/vite-web-test-runner-plugin" target="_blank" rel="noreferrer">plugin</a>, although certain features such as changing the viewport size in a test are <a href="https://github.com/material-svelte/vite-web-test-runner-plugin/issues/11" target="_blank" rel="noreferrer">not currently working</a>. @web/test-runner does not include assertion or mocking libraries, so it is up to you to add them.</p>
<h2 id="uvu" tabindex="-1">uvu </h2>
<p><a href="https://github.com/lukeed/uvu" target="_blank" rel="noreferrer">uvu</a> is a test runner for Node.js and the browser. It runs tests in a single thread, so tests are not isolated and can leak across files. Vitest, however, uses worker threads to isolate tests and run them in parallel. For transforming your code, uvu relies on require and loader hooks. Vitest uses <a href="https://vitejs.dev" target="_blank" rel="noreferrer">Vite</a>, so files are transformed with the full power of Vite's plugin system. In a world where we have Vite providing support for the most common web tooling (typescript, JSX, most popular UI Frameworks), uvu represents a duplication of complexity. If your app is powered by Vite, having two different pipelines to configure and maintain is not justifiable. With Vitest you get to define the configuration for your dev, build and test environments as a single pipeline, sharing the same plugins and the same vite.config.js. uvu does not provide an intelligent watch mode to rerun the changed tests, but Vitest gives you amazing DX thanks to the default watch mode using Vite instant Hot Module Reload (HMR). uvu is a fast option for running simple tests, but Vitest can be faster and more reliable for more complex tests and projects.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2021-Present Anthony Fu<br>© 2021-Present Matias Capeletto<br>Licensed under the MIT License.<br>
    <a href="https://vitest.dev/guide/comparisons.html" class="_attribution-link">https://vitest.dev/guide/comparisons.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
