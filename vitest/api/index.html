
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>API Reference - Vitest - W3cubDocs</title>
  
  <meta name="description" content=" The following types are used in the type signatures below ">
  <meta name="keywords" content="api, reference, vitest">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/vitest/api/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-f16eecbe420d8b2925d31ffbb21d05646497ecbd9515f08ffe69e9bba7332f5657accc7003c7f6c72cb4a132171acf171b359ae3bae4ae5660ddfb1718f88c67.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/vitest.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/vitest/" class="_nav-link" title="" style="margin-left:0;">Vitest</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 id="api-reference" tabindex="-1">API Reference </h1>
<p>The following types are used in the type signatures below</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">type Awaitable&lt;T&gt; = T | PromiseLike&lt;T&gt;
type TestFunction = () =&gt; Awaitable&lt;void&gt;

interface TestOptions {
  timeout?: number
  retry?: number
}</pre>
<pre class="vp-code-light" data-language="javascript">type Awaitable&lt;T&gt; = T | PromiseLike&lt;T&gt;
type TestFunction = () =&gt; Awaitable&lt;void&gt;

interface TestOptions {
  timeout?: number
  retry?: number
}</pre>
</div>
<p>When a test function returns a promise, the runner will wait until it is resolved to collect async expectations. If the promise is rejected, the test will fail.</p>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>In Jest, <code>TestFunction</code> can also be of type <code>(done: DoneCallback) =&gt; void</code>. If this form is used, the test will not be concluded until <code>done</code> is called. You can achieve the same using an <code>async</code> function, see the <a href="../guide/migration#done-callback">Migration guide Done Callback section</a>.</p>
</div>
<h2 id="test" tabindex="-1">test </h2>
<ul>
<li><p><strong>Type:</strong> <code>(name: string, fn: TestFunction, timeout?: number | TestOptions) =&gt; void</code></p></li>
<li>
<p><strong>Alias:</strong> <code>it</code></p>
<p><code>test</code> defines a set of related expectations. It receives the test name and a function that holds the expectations to test.</p>
<p>Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds, and can be configured globally with <a href="../config/index#testtimeout">testTimeout</a></p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test('should work as expected', () =&gt; {
  expect(Math.sqrt(4)).toBe(2)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test('should work as expected', () =&gt; {
  expect(Math.sqrt(4)).toBe(2)
})</pre>
</div>
</li>
</ul>
<h3 id="test-skip" tabindex="-1">test.skip </h3>
<ul>
<li><p><strong>Type:</strong> <code>(name: string, fn: TestFunction, timeout?: number | TestOptions) =&gt; void</code></p></li>
<li>
<p><strong>Alias:</strong> <code>it.skip</code></p>
<p>If you want to skip running certain tests, but you don't want to delete the code due to any reason, you can use <code>test.skip</code> to avoid running them.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { assert, test } from 'vitest'

test.skip('skipped test', () =&gt; {
  // Test skipped, no error
  assert.equal(Math.sqrt(4), 3)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { assert, test } from 'vitest'

test.skip('skipped test', () =&gt; {
  // Test skipped, no error
  assert.equal(Math.sqrt(4), 3)
})</pre>
</div>
</li>
</ul>
<h3 id="test-skipif" tabindex="-1">test.skipIf </h3>
<ul>
<li><p><strong>Type:</strong> <code>(condition: any) =&gt; Test</code></p></li>
<li>
<p><strong>Alias:</strong> <code>it.skipIf</code></p>
<p>In some cases you might run tests multiple times with different environments, and some of the tests might be environment-specific. Instead of wrapping the test code with <code>if</code>, you can use <code>test.skipIf</code> to skip the test whenever the condition is truthy.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { assert, test } from 'vitest'

const isDev = process.env.NODE_ENV === 'development'

test.skipIf(isDev)('prod only test', () =&gt; {
  // this test only runs in production
})</pre>
<pre class="vp-code-light" data-language="javascript">import { assert, test } from 'vitest'

const isDev = process.env.NODE_ENV === 'development'

test.skipIf(isDev)('prod only test', () =&gt; {
  // this test only runs in production
})</pre>
</div>
</li>
</ul>
<h3 id="test-runif" tabindex="-1">test.runIf </h3>
<ul>
<li><p><strong>Type:</strong> <code>(condition: any) =&gt; Test</code></p></li>
<li>
<p><strong>Alias:</strong> <code>it.runIf</code></p>
<p>Opposite of <a href="#testskipif">test.skipIf</a>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { assert, test } from 'vitest'

const isDev = process.env.NODE_ENV === 'development'

test.runIf(isDev)('dev only test', () =&gt; {
  // this test only runs in development
})</pre>
<pre class="vp-code-light" data-language="javascript">import { assert, test } from 'vitest'

const isDev = process.env.NODE_ENV === 'development'

test.runIf(isDev)('dev only test', () =&gt; {
  // this test only runs in development
})</pre>
</div>
</li>
</ul>
<h3 id="test-only" tabindex="-1">test.only </h3>
<ul>
<li><p><strong>Type:</strong> <code>(name: string, fn: TestFunction, timeout?: number) =&gt; void</code></p></li>
<li>
<p><strong>Alias:</strong> <code>it.only</code></p>
<p>Use <code>test.only</code> to only run certain tests in a given suite. This is useful when debugging.</p>
<p>Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds, and can be configured globally with <a href="../config/index#testtimeout">testTimeout</a>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { assert, test } from 'vitest'

test.only('test', () =&gt; {
  // Only this test (and others marked with only) are run
  assert.equal(Math.sqrt(4), 2)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { assert, test } from 'vitest'

test.only('test', () =&gt; {
  // Only this test (and others marked with only) are run
  assert.equal(Math.sqrt(4), 2)
})</pre>
</div>
<p>Sometimes it is very useful to run <code>only</code> tests in a certain file, ignoring all other tests from the whole test suite, which pollute the output.</p>
<p>In order to do that run <code>vitest</code> with specific file containing the tests in question.</p>
<div class="language-">
<pre class="vp-code-dark" data-language="javascript"># vitest interesting.test.ts</pre>
<pre class="vp-code-light" data-language="javascript"># vitest interesting.test.ts</pre>
</div>
</li>
</ul>
<h3 id="test-concurrent" tabindex="-1">test.concurrent </h3>
<ul>
<li><p><strong>Type:</strong> <code>(name: string, fn: TestFunction, timeout?: number) =&gt; void</code></p></li>
<li>
<p><strong>Alias:</strong> <code>it.concurrent</code></p>
<p><code>test.concurrent</code> marks consecutive tests to be run in parallel. It receives the test name, an async function with the tests to collect, and an optional timeout (in milliseconds).</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { describe, test } from 'vitest'

// The two tests marked with concurrent will be run in parallel
describe('suite', () =&gt; {
  test('serial test', async () =&gt; { /* ... */ })
  test.concurrent('concurrent test 1', async () =&gt; { /* ... */ })
  test.concurrent('concurrent test 2', async () =&gt; { /* ... */ })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { describe, test } from 'vitest'

// The two tests marked with concurrent will be run in parallel
describe('suite', () =&gt; {
  test('serial test', async () =&gt; { /* ... */ })
  test.concurrent('concurrent test 1', async () =&gt; { /* ... */ })
  test.concurrent('concurrent test 2', async () =&gt; { /* ... */ })
})</pre>
</div>
<p><code>test.skip</code>, <code>test.only</code>, and <code>test.todo</code> works with concurrent tests. All the following combinations are valid:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">test.concurrent(/* ... */)
test.skip.concurrent(/* ... */) // or test.concurrent.skip(/* ... */)
test.only.concurrent(/* ... */) // or test.concurrent.only(/* ... */)
test.todo.concurrent(/* ... */) // or test.concurrent.todo(/* ... */)</pre>
<pre class="vp-code-light" data-language="javascript">test.concurrent(/* ... */)
test.skip.concurrent(/* ... */) // or test.concurrent.skip(/* ... */)
test.only.concurrent(/* ... */) // or test.concurrent.only(/* ... */)
test.todo.concurrent(/* ... */) // or test.concurrent.todo(/* ... */)</pre>
</div>
<p>When using Snapshots with async concurrent tests, due to the limitation of JavaScript, you need to use the <code>expect</code> from the <a href="../guide/test-context">Test Context</a> to ensure the right test is being detected.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">test.concurrent('test 1', async ({ expect }) =&gt; {
  expect(foo).toMatchSnapshot()
})
test.concurrent('test 2', async ({ expect }) =&gt; {
  expect(foo).toMatchSnapshot()
})</pre>
<pre class="vp-code-light" data-language="javascript">test.concurrent('test 1', async ({ expect }) =&gt; {
  expect(foo).toMatchSnapshot()
})
test.concurrent('test 2', async ({ expect }) =&gt; {
  expect(foo).toMatchSnapshot()
})</pre>
</div>
</li>
</ul>
<h3 id="test-todo" tabindex="-1">test.todo </h3>
<ul>
<li><p><strong>Type:</strong> <code>(name: string) =&gt; void</code></p></li>
<li>
<p><strong>Alias:</strong> <code>it.todo</code></p>
<p>Use <code>test.todo</code> to stub tests to be implemented later. An entry will be shown in the report for the tests so you know how many tests you still need to implement.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">// An entry will be shown in the report for this test
test.todo('unimplemented test')</pre>
<pre class="vp-code-light" data-language="javascript">// An entry will be shown in the report for this test
test.todo('unimplemented test')</pre>
</div>
</li>
</ul>
<h3 id="test-fails" tabindex="-1">test.fails </h3>
<ul>
<li><p><strong>Type:</strong> <code>(name: string, fn: TestFunction, timeout?: number) =&gt; void</code></p></li>
<li>
<p><strong>Alias:</strong> <code>it.fails</code></p>
<p>Use <code>test.fails</code> to indicate that an assertion will fail explicitly.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'
const myAsyncFunc = () =&gt; new Promise(resolve =&gt; resolve(1))
test.fails('fail test', async () =&gt; {
  await expect(myAsyncFunc()).rejects.toBe(1)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'
const myAsyncFunc = () =&gt; new Promise(resolve =&gt; resolve(1))
test.fails('fail test', async () =&gt; {
  await expect(myAsyncFunc()).rejects.toBe(1)
})</pre>
</div>
</li>
</ul>
<h3 id="test-each" tabindex="-1">test.each </h3>
<ul>
<li><p><strong>Type:</strong> <code>(cases: ReadonlyArray&lt;T&gt;) =&gt; void</code></p></li>
<li>
<p><strong>Alias:</strong> <code>it.each</code></p>
<p>Use <code>test.each</code> when you need to run the same test with different variables. You can inject parameters with <a href="https://nodejs.org/api/util.html#util_util_format_format_args" target="_blank" rel="noreferrer">printf formatting</a> in the test name in the order of the test function parameters.</p>
<ul>
<li>
<code>%s</code>: string</li>
<li>
<code>%d</code>: number</li>
<li>
<code>%i</code>: integer</li>
<li>
<code>%f</code>: floating point value</li>
<li>
<code>%j</code>: json</li>
<li>
<code>%o</code>: object</li>
<li>
<code>%#</code>: index of the test case</li>
<li>
<code>%%</code>: single percent sign ('%')</li>
</ul>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">test.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('add(%i, %i) -&gt; %i', (a, b, expected) =&gt; {
  expect(a + b).toBe(expected)
})

// this will return
// ✓ add(1, 1) -&gt; 2
// ✓ add(1, 2) -&gt; 3
// ✓ add(2, 1) -&gt; 3</pre>
<pre class="vp-code-light" data-language="javascript">test.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('add(%i, %i) -&gt; %i', (a, b, expected) =&gt; {
  expect(a + b).toBe(expected)
})

// this will return
// ✓ add(1, 1) -&gt; 2
// ✓ add(1, 2) -&gt; 3
// ✓ add(2, 1) -&gt; 3</pre>
</div>
<p>If you want to have access to <code>TestContext</code>, use <code>describe.each</code> with a single test.</p>
</li>
</ul>
<h2 id="bench" tabindex="-1">bench </h2>
<ul><li>
<strong>Type:</strong> <code>(name: string, fn: BenchFunction, options?: BenchOptions) =&gt; void</code>
</li></ul>
<p><code>bench</code> defines a benchmark. In Vitest terms benchmark is a function that defines a series of operations. Vitest runs this function multiple times to display different performance results.</p>
<p>Vitest uses <a href="https://github.com/tinylibs/tinybench" target="_blank" rel="noreferrer"><code>tinybench</code></a> library under the hood, inheriting all its options that can be used as a third argument.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { bench } from 'vitest'

bench('normal sorting', () =&gt; {
  const x = [1, 5, 4, 2, 3]
  x.sort((a, b) =&gt; {
    return a - b
  })
}, { time: 1000 })</pre>
<pre class="vp-code-light" data-language="javascript">import { bench } from 'vitest'

bench('normal sorting', () =&gt; {
  const x = [1, 5, 4, 2, 3]
  x.sort((a, b) =&gt; {
    return a - b
  })
}, { time: 1000 })</pre>
</div>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">export interface Options {
  /**
   * time needed for running a benchmark task (milliseconds)
   * @default 500
   */
  time?: number

  /**
   * number of times that a task should run if even the time option is finished
   * @default 10
   */
  iterations?: number

  /**
   * function to get the current timestamp in milliseconds
   */
  now?: () =&gt; number

  /**
   * An AbortSignal for aborting the benchmark
   */
  signal?: AbortSignal

  /**
   * warmup time (milliseconds)
   * @default 100ms
   */
  warmupTime?: number

  /**
   * warmup iterations
   * @default 5
   */
  warmupIterations?: number

  /**
   * setup function to run before each benchmark task (cycle)
   */
  setup?: Hook

  /**
   * teardown function to run after each benchmark task (cycle)
   */
  teardown?: Hook
}</pre>
<pre class="vp-code-light" data-language="javascript">export interface Options {
  /**
   * time needed for running a benchmark task (milliseconds)
   * @default 500
   */
  time?: number

  /**
   * number of times that a task should run if even the time option is finished
   * @default 10
   */
  iterations?: number

  /**
   * function to get the current timestamp in milliseconds
   */
  now?: () =&gt; number

  /**
   * An AbortSignal for aborting the benchmark
   */
  signal?: AbortSignal

  /**
   * warmup time (milliseconds)
   * @default 100ms
   */
  warmupTime?: number

  /**
   * warmup iterations
   * @default 5
   */
  warmupIterations?: number

  /**
   * setup function to run before each benchmark task (cycle)
   */
  setup?: Hook

  /**
   * teardown function to run after each benchmark task (cycle)
   */
  teardown?: Hook
}</pre>
</div>
<h3 id="bench-skip" tabindex="-1">bench.skip </h3>
<ul><li>
<strong>Type:</strong> <code>(name: string, fn: BenchFunction, options?: BenchOptions) =&gt; void</code>
</li></ul>
<p>You can use <code>bench.skip</code> syntax to skip running certain benchmarks.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { bench } from 'vitest'

bench.skip('normal sorting', () =&gt; {
  const x = [1, 5, 4, 2, 3]
  x.sort((a, b) =&gt; {
    return a - b
  })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { bench } from 'vitest'

bench.skip('normal sorting', () =&gt; {
  const x = [1, 5, 4, 2, 3]
  x.sort((a, b) =&gt; {
    return a - b
  })
})</pre>
</div>
<h3 id="bench-only" tabindex="-1">bench.only </h3>
<ul><li>
<strong>Type:</strong> <code>(name: string, fn: BenchFunction, options?: BenchOptions) =&gt; void</code>
</li></ul>
<p>Use <code>bench.only</code> to only run certain benchmarks in a given suite. This is useful when debugging.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { bench } from 'vitest'

bench.only('normal sorting', () =&gt; {
  const x = [1, 5, 4, 2, 3]
  x.sort((a, b) =&gt; {
    return a - b
  })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { bench } from 'vitest'

bench.only('normal sorting', () =&gt; {
  const x = [1, 5, 4, 2, 3]
  x.sort((a, b) =&gt; {
    return a - b
  })
})</pre>
</div>
<h3 id="bench-todo" tabindex="-1">bench.todo </h3>
<ul><li>
<strong>Type:</strong> <code>(name: string) =&gt; void</code>
</li></ul>
<p>Use <code>bench.todo</code> to stub benchmarks to be implemented later.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { bench } from 'vitest'

bench.todo('unimplemented test')</pre>
<pre class="vp-code-light" data-language="javascript">import { bench } from 'vitest'

bench.todo('unimplemented test')</pre>
</div>
<h2 id="describe" tabindex="-1">describe </h2>
<p>When you use <code>test</code> or <code>bench</code> in the top level of file, they are collected as part of the implicit suite for it. Using <code>describe</code> you can define a new suite in the current context, as a set of related tests or benchmarks and other nested suites. A suite lets you organize your tests and benchmarks so reports are more clear.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">// basic.spec.ts
// organizing tests

import { describe, expect, test } from 'vitest'

const person = {
  isActive: true,
  age: 32,
}

describe('person', () =&gt; {
  test('person is defined', () =&gt; {
    expect(person).toBeDefined()
  })

  test('is active', () =&gt; {
    expect(person.isActive).toBeTruthy()
  })

  test('age limit', () =&gt; {
    expect(person.age).toBeLessThanOrEqual(32)
  })
})</pre>
<pre class="vp-code-light" data-language="javascript">// basic.spec.ts
// organizing tests

import { describe, expect, test } from 'vitest'

const person = {
  isActive: true,
  age: 32,
}

describe('person', () =&gt; {
  test('person is defined', () =&gt; {
    expect(person).toBeDefined()
  })

  test('is active', () =&gt; {
    expect(person.isActive).toBeTruthy()
  })

  test('age limit', () =&gt; {
    expect(person.age).toBeLessThanOrEqual(32)
  })
})</pre>
</div>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">// basic.bench.ts
// organizing benchmarks

import { bench, describe } from 'vitest'

describe('sort', () =&gt; {
  bench('normal', () =&gt; {
    const x = [1, 5, 4, 2, 3]
    x.sort((a, b) =&gt; {
      return a - b
    })
  })

  bench('reverse', () =&gt; {
    const x = [1, 5, 4, 2, 3]
    x.reverse().sort((a, b) =&gt; {
      return a - b
    })
  })
})</pre>
<pre class="vp-code-light" data-language="javascript">// basic.bench.ts
// organizing benchmarks

import { bench, describe } from 'vitest'

describe('sort', () =&gt; {
  bench('normal', () =&gt; {
    const x = [1, 5, 4, 2, 3]
    x.sort((a, b) =&gt; {
      return a - b
    })
  })

  bench('reverse', () =&gt; {
    const x = [1, 5, 4, 2, 3]
    x.reverse().sort((a, b) =&gt; {
      return a - b
    })
  })
})</pre>
</div>
<p>You can also nest describe blocks if you have a hierarchy of tests or benchmarks:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { describe, expect, test } from 'vitest'

const numberToCurrency = (value) =&gt; {
  if (typeof value !== 'number')
    throw new Error('Value must be a number')

  return value.toFixed(2).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')
}

describe('numberToCurrency', () =&gt; {
  describe('given an invalid number', () =&gt; {
    test('composed of non-numbers to throw error', () =&gt; {
      expect(() =&gt; numberToCurrency('abc')).toThrow()
    })
  })

  describe('given a valid number', () =&gt; {
    test('returns the correct currency format', () =&gt; {
      expect(numberToCurrency(10000)).toBe('10,000.00')
    })
  })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { describe, expect, test } from 'vitest'

const numberToCurrency = (value) =&gt; {
  if (typeof value !== 'number')
    throw new Error('Value must be a number')

  return value.toFixed(2).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')
}

describe('numberToCurrency', () =&gt; {
  describe('given an invalid number', () =&gt; {
    test('composed of non-numbers to throw error', () =&gt; {
      expect(() =&gt; numberToCurrency('abc')).toThrow()
    })
  })

  describe('given a valid number', () =&gt; {
    test('returns the correct currency format', () =&gt; {
      expect(numberToCurrency(10000)).toBe('10,000.00')
    })
  })
})</pre>
</div>
<h3 id="describe-skip" tabindex="-1">describe.skip </h3>
<ul><li>
<p><strong>Type:</strong> <code>(name: string, fn: TestFunction, options?: number | TestOptions) =&gt; void</code></p>
<p>Use <code>describe.skip</code> in a suite to avoid running a particular describe block.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { assert, describe, test } from 'vitest'

describe.skip('skipped suite', () =&gt; {
  test('sqrt', () =&gt; {
    // Suite skipped, no error
    assert.equal(Math.sqrt(4), 3)
  })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { assert, describe, test } from 'vitest'

describe.skip('skipped suite', () =&gt; {
  test('sqrt', () =&gt; {
    // Suite skipped, no error
    assert.equal(Math.sqrt(4), 3)
  })
})</pre>
</div>
</li></ul>
<h3 id="describe-only" tabindex="-1">describe.only </h3>
<ul><li>
<p><strong>Type:</strong> <code>(name: string, fn: TestFunction, options?: number | TestOptions) =&gt; void</code></p>
<p>Use <code>describe.only</code> to only run certain suites</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">// Only this suite (and others marked with only) are run
describe.only('suite', () =&gt; {
  test('sqrt', () =&gt; {
    assert.equal(Math.sqrt(4), 3)
  })
})

describe('other suite', () =&gt; {
  // ... will be skipped
})</pre>
<pre class="vp-code-light" data-language="javascript">// Only this suite (and others marked with only) are run
describe.only('suite', () =&gt; {
  test('sqrt', () =&gt; {
    assert.equal(Math.sqrt(4), 3)
  })
})

describe('other suite', () =&gt; {
  // ... will be skipped
})</pre>
</div>
<p>Sometimes it is very useful to run <code>only</code> tests in a certain file, ignoring all other tests from the whole test suite, which pollute the output.</p>
<p>In order to do that run <code>vitest</code> with specific file containing the tests in question.</p>
<div class="language-">
<pre class="vp-code-dark" data-language="javascript"># vitest interesting.test.ts</pre>
<pre class="vp-code-light" data-language="javascript"># vitest interesting.test.ts</pre>
</div>
</li></ul>
<h3 id="describe-concurrent" tabindex="-1">describe.concurrent </h3>
<ul><li>
<p><strong>Type:</strong> <code>(name: string, fn: TestFunction, options?: number | TestOptions) =&gt; void</code></p>
<p><code>describe.concurrent</code> in a suite marks every tests as concurrent</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">// All tests within this suite will be run in parallel
describe.concurrent('suite', () =&gt; {
  test('concurrent test 1', async () =&gt; { /* ... */ })
  test('concurrent test 2', async () =&gt; { /* ... */ })
  test.concurrent('concurrent test 3', async () =&gt; { /* ... */ })
})</pre>
<pre class="vp-code-light" data-language="javascript">// All tests within this suite will be run in parallel
describe.concurrent('suite', () =&gt; {
  test('concurrent test 1', async () =&gt; { /* ... */ })
  test('concurrent test 2', async () =&gt; { /* ... */ })
  test.concurrent('concurrent test 3', async () =&gt; { /* ... */ })
})</pre>
</div>
<p><code>.skip</code>, <code>.only</code>, and <code>.todo</code> works with concurrent suites. All the following combinations are valid:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">describe.concurrent(/* ... */)
describe.skip.concurrent(/* ... */) // or describe.concurrent.skip(/* ... */)
describe.only.concurrent(/* ... */) // or describe.concurrent.only(/* ... */)
describe.todo.concurrent(/* ... */) // or describe.concurrent.todo(/* ... */)</pre>
<pre class="vp-code-light" data-language="javascript">describe.concurrent(/* ... */)
describe.skip.concurrent(/* ... */) // or describe.concurrent.skip(/* ... */)
describe.only.concurrent(/* ... */) // or describe.concurrent.only(/* ... */)
describe.todo.concurrent(/* ... */) // or describe.concurrent.todo(/* ... */)</pre>
</div>
</li></ul>
<h3 id="describe-shuffle" tabindex="-1">describe.shuffle </h3>
<ul><li>
<p><strong>Type:</strong> <code>(name: string, fn: TestFunction, options?: number | TestOptions) =&gt; void</code></p>
<p>Vitest provides a way to run all tests in random order via CLI flag <a href="../guide/cli"><code>--sequence.shuffle</code></a> or config option <a href="../config/index#sequence-shuffle"><code>sequence.shuffle</code></a>, but if you want to have only part of your test suite to run tests in random order, you can mark it with this flag.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">describe.shuffle('suite', () =&gt; {
  test('random test 1', async () =&gt; { /* ... */ })
  test('random test 2', async () =&gt; { /* ... */ })
  test('random test 3', async () =&gt; { /* ... */ })
})
// order depends on sequence.seed option in config (Date.now() by default)</pre>
<pre class="vp-code-light" data-language="javascript">describe.shuffle('suite', () =&gt; {
  test('random test 1', async () =&gt; { /* ... */ })
  test('random test 2', async () =&gt; { /* ... */ })
  test('random test 3', async () =&gt; { /* ... */ })
})
// order depends on sequence.seed option in config (Date.now() by default)</pre>
</div>
</li></ul>
<p><code>.skip</code>, <code>.only</code>, and <code>.todo</code> works with random suites.</p>
<h3 id="describe-todo" tabindex="-1">describe.todo </h3>
<ul><li>
<p><strong>Type:</strong> <code>(name: string) =&gt; void</code></p>
<p>Use <code>describe.todo</code> to stub suites to be implemented later. An entry will be shown in the report for the tests so you know how many tests you still need to implement.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">// An entry will be shown in the report for this suite
describe.todo('unimplemented suite')</pre>
<pre class="vp-code-light" data-language="javascript">// An entry will be shown in the report for this suite
describe.todo('unimplemented suite')</pre>
</div>
</li></ul>
<h3 id="describe-each" tabindex="-1">describe.each </h3>
<ul><li>
<p><strong>Type:</strong> <code>(cases: ReadonlyArray&lt;T&gt;): (name: string, fn: (...args: T[]) =&gt; void, options?: number | TestOptions) =&gt; void</code></p>
<p>Use <code>describe.each</code> if you have more than one test that depends on the same data.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">describe.each([
  { a: 1, b: 1, expected: 2 },
  { a: 1, b: 2, expected: 3 },
  { a: 2, b: 1, expected: 3 },
])('describe object add($a, $b)', ({ a, b, expected }) =&gt; {
  test(`returns ${expected}`, () =&gt; {
    expect(a + b).toBe(expected)
  })

  test(`returned value not be greater than ${expected}`, () =&gt; {
    expect(a + b).not.toBeGreaterThan(expected)
  })

  test(`returned value not be less than ${expected}`, () =&gt; {
    expect(a + b).not.toBeLessThan(expected)
  })
})</pre>
<pre class="vp-code-light" data-language="javascript">describe.each([
  { a: 1, b: 1, expected: 2 },
  { a: 1, b: 2, expected: 3 },
  { a: 2, b: 1, expected: 3 },
])('describe object add($a, $b)', ({ a, b, expected }) =&gt; {
  test(`returns ${expected}`, () =&gt; {
    expect(a + b).toBe(expected)
  })

  test(`returned value not be greater than ${expected}`, () =&gt; {
    expect(a + b).not.toBeGreaterThan(expected)
  })

  test(`returned value not be less than ${expected}`, () =&gt; {
    expect(a + b).not.toBeLessThan(expected)
  })
})</pre>
</div>
</li></ul>
<h2 id="expect" tabindex="-1">expect </h2>
<ul><li>
<p><strong>Type:</strong> <code>ExpectStatic &amp; (actual: any) =&gt; Assertions</code></p>
<p><code>expect</code> is used to create assertions. In this context <code>assertions</code> are functions that can be called to assert a statement. Vitest provides <code>chai</code> assertions by default and also <code>Jest</code> compatible assertions build on top of <code>chai</code>.</p>
<p>For example, this code asserts that an <code>input</code> value is equal to <code>2</code>. If it's not, assertion will throw an error, and the test will fail.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect } from 'vitest'

const input = Math.sqrt(4)

expect(input).to.equal(2) // chai API
expect(input).toBe(2) // jest API</pre>
<pre class="vp-code-light" data-language="javascript">import { expect } from 'vitest'

const input = Math.sqrt(4)

expect(input).to.equal(2) // chai API
expect(input).toBe(2) // jest API</pre>
</div>
<p>Technically this example doesn't use <a href="#test"><code>test</code></a> function, so in the console you will see Nodejs error instead of Vitest output. To learn more about <code>test</code>, please read <a href="#test">next chapter</a>.</p>
<p>Also, <code>expect</code> can be used statically to access matchers functions, described later, and more.</p>
</li></ul>
<h3 id="not" tabindex="-1">not </h3>
<p>Using <code>not</code> will negate the assertion. For example, this code asserts that an <code>input</code> value is not equal to <code>2</code>. If it's equal, assertion will throw an error, and the test will fail.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

const input = Math.sqrt(16)

expect(input).not.to.equal(2) // chai API
expect(input).not.toBe(2) // jest API</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

const input = Math.sqrt(16)

expect(input).not.to.equal(2) // chai API
expect(input).not.toBe(2) // jest API</pre>
</div>
<h3 id="tobe" tabindex="-1">toBe </h3>
<ul><li>
<p><strong>Type:</strong> <code>(value: any) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toBe</code> can be used to assert if primitives are equal or that objects share the same reference. It is equivalent of calling <code>expect(Object.is(3, 3)).toBe(true)</code>. If the objects are not the same, but you want check if their structures are identical, you can use <a href="#toequal"><code>toEqual</code></a>.</p>
<p>For example, the code below checks if the trader has 13 apples.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

const stock = {
  type: 'apples',
  count: 13,
}

test('stock has 13 apples', () =&gt; {
  expect(stock.type).toBe('apples')
  expect(stock.count).toBe(13)
})

test('stocks are the same', () =&gt; {
  const refStock = stock // same reference

  expect(stock).toBe(refStock)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

const stock = {
  type: 'apples',
  count: 13,
}

test('stock has 13 apples', () =&gt; {
  expect(stock.type).toBe('apples')
  expect(stock.count).toBe(13)
})

test('stocks are the same', () =&gt; {
  const refStock = stock // same reference

  expect(stock).toBe(refStock)
})</pre>
</div>
<p>Try not to use <code>toBe</code> with floating-point numbers. Since JavaScript rounds them, <code>0.1 + 0.2</code> is not strictly <code>0.3</code>. To reliably assert floating-point numbers, use <a href="#tobecloseto"><code>toBeCloseTo</code></a> assertion.</p>
</li></ul>
<h3 id="tobecloseto" tabindex="-1">toBeCloseTo </h3>
<ul><li>
<p><strong>Type:</strong> <code>(value: number, numDigits?: number) =&gt; Awaitable&lt;void&gt;</code></p>
<p>Use <code>toBeCloseTo</code> to compare floating-point numbers. The optional <code>numDigits</code> argument limits the number of digits to check <em>after</em> the decimal point. For example:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test.fails('decimals are not equal in javascript', () =&gt; {
  expect(0.2 + 0.1).toBe(0.3) // 0.2 + 0.1 is 0.30000000000000004
})

test('decimals are rounded to 5 after the point', () =&gt; {
  // 0.2 + 0.1 is 0.30000 | "000000000004" removed
  expect(0.2 + 0.1).toBeCloseTo(0.3, 5)
  // nothing from 0.30000000000000004 is removed
  expect(0.2 + 0.1).not.toBeCloseTo(0.3, 50)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test.fails('decimals are not equal in javascript', () =&gt; {
  expect(0.2 + 0.1).toBe(0.3) // 0.2 + 0.1 is 0.30000000000000004
})

test('decimals are rounded to 5 after the point', () =&gt; {
  // 0.2 + 0.1 is 0.30000 | "000000000004" removed
  expect(0.2 + 0.1).toBeCloseTo(0.3, 5)
  // nothing from 0.30000000000000004 is removed
  expect(0.2 + 0.1).not.toBeCloseTo(0.3, 50)
})</pre>
</div>
</li></ul>
<h3 id="tobedefined" tabindex="-1">toBeDefined </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toBeDefined</code> asserts that the value is not equal to <code>undefined</code>. Useful use case would be to check if function <em>returned</em> anything.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

const getApples = () =&gt; 3

test('function returned something', () =&gt; {
  expect(getApples()).toBeDefined()
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

const getApples = () =&gt; 3

test('function returned something', () =&gt; {
  expect(getApples()).toBeDefined()
})</pre>
</div>
</li></ul>
<h3 id="tobeundefined" tabindex="-1">toBeUndefined </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code></p>
<p>Opposite of <code>toBeDefined</code>, <code>toBeUndefined</code> asserts that the value <em>is</em> equal to <code>undefined</code>. Useful use case would be to check if function hasn't <em>returned</em> anything.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

function getApplesFromStock(stock) {
  if (stock === 'Bill')
    return 13
}

test('mary doesn\'t have a stock', () =&gt; {
  expect(getApplesFromStock('Mary')).toBeUndefined()
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

function getApplesFromStock(stock) {
  if (stock === 'Bill')
    return 13
}

test('mary doesn\'t have a stock', () =&gt; {
  expect(getApplesFromStock('Mary')).toBeUndefined()
})</pre>
</div>
</li></ul>
<h3 id="tobetruthy" tabindex="-1">toBeTruthy </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toBeTruthy</code> asserts that the value is true, when converted to boolean. Useful if you don't care for the value, but just want to know it can be converted to <code>true</code>.</p>
<p>For example having this code you don't care for the return value of <code>stocks.getInfo</code> - it maybe complex object, a string or anything else. The code will still work.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { Stocks } from './stocks'
const stocks = new Stocks()
stocks.sync('Bill')
if (stocks.getInfo('Bill'))
  stocks.sell('apples', 'Bill')</pre>
<pre class="vp-code-light" data-language="javascript">import { Stocks } from './stocks'
const stocks = new Stocks()
stocks.sync('Bill')
if (stocks.getInfo('Bill'))
  stocks.sell('apples', 'Bill')</pre>
</div>
<p>So if you want to test that <code>stocks.getInfo</code> will be truthy, you could write:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'
import { Stocks } from './stocks'
const stocks = new Stocks()

test('if we know Bill stock, sell apples to him', () =&gt; {
  stocks.sync('Bill')
  expect(stocks.getInfo('Bill')).toBeTruthy()
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'
import { Stocks } from './stocks'
const stocks = new Stocks()

test('if we know Bill stock, sell apples to him', () =&gt; {
  stocks.sync('Bill')
  expect(stocks.getInfo('Bill')).toBeTruthy()
})</pre>
</div>
<p>Everything in JavaScript is truthy, except <code>false</code>, <code>0</code>, <code>''</code>, <code>null</code>, <code>undefined</code>, and <code>NaN</code>.</p>
</li></ul>
<h3 id="tobefalsy" tabindex="-1">toBeFalsy </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toBeFalsy</code> asserts that the value is false, when converted to boolean. Useful if you don't care for the value, but just want to know it can be converted to <code>false</code>.</p>
<p>For example having this code you don't care for the return value of <code>stocks.stockFailed</code> - it may return any falsy value, but the code will still work.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { Stocks } from './stocks'
const stocks = new Stocks()
stocks.sync('Bill')
if (!stocks.stockFailed('Bill'))
  stocks.sell('apples', 'Bill')</pre>
<pre class="vp-code-light" data-language="javascript">import { Stocks } from './stocks'
const stocks = new Stocks()
stocks.sync('Bill')
if (!stocks.stockFailed('Bill'))
  stocks.sell('apples', 'Bill')</pre>
</div>
<p>So if you want to test that <code>stocks.stockFailed</code> will be falsy, you could write:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'
import { Stocks } from './stocks'
const stocks = new Stocks()

test('if Bill stock hasn\'t failed, sell apples to him', () =&gt; {
  stocks.syncStocks('Bill')
  expect(stocks.stockFailed('Bill')).toBeFalsy()
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'
import { Stocks } from './stocks'
const stocks = new Stocks()

test('if Bill stock hasn\'t failed, sell apples to him', () =&gt; {
  stocks.syncStocks('Bill')
  expect(stocks.stockFailed('Bill')).toBeFalsy()
})</pre>
</div>
<p>Everything in JavaScript is truthy, except <code>false</code>, <code>0</code>, <code>''</code>, <code>null</code>, <code>undefined</code>, and <code>NaN</code>.</p>
</li></ul>
<h3 id="tobenull" tabindex="-1">toBeNull </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toBeNull</code> simply asserts if something is <code>null</code>. Alias for <code>.toBe(null)</code>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

function apples() {
  return null
}

test('we don\'t have apples', () =&gt; {
  expect(apples()).toBeNull()
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

function apples() {
  return null
}

test('we don\'t have apples', () =&gt; {
  expect(apples()).toBeNull()
})</pre>
</div>
</li></ul>
<h3 id="tobenan" tabindex="-1">toBeNaN </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toBeNaN</code> simply asserts if something is <code>NaN</code>. Alias for <code>.toBe(NaN)</code>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

let i = 0

function getApplesCount() {
  i++
  return i &gt; 1 ? NaN : i
}

test('getApplesCount has some unusual side effects...', () =&gt; {
  expect(getApplesCount()).not.toBeNaN()
  expect(getApplesCount()).toBeNaN()
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

let i = 0

function getApplesCount() {
  i++
  return i &gt; 1 ? NaN : i
}

test('getApplesCount has some unusual side effects...', () =&gt; {
  expect(getApplesCount()).not.toBeNaN()
  expect(getApplesCount()).toBeNaN()
})</pre>
</div>
</li></ul>
<h3 id="tobetypeof" tabindex="-1">toBeTypeOf </h3>
<ul><li>
<p><strong>Type:</strong> <code>(c: 'bigint' | 'boolean' | 'function' | 'number' | 'object' | 'string' | 'symbol' | 'undefined') =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toBeTypeOf</code> asserts if an actual value is of type of received type.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'
const actual = 'stock'

test('stock is type of string', () =&gt; {
  expect(actual).toBeTypeOf('string')
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'
const actual = 'stock'

test('stock is type of string', () =&gt; {
  expect(actual).toBeTypeOf('string')
})</pre>
</div>
</li></ul>
<h3 id="tobeinstanceof" tabindex="-1">toBeInstanceOf </h3>
<ul><li>
<p><strong>Type:</strong> <code>(c: any) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toBeInstanceOf</code> asserts if an actual value is instance of received class.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'
import { Stocks } from './stocks'
const stocks = new Stocks()

test('stocks are instance of Stocks', () =&gt; {
  expect(stocks).toBeInstanceOf(Stocks)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'
import { Stocks } from './stocks'
const stocks = new Stocks()

test('stocks are instance of Stocks', () =&gt; {
  expect(stocks).toBeInstanceOf(Stocks)
})</pre>
</div>
</li></ul>
<h3 id="tobegreaterthan" tabindex="-1">toBeGreaterThan </h3>
<ul><li>
<p><strong>Type:</strong> <code>(n: number | bigint) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toBeGreaterThan</code> asserts if actual value is greater than received one. Equal values will fail the test.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'
import { getApples } from './stock'

test('have more then 10 apples', () =&gt; {
  expect(getApples()).toBeGreaterThan(10)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'
import { getApples } from './stock'

test('have more then 10 apples', () =&gt; {
  expect(getApples()).toBeGreaterThan(10)
})</pre>
</div>
</li></ul>
<h3 id="tobegreaterthanorequal" tabindex="-1">toBeGreaterThanOrEqual </h3>
<ul><li>
<p><strong>Type:</strong> <code>(n: number | bigint) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toBeGreaterThanOrEqual</code> asserts if actual value is greater than received one or equal to it.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'
import { getApples } from './stock'

test('have 11 apples or more', () =&gt; {
  expect(getApples()).toBeGreaterThanOrEqual(11)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'
import { getApples } from './stock'

test('have 11 apples or more', () =&gt; {
  expect(getApples()).toBeGreaterThanOrEqual(11)
})</pre>
</div>
</li></ul>
<h3 id="tobelessthan" tabindex="-1">toBeLessThan </h3>
<ul><li>
<p><strong>Type:</strong> <code>(n: number | bigint) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toBeLessThan</code> asserts if actual value is less than received one. Equal values will fail the test.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'
import { getApples } from './stock'

test('have less then 20 apples', () =&gt; {
  expect(getApples()).toBeLessThan(20)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'
import { getApples } from './stock'

test('have less then 20 apples', () =&gt; {
  expect(getApples()).toBeLessThan(20)
})</pre>
</div>
</li></ul>
<h3 id="tobelessthanorequal" tabindex="-1">toBeLessThanOrEqual </h3>
<ul><li>
<p><strong>Type:</strong> <code>(n: number | bigint) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toBeLessThanOrEqual</code> asserts if actual value is less than received one or equal to it.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'
import { getApples } from './stock'

test('have 11 apples or less', () =&gt; {
  expect(getApples()).toBeLessThanOrEqual(11)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'
import { getApples } from './stock'

test('have 11 apples or less', () =&gt; {
  expect(getApples()).toBeLessThanOrEqual(11)
})</pre>
</div>
</li></ul>
<h3 id="toequal" tabindex="-1">toEqual </h3>
<ul><li>
<p><strong>Type:</strong> <code>(received: any) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toEqual</code> asserts if actual value is equal to received one or has the same structure, if it is an object (compares them recursively). You can see the difference between <code>toEqual</code> and <a href="#tobe"><code>toBe</code></a> in this example:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

const stockBill = {
  type: 'apples',
  count: 13,
}

const stockMary = {
  type: 'apples',
  count: 13,
}

test('stocks have the same properties', () =&gt; {
  expect(stockBill).toEqual(stockMary)
})

test('stocks are not the same', () =&gt; {
  expect(stockBill).not.toBe(stockMary)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

const stockBill = {
  type: 'apples',
  count: 13,
}

const stockMary = {
  type: 'apples',
  count: 13,
}

test('stocks have the same properties', () =&gt; {
  expect(stockBill).toEqual(stockMary)
})

test('stocks are not the same', () =&gt; {
  expect(stockBill).not.toBe(stockMary)
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>A <em>deep equality</em> will not be performed for <code>Error</code> objects. To test if something was thrown, use <a href="#tothrow"><code>toThrow</code></a> assertion.</p>
</div>
</li></ul>
<h3 id="tostrictequal" tabindex="-1">toStrictEqual </h3>
<ul><li>
<p><strong>Type:</strong> <code>(received: any) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toStrictEqual</code> asserts if actual value is equal to received one or has the same structure, if it is an object (compares them recursively), and of the same type.</p>
<p>Differences from <a href="#toequal"><code>.toEqual</code></a>:</p>
<ul>
<li>Keys with <code>undefined</code> properties are checked. e.g. <code>{a: undefined, b: 2}</code> does not match <code>{b: 2}</code> when using <code>.toStrictEqual</code>.</li>
<li>Array sparseness is checked. e.g. <code>[, 1]</code> does not match <code>[undefined, 1]</code> when using <code>.toStrictEqual</code>.</li>
<li>Object types are checked to be equal. e.g. A class instance with fields <code>a</code> and<code> b</code> will not equal a literal object with fields <code>a</code> and <code>b</code>.</li>
</ul>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

class Stock {
  constructor(type) {
    this.type = type
  }
}

test('structurally the same, but semantically different', () =&gt; {
  expect(new Stock('apples')).toEqual({ type: 'apples' })
  expect(new Stock('apples')).not.toStrictEqual({ type: 'apples' })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

class Stock {
  constructor(type) {
    this.type = type
  }
}

test('structurally the same, but semantically different', () =&gt; {
  expect(new Stock('apples')).toEqual({ type: 'apples' })
  expect(new Stock('apples')).not.toStrictEqual({ type: 'apples' })
})</pre>
</div>
</li></ul>
<h3 id="tocontain" tabindex="-1">toContain </h3>
<ul><li>
<p><strong>Type:</strong> <code>(received: string) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toContain</code> asserts if actual value is in an array. <code>toContain</code> can also check whether a string is a substring of another string.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'
import { getAllFruits } from './stock'

test('the fruit list contains orange', () =&gt; {
  expect(getAllFruits()).toContain('orange')
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'
import { getAllFruits } from './stock'

test('the fruit list contains orange', () =&gt; {
  expect(getAllFruits()).toContain('orange')
})</pre>
</div>
</li></ul>
<h3 id="tocontainequal" tabindex="-1">toContainEqual </h3>
<ul><li>
<p><strong>Type:</strong> <code>(received: any) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toContainEqual</code> asserts if an item with a specific structure and values is contained in an array. It works like <a href="#toequal"><code>toEqual</code></a> inside for each element.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'
import { getFruitStock } from './stock'

test('apple available', () =&gt; {
  expect(getFruitStock()).toContainEqual({ fruit: 'apple', count: 5 })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'
import { getFruitStock } from './stock'

test('apple available', () =&gt; {
  expect(getFruitStock()).toContainEqual({ fruit: 'apple', count: 5 })
})</pre>
</div>
</li></ul>
<h3 id="tohavelength" tabindex="-1">toHaveLength </h3>
<ul><li>
<p><strong>Type:</strong> <code>(received: number) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toHaveLength</code> asserts if an object has a <code>.length</code> property and it is set to a certain numeric value.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test('toHaveLength', () =&gt; {
  expect('abc').toHaveLength(3)
  expect([1, 2, 3]).toHaveLength(3)

  expect('').not.toHaveLength(3) // doesn't have .length of 3
  expect({ length: 3 }).toHaveLength(3)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test('toHaveLength', () =&gt; {
  expect('abc').toHaveLength(3)
  expect([1, 2, 3]).toHaveLength(3)

  expect('').not.toHaveLength(3) // doesn't have .length of 3
  expect({ length: 3 }).toHaveLength(3)
})</pre>
</div>
</li></ul>
<h3 id="tohaveproperty" tabindex="-1">toHaveProperty </h3>
<ul><li>
<p><strong>Type:</strong> <code>(key: any, received?: any) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toHaveProperty</code> asserts if a property at provided reference <code>key</code> exists for an object.</p>
<p>You can provide an optional value argument also known as deep equality, like the <code>toEqual</code> matcher to compare the received property value.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

const invoice = {
  'isActive': true,
  'P.O': '12345',
  'customer': {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
  'total_amount': 5000,
  'items': [
    {
      type: 'apples',
      quantity: 10,
    },
    {
      type: 'oranges',
      quantity: 5,
    },
  ],
}

test('John Doe Invoice', () =&gt; {
  expect(invoice).toHaveProperty('isActive') // assert that the key exists
  expect(invoice).toHaveProperty('total_amount', 5000) // assert that the key exists and the value is equal

  expect(invoice).not.toHaveProperty('account') // assert that this key does not exist

  // Deep referencing using dot notation
  expect(invoice).toHaveProperty('customer.first_name')
  expect(invoice).toHaveProperty('customer.last_name', 'Doe')
  expect(invoice).not.toHaveProperty('customer.location', 'India')

  // Deep referencing using an array containing the key
  expect(invoice).toHaveProperty('items[0].type', 'apples')
  expect(invoice).toHaveProperty('items.0.type', 'apples') // dot notation also works

  // Wrap your key in an array to avoid the key from being parsed as a deep reference
  expect(invoice).toHaveProperty(['P.O'], '12345')
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

const invoice = {
  'isActive': true,
  'P.O': '12345',
  'customer': {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
  'total_amount': 5000,
  'items': [
    {
      type: 'apples',
      quantity: 10,
    },
    {
      type: 'oranges',
      quantity: 5,
    },
  ],
}

test('John Doe Invoice', () =&gt; {
  expect(invoice).toHaveProperty('isActive') // assert that the key exists
  expect(invoice).toHaveProperty('total_amount', 5000) // assert that the key exists and the value is equal

  expect(invoice).not.toHaveProperty('account') // assert that this key does not exist

  // Deep referencing using dot notation
  expect(invoice).toHaveProperty('customer.first_name')
  expect(invoice).toHaveProperty('customer.last_name', 'Doe')
  expect(invoice).not.toHaveProperty('customer.location', 'India')

  // Deep referencing using an array containing the key
  expect(invoice).toHaveProperty('items[0].type', 'apples')
  expect(invoice).toHaveProperty('items.0.type', 'apples') // dot notation also works

  // Wrap your key in an array to avoid the key from being parsed as a deep reference
  expect(invoice).toHaveProperty(['P.O'], '12345')
})</pre>
</div>
</li></ul>
<h3 id="tomatch" tabindex="-1">toMatch </h3>
<ul><li>
<p><strong>Type:</strong> <code>(received: string | regexp) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toMatch</code> asserts if a string matches a regular expression or a string.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test('top fruits', () =&gt; {
  expect('top fruits include apple, orange and grape').toMatch(/apple/)
  expect('applefruits').toMatch('fruit') // toMatch also accepts a string
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test('top fruits', () =&gt; {
  expect('top fruits include apple, orange and grape').toMatch(/apple/)
  expect('applefruits').toMatch('fruit') // toMatch also accepts a string
})</pre>
</div>
</li></ul>
<h3 id="tomatchobject" tabindex="-1">toMatchObject </h3>
<ul><li>
<p><strong>Type:</strong> <code>(received: object | array) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toMatchObject</code> asserts if an object matches a subset of the properties of an object.</p>
<p>You can also pass an array of objects. This is useful if you want to check that two arrays match in their number of elements, as opposed to <code>arrayContaining</code>, which allows for extra elements in the received array.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

const johnInvoice = {
  isActive: true,
  customer: {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
  total_amount: 5000,
  items: [
    {
      type: 'apples',
      quantity: 10,
    },
    {
      type: 'oranges',
      quantity: 5,
    },
  ],
}

const johnDetails = {
  customer: {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
}

test('invoice has john personal details', () =&gt; {
  expect(johnInvoice).toMatchObject(johnDetails)
})

test('the number of elements must match exactly', () =&gt; {
  // Assert that an array of object matches
  expect([{ foo: 'bar' }, { baz: 1 }]).toMatchObject([
    { foo: 'bar' },
    { baz: 1 },
  ])
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

const johnInvoice = {
  isActive: true,
  customer: {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
  total_amount: 5000,
  items: [
    {
      type: 'apples',
      quantity: 10,
    },
    {
      type: 'oranges',
      quantity: 5,
    },
  ],
}

const johnDetails = {
  customer: {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
}

test('invoice has john personal details', () =&gt; {
  expect(johnInvoice).toMatchObject(johnDetails)
})

test('the number of elements must match exactly', () =&gt; {
  // Assert that an array of object matches
  expect([{ foo: 'bar' }, { baz: 1 }]).toMatchObject([
    { foo: 'bar' },
    { baz: 1 },
  ])
})</pre>
</div>
</li></ul>
<h3 id="tothrowerror" tabindex="-1">toThrowError </h3>
<ul><li>
<p><strong>Type:</strong> <code>(received: any) =&gt; Awaitable&lt;void&gt;</code></p>
<p><code>toThrowError</code> asserts if a function throws an error when it is called.</p>
<p>For example, if we want to test that <code>getFruitStock('pineapples')</code> throws, we could write:</p>
<p>You can provide an optional argument to test that a specific error is thrown:</p>
<ul>
<li>regular expression: error message matches the pattern</li>
<li>string: error message includes the substring</li>
</ul>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>You must wrap the code in a function, otherwise the error will not be caught, and the assertion will fail.</p>
</div>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

function getFruitStock(type) {
  if (type === 'pineapples')
    throw new DiabetesError('Pineapples is not good for people with diabetes')

  // Do some other stuff
}

test('throws on pineapples', () =&gt; {
  // Test that the error message says "diabetes" somewhere: these are equivalent
  expect(() =&gt; getFruitStock('pineapples')).toThrowError(/diabetes/)
  expect(() =&gt; getFruitStock('pineapples')).toThrowError('diabetes')

  // Test the exact error message
  expect(() =&gt; getFruitStock('pineapples')).toThrowError(
    /^Pineapples is not good for people with diabetes$/,
  )
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

function getFruitStock(type) {
  if (type === 'pineapples')
    throw new DiabetesError('Pineapples is not good for people with diabetes')

  // Do some other stuff
}

test('throws on pineapples', () =&gt; {
  // Test that the error message says "diabetes" somewhere: these are equivalent
  expect(() =&gt; getFruitStock('pineapples')).toThrowError(/diabetes/)
  expect(() =&gt; getFruitStock('pineapples')).toThrowError('diabetes')

  // Test the exact error message
  expect(() =&gt; getFruitStock('pineapples')).toThrowError(
    /^Pineapples is not good for people with diabetes$/,
  )
})</pre>
</div>
</li></ul>
<h3 id="tomatchsnapshot" tabindex="-1">toMatchSnapshot </h3>
<ul><li>
<p><strong>Type:</strong> <code>&lt;T&gt;(shape?: Partial&lt;T&gt; | string, message?: string) =&gt; void</code></p>
<p>This ensures that a value matches the most recent snapshot.</p>
<p>You can provide an optional <code>hint</code> string argument that is appended to the test name. Although Vitest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate multiple snapshots in a single it or test block. Vitest sorts snapshots by name in the corresponding <code>.snap</code> file.</p>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>When snapshot mismatch and causing the test failing, if the mismatch is expected, you can press <code>u</code> key to update the snapshot for once. Or you can pass <code>-u</code> or <code>--update</code> CLI options to make Vitest always update the tests.</p>
</div>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test('matches snapshot', () =&gt; {
  const data = { foo: new Set(['bar', 'snapshot']) }
  expect(data).toMatchSnapshot()
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test('matches snapshot', () =&gt; {
  const data = { foo: new Set(['bar', 'snapshot']) }
  expect(data).toMatchSnapshot()
})</pre>
</div>
<p>You can also provide a shape of an object, if you are testing just a shape of an object, and don't need it to be 100% compatible:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test('matches snapshot', () =&gt; {
  const data = { foo: new Set(['bar', 'snapshot']) }
  expect(data).toMatchSnapshot({ foo: expect.any(Set) })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test('matches snapshot', () =&gt; {
  const data = { foo: new Set(['bar', 'snapshot']) }
  expect(data).toMatchSnapshot({ foo: expect.any(Set) })
})</pre>
</div>
</li></ul>
<h3 id="tomatchinlinesnapshot" tabindex="-1">toMatchInlineSnapshot </h3>
<ul><li>
<p><strong>Type:</strong> <code>&lt;T&gt;(shape?: Partial&lt;T&gt; | string, snapshot?: string, message?: string) =&gt; void</code></p>
<p>This ensures that a value matches the most recent snapshot.</p>
<p>Vitest adds and updates the inlineSnapshot string argument to the matcher in the test file (instead of an external <code>.snap</code> file).</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test('matches inline snapshot', () =&gt; {
  const data = { foo: new Set(['bar', 'snapshot']) }
  // Vitest will update following content when updating the snapshot
  expect(data).toMatchInlineSnapshot(`
    {
      "foo": Set {
        "bar",
        "snapshot",
      },
    }
  `)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test('matches inline snapshot', () =&gt; {
  const data = { foo: new Set(['bar', 'snapshot']) }
  // Vitest will update following content when updating the snapshot
  expect(data).toMatchInlineSnapshot(`
    {
      "foo": Set {
        "bar",
        "snapshot",
      },
    }
  `)
})</pre>
</div>
<p>You can also provide a shape of an object, if you are testing just a shape of an object, and don't need it to be 100% compatible:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test('matches snapshot', () =&gt; {
  const data = { foo: new Set(['bar', 'snapshot']) }
  expect(data).toMatchInlineSnapshot(
    { foo: expect.any(Set) },
    `
    {
      "foo": Any&lt;Set&gt;,
    }
  `
  )
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test('matches snapshot', () =&gt; {
  const data = { foo: new Set(['bar', 'snapshot']) }
  expect(data).toMatchInlineSnapshot(
    { foo: expect.any(Set) },
    `
    {
      "foo": Any&lt;Set&gt;,
    }
  `
  )
})</pre>
</div>
</li></ul>
<h3 id="tothrowerrormatchingsnapshot" tabindex="-1">toThrowErrorMatchingSnapshot </h3>
<ul><li>
<p><strong>Type:</strong> <code>(message?: string) =&gt; void</code></p>
<p>The same as <a href="#tomatchsnapshot"><code>toMatchSnapshot</code></a>, but expects the same value as <a href="#tothrowerror"><code>toThrowError</code></a>.</p>
<p>If the function throws an <code>Error</code>, the snapshot will be the error message. Otherwise, snapshot will be the value thrown by the function.</p>
</li></ul>
<h3 id="tothrowerrormatchinginlinesnapshot" tabindex="-1">toThrowErrorMatchingInlineSnapshot </h3>
<ul><li>
<p><strong>Type:</strong> <code>(snapshot?: string, message?: string) =&gt; void</code></p>
<p>The same as <a href="#tomatchinlinesnapshot"><code>toMatchInlineSnapshot</code></a>, but expects the same value as <a href="#tothrowerror"><code>toThrowError</code></a>.</p>
<p>If the function throws an <code>Error</code>, the snapshot will be the error message. Otherwise, snapshot will be the value thrown by the function.</p>
</li></ul>
<h3 id="tohavebeencalled" tabindex="-1">toHaveBeenCalled </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code></p>
<p>This assertion is useful for testing that a function has been called. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  expect(buySpy).not.toHaveBeenCalled()

  market.buy('apples', 10)

  expect(buySpy).toHaveBeenCalled()
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  expect(buySpy).not.toHaveBeenCalled()

  market.buy('apples', 10)

  expect(buySpy).toHaveBeenCalled()
})</pre>
</div>
</li></ul>
<h3 id="tohavebeencalledtimes" tabindex="-1">toHaveBeenCalledTimes </h3>
<ul><li>
<strong>Type</strong>: <code>(amount: number) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a function was called a certain amount of times. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function called two times', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).toHaveBeenCalledTimes(2)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function called two times', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).toHaveBeenCalledTimes(2)
})</pre>
</div>
<h3 id="tohavebeencalledwith" tabindex="-1">toHaveBeenCalledWith </h3>
<ul><li>
<strong>Type</strong>: <code>(...args: any[]) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a function was called at least once with certain parameters. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).toHaveBeenCalledWith('apples', 10)
  expect(buySpy).toHaveBeenCalledWith('apples', 20)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).toHaveBeenCalledWith('apples', 10)
  expect(buySpy).toHaveBeenCalledWith('apples', 20)
})</pre>
</div>
<h3 id="tohavebeenlastcalledwith" tabindex="-1">toHaveBeenLastCalledWith </h3>
<ul><li>
<strong>Type</strong>: <code>(...args: any[]) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a function was called with certain parameters at it's last invocation. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).not.toHaveBeenLastCalledWith('apples', 10)
  expect(buySpy).toHaveBeenLastCalledWith('apples', 20)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).not.toHaveBeenLastCalledWith('apples', 10)
  expect(buySpy).toHaveBeenLastCalledWith('apples', 20)
})</pre>
</div>
<h3 id="tohavebeennthcalledwith" tabindex="-1">toHaveBeenNthCalledWith </h3>
<ul><li>
<strong>Type</strong>: <code>(time: number, ...args: any[]) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a function was called with certain parameters at the certain time. The count starts at 1. So, to check the second entry, you would write <code>.toHaveBeenNthCalledWith(2, ...)</code>.</p>
<p>Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('first call of spy function called with right params', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).toHaveBeenNthCalledWith(1, 'apples', 10)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('first call of spy function called with right params', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).toHaveBeenNthCalledWith(1, 'apples', 10)
})</pre>
</div>
<h3 id="tohavereturned" tabindex="-1">toHaveReturned </h3>
<ul><li>
<strong>Type</strong>: <code>() =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a function has successfully returned a value at least once (i.e., did not throw an error). Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test, vi } from 'vitest'

const getApplesPrice = (amount: number) =&gt; {
  const PRICE = 10
  return amount * PRICE
}

test('spy function returned a value', () =&gt; {
  const getPriceSpy = vi.fn(getApplesPrice)

  const price = getPriceSpy(10)

  expect(price).toBe(100)
  expect(getPriceSpy).toHaveReturned()
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test, vi } from 'vitest'

const getApplesPrice = (amount: number) =&gt; {
  const PRICE = 10
  return amount * PRICE
}

test('spy function returned a value', () =&gt; {
  const getPriceSpy = vi.fn(getApplesPrice)

  const price = getPriceSpy(10)

  expect(price).toBe(100)
  expect(getPriceSpy).toHaveReturned()
})</pre>
</div>
<h3 id="tohavereturnedtimes" tabindex="-1">toHaveReturnedTimes </h3>
<ul><li>
<strong>Type</strong>: <code>(amount: number) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a function has successfully returned a value exact amount of times (i.e., did not throw an error). Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test, vi } from 'vitest'

test('spy function returns a value two times', () =&gt; {
  const sell = vi.fn((product: string) =&gt; ({ product }))

  sell('apples')
  sell('bananas')

  expect(sell).toHaveReturnedTimes(2)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test, vi } from 'vitest'

test('spy function returns a value two times', () =&gt; {
  const sell = vi.fn((product: string) =&gt; ({ product }))

  sell('apples')
  sell('bananas')

  expect(sell).toHaveReturnedTimes(2)
})</pre>
</div>
<h3 id="tohavereturnedwith" tabindex="-1">toHaveReturnedWith </h3>
<ul><li>
<strong>Type</strong>: <code>(returnValue: any) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>You can call this assertion to check if a function has successfully returned a value with certain parameters at least once. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test, vi } from 'vitest'

test('spy function returns a product', () =&gt; {
  const sell = vi.fn((product: string) =&gt; ({ product }))

  sell('apples')

  expect(sell).toHaveReturnedWith({ product: 'apples' })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test, vi } from 'vitest'

test('spy function returns a product', () =&gt; {
  const sell = vi.fn((product: string) =&gt; ({ product }))

  sell('apples')

  expect(sell).toHaveReturnedWith({ product: 'apples' })
})</pre>
</div>
<h3 id="tohavelastreturnedwith" tabindex="-1">toHaveLastReturnedWith </h3>
<ul><li>
<strong>Type</strong>: <code>(returnValue: any) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>You can call this assertion to check if a function has successfully returned a value with certain parameters on it's last invoking. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test, vi } from 'vitest'

test('spy function returns bananas on a last call', () =&gt; {
  const sell = vi.fn((product: string) =&gt; ({ product }))

  sell('apples')
  sell('bananas')

  expect(sell).toHaveLastReturnedWith({ product: 'bananas' })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test, vi } from 'vitest'

test('spy function returns bananas on a last call', () =&gt; {
  const sell = vi.fn((product: string) =&gt; ({ product }))

  sell('apples')
  sell('bananas')

  expect(sell).toHaveLastReturnedWith({ product: 'bananas' })
})</pre>
</div>
<h3 id="tohaventhreturnedwith" tabindex="-1">toHaveNthReturnedWith </h3>
<ul><li>
<strong>Type</strong>: <code>(time: number, returnValue: any) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>You can call this assertion to check if a function has successfully returned a value with certain parameters on a certain call. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test, vi } from 'vitest'

test('spy function returns bananas on second call', () =&gt; {
  const sell = vi.fn((product: string) =&gt; ({ product }))

  sell('apples')
  sell('bananas')

  expect(sell).toHaveNthReturnedWith(2, { product: 'bananas' })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test, vi } from 'vitest'

test('spy function returns bananas on second call', () =&gt; {
  const sell = vi.fn((product: string) =&gt; ({ product }))

  sell('apples')
  sell('bananas')

  expect(sell).toHaveNthReturnedWith(2, { product: 'bananas' })
})</pre>
</div>
<h3 id="tosatisfy" tabindex="-1">toSatisfy </h3>
<ul><li>
<strong>Type:</strong> <code>(predicate: (value: any) =&gt; boolean) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a value satisfies a certain predicate.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">describe('toSatisfy()', () =&gt; {
  const isOdd = (value: number) =&gt; value % 2 !== 0

  it('pass with 0', () =&gt; {
    expect(1).toSatisfy(isOdd)
  })

  it('pass with negotiation', () =&gt; {
    expect(2).not.toSatisfy(isOdd)
  })
})</pre>
<pre class="vp-code-light" data-language="javascript">describe('toSatisfy()', () =&gt; {
  const isOdd = (value: number) =&gt; value % 2 !== 0

  it('pass with 0', () =&gt; {
    expect(1).toSatisfy(isOdd)
  })

  it('pass with negotiation', () =&gt; {
    expect(2).not.toSatisfy(isOdd)
  })
})</pre>
</div>
<h3 id="resolves" tabindex="-1">resolves </h3>
<ul><li>
<p><strong>Type:</strong> <code>Promisify&lt;Assertions&gt;</code></p>
<p><code>resolves</code> is intended to remove boilerplate when asserting asynchronous code. Use it to unwrap value from the pending promise and assert its value with usual assertions. If the promise rejects, the assertion will fail.</p>
<p>It returns the same <code>Assertions</code> object, but all matchers now return <code>Promise</code>, so you would need to <code>await</code> it. Also works with <code>chai</code> assertions.</p>
<p>For example, if you have a function, that makes an API call and returns some data, you may use this code to assert its return value:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

async function buyApples() {
  return fetch('/buy/apples').then(r =&gt; r.json())
}

test('buyApples returns new stock id', async () =&gt; {
  // toEqual returns a promise now, so you HAVE to await it
  await expect(buyApples()).resolves.toEqual({ id: 1 }) // jest API
  await expect(buyApples()).resolves.to.equal({ id: 1 }) // chai API
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

async function buyApples() {
  return fetch('/buy/apples').then(r =&gt; r.json())
}

test('buyApples returns new stock id', async () =&gt; {
  // toEqual returns a promise now, so you HAVE to await it
  await expect(buyApples()).resolves.toEqual({ id: 1 }) // jest API
  await expect(buyApples()).resolves.to.equal({ id: 1 }) // chai API
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>If the assertion is not awaited, then you will have a false-positive test that will pass every time. To make sure that assertions are actually called, you may use <a href="#expect-assertions"><code>expect.assertions(number)</code></a>.</p>
</div>
</li></ul>
<h3 id="rejects" tabindex="-1">rejects </h3>
<ul><li>
<p><strong>Type:</strong> <code>Promisify&lt;Assertions&gt;</code></p>
<p><code>rejects</code> is intended to remove boilerplate when asserting asynchronous code. Use it to unwrap reason why promise was rejected, and assert its value with usual assertions. If promise successfully resolves, the assertion will fail.</p>
<p>It returns the same <code>Assertions</code> object, but all matchers are now return <code>Promise</code>, so you would need to <code>await</code> it. Also works with <code>chai</code> assertions.</p>
<p>For example, if you have a function that fails when you call it, you may use this code to assert the reason:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

async function buyApples(id) {
  if (!id)
    throw new Error('no id')
}

test('buyApples throws an error when no id provided', async () =&gt; {
  // toThrow returns a promise now, so you HAVE to await it
  await expect(buyApples()).rejects.toThrow('no id')
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

async function buyApples(id) {
  if (!id)
    throw new Error('no id')
}

test('buyApples throws an error when no id provided', async () =&gt; {
  // toThrow returns a promise now, so you HAVE to await it
  await expect(buyApples()).rejects.toThrow('no id')
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>If the assertion is not awaited, then you will have a false-positive test that will pass every time. To make sure that assertions are actually happened, you may use <a href="#expect-assertions"><code>expect.assertions(number)</code></a>.</p>
</div>
</li></ul>
<h3 id="expect-assertions" tabindex="-1">expect.assertions </h3>
<ul><li>
<p><strong>Type:</strong> <code>(count: number) =&gt; void</code></p>
<p>After the test has passed or failed verifies that certain number of assertions was called during a test. Useful case would be to check if an asynchronous code was called.</p>
<p>For example, if we have a function that asynchronously calls two matchers, we can assert that they were actually called.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

async function doAsync(...cbs) {
  await Promise.all(
    cbs.map((cb, index) =&gt; cb({ index })),
  )
}

test('all assertions are called', async () =&gt; {
  expect.assertions(2)
  function callback1(data) {
    expect(data).toBeTruthy()
  }
  function callback2(data) {
    expect(data).toBeTruthy()
  }

  await doAsync(callback1, callback2)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

async function doAsync(...cbs) {
  await Promise.all(
    cbs.map((cb, index) =&gt; cb({ index })),
  )
}

test('all assertions are called', async () =&gt; {
  expect.assertions(2)
  function callback1(data) {
    expect(data).toBeTruthy()
  }
  function callback2(data) {
    expect(data).toBeTruthy()
  }

  await doAsync(callback1, callback2)
})</pre>
</div>
</li></ul>
<h3 id="expect-hasassertions" tabindex="-1">expect.hasAssertions </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; void</code></p>
<p>After the test has passed or failed verifies that at least one assertion was called during a test. Useful case would be to check if an asynchronous code was called.</p>
<p>For example, if you have a code that calls a callback, we can make an assertion inside a callback, but the test will always pass, if we don't check if an assertion was called.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'
import { db } from './db'

const cbs = []

function onSelect(cb) {
  cbs.push(cb)
}

// after selecting from db, we call all callbacks
function select(id) {
  return db.select({ id }).then((data) =&gt; {
    return Promise.all(
      cbs.map(cb =&gt; cb(data)),
    )
  })
}

test('callback was called', async () =&gt; {
  expect.hasAssertions()
  onSelect((data) =&gt; {
    // should be called on select
    expect(data).toBeTruthy()
  })
  // if not awaited, test will fail
  // if you don't have expect.hasAssertions(), test will pass
  await select(3)
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'
import { db } from './db'

const cbs = []

function onSelect(cb) {
  cbs.push(cb)
}

// after selecting from db, we call all callbacks
function select(id) {
  return db.select({ id }).then((data) =&gt; {
    return Promise.all(
      cbs.map(cb =&gt; cb(data)),
    )
  })
}

test('callback was called', async () =&gt; {
  expect.hasAssertions()
  onSelect((data) =&gt; {
    // should be called on select
    expect(data).toBeTruthy()
  })
  // if not awaited, test will fail
  // if you don't have expect.hasAssertions(), test will pass
  await select(3)
})</pre>
</div>
</li></ul>
<h3 id="expect-anything" tabindex="-1">expect.anything </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; any</code></p>
<p>This asymmetric matcher, when used with equality check, will always return <code>true</code>. Useful, if you just want to be sure that the property exist.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test('object has "apples" key', () =&gt; {
  expect({ apples: 22 }).toEqual({ apples: expect.anything() })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test('object has "apples" key', () =&gt; {
  expect({ apples: 22 }).toEqual({ apples: expect.anything() })
})</pre>
</div>
</li></ul>
<h3 id="expect-any" tabindex="-1">expect.any </h3>
<ul><li>
<p><strong>Type:</strong> <code>(constructor: unknown) =&gt; any</code></p>
<p>This asymmetric matcher, when used with equality check, will return <code>true</code> only if value is an instance of specified constructor. Useful, if you have a value that is generated each time, and you only want to know that it exist with a proper type.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'
import { generateId } from './generators'

test('"id" is a number', () =&gt; {
  expect({ id: generateId() }).toEqual({ id: expect.any(Number) })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'
import { generateId } from './generators'

test('"id" is a number', () =&gt; {
  expect({ id: generateId() }).toEqual({ id: expect.any(Number) })
})</pre>
</div>
</li></ul>
<h3 id="expect-arraycontaining" tabindex="-1">expect.arrayContaining </h3>
<ul><li>
<p><strong>Type:</strong> <code>&lt;T&gt;(expected: T[]) =&gt; any</code></p>
<p>When used with equality check, this asymmetric matcher will return <code>true</code> if value is an array and contains specified items.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test('basket includes fuji', () =&gt; {
  const basket = {
    varieties: [
      'Empire',
      'Fuji',
      'Gala',
    ],
    count: 3
  }
  expect(basket).toEqual({
    count: 3,
    varieties: expect.arrayContaining(['Fuji'])
  })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test('basket includes fuji', () =&gt; {
  const basket = {
    varieties: [
      'Empire',
      'Fuji',
      'Gala',
    ],
    count: 3
  }
  expect(basket).toEqual({
    count: 3,
    varieties: expect.arrayContaining(['Fuji'])
  })
})</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>You can use <code>expect.not</code> with this matcher to negate the expected value.</p>
</div>
</li></ul>
<h3 id="expect-objectcontaining" tabindex="-1">expect.objectContaining </h3>
<ul><li>
<p><strong>Type:</strong> <code>(expected: any) =&gt; any</code></p>
<p>When used with equality check, this asymmetric matcher will return <code>true</code> if value has a similar shape.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test('basket has empire apples', () =&gt; {
  const basket = {
    varieties: [
      {
        name: 'Empire',
        count: 1,
      }
    ],
  }
  expect(basket).toEqual({
    varieties: [
      expect.objectContaining({ name: 'Empire' }),
    ]
  })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test('basket has empire apples', () =&gt; {
  const basket = {
    varieties: [
      {
        name: 'Empire',
        count: 1,
      }
    ],
  }
  expect(basket).toEqual({
    varieties: [
      expect.objectContaining({ name: 'Empire' }),
    ]
  })
})</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>You can use <code>expect.not</code> with this matcher to negate the expected value.</p>
</div>
</li></ul>
<h3 id="expect-stringcontaining" tabindex="-1">expect.stringContaining </h3>
<ul><li>
<p><strong>Type:</strong> <code>(expected: any) =&gt; any</code></p>
<p>When used with equality check, this asymmetric matcher will return <code>true</code> if value is a string and contains specified substring.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test('variety has "Emp" in its name', () =&gt; {
  const variety = {
    name: 'Empire',
    count: 1,
  }
  expect(basket).toEqual({
    name: expect.stringContaining('Emp'),
    count: 1,
  })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test('variety has "Emp" in its name', () =&gt; {
  const variety = {
    name: 'Empire',
    count: 1,
  }
  expect(basket).toEqual({
    name: expect.stringContaining('Emp'),
    count: 1,
  })
})</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>You can use <code>expect.not</code> with this matcher to negate the expected value.</p>
</div>
</li></ul>
<h3 id="expect-stringmatching" tabindex="-1">expect.stringMatching </h3>
<ul><li>
<p><strong>Type:</strong> <code>(expected: any) =&gt; any</code></p>
<p>When used with equality check, this asymmetric matcher will return <code>true</code> if value is a string and contains specified substring or the string matches regular expression.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test('variety ends with "re"', () =&gt; {
  const variety = {
    name: 'Empire',
    count: 1,
  }
  expect(basket).toEqual({
    name: expect.stringMatching(/re$/),
    count: 1,
  })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test('variety ends with "re"', () =&gt; {
  const variety = {
    name: 'Empire',
    count: 1,
  }
  expect(basket).toEqual({
    name: expect.stringMatching(/re$/),
    count: 1,
  })
})</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>You can use <code>expect.not</code> with this matcher to negate the expected value.</p>
</div>
</li></ul>
<h3 id="expect-addsnapshotserializer" tabindex="-1">expect.addSnapshotSerializer </h3>
<ul><li>
<p><strong>Type:</strong> <code>(plugin: PrettyFormatPlugin) =&gt; void</code></p>
<p>This method adds custom serializers that are called when creating a snapshot. This is advanced feature - if you want to know more, please read a <a href="../guide/snapshot#custom-serializer">guide on custom serializers</a>.</p>
<p>If you are adding custom serializers, you should call this method inside <a href="../config/index#setupfiles"><code>setupFiles</code></a>. This will affect every snapshot.</p>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>If you previously used Vue CLI with Jest, you might want to install <a href="https://www.npmjs.com/package/jest-serializer-vue" target="_blank" rel="noreferrer">jest-serializer-vue</a>. Otherwise, your snapshots will be wrapped in a string, which cases <code>"</code> to be escaped.</p>
</div>
</li></ul>
<h3 id="expect-extend" tabindex="-1">expect.extend </h3>
<ul><li>
<p><strong>Type:</strong> <code>(matchers: MatchersObject) =&gt; void</code></p>
<p>You can extend default matchers with your own. This function is used to extend the matchers object with custom matchers.</p>
<p>When you define matchers that way, you also create asymmetric matchers that can be used like <code>expect.stringContaining</code>.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { expect, test } from 'vitest'

test('custom matchers', () =&gt; {
  expect.extend({
    toBeFoo: (received, expected) =&gt; {
      if (received !== 'foo') {
        return {
          message: () =&gt; `expected ${received} to be foo`,
          pass: false,
        }
      }
    },
  })

  expect('foo').toBeFoo()
  expect({ foo: 'foo' }).toEqual({ foo: expect.toBeFoo() })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, test } from 'vitest'

test('custom matchers', () =&gt; {
  expect.extend({
    toBeFoo: (received, expected) =&gt; {
      if (received !== 'foo') {
        return {
          message: () =&gt; `expected ${received} to be foo`,
          pass: false,
        }
      }
    },
  })

  expect('foo').toBeFoo()
  expect({ foo: 'foo' }).toEqual({ foo: expect.toBeFoo() })
})</pre>
</div>
<blockquote><p>If you want your matchers to appear in every test, you should call this method inside <a href="../config/index#setupFiles"><code>setupFiles</code></a>.</p></blockquote>
<p>This function is compatible with Jest's <code>expect.extend</code>, so any library that uses it to create custom matchers will work with Vitest.</p>
<p>If you are using TypeScript, you can extend default Matchers interface with the code bellow:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">interface CustomMatchers&lt;R = unknown&gt; {
  toBeFoo(): R
}

declare global {
  namespace Vi {
    interface Assertion extends CustomMatchers {}
    interface AsymmetricMatchersContaining extends CustomMatchers {}
  }
}</pre>
<pre class="vp-code-light" data-language="javascript">interface CustomMatchers&lt;R = unknown&gt; {
  toBeFoo(): R
}

declare global {
  namespace Vi {
    interface Assertion extends CustomMatchers {}
    interface AsymmetricMatchersContaining extends CustomMatchers {}
  }
}</pre>
</div>
<blockquote><p>Note: augmenting jest.Matchers interface will also work.</p></blockquote>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>If you want to know more, checkout <a href="../guide/extending-matchers">guide on extending matchers</a>.</p>
</div>
</li></ul>
<h2 id="setup-and-teardown" tabindex="-1">Setup and Teardown </h2>
<p>These functions allow you to hook into the life cycle of tests to avoid repeating setup and teardown code. They apply to the current context: the file if they are used at the top-level or the current suite if they are inside a <code>describe</code> block.</p>
<h3 id="beforeeach" tabindex="-1">beforeEach </h3>
<ul><li>
<p><strong>Type:</strong> <code>beforeEach(fn: () =&gt; Awaitable&lt;void&gt;, timeout?: number)</code></p>
<p>Register a callback to be called before each of the tests in the current context runs. If the function returns a promise, Vitest waits until the promise resolve before running the test.</p>
<p>Optionally, you can pass a timeout (in milliseconds) defining how long to wait before terminating. The default is 5 seconds.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { beforeEach } from 'vitest'

beforeEach(async () =&gt; {
  // Clear mocks and add some testing data after before each test run
  await stopMocking()
  await addUser({ name: 'John' })
})</pre>
<pre class="vp-code-light" data-language="javascript">import { beforeEach } from 'vitest'

beforeEach(async () =&gt; {
  // Clear mocks and add some testing data after before each test run
  await stopMocking()
  await addUser({ name: 'John' })
})</pre>
</div>
<p>Here, the <code>beforeEach</code> ensures that user is added for each test.</p>
<p>Since Vitest v0.10.0, <code>beforeEach</code> also accepts an optional cleanup function (equivalent to <code>afterEach</code>).</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { beforeEach } from 'vitest'

beforeEach(async () =&gt; {
  // called once before each test run
  await prepareSomething()

  // clean up function, called once after each test run
  return async () =&gt; {
    await resetSomething()
  }
})</pre>
<pre class="vp-code-light" data-language="javascript">import { beforeEach } from 'vitest'

beforeEach(async () =&gt; {
  // called once before each test run
  await prepareSomething()

  // clean up function, called once after each test run
  return async () =&gt; {
    await resetSomething()
  }
})</pre>
</div>
</li></ul>
<h3 id="aftereach" tabindex="-1">afterEach </h3>
<ul><li>
<p><strong>Type:</strong> <code>afterEach(fn: () =&gt; Awaitable&lt;void&gt;, timeout?: number)</code></p>
<p>Register a callback to be called after each one of the tests in the current context completes. If the function returns a promise, Vitest waits until the promise resolve before continuing.</p>
<p>Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { afterEach } from 'vitest'

afterEach(async () =&gt; {
  await clearTestingData() // clear testing data after each test run
})</pre>
<pre class="vp-code-light" data-language="javascript">import { afterEach } from 'vitest'

afterEach(async () =&gt; {
  await clearTestingData() // clear testing data after each test run
})</pre>
</div>
<p>Here, the <code>afterEach</code> ensures that testing data is cleared after each test runs.</p>
</li></ul>
<h3 id="beforeall" tabindex="-1">beforeAll </h3>
<ul><li>
<p><strong>Type:</strong> <code>beforeAll(fn: () =&gt; Awaitable&lt;void&gt;, timeout?: number)</code></p>
<p>Register a callback to be called once before starting to run all tests in the current context. If the function returns a promise, Vitest waits until the promise resolve before running tests.</p>
<p>Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { beforeAll } from 'vitest'

beforeAll(async () =&gt; {
  await startMocking() // called once before all tests run
})</pre>
<pre class="vp-code-light" data-language="javascript">import { beforeAll } from 'vitest'

beforeAll(async () =&gt; {
  await startMocking() // called once before all tests run
})</pre>
</div>
<p>Here the <code>beforeAll</code> ensures that the mock data is set up before tests run.</p>
<p>Since Vitest v0.10.0, <code>beforeAll</code> also accepts an optional cleanup function (equivalent to <code>afterAll</code>).</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { beforeAll } from 'vitest'

beforeAll(async () =&gt; {
  // called once before all tests run
  await startMocking()

  // clean up function, called once after all tests run
  return async () =&gt; {
    await stopMocking()
  }
})</pre>
<pre class="vp-code-light" data-language="javascript">import { beforeAll } from 'vitest'

beforeAll(async () =&gt; {
  // called once before all tests run
  await startMocking()

  // clean up function, called once after all tests run
  return async () =&gt; {
    await stopMocking()
  }
})</pre>
</div>
</li></ul>
<h3 id="afterall" tabindex="-1">afterAll </h3>
<ul><li>
<p><strong>Type:</strong> <code>afterAll(fn: () =&gt; Awaitable&lt;void&gt;, timeout?: number)</code></p>
<p>Register a callback to be called once after all tests have run in the current context. If the function returns a promise, Vitest waits until the promise resolve before continuing.</p>
<p>Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { afterAll } from 'vitest'

afterAll(async () =&gt; {
  await stopMocking() // this method is called after all tests run
})</pre>
<pre class="vp-code-light" data-language="javascript">import { afterAll } from 'vitest'

afterAll(async () =&gt; {
  await stopMocking() // this method is called after all tests run
})</pre>
</div>
<p>Here the <code>afterAll</code> ensures that <code>stopMocking</code> method is called after all tests run.</p>
</li></ul>
<h2 id="vi" tabindex="-1">Vi </h2>
<p>Vitest provides utility functions to help you out through it's <strong>vi</strong> helper. You can <code>import { vi } from 'vitest'</code> or access it <strong>globally</strong> (when <a href="../config/index#globals">globals configuration</a> is <strong>enabled</strong>).</p>
<h3 id="vi-advancetimersbytime" tabindex="-1">vi.advanceTimersByTime </h3>
<ul><li>
<p><strong>Type:</strong> <code>(ms: number) =&gt; Vitest</code></p>
<p>Works just like <code>runAllTimers</code>, but will end after passed milliseconds. For example this will log <code>1, 2, 3</code> and will not throw:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">let i = 0
setInterval(() =&gt; console.log(++i), 50)

vi.advanceTimersByTime(150)</pre>
<pre class="vp-code-light" data-language="javascript">let i = 0
setInterval(() =&gt; console.log(++i), 50)

vi.advanceTimersByTime(150)</pre>
</div>
</li></ul>
<h3 id="vi-advancetimerstonexttimer" tabindex="-1">vi.advanceTimersToNextTimer </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; Vitest</code></p>
<p>Will call next available timer. Useful to make assertions between each timer call. You can chain call it to manage timers by yourself.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">let i = 0
setInterval(() =&gt; console.log(++i), 50)

vi.advanceTimersToNextTimer() // log 1
  .advanceTimersToNextTimer() // log 2
  .advanceTimersToNextTimer() // log 3</pre>
<pre class="vp-code-light" data-language="javascript">let i = 0
setInterval(() =&gt; console.log(++i), 50)

vi.advanceTimersToNextTimer() // log 1
  .advanceTimersToNextTimer() // log 2
  .advanceTimersToNextTimer() // log 3</pre>
</div>
</li></ul>
<h3 id="vi-clearallmocks" tabindex="-1">vi.clearAllMocks </h3>
<p>Will call <a href="index#mockclear"><code>.mockClear()</code></a> on all spies. This will clear mock history, but not reset its implementation to the default one.</p>
<h3 id="vi-clearalltimers" tabindex="-1">vi.clearAllTimers </h3>
<p>Removes all timers that are scheduled to run. These timers will never run in the future.</p>
<h3 id="vi-dynamicimportsettled" tabindex="-1">vi.dynamicImportSettled </h3>
<p>Wait for all imports to load. Useful, if you have a synchronous call that starts importing a module, that you cannot wait otherwise.</p>
<h3 id="vi-fn" tabindex="-1">vi.fn </h3>
<ul><li>
<p><strong>Type:</strong> <code>(fn?: Function) =&gt; CallableMockInstance</code></p>
<p>Creates a spy on a function, though can be initiated without one. Every time a function is invoked, it stores its call arguments, returns and instances. Also, you can manipulate its behavior with <a href="#mockinstance-methods">methods</a>. If no function is given, mock will return <code>undefined</code>, when invoked.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">const getApples = vi.fn(() =&gt; 0)

getApples()

expect(getApples).toHaveBeenCalled()
expect(getApples).toHaveReturnedWith(0)

getApples.mockReturnValueOnce(5)

const res = getApples()
expect(res).toBe(5)
expect(getApples).toHaveNthReturnedWith(2, 5)</pre>
<pre class="vp-code-light" data-language="javascript">const getApples = vi.fn(() =&gt; 0)

getApples()

expect(getApples).toHaveBeenCalled()
expect(getApples).toHaveReturnedWith(0)

getApples.mockReturnValueOnce(5)

const res = getApples()
expect(res).toBe(5)
expect(getApples).toHaveNthReturnedWith(2, 5)</pre>
</div>
</li></ul>
<h3 id="vi-getmockedsystemtime" tabindex="-1">vi.getMockedSystemTime </h3>
<ul><li>
<p><strong>Type</strong>: <code>() =&gt; Date | null</code></p>
<p>Returns mocked current date that was set using <code>setSystemTime</code>. If date is not mocked, will return <code>null</code>.</p>
</li></ul>
<h3 id="vi-getrealsystemtime" tabindex="-1">vi.getRealSystemTime </h3>
<ul><li>
<p><strong>Type</strong>: <code>() =&gt; number</code></p>
<p>When using <code>vi.useFakeTimers</code>, <code>Date.now</code> calls are mocked. If you need to get real time in milliseconds, you can call this function.</p>
</li></ul>
<h3 id="vi-mock" tabindex="-1">vi.mock </h3>
<ul><li>
<p><strong>Type</strong>: <code>(path: string, factory?: () =&gt; unknown) =&gt; void</code></p>
<p>Makes all <code>imports</code> to passed module to be mocked. Inside a path you <em>can</em> use configured Vite aliases.</p>
<ul>
<li>If <code>factory</code> is defined, will return its result. Factory function can be asynchronous. You may call <a href="#vi-importactual"><code>vi.importActual</code></a> inside to get the original module. The call to <code>vi.mock</code> is hoisted to the top of the file, so you don't have access to variables declared in the global file scope!</li>
<li>If mocking a module with a default export, you'll need to provide a <code>default</code> key within the returned factory function object. This is an ES modules specific caveat, therefore <code>jest</code> documentation may differ as <code>jest</code> uses commonJS modules. <em>Example:</em>
</li>
</ul>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">vi.mock('path', () =&gt; {
  return {
    default: { myDefaultKey: vi.fn() },
    namedExport: vi.fn(),
    // etc...
  }
})</pre>
<pre class="vp-code-light" data-language="javascript">vi.mock('path', () =&gt; {
  return {
    default: { myDefaultKey: vi.fn() },
    namedExport: vi.fn(),
    // etc...
  }
})</pre>
</div>
<ul>
<li>If <code>__mocks__</code> folder with file of the same name exist, all imports will return its exports. For example, <code>vi.mock('axios')</code> with <code>&lt;root&gt;/__mocks__/axios.ts</code> folder will return everything exported from <code>axios.ts</code>.</li>
<li>If there is no <code>__mocks__</code> folder or a file with the same name inside, will call original module and mock it. (For the rules applied, see <a href="../guide/mocking#automocking-algorithm">algorithm</a>.)</li>
</ul>
</li></ul>
<h3 id="vi-mocked" tabindex="-1">vi.mocked </h3>
<ul>
<li><p><strong>Type</strong>: <code>&lt;T&gt;(obj: T, deep?: boolean) =&gt; MaybeMockedDeep&lt;T&gt;</code></p></li>
<li>
<p><strong>Type</strong>: <code>&lt;T&gt;(obj: T, options?: { partial?: boolean; deep?: boolean }) =&gt; MaybePartiallyMockedDeep&lt;T&gt;</code></p>
<p>Type helper for TypeScript. In reality just returns the object that was passed.</p>
<p>When <code>partial</code> is <code>true</code> it will expect a <code>Partial&lt;T&gt;</code> as a return value.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import example from './example'
vi.mock('./example')

test('1+1 equals 2', async () =&gt; {
  vi.mocked(example.calc).mockRestore()

  const res = example.calc(1, '+', 1)

  expect(res).toBe(2)
})</pre>
<pre class="vp-code-light" data-language="javascript">import example from './example'
vi.mock('./example')

test('1+1 equals 2', async () =&gt; {
  vi.mocked(example.calc).mockRestore()

  const res = example.calc(1, '+', 1)

  expect(res).toBe(2)
})</pre>
</div>
</li>
</ul>
<h3 id="vi-importactual" tabindex="-1">vi.importActual </h3>
<ul><li>
<p><strong>Type</strong>: <code>&lt;T&gt;(path: string) =&gt; Promise&lt;T&gt;</code></p>
<p>Imports module, bypassing all checks if it should be mocked. Can be useful if you want to mock module partially.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">vi.mock('./example', async () =&gt; {
  const axios = await vi.importActual('./example')

  return { ...axios, get: vi.fn() }
})</pre>
<pre class="vp-code-light" data-language="javascript">vi.mock('./example', async () =&gt; {
  const axios = await vi.importActual('./example')

  return { ...axios, get: vi.fn() }
})</pre>
</div>
</li></ul>
<h3 id="vi-importmock" tabindex="-1">vi.importMock </h3>
<ul><li>
<p><strong>Type</strong>: <code>&lt;T&gt;(path: string) =&gt; Promise&lt;MaybeMockedDeep&lt;T&gt;&gt;</code></p>
<p>Imports a module with all of its properties (including nested properties) mocked. Follows the same rules that <a href="#vi-mock"><code>vi.mock</code></a> follows. For the rules applied, see <a href="../guide/mocking#automocking-algorithm">algorithm</a>.</p>
</li></ul>
<h3 id="vi-resetallmocks" tabindex="-1">vi.resetAllMocks </h3>
<p>Will call <a href="index#mockreset"><code>.mockReset()</code></a> on all spies. This will clear mock history and reset its implementation to an empty function (will return <code>undefined</code>).</p>
<h3 id="vi-resetmodules" tabindex="-1">vi.resetModules </h3>
<ul><li>
<p><strong>Type</strong>: <code>() =&gt; Vitest</code></p>
<p>Resets modules registry by clearing cache of all modules. Might be useful to isolate modules where local state conflicts between tests.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">import { vi } from 'vitest'

beforeAll(() =&gt; {
  vi.resetModules()
})

test('change state', async () =&gt; {
  const mod = await import('./some/path')
  mod.changeLocalState('new value')
  expect(mod.getlocalState()).toBe('new value')
})

test('module has old state', async () =&gt; {
  const mod = await import('./some/path')
  expect(mod.getlocalState()).toBe('old value')
})</pre>
<pre class="vp-code-light" data-language="javascript">import { vi } from 'vitest'

beforeAll(() =&gt; {
  vi.resetModules()
})

test('change state', async () =&gt; {
  const mod = await import('./some/path')
  mod.changeLocalState('new value')
  expect(mod.getlocalState()).toBe('new value')
})

test('module has old state', async () =&gt; {
  const mod = await import('./some/path')
  expect(mod.getlocalState()).toBe('old value')
})</pre>
</div>
</li></ul>
<h3 id="vi-restoreallmocks" tabindex="-1">vi.restoreAllMocks </h3>
<p>Will call <a href="index#mockrestore"><code>.mockRestore()</code></a> on all spies. This will clear mock history and reset its implementation to the original one.</p>
<h3 id="vi-restorecurrentdate" tabindex="-1">vi.restoreCurrentDate </h3>
<ul><li>
<p><strong>Type</strong>: <code>() =&gt; void</code></p>
<p>Restores <code>Date</code> back to its native implementation.</p>
</li></ul>
<h3 id="vi-runallticks" tabindex="-1">vi.runAllTicks </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; Vitest</code></p>
<p>Calls every microtask. These are usually queued by <code>proccess.nextTick</code>. This will also run all microtasks scheduled by themselves.</p>
</li></ul>
<h3 id="vi-runalltimers" tabindex="-1">vi.runAllTimers </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; Vitest</code></p>
<p>This method will invoke every initiated timer until the timers queue is empty. It means that every timer called during <code>runAllTimers</code> will be fired. If you have an infinite interval, it will throw after 10 000 tries. For example this will log <code>1, 2, 3</code>:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">let i = 0
setTimeout(() =&gt; console.log(++i))
const interval = setInterval(() =&gt; {
  console.log(++i)
  if (i === 3)
    clearInterval(interval)

}, 50)

vi.runAllTimers()</pre>
<pre class="vp-code-light" data-language="javascript">let i = 0
setTimeout(() =&gt; console.log(++i))
const interval = setInterval(() =&gt; {
  console.log(++i)
  if (i === 3)
    clearInterval(interval)

}, 50)

vi.runAllTimers()</pre>
</div>
</li></ul>
<h3 id="vi-runonlypendingtimers" tabindex="-1">vi.runOnlyPendingTimers </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; Vitest</code></p>
<p>This method will call every timer that was initiated after <code>vi.useFakeTimers()</code> call. It will not fire any timer that was initiated during its call. For example this will only log <code>1</code>:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">let i = 0
setInterval(() =&gt; console.log(++i), 50)

vi.runOnlyPendingTimers()</pre>
<pre class="vp-code-light" data-language="javascript">let i = 0
setInterval(() =&gt; console.log(++i), 50)

vi.runOnlyPendingTimers()</pre>
</div>
</li></ul>
<h3 id="vi-setsystemtime" tabindex="-1">vi.setSystemTime </h3>
<ul><li>
<p><strong>Type</strong>: <code>(date: string | number | Date) =&gt; void</code></p>
<p>Sets current date to the one that was passed. All <code>Date</code> calls will return this date.</p>
<p>Useful if you need to test anything that depends on the current date - for example <a href="https://github.com/moment/luxon/" target="_blank" rel="noreferrer">luxon</a> calls inside your code.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">const date = new Date(1998, 11, 19)

vi.useFakeTimers()
vi.setSystemTime(date)

expect(Date.now()).toBe(date.valueOf())

vi.useRealTimers()</pre>
<pre class="vp-code-light" data-language="javascript">const date = new Date(1998, 11, 19)

vi.useFakeTimers()
vi.setSystemTime(date)

expect(Date.now()).toBe(date.valueOf())

vi.useRealTimers()</pre>
</div>
</li></ul>
<h3 id="vi-spyon" tabindex="-1">vi.spyOn </h3>
<ul><li>
<p><strong>Type:</strong> <code>&lt;T, K extends keyof T&gt;(object: T, method: K, accessType?: 'get' | 'set') =&gt; MockInstance</code></p>
<p>Creates a spy on a method or getter/setter of an object.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">let apples = 0
const obj = {
  getApples: () =&gt; 13,
}

const spy = vi.spyOn(obj, 'getApples').mockImplementation(() =&gt; apples)
apples = 1

expect(obj.getApples()).toBe(1)

expect(spy).toHaveBeenCalled()
expect(spy).toHaveReturnedWith(1)</pre>
<pre class="vp-code-light" data-language="javascript">let apples = 0
const obj = {
  getApples: () =&gt; 13,
}

const spy = vi.spyOn(obj, 'getApples').mockImplementation(() =&gt; apples)
apples = 1

expect(obj.getApples()).toBe(1)

expect(spy).toHaveBeenCalled()
expect(spy).toHaveReturnedWith(1)</pre>
</div>
</li></ul>
<h3 id="vi-stubglobal" tabindex="-1">vi.stubGlobal </h3>
<ul><li>
<p><strong>Type</strong>: <code>(key: keyof globalThis &amp; Window, value: any) =&gt; Vitest</code></p>
<p>Puts a value on global variable. If you are using <code>jsdom</code> or <code>happy-dom</code>, also puts the value on <code>window</code> object.</p>
<p>Read more in <a href="../guide/mocking#globals">"Mocking Globals" section</a>.</p>
</li></ul>
<h3 id="vi-unmock" tabindex="-1">vi.unmock </h3>
<ul><li>
<p><strong>Type</strong>: <code>(path: string) =&gt; void</code></p>
<p>Removes module from mocked registry. All subsequent calls to import will return original module even if it was mocked.</p>
</li></ul>
<h3 id="vi-usefaketimers" tabindex="-1">vi.useFakeTimers </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; Vitest</code></p>
<p>To enable mocking timers, you need to call this method. It will wrap all further calls to timers (such as <code>setTimeout</code>, <code>setInterval</code>, <code>clearTimeout</code>, <code>clearInterval</code>, <code>nextTick</code>, <code>setImmediate</code>, <code>clearImmediate</code>, and <code>Date</code>), until <a href="#vi-userealtimers"><code>vi.useRealTimers()</code></a> is called.</p>
<p>The implementation is based internally on <a href="https://github.com/sinonjs/fake-timers" target="_blank" rel="noreferrer"><code>@sinonjs/fake-timers</code></a>.</p>
</li></ul>
<h3 id="vi-userealtimers" tabindex="-1">vi.useRealTimers </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; Vitest</code></p>
<p>When timers are run out, you may call this method to return mocked timers to its original implementations. All timers that were run before will not be restored.</p>
</li></ul>
<h2 id="mockinstance-methods" tabindex="-1">MockInstance Methods </h2>
<h3 id="getmockname" tabindex="-1">getMockName </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; string</code></p>
<p>Use it to return the name given to mock with method <code>.mockName(name)</code>.</p>
</li></ul>
<h3 id="mockclear" tabindex="-1">mockClear </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; MockInstance</code></p>
<p>Clears all information about every call. After calling it, <a href="#mock-calls"><code>spy.mock.calls</code></a>, <a href="#mock-results"><code>spy.mock.results</code></a> will return empty arrays. It is useful if you need to clean up spy between different assertions.</p>
<p>If you want this method to be called before each test automatically, you can enable <a href="../config/index#clearmocks"><code>clearMocks</code></a> setting in config.</p>
</li></ul>
<h3 id="mockname" tabindex="-1">mockName </h3>
<ul><li>
<p><strong>Type:</strong> <code>(name: string) =&gt; MockInstance</code></p>
<p>Sets internal mock name. Useful to see what mock has failed the assertion.</p>
</li></ul>
<h3 id="mockimplementation" tabindex="-1">mockImplementation </h3>
<ul><li>
<p><strong>Type:</strong> <code>(fn: Function) =&gt; MockInstance</code></p>
<p>Accepts a function that will be used as an implementation of the mock.</p>
<p>For example:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">const mockFn = vi.fn().mockImplementation(apples =&gt; apples + 1)
// or: vi.fn(apples =&gt; apples + 1);

const NelliesBucket = mockFn(0)
const BobsBucket = mockFn(1)

NelliesBucket === 1 // true
BobsBucket === 2 // true

mockFn.mock.calls[0][0] === 0 // true
mockFn.mock.calls[1][0] === 1 // true</pre>
<pre class="vp-code-light" data-language="javascript">const mockFn = vi.fn().mockImplementation(apples =&gt; apples + 1)
// or: vi.fn(apples =&gt; apples + 1);

const NelliesBucket = mockFn(0)
const BobsBucket = mockFn(1)

NelliesBucket === 1 // true
BobsBucket === 2 // true

mockFn.mock.calls[0][0] === 0 // true
mockFn.mock.calls[1][0] === 1 // true</pre>
</div>
</li></ul>
<h3 id="mockimplementationonce" tabindex="-1">mockImplementationOnce </h3>
<ul><li>
<p><strong>Type:</strong> <code>(fn: Function) =&gt; MockInstance</code></p>
<p>Accepts a function that will be used as an implementation of the mock for one call to the mocked function. Can be chained so that multiple function calls produce different results.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">const myMockFn = vi
  .fn()
  .mockImplementationOnce(() =&gt; true)
  .mockImplementationOnce(() =&gt; false)

myMockFn() // true
myMockFn() // false</pre>
<pre class="vp-code-light" data-language="javascript">const myMockFn = vi
  .fn()
  .mockImplementationOnce(() =&gt; true)
  .mockImplementationOnce(() =&gt; false)

myMockFn() // true
myMockFn() // false</pre>
</div>
<p>When the mocked function runs out of implementations, it will invoke the default implementation that was set with <code>vi.fn(() =&gt; defaultValue)</code> or <code>.mockImplementation(() =&gt; defaultValue)</code> if they were called:</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">const myMockFn = vi
  .fn(() =&gt; 'default')
  .mockImplementationOnce(() =&gt; 'first call')
  .mockImplementationOnce(() =&gt; 'second call')

// 'first call', 'second call', 'default', 'default'
console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())</pre>
<pre class="vp-code-light" data-language="javascript">const myMockFn = vi
  .fn(() =&gt; 'default')
  .mockImplementationOnce(() =&gt; 'first call')
  .mockImplementationOnce(() =&gt; 'second call')

// 'first call', 'second call', 'default', 'default'
console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())</pre>
</div>
</li></ul>
<h3 id="mockrejectedvalue" tabindex="-1">mockRejectedValue </h3>
<ul><li>
<p><strong>Type:</strong> <code>(value: any) =&gt; MockInstance</code></p>
<p>Accepts an error that will be rejected, when async function will be called.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">test('async test', async () =&gt; {
  const asyncMock = vi.fn().mockRejectedValue(new Error('Async error'))

  await asyncMock() // throws "Async error"
})</pre>
<pre class="vp-code-light" data-language="javascript">test('async test', async () =&gt; {
  const asyncMock = vi.fn().mockRejectedValue(new Error('Async error'))

  await asyncMock() // throws "Async error"
})</pre>
</div>
</li></ul>
<h3 id="mockrejectedvalueonce" tabindex="-1">mockRejectedValueOnce </h3>
<ul><li>
<p><strong>Type:</strong> <code>(value: any) =&gt; MockInstance</code></p>
<p>Accepts a value that will be rejected for one call to the mock function. If chained, every consecutive call will reject passed value.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">test('async test', async () =&gt; {
  const asyncMock = vi
    .fn()
    .mockResolvedValueOnce('first call')
    .mockRejectedValueOnce(new Error('Async error'))

  await asyncMock() // first call
  await asyncMock() // throws "Async error"
})</pre>
<pre class="vp-code-light" data-language="javascript">test('async test', async () =&gt; {
  const asyncMock = vi
    .fn()
    .mockResolvedValueOnce('first call')
    .mockRejectedValueOnce(new Error('Async error'))

  await asyncMock() // first call
  await asyncMock() // throws "Async error"
})</pre>
</div>
</li></ul>
<h3 id="mockreset" tabindex="-1">mockReset </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; MockInstance</code></p>
<p>Does what <code>mockClear</code> does and makes inner implementation as an empty function (returning <code>undefined</code>, when invoked). This is useful when you want to completely reset a mock back to its initial state.</p>
<p>If you want this method to be called before each test automatically, you can enable <a href="../config/index#mockreset"><code>mockReset</code></a> setting in config.</p>
</li></ul>
<h3 id="mockrestore" tabindex="-1">mockRestore </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; MockInstance</code></p>
<p>Does what <code>mockReset</code> does and restores inner implementation to the original function.</p>
<p>Note that restoring mock from <code>vi.fn()</code> will set implementation to an empty function that returns <code>undefined</code>. Restoring a <code>vi.fn(impl)</code> will restore implementation to <code>impl</code>.</p>
<p>If you want this method to be called before each test automatically, you can enable <a href="../config/index#restoreMocks"><code>restoreMocks</code></a> setting in config.</p>
</li></ul>
<h3 id="mockresolvedvalue" tabindex="-1">mockResolvedValue </h3>
<ul><li>
<p><strong>Type:</strong> <code>(value: any) =&gt; MockInstance</code></p>
<p>Accepts a value that will be resolved, when async function will be called.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">test('async test', async () =&gt; {
  const asyncMock = vi.fn().mockResolvedValue(43)

  await asyncMock() // 43
})</pre>
<pre class="vp-code-light" data-language="javascript">test('async test', async () =&gt; {
  const asyncMock = vi.fn().mockResolvedValue(43)

  await asyncMock() // 43
})</pre>
</div>
</li></ul>
<h3 id="mockresolvedvalueonce" tabindex="-1">mockResolvedValueOnce </h3>
<ul><li>
<p><strong>Type:</strong> <code>(value: any) =&gt; MockInstance</code></p>
<p>Accepts a value that will be resolved for one call to the mock function. If chained, every consecutive call will resolve passed value.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">test('async test', async () =&gt; {
  const asyncMock = vi
    .fn()
    .mockResolvedValue('default')
    .mockResolvedValueOnce('first call')
    .mockResolvedValueOnce('second call')

  await asyncMock() // first call
  await asyncMock() // second call
  await asyncMock() // default
  await asyncMock() // default
})</pre>
<pre class="vp-code-light" data-language="javascript">test('async test', async () =&gt; {
  const asyncMock = vi
    .fn()
    .mockResolvedValue('default')
    .mockResolvedValueOnce('first call')
    .mockResolvedValueOnce('second call')

  await asyncMock() // first call
  await asyncMock() // second call
  await asyncMock() // default
  await asyncMock() // default
})</pre>
</div>
</li></ul>
<h3 id="mockreturnthis" tabindex="-1">mockReturnThis </h3>
<ul><li>
<p><strong>Type:</strong> <code>() =&gt; MockInstance</code></p>
<p>Sets inner implementation to return <code>this</code> context.</p>
</li></ul>
<h3 id="mockreturnvalue" tabindex="-1">mockReturnValue </h3>
<ul><li>
<p><strong>Type:</strong> <code>(value: any) =&gt; MockInstance</code></p>
<p>Accepts a value that will be returned whenever the mock function is called.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">const mock = vi.fn()
mock.mockReturnValue(42)
mock() // 42
mock.mockReturnValue(43)
mock() // 43</pre>
<pre class="vp-code-light" data-language="javascript">const mock = vi.fn()
mock.mockReturnValue(42)
mock() // 42
mock.mockReturnValue(43)
mock() // 43</pre>
</div>
</li></ul>
<h3 id="mockreturnvalueonce" tabindex="-1">mockReturnValueOnce </h3>
<ul><li>
<p><strong>Type:</strong> <code>(value: any) =&gt; MockInstance</code></p>
<p>Accepts a value that will be returned for one call to the mock function. If chained, every consecutive call will return passed value. When there are no more <code>mockReturnValueOnce</code> values to use, calls a function specified by <code>mockImplementation</code> or other <code>mockReturn*</code> methods.</p>
<div class="language-ts">
<span class="lang">ts</span><pre class="vp-code-dark" data-language="javascript">const myMockFn = vi
  .fn()
  .mockReturnValue('default')
  .mockReturnValueOnce('first call')
  .mockReturnValueOnce('second call')

// 'first call', 'second call', 'default', 'default'
console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())</pre>
<pre class="vp-code-light" data-language="javascript">const myMockFn = vi
  .fn()
  .mockReturnValue('default')
  .mockReturnValueOnce('first call')
  .mockReturnValueOnce('second call')

// 'first call', 'second call', 'default', 'default'
console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())</pre>
</div>
</li></ul>
<h2 id="mockinstance-properties" tabindex="-1">MockInstance Properties </h2>
<h3 id="mock-calls" tabindex="-1">mock.calls </h3>
<p>This is an array containing all arguments for each call. One item of the array is arguments of that call.</p>
<p>If a function was invoked twice with the following arguments <code>fn(arg1, arg2)</code>, <code>fn(arg3, arg4)</code> in that order, then <code>mock.calls</code> will be:</p>
<div class="language-js">
<span class="lang">js</span><pre class="vp-code-dark" data-language="javascript">[
  ['arg1', 'arg2'],
  ['arg3', 'arg4'],
]</pre>
<pre class="vp-code-light" data-language="javascript">[
  ['arg1', 'arg2'],
  ['arg3', 'arg4'],
]</pre>
</div>
<h3 id="mock-lastcall" tabindex="-1">mock.lastCall </h3>
<p>This contains the arguments of the last call. If spy wasn't called, will return <code>undefined</code>.</p>
<h3 id="mock-results" tabindex="-1">mock.results </h3>
<p>This is an array containing all values, that were <code>returned</code> from function. One item of the array is an object with properties <code>type</code> and <code>value</code>. Available types are:</p>
<ul>
<li>
<code>'return'</code> - function returned without throwing.</li>
<li>
<code>'throw'</code> - function threw a value.</li>
</ul>
<p>The <code>value</code> property contains returned value or thrown error.</p>
<p>If function returned <code>result</code>, then threw an error, then <code>mock.results</code> will be:</p>
<div class="language-js">
<span class="lang">js</span><pre class="vp-code-dark" data-language="javascript">[
  {
    type: 'return',
    value: 'result',
  },
  {
    type: 'throw',
    value: Error,
  },
]</pre>
<pre class="vp-code-light" data-language="javascript">[
  {
    type: 'return',
    value: 'result',
  },
  {
    type: 'throw',
    value: Error,
  },
]</pre>
</div>
<h3 id="mock-instances" tabindex="-1">mock.instances </h3>
<p>This is an array containing all instances that were instantiated when mock was called with a <code>new</code> keyword. Note, this is an actual context (<code>this</code>) of the function, not a return value.</p>
<p>For example, if mock was instantiated with <code>new MyClass()</code>, then <code>mock.instances</code> will be an array of one value:</p>
<div class="language-js">
<span class="lang">js</span><pre class="vp-code-dark" data-language="javascript">import { expect, vi } from 'vitest'

const MyClass = vi.fn()

const a = new MyClass()

expect(MyClass.mock.instances[0]).toBe(a)</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, vi } from 'vitest'

const MyClass = vi.fn()

const a = new MyClass()

expect(MyClass.mock.instances[0]).toBe(a)</pre>
</div>
<p>If you return a value from constructor, it will not be in <code>instances</code> array, but instead on <code>results</code>:</p>
<div class="language-js">
<span class="lang">js</span><pre class="vp-code-dark" data-language="javascript">import { expect, vi } from 'vitest'

const Spy = vi.fn(() =&gt; ({ method: vi.fn() }))

const a = new Spy()

expect(Spy.mock.instances[0]).not.toBe(a)
expect(Spy.mock.results[0]).toBe(a)</pre>
<pre class="vp-code-light" data-language="javascript">import { expect, vi } from 'vitest'

const Spy = vi.fn(() =&gt; ({ method: vi.fn() }))

const a = new Spy()

expect(Spy.mock.instances[0]).not.toBe(a)
expect(Spy.mock.results[0]).toBe(a)</pre>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2021-Present Anthony Fu<br>© 2021-Present Matias Capeletto<br>Licensed under the MIT License.<br>
    <a href="https://vitest.dev/api/" class="_attribution-link">https://vitest.dev/api/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
