
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Encoding&#47;binary - Go - W3cubDocs</title>
  
  <meta name="description" content=" Package binary implements simple translation between numbers and byte sequences and encoding and decoding of varints. ">
  <meta name="keywords" content="package, binary, encoding, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/go/encoding/binary/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/go.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _go">
				
				
<h1> Package binary  </h1>    <ul id="short-nav">
<li><code>import "encoding/binary"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p> Package binary implements simple translation between numbers and byte sequences and encoding and decoding of varints. </p> <p> Numbers are translated by reading and writing fixed-size values. A fixed-size value is either a fixed-size arithmetic type (bool, int8, uint8, int16, float32, complex64, ...) or an array or struct containing only fixed-size values. </p> <p> The varint functions encode and decode single integer values using a variable-length encoding; smaller values require fewer bytes. For a specification, see <a href="https://developers.google.com/protocol-buffers/docs/encoding">https://developers.google.com/protocol-buffers/docs/encoding</a>. </p> <p> This package favors simplicity over efficiency. Clients that require high-performance serialization, especially for large data structures, should look at more advanced solutions such as the encoding/gob package or protocol buffers. </p>      <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#PutUvarint">func PutUvarint(buf []byte, x uint64) int</a></li>
<li><a href="#PutVarint">func PutVarint(buf []byte, x int64) int</a></li>
<li><a href="#Read">func Read(r io.Reader, order ByteOrder, data interface{}) error</a></li>
<li><a href="#ReadUvarint">func ReadUvarint(r io.ByteReader) (uint64, error)</a></li>
<li><a href="#ReadVarint">func ReadVarint(r io.ByteReader) (int64, error)</a></li>
<li><a href="#Size">func Size(v interface{}) int</a></li>
<li><a href="#Uvarint">func Uvarint(buf []byte) (uint64, int)</a></li>
<li><a href="#Varint">func Varint(buf []byte) (int64, int)</a></li>
<li><a href="#Write">func Write(w io.Writer, order ByteOrder, data interface{}) error</a></li>
<li><a href="#ByteOrder">type ByteOrder</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_ByteOrder_get">ByteOrder (Get)</a></dd> <dd><a class="exampleLink" href="#example_ByteOrder_put">ByteOrder (Put)</a></dd> <dd><a class="exampleLink" href="#example_PutUvarint">PutUvarint</a></dd> <dd><a class="exampleLink" href="#example_PutVarint">PutVarint</a></dd> <dd><a class="exampleLink" href="#example_Read">Read</a></dd> <dd><a class="exampleLink" href="#example_Read_multi">Read (Multi)</a></dd> <dd><a class="exampleLink" href="#example_Uvarint">Uvarint</a></dd> <dd><a class="exampleLink" href="#example_Varint">Varint</a></dd> <dd><a class="exampleLink" href="#example_Write">Write</a></dd> <dd><a class="exampleLink" href="#example_Write_multi">Write (Multi)</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/encoding/binary/binary.go">binary.go</a> <a href="https://golang.org/src/encoding/binary/varint.go">varint.go</a>  </p>   <h2 id="pkg-constants">Constants</h2> <p> MaxVarintLenN is the maximum length of a varint-encoded N-bit integer. </p> <pre data-language="go">const (
    MaxVarintLen16 = 3
    MaxVarintLen32 = 5
    MaxVarintLen64 = 10
)</pre> <h2 id="pkg-variables">Variables</h2> <p> BigEndian is the big-endian implementation of ByteOrder. </p> <pre data-language="go">var BigEndian bigEndian</pre> <p> LittleEndian is the little-endian implementation of ByteOrder. </p> <pre data-language="go">var LittleEndian littleEndian</pre> <h2 id="PutUvarint">func PutUvarint<a href="https://golang.org/src/encoding/binary/varint.go?s=1611:1652#L31" class="source">Source</a>  </h2> <pre data-language="go">func PutUvarint(buf []byte, x uint64) int</pre> <p> PutUvarint encodes a uint64 into buf and returns the number of bytes written. If the buffer is too small, PutUvarint will panic. </p>    <h4 id="example_PutUvarint"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/binary"
	"fmt"
)

func main() {
	buf := make([]byte, binary.MaxVarintLen64)

	for _, x := range []uint64{1, 2, 127, 128, 255, 256} {
		n := binary.PutUvarint(buf, x)
		fmt.Printf("%x\n", buf[:n])
	}
}
</pre>   <h2 id="PutVarint">func PutVarint<a href="https://golang.org/src/encoding/binary/varint.go?s=2477:2516#L68" class="source">Source</a>  </h2> <pre data-language="go">func PutVarint(buf []byte, x int64) int</pre> <p> PutVarint encodes an int64 into buf and returns the number of bytes written. If the buffer is too small, PutVarint will panic. </p>    <h4 id="example_PutVarint"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/binary"
	"fmt"
)

func main() {
	buf := make([]byte, binary.MaxVarintLen64)

	for _, x := range []int64{-65, -64, -2, -1, 0, 1, 2, 63, 64} {
		n := binary.PutVarint(buf, x)
		fmt.Printf("%x\n", buf[:n])
	}
}
</pre>   <h2 id="Read">func Read<a href="https://golang.org/src/encoding/binary/binary.go?s=5188:5251#L152" class="source">Source</a>  </h2> <pre data-language="go">func Read(r io.Reader, order ByteOrder, data interface{}) error</pre> <p> Read reads structured binary data from r into data. Data must be a pointer to a fixed-size value or a slice of fixed-size values. Bytes read from r are decoded using the specified byte order and written to successive fields of the data. When decoding boolean values, a zero byte is decoded as false, and any other non-zero byte is decoded as true. When reading into structs, the field data for fields with blank (_) field names is skipped; i.e., blank field names may be used for padding. When reading into a struct, all non-blank fields must be exported or Read may panic. </p> <p> The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, Read returns ErrUnexpectedEOF. </p>    <h4 id="example_Read"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
)

func main() {
	var pi float64
	b := []byte{0x18, 0x2d, 0x44, 0x54, 0xfb, 0x21, 0x09, 0x40}
	buf := bytes.NewReader(b)
	err := binary.Read(buf, binary.LittleEndian, &amp;pi)
	if err != nil {
		fmt.Println("binary.Read failed:", err)
	}
	fmt.Print(pi)
}
</pre>      <h4 id="example_Read_multi"> <span class="text">Example (Multi)</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
)

func main() {
	b := []byte{0x18, 0x2d, 0x44, 0x54, 0xfb, 0x21, 0x09, 0x40, 0xff, 0x01, 0x02, 0x03, 0xbe, 0xef}
	r := bytes.NewReader(b)

	var data struct {
		PI   float64
		Uate uint8
		Mine [3]byte
		Too  uint16
	}

	if err := binary.Read(r, binary.LittleEndian, &amp;data); err != nil {
		fmt.Println("binary.Read failed:", err)
	}

	fmt.Println(data.PI)
	fmt.Println(data.Uate)
	fmt.Printf("% x\n", data.Mine)
	fmt.Println(data.Too)
}
</pre>   <h2 id="ReadUvarint">func ReadUvarint<a href="https://golang.org/src/encoding/binary/varint.go?s=3248:3297#L96" class="source">Source</a>  </h2> <pre data-language="go">func ReadUvarint(r io.ByteReader) (uint64, error)</pre> <p> ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64. </p> <h2 id="ReadVarint">func ReadVarint<a href="https://golang.org/src/encoding/binary/varint.go?s=3676:3723#L117" class="source">Source</a>  </h2> <pre data-language="go">func ReadVarint(r io.ByteReader) (int64, error)</pre> <p> ReadVarint reads an encoded signed integer from r and returns it as an int64. </p> <h2 id="Size">func Size<a href="https://golang.org/src/encoding/binary/binary.go?s=10675:10703#L385" class="source">Source</a>  </h2> <pre data-language="go">func Size(v interface{}) int</pre> <p> Size returns how many bytes Write would generate to encode the value v, which must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. If v is neither of these, Size returns -1. </p> <h2 id="Uvarint">func Uvarint<a href="https://golang.org/src/encoding/binary/varint.go?s=2070:2108#L50" class="source">Source</a>  </h2> <pre data-language="go">func Uvarint(buf []byte) (uint64, int)</pre> <p> Uvarint decodes a uint64 from buf and returns that value and the number of bytes read (&gt; 0). If an error occurred, the value is 0 and the number of bytes n is &lt;= 0 meaning: </p> <pre data-language="go">n == 0: buf too small
n  &lt; 0: value larger than 64 bits (overflow)
        and -n is the number of bytes read
</pre>    <h4 id="example_Uvarint"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/binary"
	"fmt"
)

func main() {
	inputs := [][]byte{
		{0x01},
		{0x02},
		{0x7f},
		{0x80, 0x01},
		{0xff, 0x01},
		{0x80, 0x02},
	}
	for _, b := range inputs {
		x, n := binary.Uvarint(b)
		if n != len(b) {
			fmt.Println("Uvarint did not consume all of in")
		}
		fmt.Println(x)
	}
}
</pre>   <h2 id="Varint">func Varint<a href="https://golang.org/src/encoding/binary/varint.go?s=2926:2962#L84" class="source">Source</a>  </h2> <pre data-language="go">func Varint(buf []byte) (int64, int)</pre> <p> Varint decodes an int64 from buf and returns that value and the number of bytes read (&gt; 0). If an error occurred, the value is 0 and the number of bytes n is &lt;= 0 with the following meaning: </p> <pre data-language="go">n == 0: buf too small
n  &lt; 0: value larger than 64 bits (overflow)
        and -n is the number of bytes read
</pre>    <h4 id="example_Varint"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/binary"
	"fmt"
)

func main() {
	inputs := [][]byte{
		{0x81, 0x01},
		{0x7f},
		{0x03},
		{0x01},
		{0x00},
		{0x02},
		{0x04},
		{0x7e},
		{0x80, 0x01},
	}
	for _, b := range inputs {
		x, n := binary.Varint(b)
		if n != len(b) {
			fmt.Println("Varint did not consume all of in")
		}
		fmt.Println(x)
	}
}
</pre>   <h2 id="Write">func Write<a href="https://golang.org/src/encoding/binary/binary.go?s=7891:7955#L261" class="source">Source</a>  </h2> <pre data-language="go">func Write(w io.Writer, order ByteOrder, data interface{}) error</pre> <p> Write writes the binary representation of data into w. Data must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. Boolean values encode as one byte: 1 for true, and 0 for false. Bytes written to w are encoded using the specified byte order and read from successive fields of the data. When writing structs, zero values are written for fields with blank (_) field names. </p>    <h4 id="example_Write"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"math"
)

func main() {
	buf := new(bytes.Buffer)
	var pi float64 = math.Pi
	err := binary.Write(buf, binary.LittleEndian, pi)
	if err != nil {
		fmt.Println("binary.Write failed:", err)
	}
	fmt.Printf("% x", buf.Bytes())
}
</pre>      <h4 id="example_Write_multi"> <span class="text">Example (Multi)</span>
</h4> <pre class="play" data-language="go">package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
)

func main() {
	buf := new(bytes.Buffer)
	var data = []interface{}{
		uint16(61374),
		int8(-54),
		uint8(254),
	}
	for _, v := range data {
		err := binary.Write(buf, binary.LittleEndian, v)
		if err != nil {
			fmt.Println("binary.Write failed:", err)
		}
	}
	fmt.Printf("%x", buf.Bytes())
}
</pre>   <h2 id="ByteOrder">type ByteOrder<a href="https://golang.org/src/encoding/binary/binary.go?s=1184:1379#L24" class="source">Source</a>  </h2> <p> A ByteOrder specifies how to convert byte sequences into 16-, 32-, or 64-bit unsigned integers. </p> <pre data-language="go">type ByteOrder interface {
    Uint16([]byte) uint16
    Uint32([]byte) uint32
    Uint64([]byte) uint64
    PutUint16([]byte, uint16)
    PutUint32([]byte, uint32)
    PutUint64([]byte, uint64)
    String() string
}</pre>    <h4 id="example_ByteOrder_get"> <span class="text">Example (Get)</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/binary"
	"fmt"
)

func main() {
	b := []byte{0xe8, 0x03, 0xd0, 0x07}
	x1 := binary.LittleEndian.Uint16(b[0:])
	x2 := binary.LittleEndian.Uint16(b[2:])
	fmt.Printf("%#04x %#04x\n", x1, x2)
}
</pre>      <h4 id="example_ByteOrder_put"> <span class="text">Example (Put)</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/binary"
	"fmt"
)

func main() {
	b := make([]byte, 4)
	binary.LittleEndian.PutUint16(b[0:], 0x03e8)
	binary.LittleEndian.PutUint16(b[2:], 0x07d0)
	fmt.Printf("% x\n", b)
}
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/encoding/binary/" class="_attribution-link">https://golang.org/pkg/encoding/binary/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
