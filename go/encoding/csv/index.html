
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Encoding&#47;csv - Go - W3cubDocs</title>
  
  <meta name="description" content="Package csv reads and writes comma-separated values (CSV) files. There are many kinds of CSV files; this package supports the format described in &hellip;">
  <meta name="keywords" content="package, csv, encoding, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/go/encoding/csv/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _go">
				
				
<h1> Package csv  </h1>    <ul id="short-nav">
<li><code>import "encoding/csv"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p> Package csv reads and writes comma-separated values (CSV) files. There are many kinds of CSV files; this package supports the format described in RFC 4180. </p> <p> A csv file contains zero or more records of one or more fields per record. Each record is separated by the newline character. The final record may optionally be followed by a newline character. </p> <pre data-language="go">field1,field2,field3
</pre> <p> White space is considered part of a field. </p> <p> Carriage returns before newline characters are silently removed. </p> <p> Blank lines are ignored. A line with only whitespace characters (excluding the ending newline character) is not considered a blank line. </p> <p> Fields which start and stop with the quote character " are called quoted-fields. The beginning and ending quote are not part of the field. </p> <p> The source: </p> <pre data-language="go">normal string,"quoted-field"
</pre> <p> results in the fields </p> <pre data-language="go">{`normal string`, `quoted-field`}
</pre> <p> Within a quoted-field a quote character followed by a second quote character is considered a single quote. </p> <pre data-language="go">"the ""word"" is true","a ""quoted-field"""
</pre> <p> results in </p> <pre data-language="go">{`the "word" is true`, `a "quoted-field"`}
</pre> <p> Newlines and commas may be included in a quoted-field </p> <pre data-language="go">"Multi-line
field","comma is ,"
</pre> <p> results in </p> <pre data-language="go">{`Multi-line
field`, `comma is ,`}
</pre>      <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#ParseError">type ParseError</a></li>
<li> <a href="#ParseError.Error">func (e *ParseError) Error() string</a>
</li>
<li> <a href="#ParseError.Unwrap">func (e *ParseError) Unwrap() error</a>
</li>
<li><a href="#Reader">type Reader</a></li>
<li> <a href="#NewReader">func NewReader(r io.Reader) *Reader</a>
</li>
<li> <a href="#Reader.Read">func (r *Reader) Read() (record []string, err error)</a>
</li>
<li> <a href="#Reader.ReadAll">func (r *Reader) ReadAll() (records [][]string, err error)</a>
</li>
<li><a href="#Writer">type Writer</a></li>
<li> <a href="#NewWriter">func NewWriter(w io.Writer) *Writer</a>
</li>
<li> <a href="#Writer.Error">func (w *Writer) Error() error</a>
</li>
<li> <a href="#Writer.Flush">func (w *Writer) Flush()</a>
</li>
<li> <a href="#Writer.Write">func (w *Writer) Write(record []string) error</a>
</li>
<li> <a href="#Writer.WriteAll">func (w *Writer) WriteAll(records [][]string) error</a>
</li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_Reader">Reader</a></dd> <dd><a class="exampleLink" href="#example_Reader_ReadAll">Reader.ReadAll</a></dd> <dd><a class="exampleLink" href="#example_Reader_options">Reader (Options)</a></dd> <dd><a class="exampleLink" href="#example_Writer">Writer</a></dd> <dd><a class="exampleLink" href="#example_Writer_WriteAll">Writer.WriteAll</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/encoding/csv/reader.go">reader.go</a> <a href="https://golang.org/src/encoding/csv/writer.go">writer.go</a>  </p>   <h2 id="pkg-variables">Variables</h2> <p> These are the errors that can be returned in ParseError.Err. </p> <pre data-language="go">var (
    ErrTrailingComma = errors.New("extra delimiter at end of line") // Deprecated: No longer used.
    ErrBareQuote     = errors.New("bare \" in non-quoted-field")
    ErrQuote         = errors.New("extraneous or missing \" in quoted-field")
    ErrFieldCount    = errors.New("wrong number of fields")
)</pre> <h2 id="ParseError">type ParseError<a href="https://golang.org/src/encoding/csv/reader.go?s=1688:1915#L56" class="source">Source</a>  </h2> <p> A ParseError is returned for parsing errors. Line numbers are 1-indexed and columns are 0-indexed. </p> <pre data-language="go">type ParseError struct {
    StartLine int   // Line where the record starts; added in Go 1.10
    Line      int   // Line where the error occurred
    Column    int   // Column (rune index) where the error occurred
    Err       error // The actual error
}
</pre> <h3 id="ParseError.Error">func (*ParseError) Error<a href="https://golang.org/src/encoding/csv/reader.go?s=1917:1952#L63" class="source">Source</a>  </h3> <pre data-language="go">func (e *ParseError) Error() string</pre> <h3 id="ParseError.Unwrap">func (*ParseError) Unwrap<a href="https://golang.org/src/encoding/csv/reader.go?s=2287:2322#L73" class="source">Source</a>  <span title="Added in Go 1.13">1.13</span> </h3> <pre data-language="go">func (e *ParseError) Unwrap() error</pre> <h2 id="Reader">type Reader<a href="https://golang.org/src/encoding/csv/reader.go?s=3358:5758#L98" class="source">Source</a>  </h2> <p> A Reader reads records from a CSV-encoded file. </p> <p> As returned by NewReader, a Reader expects input conforming to RFC 4180. The exported fields can be changed to customize the details before the first call to Read or ReadAll. </p> <p> The Reader converts all \r\n sequences in its input to plain \n, including in multiline field values, so that the returned data does not depend on which line-ending convention an input file uses. </p> <pre data-language="go">type Reader struct {
    // Comma is the field delimiter.
    // It is set to comma (',') by NewReader.
    // Comma must be a valid rune and must not be \r, \n,
    // or the Unicode replacement character (0xFFFD).
    Comma rune

    // Comment, if not 0, is the comment character. Lines beginning with the
    // Comment character without preceding whitespace are ignored.
    // With leading whitespace the Comment character becomes part of the
    // field, even if TrimLeadingSpace is true.
    // Comment must be a valid rune and must not be \r, \n,
    // or the Unicode replacement character (0xFFFD).
    // It must also not be equal to Comma.
    Comment rune

    // FieldsPerRecord is the number of expected fields per record.
    // If FieldsPerRecord is positive, Read requires each record to
    // have the given number of fields. If FieldsPerRecord is 0, Read sets it to
    // the number of fields in the first record, so that future records must
    // have the same field count. If FieldsPerRecord is negative, no check is
    // made and records may have a variable number of fields.
    FieldsPerRecord int

    // If LazyQuotes is true, a quote may appear in an unquoted field and a
    // non-doubled quote may appear in a quoted field.
    LazyQuotes bool

    // If TrimLeadingSpace is true, leading white space in a field is ignored.
    // This is done even if the field delimiter, Comma, is white space.
    TrimLeadingSpace bool

    // ReuseRecord controls whether calls to Read may return a slice sharing
    // the backing array of the previous call's returned slice for performance.
    // By default, each call to Read returns newly allocated memory owned by the caller.
    ReuseRecord bool // Go 1.9

    TrailingComma bool // Deprecated: No longer used.
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_Reader"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"strings"
)

func main() {
	in := `first_name,last_name,username
"Rob","Pike",rob
Ken,Thompson,ken
"Robert","Griesemer","gri"
`
	r := csv.NewReader(strings.NewReader(in))

	for {
		record, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatal(err)
		}

		fmt.Println(record)
	}
}
</pre>      <h4 id="example_Reader_options"> <span class="text">Example (Options)</span>
</h4> <p>This example shows how csv.Reader can be configured to handle other types of CSV files. </p> <pre class="play" data-language="go">package main

import (
	"encoding/csv"
	"fmt"
	"log"
	"strings"
)

func main() {
	in := `first_name;last_name;username
"Rob";"Pike";rob
# lines beginning with a # character are ignored
Ken;Thompson;ken
"Robert";"Griesemer";"gri"
`
	r := csv.NewReader(strings.NewReader(in))
	r.Comma = ';'
	r.Comment = '#'

	records, err := r.ReadAll()
	if err != nil {
		log.Fatal(err)
	}

	fmt.Print(records)
}
</pre>   <h3 id="NewReader">func NewReader<a href="https://golang.org/src/encoding/csv/reader.go?s=5813:5848#L160" class="source">Source</a>  </h3> <pre data-language="go">func NewReader(r io.Reader) *Reader</pre> <p> NewReader returns a new Reader that reads from r. </p> <h3 id="Reader.Read">func (*Reader) Read<a href="https://golang.org/src/encoding/csv/reader.go?s=6353:6405#L175" class="source">Source</a>  </h3> <pre data-language="go">func (r *Reader) Read() (record []string, err error)</pre> <p> Read reads one record (a slice of fields) from r. If the record has an unexpected number of fields, Read returns the record along with the error ErrFieldCount. Except for that case, Read always returns either a non-nil record or a non-nil error, but not both. If there is no data left to be read, Read returns nil, io.EOF. If ReuseRecord is true, the returned slice may be shared between multiple calls to Read. </p> <h3 id="Reader.ReadAll">func (*Reader) ReadAll<a href="https://golang.org/src/encoding/csv/reader.go?s=6823:6881#L190" class="source">Source</a>  </h3> <pre data-language="go">func (r *Reader) ReadAll() (records [][]string, err error)</pre> <p> ReadAll reads all the remaining records from r. Each record is a slice of fields. A successful call returns err == nil, not err == io.EOF. Because ReadAll is defined to read until EOF, it does not treat end of file as an error to be reported. </p>    <h4 id="example_Reader_ReadAll"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/csv"
	"fmt"
	"log"
	"strings"
)

func main() {
	in := `first_name,last_name,username
"Rob","Pike",rob
Ken,Thompson,ken
"Robert","Griesemer","gri"
`
	r := csv.NewReader(strings.NewReader(in))

	records, err := r.ReadAll()
	if err != nil {
		log.Fatal(err)
	}

	fmt.Print(records)
}
</pre>   <h2 id="Writer">type Writer<a href="https://golang.org/src/encoding/csv/writer.go?s=913:1074#L20" class="source">Source</a>  </h2> <p> A Writer writes records using CSV encoding. </p> <p> As returned by NewWriter, a Writer writes records terminated by a newline and uses ',' as the field delimiter. The exported fields can be changed to customize the details before the first call to Write or WriteAll. </p> <p> Comma is the field delimiter. </p> <p> If UseCRLF is true, the Writer ends each output line with \r\n instead of \n. </p> <p> The writes of individual records are buffered. After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer. Any errors that occurred should be checked by calling the Error method. </p> <pre data-language="go">type Writer struct {
    Comma   rune // Field delimiter (set to ',' by NewWriter)
    UseCRLF bool // True to use \r\n as the line terminator
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_Writer"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/csv"
	"log"
	"os"
)

func main() {
	records := [][]string{
		{"first_name", "last_name", "username"},
		{"Rob", "Pike", "rob"},
		{"Ken", "Thompson", "ken"},
		{"Robert", "Griesemer", "gri"},
	}

	w := csv.NewWriter(os.Stdout)

	for _, record := range records {
		if err := w.Write(record); err != nil {
			log.Fatalln("error writing record to csv:", err)
		}
	}

	// Write any buffered data to the underlying writer (standard output).
	w.Flush()

	if err := w.Error(); err != nil {
		log.Fatal(err)
	}
}
</pre>   <h3 id="NewWriter">func NewWriter<a href="https://golang.org/src/encoding/csv/writer.go?s=1128:1163#L27" class="source">Source</a>  </h3> <pre data-language="go">func NewWriter(w io.Writer) *Writer</pre> <p> NewWriter returns a new Writer that writes to w. </p> <h3 id="Writer.Error">func (*Writer) Error<a href="https://golang.org/src/encoding/csv/writer.go?s=3196:3226#L118" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (w *Writer) Error() error</pre> <p> Error reports any error that has occurred during a previous Write or Flush. </p> <h3 id="Writer.Flush">func (*Writer) Flush<a href="https://golang.org/src/encoding/csv/writer.go?s=3074:3098#L113" class="source">Source</a>  </h3> <pre data-language="go">func (w *Writer) Flush()</pre> <p> Flush writes any buffered data to the underlying io.Writer. To check if an error occurred during the Flush, call Error. </p> <h3 id="Writer.Write">func (*Writer) Write<a href="https://golang.org/src/encoding/csv/writer.go?s=1503:1548#L38" class="source">Source</a>  </h3> <pre data-language="go">func (w *Writer) Write(record []string) error</pre> <p> Write writes a single CSV record to w along with any necessary quoting. A record is a slice of strings with each string being one field. Writes are buffered, so Flush must eventually be called to ensure that the record is written to the underlying io.Writer. </p> <h3 id="Writer.WriteAll">func (*Writer) WriteAll<a href="https://golang.org/src/encoding/csv/writer.go?s=3388:3439#L125" class="source">Source</a>  </h3> <pre data-language="go">func (w *Writer) WriteAll(records [][]string) error</pre> <p> WriteAll writes multiple CSV records to w using Write and then calls Flush, returning any error from the Flush. </p>    <h4 id="example_Writer_WriteAll"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"encoding/csv"
	"log"
	"os"
)

func main() {
	records := [][]string{
		{"first_name", "last_name", "username"},
		{"Rob", "Pike", "rob"},
		{"Ken", "Thompson", "ken"},
		{"Robert", "Griesemer", "gri"},
	}

	w := csv.NewWriter(os.Stdout)
	w.WriteAll(records) // calls Flush internally

	if err := w.Error(); err != nil {
		log.Fatalln("error writing csv:", err)
	}
}
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/encoding/csv/" class="_attribution-link">https://golang.org/pkg/encoding/csv/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
