
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Go&#47;ast - Go - W3cubDocs</title>
  
  <meta name="description" content=" Package ast declares the types used to represent syntax trees for Go packages. ">
  <meta name="keywords" content="package, ast, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/go/go/ast/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _go">
				
				
<h1> Package ast  </h1>    <ul id="short-nav">
<li><code>import "go/ast"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p> Package ast declares the types used to represent syntax trees for Go packages. </p>      <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#FileExports">func FileExports(src *File) bool</a></li>
<li><a href="#FilterDecl">func FilterDecl(decl Decl, f Filter) bool</a></li>
<li><a href="#FilterFile">func FilterFile(src *File, f Filter) bool</a></li>
<li><a href="#FilterPackage">func FilterPackage(pkg *Package, f Filter) bool</a></li>
<li><a href="#Fprint">func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) error</a></li>
<li><a href="#Inspect">func Inspect(node Node, f func(Node) bool)</a></li>
<li><a href="#IsExported">func IsExported(name string) bool</a></li>
<li><a href="#NotNilFilter">func NotNilFilter(_ string, v reflect.Value) bool</a></li>
<li><a href="#PackageExports">func PackageExports(pkg *Package) bool</a></li>
<li><a href="#Print">func Print(fset *token.FileSet, x interface{}) error</a></li>
<li><a href="#SortImports">func SortImports(fset *token.FileSet, f *File)</a></li>
<li><a href="#Walk">func Walk(v Visitor, node Node)</a></li>
<li><a href="#ArrayType">type ArrayType</a></li>
<li> <a href="#ArrayType.End">func (x *ArrayType) End() token.Pos</a>
</li>
<li> <a href="#ArrayType.Pos">func (x *ArrayType) Pos() token.Pos</a>
</li>
<li><a href="#AssignStmt">type AssignStmt</a></li>
<li> <a href="#AssignStmt.End">func (s *AssignStmt) End() token.Pos</a>
</li>
<li> <a href="#AssignStmt.Pos">func (s *AssignStmt) Pos() token.Pos</a>
</li>
<li><a href="#BadDecl">type BadDecl</a></li>
<li> <a href="#BadDecl.End">func (d *BadDecl) End() token.Pos</a>
</li>
<li> <a href="#BadDecl.Pos">func (d *BadDecl) Pos() token.Pos</a>
</li>
<li><a href="#BadExpr">type BadExpr</a></li>
<li> <a href="#BadExpr.End">func (x *BadExpr) End() token.Pos</a>
</li>
<li> <a href="#BadExpr.Pos">func (x *BadExpr) Pos() token.Pos</a>
</li>
<li><a href="#BadStmt">type BadStmt</a></li>
<li> <a href="#BadStmt.End">func (s *BadStmt) End() token.Pos</a>
</li>
<li> <a href="#BadStmt.Pos">func (s *BadStmt) Pos() token.Pos</a>
</li>
<li><a href="#BasicLit">type BasicLit</a></li>
<li> <a href="#BasicLit.End">func (x *BasicLit) End() token.Pos</a>
</li>
<li> <a href="#BasicLit.Pos">func (x *BasicLit) Pos() token.Pos</a>
</li>
<li><a href="#BinaryExpr">type BinaryExpr</a></li>
<li> <a href="#BinaryExpr.End">func (x *BinaryExpr) End() token.Pos</a>
</li>
<li> <a href="#BinaryExpr.Pos">func (x *BinaryExpr) Pos() token.Pos</a>
</li>
<li><a href="#BlockStmt">type BlockStmt</a></li>
<li> <a href="#BlockStmt.End">func (s *BlockStmt) End() token.Pos</a>
</li>
<li> <a href="#BlockStmt.Pos">func (s *BlockStmt) Pos() token.Pos</a>
</li>
<li><a href="#BranchStmt">type BranchStmt</a></li>
<li> <a href="#BranchStmt.End">func (s *BranchStmt) End() token.Pos</a>
</li>
<li> <a href="#BranchStmt.Pos">func (s *BranchStmt) Pos() token.Pos</a>
</li>
<li><a href="#CallExpr">type CallExpr</a></li>
<li> <a href="#CallExpr.End">func (x *CallExpr) End() token.Pos</a>
</li>
<li> <a href="#CallExpr.Pos">func (x *CallExpr) Pos() token.Pos</a>
</li>
<li><a href="#CaseClause">type CaseClause</a></li>
<li> <a href="#CaseClause.End">func (s *CaseClause) End() token.Pos</a>
</li>
<li> <a href="#CaseClause.Pos">func (s *CaseClause) Pos() token.Pos</a>
</li>
<li><a href="#ChanDir">type ChanDir</a></li>
<li><a href="#ChanType">type ChanType</a></li>
<li> <a href="#ChanType.End">func (x *ChanType) End() token.Pos</a>
</li>
<li> <a href="#ChanType.Pos">func (x *ChanType) Pos() token.Pos</a>
</li>
<li><a href="#CommClause">type CommClause</a></li>
<li> <a href="#CommClause.End">func (s *CommClause) End() token.Pos</a>
</li>
<li> <a href="#CommClause.Pos">func (s *CommClause) Pos() token.Pos</a>
</li>
<li><a href="#Comment">type Comment</a></li>
<li> <a href="#Comment.End">func (c *Comment) End() token.Pos</a>
</li>
<li> <a href="#Comment.Pos">func (c *Comment) Pos() token.Pos</a>
</li>
<li><a href="#CommentGroup">type CommentGroup</a></li>
<li> <a href="#CommentGroup.End">func (g *CommentGroup) End() token.Pos</a>
</li>
<li> <a href="#CommentGroup.Pos">func (g *CommentGroup) Pos() token.Pos</a>
</li>
<li> <a href="#CommentGroup.Text">func (g *CommentGroup) Text() string</a>
</li>
<li><a href="#CommentMap">type CommentMap</a></li>
<li> <a href="#NewCommentMap">func NewCommentMap(fset *token.FileSet, node Node, comments []*CommentGroup) CommentMap</a>
</li>
<li> <a href="#CommentMap.Comments">func (cmap CommentMap) Comments() []*CommentGroup</a>
</li>
<li> <a href="#CommentMap.Filter">func (cmap CommentMap) Filter(node Node) CommentMap</a>
</li>
<li> <a href="#CommentMap.String">func (cmap CommentMap) String() string</a>
</li>
<li> <a href="#CommentMap.Update">func (cmap CommentMap) Update(old, new Node) Node</a>
</li>
<li><a href="#CompositeLit">type CompositeLit</a></li>
<li> <a href="#CompositeLit.End">func (x *CompositeLit) End() token.Pos</a>
</li>
<li> <a href="#CompositeLit.Pos">func (x *CompositeLit) Pos() token.Pos</a>
</li>
<li><a href="#Decl">type Decl</a></li>
<li><a href="#DeclStmt">type DeclStmt</a></li>
<li> <a href="#DeclStmt.End">func (s *DeclStmt) End() token.Pos</a>
</li>
<li> <a href="#DeclStmt.Pos">func (s *DeclStmt) Pos() token.Pos</a>
</li>
<li><a href="#DeferStmt">type DeferStmt</a></li>
<li> <a href="#DeferStmt.End">func (s *DeferStmt) End() token.Pos</a>
</li>
<li> <a href="#DeferStmt.Pos">func (s *DeferStmt) Pos() token.Pos</a>
</li>
<li><a href="#Ellipsis">type Ellipsis</a></li>
<li> <a href="#Ellipsis.End">func (x *Ellipsis) End() token.Pos</a>
</li>
<li> <a href="#Ellipsis.Pos">func (x *Ellipsis) Pos() token.Pos</a>
</li>
<li><a href="#EmptyStmt">type EmptyStmt</a></li>
<li> <a href="#EmptyStmt.End">func (s *EmptyStmt) End() token.Pos</a>
</li>
<li> <a href="#EmptyStmt.Pos">func (s *EmptyStmt) Pos() token.Pos</a>
</li>
<li><a href="#Expr">type Expr</a></li>
<li><a href="#ExprStmt">type ExprStmt</a></li>
<li> <a href="#ExprStmt.End">func (s *ExprStmt) End() token.Pos</a>
</li>
<li> <a href="#ExprStmt.Pos">func (s *ExprStmt) Pos() token.Pos</a>
</li>
<li><a href="#Field">type Field</a></li>
<li> <a href="#Field.End">func (f *Field) End() token.Pos</a>
</li>
<li> <a href="#Field.Pos">func (f *Field) Pos() token.Pos</a>
</li>
<li><a href="#FieldFilter">type FieldFilter</a></li>
<li><a href="#FieldList">type FieldList</a></li>
<li> <a href="#FieldList.End">func (f *FieldList) End() token.Pos</a>
</li>
<li> <a href="#FieldList.NumFields">func (f *FieldList) NumFields() int</a>
</li>
<li> <a href="#FieldList.Pos">func (f *FieldList) Pos() token.Pos</a>
</li>
<li><a href="#File">type File</a></li>
<li> <a href="#MergePackageFiles">func MergePackageFiles(pkg *Package, mode MergeMode) *File</a>
</li>
<li> <a href="#File.End">func (f *File) End() token.Pos</a>
</li>
<li> <a href="#File.Pos">func (f *File) Pos() token.Pos</a>
</li>
<li><a href="#Filter">type Filter</a></li>
<li><a href="#ForStmt">type ForStmt</a></li>
<li> <a href="#ForStmt.End">func (s *ForStmt) End() token.Pos</a>
</li>
<li> <a href="#ForStmt.Pos">func (s *ForStmt) Pos() token.Pos</a>
</li>
<li><a href="#FuncDecl">type FuncDecl</a></li>
<li> <a href="#FuncDecl.End">func (d *FuncDecl) End() token.Pos</a>
</li>
<li> <a href="#FuncDecl.Pos">func (d *FuncDecl) Pos() token.Pos</a>
</li>
<li><a href="#FuncLit">type FuncLit</a></li>
<li> <a href="#FuncLit.End">func (x *FuncLit) End() token.Pos</a>
</li>
<li> <a href="#FuncLit.Pos">func (x *FuncLit) Pos() token.Pos</a>
</li>
<li><a href="#FuncType">type FuncType</a></li>
<li> <a href="#FuncType.End">func (x *FuncType) End() token.Pos</a>
</li>
<li> <a href="#FuncType.Pos">func (x *FuncType) Pos() token.Pos</a>
</li>
<li><a href="#GenDecl">type GenDecl</a></li>
<li> <a href="#GenDecl.End">func (d *GenDecl) End() token.Pos</a>
</li>
<li> <a href="#GenDecl.Pos">func (d *GenDecl) Pos() token.Pos</a>
</li>
<li><a href="#GoStmt">type GoStmt</a></li>
<li> <a href="#GoStmt.End">func (s *GoStmt) End() token.Pos</a>
</li>
<li> <a href="#GoStmt.Pos">func (s *GoStmt) Pos() token.Pos</a>
</li>
<li><a href="#Ident">type Ident</a></li>
<li> <a href="#NewIdent">func NewIdent(name string) *Ident</a>
</li>
<li> <a href="#Ident.End">func (x *Ident) End() token.Pos</a>
</li>
<li> <a href="#Ident.IsExported">func (id *Ident) IsExported() bool</a>
</li>
<li> <a href="#Ident.Pos">func (x *Ident) Pos() token.Pos</a>
</li>
<li> <a href="#Ident.String">func (id *Ident) String() string</a>
</li>
<li><a href="#IfStmt">type IfStmt</a></li>
<li> <a href="#IfStmt.End">func (s *IfStmt) End() token.Pos</a>
</li>
<li> <a href="#IfStmt.Pos">func (s *IfStmt) Pos() token.Pos</a>
</li>
<li><a href="#ImportSpec">type ImportSpec</a></li>
<li> <a href="#ImportSpec.End">func (s *ImportSpec) End() token.Pos</a>
</li>
<li> <a href="#ImportSpec.Pos">func (s *ImportSpec) Pos() token.Pos</a>
</li>
<li><a href="#Importer">type Importer</a></li>
<li><a href="#IncDecStmt">type IncDecStmt</a></li>
<li> <a href="#IncDecStmt.End">func (s *IncDecStmt) End() token.Pos</a>
</li>
<li> <a href="#IncDecStmt.Pos">func (s *IncDecStmt) Pos() token.Pos</a>
</li>
<li><a href="#IndexExpr">type IndexExpr</a></li>
<li> <a href="#IndexExpr.End">func (x *IndexExpr) End() token.Pos</a>
</li>
<li> <a href="#IndexExpr.Pos">func (x *IndexExpr) Pos() token.Pos</a>
</li>
<li><a href="#InterfaceType">type InterfaceType</a></li>
<li> <a href="#InterfaceType.End">func (x *InterfaceType) End() token.Pos</a>
</li>
<li> <a href="#InterfaceType.Pos">func (x *InterfaceType) Pos() token.Pos</a>
</li>
<li><a href="#KeyValueExpr">type KeyValueExpr</a></li>
<li> <a href="#KeyValueExpr.End">func (x *KeyValueExpr) End() token.Pos</a>
</li>
<li> <a href="#KeyValueExpr.Pos">func (x *KeyValueExpr) Pos() token.Pos</a>
</li>
<li><a href="#LabeledStmt">type LabeledStmt</a></li>
<li> <a href="#LabeledStmt.End">func (s *LabeledStmt) End() token.Pos</a>
</li>
<li> <a href="#LabeledStmt.Pos">func (s *LabeledStmt) Pos() token.Pos</a>
</li>
<li><a href="#MapType">type MapType</a></li>
<li> <a href="#MapType.End">func (x *MapType) End() token.Pos</a>
</li>
<li> <a href="#MapType.Pos">func (x *MapType) Pos() token.Pos</a>
</li>
<li><a href="#MergeMode">type MergeMode</a></li>
<li><a href="#Node">type Node</a></li>
<li><a href="#ObjKind">type ObjKind</a></li>
<li> <a href="#ObjKind.String">func (kind ObjKind) String() string</a>
</li>
<li><a href="#Object">type Object</a></li>
<li> <a href="#NewObj">func NewObj(kind ObjKind, name string) *Object</a>
</li>
<li> <a href="#Object.Pos">func (obj *Object) Pos() token.Pos</a>
</li>
<li><a href="#Package">type Package</a></li>
<li> <a href="#NewPackage">func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error)</a>
</li>
<li> <a href="#Package.End">func (p *Package) End() token.Pos</a>
</li>
<li> <a href="#Package.Pos">func (p *Package) Pos() token.Pos</a>
</li>
<li><a href="#ParenExpr">type ParenExpr</a></li>
<li> <a href="#ParenExpr.End">func (x *ParenExpr) End() token.Pos</a>
</li>
<li> <a href="#ParenExpr.Pos">func (x *ParenExpr) Pos() token.Pos</a>
</li>
<li><a href="#RangeStmt">type RangeStmt</a></li>
<li> <a href="#RangeStmt.End">func (s *RangeStmt) End() token.Pos</a>
</li>
<li> <a href="#RangeStmt.Pos">func (s *RangeStmt) Pos() token.Pos</a>
</li>
<li><a href="#ReturnStmt">type ReturnStmt</a></li>
<li> <a href="#ReturnStmt.End">func (s *ReturnStmt) End() token.Pos</a>
</li>
<li> <a href="#ReturnStmt.Pos">func (s *ReturnStmt) Pos() token.Pos</a>
</li>
<li><a href="#Scope">type Scope</a></li>
<li> <a href="#NewScope">func NewScope(outer *Scope) *Scope</a>
</li>
<li> <a href="#Scope.Insert">func (s *Scope) Insert(obj *Object) (alt *Object)</a>
</li>
<li> <a href="#Scope.Lookup">func (s *Scope) Lookup(name string) *Object</a>
</li>
<li> <a href="#Scope.String">func (s *Scope) String() string</a>
</li>
<li><a href="#SelectStmt">type SelectStmt</a></li>
<li> <a href="#SelectStmt.End">func (s *SelectStmt) End() token.Pos</a>
</li>
<li> <a href="#SelectStmt.Pos">func (s *SelectStmt) Pos() token.Pos</a>
</li>
<li><a href="#SelectorExpr">type SelectorExpr</a></li>
<li> <a href="#SelectorExpr.End">func (x *SelectorExpr) End() token.Pos</a>
</li>
<li> <a href="#SelectorExpr.Pos">func (x *SelectorExpr) Pos() token.Pos</a>
</li>
<li><a href="#SendStmt">type SendStmt</a></li>
<li> <a href="#SendStmt.End">func (s *SendStmt) End() token.Pos</a>
</li>
<li> <a href="#SendStmt.Pos">func (s *SendStmt) Pos() token.Pos</a>
</li>
<li><a href="#SliceExpr">type SliceExpr</a></li>
<li> <a href="#SliceExpr.End">func (x *SliceExpr) End() token.Pos</a>
</li>
<li> <a href="#SliceExpr.Pos">func (x *SliceExpr) Pos() token.Pos</a>
</li>
<li><a href="#Spec">type Spec</a></li>
<li><a href="#StarExpr">type StarExpr</a></li>
<li> <a href="#StarExpr.End">func (x *StarExpr) End() token.Pos</a>
</li>
<li> <a href="#StarExpr.Pos">func (x *StarExpr) Pos() token.Pos</a>
</li>
<li><a href="#Stmt">type Stmt</a></li>
<li><a href="#StructType">type StructType</a></li>
<li> <a href="#StructType.End">func (x *StructType) End() token.Pos</a>
</li>
<li> <a href="#StructType.Pos">func (x *StructType) Pos() token.Pos</a>
</li>
<li><a href="#SwitchStmt">type SwitchStmt</a></li>
<li> <a href="#SwitchStmt.End">func (s *SwitchStmt) End() token.Pos</a>
</li>
<li> <a href="#SwitchStmt.Pos">func (s *SwitchStmt) Pos() token.Pos</a>
</li>
<li><a href="#TypeAssertExpr">type TypeAssertExpr</a></li>
<li> <a href="#TypeAssertExpr.End">func (x *TypeAssertExpr) End() token.Pos</a>
</li>
<li> <a href="#TypeAssertExpr.Pos">func (x *TypeAssertExpr) Pos() token.Pos</a>
</li>
<li><a href="#TypeSpec">type TypeSpec</a></li>
<li> <a href="#TypeSpec.End">func (s *TypeSpec) End() token.Pos</a>
</li>
<li> <a href="#TypeSpec.Pos">func (s *TypeSpec) Pos() token.Pos</a>
</li>
<li><a href="#TypeSwitchStmt">type TypeSwitchStmt</a></li>
<li> <a href="#TypeSwitchStmt.End">func (s *TypeSwitchStmt) End() token.Pos</a>
</li>
<li> <a href="#TypeSwitchStmt.Pos">func (s *TypeSwitchStmt) Pos() token.Pos</a>
</li>
<li><a href="#UnaryExpr">type UnaryExpr</a></li>
<li> <a href="#UnaryExpr.End">func (x *UnaryExpr) End() token.Pos</a>
</li>
<li> <a href="#UnaryExpr.Pos">func (x *UnaryExpr) Pos() token.Pos</a>
</li>
<li><a href="#ValueSpec">type ValueSpec</a></li>
<li> <a href="#ValueSpec.End">func (s *ValueSpec) End() token.Pos</a>
</li>
<li> <a href="#ValueSpec.Pos">func (s *ValueSpec) Pos() token.Pos</a>
</li>
<li><a href="#Visitor">type Visitor</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_CommentMap">CommentMap</a></dd> <dd><a class="exampleLink" href="#example_Inspect">Inspect</a></dd> <dd><a class="exampleLink" href="#example_Print">Print</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/go/ast/ast.go">ast.go</a> <a href="https://golang.org/src/go/ast/commentmap.go">commentmap.go</a> <a href="https://golang.org/src/go/ast/filter.go">filter.go</a> <a href="https://golang.org/src/go/ast/import.go">import.go</a> <a href="https://golang.org/src/go/ast/print.go">print.go</a> <a href="https://golang.org/src/go/ast/resolve.go">resolve.go</a> <a href="https://golang.org/src/go/ast/scope.go">scope.go</a> <a href="https://golang.org/src/go/ast/walk.go">walk.go</a>  </p>   <h2 id="FileExports">func FileExports<a href="https://golang.org/src/go/ast/filter.go?s=869:901#L18" class="source">Source</a>  </h2> <pre data-language="go">func FileExports(src *File) bool</pre> <p> FileExports trims the AST for a Go source file in place such that only exported nodes remain: all top-level identifiers which are not exported and their associated information (such as type, initial value, or function body) are removed. Non-exported fields and methods of exported types are stripped. The File.Comments list is not changed. </p> <p> FileExports reports whether there are exported declarations. </p> <h2 id="FilterDecl">func FilterDecl<a href="https://golang.org/src/go/ast/filter.go?s=5502:5543#L223" class="source">Source</a>  </h2> <pre data-language="go">func FilterDecl(decl Decl, f Filter) bool</pre> <p> FilterDecl trims the AST for a Go declaration in place by removing all names (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. </p> <p> FilterDecl reports whether there are any declared names left after filtering. </p> <h2 id="FilterFile">func FilterFile<a href="https://golang.org/src/go/ast/filter.go?s=6312:6353#L248" class="source">Source</a>  </h2> <pre data-language="go">func FilterFile(src *File, f Filter) bool</pre> <p> FilterFile trims the AST for a Go file in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. Import declarations are always removed. The File.Comments list is not changed. </p> <p> FilterFile reports whether there are any top-level declarations left after filtering. </p> <h2 id="FilterPackage">func FilterPackage<a href="https://golang.org/src/go/ast/filter.go?s=7128:7175#L275" class="source">Source</a>  </h2> <pre data-language="go">func FilterPackage(pkg *Package, f Filter) bool</pre> <p> FilterPackage trims the AST for a Go package in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost. </p> <p> FilterPackage reports whether there are any top-level declarations left after filtering. </p> <h2 id="Fprint">func Fprint<a href="https://golang.org/src/go/ast/print.go?s=1165:1246#L29" class="source">Source</a>  </h2> <pre data-language="go">func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) error</pre> <p> Fprint prints the (sub-)tree starting at AST node x to w. If fset != nil, position information is interpreted relative to that file set. Otherwise positions are printed as integer values (file set specific offsets). </p> <p> A non-nil FieldFilter f may be provided to control the output: struct fields for which f(fieldname, fieldvalue) is true are printed; all others are filtered from the output. Unexported struct fields are never printed. </p> <h2 id="Inspect">func Inspect<a href="https://golang.org/src/go/ast/walk.go?s=6291:6333#L374" class="source">Source</a>  </h2> <pre data-language="go">func Inspect(node Node, f func(Node) bool)</pre> <p> Inspect traverses an AST in depth-first order: It starts by calling f(node); node must not be nil. If f returns true, Inspect invokes f recursively for each of the non-nil children of node, followed by a call of f(nil). </p>    <h4 id="example_Inspect"> <span class="text">Example</span>
</h4> <p>This example demonstrates how to inspect the AST of a Go program. </p> <pre class="play" data-language="go">package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
)

func main() {
	// src is the input for which we want to inspect the AST.
	src := `
package p
const c = 1.0
var X = f(3.14)*2 + c
`

	// Create the AST by parsing src.
	fset := token.NewFileSet() // positions are relative to fset
	f, err := parser.ParseFile(fset, "src.go", src, 0)
	if err != nil {
		panic(err)
	}

	// Inspect the AST and print all identifiers and literals.
	ast.Inspect(f, func(n ast.Node) bool {
		var s string
		switch x := n.(type) {
		case *ast.BasicLit:
			s = x.Value
		case *ast.Ident:
			s = x.Name
		}
		if s != "" {
			fmt.Printf("%s:\t%s\n", fset.Position(n.Pos()), s)
		}
		return true
	})

}
</pre>   <h2 id="IsExported">func IsExported<a href="https://golang.org/src/go/ast/ast.go?s=17296:17329#L551" class="source">Source</a>  </h2> <pre data-language="go">func IsExported(name string) bool</pre> <p> IsExported reports whether name starts with an upper-case letter. </p> <h2 id="NotNilFilter">func NotNilFilter<a href="https://golang.org/src/go/ast/print.go?s=500:549#L12" class="source">Source</a>  </h2> <pre data-language="go">func NotNilFilter(_ string, v reflect.Value) bool</pre> <p> NotNilFilter returns true for field values that are not nil; it returns false otherwise. </p> <h2 id="PackageExports">func PackageExports<a href="https://golang.org/src/go/ast/filter.go?s=1258:1296#L29" class="source">Source</a>  </h2> <pre data-language="go">func PackageExports(pkg *Package) bool</pre> <p> PackageExports trims the AST for a Go package in place such that only exported nodes remain. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost. </p> <p> PackageExports reports whether there are exported declarations; it returns false otherwise. </p> <h2 id="Print">func Print<a href="https://golang.org/src/go/ast/print.go?s=1951:2003#L63" class="source">Source</a>  </h2> <pre data-language="go">func Print(fset *token.FileSet, x interface{}) error</pre> <p> Print prints x to standard output, skipping nil fields. Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter). </p>    <h4 id="example_Print"> <span class="text">Example</span>
</h4> <p>This example shows what an AST looks like when printed for debugging. </p> <pre class="play" data-language="go">package main

import (
	"go/ast"
	"go/parser"
	"go/token"
)

func main() {
	// src is the input for which we want to print the AST.
	src := `
package main
func main() {
	println("Hello, World!")
}
`

	// Create the AST by parsing src.
	fset := token.NewFileSet() // positions are relative to fset
	f, err := parser.ParseFile(fset, "", src, 0)
	if err != nil {
		panic(err)
	}

	// Print the AST.
	ast.Print(fset, f)

}
</pre>   <h2 id="SortImports">func SortImports<a href="https://golang.org/src/go/ast/import.go?s=378:424#L5" class="source">Source</a>  </h2> <pre data-language="go">func SortImports(fset *token.FileSet, f *File)</pre> <p> SortImports sorts runs of consecutive import lines in import blocks in f. It also removes duplicate imports when it is possible to do so without data loss. </p> <h2 id="Walk">func Walk<a href="https://golang.org/src/go/ast/walk.go?s=1311:1342#L41" class="source">Source</a>  </h2> <pre data-language="go">func Walk(v Visitor, node Node)</pre> <p> Walk traverses an AST in depth-first order: It starts by calling v.Visit(node); node must not be nil. If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non-nil children of node, followed by a call of w.Visit(nil). </p> <h2 id="ArrayType">type ArrayType<a href="https://golang.org/src/go/ast/ast.go?s=11430:11604#L401" class="source">Source</a>  </h2> <p> An ArrayType node represents an array or slice type. </p> <pre data-language="go">type ArrayType struct {
    Lbrack token.Pos // position of "["
    Len    Expr      // Ellipsis node for [...]T array types, nil for slice types
    Elt    Expr      // element type
}
</pre> <h3 id="ArrayType.End">func (*ArrayType) End<a href="https://golang.org/src/go/ast/ast.go?s=15574:15609#L502" class="source">Source</a>  </h3> <pre data-language="go">func (x *ArrayType) End() token.Pos</pre> <h3 id="ArrayType.Pos">func (*ArrayType) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13956:13991#L469" class="source">Source</a>  </h3> <pre data-language="go">func (x *ArrayType) Pos() token.Pos</pre> <h2 id="AssignStmt">type AssignStmt<a href="https://golang.org/src/go/ast/ast.go?s=19189:19332#L624" class="source">Source</a>  </h2> <p> An AssignStmt node represents an assignment or a short variable declaration. </p> <pre data-language="go">type AssignStmt struct {
    Lhs    []Expr
    TokPos token.Pos   // position of Tok
    Tok    token.Token // assignment token, DEFINE
    Rhs    []Expr
}
</pre> <h3 id="AssignStmt.End">func (*AssignStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=24388:24424#L770" class="source">Source</a>  </h3> <pre data-language="go">func (s *AssignStmt) End() token.Pos</pre> <h3 id="AssignStmt.Pos">func (*AssignStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23054:23090#L741" class="source">Source</a>  </h3> <pre data-language="go">func (s *AssignStmt) Pos() token.Pos</pre> <h2 id="BadDecl">type BadDecl<a href="https://golang.org/src/go/ast/ast.go?s=29093:29170#L929" class="source">Source</a>  </h2> <p> A BadDecl node is a placeholder for a declaration containing syntax errors for which a correct declaration node cannot be created. </p> <pre data-language="go">type BadDecl struct {
    From, To token.Pos // position range of bad declaration
}
</pre> <h3 id="BadDecl.End">func (*BadDecl) End<a href="https://golang.org/src/go/ast/ast.go?s=30484:30517#L969" class="source">Source</a>  </h3> <pre data-language="go">func (d *BadDecl) End() token.Pos</pre> <h3 id="BadDecl.Pos">func (*BadDecl) Pos<a href="https://golang.org/src/go/ast/ast.go?s=30316:30349#L965" class="source">Source</a>  </h3> <pre data-language="go">func (d *BadDecl) Pos() token.Pos</pre> <h2 id="BadExpr">type BadExpr<a href="https://golang.org/src/go/ast/ast.go?s=7168:7244#L258" class="source">Source</a>  </h2> <p> A BadExpr node is a placeholder for an expression containing syntax errors for which a correct expression node cannot be created. </p> <pre data-language="go">type BadExpr struct {
    From, To token.Pos // position range of bad expression
}
</pre> <h3 id="BadExpr.End">func (*BadExpr) End<a href="https://golang.org/src/go/ast/ast.go?s=14455:14488#L481" class="source">Source</a>  </h3> <pre data-language="go">func (x *BadExpr) End() token.Pos</pre> <h3 id="BadExpr.Pos">func (*BadExpr) Pos<a href="https://golang.org/src/go/ast/ast.go?s=12951:12984#L448" class="source">Source</a>  </h3> <pre data-language="go">func (x *BadExpr) Pos() token.Pos</pre> <h2 id="BadStmt">type BadStmt<a href="https://golang.org/src/go/ast/ast.go?s=17957:18032#L575" class="source">Source</a>  </h2> <p> A BadStmt node is a placeholder for statements containing syntax errors for which no correct statement nodes can be created. </p> <pre data-language="go">type BadStmt struct {
    From, To token.Pos // position range of bad statement
}
</pre> <h3 id="BadStmt.End">func (*BadStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=23896:23929#L756" class="source">Source</a>  </h3> <pre data-language="go">func (s *BadStmt) End() token.Pos</pre> <h3 id="BadStmt.Pos">func (*BadStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=22611:22644#L734" class="source">Source</a>  </h3> <pre data-language="go">func (s *BadStmt) Pos() token.Pos</pre> <h2 id="BasicLit">type BasicLit<a href="https://golang.org/src/go/ast/ast.go?s=7750:8009#L278" class="source">Source</a>  </h2> <p> A BasicLit node represents a literal of basic type. </p> <pre data-language="go">type BasicLit struct {
    ValuePos token.Pos   // literal position
    Kind     token.Token // token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING
    Value    string      // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\x7f', "foo" or `\m\n\o`
}
</pre> <h3 id="BasicLit.End">func (*BasicLit) End<a href="https://golang.org/src/go/ast/ast.go?s=14709:14743#L489" class="source">Source</a>  </h3> <pre data-language="go">func (x *BasicLit) End() token.Pos</pre> <h3 id="BasicLit.Pos">func (*BasicLit) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13117:13151#L451" class="source">Source</a>  </h3> <pre data-language="go">func (x *BasicLit) Pos() token.Pos</pre> <h2 id="BinaryExpr">type BinaryExpr<a href="https://golang.org/src/go/ast/ast.go?s=10722:10887#L368" class="source">Source</a>  </h2> <p> A BinaryExpr node represents a binary expression. </p> <pre data-language="go">type BinaryExpr struct {
    X     Expr        // left operand
    OpPos token.Pos   // position of Op
    Op    token.Token // operator
    Y     Expr        // right operand
}
</pre> <h3 id="BinaryExpr.End">func (*BinaryExpr) End<a href="https://golang.org/src/go/ast/ast.go?s=15446:15482#L500" class="source">Source</a>  </h3> <pre data-language="go">func (x *BinaryExpr) End() token.Pos</pre> <h3 id="BinaryExpr.Pos">func (*BinaryExpr) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13830:13866#L467" class="source">Source</a>  </h3> <pre data-language="go">func (x *BinaryExpr) Pos() token.Pos</pre> <h2 id="BlockStmt">type BlockStmt<a href="https://golang.org/src/go/ast/ast.go?s=20117:20274#L659" class="source">Source</a>  </h2> <p> A BlockStmt node represents a braced statement list. </p> <pre data-language="go">type BlockStmt struct {
    Lbrace token.Pos // position of "{"
    List   []Stmt
    Rbrace token.Pos // position of "}", if any (may be absent due to syntax error)
}
</pre> <h3 id="BlockStmt.End">func (*BlockStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=24872:24907#L785" class="source">Source</a>  </h3> <pre data-language="go">func (s *BlockStmt) End() token.Pos</pre> <h3 id="BlockStmt.Pos">func (*BlockStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23360:23395#L746" class="source">Source</a>  </h3> <pre data-language="go">func (s *BlockStmt) Pos() token.Pos</pre> <h2 id="BranchStmt">type BranchStmt<a href="https://golang.org/src/go/ast/ast.go?s=19877:20057#L652" class="source">Source</a>  </h2> <p> A BranchStmt node represents a break, continue, goto, or fallthrough statement. </p> <pre data-language="go">type BranchStmt struct {
    TokPos token.Pos   // position of Tok
    Tok    token.Token // keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)
    Label  *Ident      // label name; or nil
}
</pre> <h3 id="BranchStmt.End">func (*BranchStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=24729:24765#L779" class="source">Source</a>  </h3> <pre data-language="go">func (s *BranchStmt) End() token.Pos</pre> <h3 id="BranchStmt.Pos">func (*BranchStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23299:23335#L745" class="source">Source</a>  </h3> <pre data-language="go">func (s *BranchStmt) Pos() token.Pos</pre> <h2 id="CallExpr">type CallExpr<a href="https://golang.org/src/go/ast/ast.go?s=9914:10186#L342" class="source">Source</a>  </h2> <p> A CallExpr node represents an expression followed by an argument list. </p> <pre data-language="go">type CallExpr struct {
    Fun      Expr      // function expression
    Lparen   token.Pos // position of "("
    Args     []Expr    // function arguments; or nil
    Ellipsis token.Pos // position of "..." (token.NoPos if there is no "...")
    Rparen   token.Pos // position of ")"
}
</pre> <h3 id="CallExpr.End">func (*CallExpr) End<a href="https://golang.org/src/go/ast/ast.go?s=15257:15291#L497" class="source">Source</a>  </h3> <pre data-language="go">func (x *CallExpr) End() token.Pos</pre> <h3 id="CallExpr.Pos">func (*CallExpr) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13647:13681#L464" class="source">Source</a>  </h3> <pre data-language="go">func (x *CallExpr) Pos() token.Pos</pre> <h2 id="CaseClause">type CaseClause<a href="https://golang.org/src/go/ast/ast.go?s=20604:20842#L675" class="source">Source</a>  </h2> <p> A CaseClause represents a case of an expression or type switch statement. </p> <pre data-language="go">type CaseClause struct {
    Case  token.Pos // position of "case" or "default" keyword
    List  []Expr    // list of expressions or types; nil means default case
    Colon token.Pos // position of ":"
    Body  []Stmt    // statement list; or nil
}
</pre> <h3 id="CaseClause.End">func (*CaseClause) End<a href="https://golang.org/src/go/ast/ast.go?s=25146:25182#L800" class="source">Source</a>  </h3> <pre data-language="go">func (s *CaseClause) End() token.Pos</pre> <h3 id="CaseClause.Pos">func (*CaseClause) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23478:23514#L748" class="source">Source</a>  </h3> <pre data-language="go">func (s *CaseClause) Pos() token.Pos</pre> <h2 id="ChanDir">type ChanDir<a href="https://golang.org/src/go/ast/ast.go?s=11185:11201#L388" class="source">Source</a>  </h2> <p> The direction of a channel type is indicated by a bit mask including one or both of the following constants. </p> <pre data-language="go">type ChanDir int</pre> <pre data-language="go">const (
    SEND ChanDir = 1 &lt;&lt; iota
    RECV
)</pre> <h2 id="ChanType">type ChanType<a href="https://golang.org/src/go/ast/ast.go?s=12645:12888#L438" class="source">Source</a>  </h2> <p> A ChanType node represents a channel type. </p> <pre data-language="go">type ChanType struct {
    Begin token.Pos // position of "chan" keyword or "&lt;-" (whichever comes first)
    Arrow token.Pos // position of "&lt;-" (token.NoPos if there is no "&lt;-"); added in Go 1.1
    Dir   ChanDir   // channel direction
    Value Expr      // value type
}
</pre> <h3 id="ChanType.End">func (*ChanType) End<a href="https://golang.org/src/go/ast/ast.go?s=15950:15984#L512" class="source">Source</a>  </h3> <pre data-language="go">func (x *ChanType) End() token.Pos</pre> <h3 id="ChanType.Pos">func (*ChanType) Pos<a href="https://golang.org/src/go/ast/ast.go?s=14395:14429#L479" class="source">Source</a>  </h3> <pre data-language="go">func (x *ChanType) Pos() token.Pos</pre> <h2 id="CommClause">type CommClause<a href="https://golang.org/src/go/ast/ast.go?s=21480:21715#L699" class="source">Source</a>  </h2> <p> A CommClause node represents a case of a select statement. </p> <pre data-language="go">type CommClause struct {
    Case  token.Pos // position of "case" or "default" keyword
    Comm  Stmt      // send or receive statement; nil means default case
    Colon token.Pos // position of ":"
    Body  []Stmt    // statement list; or nil
}
</pre> <h3 id="CommClause.End">func (*CommClause) End<a href="https://golang.org/src/go/ast/ast.go?s=25397:25433#L808" class="source">Source</a>  </h3> <pre data-language="go">func (s *CommClause) End() token.Pos</pre> <h3 id="CommClause.Pos">func (*CommClause) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23659:23695#L751" class="source">Source</a>  </h3> <pre data-language="go">func (s *CommClause) Pos() token.Pos</pre> <h2 id="Comment">type Comment<a href="https://golang.org/src/go/ast/ast.go?s=1803:1955#L50" class="source">Source</a>  </h2> <p> A Comment node represents a single //-style or /*-style comment. </p> <pre data-language="go">type Comment struct {
    Slash token.Pos // position of "/" starting the comment
    Text  string    // comment text (excluding '\n' for //-style comments)
}
</pre> <h3 id="Comment.End">func (*Comment) End<a href="https://golang.org/src/go/ast/ast.go?s=2010:2043#L56" class="source">Source</a>  </h3> <pre data-language="go">func (c *Comment) End() token.Pos</pre> <h3 id="Comment.Pos">func (*Comment) Pos<a href="https://golang.org/src/go/ast/ast.go?s=1957:1990#L55" class="source">Source</a>  </h3> <pre data-language="go">func (c *Comment) Pos() token.Pos</pre> <h2 id="CommentGroup">type CommentGroup<a href="https://golang.org/src/go/ast/ast.go?s=2201:2263#L61" class="source">Source</a>  </h2> <p> A CommentGroup represents a sequence of comments with no other tokens and no empty lines between. </p> <pre data-language="go">type CommentGroup struct {
    List []*Comment // len(List) &gt; 0
}
</pre> <h3 id="CommentGroup.End">func (*CommentGroup) End<a href="https://golang.org/src/go/ast/ast.go?s=2331:2369#L66" class="source">Source</a>  </h3> <pre data-language="go">func (g *CommentGroup) End() token.Pos</pre> <h3 id="CommentGroup.Pos">func (*CommentGroup) Pos<a href="https://golang.org/src/go/ast/ast.go?s=2265:2303#L65" class="source">Source</a>  </h3> <pre data-language="go">func (g *CommentGroup) Pos() token.Pos</pre> <h3 id="CommentGroup.Text">func (*CommentGroup) Text<a href="https://golang.org/src/go/ast/ast.go?s=3012:3048#L84" class="source">Source</a>  </h3> <pre data-language="go">func (g *CommentGroup) Text() string</pre> <p> Text returns the text of the comment. Comment markers (//, /*, and */), the first space of a line comment, and leading and trailing empty lines are removed. Comment directives like "//line" and "//go:noinline" are also removed. Multiple empty lines are reduced to one, and trailing space on lines is trimmed. Unless the result is empty, it is newline-terminated. </p> <h2 id="CommentMap">type CommentMap<a href="https://golang.org/src/go/ast/commentmap.go?s=932:972#L25" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h2> <p> A CommentMap maps an AST node to a list of comment groups associated with it. See NewCommentMap for a description of the association. </p> <pre data-language="go">type CommentMap map[Node][]*CommentGroup</pre>    <h4 id="example_CommentMap"> <span class="text">Example</span>
</h4> <p>This example illustrates how to remove a variable declaration in a Go program while maintaining correct comment association using an ast.CommentMap. </p> <pre class="play" data-language="go">package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
)

func main() {
	// src is the input for which we create the AST that we
	// are going to manipulate.
	src := `
// This is the package comment.
package main

// This comment is associated with the hello constant.
const hello = "Hello, World!" // line comment 1

// This comment is associated with the foo variable.
var foo = hello // line comment 2

// This comment is associated with the main function.
func main() {
	fmt.Println(hello) // line comment 3
}
`

	// Create the AST by parsing src.
	fset := token.NewFileSet() // positions are relative to fset
	f, err := parser.ParseFile(fset, "src.go", src, parser.ParseComments)
	if err != nil {
		panic(err)
	}

	// Create an ast.CommentMap from the ast.File's comments.
	// This helps keeping the association between comments
	// and AST nodes.
	cmap := ast.NewCommentMap(fset, f, f.Comments)

	// Remove the first variable declaration from the list of declarations.
	for i, decl := range f.Decls {
		if gen, ok := decl.(*ast.GenDecl); ok &amp;&amp; gen.Tok == token.VAR {
			copy(f.Decls[i:], f.Decls[i+1:])
			f.Decls = f.Decls[:len(f.Decls)-1]
			break
		}
	}

	// Use the comment map to filter comments that don't belong anymore
	// (the comments associated with the variable declaration), and create
	// the new comments list.
	f.Comments = cmap.Filter(f).Comments()

	// Print the modified AST.
	var buf bytes.Buffer
	if err := format.Node(&amp;buf, fset, f); err != nil {
		panic(err)
	}
	fmt.Printf("%s", buf.Bytes())

}
</pre>   <h3 id="NewCommentMap">func NewCommentMap<a href="https://golang.org/src/go/ast/commentmap.go?s=3964:4051#L133" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func NewCommentMap(fset *token.FileSet, node Node, comments []*CommentGroup) CommentMap</pre> <p> NewCommentMap creates a new comment map by associating comment groups of the comments list with the nodes of the AST specified by node. </p> <p> A comment group g is associated with a node n if: </p> <pre data-language="go">- g starts on the same line as n ends
- g starts on the line immediately following n, and there is
  at least one empty line after g and before the next node
- g starts before n and is not associated to the node before n
  via the previous rules
</pre> <p> NewCommentMap tries to associate a comment group to the "largest" node possible: For instance, if the comment is a line comment trailing an assignment, the comment is associated with the entire assignment rather than just the last operand in the assignment. </p> <h3 id="CommentMap.Comments">func (CommentMap) Comments<a href="https://golang.org/src/go/ast/commentmap.go?s=7690:7739#L262" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (cmap CommentMap) Comments() []*CommentGroup</pre> <p> Comments returns the list of comment groups in the comment map. The result is sorted in source order. </p> <h3 id="CommentMap.Filter">func (CommentMap) Filter<a href="https://golang.org/src/go/ast/commentmap.go?s=7379:7430#L248" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (cmap CommentMap) Filter(node Node) CommentMap</pre> <p> Filter returns a new comment map consisting of only those entries of cmap for which a corresponding node exists in the AST specified by node. </p> <h3 id="CommentMap.String">func (CommentMap) String<a href="https://golang.org/src/go/ast/commentmap.go?s=8595:8633#L307" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (cmap CommentMap) String() string</pre> <h3 id="CommentMap.Update">func (CommentMap) Update<a href="https://golang.org/src/go/ast/commentmap.go?s=7055:7104#L236" class="source">Source</a>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (cmap CommentMap) Update(old, new Node) Node</pre> <p> Update replaces an old node in the comment map with the new node and returns the new node. Comments that were associated with the old node are associated with the new node. </p> <h2 id="CompositeLit">type CompositeLit<a href="https://golang.org/src/go/ast/ast.go?s=8210:8510#L291" class="source">Source</a>  </h2> <p> A CompositeLit node represents a composite literal. </p> <pre data-language="go">type CompositeLit struct {
    Type       Expr      // literal type; or nil
    Lbrace     token.Pos // position of "{"
    Elts       []Expr    // list of composite elements; or nil
    Rbrace     token.Pos // position of "}"
    Incomplete bool      // true if (source) expressions are missing in the Elts list; added in Go 1.11
}
</pre> <h3 id="CompositeLit.End">func (*CompositeLit) End<a href="https://golang.org/src/go/ast/ast.go?s=14868:14906#L491" class="source">Source</a>  </h3> <pre data-language="go">func (x *CompositeLit) End() token.Pos</pre> <h3 id="CompositeLit.Pos">func (*CompositeLit) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13233:13271#L453" class="source">Source</a>  </h3> <pre data-language="go">func (x *CompositeLit) Pos() token.Pos</pre> <h2 id="Decl">type Decl<a href="https://golang.org/src/go/ast/ast.go?s=1599:1640#L41" class="source">Source</a>  </h2> <p> All declaration nodes implement the Decl interface. </p> <pre data-language="go">type Decl interface {
    Node
    // contains filtered or unexported methods
}</pre> <h2 id="DeclStmt">type DeclStmt<a href="https://golang.org/src/go/ast/ast.go?s=18101:18176#L580" class="source">Source</a>  </h2> <p> A DeclStmt node represents a declaration in a statement list. </p> <pre data-language="go">type DeclStmt struct {
    Decl Decl // *GenDecl with CONST, TYPE, or VAR token
}
</pre> <h3 id="DeclStmt.End">func (*DeclStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=23947:23981#L757" class="source">Source</a>  </h3> <pre data-language="go">func (s *DeclStmt) End() token.Pos</pre> <h3 id="DeclStmt.Pos">func (*DeclStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=22670:22704#L735" class="source">Source</a>  </h3> <pre data-language="go">func (s *DeclStmt) Pos() token.Pos</pre> <h2 id="DeferStmt">type DeferStmt<a href="https://golang.org/src/go/ast/ast.go?s=19514:19602#L638" class="source">Source</a>  </h2> <p> A DeferStmt node represents a defer statement. </p> <pre data-language="go">type DeferStmt struct {
    Defer token.Pos // position of "defer" keyword
    Call  *CallExpr
}
</pre> <h3 id="DeferStmt.End">func (*DeferStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=24523:24558#L772" class="source">Source</a>  </h3> <pre data-language="go">func (s *DeferStmt) End() token.Pos</pre> <h3 id="DeferStmt.Pos">func (*DeferStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23178:23213#L743" class="source">Source</a>  </h3> <pre data-language="go">func (s *DeferStmt) Pos() token.Pos</pre> <h2 id="Ellipsis">type Ellipsis<a href="https://golang.org/src/go/ast/ast.go?s=7552:7691#L272" class="source">Source</a>  </h2> <p> An Ellipsis node stands for the "..." type in a parameter list or the "..." length in an array type. </p> <pre data-language="go">type Ellipsis struct {
    Ellipsis token.Pos // position of "..."
    Elt      Expr      // ellipsis element type (parameter lists only); or nil
}
</pre> <h3 id="Ellipsis.End">func (*Ellipsis) End<a href="https://golang.org/src/go/ast/ast.go?s=14590:14624#L483" class="source">Source</a>  </h3> <pre data-language="go">func (x *Ellipsis) End() token.Pos</pre> <h3 id="Ellipsis.Pos">func (*Ellipsis) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13060:13094#L450" class="source">Source</a>  </h3> <pre data-language="go">func (x *Ellipsis) Pos() token.Pos</pre> <h2 id="EmptyStmt">type EmptyStmt<a href="https://golang.org/src/go/ast/ast.go?s=18361:18496#L588" class="source">Source</a>  </h2> <p> An EmptyStmt node represents an empty statement. The "position" of the empty statement is the position of the immediately following (explicit or implicit) semicolon. </p> <pre data-language="go">type EmptyStmt struct {
    Semicolon token.Pos // position of following ";"
    Implicit  bool      // if set, ";" was omitted in the source; added in Go 1.5
}
</pre> <h3 id="EmptyStmt.End">func (*EmptyStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=24006:24041#L758" class="source">Source</a>  </h3> <pre data-language="go">func (s *EmptyStmt) End() token.Pos</pre> <h3 id="EmptyStmt.Pos">func (*EmptyStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=22735:22770#L736" class="source">Source</a>  </h3> <pre data-language="go">func (s *EmptyStmt) Pos() token.Pos</pre> <h2 id="Expr">type Expr<a href="https://golang.org/src/go/ast/ast.go?s=1405:1446#L29" class="source">Source</a>  </h2> <p> All expression nodes implement the Expr interface. </p> <pre data-language="go">type Expr interface {
    Node
    // contains filtered or unexported methods
}</pre> <h2 id="ExprStmt">type ExprStmt<a href="https://golang.org/src/go/ast/ast.go?s=18733:18776#L603" class="source">Source</a>  </h2> <p> An ExprStmt node represents a (stand-alone) expression in a statement list. </p> <pre data-language="go">type ExprStmt struct {
    X Expr // expression
}
</pre> <h3 id="ExprStmt.End">func (*ExprStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=24188:24222#L765" class="source">Source</a>  </h3> <pre data-language="go">func (s *ExprStmt) End() token.Pos</pre> <h3 id="ExprStmt.Pos">func (*ExprStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=22865:22899#L738" class="source">Source</a>  </h3> <pre data-language="go">func (s *ExprStmt) Pos() token.Pos</pre> <h2 id="Field">type Field<a href="https://golang.org/src/go/ast/ast.go?s=5329:5618#L182" class="source">Source</a>  </h2> <p> A Field represents a Field declaration list in a struct type, a method list in an interface type, or a parameter/result declaration in a signature. Field.Names is nil for unnamed parameters (parameter lists which only contain types) and embedded struct fields. In the latter case, the field name is the type name. </p> <pre data-language="go">type Field struct {
    Doc     *CommentGroup // associated documentation; or nil
    Names   []*Ident      // field/method/parameter names; or nil
    Type    Expr          // field/method/parameter type
    Tag     *BasicLit     // field tag; or nil
    Comment *CommentGroup // line comments; or nil
}
</pre> <h3 id="Field.End">func (*Field) End<a href="https://golang.org/src/go/ast/ast.go?s=5730:5761#L197" class="source">Source</a>  </h3> <pre data-language="go">func (f *Field) End() token.Pos</pre> <h3 id="Field.Pos">func (*Field) Pos<a href="https://golang.org/src/go/ast/ast.go?s=5620:5651#L190" class="source">Source</a>  </h3> <pre data-language="go">func (f *Field) Pos() token.Pos</pre> <h2 id="FieldFilter">type FieldFilter<a href="https://golang.org/src/go/ast/print.go?s=343:403#L8" class="source">Source</a>  </h2> <p> A FieldFilter may be provided to Fprint to control the output. </p> <pre data-language="go">type FieldFilter func(name string, value reflect.Value) bool</pre> <h2 id="FieldList">type FieldList<a href="https://golang.org/src/go/ast/ast.go?s=5910:6112#L205" class="source">Source</a>  </h2> <p> A FieldList represents a list of Fields, enclosed by parentheses or braces. </p> <pre data-language="go">type FieldList struct {
    Opening token.Pos // position of opening parenthesis/brace, if any
    List    []*Field  // field list; or nil
    Closing token.Pos // position of closing parenthesis/brace, if any
}
</pre> <h3 id="FieldList.End">func (*FieldList) End<a href="https://golang.org/src/go/ast/ast.go?s=6367:6402#L223" class="source">Source</a>  </h3> <pre data-language="go">func (f *FieldList) End() token.Pos</pre> <h3 id="FieldList.NumFields">func (*FieldList) NumFields<a href="https://golang.org/src/go/ast/ast.go?s=6725:6760#L236" class="source">Source</a>  </h3> <pre data-language="go">func (f *FieldList) NumFields() int</pre> <p> NumFields returns the number of parameters or struct fields represented by a FieldList. </p> <h3 id="FieldList.Pos">func (*FieldList) Pos<a href="https://golang.org/src/go/ast/ast.go?s=6114:6149#L211" class="source">Source</a>  </h3> <pre data-language="go">func (f *FieldList) Pos() token.Pos</pre> <h2 id="File">type File<a href="https://golang.org/src/go/ast/ast.go?s=32088:32591#L1012" class="source">Source</a>  </h2> <p> A File node represents a Go source file. </p> <p> The Comments list contains all comments in the source file in order of appearance, including the comments that are pointed to from other nodes via Doc and Comment fields. </p> <p> For correct printing of source code containing comments (using packages go/format and go/printer), special care must be taken to update comments when a File's syntax tree is modified: For printing, comments are interspersed between tokens based on their position. If syntax tree nodes are removed or moved, relevant comments in their vicinity must also be removed (from the File.Comments list) or moved accordingly (by updating their positions). A CommentMap may be used to facilitate some of these operations. </p> <p> Whether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: Except for Doc and Comment comments directly associated with nodes, the remaining comments are "free-floating" (see also issues #18593, #20744). </p> <pre data-language="go">type File struct {
    Doc        *CommentGroup   // associated documentation; or nil
    Package    token.Pos       // position of "package" keyword
    Name       *Ident          // package name
    Decls      []Decl          // top-level declarations; or nil
    Scope      *Scope          // package scope (this file only)
    Imports    []*ImportSpec   // imports in this file
    Unresolved []*Ident        // unresolved identifiers in this file
    Comments   []*CommentGroup // list of all comments in the source file
}
</pre> <h3 id="MergePackageFiles">func MergePackageFiles<a href="https://golang.org/src/go/ast/filter.go?s=8888:8946#L334" class="source">Source</a>  </h3> <pre data-language="go">func MergePackageFiles(pkg *Package, mode MergeMode) *File</pre> <p> MergePackageFiles creates a file AST by merging the ASTs of the files belonging to a package. The mode flags control merging behavior. </p> <h3 id="File.End">func (*File) End<a href="https://golang.org/src/go/ast/ast.go?s=32645:32675#L1024" class="source">Source</a>  </h3> <pre data-language="go">func (f *File) End() token.Pos</pre> <h3 id="File.Pos">func (*File) Pos<a href="https://golang.org/src/go/ast/ast.go?s=32593:32623#L1023" class="source">Source</a>  </h3> <pre data-language="go">func (f *File) Pos() token.Pos</pre> <h2 id="Filter">type Filter<a href="https://golang.org/src/go/ast/filter.go?s=1451:1480#L36" class="source">Source</a>  </h2> <pre data-language="go">type Filter func(string) bool</pre> <h2 id="ForStmt">type ForStmt<a href="https://golang.org/src/go/ast/ast.go?s=21930:22157#L713" class="source">Source</a>  </h2> <p> A ForStmt represents a for statement. </p> <pre data-language="go">type ForStmt struct {
    For  token.Pos // position of "for" keyword
    Init Stmt      // initialization statement; or nil
    Cond Expr      // condition; or nil
    Post Stmt      // post iteration statement; or nil
    Body *BlockStmt
}
</pre> <h3 id="ForStmt.End">func (*ForStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=25579:25612#L815" class="source">Source</a>  </h3> <pre data-language="go">func (s *ForStmt) End() token.Pos</pre> <h3 id="ForStmt.Pos">func (*ForStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23779:23812#L753" class="source">Source</a>  </h3> <pre data-language="go">func (s *ForStmt) Pos() token.Pos</pre> <h2 id="FuncDecl">type FuncDecl<a href="https://golang.org/src/go/ast/ast.go?s=29899:30257#L954" class="source">Source</a>  </h2> <p> A FuncDecl node represents a function declaration. </p> <pre data-language="go">type FuncDecl struct {
    Doc  *CommentGroup // associated documentation; or nil
    Recv *FieldList    // receiver (methods); or nil (functions)
    Name *Ident        // function/method name
    Type *FuncType     // function signature: parameters, results, and position of "func" keyword
    Body *BlockStmt    // function body; or nil for external (non-Go) function
}
</pre> <h3 id="FuncDecl.End">func (*FuncDecl) End<a href="https://golang.org/src/go/ast/ast.go?s=30647:30681#L976" class="source">Source</a>  </h3> <pre data-language="go">func (d *FuncDecl) End() token.Pos</pre> <h3 id="FuncDecl.Pos">func (*FuncDecl) Pos<a href="https://golang.org/src/go/ast/ast.go?s=30424:30458#L967" class="source">Source</a>  </h3> <pre data-language="go">func (d *FuncDecl) Pos() token.Pos</pre> <h2 id="FuncLit">type FuncLit<a href="https://golang.org/src/go/ast/ast.go?s=8062:8151#L285" class="source">Source</a>  </h2> <p> A FuncLit node represents a function literal. </p> <pre data-language="go">type FuncLit struct {
    Type *FuncType  // function type
    Body *BlockStmt // function body
}
</pre> <h3 id="FuncLit.End">func (*FuncLit) End<a href="https://golang.org/src/go/ast/ast.go?s=14803:14836#L490" class="source">Source</a>  </h3> <pre data-language="go">func (x *FuncLit) End() token.Pos</pre> <h3 id="FuncLit.Pos">func (*FuncLit) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13174:13207#L452" class="source">Source</a>  </h3> <pre data-language="go">func (x *FuncLit) Pos() token.Pos</pre> <h2 id="FuncType">type FuncType<a href="https://golang.org/src/go/ast/ast.go?s=11975:12188#L417" class="source">Source</a>  </h2> <p> A FuncType node represents a function type. </p> <pre data-language="go">type FuncType struct {
    Func    token.Pos  // position of "func" keyword (token.NoPos if there is no "func")
    Params  *FieldList // (incoming) parameters; non-nil
    Results *FieldList // (outgoing) results; or nil
}
</pre> <h3 id="FuncType.End">func (*FuncType) End<a href="https://golang.org/src/go/ast/ast.go?s=15705:15739#L504" class="source">Source</a>  </h3> <pre data-language="go">func (x *FuncType) End() token.Pos</pre> <h3 id="FuncType.Pos">func (*FuncType) Pos<a href="https://golang.org/src/go/ast/ast.go?s=14078:14112#L471" class="source">Source</a>  </h3> <pre data-language="go">func (x *FuncType) Pos() token.Pos</pre> <h2 id="GenDecl">type GenDecl<a href="https://golang.org/src/go/ast/ast.go?s=29558:29841#L944" class="source">Source</a>  </h2> <p> A GenDecl node (generic declaration node) represents an import, constant, type or variable declaration. A valid Lparen position (Lparen.IsValid()) indicates a parenthesized declaration. </p> <p> Relationship between Tok value and Specs element type: </p> <pre data-language="go">token.IMPORT  *ImportSpec
token.CONST   *ValueSpec
token.TYPE    *TypeSpec
token.VAR     *ValueSpec
</pre> <pre data-language="go">type GenDecl struct {
    Doc    *CommentGroup // associated documentation; or nil
    TokPos token.Pos     // position of Tok
    Tok    token.Token   // IMPORT, CONST, TYPE, VAR
    Lparen token.Pos     // position of '(', if any
    Specs  []Spec
    Rparen token.Pos // position of ')', if any
}
</pre> <h3 id="GenDecl.End">func (*GenDecl) End<a href="https://golang.org/src/go/ast/ast.go?s=30534:30567#L970" class="source">Source</a>  </h3> <pre data-language="go">func (d *GenDecl) End() token.Pos</pre> <h3 id="GenDecl.Pos">func (*GenDecl) Pos<a href="https://golang.org/src/go/ast/ast.go?s=30369:30402#L966" class="source">Source</a>  </h3> <pre data-language="go">func (d *GenDecl) Pos() token.Pos</pre> <h2 id="GoStmt">type GoStmt<a href="https://golang.org/src/go/ast/ast.go?s=19380:19460#L632" class="source">Source</a>  </h2> <p> A GoStmt node represents a go statement. </p> <pre data-language="go">type GoStmt struct {
    Go   token.Pos // position of "go" keyword
    Call *CallExpr
}
</pre> <h3 id="GoStmt.End">func (*GoStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=24462:24494#L771" class="source">Source</a>  </h3> <pre data-language="go">func (s *GoStmt) End() token.Pos</pre> <h3 id="GoStmt.Pos">func (*GoStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23121:23153#L742" class="source">Source</a>  </h3> <pre data-language="go">func (s *GoStmt) Pos() token.Pos</pre> <h2 id="Ident">type Ident<a href="https://golang.org/src/go/ast/ast.go?s=7291:7436#L263" class="source">Source</a>  </h2> <p> An Ident node represents an identifier. </p> <pre data-language="go">type Ident struct {
    NamePos token.Pos // identifier position
    Name    string    // identifier name
    Obj     *Object   // denoted object; or nil
}
</pre> <h3 id="NewIdent">func NewIdent<a href="https://golang.org/src/go/ast/ast.go?s=17147:17180#L547" class="source">Source</a>  </h3> <pre data-language="go">func NewIdent(name string) *Ident</pre> <p> NewIdent creates a new Ident without position. Useful for ASTs generated by code other than the Go parser. </p> <h3 id="Ident.End">func (*Ident) End<a href="https://golang.org/src/go/ast/ast.go?s=14505:14536#L482" class="source">Source</a>  </h3> <pre data-language="go">func (x *Ident) End() token.Pos</pre> <h3 id="Ident.IsExported">func (*Ident) IsExported<a href="https://golang.org/src/go/ast/ast.go?s=17435:17469#L555" class="source">Source</a>  </h3> <pre data-language="go">func (id *Ident) IsExported() bool</pre> <p> IsExported reports whether id starts with an upper-case letter. </p> <h3 id="Ident.Pos">func (*Ident) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13004:13035#L449" class="source">Source</a>  </h3> <pre data-language="go">func (x *Ident) Pos() token.Pos</pre> <h3 id="Ident.String">func (*Ident) String<a href="https://golang.org/src/go/ast/ast.go?s=17508:17540#L557" class="source">Source</a>  </h3> <pre data-language="go">func (id *Ident) String() string</pre> <h2 id="IfStmt">type IfStmt<a href="https://golang.org/src/go/ast/ast.go?s=20324:20523#L666" class="source">Source</a>  </h2> <p> An IfStmt node represents an if statement. </p> <pre data-language="go">type IfStmt struct {
    If   token.Pos // position of "if" keyword
    Init Stmt      // initialization statement; or nil
    Cond Expr      // condition
    Body *BlockStmt
    Else Stmt // else branch; or nil
}
</pre> <h3 id="IfStmt.End">func (*IfStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=25043:25075#L794" class="source">Source</a>  </h3> <pre data-language="go">func (s *IfStmt) End() token.Pos</pre> <h3 id="IfStmt.Pos">func (*IfStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23421:23453#L747" class="source">Source</a>  </h3> <pre data-language="go">func (s *IfStmt) Pos() token.Pos</pre> <h2 id="ImportSpec">type ImportSpec<a href="https://golang.org/src/go/ast/ast.go?s=26953:27264#L857" class="source">Source</a>  </h2> <p> An ImportSpec node represents a single package import. </p> <pre data-language="go">type ImportSpec struct {
    Doc     *CommentGroup // associated documentation; or nil
    Name    *Ident        // local package name (including "."); or nil
    Path    *BasicLit     // import path
    Comment *CommentGroup // line comments; or nil
    EndPos  token.Pos     // end of spec (overrides Path.Pos if nonzero)
}
</pre> <h3 id="ImportSpec.End">func (*ImportSpec) End<a href="https://golang.org/src/go/ast/ast.go?s=28333:28369#L897" class="source">Source</a>  </h3> <pre data-language="go">func (s *ImportSpec) End() token.Pos</pre> <h3 id="ImportSpec.Pos">func (*ImportSpec) Pos<a href="https://golang.org/src/go/ast/ast.go?s=28101:28137#L888" class="source">Source</a>  </h3> <pre data-language="go">func (s *ImportSpec) Pos() token.Pos</pre> <h2 id="Importer">type Importer<a href="https://golang.org/src/go/ast/resolve.go?s=1751:1835#L53" class="source">Source</a>  </h2> <p> An Importer resolves import paths to package Objects. The imports map records the packages already imported, indexed by package id (canonical import path). An Importer must determine the canonical import path and check the map to see if it is already present in the imports map. If so, the Importer can return the map entry. Otherwise, the Importer should load the package data for the given path into a new *Object (pkg), record pkg in the imports map, and then return pkg. </p> <pre data-language="go">type Importer func(imports map[string]*Object, path string) (pkg *Object, err error)</pre> <h2 id="IncDecStmt">type IncDecStmt<a href="https://golang.org/src/go/ast/ast.go?s=18986:19097#L615" class="source">Source</a>  </h2> <p> An IncDecStmt node represents an increment or decrement statement. </p> <pre data-language="go">type IncDecStmt struct {
    X      Expr
    TokPos token.Pos   // position of Tok
    Tok    token.Token // INC or DEC
}
</pre> <h3 id="IncDecStmt.End">func (*IncDecStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=24310:24346#L767" class="source">Source</a>  </h3> <pre data-language="go">func (s *IncDecStmt) End() token.Pos</pre> <h3 id="IncDecStmt.Pos">func (*IncDecStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=22992:23028#L740" class="source">Source</a>  </h3> <pre data-language="go">func (s *IncDecStmt) Pos() token.Pos</pre> <h2 id="IndexExpr">type IndexExpr<a href="https://golang.org/src/go/ast/ast.go?s=8947:9116#L313" class="source">Source</a>  </h2> <p> An IndexExpr node represents an expression followed by an index. </p> <pre data-language="go">type IndexExpr struct {
    X      Expr      // expression
    Lbrack token.Pos // position of "["
    Index  Expr      // index expression
    Rbrack token.Pos // position of "]"
}
</pre> <h3 id="IndexExpr.End">func (*IndexExpr) End<a href="https://golang.org/src/go/ast/ast.go?s=15062:15097#L494" class="source">Source</a>  </h3> <pre data-language="go">func (x *IndexExpr) End() token.Pos</pre> <h3 id="IndexExpr.Pos">func (*IndexExpr) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13461:13496#L461" class="source">Source</a>  </h3> <pre data-language="go">func (x *IndexExpr) Pos() token.Pos</pre> <h2 id="InterfaceType">type InterfaceType<a href="https://golang.org/src/go/ast/ast.go?s=12247:12458#L424" class="source">Source</a>  </h2> <p> An InterfaceType node represents an interface type. </p> <pre data-language="go">type InterfaceType struct {
    Interface  token.Pos  // position of "interface" keyword
    Methods    *FieldList // list of methods
    Incomplete bool       // true if (source) methods are missing in the Methods list
}
</pre> <h3 id="InterfaceType.End">func (*InterfaceType) End<a href="https://golang.org/src/go/ast/ast.go?s=15818:15857#L510" class="source">Source</a>  </h3> <pre data-language="go">func (x *InterfaceType) End() token.Pos</pre> <h3 id="InterfaceType.Pos">func (*InterfaceType) Pos<a href="https://golang.org/src/go/ast/ast.go?s=14275:14314#L477" class="source">Source</a>  </h3> <pre data-language="go">func (x *InterfaceType) Pos() token.Pos</pre> <h2 id="KeyValueExpr">type KeyValueExpr<a href="https://golang.org/src/go/ast/ast.go?s=10976:11063#L378" class="source">Source</a>  </h2> <p> A KeyValueExpr node represents (key : value) pairs in composite literals. </p> <pre data-language="go">type KeyValueExpr struct {
    Key   Expr
    Colon token.Pos // position of ":"
    Value Expr
}
</pre> <h3 id="KeyValueExpr.End">func (*KeyValueExpr) End<a href="https://golang.org/src/go/ast/ast.go?s=15508:15546#L501" class="source">Source</a>  </h3> <pre data-language="go">func (x *KeyValueExpr) End() token.Pos</pre> <h3 id="KeyValueExpr.Pos">func (*KeyValueExpr) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13892:13930#L468" class="source">Source</a>  </h3> <pre data-language="go">func (x *KeyValueExpr) Pos() token.Pos</pre> <h2 id="LabeledStmt">type LabeledStmt<a href="https://golang.org/src/go/ast/ast.go?s=18554:18642#L594" class="source">Source</a>  </h2> <p> A LabeledStmt node represents a labeled statement. </p> <pre data-language="go">type LabeledStmt struct {
    Label *Ident
    Colon token.Pos // position of ":"
    Stmt  Stmt
}
</pre> <h3 id="LabeledStmt.End">func (*LabeledStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=24126:24163#L764" class="source">Source</a>  </h3> <pre data-language="go">func (s *LabeledStmt) End() token.Pos</pre> <h3 id="LabeledStmt.Pos">func (*LabeledStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=22799:22836#L737" class="source">Source</a>  </h3> <pre data-language="go">func (s *LabeledStmt) Pos() token.Pos</pre> <h2 id="MapType">type MapType<a href="https://golang.org/src/go/ast/ast.go?s=12503:12595#L431" class="source">Source</a>  </h2> <p> A MapType node represents a map type. </p> <pre data-language="go">type MapType struct {
    Map   token.Pos // position of "map" keyword
    Key   Expr
    Value Expr
}
</pre> <h3 id="MapType.End">func (*MapType) End<a href="https://golang.org/src/go/ast/ast.go?s=15885:15918#L511" class="source">Source</a>  </h3> <pre data-language="go">func (x *MapType) End() token.Pos</pre> <h3 id="MapType.Pos">func (*MapType) Pos<a href="https://golang.org/src/go/ast/ast.go?s=14338:14371#L478" class="source">Source</a>  </h3> <pre data-language="go">func (x *MapType) Pos() token.Pos</pre> <h2 id="MergeMode">type MergeMode<a href="https://golang.org/src/go/ast/filter.go?s=7588:7607#L293" class="source">Source</a>  </h2> <p> The MergeMode flags control the behavior of MergePackageFiles. </p> <pre data-language="go">type MergeMode uint</pre> <pre data-language="go">const (
    // If set, duplicate function declarations are excluded.
    FilterFuncDuplicates MergeMode = 1 &lt;&lt; iota
    // If set, comments that are not associated with a specific
    // AST node (as Doc or Comment) are excluded.
    FilterUnassociatedComments
    // If set, duplicate import declarations are excluded.
    FilterImportDuplicates
)</pre> <h2 id="Node">type Node<a href="https://golang.org/src/go/ast/ast.go?s=1181:1349#L23" class="source">Source</a>  </h2> <p> All node types implement the Node interface. </p> <pre data-language="go">type Node interface {
    Pos() token.Pos // position of first character belonging to the node
    End() token.Pos // position of first character immediately after the node
}</pre> <h2 id="ObjKind">type ObjKind<a href="https://golang.org/src/go/ast/scope.go?s=3516:3532#L127" class="source">Source</a>  </h2> <p> ObjKind describes what an object represents. </p> <pre data-language="go">type ObjKind int</pre> <p> The list of possible Object kinds. </p> <pre data-language="go">const (
    Bad ObjKind = iota // for error handling
    Pkg                // package
    Con                // constant
    Typ                // type
    Var                // variable
    Fun                // function or method
    Lbl                // label
)</pre> <h3 id="ObjKind.String">func (ObjKind) String<a href="https://golang.org/src/go/ast/scope.go?s=3957:3992#L150" class="source">Source</a>  </h3> <pre data-language="go">func (kind ObjKind) String() string</pre> <h2 id="Object">type Object<a href="https://golang.org/src/go/ast/scope.go?s=2004:2291#L66" class="source">Source</a>  </h2> <p> An Object describes a named language entity such as a package, constant, type, variable, function (incl. methods), or label. </p> <p> The Data fields contains object-specific data: </p> <pre data-language="go">Kind    Data type         Data value
Pkg     *Scope            package scope
Con     int               iota for the respective declaration
</pre> <pre data-language="go">type Object struct {
    Kind ObjKind
    Name string      // declared name
    Decl interface{} // corresponding Field, XxxSpec, FuncDecl, LabeledStmt, AssignStmt, Scope; or nil
    Data interface{} // object-specific data; or nil
    Type interface{} // placeholder for type information; may be nil
}
</pre> <h3 id="NewObj">func NewObj<a href="https://golang.org/src/go/ast/scope.go?s=2350:2396#L75" class="source">Source</a>  </h3> <pre data-language="go">func NewObj(kind ObjKind, name string) *Object</pre> <p> NewObj creates a new object of a given kind and name. </p> <h3 id="Object.Pos">func (*Object) Pos<a href="https://golang.org/src/go/ast/scope.go?s=2623:2657#L82" class="source">Source</a>  </h3> <pre data-language="go">func (obj *Object) Pos() token.Pos</pre> <p> Pos computes the source position of the declaration of an object name. The result may be an invalid position if it cannot be computed (obj.Decl may be nil or not correct). </p> <h2 id="Package">type Package<a href="https://golang.org/src/go/ast/ast.go?s=32857:33112#L1034" class="source">Source</a>  </h2> <p> A Package node represents a set of source files collectively building a Go package. </p> <pre data-language="go">type Package struct {
    Name    string             // package name
    Scope   *Scope             // package scope across all files
    Imports map[string]*Object // map of package id -&gt; package object
    Files   map[string]*File   // Go source files by filename
}
</pre> <h3 id="NewPackage">func NewPackage<a href="https://golang.org/src/go/ast/resolve.go?s=2445:2559#L64" class="source">Source</a>  </h3> <pre data-language="go">func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error)</pre> <p> NewPackage creates a new Package node from a set of File nodes. It resolves unresolved identifiers across files and updates each file's Unresolved list accordingly. If a non-nil importer and universe scope are provided, they are used to resolve identifiers not declared in any of the package files. Any remaining unresolved identifiers are reported as undeclared. If the files belong to different packages, one package name is selected and files with different package names are reported and then ignored. The result is a package node and a scanner.ErrorList if there were errors. </p> <h3 id="Package.End">func (*Package) End<a href="https://golang.org/src/go/ast/ast.go?s=33171:33204#L1042" class="source">Source</a>  </h3> <pre data-language="go">func (p *Package) End() token.Pos</pre> <h3 id="Package.Pos">func (*Package) Pos<a href="https://golang.org/src/go/ast/ast.go?s=33114:33147#L1041" class="source">Source</a>  </h3> <pre data-language="go">func (p *Package) Pos() token.Pos</pre> <h2 id="ParenExpr">type ParenExpr<a href="https://golang.org/src/go/ast/ast.go?s=8573:8717#L300" class="source">Source</a>  </h2> <p> A ParenExpr node represents a parenthesized expression. </p> <pre data-language="go">type ParenExpr struct {
    Lparen token.Pos // position of "("
    X      Expr      // parenthesized expression
    Rparen token.Pos // position of ")"
}
</pre> <h3 id="ParenExpr.End">func (*ParenExpr) End<a href="https://golang.org/src/go/ast/ast.go?s=14933:14968#L492" class="source">Source</a>  </h3> <pre data-language="go">func (x *ParenExpr) End() token.Pos</pre> <h3 id="ParenExpr.Pos">func (*ParenExpr) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13338:13373#L459" class="source">Source</a>  </h3> <pre data-language="go">func (x *ParenExpr) Pos() token.Pos</pre> <h2 id="RangeStmt">type RangeStmt<a href="https://golang.org/src/go/ast/ast.go?s=22224:22554#L722" class="source">Source</a>  </h2> <p> A RangeStmt represents a for statement with a range clause. </p> <pre data-language="go">type RangeStmt struct {
    For        token.Pos   // position of "for" keyword
    Key, Value Expr        // Key, Value may be nil
    TokPos     token.Pos   // position of Tok; invalid if Key == nil
    Tok        token.Token // ILLEGAL if Key == nil, ASSIGN, DEFINE
    X          Expr        // value to range over
    Body       *BlockStmt
}
</pre> <h3 id="RangeStmt.End">func (*RangeStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=25640:25675#L816" class="source">Source</a>  </h3> <pre data-language="go">func (s *RangeStmt) End() token.Pos</pre> <h3 id="RangeStmt.Pos">func (*RangeStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23837:23872#L754" class="source">Source</a>  </h3> <pre data-language="go">func (s *RangeStmt) Pos() token.Pos</pre> <h2 id="ReturnStmt">type ReturnStmt<a href="https://golang.org/src/go/ast/ast.go?s=19658:19782#L644" class="source">Source</a>  </h2> <p> A ReturnStmt node represents a return statement. </p> <pre data-language="go">type ReturnStmt struct {
    Return  token.Pos // position of "return" keyword
    Results []Expr    // result expressions; or nil
}
</pre> <h3 id="ReturnStmt.End">func (*ReturnStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=24584:24620#L773" class="source">Source</a>  </h3> <pre data-language="go">func (s *ReturnStmt) End() token.Pos</pre> <h3 id="ReturnStmt.Pos">func (*ReturnStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23238:23274#L744" class="source">Source</a>  </h3> <pre data-language="go">func (s *ReturnStmt) Pos() token.Pos</pre> <h2 id="Scope">type Scope<a href="https://golang.org/src/go/ast/scope.go?s=419:484#L9" class="source">Source</a>  </h2> <p> A Scope maintains the set of named language entities declared in the scope and a link to the immediately surrounding (outer) scope. </p> <pre data-language="go">type Scope struct {
    Outer   *Scope
    Objects map[string]*Object
}
</pre> <h3 id="NewScope">func NewScope<a href="https://golang.org/src/go/ast/scope.go?s=545:579#L15" class="source">Source</a>  </h3> <pre data-language="go">func NewScope(outer *Scope) *Scope</pre> <p> NewScope creates a new scope nested in the outer scope. </p> <h3 id="Scope.Insert">func (*Scope) Insert<a href="https://golang.org/src/go/ast/scope.go?s=1120:1169#L33" class="source">Source</a>  </h3> <pre data-language="go">func (s *Scope) Insert(obj *Object) (alt *Object)</pre> <p> Insert attempts to insert a named object obj into the scope s. If the scope already contains an object alt with the same name, Insert leaves the scope unchanged and returns alt. Otherwise it inserts obj and returns nil. </p> <h3 id="Scope.Lookup">func (*Scope) Lookup<a href="https://golang.org/src/go/ast/scope.go?s=812:855#L24" class="source">Source</a>  </h3> <pre data-language="go">func (s *Scope) Lookup(name string) *Object</pre> <p> Lookup returns the object with the given name if it is found in scope s, otherwise it returns nil. Outer scopes are ignored. </p> <h3 id="Scope.String">func (*Scope) String<a href="https://golang.org/src/go/ast/scope.go?s=1279:1310#L41" class="source">Source</a>  </h3> <pre data-language="go">func (s *Scope) String() string</pre> <p> Debugging support </p> <h2 id="SelectStmt">type SelectStmt<a href="https://golang.org/src/go/ast/ast.go?s=21771:21885#L707" class="source">Source</a>  </h2> <p> A SelectStmt node represents a select statement. </p> <pre data-language="go">type SelectStmt struct {
    Select token.Pos  // position of "select" keyword
    Body   *BlockStmt // CommClauses only
}
</pre> <h3 id="SelectStmt.End">func (*SelectStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=25518:25554#L814" class="source">Source</a>  </h3> <pre data-language="go">func (s *SelectStmt) End() token.Pos</pre> <h3 id="SelectStmt.Pos">func (*SelectStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23718:23754#L752" class="source">Source</a>  </h3> <pre data-language="go">func (s *SelectStmt) Pos() token.Pos</pre> <h2 id="SelectorExpr">type SelectorExpr<a href="https://golang.org/src/go/ast/ast.go?s=8793:8875#L307" class="source">Source</a>  </h2> <p> A SelectorExpr node represents an expression followed by a selector. </p> <pre data-language="go">type SelectorExpr struct {
    X   Expr   // expression
    Sel *Ident // field selector
}
</pre> <h3 id="SelectorExpr.End">func (*SelectorExpr) End<a href="https://golang.org/src/go/ast/ast.go?s=14998:15036#L493" class="source">Source</a>  </h3> <pre data-language="go">func (x *SelectorExpr) End() token.Pos</pre> <h3 id="SelectorExpr.Pos">func (*SelectorExpr) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13399:13437#L460" class="source">Source</a>  </h3> <pre data-language="go">func (x *SelectorExpr) Pos() token.Pos</pre> <h2 id="SendStmt">type SendStmt<a href="https://golang.org/src/go/ast/ast.go?s=18828:18912#L608" class="source">Source</a>  </h2> <p> A SendStmt node represents a send statement. </p> <pre data-language="go">type SendStmt struct {
    Chan  Expr
    Arrow token.Pos // position of "&lt;-"
    Value Expr
}
</pre> <h3 id="SendStmt.End">func (*SendStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=24247:24281#L766" class="source">Source</a>  </h3> <pre data-language="go">func (s *SendStmt) End() token.Pos</pre> <h3 id="SendStmt.Pos">func (*SendStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=22927:22961#L739" class="source">Source</a>  </h3> <pre data-language="go">func (s *SendStmt) Pos() token.Pos</pre> <h2 id="SliceExpr">type SliceExpr<a href="https://golang.org/src/go/ast/ast.go?s=9192:9541#L321" class="source">Source</a>  </h2> <p> A SliceExpr node represents an expression followed by slice indices. </p> <pre data-language="go">type SliceExpr struct {
    X      Expr      // expression
    Lbrack token.Pos // position of "["
    Low    Expr      // begin of slice range; or nil
    High   Expr      // end of slice range; or nil
    Max    Expr      // maximum capacity of slice; or nil; added in Go 1.2
    Slice3 bool      // true if 3-index slice (2 colons present); added in Go 1.2
    Rbrack token.Pos // position of "]"
}
</pre> <h3 id="SliceExpr.End">func (*SliceExpr) End<a href="https://golang.org/src/go/ast/ast.go?s=15127:15162#L495" class="source">Source</a>  </h3> <pre data-language="go">func (x *SliceExpr) End() token.Pos</pre> <h3 id="SliceExpr.Pos">func (*SliceExpr) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13523:13558#L462" class="source">Source</a>  </h3> <pre data-language="go">func (x *SliceExpr) Pos() token.Pos</pre> <h2 id="Spec">type Spec<a href="https://golang.org/src/go/ast/ast.go?s=26852:26891#L851" class="source">Source</a>  </h2> <p> The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec. </p> <pre data-language="go">type Spec interface {
    Node
    // contains filtered or unexported methods
}</pre> <h2 id="StarExpr">type StarExpr<a href="https://golang.org/src/go/ast/ast.go?s=10338:10422#L353" class="source">Source</a>  </h2> <p> A StarExpr node represents an expression of the form "*" Expression. Semantically it could be a unary "*" expression, or a pointer type. </p> <pre data-language="go">type StarExpr struct {
    Star token.Pos // position of "*"
    X    Expr      // operand
}
</pre> <h3 id="StarExpr.End">func (*StarExpr) End<a href="https://golang.org/src/go/ast/ast.go?s=15322:15356#L498" class="source">Source</a>  </h3> <pre data-language="go">func (x *StarExpr) End() token.Pos</pre> <h3 id="StarExpr.Pos">func (*StarExpr) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13711:13745#L465" class="source">Source</a>  </h3> <pre data-language="go">func (x *StarExpr) Pos() token.Pos</pre> <h2 id="Stmt">type Stmt<a href="https://golang.org/src/go/ast/ast.go?s=1501:1542#L35" class="source">Source</a>  </h2> <p> All statement nodes implement the Stmt interface. </p> <pre data-language="go">type Stmt interface {
    Node
    // contains filtered or unexported methods
}</pre> <h2 id="StructType">type StructType<a href="https://golang.org/src/go/ast/ast.go?s=11655:11869#L408" class="source">Source</a>  </h2> <p> A StructType node represents a struct type. </p> <pre data-language="go">type StructType struct {
    Struct     token.Pos  // position of "struct" keyword
    Fields     *FieldList // list of field declarations
    Incomplete bool       // true if (source) fields are missing in the Fields list
}
</pre> <h3 id="StructType.End">func (*StructType) End<a href="https://golang.org/src/go/ast/ast.go?s=15638:15674#L503" class="source">Source</a>  </h3> <pre data-language="go">func (x *StructType) End() token.Pos</pre> <h3 id="StructType.Pos">func (*StructType) Pos<a href="https://golang.org/src/go/ast/ast.go?s=14017:14053#L470" class="source">Source</a>  </h3> <pre data-language="go">func (x *StructType) Pos() token.Pos</pre> <h2 id="SwitchStmt">type SwitchStmt<a href="https://golang.org/src/go/ast/ast.go?s=20910:21126#L683" class="source">Source</a>  </h2> <p> A SwitchStmt node represents an expression switch statement. </p> <pre data-language="go">type SwitchStmt struct {
    Switch token.Pos  // position of "switch" keyword
    Init   Stmt       // initialization statement; or nil
    Tag    Expr       // tag expression; or nil
    Body   *BlockStmt // CaseClauses only
}
</pre> <h3 id="SwitchStmt.End">func (*SwitchStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=25267:25303#L806" class="source">Source</a>  </h3> <pre data-language="go">func (s *SwitchStmt) End() token.Pos</pre> <h3 id="SwitchStmt.Pos">func (*SwitchStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23537:23573#L749" class="source">Source</a>  </h3> <pre data-language="go">func (s *SwitchStmt) Pos() token.Pos</pre> <h2 id="TypeAssertExpr">type TypeAssertExpr<a href="https://golang.org/src/go/ast/ast.go?s=9633:9836#L334" class="source">Source</a>  </h2> <p> A TypeAssertExpr node represents an expression followed by a type assertion. </p> <pre data-language="go">type TypeAssertExpr struct {
    X      Expr      // expression
    Lparen token.Pos // position of "("; added in Go 1.2
    Type   Expr      // asserted type; nil means type switch X.(type)
    Rparen token.Pos // position of ")"; added in Go 1.2
}
</pre> <h3 id="TypeAssertExpr.End">func (*TypeAssertExpr) End<a href="https://golang.org/src/go/ast/ast.go?s=15192:15232#L496" class="source">Source</a>  </h3> <pre data-language="go">func (x *TypeAssertExpr) End() token.Pos</pre> <h3 id="TypeAssertExpr.Pos">func (*TypeAssertExpr) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13585:13625#L463" class="source">Source</a>  </h3> <pre data-language="go">func (x *TypeAssertExpr) Pos() token.Pos</pre> <h2 id="TypeSpec">type TypeSpec<a href="https://golang.org/src/go/ast/ast.go?s=27735:28049#L877" class="source">Source</a>  </h2> <p> A TypeSpec node represents a type declaration (TypeSpec production). </p> <pre data-language="go">type TypeSpec struct {
    Doc     *CommentGroup // associated documentation; or nil
    Name    *Ident        // type name
    Assign  token.Pos     // position of '=', if any; added in Go 1.9
    Type    Expr          // *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes
    Comment *CommentGroup // line comments; or nil
}
</pre> <h3 id="TypeSpec.End">func (*TypeSpec) End<a href="https://golang.org/src/go/ast/ast.go?s=28624:28658#L913" class="source">Source</a>  </h3> <pre data-language="go">func (s *TypeSpec) End() token.Pos</pre> <h3 id="TypeSpec.Pos">func (*TypeSpec) Pos<a href="https://golang.org/src/go/ast/ast.go?s=28272:28306#L895" class="source">Source</a>  </h3> <pre data-language="go">func (s *TypeSpec) Pos() token.Pos</pre> <h2 id="TypeSwitchStmt">type TypeSwitchStmt<a href="https://golang.org/src/go/ast/ast.go?s=21191:21414#L691" class="source">Source</a>  </h2> <p> A TypeSwitchStmt node represents a type switch statement. </p> <pre data-language="go">type TypeSwitchStmt struct {
    Switch token.Pos  // position of "switch" keyword
    Init   Stmt       // initialization statement; or nil
    Assign Stmt       // x := y.(type) or y.(type)
    Body   *BlockStmt // CaseClauses only
}
</pre> <h3 id="TypeSwitchStmt.End">func (*TypeSwitchStmt) End<a href="https://golang.org/src/go/ast/ast.go?s=25332:25372#L807" class="source">Source</a>  </h3> <pre data-language="go">func (s *TypeSwitchStmt) End() token.Pos</pre> <h3 id="TypeSwitchStmt.Pos">func (*TypeSwitchStmt) Pos<a href="https://golang.org/src/go/ast/ast.go?s=23598:23638#L750" class="source">Source</a>  </h3> <pre data-language="go">func (s *TypeSwitchStmt) Pos() token.Pos</pre> <h2 id="UnaryExpr">type UnaryExpr<a href="https://golang.org/src/go/ast/ast.go?s=10543:10665#L361" class="source">Source</a>  </h2> <p> A UnaryExpr node represents a unary expression. Unary "*" expressions are represented via StarExpr nodes. </p> <pre data-language="go">type UnaryExpr struct {
    OpPos token.Pos   // position of Op
    Op    token.Token // operator
    X     Expr        // operand
}
</pre> <h3 id="UnaryExpr.End">func (*UnaryExpr) End<a href="https://golang.org/src/go/ast/ast.go?s=15384:15419#L499" class="source">Source</a>  </h3> <pre data-language="go">func (x *UnaryExpr) End() token.Pos</pre> <h3 id="UnaryExpr.Pos">func (*UnaryExpr) Pos<a href="https://golang.org/src/go/ast/ast.go?s=13770:13805#L466" class="source">Source</a>  </h3> <pre data-language="go">func (x *UnaryExpr) Pos() token.Pos</pre> <h2 id="ValueSpec">type ValueSpec<a href="https://golang.org/src/go/ast/ast.go?s=27377:27659#L868" class="source">Source</a>  </h2> <p> A ValueSpec node represents a constant or variable declaration (ConstSpec or VarSpec production). </p> <pre data-language="go">type ValueSpec struct {
    Doc     *CommentGroup // associated documentation; or nil
    Names   []*Ident      // value names (len(Names) &gt; 0)
    Type    Expr          // value type; or nil
    Values  []Expr        // initial values; or nil
    Comment *CommentGroup // line comments; or nil
}
</pre> <h3 id="ValueSpec.End">func (*ValueSpec) End<a href="https://golang.org/src/go/ast/ast.go?s=28437:28472#L904" class="source">Source</a>  </h3> <pre data-language="go">func (s *ValueSpec) End() token.Pos</pre> <h3 id="ValueSpec.Pos">func (*ValueSpec) Pos<a href="https://golang.org/src/go/ast/ast.go?s=28208:28243#L894" class="source">Source</a>  </h3> <pre data-language="go">func (s *ValueSpec) Pos() token.Pos</pre> <h2 id="Visitor">type Visitor<a href="https://golang.org/src/go/ast/walk.go?s=400:456#L2" class="source">Source</a>  </h2> <p> A Visitor's Visit method is invoked for each node encountered by Walk. If the result visitor w is not nil, Walk visits each of the children of node with the visitor w, followed by a call of w.Visit(nil). </p> <pre data-language="go">type Visitor interface {
    Visit(node Node) (w Visitor)
}</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/go/ast/" class="_attribution-link">https://golang.org/pkg/go/ast/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
