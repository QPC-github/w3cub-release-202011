
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Nokogiri&#58;&#58;XML&#58;&#58;Node - Nokogiri - W3cubDocs</title>
  
  <meta name="description" content="Nokogiri&#58;&#58;XML&#58;&#58;Node is your window to the fun filled world of dealing with XML and HTML tags. A Nokogiri&#58;&#58;XML&#58;&#58;Node &hellip;">
  <meta name="keywords" content="class, nokogiri, xml, node">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nokogiri/nokogiri/xml/node.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/nokogiri.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nokogiri/" class="_nav-link" title="" style="margin-left:0;">Nokogiri</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="class-Nokogiri::XML::Node" class="class"> class Nokogiri::XML::Node </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><span>Object</span></dd>
<dt>Included modules:</dt>
<dd class="meta-includes">
<a class="include" href="pp/node">Nokogiri::XML::PP::Node</a>, <a class="include" href="searchable">Nokogiri::XML::Searchable</a>
</dd>
</dl> <section class="description"> <p><a href="node"><code>Nokogiri::XML::Node</code></a> is your window to the fun filled world of dealing with <a href="../xml"><code>XML</code></a> and <a href="../html"><code>HTML</code></a> tags. A <a href="node"><code>Nokogiri::XML::Node</code></a> may be treated similarly to a hash with regard to attributes. For example (from irb):</p> <pre>irb(main):004:0&gt; node
=&gt; &lt;a href="#foo" id="link"&gt;link&lt;/a&gt;
irb(main):005:0&gt; node['href']
=&gt; "#foo"
irb(main):006:0&gt; node.keys
=&gt; ["href", "id"]
irb(main):007:0&gt; node.values
=&gt; ["#foo", "link"]
irb(main):008:0&gt; node['class'] = 'green'
=&gt; "green"
irb(main):009:0&gt; node
=&gt; &lt;a href="#foo" id="link" class="green"&gt;link&lt;/a&gt;
irb(main):010:0&gt;</pre> <p>See <a href="node#method-i-5B-5D"><code>Nokogiri::XML::Node#[]</code></a> and Nokogiri::XML#[]= for more information.</p> <p><a href="node"><code>Nokogiri::XML::Node</code></a> also has methods that let you move around your tree. For navigating your tree, see:</p> <ul>
<li> <p><a href="node#method-i-parent"><code>Nokogiri::XML::Node#parent</code></a></p> </li>
<li> <p><a href="node#method-i-children"><code>Nokogiri::XML::Node#children</code></a></p> </li>
<li> <p><a href="node#method-i-next"><code>Nokogiri::XML::Node#next</code></a></p> </li>
<li> <p><a href="node#method-i-previous"><code>Nokogiri::XML::Node#previous</code></a></p> </li>
</ul> <p>When printing or otherwise emitting a document or a node (and its subtree), there are a few methods you might want to use:</p> <ul>
<li> <p>content, text, <a href="node#method-i-inner_text"><code>inner_text</code></a>, <a href="node#method-i-to_str"><code>to_str</code></a>: emit plaintext</p> <p>These methods will all emit the plaintext version of your document, meaning that entities will be replaced (e.g., “&amp;lt;” will be replaced with “&lt;”), meaning that any sanitizing will likely be un-done in the output.</p> </li>
<li> <p><a href="node#method-i-to_s"><code>to_s</code></a>, <a href="node#method-i-to_xml"><code>to_xml</code></a>, <a href="node#method-i-to_html"><code>to_html</code></a>, <a href="node#method-i-inner_html"><code>inner_html</code></a>: emit well-formed markup</p> <p>These methods will all emit properly-escaped markup, meaning that it's suitable for consumption by browsers, parsers, etc.</p> </li>
</ul> <p>You may search this node's subtree using <a href="searchable#method-i-xpath"><code>Searchable#xpath</code></a> and <a href="searchable#method-i-css"><code>Searchable#css</code></a></p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="ATTRIBUTE_DECL">ATTRIBUTE_DECL </dt>
<dd>
<p>Attribute declaration type</p> </dd>
<dt id="ATTRIBUTE_NODE">ATTRIBUTE_NODE </dt>
<dd>
<p>Attribute node type</p> </dd>
<dt id="CDATA_SECTION_NODE">CDATA_SECTION_NODE </dt>
<dd>
<p><a href="cdata"><code>CDATA</code></a> node type, see <a href="node#method-i-cdata-3F"><code>Nokogiri::XML::Node#cdata?</code></a></p> </dd>
<dt id="COMMENT_NODE">COMMENT_NODE </dt>
<dd>
<p><a href="comment"><code>Comment</code></a> node type, see <a href="node#method-i-comment-3F"><code>Nokogiri::XML::Node#comment?</code></a></p> </dd>
<dt id="DOCB_DOCUMENT_NODE">DOCB_DOCUMENT_NODE </dt>
<dd>
<p>DOCB document node type</p> </dd>
<dt id="DOCUMENT_FRAG_NODE">DOCUMENT_FRAG_NODE </dt>
<dd>
<p><a href="document"><code>Document</code></a> fragment node type</p> </dd>
<dt id="DOCUMENT_NODE">DOCUMENT_NODE </dt>
<dd>
<p><a href="document"><code>Document</code></a> node type, see <a href="node#method-i-xml-3F"><code>Nokogiri::XML::Node#xml?</code></a></p> </dd>
<dt id="DOCUMENT_TYPE_NODE">DOCUMENT_TYPE_NODE </dt>
<dd>
<p><a href="document"><code>Document</code></a> type node type</p> </dd>
<dt id="DTD_NODE">DTD_NODE </dt>
<dd>
<p><a href="dtd"><code>DTD</code></a> node type</p> </dd>
<dt id="ELEMENT_DECL">ELEMENT_DECL </dt>
<dd>
<p><a href="element"><code>Element</code></a> declaration type</p> </dd>
<dt id="ELEMENT_NODE">ELEMENT_NODE </dt>
<dd>
<p><a href="element"><code>Element</code></a> node type, see <a href="node#method-i-element-3F"><code>Nokogiri::XML::Node#element?</code></a></p> </dd>
<dt id="ENTITY_DECL">ENTITY_DECL </dt>
<dd>
<p>Entity declaration type</p> </dd>
<dt id="ENTITY_NODE">ENTITY_NODE </dt>
<dd>
<p>Entity node type</p> </dd>
<dt id="ENTITY_REF_NODE">ENTITY_REF_NODE </dt>
<dd>
<p>Entity reference node type</p> </dd>
<dt id="HTML_DOCUMENT_NODE">HTML_DOCUMENT_NODE </dt>
<dd>
<p><a href="../html"><code>HTML</code></a> document node type, see <a href="node#method-i-html-3F"><code>Nokogiri::XML::Node#html?</code></a></p> </dd>
<dt id="NAMESPACE_DECL">NAMESPACE_DECL </dt>
<dd>
<p><a href="namespace"><code>Namespace</code></a> declaration type</p> </dd>
<dt id="NOTATION_NODE">NOTATION_NODE </dt>
<dd>
<p><a href="notation"><code>Notation</code></a> node type</p> </dd>
<dt id="PI_NODE">PI_NODE </dt>
<dd>
<p>PI node type</p> </dd>
<dt id="TEXT_NODE">TEXT_NODE </dt>
<dd>
<p><a href="text"><code>Text</code></a> node type, see <a href="node#method-i-text-3F"><code>Nokogiri::XML::Node#text?</code></a></p> </dd>
<dt id="XINCLUDE_END">XINCLUDE_END </dt>
<dd>
<p>XInclude end type</p> </dd>
<dt id="XINCLUDE_START">XINCLUDE_START </dt>
<dd>
<p>XInclude start type</p> </dd>
</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(name, document) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  xmlDocPtr doc;
  xmlNodePtr node;
  VALUE name;
  VALUE document;
  VALUE rest;
  VALUE rb_node;

  rb_scan_args(argc, argv, "2*", &amp;name, &amp;document, &amp;rest);

  Data_Get_Struct(document, xmlDoc, doc);

  node = xmlNewNode(NULL, (xmlChar *)StringValueCStr(name));
  node-&gt;doc = doc-&gt;doc;
  nokogiri_root_node(node);

  rb_node = Nokogiri_wrap_xml_node(
              klass == cNokogiriXmlNode ? (VALUE)NULL : klass,
              node
            );
  rb_obj_call_init(rb_node, argc, argv);

  if(rb_block_given_p()) { rb_yield(rb_node); }

  return rb_node;
}</pre> </div> <p>Create a new node with <code>name</code> sharing GC lifecycle with <code>document</code></p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3C"> <span class="method-name">&lt;&lt;</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 183
def &lt;&lt; node_or_tags
  add_child node_or_tags
  self
end</pre> </div> <p>Add <code>node_or_tags</code> as a child of this <a href="node"><code>Node</code></a>. <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns self, to support chaining of calls (e.g., root &lt;&lt; child1 &lt;&lt; child2)</p> <p>Also see related method <code>add_child</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3D-3E"> <span class="method-name">&lt;=&gt;</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-3E-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 800
def &lt;=&gt; other
  return nil unless other.is_a?(Nokogiri::XML::Node)
  return nil unless document == other.document
  compare other
end</pre> </div> <p>Compare two <a href="node"><code>Node</code></a> objects with respect to their <a href="document"><code>Document</code></a>. Nodes from different documents cannot be compared.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3D-3D"> <span class="method-name">==</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 667
def == other
  return false unless other
  return false unless other.respond_to?(:pointer_id)
  pointer_id == other.pointer_id
end</pre> </div> <p>Test to see if this <a href="node"><code>Node</code></a> is equal to <code>other</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3E"> <span class="method-name">&gt;</span><span class="method-args">(selector)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3E-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 113
def &gt; selector
  ns = document.root.namespaces
  xpath CSS.xpath_for(selector, :prefix =&gt; "./", :ns =&gt; ns).first
end</pre> </div> <p>Search this node's immediate children using <a href="../css"><code>CSS</code></a> selector <code>selector</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D"> <span class="method-name">[]</span><span class="method-args">(name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 120
def [] name
  get(name.to_s)
end</pre> </div> <p>Get the attribute value for the attribute <code>name</code></p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-get_attribute">get_attribute</a>, <a href="node#method-i-attr">attr</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-name">[]=</span><span class="method-args">(name, value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 126
def []= name, value
  set name.to_s, value.to_s
end</pre> </div> <p>Set the attribute value for the attribute <code>name</code> to <code>value</code></p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-set_attribute">set_attribute</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-accept"> <span class="method-name">accept</span><span class="method-args">(visitor)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="accept-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 661
def accept visitor
  visitor.visit(self)
end</pre> </div> <p>Accept a visitor. This method calls “visit” on <code>visitor</code> with self.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_child"> <span class="method-name">add_child</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_child-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 137
def add_child node_or_tags
  node_or_tags = coerce(node_or_tags)
  if node_or_tags.is_a?(XML::NodeSet)
    node_or_tags.each { |n| add_child_node_and_reparent_attrs n }
  else
    add_child_node_and_reparent_attrs node_or_tags
  end
  node_or_tags
end</pre> </div> <p>Add <code>node_or_tags</code> as a child of this <a href="node"><code>Node</code></a>. <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node"><code>Node</code></a>), or <a href="nodeset"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment"><code>DocumentFragment</code></a>, <a href="nodeset"><code>NodeSet</code></a>, or string).</p> <p>Also see related method +&lt;&lt;+.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_class"> <span class="method-name">add_class</span><span class="method-args">(name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_class-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 380
def add_class name
  names = classes
  self['class'] = (names + (name.scan(/\S+/) - names)).join(' ')
  self
end</pre> </div> <p>Add <code>name</code> to the “class” attribute value of this <a href="node"><code>Node</code></a> and return self. If the value is already in the current value, it is not added. If no “class” attribute exists yet, one is created with the given value.</p> <p>More than one class may be added at a time, separated by a space.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-add_namespace"> <span class="method-name">add_namespace</span><span class="method-args">(p1, p2)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-add_namespace_definition">add_namespace_definition</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_namespace_definition"> <span class="method-callseq"> add_namespace_definition(prefix, href) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_namespace_definition-source"> <pre class="c" data-language="c">static VALUE add_namespace_definition(VALUE self, VALUE prefix, VALUE href)
{
  xmlNodePtr node, namespace;
  xmlNsPtr ns;

  Data_Get_Struct(self, xmlNode, node);
  namespace = node ;

  ns = xmlSearchNs(
         node-&gt;doc,
         node,
         (const xmlChar *)(NIL_P(prefix) ? NULL : StringValueCStr(prefix))
       );

  if(!ns) {
    if (node-&gt;type != XML_ELEMENT_NODE) {
      namespace = node-&gt;parent;
    }
    ns = xmlNewNs(
           namespace,
           (const xmlChar *)StringValueCStr(href),
           (const xmlChar *)(NIL_P(prefix) ? NULL : StringValueCStr(prefix))
         );
  }

  if (!ns) { return Qnil ; }

  if(NIL_P(prefix) || node != namespace) { xmlSetNs(node, ns); }

  return Nokogiri_wrap_xml_namespace(node-&gt;doc, ns);
}</pre> </div> <p>Adds a namespace definition with <code>prefix</code> using <code>href</code> value. The result is as if parsed <a href="../xml"><code>XML</code></a> for this node had included an attribute 'xmlns:prefix=value'. A default namespace for this node (“xmlns=”) can be added by passing 'nil' for prefix. Namespaces added this way will not show up in <a href="node#method-i-attributes"><code>attributes</code></a>, but they will be included as an xmlns attribute when the node is serialized to <a href="../xml"><code>XML</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-add_namespace">add_namespace</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_next_sibling"> <span class="method-name">add_next_sibling</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_next_sibling-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 208
def add_next_sibling node_or_tags
  raise ArgumentError.new("A document may not have multiple root nodes.") if (parent &amp;&amp; parent.document?) &amp;&amp; !(node_or_tags.comment? || node_or_tags.processing_instruction?)

  add_sibling :next, node_or_tags
end</pre> </div> <p>Insert <code>node_or_tags</code> after this <a href="node"><code>Node</code></a> (as a sibling). <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node"><code>Node</code></a>), or <a href="nodeset"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment"><code>DocumentFragment</code></a>, <a href="nodeset"><code>NodeSet</code></a>, or string).</p> <p>Also see related method <code>after</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_previous_sibling"> <span class="method-name">add_previous_sibling</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_previous_sibling-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 195
def add_previous_sibling node_or_tags
  raise ArgumentError.new("A document may not have multiple root nodes.") if (parent &amp;&amp; parent.document?) &amp;&amp; !(node_or_tags.comment? || node_or_tags.processing_instruction?)

  add_sibling :previous, node_or_tags
end</pre> </div> <p>Insert <code>node_or_tags</code> before this <a href="node"><code>Node</code></a> (as a sibling). <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node"><code>Node</code></a>), or <a href="nodeset"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment"><code>DocumentFragment</code></a>, <a href="nodeset"><code>NodeSet</code></a>, or string).</p> <p>Also see related method <code>before</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-previous-3D">previous=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-after"> <span class="method-name">after</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="after-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 233
def after node_or_tags
  add_next_sibling node_or_tags
  self
end</pre> </div> <p>Insert <code>node_or_tags</code> after this node (as a sibling). <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a <a href="documentfragment"><code>Nokogiri::XML::DocumentFragment</code></a>, or a string containing markup.</p> <p>Returns self, to support chaining of calls.</p> <p>Also see related method <code>add_next_sibling</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ancestors"> <span class="method-name">ancestors</span><span class="method-args">(selector = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ancestors-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 601
def ancestors selector = nil
  return NodeSet.new(document) unless respond_to?(:parent)
  return NodeSet.new(document) unless parent

  parents = [parent]

  while parents.last.respond_to?(:parent)
    break unless ctx_parent = parents.last.parent
    parents &lt;&lt; ctx_parent
  end

  return NodeSet.new(document, parents) unless selector

  root = parents.last
  search_results = root.search(selector)

  NodeSet.new(document, parents.find_all { |parent|
    search_results.include?(parent)
  })
end</pre> </div> <p>Get a list of ancestor <a href="node"><code>Node</code></a> for this <a href="node"><code>Node</code></a>. If <code>selector</code> is given, the ancestors must match <code>selector</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-append_class"> <span class="method-name">append_class</span><span class="method-args">(name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="append_class-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 394
def append_class name
  self['class'] = (classes + name.scan(/\S+/)).join(' ')
  self
end</pre> </div> <p>Append <code>name</code> to the “class” attribute value of this <a href="node"><code>Node</code></a> and return self. The value is simply appended without checking if it is already in the current value. If no “class” attribute exists yet, one is created with the given value.</p> <p>More than one class may be appended at a time, separated by a space.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-attr"> <span class="method-name">attr</span><span class="method-args">(name)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attribute"> <span class="method-callseq"> attribute(name) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="attribute-source"> <pre class="c" data-language="c">static VALUE attr(VALUE self, VALUE name)
{
  xmlNodePtr node;
  xmlAttrPtr prop;
  Data_Get_Struct(self, xmlNode, node);
  prop = xmlHasProp(node, (xmlChar *)StringValueCStr(name));

  if(! prop) { return Qnil; }
  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)prop);
}</pre> </div> <p>Get the attribute node with <code>name</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attribute_nodes"> <span class="method-callseq"> attribute_nodes() </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="attribute_nodes-source"> <pre class="c" data-language="c">static VALUE attribute_nodes(VALUE self)
{
  /* this code in the mode of xmlHasProp() */
  xmlNodePtr node;
  VALUE attr;

  Data_Get_Struct(self, xmlNode, node);

  attr = rb_ary_new();
  Nokogiri_xml_node_properties(node, attr);

  return attr ;
}</pre> </div> <p>returns a list containing the <a href="node"><code>Node</code></a> attributes.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attribute_with_ns"> <span class="method-callseq"> attribute_with_ns(name, namespace) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="attribute_with_ns-source"> <pre class="c" data-language="c">static VALUE attribute_with_ns(VALUE self, VALUE name, VALUE namespace)
{
  xmlNodePtr node;
  xmlAttrPtr prop;
  Data_Get_Struct(self, xmlNode, node);
  prop = xmlHasNsProp(node, (xmlChar *)StringValueCStr(name),
                      NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace));

  if(! prop) { return Qnil; }
  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)prop);
}</pre> </div> <p>Get the attribute node with <code>name</code> and <code>namespace</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attributes"> <span class="method-name">attributes</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="attributes-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 339
def attributes
  Hash[attribute_nodes.map { |node|
    [node.node_name, node]
  }]
end</pre> </div> <p>Returns a hash containing the node's attributes. The key is the attribute name without any namespace, the value is a <a href="attr"><code>Nokogiri::XML::Attr</code></a> representing the attribute. If you need to distinguish attributes with the same name, with different namespaces use <a href="node#method-i-attribute_nodes"><code>attribute_nodes</code></a> instead.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-before"> <span class="method-name">before</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="before-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 221
def before node_or_tags
  add_previous_sibling node_or_tags
  self
end</pre> </div> <p>Insert <code>node_or_tags</code> before this node (as a sibling). <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns self, to support chaining of calls.</p> <p>Also see related method <code>add_previous_sibling</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-blank-3F"> <span class="method-callseq"> blank? </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="blank-3F-source"> <pre class="c" data-language="c">static VALUE blank_eh(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return (1 == xmlIsBlankNode(node)) ? Qtrue : Qfalse ;
}</pre> </div> <p>Is this node blank?</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-canonicalize"> <span class="method-name">canonicalize</span><span class="method-args">(mode=XML::XML_C14N_1_0,inclusive_namespaces=nil,with_comments=false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="canonicalize-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 820
def canonicalize(mode=XML::XML_C14N_1_0,inclusive_namespaces=nil,with_comments=false)
  c14n_root = self
  document.canonicalize(mode, inclusive_namespaces, with_comments) do |node, parent|
    tn = node.is_a?(XML::Node) ? node : parent
    tn == c14n_root || tn.ancestors.include?(c14n_root)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cdata-3F"> <span class="method-name">cdata?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cdata-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 524
def cdata?
  type == CDATA_SECTION_NODE
end</pre> </div> <p>Returns true if this is a <a href="cdata"><code>CDATA</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-child"> <span class="method-callseq"> child </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="child-source"> <pre class="c" data-language="c">static VALUE child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  if(!child) { return Qnil; }

  return Nokogiri_wrap_xml_node(Qnil, child);
}</pre> </div> <p>Returns the child node</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-children"> <span class="method-callseq"> children </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="children-source"> <pre class="c" data-language="c">static VALUE children(VALUE self)
{
  xmlNodePtr node;
  xmlNodePtr child;
  xmlNodeSetPtr set;
  VALUE document;
  VALUE node_set;

  Data_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  set = xmlXPathNodeSetCreate(child);

  document = DOC_RUBY_OBJECT(node-&gt;doc);

  if(!child) { return Nokogiri_wrap_xml_node_set(set, document); }

  child = child-&gt;next;
  while(NULL != child) {
    xmlXPathNodeSetAddUnique(set, child);
    child = child-&gt;next;
  }

  node_set = Nokogiri_wrap_xml_node_set(set, document);

  return node_set;
}</pre> </div> <p>Get the list of children for this node as a <a href="nodeset"><code>NodeSet</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-children-3D"> <span class="method-name">children=</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="children-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 257
def children= node_or_tags
  node_or_tags = coerce(node_or_tags)
  children.unlink
  if node_or_tags.is_a?(XML::NodeSet)
    node_or_tags.each { |n| add_child_node_and_reparent_attrs n }
  else
    add_child_node_and_reparent_attrs node_or_tags
  end
  node_or_tags
end</pre> </div> <p>Set the inner html for this <a href="node"><code>Node</code></a> <code>node_or_tags</code> <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a <a href="documentfragment"><code>Nokogiri::XML::DocumentFragment</code></a>, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node"><code>Node</code></a>), or <a href="nodeset"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment"><code>DocumentFragment</code></a>, <a href="nodeset"><code>NodeSet</code></a>, or string).</p> <p>Also see related method <code>inner_html=</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-classes"> <span class="method-name">classes</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="classes-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 368
def classes
  self['class'].to_s.scan(/\S+/)
end</pre> </div> <p>Get the list of class names of this <a href="node"><code>Node</code></a>, without deduplication or sorting.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-clone"> <span class="method-name">clone</span><span class="method-args">(p1 = v1, p2 = v2)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-dup">dup</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-comment-3F"> <span class="method-name">comment?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="comment-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 519
def comment?
  type == COMMENT_NODE
end</pre> </div> <p>Returns true if this is a <a href="comment"><code>Comment</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-content"> <span class="method-callseq"> content </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="content-source"> <pre class="c" data-language="c">static VALUE get_native_content(VALUE self)
{
  xmlNodePtr node;
  xmlChar * content;

  Data_Get_Struct(self, xmlNode, node);

  content = xmlNodeGetContent(node);
  if(content) {
    VALUE rval = NOKOGIRI_STR_NEW2(content);
    xmlFree(content);
    return rval;
  }
  return Qnil;
}</pre> </div> <p>Returns the plaintext content for this <a href="node"><code>Node</code></a>. Note that entities will always be expanded in the returned string.</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-text">text</a>, <a href="node#method-i-inner_text">inner_text</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-content-3D"> <span class="method-name">content=</span><span class="method-args">(string)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="content-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 486
def content= string
  self.native_content = encode_special_chars(string.to_s)
end</pre> </div> <p>Set the Node's content to a <a href="text"><code>Text</code></a> node containing <code>string</code>. The string gets <a href="../xml"><code>XML</code></a> escaped, not interpreted as markup.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_external_subset"> <span class="method-callseq"> create_external_subset(name, external_id, system_id) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="create_external_subset-source"> <pre class="c" data-language="c">static VALUE create_external_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  doc = node-&gt;doc;

  if(doc-&gt;extSubset) {
    rb_raise(rb_eRuntimeError, "Document already has an external subset");
  }

  dtd = xmlNewDtd(
          doc,
          NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),
          NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),
          NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)
        );

  if(!dtd) { return Qnil; }

  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);
}</pre> </div> <p>Create an external subset</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_internal_subset"> <span class="method-callseq"> create_internal_subset(name, external_id, system_id) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="create_internal_subset-source"> <pre class="c" data-language="c">static VALUE create_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  doc = node-&gt;doc;

  if(xmlGetIntSubset(doc)) {
    rb_raise(rb_eRuntimeError, "Document already has an internal subset");
  }

  dtd = xmlCreateIntSubset(
          doc,
          NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),
          NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),
          NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)
        );

  if(!dtd) { return Qnil; }

  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);
}</pre> </div> <p>Create the internal subset of a document.</p> <pre class="ruby" data-language="ruby">doc.create_internal_subset("chapter", "-//OASIS//DTD DocBook XML//EN", "chapter.dtd")
# =&gt; &lt;!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN" "chapter.dtd"&gt;

doc.create_internal_subset("chapter", nil, "chapter.dtd")
# =&gt; &lt;!DOCTYPE chapter SYSTEM "chapter.dtd"&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-css_path"> <span class="method-name">css_path</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="css_path-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 592
def css_path
  path.split(/\//).map { |part|
    part.length == 0 ? nil : part.gsub(/\[(\d+)\]/, ':nth-of-type(\1)')
  }.compact.join(' &gt; ')
end</pre> </div> <p>Get the path to this node as a <a href="../css"><code>CSS</code></a> expression</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-decorate-21"> <span class="method-name">decorate!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="decorate-21-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 107
def decorate!
  document.decorate(self)
end</pre> </div> <p>Decorate this node with the decorators set up in this node's <a href="document"><code>Document</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-default_namespace-3D"> <span class="method-name">default_namespace=</span><span class="method-args">(url)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default_namespace-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 628
def default_namespace= url
  add_namespace_definition(nil, url)
end</pre> </div> <p>Adds a default namespace supplied as a string <code>url</code> href, to self. The consequence is as an xmlns attribute with supplied argument were present in parsed <a href="../xml"><code>XML</code></a>. A default namespace set with this method will now show up in <a href="node#method-i-attributes"><code>attributes</code></a>, but when this node is serialized to <a href="../xml"><code>XML</code></a> an “xmlns” attribute will appear. See also <a href="node#method-i-namespace"><code>namespace</code></a> and <a href="node#method-i-namespace-3D"><code>namespace=</code></a></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-delete"> <span class="method-name">delete</span><span class="method-args">(name)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-remove_attribute">remove_attribute</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-description"> <span class="method-name">description</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="description-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 561
def description
  return nil if document.xml?
  Nokogiri::HTML::ElementDescription[name]
end</pre> </div> <p>Fetch the <a href="../html/elementdescription"><code>Nokogiri::HTML::ElementDescription</code></a> for this node. Returns nil on <a href="../xml"><code>XML</code></a> documents and on unknown tags.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-do_xinclude"> <span class="method-name">do_xinclude</span><span class="method-args">(options = XML::ParseOptions::DEFAULT_XML) { |options| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="do_xinclude-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 810
def do_xinclude options = XML::ParseOptions::DEFAULT_XML
  options = Nokogiri::XML::ParseOptions.new(options) if Integer === options

  # give options to user
  yield options if block_given?

  # call c extension
  process_xincludes(options.to_i)
end</pre> </div> <p>Do xinclude substitution on the subtree below node. If given a block, a <a href="parseoptions"><code>Nokogiri::XML::ParseOptions</code></a> object initialized from <code>options</code>, will be passed to it, allowing more convenient modification of the parser options.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-document"> <span class="method-callseq"> document </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="document-source"> <pre class="c" data-language="c">static VALUE document(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return DOC_RUBY_OBJECT(node-&gt;doc);
}</pre> </div> <p>Get the document for this <a href="node"><code>Node</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-document-3F"> <span class="method-name">document?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="document-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 539
def document?
  is_a? XML::Document
end</pre> </div> <p>Returns true if this is a <a href="document"><code>Document</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-dup"> <span class="method-callseq"> dup </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> dup(depth) </span> </div> <div class="method-heading"> <span class="method-callseq"> dup(depth, new_parent_doc) </span> </div> <div class="method-description">
<div class="method-source-code" id="dup-source"> <pre class="c" data-language="c">static VALUE duplicate_node(int argc, VALUE *argv, VALUE self)
{
  VALUE r_level, r_new_parent_doc;
  int level;
  int n_args;
  xmlDocPtr new_parent_doc;
  xmlNodePtr node, dup;

  Data_Get_Struct(self, xmlNode, node);

  n_args = rb_scan_args(argc, argv, "02", &amp;r_level, &amp;r_new_parent_doc);

  if (n_args &lt; 1) {
    r_level = INT2NUM((long)1);
  }
  level = (int)NUM2INT(r_level);

  if (n_args &lt; 2) {
    new_parent_doc = node-&gt;doc;
  } else {
    Data_Get_Struct(r_new_parent_doc, xmlDoc, new_parent_doc);
  }

  dup = xmlDocCopyNode(node, new_parent_doc, level);
  if(dup == NULL) { return Qnil; }

  nokogiri_root_node(dup);

  return Nokogiri_wrap_xml_node(rb_obj_class(self), dup);
}</pre> </div> <p>Copy this node. An optional depth may be passed in. 0 is a shallow copy, 1 (the default) is a deep copy. An optional new_parent_doc may also be passed in, which will be the new node's parent document. Defaults to the current node's document. current document.</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-clone">clone</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-name">each</span><span class="method-args">() { |node_name, value| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 359
def each
  attribute_nodes.each { |node|
    yield [node.node_name, node.value]
  }
end</pre> </div> <p>Iterate over each attribute name and value pair for this <a href="node"><code>Node</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-elem-3F"> <span class="method-name">elem?</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-element-3F">element?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-element-3F"> <span class="method-name">element?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="element-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 574
def element?
  type == ELEMENT_NODE
end</pre> </div> <p>Returns true if this is an <a href="element"><code>Element</code></a> node</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-elem-3F">elem?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-element_children"> <span class="method-callseq"> element_children </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="element_children-source"> <pre class="c" data-language="c">static VALUE element_children(VALUE self)
{
  xmlNodePtr node;
  xmlNodePtr child;
  xmlNodeSetPtr set;
  VALUE document;
  VALUE node_set;

  Data_Get_Struct(self, xmlNode, node);

  child = xmlFirstElementChild(node);
  set = xmlXPathNodeSetCreate(child);

  document = DOC_RUBY_OBJECT(node-&gt;doc);

  if(!child) { return Nokogiri_wrap_xml_node_set(set, document); }

  child = xmlNextElementSibling(child);
  while(NULL != child) {
    xmlXPathNodeSetAddUnique(set, child);
    child = xmlNextElementSibling(child);
  }

  node_set = Nokogiri_wrap_xml_node_set(set, document);

  return node_set;
}</pre> </div> <p>Get the list of children for this node as a <a href="nodeset"><code>NodeSet</code></a>. All nodes will be element nodes.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">@doc.root.element_children.all? { |x| x.element? } # =&gt; true
</pre>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-elements">elements</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-elements"> <span class="method-name">elements</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-element_children">element_children</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-encode_special_chars"> <span class="method-callseq"> encode_special_chars(string) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="encode_special_chars-source"> <pre class="c" data-language="c">static VALUE encode_special_chars(VALUE self, VALUE string)
{
  xmlNodePtr node;
  xmlChar *encoded;
  VALUE encoded_str;

  Data_Get_Struct(self, xmlNode, node);
  encoded = xmlEncodeSpecialChars(
              node-&gt;doc,
              (const xmlChar *)StringValueCStr(string)
            );

  encoded_str = NOKOGIRI_STR_NEW2(encoded);
  xmlFree(encoded);

  return encoded_str;
}</pre> </div> <p>Encode any special characters in <code>string</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-external_subset"> <span class="method-callseq"> external_subset </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="external_subset-source"> <pre class="c" data-language="c">static VALUE external_subset(VALUE self)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  if(!node-&gt;doc) { return Qnil; }

  doc = node-&gt;doc;
  dtd = doc-&gt;extSubset;

  if(!dtd) { return Qnil; }

  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);
}</pre> </div> <p>Get the external subset</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-first_element_child"> <span class="method-callseq"> first_element_child </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="first_element_child-source"> <pre class="c" data-language="c">static VALUE first_element_child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = xmlFirstElementChild(node);
  if(!child) { return Qnil; }

  return Nokogiri_wrap_xml_node(Qnil, child);
}</pre> </div> <p>Returns the first child node of this node that is an element.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">@doc.root.first_element_child.element? # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fragment"> <span class="method-name">fragment</span><span class="method-args">(tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fragment-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 441
def fragment tags
  type = document.html? ? Nokogiri::HTML : Nokogiri::XML
  type::DocumentFragment.new(document, tags, self)
end</pre> </div> <p>Create a <a href="documentfragment"><code>DocumentFragment</code></a> containing <code>tags</code> that is relative to <em>this</em> context node.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fragment-3F"> <span class="method-name">fragment?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="fragment-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 554
def fragment?
  type == DOCUMENT_FRAG_NODE
end</pre> </div> <p>Returns true if this is a <a href="documentfragment"><code>DocumentFragment</code></a></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-get_attribute"> <span class="method-name">get_attribute</span><span class="method-args">(name)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-has_attribute-3F"> <span class="method-name">has_attribute?</span><span class="method-args">(p1)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-key-3F">key?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-html-3F"> <span class="method-name">html?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="html-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 534
def html?
  type == HTML_DOCUMENT_NODE
end</pre> </div> <p>Returns true if this is an <a href="../html/document"><code>HTML::Document</code></a> node</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inner_html"> <span class="method-name">inner_html</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inner_html-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 587
def inner_html *args
  children.map { |x| x.to_html(*args) }.join
end</pre> </div> <p>Get the <a href="node#method-i-inner_html"><code>inner_html</code></a> for this node's <a href="node#method-i-children"><code>Node#children</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inner_html-3D"> <span class="method-name">inner_html=</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="inner_html-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 245
def inner_html= node_or_tags
  self.children = node_or_tags
  self
end</pre> </div> <p>Set the inner html for this <a href="node"><code>Node</code></a> to <code>node_or_tags</code> <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a <a href="documentfragment"><code>Nokogiri::XML::DocumentFragment</code></a>, or a string containing markup.</p> <p>Returns self.</p> <p>Also see related method <code>children=</code></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-inner_text"> <span class="method-name">inner_text</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-content">content</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-internal_subset"> <span class="method-callseq"> internal_subset </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="internal_subset-source"> <pre class="c" data-language="c">static VALUE internal_subset(VALUE self)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  if(!node-&gt;doc) { return Qnil; }

  doc = node-&gt;doc;
  dtd = xmlGetIntSubset(doc);

  if(!dtd) { return Qnil; }

  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);
}</pre> </div> <p>Get the internal subset</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-key-3F"> <span class="method-callseq"> key?(attribute) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="key-3F-source"> <pre class="c" data-language="c">static VALUE key_eh(VALUE self, VALUE attribute)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if(xmlHasProp(node, (xmlChar *)StringValueCStr(attribute))) {
    return Qtrue;
  }
  return Qfalse;
}</pre> </div> <p>Returns true if <code>attribute</code> is set</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-has_attribute-3F">has_attribute?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-keys"> <span class="method-name">keys</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="keys-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 353
def keys
  attribute_nodes.map(&amp;:node_name)
end</pre> </div> <p>Get the attribute names for this <a href="node"><code>Node</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lang"> <span class="method-callseq"> lang </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lang-source"> <pre class="c" data-language="c">static VALUE get_lang(VALUE self_rb)
{
  xmlNodePtr self ;
  xmlChar* lang ;
  VALUE lang_rb ;

  Data_Get_Struct(self_rb, xmlNode, self);

  lang = xmlNodeGetLang(self);
  if (lang) {
    lang_rb = NOKOGIRI_STR_NEW2(lang);
    xmlFree(lang);
    return lang_rb ;
  }

  return Qnil ;
}</pre> </div> <p>Searches the language of a node, i.e. the values of the xml:lang attribute or the one carried by the nearest ancestor.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lang-3D"> <span class="method-callseq"> lang= </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lang-3D-source"> <pre class="c" data-language="c">static VALUE set_lang(VALUE self_rb, VALUE lang_rb)
{
  xmlNodePtr self ;
  xmlChar* lang ;

  Data_Get_Struct(self_rb, xmlNode, self);
  lang = (xmlChar*)StringValueCStr(lang_rb);

  xmlNodeSetLang(self, lang);

  return Qnil ;
}</pre> </div> <p>Set the language of a node, i.e. the values of the xml:lang attribute.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-last_element_child"> <span class="method-callseq"> last_element_child </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="last_element_child-source"> <pre class="c" data-language="c">static VALUE last_element_child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = xmlLastElementChild(node);
  if(!child) { return Qnil; }

  return Nokogiri_wrap_xml_node(Qnil, child);
}</pre> </div> <p>Returns the last child node of this node that is an element.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">@doc.root.last_element_child.element? # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-line"> <span class="method-callseq"> line </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="line-source"> <pre class="c" data-language="c">static VALUE line(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);

  return INT2NUM(xmlGetLineNo(node));
}</pre> </div> <p>Returns the line for this <a href="node"><code>Node</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-matches-3F"> <span class="method-name">matches?</span><span class="method-args">(selector)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="matches-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 434
def matches? selector
  ancestors.last.search(selector).include?(self)
end</pre> </div> <p>Returns true if this <a href="node"><code>Node</code></a> matches <code>selector</code></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-name"> <span class="method-name">name</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-node_name">node_name</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-name-3D"> <span class="method-name">name=</span><span class="method-args">(p1)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-node_name-3D">node_name=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespace"> <span class="method-callseq"> namespace() </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="namespace-source"> <pre class="c" data-language="c">static VALUE namespace(VALUE self)
{
xmlNodePtr node ;
Data_Get_Struct(self, xmlNode, node);

if (node-&gt;ns) {
  return Nokogiri_wrap_xml_namespace(node-&gt;doc, node-&gt;ns);
}</pre> </div> <p>returns the namespace of the element or attribute node as a <a href="namespace"><code>Namespace</code></a> object, or nil if there is no namespace for the element or attribute.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespace-3D"> <span class="method-name">namespace=</span><span class="method-args">(ns)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="namespace-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 639
def namespace= ns
  return set_namespace(ns) unless ns

  unless Nokogiri::XML::Namespace === ns
    raise TypeError, "#{ns.class} can't be coerced into Nokogiri::XML::Namespace"
  end
  if ns.document != document
    raise ArgumentError, 'namespace must be declared on the same document'
  end

  set_namespace ns
end</pre> </div> <p>Set the default namespace on this node (as would be defined with an “xmlns=” attribute in <a href="../xml"><code>XML</code></a> source), as a <a href="namespace"><code>Namespace</code></a> object <code>ns</code>. Note that a <a href="namespace"><code>Namespace</code></a> added this way will NOT be serialized as an xmlns attribute for this node. You probably want <a href="node#method-i-default_namespace-3D"><code>default_namespace=</code></a> instead, or perhaps <a href="node#method-i-add_namespace_definition"><code>add_namespace_definition</code></a> with a nil prefix argument.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespace_definitions"> <span class="method-callseq"> namespace_definitions() </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="namespace_definitions-source"> <pre class="c" data-language="c">static VALUE namespace_definitions(VALUE self)
{
  /* this code in the mode of xmlHasProp() */
  xmlNodePtr node ;
  VALUE list;
  xmlNsPtr ns;

  Data_Get_Struct(self, xmlNode, node);

  list = rb_ary_new();

  ns = node-&gt;nsDef;

  if(!ns) { return list; }

  while(NULL != ns) {
    rb_ary_push(list, Nokogiri_wrap_xml_namespace(node-&gt;doc, ns));
    ns = ns-&gt;next;
  }

  return list;
}</pre> </div> <p>returns namespaces defined on self element directly, as an array of <a href="namespace"><code>Namespace</code></a> objects. Includes both a default namespace (as in“xmlns=”), and prefixed namespaces (as in “xmlns:prefix=”).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespace_scopes"> <span class="method-callseq"> namespace_scopes() </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="namespace_scopes-source"> <pre class="c" data-language="c">static VALUE namespace_scopes(VALUE self)
{
  xmlNodePtr node ;
  VALUE list;
  xmlNsPtr *ns_list;
  int j;

  Data_Get_Struct(self, xmlNode, node);

  list = rb_ary_new();
  ns_list = xmlGetNsList(node-&gt;doc, node);

  if(!ns_list) { return list; }

  for (j = 0 ; ns_list[j] != NULL ; ++j) {
    rb_ary_push(list, Nokogiri_wrap_xml_namespace(node-&gt;doc, ns_list[j]));
  }

  xmlFree(ns_list);
  return list;
}</pre> </div> <p>returns namespaces in scope for self – those defined on self element directly or any ancestor node – as an array of <a href="namespace"><code>Namespace</code></a> objects. Default namespaces (“xmlns=” style) for self are included in this array; Default namespaces for ancestors, however, are not. See also <a href="node#method-i-namespaces"><code>namespaces</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespaced_key-3F"> <span class="method-callseq"> namespaced_key?(attribute, namespace) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="namespaced_key-3F-source"> <pre class="c" data-language="c">static VALUE namespaced_key_eh(VALUE self, VALUE attribute, VALUE namespace)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if(xmlHasNsProp(node, (xmlChar *)StringValueCStr(attribute),
                  NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace))) {
    return Qtrue;
  }
  return Qfalse;
}</pre> </div> <p>Returns true if <code>attribute</code> is set with <code>namespace</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespaces"> <span class="method-name">namespaces</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="namespaces-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 511
def namespaces
  Hash[namespace_scopes.map { |nd|
    key = ['xmlns', nd.prefix].compact.join(':')
    [key, nd.href]
  }]
end</pre> </div> <p>Returns a Hash of +{prefix =&gt; value}+ for all namespaces on this node and its ancestors.</p> <p>This method returns the same namespaces as <a href="node#method-i-namespace_scopes"><code>namespace_scopes</code></a>.</p> <p>Returns namespaces in scope for self – those defined on self element directly or any ancestor node – as a Hash of attribute-name/value pairs. Note that the keys in this hash <a href="../xml"><code>XML</code></a> attributes that would be used to define this namespace, such as “xmlns:prefix”, not just the prefix. Default namespace set on self will be included with key “xmlns”. However, default namespaces set on ancestor will NOT be, even if self has no explicit default namespace.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-native_content-3D"> <span class="method-callseq"> content= </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="native_content-3D-source"> <pre class="c" data-language="c">static VALUE set_native_content(VALUE self, VALUE content)
{
  xmlNodePtr node, child, next ;
  Data_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  while (NULL != child) {
    next = child-&gt;next ;
    xmlUnlinkNode(child) ;
    nokogiri_root_node(child);
    child = next ;
  }

  xmlNodeSetContent(node, (xmlChar *)StringValueCStr(content));
  return content;
}</pre> </div> <p>Set the content for this <a href="node"><code>Node</code></a></p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-next"> <span class="method-name">next</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-next_sibling">next_sibling</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-next_element"> <span class="method-callseq"> next_element </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="next_element-source"> <pre class="c" data-language="c">static VALUE next_element(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = xmlNextElementSibling(node);
  if(!sibling) { return Qnil; }

  return Nokogiri_wrap_xml_node(Qnil, sibling);
}</pre> </div> <p>Returns the next <a href="element"><code>Nokogiri::XML::Element</code></a> type sibling node.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-next_sibling"> <span class="method-callseq"> next_sibling </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="next_sibling-source"> <pre class="c" data-language="c">static VALUE next_sibling(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = node-&gt;next;
  if(!sibling) { return Qnil; }

  return Nokogiri_wrap_xml_node(Qnil, sibling) ;
}</pre> </div> <p>Returns the next sibling node</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-next">next</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-node_name"> <span class="method-callseq"> name </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="node_name-source"> <pre class="c" data-language="c">static VALUE get_name(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if(node-&gt;name) {
    return NOKOGIRI_STR_NEW2(node-&gt;name);
  }
  return Qnil;
}</pre> </div> <p>Returns the name for this <a href="node"><code>Node</code></a></p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-name">name</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-node_name-3D"> <span class="method-callseq"> name=(new_name) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="node_name-3D-source"> <pre class="c" data-language="c">static VALUE set_name(VALUE self, VALUE new_name)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  xmlNodeSetName(node, (xmlChar*)StringValueCStr(new_name));
  return new_name;
}</pre> </div> <p>Set the name for this <a href="node"><code>Node</code></a></p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-name-3D">name=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-node_type"> <span class="method-callseq"> node_type </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="node_type-source"> <pre class="c" data-language="c">static VALUE node_type(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return INT2NUM((long)node-&gt;type);
}</pre> </div> <p>Get the type for this <a href="node"><code>Node</code></a></p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-type">type</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parent"> <span class="method-callseq"> parent </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parent-source"> <pre class="c" data-language="c">static VALUE get_parent(VALUE self)
{
  xmlNodePtr node, parent;
  Data_Get_Struct(self, xmlNode, node);

  parent = node-&gt;parent;
  if(!parent) { return Qnil; }

  return Nokogiri_wrap_xml_node(Qnil, parent) ;
}</pre> </div> <p>Get the parent <a href="node"><code>Node</code></a> for this <a href="node"><code>Node</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parent-3D"> <span class="method-name">parent=</span><span class="method-args">(parent_node)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parent-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 492
def parent= parent_node
  parent_node.add_child(self)
  parent_node
end</pre> </div> <p>Set the parent <a href="node"><code>Node</code></a> for this <a href="node"><code>Node</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parse"> <span class="method-name">parse</span><span class="method-args">(string_or_io, options = nil) { |options| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 450
def parse string_or_io, options = nil
  ##
  # When the current node is unparented and not an element node, use the
  # document as the parsing context instead. Otherwise, the in-context
  # parser cannot find an element or a document node.
  # Document Fragments are also not usable by the in-context parser.
  if !element? &amp;&amp; !document? &amp;&amp; (!parent || parent.fragment?)
    return document.parse(string_or_io, options)
  end

  options ||= (document.html? ? ParseOptions::DEFAULT_HTML : ParseOptions::DEFAULT_XML)
  if Integer === options
    options = Nokogiri::XML::ParseOptions.new(options)
  end
  # Give the options to the user
  yield options if block_given?

  contents = string_or_io.respond_to?(:read) ?
    string_or_io.read :
    string_or_io

  return Nokogiri::XML::NodeSet.new(document) if contents.empty?

  ##
  # This is a horrible hack, but I don't care. See #313 for background.
  error_count = document.errors.length
  node_set = in_context(contents, options.to_i)
  if node_set.empty? and document.errors.length &gt; error_count and options.recover?
    fragment = Nokogiri::HTML::DocumentFragment.parse contents
    node_set = fragment.children
  end
  node_set
end</pre> </div> <p>Parse <code>string_or_io</code> as a document fragment within the context of <strong>this</strong> node. Returns a <a href="nodeset"><code>XML::NodeSet</code></a> containing the nodes parsed from <code>string_or_io</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-path"> <span class="method-callseq"> path </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="path-source"> <pre class="c" data-language="c">static VALUE path(VALUE self)
{
  xmlNodePtr node;
  xmlChar *path ;
  VALUE rval;

  Data_Get_Struct(self, xmlNode, node);

  path = xmlGetNodePath(node);
  rval = NOKOGIRI_STR_NEW2(path);
  xmlFree(path);
  return rval ;
}</pre> </div> <p>Returns the path associated with this <a href="node"><code>Node</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pointer_id"> <span class="method-callseq"> pointer_id </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pointer_id-source"> <pre class="c" data-language="c">static VALUE pointer_id(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);

  return INT2NUM((long)(node));
}</pre> </div> <p>Get the internal pointer number</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-prepend_child"> <span class="method-name">prepend_child</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="prepend_child-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 154
def prepend_child node_or_tags
  if first = children.first
    # Mimic the error add_child would raise.
    raise RuntimeError, "Document already has a root node" if document? &amp;&amp; !(node_or_tags.comment? || node_or_tags.processing_instruction?)
    first.__send__(:add_sibling, :previous, node_or_tags)
  else
    add_child(node_or_tags)
  end
end</pre> </div> <p>Add <code>node_or_tags</code> as the first child of this <a href="node"><code>Node</code></a>. <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node"><code>Node</code></a>), or <a href="nodeset"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment"><code>DocumentFragment</code></a>, <a href="nodeset"><code>NodeSet</code></a>, or string).</p> <p>Also see related method <code>add_child</code>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-previous"> <span class="method-name">previous</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-previous_sibling">previous_sibling</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-previous-3D"> <span class="method-name">previous=</span><span class="method-args">(node_or_tags)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-add_previous_sibling">add_previous_sibling</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-previous_element"> <span class="method-callseq"> previous_element </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="previous_element-source"> <pre class="c" data-language="c">static VALUE previous_element(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  /*
   *  note that we don't use xmlPreviousElementSibling here because it's buggy pre-2.7.7.
   */
  sibling = node-&gt;prev;
  if(!sibling) { return Qnil; }

  while(sibling &amp;&amp; sibling-&gt;type != XML_ELEMENT_NODE) {
    sibling = sibling-&gt;prev;
  }

  return sibling ? Nokogiri_wrap_xml_node(Qnil, sibling) : Qnil ;
}</pre> </div> <p>Returns the previous <a href="element"><code>Nokogiri::XML::Element</code></a> type sibling node.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-previous_sibling"> <span class="method-callseq"> previous_sibling </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="previous_sibling-source"> <pre class="c" data-language="c">static VALUE previous_sibling(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = node-&gt;prev;
  if(!sibling) { return Qnil; }

  return Nokogiri_wrap_xml_node(Qnil, sibling);
}</pre> </div> <p>Returns the previous sibling node</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-previous">previous</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-processing_instruction-3F"> <span class="method-name">processing_instruction?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="processing_instruction-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 544
def processing_instruction?
  type == PI_NODE
end</pre> </div> <p>Returns true if this is a <a href="processinginstruction"><code>ProcessingInstruction</code></a> node</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-read_only-3F"> <span class="method-name">read_only?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="read_only-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 568
def read_only?
  # According to gdome2, these are read-only node types
  [NOTATION_NODE, ENTITY_NODE, ENTITY_DECL].include?(type)
end</pre> </div> <p>Is this a read only node?</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-remove"> <span class="method-name">remove</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-unlink">unlink</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_attribute"> <span class="method-name">remove_attribute</span><span class="method-args">(name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_attribute-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 425
def remove_attribute name
  attr = attributes[name].remove if key? name
  clear_xpath_context if Nokogiri.jruby?
  attr
end</pre> </div> <p>Remove the attribute named <code>name</code></p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-delete">delete</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_class"> <span class="method-name">remove_class</span><span class="method-args">(name = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_class-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 409
def remove_class name = nil
  if name
    names = classes - name.scan(/\S+/)
    if names.empty?
      delete 'class'
    else
      self['class'] = names.join(' ')
    end
  else
    delete "class"
  end
  self
end</pre> </div> <p>Remove <code>name</code> from the “class” attribute value of this <a href="node"><code>Node</code></a> and return self. If there are many occurrences of the name, they are all removed.</p> <p>More than one class may be removed at a time, separated by a space.</p> <p>If no class name is left after removal, or when <code>name</code> is nil, the “class” attribute is removed from this <a href="node"><code>Node</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-replace"> <span class="method-name">replace</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="replace-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 275
def replace node_or_tags
  # We cannot replace a text node directly, otherwise libxml will return
  # an internal error at parser.c:13031, I don't know exactly why
  # libxml is trying to find a parent node that is an element or document
  # so I can't tell if this is bug in libxml or not. issue #775.
  if text?
    replacee = Nokogiri::XML::Node.new 'dummy', document
    add_previous_sibling_node replacee
    unlink
    return replacee.replace node_or_tags
  end

  node_or_tags = coerce(node_or_tags)

  if node_or_tags.is_a?(XML::NodeSet)
    node_or_tags.each { |n| add_previous_sibling n }
    unlink
  else
    replace_node node_or_tags
  end
  node_or_tags
end</pre> </div> <p>Replace this <a href="node"><code>Node</code></a> with <code>node_or_tags</code>. <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="node"><code>Node</code></a>), or <a href="nodeset"><code>NodeSet</code></a> (if <code>node_or_tags</code> is a <a href="documentfragment"><code>DocumentFragment</code></a>, <a href="nodeset"><code>NodeSet</code></a>, or string).</p> <p>Also see related method <code>swap</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-serialize"> <span class="method-name">serialize</span><span class="method-args">(*args, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="serialize-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 687
def serialize *args, &amp;block
  options = args.first.is_a?(Hash) ? args.shift : {
    :encoding   =&gt; args[0],
    :save_with  =&gt; args[1]
  }

  encoding = options[:encoding] || document.encoding
  options[:encoding] = encoding

  outstring = String.new
  outstring.force_encoding(Encoding.find(encoding || 'utf-8'))
  io = StringIO.new(outstring)
  write_to io, options, &amp;block
  io.string
end</pre> </div> <p>Serialize <a href="node"><code>Node</code></a> using <code>options</code>. Save options can also be set using a block. See <a href="node/saveoptions"><code>SaveOptions</code></a>.</p> <p>These two statements are equivalent:</p> <pre class="ruby" data-language="ruby">node.serialize(:encoding =&gt; 'UTF-8', :save_with =&gt; FORMAT | AS_XML)
</pre> <p>or</p> <pre class="ruby" data-language="ruby">node.serialize(:encoding =&gt; 'UTF-8') do |config|
  config.format.as_xml
end
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-set_attribute"> <span class="method-name">set_attribute</span><span class="method-args">(name, value)</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-5B-5D-3D">[]=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-swap"> <span class="method-name">swap</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="swap-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 305
def swap node_or_tags
  replace node_or_tags
  self
end</pre> </div> <p>Swap this <a href="node"><code>Node</code></a> for <code>node_or_tags</code> <code>node_or_tags</code> can be a <a href="node"><code>Nokogiri::XML::Node</code></a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns self, to support chaining of calls.</p> <p>Also see related method <code>replace</code>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-text"> <span class="method-name">text</span><span class="method-args">()</span> </div>  <div class="aliases"> Also aliased as: <a href="node#method-i-to_str">to_str</a> </div> <div class="aliases"> Alias for: <a href="node#method-i-content">content</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-text-3F"> <span class="method-name">text?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="text-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 549
def text?
  type == TEXT_NODE
end</pre> </div> <p>Returns true if this is a <a href="text"><code>Text</code></a> node</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_html"> <span class="method-name">to_html</span><span class="method-args">(options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_html-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 710
def to_html options = {}
  to_format SaveOptions::DEFAULT_HTML, options
end</pre> </div> <p>Serialize this <a href="node"><code>Node</code></a> to <a href="../html"><code>HTML</code></a></p> <pre class="ruby" data-language="ruby">doc.to_html
</pre> <p>See <a href="node#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code>. For formatted output, use <a href="node#method-i-to_xhtml"><code>Node#to_xhtml</code></a> instead.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 582
def to_s
  document.xml? ? to_xml : to_html
end</pre> </div> <p>Turn this node in to a string. If the document is <a href="../html"><code>HTML</code></a>, this method returns html. If the document is <a href="../xml"><code>XML</code></a>, this method returns <a href="../xml"><code>XML</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-to_str"> <span class="method-name">to_str</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-text">text</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_xhtml"> <span class="method-name">to_xhtml</span><span class="method-args">(options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_xhtml-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 731
def to_xhtml options = {}
  to_format SaveOptions::DEFAULT_XHTML, options
end</pre> </div> <p>Serialize this <a href="node"><code>Node</code></a> to XHTML using <code>options</code></p> <pre class="ruby" data-language="ruby">doc.to_xhtml(:indent =&gt; 5, :encoding =&gt; 'UTF-8')
</pre> <p>See <a href="node#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_xml"> <span class="method-name">to_xml</span><span class="method-args">(options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_xml-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 720
def to_xml options = {}
  options[:save_with] ||= SaveOptions::DEFAULT_XML
  serialize(options)
end</pre> </div> <p>Serialize this <a href="node"><code>Node</code></a> to <a href="../xml"><code>XML</code></a> using <code>options</code></p> <pre class="ruby" data-language="ruby">doc.to_xml(:indent =&gt; 5, :encoding =&gt; 'UTF-8')
</pre> <p>See <a href="node#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-traverse"> <span class="method-name">traverse</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="traverse-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 654
def traverse &amp;block
  children.each{|j| j.traverse(&amp;block) }
  block.call(self)
end</pre> </div> <p>Yields self and all children to <code>block</code> recursively.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-type"> <span class="method-name">type</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="node#method-i-node_type">node_type</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-unlink"> <span class="method-callseq"> unlink </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="unlink-source"> <pre class="c" data-language="c">static VALUE unlink_node(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  xmlUnlinkNode(node);
  nokogiri_root_node(node);
  return self;
}</pre> </div> <p>Unlink this node from its current context.</p>  </div> <div class="aliases"> Also aliased as: <a href="node#method-i-remove">remove</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-values"> <span class="method-name">values</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="values-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 347
def values
  attribute_nodes.map(&amp;:value)
end</pre> </div> <p>Get the attribute values for this <a href="node"><code>Node</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-wrap"> <span class="method-name">wrap</span><span class="method-args">(html)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="wrap-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 169
def wrap(html)
  new_parent = document.parse(html).first
  add_next_sibling(new_parent)
  new_parent.add_child(self)
  self
end</pre> </div> <p>Add html around this node</p> <p>Returns self</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_html_to"> <span class="method-name">write_html_to</span><span class="method-args">(io, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="write_html_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 774
def write_html_to io, options = {}
  write_format_to SaveOptions::DEFAULT_HTML, io, options
end</pre> </div> <p>Write <a href="node"><code>Node</code></a> as <a href="../html"><code>HTML</code></a> to <code>io</code> with <code>options</code></p> <p>See <a href="node#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_to"> <span class="method-name">write_to</span><span class="method-args">(io, *options) { |config| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="write_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 752
def write_to io, *options
  options       = options.first.is_a?(Hash) ? options.shift : {}
  encoding      = options[:encoding] || options[0]
  if Nokogiri.jruby?
    save_options  = options[:save_with] || options[1]
    indent_times  = options[:indent] || 0
  else
    save_options  = options[:save_with] || options[1] || SaveOptions::FORMAT
    indent_times  = options[:indent] || 2
  end
  indent_text   = options[:indent_text] || ' '

  config = SaveOptions.new(save_options.to_i)
  yield config if block_given?

  native_write_to(io, encoding, indent_text * indent_times, config.options)
end</pre> </div> <p>Write <a href="node"><code>Node</code></a> to <code>io</code> with <code>options</code>. <code>options</code> modify the output of this method. Valid options are:</p> <ul>
<li> <p><code>:encoding</code> for changing the encoding</p> </li>
<li> <p><code>:indent_text</code> the indentation text, defaults to one space</p> </li>
<li> <p><code>:indent</code> the number of <code>:indent_text</code> to use, defaults to 2</p> </li>
<li> <p><code>:save_with</code> a combination of <a href="node/saveoptions"><code>SaveOptions</code></a> constants.</p> </li>
</ul> <p>To save with UTF-8 indented twice:</p> <pre class="ruby" data-language="ruby">node.write_to(io, :encoding =&gt; 'UTF-8', :indent =&gt; 2)
</pre> <p>To save indented with two dashes:</p> <pre class="ruby" data-language="ruby">node.write_to(io, :indent_text =&gt; '-', :indent =&gt; 2)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_xhtml_to"> <span class="method-name">write_xhtml_to</span><span class="method-args">(io, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="write_xhtml_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 782
def write_xhtml_to io, options = {}
  write_format_to SaveOptions::DEFAULT_XHTML, io, options
end</pre> </div> <p>Write <a href="node"><code>Node</code></a> as XHTML to <code>io</code> with <code>options</code></p> <p>See <a href="node#method-i-write_to"><code>Node#write_to</code></a> for a list of <code>options</code></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_xml_to"> <span class="method-name">write_xml_to</span><span class="method-args">(io, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="write_xml_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 792
def write_xml_to io, options = {}
  options[:save_with] ||= SaveOptions::DEFAULT_XML
  write_to io, options
end</pre> </div> <p>Write <a href="node"><code>Node</code></a> as <a href="../xml"><code>XML</code></a> to <code>io</code> with <code>options</code></p> <pre class="ruby" data-language="ruby">doc.write_xml_to io, :encoding =&gt; 'UTF-8'
</pre> <p>See <a href="node#method-i-write_to"><code>Node#write_to</code></a> for a list of options</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-xml-3F"> <span class="method-name">xml?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="xml-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 529
def xml?
  type == DOCUMENT_NODE
end</pre> </div> <p>Returns true if this is an <a href="document"><code>XML::Document</code></a> node</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2008–2018 Aaron Patterson, Mike Dalessio, Charles Nutter, Sergio Arbeo,<br>Patrick Mahoney, Yoko Harada, Akinori MUSHA, John Shahid, Lars Kanis<br>Licensed under the MIT License.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
