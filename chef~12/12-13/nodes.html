
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Nodes - Chef 12 - W3cubDocs</title>
  
  <meta name="description" content=" A node is any machine—physical, virtual, cloud, network device, etc.—that is under management by Chef. ">
  <meta name="keywords" content="about, nodes, chef, chef~12">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/chef~12/12-13/nodes.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/chef~12.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/chef~12/" class="_nav-link" title="" style="margin-left:0;">Chef 12</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx_simple">
				
				
<h1 id="about-nodes">About Nodes</h1> <p>A node is any machine—physical, virtual, cloud, network device, etc.—that is under management by Chef.</p> <p>The types of nodes that can be managed by Chef include, but are not limited to, the following:</p> <table class="docutils"> <colgroup> <col width="19%"> <col width="81%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Node Type</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>
<img src="https://docs-archive.chef.io/release/12-13/_images/icon_node_type_server.svg" width="100px">  </td> <td>A physical node is typically a server or a virtual machine, but it can be any active device attached to a network that is capable of sending, receiving, and forwarding information over a communications channel. In other words, a physical node is any active device attached to a network that can run a chef-client and also allow that chef-client to communicate with a Chef server.</td> </tr> <tr class="row-odd">
<td>
<img src="https://docs-archive.chef.io/release/12-13/_images/icon_node_type_cloud_public.svg" width="100px">  </td> <td>A cloud-based node is hosted in an external cloud-based service, such as Amazon Web Services (AWS), OpenStack, Rackspace, Google Compute Engine, or Microsoft Azure. Plugins are available for knife that provide support for external cloud-based services. knife can use these plugins to create instances on cloud-based services. Once created, the chef-client can be used to deploy, configure, and maintain those instances.</td> </tr> <tr class="row-even">
<td>
<img src="https://docs-archive.chef.io/release/12-13/_images/icon_node_virtual_machine.svg" width="100px">  </td> <td>A virtual node is a machine that runs only as a software implementation, but otherwise behaves much like a physical machine.</td> </tr> <tr class="row-odd">
<td>
<img src="https://docs-archive.chef.io/release/12-13/_images/icon_node_type_network_device.svg" width="100px">  </td> <td>A network node is any networking device—a switch, a router—that is being managed by a chef-client, such as networking devices by Juniper Networks, Arista, Cisco, and F5. Use Chef to automate common network configurations, such as physical and logical Ethernet link properties and VLANs, on these devices.</td> </tr> <tr class="row-even">
<td>
<img src="https://docs-archive.chef.io/release/12-13/_images/icon_node_type_container.svg" width="100px">  </td> <td>Containers are an approach to virtualization that allows a single operating system to host many working configurations, where each working configuration—a container—is assigned a single responsibility that is isolated from all other responsibilities. Containers are popular as a way to manage distributed and scalable applications and services.</td> </tr> </tbody> </table> <p>The key components of nodes that are under management by Chef include:</p> <table class="docutils"> <colgroup> <col width="19%"> <col width="81%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Component</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>
<img src="https://docs-archive.chef.io/release/12-13/_images/icon_chef_client.svg" width="100px">  </td> <td>
<p class="first">A chef-client is an agent that runs locally on every node that is under management by Chef. When a chef-client is run, it will perform all of the steps that are required to bring the node into the expected state, including:</p> <ul class="simple"> <li>Registering and authenticating the node with the Chef server</li> <li>Building the node object</li> <li>Synchronizing cookbooks</li> <li>Compiling the resource collection by loading each of the required cookbooks, including recipes, attributes, and all other dependencies</li> <li>Taking the appropriate and required actions to configure the node</li> <li>Looking for exceptions and notifications, handling each as required</li> </ul> <p class="last">RSA public key-pairs are used to authenticate the chef-client with the Chef server every time a chef-client needs access to data that is stored on the Chef server. This prevents any node from accessing data that it shouldn’t and it ensures that only nodes that are properly registered with the Chef server can be managed.</p> </td> </tr> <tr class="row-odd">
<td>
<img src="https://docs-archive.chef.io/release/12-13/_images/icon_ohai.svg" width="100px">  </td> <td>
<p class="first">Ohai is a tool that is used to detect attributes on a node, and then provide these attributes to the chef-client at the start of every chef-client run. Ohai is required by the chef-client and must be present on a node. (Ohai is installed on a node as part of the chef-client install process.)</p> <p>The types of attributes Ohai collects include (but are not limited to):</p> <ul class="simple"> <li>Platform details</li> <li>Network usage</li> <li>Memory usage</li> <li>CPU data</li> <li>Kernel data</li> <li>Host names</li> <li>Fully qualified domain names</li> <li>Other configuration details</li> </ul> <p class="last">Attributes that are collected by Ohai are automatic attributes, in that these attributes are used by the chef-client to ensure that these attributes remain unchanged after the chef-client is done configuring the node.</p> </td> </tr> </tbody> </table>  <h2 id="the-chef-client-run">The chef-client Run</h2> <p>A “chef-client run” is the term used to describe a series of steps that are taken by the chef-client when it is configuring a node. The following diagram shows the various stages that occur during the chef-client run, and then the list below the diagram describes in greater detail each of those stages.</p> <img alt="_images/chef_run.png" src="https://docs-archive.chef.io/release/12-13/_images/chef_run.png"> <p>During every chef-client run, the following happens:</p> <table class="docutils"> <colgroup> <col width="25%"> <col width="75%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Stages</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td><strong>Get configuration data</strong></td> <td>The chef-client gets process configuration data from the client.rb file on the node, and then gets node configuration data from Ohai. One important piece of configuration data is the name of the node, which is found in the <code class="docutils literal">node_name</code> attribute in the client.rb file or is provided by Ohai. If Ohai provides the name of a node, it is typically the FQDN for the node, which is always unique within an organization.</td> </tr> <tr class="row-odd">
<td><strong>Authenticate to the Chef Server</strong></td> <td>The chef-client authenticates to the Chef server using an RSA private key and the Chef server API. The name of the node is required as part of the authentication process to the Chef server. If this is the first chef-client run for a node, the chef-validator will be used to generate the RSA private key.</td> </tr> <tr class="row-even">
<td><strong>Get, rebuild the node object</strong></td> <td>The chef-client pulls down the node object from the Chef server. If this is the first chef-client run for the node, there will not be a node object to pull down from the Chef server. After the node object is pulled down from the Chef server, the chef-client rebuilds the node object. If this is the first chef-client run for the node, the rebuilt node object will contain only the default run-list. For any subsequent chef-client run, the rebuilt node object will also contain the run-list from the previous chef-client run.</td> </tr> <tr class="row-odd">
<td><strong>Expand the run-list</strong></td> <td>The chef-client expands the run-list from the rebuilt node object, compiling a full and complete list of roles and recipes that will be applied to the node, placing the roles and recipes in the same exact order they will be applied. (The run-list is stored in each node object’s JSON file, grouped under <code class="docutils literal">run_list</code>.)</td> </tr> <tr class="row-even">
<td><strong>Synchronize cookbooks</strong></td> <td>The chef-client asks the Chef server for a list of all cookbook files (including recipes, templates, resources, providers, attributes, libraries, and definitions) that will be required to do every action identified in the run-list for the rebuilt node object. The Chef server provides to the chef-client a list of all of those files. The chef-client compares this list to the cookbook files cached on the node (from previous chef-client runs), and then downloads a copy of every file that has changed since the previous chef-client run, along with any new files.</td> </tr> <tr class="row-odd">
<td><strong>Reset node attributes</strong></td> <td>All attributes in the rebuilt node object are reset. All attributes from attribute files, environments, roles, and Ohai are loaded. Attributes that are defined in attribute files are first loaded according to cookbook order. For each cookbook, attributes in the <code class="docutils literal">default.rb</code> file are loaded first, and then additional attribute files (if present) are loaded in lexical sort order. All attributes in the rebuilt node object are updated with the attribute data according to attribute precedence. When all of the attributes are updated, the rebuilt node object is complete.</td> </tr> <tr class="row-even">
<td><strong>Compile the resource collection</strong></td> <td>The chef-client identifies each resource in the node object and builds the resource collection. Libraries are loaded first to ensure that all language extensions and Ruby classes are available to all resources. Next, attributes are loaded, followed by lightweight resources, and then all definitions (to ensure that any pseudo-resources within definitions are available). Finally, all recipes are loaded in the order specified by the expanded run-list. This is also referred to as the “compile phase”.</td> </tr> <tr class="row-odd">
<td><strong>Converge the node</strong></td> <td>The chef-client configures the system based on the information that has been collected. Each resource is executed in the order identified by the run-list, and then by the order in which each resource is listed in each recipe. Each resource in the resource collection is mapped to a provider. The provider examines the node, and then does the steps necessary to complete the action. And then the next resource is processed. Each action configures a specific part of the system. This process is also referred to as convergence. This is also referred to as the “execution phase”.</td> </tr> <tr class="row-even">
<td><strong>Update the node object, process exception and report handlers</strong></td> <td>
<p class="first">When all of the actions identified by resources in the resource collection have been done, and when the chef-client run finished successfully, the chef-client updates the node object on the Chef server with the node object that was built during this chef-client run. (This node object will be pulled down by the chef-client during the next chef-client run.) This makes the node object (and the data in the node object) available for search.</p> <p class="last">The chef-client always checks the resource collection for the presence of exception and report handlers. If any are present, each one is processed appropriately.</p> </td> </tr> <tr class="row-odd">
<td><strong>Stop, wait for the next run</strong></td> <td>When everything is configured and the chef-client run is complete, the chef-client stops and waits until the next time it is asked to run.</td> </tr> </tbody> </table>  <h3 id="about-run-lists">About Run-lists</h3> <p>A run-list defines all of the information necessary for Chef to configure a node into the desired state. A run-list is:</p> <ul class="simple"> <li>An ordered list of roles and/or recipes that are run in the exact order defined in the run-list; if a recipe appears more than once in the run-list, the chef-client will not run it twice</li> <li>Always specific to the node on which it runs; nodes may have a run-list that is identical to the run-list used by other nodes</li> <li>Stored as part of the node object on the Chef server</li> <li>Maintained using knife, and then uploaded from the workstation to the Chef server, or is maintained using the Chef management console</li> </ul>  <h4 id="run-list-format">Run-list Format</h4> <p>A run-list must be in one of the following formats: fully qualified, cookbook, or default. Both roles and recipes must be in quotes, for example:</p> <pre class="highlight-ruby" data-language="ruby">'role[NAME]'</pre> <p>or</p> <pre class="highlight-ruby" data-language="ruby">'recipe[COOKBOOK::RECIPE]'</pre> <p>Use a comma to separate roles and recipes when adding more than one item the run-list:</p> <pre class="highlight-ruby" data-language="ruby">'recipe[COOKBOOK::RECIPE],COOKBOOK::RECIPE,role[NAME]'</pre>   <h4 id="empty-run-lists">Empty Run-lists</h4> <p>Use an empty run-list to determine if a failed chef-client run has anything to do with the recipes that are defined within that run-list. This is a quick way to discover if the underlying cause of a chef-client run failure is a configuration issue. If a failure persists even if the run-list is empty, check the following:</p> <ul class="simple"> <li>Configuration settings in the knife.rb file</li> <li>Permissions for the user to both the Chef server and to the node on which the chef-client run is to take place</li> </ul>     <h2 id="about-why-run-mode">About why-run Mode</h2> <p>why-run mode is a way to see what the chef-client would have configured, had an actual chef-client run occurred. This approach is similar to the concept of “no-operation” (or “no-op”): decide what should be done, but then don’t actually do anything until it’s done right. This approach to configuration management can help identify where complexity exists in the system, where inter-dependencies may be located, and to verify that everything will be configured in the desired manner.</p> <p>When why-run mode is enabled, a chef-client run will occur that does everything up to the point at which configuration would normally occur. This includes getting the configuration data, authenticating to the Chef server, rebuilding the node object, expanding the run-list, getting the necessary cookbook files, resetting node attributes, identifying the resources, and building the resource collection and does not include mapping each resource to a provider or configuring any part of the system.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">why-run mode is not a replacement for running cookbooks in a test environment that mirrors the production environment. Chef uses why-run mode to learn more about what is going on, but also Kitchen on developer systems, along with an internal OpenStack cloud and external cloud providers to test more thoroughly.</p> </div> <p>When the chef-client is run in why-run mode, certain assumptions are made:</p> <ul class="simple"> <li>If the <strong>service</strong> resource cannot find the appropriate command to verify the status of a service, why-run mode will assume that the command would have been installed by a previous resource and that the service would not be running</li> <li>For <code class="docutils literal">not_if</code> and <code class="docutils literal">only_if</code> attribute, why-run mode will assume these are commands or blocks that are safe to run. These conditions are not designed to be used to change the state of the system, but rather to help facilitate idempotency for the resource itself. That said, it may be possible that these attributes are being used in a way that modifies the system state</li> <li>The closer the current state of the system is to the desired state, the more useful why-run mode will be. For example, if a full run-list is run against a fresh system, that run-list may not be completely correct on the first try, but also that run-list will produce more output than a smaller run-list</li> </ul> <p>For example, the <strong>service</strong> resource can be used to start a service. If the action is <code class="docutils literal">:start</code> and the service is not running, then start the service (if it is not running) and do nothing (if it is running). What about a service that is installed from a package? The chef-client cannot check to see if the service is running until after the package is installed. A simple question that why-run mode can answer is what the chef-client would say about the state of the service after installing the package because service actions often trigger notifications to other resources. So it can be important to know in advance that any notifications are being triggered correctly.</p> <p>For a detailed explanation of the dry-run concept and how it relates to the why-run mode, see <a class="reference external" href="http://blog.afistfulofservers.net/post/2012/12/21/promises-lies-and-dryrun-mode/">this blog post</a>.</p>   <h2 id="about-node-names">About Node Names</h2> <p>The name of a node is required as part of the authentication process to the Chef server. The name of each node must be unique within an organization, but otherwise can be any string that matches the following regular expression:</p> <pre class="highlight-python" data-language="python">/^[\-[:alnum:]_:.]+$/</pre> <p>The name of a node can be obtained from the <code class="docutils literal">node_name</code> attribute in the client.rb file or by allowing Ohai to collect this data during the chef-client run. When Ohai collects this data during the chef-client run, it uses the FQDN name of the node (which is always unique within an organization) as the name of the node.</p> <p>Using the FQDN as the node name, and then allowing Ohai to collect this information during each chef-client run, is the recommended approach and the easiest way to ensure that the names of all nodes across the organization are unique.</p>   <h2 id="manage-nodes">Manage Nodes</h2> <p>There are several ways to manage nodes directly, including by using knife, the Chef management console add-on for the Chef server, or by using command-line tools that are specific to chef-client.</p> <ul class="simple"> <li>knife can be used to create, edit, view, list, tag, and delete nodes.</li> <li>knife plug-ins can be used to create, edit, and manage nodes that are located on cloud providers.</li> <li>The Chef management console add-on can be used to create, edit, view, list, tag, and delete nodes. In addition, node attributes can be modified and nodes can be moved between environments.</li> <li>The chef-client can be used to manage node data using the command line and JSON files. Each JSON file contains a hash, the elements of which are added as node attributes. In addition, the <code class="docutils literal">run_list</code> setting allows roles and/or recipes to be added to the node.</li> <li>chef-solo can be used to manage node data using the command line and JSON files. Each JSON file contains a hash, the elements of which are added as node attributes. In addition, the <code class="docutils literal">run_list</code> setting allows roles and/or recipes to be added to the node.</li> <li>The command line can also be used to edit JSON files and files that are related to third-party services, such as Amazon EC2, where the JSON files can contain per-instance metadata that is stored in a file on-disk and then read by chef-solo or chef-client as required.</li> </ul>   <h2 id="node-objects">Node Objects</h2> <p>For the chef-client, two important aspects of nodes are groups of attributes and run-lists. An attribute is a specific piece of data about the node, such as a network interface, a file system, the number of clients a service running on a node is capable of accepting, and so on. A run-list is an ordered list of recipes and/or roles that are run in an exact order. The node object consists of the run-list and node attributes, which is a JSON file that is stored on the Chef server. The chef-client gets a copy of the node object from the Chef server during each chef-client run and places an updated copy on the Chef server at the end of each chef-client run.</p> <p>An attribute is a specific detail about a node. Attributes are used by the chef-client to understand:</p> <ul class="simple"> <li>The current state of the node</li> <li>What the state of the node was at the end of the previous chef-client run</li> <li>What the state of the node should be at the end of the current chef-client run</li> </ul> <p>Attributes are defined by:</p> <ul class="simple"> <li>The state of the node itself</li> <li>Cookbooks (in attribute files and/or recipes)</li> <li>Roles</li> <li>Environments</li> </ul> <p>During every chef-client run, the chef-client builds the attribute list using:</p> <ul class="simple"> <li>Data about the node collected by Ohai</li> <li>The node object that was saved to the Chef server at the end of the previous chef-client run</li> <li>The rebuilt node object from the current chef-client run, after it is updated for changes to cookbooks (attribute files and/or recipes), roles, and/or environments, and updated for any changes to the state of the node itself</li> </ul> <p>After the node object is rebuilt, all of the attributes are compared, and then the node is updated based on attribute precedence. At the end of every chef-client run, the node object that defines the current state of the node is uploaded to the Chef server so that it can be indexed for search.</p>   <h2 id="attributes">Attributes</h2> <p>An attribute is a specific detail about a node, such as an IP address, a host name, a list of loaded kernel modules, the version(s) of available programming languages that are available, and so on. An attribute may be unique to a specific node or it can be identical across every node in the organization. Attributes are most commonly set from a cookbook, by using knife, or are retrieved by Ohai from each node prior to every chef-client run. All attributes are indexed for search on the Chef server. Good candidates for attributes include:</p> <ul class="simple"> <li>any cross-platform abstraction for an application, such as the path to a configuration file</li> <li>default values for tunable settings, such as the amount of memory assigned to a process or the number of workers to spawn</li> <li>anything that may need to be persisted in node data between chef-client runs</li> </ul> <p>In general, attribute precedence is set to enable cookbooks and roles to define attribute defaults, for normal attributes to define the values that should be specific for a node, and for override attributes to force a certain value, even when a node already has that value specified.</p> <p>One approach is to set attributes at the same precedence level by setting attributes in a cookbook’s attribute files, and then also setting the same default attributes (but with different values) using a role. The attributes set in the role will be deep merged on top of the attributes from the attribute file, and the attributes set by the role will take precedence over the attributes specified in the cookbook’s attribute files.</p> <p>Another (much less common) approach is to set a value only if an attribute has no value. This can be done by using the <code class="docutils literal">_unless</code> variants of the attribute priority methods:</p> <ul> <li>
<p class="first"><code class="docutils literal">default_unless</code></p> </li> <li>
<p class="first"><code class="docutils literal">set_unless</code> (<code class="docutils literal">normal_unless</code> is an alias of <code class="docutils literal">set_unless</code>; use either alias to set an attribute with a normal attribute precedence.)</p> <blockquote> <div>
<div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method was deprecated in Chef client 12.12 and will be removed in Chef 14. Please use <code class="docutils literal">default_unless</code> or <code class="docutils literal">override_unless</code> instead.</p> </div> </div>
</blockquote> </li> <li>
<p class="first"><code class="docutils literal">override_unless</code></p> </li> </ul> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Use the <code class="docutils literal">_unless</code> variants carefully (and only when necessary) because when they are used, attributes applied to nodes may become out of sync with the values in the cookbooks as these cookbooks are updated. This approach can create situations where two otherwise identical nodes end up having slightly different configurations and can also be a challenge to debug.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Attributes can be configured in cookbooks (attribute files and recipes), roles, and environments. In addition, Ohai collects attribute data about each node at the start of the chef-client run. See <a class="reference external" href="https://docs.chef.io/attributes.html">https://docs.chef.io/attributes.html</a> for more information about how all of these attributes fit together.</p> </div>  <h3 id="attribute-types">Attribute Types</h3> <p>The chef-client uses six types of attributes to determine the value that is applied to a node during the chef-client run. In addition, the chef-client sources attribute values from up to five locations. The combination of attribute types and sources allows for up to 15 different competing values to be available to the chef-client during the chef-client run:</p> <table class="docutils"> <colgroup> <col width="40%"> <col width="60%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Attribute Type</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td><code class="docutils literal">default</code></td> <td>A <code class="docutils literal">default</code> attribute is automatically reset at the start of every chef-client run and has the lowest attribute precedence. Use <code class="docutils literal">default</code> attributes as often as possible in cookbooks.</td> </tr> <tr class="row-odd">
<td><code class="docutils literal">force_default</code></td> <td>Use the <code class="docutils literal">force_default</code> attribute to ensure that an attribute defined in a cookbook (by an attribute file or by a recipe) takes precedence over a <code class="docutils literal">default</code> attribute set by a role or an environment.</td> </tr> <tr class="row-even">
<td><code class="docutils literal">normal</code></td> <td>A <code class="docutils literal">normal</code> attribute is a setting that persists in the node object. A <code class="docutils literal">normal</code> attribute has a higher attribute precedence than a <code class="docutils literal">default</code> attribute.</td> </tr> <tr class="row-odd">
<td><code class="docutils literal">override</code></td> <td>An <code class="docutils literal">override</code> attribute is automatically reset at the start of every chef-client run and has a higher attribute precedence than <code class="docutils literal">default</code>, <code class="docutils literal">force_default</code>, and <code class="docutils literal">normal</code> attributes. An <code class="docutils literal">override</code> attribute is most often specified in a recipe, but can be specified in an attribute file, for a role, and/or for an environment. A cookbook should be authored so that it uses <code class="docutils literal">override</code> attributes only when required.</td> </tr> <tr class="row-even">
<td><code class="docutils literal">force_override</code></td> <td>Use the <code class="docutils literal">force_override</code> attribute to ensure that an attribute defined in a cookbook (by an attribute file or by a recipe) takes precedence over an <code class="docutils literal">override</code> attribute set by a role or an environment.</td> </tr> <tr class="row-odd">
<td><code class="docutils literal">automatic</code></td> <td>An <code class="docutils literal">automatic</code> attribute contains data that is identified by Ohai at the beginning of every chef-client run. An <code class="docutils literal">automatic</code> attribute cannot be modified and always has the highest attribute precedence.</td> </tr> </tbody> </table>   <h3 id="attribute-persistence">Attribute Persistence</h3> <p>At the beginning of a chef-client run, all attributes are reset. The chef-client rebuilds them using automatic attributes collected by Ohai at the beginning of the chef-client run and then using default and override attributes that are specified in cookbooks or by roles and environments. Normal attributes are never reset. All attributes are then merged and applied to the node according to attribute precedence. At the conclusion of the chef-client run, the attributes that were applied to the node are saved to the Chef server as part of the node object.</p>   <h3 id="attribute-precedence">Attribute Precedence</h3> <p>Attributes are always applied by the chef-client in the following order:</p> <ol class="arabic simple"> <li>A <code class="docutils literal">default</code> attribute located in a cookbook attribute file</li> <li>A <code class="docutils literal">default</code> attribute located in a recipe</li> <li>A <code class="docutils literal">default</code> attribute located in an environment</li> <li>A <code class="docutils literal">default</code> attribute located in a role</li> <li>A <code class="docutils literal">force_default</code> attribute located in a cookbook attribute file</li> <li>A <code class="docutils literal">force_default</code> attribute located in a recipe</li> <li>A <code class="docutils literal">normal</code> attribute located in a cookbook attribute file</li> <li>A <code class="docutils literal">normal</code> attribute located in a recipe</li> <li>An <code class="docutils literal">override</code> attribute located in a cookbook attribute file</li> <li>An <code class="docutils literal">override</code> attribute located in a recipe</li> <li>An <code class="docutils literal">override</code> attribute located in a role</li> <li>An <code class="docutils literal">override</code> attribute located in an environment</li> <li>A <code class="docutils literal">force_override</code> attribute located in a cookbook attribute file</li> <li>A <code class="docutils literal">force_override</code> attribute located in a recipe</li> <li>An <code class="docutils literal">automatic</code> attribute identified by Ohai at the start of the chef-client run</li> </ol> <p>where the last attribute in the list is the one that is applied to the node.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The attribute precedence order for roles and environments is reversed for <code class="docutils literal">default</code> and <code class="docutils literal">override</code> attributes. The precedence order for <code class="docutils literal">default</code> attributes is environment, then role. The precedence order for <code class="docutils literal">override</code> attributes is role, then environment. Applying environment <code class="docutils literal">override</code> attributes after role <code class="docutils literal">override</code> attributes allows the same role to be used across multiple environments, yet ensuring that values can be set that are specific to each environment (when required). For example, the role for an application server may exist in all environments, yet one environment may use a database server that is different from other environments.</p> </div> <p>Attribute precedence, viewed from the same perspective as the overview diagram, where the numbers in the diagram match the order of attribute precedence:</p> <img alt="_images/overview_chef_attributes_precedence.png" src="https://docs-archive.chef.io/release/12-13/_images/overview_chef_attributes_precedence.png"> <p>Attribute precedence, when viewed as a table:</p> <img alt="_images/overview_chef_attributes_table.png" src="https://docs-archive.chef.io/release/12-13/_images/overview_chef_attributes_table.png">  <h4 id="whitelist-attributes">Whitelist Attributes</h4> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">When these settings are used, any attribute not defined in a whitelist will not be saved. Each attribute type is whitelisted independently of the other attribute types. For example, if <code class="docutils literal">automatic_attribute_whitelist</code> defines attributes to be saved, but <code class="docutils literal">normal_attribute_whitelist</code>, <code class="docutils literal">default_attribute_whitelist</code>, and <code class="docutils literal">override_attribute_whitelist</code> are not defined, then all normal, default and override attributes are saved, along with only the specified automatic attributes.</p> </div> <p>Attributes that should be saved by a node may be whitelisted in the client.rb file. The whitelist is a Hash of keys that specify each attribute to be saved.</p> <p>Attributes are whitelisted by attribute type, with each attribute type being whitelisted independently. Each attribute type—<code class="docutils literal">automatic</code>, <code class="docutils literal">default</code>, <code class="docutils literal">normal</code>, and <code class="docutils literal">override</code>—may define whitelists by using the following settings in the client.rb file:</p> <table class="docutils"> <colgroup> <col width="40%"> <col width="60%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Setting</th> <th class="head">Description</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td><code class="docutils literal">automatic_attribute_whitelist</code></td> <td>A Hash that whitelists <code class="docutils literal">automatic</code> attributes, preventing non-whitelisted attributes from being saved. For example: <code class="docutils literal">['network/interfaces/eth0']</code>. Default value: all attributes are saved. If the Hash is empty, no attributes are saved.</td> </tr> <tr class="row-odd">
<td><code class="docutils literal">default_attribute_whitelist</code></td> <td>A Hash that whitelists <code class="docutils literal">default</code> attributes, preventing non-whitelisted attributes from being saved. For example: <code class="docutils literal">['filesystem/dev/disk0s2/size']</code>. Default value: all attributes are saved. If the Hash is empty, no attributes are saved.</td> </tr> <tr class="row-even">
<td><code class="docutils literal">normal_attribute_whitelist</code></td> <td>A Hash that whitelists <code class="docutils literal">normal</code> attributes, preventing non-whitelisted attributes from being saved. For example: <code class="docutils literal">['filesystem/dev/disk0s2/size']</code>. Default value: all attributes are saved. If the Hash is empty, no attributes are saved.</td> </tr> <tr class="row-odd">
<td><code class="docutils literal">override_attribute_whitelist</code></td> <td>A Hash that whitelists <code class="docutils literal">override</code> attributes, preventing non-whitelisted attributes from being saved. For example: <code class="docutils literal">['map - autohome/size']</code>. Default value: all attributes are saved. If the Hash is empty, no attributes are saved.</td> </tr> </tbody> </table> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">It is recommended that only <code class="docutils literal">automatic_attribute_whitelist</code> be used to whitelist attributes. This is primarily because automatic attributes generate the most data, but also that normal, default, and override attributes are typically much more important attributes and are more likely to cause issues if they are whitelisted incorrectly.</p> </div> <p>For example, normal attribute data similar to:</p> <pre class="highlight-javascript" data-language="javascript">{
  "filesystem" =&gt; {
    "/dev/disk0s2" =&gt; {
      "size" =&gt; "10mb"
    },
    "map - autohome" =&gt; {
      "size" =&gt; "10mb"
    }
  },
  "network" =&gt; {
    "interfaces" =&gt; {
      "eth0" =&gt; {...},
      "eth1" =&gt; {...},
    }
  }
}</pre> <p>To whitelist the <code class="docutils literal">network</code> attributes and prevent the other attributes from being saved, update the client.rb file:</p> <pre class="highlight-ruby" data-language="ruby">normal_attribute_whitelist ['network/interfaces/']</pre> <p>When a whitelist is defined, any attribute of that type that is not specified in that attribute whitelist <strong>will not</strong> be saved. So based on the previous whitelist for normal attributes, the <code class="docutils literal">filesystem</code> and <code class="docutils literal">map - autohome</code> attributes will not be saved, but the <code class="docutils literal">network</code> attributes will.</p> <p>Leave the value empty to prevent all attributes of that attribute type from being saved:</p> <pre class="highlight-ruby" data-language="ruby">normal_attribute_whitelist []</pre> <p>For attributes that contain slashes (<code class="docutils literal">/</code>) within the attribute value, such as the <code class="docutils literal">filesystem</code> attribute <code class="docutils literal">'/dev/diskos2'</code>, use an array. For example:</p> <pre class="highlight-ruby" data-language="ruby">automatic_attribute_whitelist [['filesystem','/dev/diskos2']]</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © Chef Software, Inc.<br>Licensed under the Creative Commons Attribution 3.0 Unported License.<br>The Chef™ Mark and Chef Logo are either registered trademarks/service marks or trademarks/servicemarks of Chef, in the United States and other countries and are used with Chef Inc's permission.<br>We are not affiliated with, endorsed or sponsored by Chef Inc.<br>
    <a href="https://docs-archive.chef.io/release/12-13/nodes.html" class="_attribution-link">https://docs-archive.chef.io/release/12-13/nodes.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
