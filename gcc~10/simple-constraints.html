
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>6.47.3.1. Simple Constraints - GCC 10 - W3cubDocs</title>
  
  <meta name="description" content="The simplest kind of constraint is a string full of letters, each of which describes one kind of operand that is permitted. Here are the letters &hellip;">
  <meta name="keywords" content="simple, constraints, gcc, gcc~10">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/gcc~10/simple-constraints.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/gcc~10.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/gcc~10/" class="_nav-link" title="" style="margin-left:0;">GCC 10</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="subsubsection" id="Simple-Constraints-1">6.47.3.1 Simple Constraints</h1>  <p id="index-simple-constraints">The simplest kind of constraint is a string full of letters, each of which describes one kind of operand that is permitted. Here are the letters that are allowed: </p> <dl compact> <dt>whitespace</dt> <dd id="index-memory-references-in-constraints">
<p>Whitespace characters are ignored and can be inserted at any position except the first. This enables each alternative for different operands to be visually aligned in the machine description even if they have different number of constraints and modifiers. </p>   </dd> <dt>‘<samp>m</samp>’</dt> <dd id="index-o-in-constraint">
<p>A memory operand is allowed, with any kind of address that the machine supports in general. Note that the letter used for the general memory constraint can be re-defined by a back end using the <code>TARGET_MEM_CONSTRAINT</code> macro. </p>   </dd> <dt>‘<samp>o</samp>’</dt> <dd id="index-V-in-constraint">
<p>A memory operand is allowed, but only if the address is <em>offsettable</em>. This means that adding a small integer (actually, the width in bytes of the operand, as determined by its machine mode) may be added to the address and the result is also a valid memory address. </p>  <p id="index-autoincrement_002fdecrement-addressing">For example, an address which is constant is offsettable; so is an address that is the sum of a register and a constant (as long as a slightly larger constant is also within the range of address-offsets supported by the machine); but an autoincrement or autodecrement address is not offsettable. More complicated indirect/indexed addresses may or may not be offsettable depending on the other addressing modes that the machine supports. </p> <p>Note that in an output operand which can be matched by another operand, the constraint letter ‘<samp>o</samp>’ is valid only when accompanied by both ‘<samp>&lt;</samp>’ (if the target machine has predecrement addressing) and ‘<samp>&gt;</samp>’ (if the target machine has preincrement addressing). </p>  </dd> <dt>‘<samp>V</samp>’</dt> <dd id="index-_003c-in-constraint">
<p>A memory operand that is not offsettable. In other words, anything that would fit the ‘<samp>m</samp>’ constraint but not the ‘<samp>o</samp>’ constraint. </p>  </dd> <dt>‘<samp>&lt;</samp>’</dt> <dd id="index-_003e-in-constraint">
<p>A memory operand with autodecrement addressing (either predecrement or postdecrement) is allowed. In inline <code>asm</code> this constraint is only allowed if the operand is used exactly once in an instruction that can handle the side effects. Not using an operand with ‘<samp>&lt;</samp>’ in constraint string in the inline <code>asm</code> pattern at all or using it in multiple instructions isn’t valid, because the side effects wouldn’t be performed or would be performed more than once. Furthermore, on some targets the operand with ‘<samp>&lt;</samp>’ in constraint string must be accompanied by special instruction suffixes like <code>%U0</code> instruction suffix on PowerPC or <code>%P0</code> on IA-64. </p>  </dd> <dt>‘<samp>&gt;</samp>’</dt> <dd id="index-registers-in-constraints">
<p>A memory operand with autoincrement addressing (either preincrement or postincrement) is allowed. In inline <code>asm</code> the same restrictions as for ‘<samp>&lt;</samp>’ apply. </p>   </dd> <dt>‘<samp>r</samp>’</dt> <dd id="index-i-in-constraint">
<p>A register operand is allowed provided that it is in a general register. </p>   </dd> <dt>‘<samp>i</samp>’</dt> <dd id="index-n-in-constraint">
<p>An immediate integer operand (one with constant value) is allowed. This includes symbolic constants whose values will be known only at assembly time or later. </p>  </dd> <dt>‘<samp>n</samp>’</dt> <dd id="index-I-in-constraint">
<p>An immediate integer operand with a known numeric value is allowed. Many systems cannot support assembly-time constants for operands less than a word wide. Constraints for these operands should use ‘<samp>n</samp>’ rather than ‘<samp>i</samp>’. </p>  </dd> <dt>‘<samp>I</samp>’, ‘<samp>J</samp>’, ‘<samp>K</samp>’, … ‘<samp>P</samp>’</dt> <dd id="index-E-in-constraint">
<p>Other letters in the range ‘<samp>I</samp>’ through ‘<samp>P</samp>’ may be defined in a machine-dependent fashion to permit immediate integer operands with explicit integer values in specified ranges. For example, on the 68000, ‘<samp>I</samp>’ is defined to stand for the range of values 1 to 8. This is the range permitted as a shift count in the shift instructions. </p>  </dd> <dt>‘<samp>E</samp>’</dt> <dd id="index-F-in-constraint">
<p>An immediate floating operand (expression code <code>const_double</code>) is allowed, but only if the target floating point format is the same as that of the host machine (on which the compiler is running). </p>  </dd> <dt>‘<samp>F</samp>’</dt> <dd id="index-H-in-constraint">
<p>An immediate floating operand (expression code <code>const_double</code> or <code>const_vector</code>) is allowed. </p>   </dd> <dt>‘<samp>G</samp>’, ‘<samp>H</samp>’</dt> <dd id="index-s-in-constraint">
<p>‘<samp>G</samp>’ and ‘<samp>H</samp>’ may be defined in a machine-dependent fashion to permit immediate floating operands in particular ranges of values. </p>  </dd> <dt>‘<samp>s</samp>’</dt> <dd id="index-g-in-constraint">
<p>An immediate integer operand whose value is not an explicit integer is allowed. </p> <p>This might appear strange; if an insn allows a constant operand with a value not known at compile time, it certainly must allow any known value. So why use ‘<samp>s</samp>’ instead of ‘<samp>i</samp>’? Sometimes it allows better code to be generated. </p> <p>For example, on the 68000 in a fullword instruction it is possible to use an immediate operand; but if the immediate value is between -128 and 127, better code results from loading the value into a register and using the register. This is because the load into the register can be done with a ‘<samp>moveq</samp>’ instruction. We arrange for this to happen by defining the letter ‘<samp>K</samp>’ to mean “any integer outside the range -128 to 127”, and then specifying ‘<samp>Ks</samp>’ in the operand constraints. </p>  </dd> <dt>‘<samp>g</samp>’</dt> <dd id="index-X-in-constraint">
<p>Any register, memory or immediate integer operand is allowed, except for registers that are not general registers. </p>  </dd> <dt>‘<samp>X</samp>’</dt> <dd id="index-digits-in-constraint">
<p>Any operand whatsoever is allowed. </p>   </dd> <dt>‘<samp>0</samp>’, ‘<samp>1</samp>’, ‘<samp>2</samp>’, … ‘<samp>9</samp>’</dt> <dd id="index-p-in-constraint">
<p>An operand that matches the specified operand number is allowed. If a digit is used together with letters within the same alternative, the digit should come last. </p> <p>This number is allowed to be more than a single digit. If multiple digits are encountered consecutively, they are interpreted as a single decimal integer. There is scant chance for ambiguity, since to-date it has never been desirable that ‘<samp>10</samp>’ be interpreted as matching either operand 1 <em>or</em> operand 0. Should this be desired, one can use multiple alternatives instead. </p>   <p id="index-constraint_002c-matching">This is called a <em>matching constraint</em> and what it really means is that the assembler has only a single operand that fills two roles which <code>asm</code> distinguishes. For example, an add instruction uses two input operands and an output operand, but on most CISC machines an add instruction really has only two operands, one of them an input-output operand: </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">addl #35,r12</pre>
</div> <p>Matching constraints are used in these circumstances. More precisely, the two operands that match must include one input-only operand and one output-only operand. Moreover, the digit must be a smaller number than the number of the operand that uses it in the constraint. </p>     </dd> <dt>‘<samp>p</samp>’</dt> <dd id="index-extensible-constraints">
<p>An operand that is a valid memory address is allowed. This is for “load address” and “push address” instructions. </p>  <p id="index-address_005foperand">‘<samp>p</samp>’ in the constraint must be accompanied by <code>address_operand</code> as the predicate in the <code>match_operand</code>. This predicate interprets the mode specified in the <code>match_operand</code> as the mode of the memory reference for which the address would be valid. </p>   </dd> <dt><var>other-letters</var></dt> <dd><p>Other letters can be defined in machine-dependent fashion to stand for particular classes of registers or other arbitrary operand types. ‘<samp>d</samp>’, ‘<samp>a</samp>’ and ‘<samp>f</samp>’ are defined on the 68000/68020 to stand for data, address and floating point registers. </p></dd> </dl>  <p class="header"> </p>
<p> Next: <a href="multi_002dalternative#Multi_002dAlternative" accesskey="n" rel="next">Multi-Alternative</a>, Up: <a href="constraints#Constraints" accesskey="u" rel="up">Constraints</a> [<a href="index#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index" title="Index" rel="index">Index</a>]</p> <div class="_attribution">
  <p class="_attribution-p">
    © Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Simple-Constraints.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Simple-Constraints.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
