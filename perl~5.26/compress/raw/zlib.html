
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Compress&#58;&#58;Raw&#58;&#58;Zlib - Perl 5.26 - W3cubDocs</title>
  
  <meta name="description" content=" Compress&#58;&#58;Raw&#58;&#58;Zlib - Low-Level Interface to zlib compression library ">
  <meta name="keywords" content="compress, raw, zlib, perl, perl~5.26">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/perl~5.26/compress/raw/zlib.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/perl~5.26.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/perl~5.26/" class="_nav-link" title="" style="margin-left:0;">Perl 5.26</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _perl">
				
				
<h1>Compress::Raw::Zlib</h1>  <ul>
<li><a href="#NAME">NAME</a></li>
<li><a href="#SYNOPSIS">SYNOPSIS</a></li>
<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
<li>
<a href="#Compress%3a%3aRaw%3a%3aZlib%3a%3aDeflate">Compress::Raw::Zlib::Deflate</a><ul>
<li><a href="#*(%24d%2c-%24status)-%3d-new-Compress%3a%3aRaw%3a%3aZlib%3a%3aDeflate(-%5bOPT%5d-)-*">*($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) *</a></li>
<li><a href="#*%24status-%3d-%24d-%3edeflate(%24input%2c-%24output)*">*$status = $d-&gt;deflate($input, $output)*</a></li>
<li><a href="#*%24status-%3d-%24d-%3eflush(%24output-%5b%2c-%24flush_type%5d)-*">*$status = $d-&gt;flush($output [, $flush_type]) *</a></li>
<li><a href="#*%24status-%3d-%24d-%3edeflateReset()-*">*$status = $d-&gt;deflateReset() *</a></li>
<li><a href="#*%24status-%3d-%24d-%3edeflateParams(%5bOPT%5d)*">*$status = $d-&gt;deflateParams([OPT])*</a></li>
<li><a href="#*%24status-%3d-%24d-%3edeflateTune(%24good_length%2c-%24max_lazy%2c-%24nice_length%2c-%24max_chain)*">*$status = $d-&gt;deflateTune($good_length, $max_lazy, $nice_length, $max_chain)*</a></li>
<li><a href="#*%24d-%3edict_adler()*">*$d-&gt;dict_adler()*</a></li>
<li><a href="#*%24d-%3ecrc32()*">*$d-&gt;crc32()*</a></li>
<li><a href="#*%24d-%3eadler32()*">*$d-&gt;adler32()*</a></li>
<li><a href="#*%24d-%3emsg()*">*$d-&gt;msg()*</a></li>
<li><a href="#*%24d-%3etotal_in()*">*$d-&gt;total_in()*</a></li>
<li><a href="#*%24d-%3etotal_out()*">*$d-&gt;total_out()*</a></li>
<li><a href="#*%24d-%3eget_Strategy()*">*$d-&gt;get_Strategy()*</a></li>
<li><a href="#*%24d-%3eget_Level()*">*$d-&gt;get_Level()*</a></li>
<li><a href="#*%24d-%3eget_BufSize()*">*$d-&gt;get_BufSize()*</a></li>
<li><a href="#Example">Example</a></li>
</ul>
</li>
<li>
<a href="#Compress%3a%3aRaw%3a%3aZlib%3a%3aInflate">Compress::Raw::Zlib::Inflate</a><ul>
<li><a href="#*-(%24i%2c-%24status)-%3d-new-Compress%3a%3aRaw%3a%3aZlib%3a%3aInflate(-%5bOPT%5d-)-*">* ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) *</a></li>
<li><a href="#*-%24status-%3d-%24i-%3einflate(%24input%2c-%24output-%5b%2c%24eof%5d)-*">* $status = $i-&gt;inflate($input, $output [,$eof]) *</a></li>
<li><a href="#*%24status-%3d-%24i-%3einflateSync(%24input)*">*$status = $i-&gt;inflateSync($input)*</a></li>
<li><a href="#*%24status-%3d-%24i-%3einflateReset()-*">*$status = $i-&gt;inflateReset() *</a></li>
<li><a href="#*%24i-%3edict_adler()*">*$i-&gt;dict_adler()*</a></li>
<li><a href="#*%24i-%3ecrc32()*">*$i-&gt;crc32()*</a></li>
<li><a href="#*%24i-%3eadler32()*">*$i-&gt;adler32()*</a></li>
<li><a href="#*%24i-%3emsg()*">*$i-&gt;msg()*</a></li>
<li><a href="#*%24i-%3etotal_in()*">*$i-&gt;total_in()*</a></li>
<li><a href="#*%24i-%3etotal_out()*">*$i-&gt;total_out()*</a></li>
<li><a href="#*%24d-%3eget_BufSize()*">*$d-&gt;get_BufSize()*</a></li>
<li><a href="#Examples">Examples</a></li>
</ul>
</li>
<li><a href="#CHECKSUM-FUNCTIONS">CHECKSUM FUNCTIONS</a></li>
<li>
<a href="#Misc">Misc</a><ul>
<li><a href="#my-%24version-%3d-Compress%3a%3aRaw%3a%3aZlib%3a%3azlib_version()%3b">my $version = Compress::Raw::Zlib::zlib_version();</a></li>
<li><a href="#my-%24flags-%3d-Compress%3a%3aRaw%3a%3aZlib%3a%3azlibCompileFlags()%3b">my $flags = Compress::Raw::Zlib::zlibCompileFlags();</a></li>
</ul>
</li>
<li><a href="#The-LimitOutput-option.">The LimitOutput option.</a></li>
<li><a href="#ACCESSING-ZIP-FILES">ACCESSING ZIP FILES</a></li>
<li>
<a href="#FAQ">FAQ</a><ul>
<li><a href="#Compatibility-with-Unix-compress%2funcompress.">Compatibility with Unix compress/uncompress.</a></li>
<li><a href="#Accessing-.tar.Z-files">Accessing .tar.Z files</a></li>
<li><a href="#Zlib-Library-Version-Support">Zlib Library Version Support</a></li>
</ul>
</li>
<li><a href="#CONSTANTS">CONSTANTS</a></li>
<li><a href="#SEE-ALSO">SEE ALSO</a></li>
<li><a href="#AUTHOR">AUTHOR</a></li>
<li><a href="#MODIFICATION-HISTORY">MODIFICATION HISTORY</a></li>
<li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>
<h2 id="NAME">NAME</h2> <p>Compress::Raw::Zlib - Low-Level Interface to zlib compression library</p> <h2 id="SYNOPSIS">SYNOPSIS</h2> <pre class="verbatim" data-language="perl">use Compress::Raw::Zlib ;

($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) ;
$status = $d-&gt;deflate($input, $output) ;
$status = $d-&gt;flush($output [, $flush_type]) ;
$d-&gt;deflateReset() ;
$d-&gt;deflateParams(OPTS) ;
$d-&gt;deflateTune(OPTS) ;
$d-&gt;dict_adler() ;
$d-&gt;crc32() ;
$d-&gt;adler32() ;
$d-&gt;total_in() ;
$d-&gt;total_out() ;
$d-&gt;msg() ;
$d-&gt;get_Strategy();
$d-&gt;get_Level();
$d-&gt;get_BufSize();

($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) ;
$status = $i-&gt;inflate($input, $output [, $eof]) ;
$status = $i-&gt;inflateSync($input) ;
$i-&gt;inflateReset() ;
$i-&gt;dict_adler() ;
$d-&gt;crc32() ;
$d-&gt;adler32() ;
$i-&gt;total_in() ;
$i-&gt;total_out() ;
$i-&gt;msg() ;
$d-&gt;get_BufSize();

$crc = adler32($buffer [,$crc]) ;
$crc = crc32($buffer [,$crc]) ;

$crc = crc32_combine($crc1, $crc2, $len2);
$adler = adler32_combine($adler1, $adler2, $len2);

my $version = Compress::Raw::Zlib::zlib_version();
my $flags = Compress::Raw::Zlib::zlibCompileFlags();
</pre>
<h2 id="DESCRIPTION">DESCRIPTION</h2> <p>The <i>Compress::Raw::Zlib</i> module provides a Perl interface to the <i>zlib</i> compression library (see <a href="#AUTHOR">AUTHOR</a> for details about where to get <i>zlib</i>).</p> <h2 id="Compress%3a%3aRaw%3a%3aZlib%3a%3aDeflate">Compress::Raw::Zlib::Deflate</h2> <p>This section defines an interface that allows in-memory compression using the <i>deflate</i> interface provided by zlib.</p> <p>Here is a definition of the interface available:</p> <h3 id="*(%24d%2c-%24status)-%3d-new-Compress%3a%3aRaw%3a%3aZlib%3a%3aDeflate(-%5bOPT%5d-)-*"><b>($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) </b></h3> <p>Initialises a deflation object.</p> <p>If you are familiar with the <i>zlib</i> library, it combines the features of the <i>zlib</i> functions <code class="inline"><span class="w">deflateInit</span></code> , <code class="inline"><span class="w">deflateInit2</span></code> and <code class="inline"><span class="w">deflateSetDictionary</span></code> .</p> <p>If successful, it will return the initialised deflation object, <code class="inline"><span class="i">$d</span></code> and a <code class="inline"><span class="i">$status</span></code> of <code class="inline"><span class="w">Z_OK</span></code> in a list context. In scalar context it returns the deflation object, <code class="inline"><span class="i">$d</span></code> , only.</p> <p>If not successful, the returned deflation object, <code class="inline"><span class="i">$d</span></code> , will be <i>undef</i> and <code class="inline"><span class="i">$status</span></code> will hold the a <i>zlib</i> error code.</p> <p>The function optionally takes a number of named options specified as <code class="inline"><span class="w">Name</span> <span class="cm">=&gt;</span> <span class="w">value</span></code> pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</p> <p>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the name=&gt;value pairs.</p> <p>Below is a list of the valid options:</p> <ul> <li id="*-Level*">
<b><b>-Level</b></b> <p>Defines the compression level. Valid values are 0 through 9, <code class="inline"><span class="w">Z_NO_COMPRESSION</span></code> , <code class="inline"><span class="w">Z_BEST_SPEED</span></code> , <code class="inline"><span class="w">Z_BEST_COMPRESSION</span></code> , and <code class="inline"><span class="w">Z_DEFAULT_COMPRESSION</span></code> .</p> <p>The default is <code class="inline"><span class="w">Z_DEFAULT_COMPRESSION</span></code> .</p> </li> <li id="*-Method*">
<b><b>-Method</b></b> <p>Defines the compression method. The only valid value at present (and the default) is <code class="inline"><span class="w">Z_DEFLATED</span></code> .</p> </li> <li id="*-WindowBits*">
<b><b>-WindowBits</b></b> <p>To compress an RFC 1950 data stream, set <code class="inline"><span class="w">WindowBits</span></code> to a positive number between 8 and 15.</p> <p>To compress an RFC 1951 data stream, set <code class="inline"><span class="w">WindowBits</span></code> to <code class="inline">-<span class="w">MAX_WBITS</span></code> .</p> <p>To compress an RFC 1952 data stream (i.e. gzip), set <code class="inline"><span class="w">WindowBits</span></code> to <code class="inline"><span class="w">WANT_GZIP</span></code> .</p> <p>For a definition of the meaning and valid values for <code class="inline"><span class="w">WindowBits</span></code> refer to the <i>zlib</i> documentation for <i>deflateInit2</i>.</p> <p>Defaults to <code class="inline"><span class="w">MAX_WBITS</span></code> .</p> </li> <li id="*-MemLevel*">
<b><b>-MemLevel</b></b> <p>For a definition of the meaning and valid values for <code class="inline"><span class="w">MemLevel</span></code> refer to the <i>zlib</i> documentation for <i>deflateInit2</i>.</p> <p>Defaults to MAX_MEM_LEVEL.</p> </li> <li id="*-Strategy*">
<b><b>-Strategy</b></b> <p>Defines the strategy used to tune the compression. The valid values are <code class="inline"><span class="w">Z_DEFAULT_STRATEGY</span></code> , <code class="inline"><span class="w">Z_FILTERED</span></code> , <code class="inline"><span class="w">Z_RLE</span></code> , <code class="inline"><span class="w">Z_FIXED</span></code> and <code class="inline"><span class="w">Z_HUFFMAN_ONLY</span></code> .</p> <p>The default is <code class="inline"><span class="w">Z_DEFAULT_STRATEGY</span></code> .</p> </li> <li id="*-Dictionary*">
<b><b>-Dictionary</b></b> <p>When a dictionary is specified <i>Compress::Raw::Zlib</i> will automatically call <code class="inline"><span class="w">deflateSetDictionary</span></code> directly after calling <code class="inline"><span class="w">deflateInit</span></code> . The Adler32 value for the dictionary can be obtained by calling the method <code class="inline"><span class="i">$d</span><span class="i">-&gt;dict_adler</span><span class="s">(</span><span class="s">)</span></code> .</p> <p>The default is no dictionary.</p> </li> <li id="*-Bufsize*">
<b><b>-Bufsize</b></b> <p>Sets the initial size for the output buffer used by the <code class="inline"><span class="i">$d</span><span class="i">-&gt;deflate</span></code> and <code class="inline"><span class="i">$d</span><span class="i">-&gt;flush</span></code> methods. If the buffer has to be reallocated to increase the size, it will grow in increments of <code class="inline"><span class="w">Bufsize</span></code> .</p> <p>The default buffer size is 4096.</p> </li> <li id="*-AppendOutput*">
<b><b>-AppendOutput</b></b> <p>This option controls how data is written to the output buffer by the <code class="inline"><span class="i">$d</span><span class="i">-&gt;deflate</span></code> and <code class="inline"><span class="i">$d</span><span class="i">-&gt;flush</span></code> methods.</p> <p>If the <code class="inline"><span class="w">AppendOutput</span></code> option is set to false, the output buffers in the <code class="inline"><span class="i">$d</span><span class="i">-&gt;deflate</span></code> and <code class="inline"><span class="i">$d</span><span class="i">-&gt;flush</span></code> methods will be truncated before uncompressed data is written to them.</p> <p>If the option is set to true, uncompressed data will be appended to the output buffer in the <code class="inline"><span class="i">$d</span><span class="i">-&gt;deflate</span></code> and <code class="inline"><span class="i">$d</span><span class="i">-&gt;flush</span></code> methods.</p> <p>This option defaults to false.</p> </li> <li id="*-CRC32*">
<b><b>-CRC32</b></b> <p>If set to true, a crc32 checksum of the uncompressed data will be calculated. Use the <code class="inline"><span class="i">$d</span><span class="i">-&gt;crc32</span></code> method to retrieve this value.</p> <p>This option defaults to false.</p> </li> <li id="*-ADLER32*">
<b><b>-ADLER32</b></b> <p>If set to true, an adler32 checksum of the uncompressed data will be calculated. Use the <code class="inline"><span class="i">$d</span><span class="i">-&gt;adler32</span></code> method to retrieve this value.</p> <p>This option defaults to false.</p> </li> </ul> <p>Here is an example of using the <code class="inline"><span class="w">Compress::Raw::Zlib::Deflate</span></code> optional parameter list to override the default buffer size and compression level. All other options will take their default values.</p> <pre class="verbatim" data-language="perl">my $d = new Compress::Raw::Zlib::Deflate ( -Bufsize =&gt; 300, 
                                           -Level   =&gt; Z_BEST_SPEED ) ;
</pre>
<h3 id="*%24status-%3d-%24d-%3edeflate(%24input%2c-%24output)*"><b>$status = $d-&gt;deflate($input, $output)</b></h3> <p>Deflates the contents of <code class="inline"><span class="i">$input</span></code> and writes the compressed data to <code class="inline"><span class="i">$output</span></code> .</p> <p>The <code class="inline"><span class="i">$input</span></code> and <code class="inline"><span class="i">$output</span></code> parameters can be either scalars or scalar references.</p> <p>When finished, <code class="inline"><span class="i">$input</span></code> will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to <code class="inline"><span class="i">$output</span></code> and returns a status value of <code class="inline"><span class="w">Z_OK</span></code> .</p> <p>On error, it returns a <i>zlib</i> error code.</p> <p>If the <code class="inline"><span class="w">AppendOutput</span></code> option is set to true in the constructor for the <code class="inline"><span class="i">$d</span></code> object, the compressed data will be appended to <code class="inline"><span class="i">$output</span></code> . If it is false, <code class="inline"><span class="i">$output</span></code> will be truncated before any compressed data is written to it.</p> <p><b>Note</b>: This method will not necessarily write compressed data to <code class="inline"><span class="i">$output</span></code> every time it is called. So do not assume that there has been an error if the contents of <code class="inline"><span class="i">$output</span></code> is empty on returning from this method. As long as the return code from the method is <code class="inline"><span class="w">Z_OK</span></code> , the deflate has succeeded.</p> <h3 id="*%24status-%3d-%24d-%3eflush(%24output-%5b%2c-%24flush_type%5d)-*"><b>$status = $d-&gt;flush($output [, $flush_type]) </b></h3> <p>Typically used to finish the deflation. Any pending output will be written to <code class="inline"><span class="i">$output</span></code> .</p> <p>Returns <code class="inline"><span class="w">Z_OK</span></code> if successful.</p> <p>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using <code class="inline"><span class="w">Z_FINISH</span></code> ) or when you want to create a <i>full flush point</i> (using <code class="inline"><span class="w">Z_FULL_FLUSH</span></code> ).</p> <p>By default the <code class="inline"><span class="w">flush_type</span></code> used is <code class="inline"><span class="w">Z_FINISH</span></code> . Other valid values for <code class="inline"><span class="w">flush_type</span></code> are <code class="inline"><span class="w">Z_NO_FLUSH</span></code> , <code class="inline"><span class="w">Z_PARTIAL_FLUSH</span></code> , <code class="inline"><span class="w">Z_SYNC_FLUSH</span></code> and <code class="inline"><span class="w">Z_FULL_FLUSH</span></code> . It is strongly recommended that you only set the <code class="inline"><span class="w">flush_type</span></code> parameter if you fully understand the implications of what it does. See the <code class="inline"><span class="w">zlib</span></code> documentation for details.</p> <p>If the <code class="inline"><span class="w">AppendOutput</span></code> option is set to true in the constructor for the <code class="inline"><span class="i">$d</span></code> object, the compressed data will be appended to <code class="inline"><span class="i">$output</span></code> . If it is false, <code class="inline"><span class="i">$output</span></code> will be truncated before any compressed data is written to it.</p> <h3 id="*%24status-%3d-%24d-%3edeflateReset()-*"><b>$status = $d-&gt;deflateReset() </b></h3> <p>This method will reset the deflation object <code class="inline"><span class="i">$d</span></code> . It can be used when you are compressing multiple data streams and want to use the same object to compress each of them. It should only be used once the previous data stream has been flushed successfully, i.e. a call to <code class="inline"><span class="i">$d</span><span class="i">-&gt;flush</span><span class="s">(</span><span class="w">Z_FINISH</span><span class="s">)</span></code> has returned <code class="inline"><span class="w">Z_OK</span></code> .</p> <p>Returns <code class="inline"><span class="w">Z_OK</span></code> if successful.</p> <h3 id="*%24status-%3d-%24d-%3edeflateParams(%5bOPT%5d)*"><b>$status = $d-&gt;deflateParams([OPT])</b></h3> <p>Change settings for the deflate object <code class="inline"><span class="i">$d</span></code> .</p> <p>The list of the valid options is shown below. Options not specified will remain unchanged.</p> <ul> <li id="*-Level*">
<b><b>-Level</b></b> <p>Defines the compression level. Valid values are 0 through 9, <code class="inline"><span class="w">Z_NO_COMPRESSION</span></code> , <code class="inline"><span class="w">Z_BEST_SPEED</span></code> , <code class="inline"><span class="w">Z_BEST_COMPRESSION</span></code> , and <code class="inline"><span class="w">Z_DEFAULT_COMPRESSION</span></code> .</p> </li> <li id="*-Strategy*">
<b><b>-Strategy</b></b> <p>Defines the strategy used to tune the compression. The valid values are <code class="inline"><span class="w">Z_DEFAULT_STRATEGY</span></code> , <code class="inline"><span class="w">Z_FILTERED</span></code> and <code class="inline"><span class="w">Z_HUFFMAN_ONLY</span></code> .</p> </li> <li id="*-BufSize*">
<b><b>-BufSize</b></b> <p>Sets the initial size for the output buffer used by the <code class="inline"><span class="i">$d</span><span class="i">-&gt;deflate</span></code> and <code class="inline"><span class="i">$d</span><span class="i">-&gt;flush</span></code> methods. If the buffer has to be reallocated to increase the size, it will grow in increments of <code class="inline"><span class="w">Bufsize</span></code> .</p> </li> </ul> <h3 id="*%24status-%3d-%24d-%3edeflateTune(%24good_length%2c-%24max_lazy%2c-%24nice_length%2c-%24max_chain)*"><b>$status = $d-&gt;deflateTune($good_length, $max_lazy, $nice_length, $max_chain)</b></h3> <p>Tune the internal settings for the deflate object <code class="inline"><span class="i">$d</span></code> . This option is only available if you are running zlib 1.2.2.3 or better.</p> <p>Refer to the documentation in zlib.h for instructions on how to fly <code class="inline"><span class="w">deflateTune</span></code> .</p> <h3 id="*%24d-%3edict_adler()*"><b>$d-&gt;dict_adler()</b></h3> <p>Returns the adler32 value for the dictionary.</p> <h3 id="*%24d-%3ecrc32()*"><b>$d-&gt;crc32()</b></h3> <p>Returns the crc32 value for the uncompressed data to date.</p> <p>If the <code class="inline"><span class="w">CRC32</span></code> option is not enabled in the constructor for this object, this method will always return 0;</p> <h3 id="*%24d-%3eadler32()*"><b>$d-&gt;adler32()</b></h3> <p>Returns the adler32 value for the uncompressed data to date.</p> <h3 id="*%24d-%3emsg()*"><b>$d-&gt;msg()</b></h3> <p>Returns the last error message generated by zlib.</p> <h3 id="*%24d-%3etotal_in()*"><b>$d-&gt;total_in()</b></h3> <p>Returns the total number of bytes uncompressed bytes input to deflate.</p> <h3 id="*%24d-%3etotal_out()*"><b>$d-&gt;total_out()</b></h3> <p>Returns the total number of compressed bytes output from deflate.</p> <h3 id="*%24d-%3eget_Strategy()*"><b>$d-&gt;get_Strategy()</b></h3> <p>Returns the deflation strategy currently used. Valid values are <code class="inline"><span class="w">Z_DEFAULT_STRATEGY</span></code> , <code class="inline"><span class="w">Z_FILTERED</span></code> and <code class="inline"><span class="w">Z_HUFFMAN_ONLY</span></code> .</p> <h3 id="*%24d-%3eget_Level()*"><b>$d-&gt;get_Level()</b></h3> <p>Returns the compression level being used.</p> <h3 id="*%24d-%3eget_BufSize()*"><b>$d-&gt;get_BufSize()</b></h3> <p>Returns the buffer size used to carry out the compression.</p> <h3 id="Example">Example</h3> <p>Here is a trivial example of using <code class="inline"><span class="w">deflate</span></code> . It simply reads standard input, deflates it and writes it to standard output.</p> <pre class="verbatim" data-language="perl">use strict ;
use warnings ;

use Compress::Raw::Zlib ;

binmode STDIN;
binmode STDOUT;
my $x = new Compress::Raw::Zlib::Deflate
   or die "Cannot create a deflation stream\n" ;

my ($output, $status) ;
while (&lt;&gt;)
{
    $status = $x-&gt;deflate($_, $output) ;

    $status == Z_OK
        or die "deflation failed\n" ;

    print $output ;
}

$status = $x-&gt;flush($output) ;

$status == Z_OK
    or die "deflation failed\n" ;

print $output ;
</pre>
<h2 id="Compress%3a%3aRaw%3a%3aZlib%3a%3aInflate">Compress::Raw::Zlib::Inflate</h2> <p>This section defines an interface that allows in-memory uncompression using the <i>inflate</i> interface provided by zlib.</p> <p>Here is a definition of the interface:</p> <h3 id="*-(%24i%2c-%24status)-%3d-new-Compress%3a%3aRaw%3a%3aZlib%3a%3aInflate(-%5bOPT%5d-)-*"><b> ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) </b></h3> <p>Initialises an inflation object.</p> <p>In a list context it returns the inflation object, <code class="inline"><span class="i">$i</span></code> , and the <i>zlib</i> status code (<code class="inline"><span class="i">$status</span></code> ). In a scalar context it returns the inflation object only.</p> <p>If successful, <code class="inline"><span class="i">$i</span></code> will hold the inflation object and <code class="inline"><span class="i">$status</span></code> will be <code class="inline"><span class="w">Z_OK</span></code> .</p> <p>If not successful, <code class="inline"><span class="i">$i</span></code> will be <i>undef</i> and <code class="inline"><span class="i">$status</span></code> will hold the <i>zlib</i> error code.</p> <p>The function optionally takes a number of named options specified as <code class="inline">-<span class="w">Name</span> <span class="cm">=&gt;</span> <span class="w">value</span></code> pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</p> <p>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the <code class="inline"><span class="w">name</span><span class="cm">=&gt;</span><span class="w">value</span></code> pairs.</p> <p>Here is a list of the valid options:</p> <ul> <li id="*-WindowBits*">
<b><b>-WindowBits</b></b> <p>To uncompress an RFC 1950 data stream, set <code class="inline"><span class="w">WindowBits</span></code> to a positive number between 8 and 15.</p> <p>To uncompress an RFC 1951 data stream, set <code class="inline"><span class="w">WindowBits</span></code> to <code class="inline">-<span class="w">MAX_WBITS</span></code> .</p> <p>To uncompress an RFC 1952 data stream (i.e. gzip), set <code class="inline"><span class="w">WindowBits</span></code> to <code class="inline"><span class="w">WANT_GZIP</span></code> .</p> <p>To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e. gzip), set <code class="inline"><span class="w">WindowBits</span></code> to <code class="inline"><span class="w">WANT_GZIP_OR_ZLIB</span></code> .</p> <p>For a full definition of the meaning and valid values for <code class="inline"><span class="w">WindowBits</span></code> refer to the <i>zlib</i> documentation for <i>inflateInit2</i>.</p> <p>Defaults to <code class="inline"><span class="w">MAX_WBITS</span></code> .</p> </li> <li id="*-Bufsize*">
<b><b>-Bufsize</b></b> <p>Sets the initial size for the output buffer used by the <code class="inline"><span class="i">$i</span><span class="i">-&gt;inflate</span></code> method. If the output buffer in this method has to be reallocated to increase the size, it will grow in increments of <code class="inline"><span class="w">Bufsize</span></code> .</p> <p>Default is 4096.</p> </li> <li id="*-Dictionary*">
<b><b>-Dictionary</b></b> <p>The default is no dictionary.</p> </li> <li id="*-AppendOutput*">
<b><b>-AppendOutput</b></b> <p>This option controls how data is written to the output buffer by the <code class="inline"><span class="i">$i</span><span class="i">-&gt;inflate</span></code> method.</p> <p>If the option is set to false, the output buffer in the <code class="inline"><span class="i">$i</span><span class="i">-&gt;inflate</span></code> method will be truncated before uncompressed data is written to it.</p> <p>If the option is set to true, uncompressed data will be appended to the output buffer by the <code class="inline"><span class="i">$i</span><span class="i">-&gt;inflate</span></code> method.</p> <p>This option defaults to false.</p> </li> <li id="*-CRC32*">
<b><b>-CRC32</b></b> <p>If set to true, a crc32 checksum of the uncompressed data will be calculated. Use the <code class="inline"><span class="i">$i</span><span class="i">-&gt;crc32</span></code> method to retrieve this value.</p> <p>This option defaults to false.</p> </li> <li id="*-ADLER32*">
<b><b>-ADLER32</b></b> <p>If set to true, an adler32 checksum of the uncompressed data will be calculated. Use the <code class="inline"><span class="i">$i</span><span class="i">-&gt;adler32</span></code> method to retrieve this value.</p> <p>This option defaults to false.</p> </li> <li id="*-ConsumeInput*">
<b><b>-ConsumeInput</b></b> <p>If set to true, this option will remove compressed data from the input buffer of the <code class="inline"><span class="i">$i</span><span class="i">-&gt;inflate</span></code> method as the inflate progresses.</p> <p>This option can be useful when you are processing compressed data that is embedded in another file/buffer. In this case the data that immediately follows the compressed stream will be left in the input buffer.</p> <p>This option defaults to true.</p> </li> <li id="*-LimitOutput*">
<b><b>-LimitOutput</b></b> <p>The <code class="inline"><span class="w">LimitOutput</span></code> option changes the behavior of the <code class="inline"><span class="i">$i</span><span class="i">-&gt;inflate</span></code> method so that the amount of memory used by the output buffer can be limited.</p> <p>When <code class="inline"><span class="w">LimitOutput</span></code> is used the size of the output buffer used will either be the value of the <code class="inline"><span class="w">Bufsize</span></code> option or the amount of memory already allocated to <code class="inline"><span class="i">$output</span></code> , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</p> <p>When <code class="inline"><span class="w">LimitOutout</span></code> is not specified <code class="inline"><span class="i">$i</span><span class="i">-&gt;inflate</span></code> will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</p> <p>If <code class="inline"><span class="w">LimitOutput</span></code> is enabled, the <code class="inline"><span class="w">ConsumeInput</span></code> option will also be enabled.</p> <p>This option defaults to false.</p> <p>See <a href="#The-LimitOutput-option">The LimitOutput option</a> for a discussion on why <code class="inline"><span class="w">LimitOutput</span></code> is needed and how to use it.</p> </li> </ul> <p>Here is an example of using an optional parameter to override the default buffer size.</p> <pre class="verbatim" data-language="perl">my ($i, $status) = new Compress::Raw::Zlib::Inflate( -Bufsize =&gt; 300 ) ;
</pre>
<h3 id="*-%24status-%3d-%24i-%3einflate(%24input%2c-%24output-%5b%2c%24eof%5d)-*"><b> $status = $i-&gt;inflate($input, $output [,$eof]) </b></h3> <p>Inflates the complete contents of <code class="inline"><span class="i">$input</span></code> and writes the uncompressed data to <code class="inline"><span class="i">$output</span></code> . The <code class="inline"><span class="i">$input</span></code> and <code class="inline"><span class="i">$output</span></code> parameters can either be scalars or scalar references.</p> <p>Returns <code class="inline"><span class="w">Z_OK</span></code> if successful and <code class="inline"><span class="w">Z_STREAM_END</span></code> if the end of the compressed data has been successfully reached.</p> <p>If not successful <code class="inline"><span class="i">$status</span></code> will hold the <i>zlib</i> error code.</p> <p>If the <code class="inline"><span class="w">ConsumeInput</span></code> option has been set to true when the <code class="inline"><span class="w">Compress::Raw::Zlib::Inflate</span></code> object is created, the <code class="inline"><span class="i">$input</span></code> parameter is modified by <code class="inline"><span class="w">inflate</span></code> . On completion it will contain what remains of the input buffer after inflation. In practice, this means that when the return status is <code class="inline"><span class="w">Z_OK</span></code> the <code class="inline"><span class="i">$input</span></code> parameter will contain an empty string, and when the return status is <code class="inline"><span class="w">Z_STREAM_END</span></code> the <code class="inline"><span class="i">$input</span></code> parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</p> <p>This feature is useful when processing a file format that encapsulates a compressed data stream (e.g. gzip, zip) and there is useful data immediately after the deflation stream.</p> <p>If the <code class="inline"><span class="w">AppendOutput</span></code> option is set to true in the constructor for this object, the uncompressed data will be appended to <code class="inline"><span class="i">$output</span></code> . If it is false, <code class="inline"><span class="i">$output</span></code> will be truncated before any uncompressed data is written to it.</p> <p>The <code class="inline"><span class="i">$eof</span></code> parameter needs a bit of explanation.</p> <p>Prior to version 1.2.0, zlib assumed that there was at least one trailing byte immediately after the compressed data stream when it was carrying out decompression. This normally isn't a problem because the majority of zlib applications guarantee that there will be data directly after the compressed data stream. For example, both gzip (RFC 1950) and zip both define trailing data that follows the compressed data stream.</p> <p>The <code class="inline"><span class="i">$eof</span></code> parameter only needs to be used if <b>all</b> of the following conditions apply</p> <dl> <dt>1</dt>
<dd> <p>You are either using a copy of zlib that is older than version 1.2.0 or you want your application code to be able to run with as many different versions of zlib as possible.</p> </dd> <dt>2</dt>
<dd> <p>You have set the <code class="inline"><span class="w">WindowBits</span></code> parameter to <code class="inline">-<span class="w">MAX_WBITS</span></code> in the constructor for this object, i.e. you are uncompressing a raw deflated data stream (RFC 1951).</p> </dd> <dt>3</dt>
<dd> <p>There is no data immediately after the compressed data stream.</p> </dd> </dl> <p>If <b>all</b> of these are the case, then you need to set the <code class="inline"><span class="i">$eof</span></code> parameter to true on the final call (and only the final call) to <code class="inline"><span class="i">$i</span><span class="i">-&gt;inflate</span></code> .</p> <p>If you have built this module with zlib &gt;= 1.2.0, the <code class="inline"><span class="i">$eof</span></code> parameter is ignored. You can still set it if you want, but it won't be used behind the scenes.</p> <h3 id="*%24status-%3d-%24i-%3einflateSync(%24input)*"><b>$status = $i-&gt;inflateSync($input)</b></h3> <p>This method can be used to attempt to recover good data from a compressed data stream that is partially corrupt. It scans <code class="inline"><span class="i">$input</span></code> until it reaches either a <i>full flush point</i> or the end of the buffer.</p> <p>If a <i>full flush point</i> is found, <code class="inline"><span class="w">Z_OK</span></code> is returned and <code class="inline"><span class="i">$input</span></code> will be have all data up to the flush point removed. This data can then be passed to the <code class="inline"><span class="i">$i</span><span class="i">-&gt;inflate</span></code> method to be uncompressed.</p> <p>Any other return code means that a flush point was not found. If more data is available, <code class="inline"><span class="w">inflateSync</span></code> can be called repeatedly with more compressed data until the flush point is found.</p> <p>Note <i>full flush points</i> are not present by default in compressed data streams. They must have been added explicitly when the data stream was created by calling <code class="inline"><span class="w">Compress::Deflate::flush</span></code> with <code class="inline"><span class="w">Z_FULL_FLUSH</span></code> .</p> <h3 id="*%24status-%3d-%24i-%3einflateReset()-*"><b>$status = $i-&gt;inflateReset() </b></h3> <p>This method will reset the inflation object <code class="inline"><span class="i">$i</span></code> . It can be used when you are uncompressing multiple data streams and want to use the same object to uncompress each of them.</p> <p>Returns <code class="inline"><span class="w">Z_OK</span></code> if successful.</p> <h3 id="*%24i-%3edict_adler()*"><b>$i-&gt;dict_adler()</b></h3> <p>Returns the adler32 value for the dictionary.</p> <h3 id="*%24i-%3ecrc32()*"><b>$i-&gt;crc32()</b></h3> <p>Returns the crc32 value for the uncompressed data to date.</p> <p>If the <code class="inline"><span class="w">CRC32</span></code> option is not enabled in the constructor for this object, this method will always return 0;</p> <h3 id="*%24i-%3eadler32()*"><b>$i-&gt;adler32()</b></h3> <p>Returns the adler32 value for the uncompressed data to date.</p> <p>If the <code class="inline"><span class="w">ADLER32</span></code> option is not enabled in the constructor for this object, this method will always return 0;</p> <h3 id="*%24i-%3emsg()*"><b>$i-&gt;msg()</b></h3> <p>Returns the last error message generated by zlib.</p> <h3 id="*%24i-%3etotal_in()*"><b>$i-&gt;total_in()</b></h3> <p>Returns the total number of bytes compressed bytes input to inflate.</p> <h3 id="*%24i-%3etotal_out()*"><b>$i-&gt;total_out()</b></h3> <p>Returns the total number of uncompressed bytes output from inflate.</p> <h3 id="*%24d-%3eget_BufSize()*"><b>$d-&gt;get_BufSize()</b></h3> <p>Returns the buffer size used to carry out the decompression.</p> <h3 id="Examples">Examples</h3> <p>Here is an example of using <code class="inline"><span class="w">inflate</span></code> .</p> <pre class="verbatim" data-language="perl">use strict ;
use warnings ;

use Compress::Raw::Zlib;

my $x = new Compress::Raw::Zlib::Inflate()
   or die "Cannot create a inflation stream\n" ;

my $input = '' ;
binmode STDIN;
binmode STDOUT;

my ($output, $status) ;
while (read(STDIN, $input, 4096))
{
    $status = $x-&gt;inflate($input, $output) ;

    print $output ;

    last if $status != Z_OK ;
}

die "inflation failed\n"
    unless $status == Z_STREAM_END ;
</pre>
<p>The next example show how to use the <code class="inline"><span class="w">LimitOutput</span></code> option. Notice the use of two nested loops in this case. The outer loop reads the data from the input source - STDIN and the inner loop repeatedly calls <code class="inline"><span class="w">inflate</span></code> until <code class="inline"><span class="i">$input</span></code> is exhausted, we get an error, or the end of the stream is reached. One point worth remembering is by using the <code class="inline"><span class="w">LimitOutput</span></code> option you also get <code class="inline"><span class="w">ConsumeInput</span></code> set as well - this makes the code below much simpler.</p> <pre class="verbatim" data-language="perl">  use strict ;
  use warnings ;
  
  use Compress::Raw::Zlib;
  
  my $x = new Compress::Raw::Zlib::Inflate(LimitOutput =&gt; 1)
     or die "Cannot create a inflation stream\n" ;
  
  my $input = '' ;
  binmode STDIN;
  binmode STDOUT;
  
  my ($output, $status) ;

OUTER:
  while (read(STDIN, $input, 4096))
  {
      do
      {
          $status = $x-&gt;inflate($input, $output) ;

          print $output ;

          last OUTER
              unless $status == Z_OK || $status == Z_BUF_ERROR ;
      }
      while ($status == Z_OK &amp;&amp; length $input);
  }
  
  die "inflation failed\n"
      unless $status == Z_STREAM_END ;
</pre>
<h2 id="CHECKSUM-FUNCTIONS">CHECKSUM FUNCTIONS</h2> <p>Two functions are provided by <i>zlib</i> to calculate checksums. For the Perl interface, the order of the two parameters in both functions has been reversed. This allows both running checksums and one off calculations to be done.</p> <pre class="verbatim" data-language="perl">$crc = adler32($buffer [,$crc]) ;
$crc = crc32($buffer [,$crc]) ;
</pre>
<p>The buffer parameters can either be a scalar or a scalar reference.</p> <p>If the $crc parameters is <code class="inline"><a class="l_k" href="../../functions/undef">undef</a></code>, the crc value will be reset.</p> <p>If you have built this module with zlib 1.2.3 or better, two more CRC-related functions are available.</p> <pre class="verbatim" data-language="perl">$crc = crc32_combine($crc1, $crc2, $len2);
$adler = adler32_combine($adler1, $adler2, $len2);
</pre>
<p>These functions allow checksums to be merged. Refer to the <i>zlib</i> documentation for more details.</p> <h2 id="Misc">Misc</h2> <h3 id="my-%24version-%3d-Compress%3a%3aRaw%3a%3aZlib%3a%3azlib_version()%3b">my $version = Compress::Raw::Zlib::zlib_version();</h3> <p>Returns the version of the zlib library.</p> <h3 id="my-%24flags-%3d-Compress%3a%3aRaw%3a%3aZlib%3a%3azlibCompileFlags()%3b">my $flags = Compress::Raw::Zlib::zlibCompileFlags();</h3> <p>Returns the flags indicating compile-time options that were used to build the zlib library. See the zlib documentation for a description of the flags returned by <code class="inline"><span class="w">zlibCompileFlags</span></code> .</p> <p>Note that when the zlib sources are built along with this module the <code class="inline"><a class="l_k" href="../../functions/sprintf">sprintf</a></code> flags (bits 24, 25 and 26) should be ignored.</p> <p>If you are using zlib 1.2.0 or older, <code class="inline"><span class="w">zlibCompileFlags</span></code> will return 0.</p> <h2 id="The-LimitOutput-option.">The LimitOutput option.</h2> <p>By default <code class="inline"><span class="i">$i</span><span class="i">-&gt;inflate</span><span class="s">(</span><span class="i">$input</span><span class="cm">,</span> <span class="i">$output</span><span class="s">)</span></code> will uncompress <i>all</i> data in <code class="inline"><span class="i">$input</span></code> and write <i>all</i> of the uncompressed data it has generated to <code class="inline"><span class="i">$output</span></code> . This makes the interface to <code class="inline"><span class="w">inflate</span></code> much simpler - if the method has uncompressed <code class="inline"><span class="i">$input</span></code> successfully <i>all</i> compressed data in <code class="inline"><span class="i">$input</span></code> will have been dealt with. So if you are reading from an input source and uncompressing as you go the code will look something like this</p> <pre class="verbatim" data-language="perl">use strict ;
use warnings ;

use Compress::Raw::Zlib;

my $x = new Compress::Raw::Zlib::Inflate()
   or die "Cannot create a inflation stream\n" ;

my $input = '' ;

my ($output, $status) ;
while (read(STDIN, $input, 4096))
{
    $status = $x-&gt;inflate($input, $output) ;

    print $output ;

    last if $status != Z_OK ;
}

die "inflation failed\n"
    unless $status == Z_STREAM_END ;
</pre>
<p>The points to note are</p> <ul> <li> <p>The main processing loop in the code handles reading of compressed data from STDIN.</p> </li> <li> <p>The status code returned from <code class="inline"><span class="w">inflate</span></code> will only trigger termination of the main processing loop if it isn't <code class="inline"><span class="w">Z_OK</span></code> . When <code class="inline"><span class="w">LimitOutput</span></code> has not been used the <code class="inline"><span class="w">Z_OK</span></code> status means that the end of the compressed data stream has been reached or there has been an error in uncompression.</p> </li> <li> <p>After the call to <code class="inline"><span class="w">inflate</span></code> <i>all</i> of the uncompressed data in <code class="inline"><span class="i">$input</span></code> will have been processed. This means the subsequent call to <code class="inline"><a class="l_k" href="../../functions/read">read</a></code> can overwrite it's contents without any problem.</p> </li> </ul> <p>For most use-cases the behavior described above is acceptable (this module and it's predecessor, <code class="inline"><span class="w">Compress::Zlib</span></code> , have used it for over 10 years without an issue), but in a few very specific use-cases the amount of memory required for <code class="inline"><span class="i">$output</span></code> can prohibitively large. For example, if the compressed data stream contains the same pattern repeated thousands of times, a relatively small compressed data stream can uncompress into hundreds of megabytes. Remember <code class="inline"><span class="w">inflate</span></code> will keep allocating memory until <i>all</i> the uncompressed data has been written to the output buffer - the size of <code class="inline"><span class="i">$output</span></code> is unbounded.</p> <p>The <code class="inline"><span class="w">LimitOutput</span></code> option is designed to help with this use-case.</p> <p>The main difference in your code when using <code class="inline"><span class="w">LimitOutput</span></code> is having to deal with cases where the <code class="inline"><span class="i">$input</span></code> parameter still contains some uncompressed data that <code class="inline"><span class="w">inflate</span></code> hasn't processed yet. The status code returned from <code class="inline"><span class="w">inflate</span></code> will be <code class="inline"><span class="w">Z_OK</span></code> if uncompression took place and <code class="inline"><span class="w">Z_BUF_ERROR</span></code> if the output buffer is full.</p> <p>Below is typical code that shows how to use <code class="inline"><span class="w">LimitOutput</span></code> .</p> <pre class="verbatim" data-language="perl">  use strict ;
  use warnings ;
  
  use Compress::Raw::Zlib;
  
  my $x = new Compress::Raw::Zlib::Inflate(LimitOutput =&gt; 1)
     or die "Cannot create a inflation stream\n" ;
  
  my $input = '' ;
  binmode STDIN;
  binmode STDOUT;
  
  my ($output, $status) ;

OUTER:
  while (read(STDIN, $input, 4096))
  {
      do
      {
          $status = $x-&gt;inflate($input, $output) ;

          print $output ;

          last OUTER
              unless $status == Z_OK || $status == Z_BUF_ERROR ;
      }
      while ($status == Z_OK &amp;&amp; length $input);
  }
  
  die "inflation failed\n"
      unless $status == Z_STREAM_END ;
</pre>
<p>Points to note this time:</p> <ul> <li> <p>There are now two nested loops in the code: the outer loop for reading the compressed data from STDIN, as before; and the inner loop to carry out the uncompression.</p> </li> <li> <p>There are two exit points from the inner uncompression loop.</p> <p>Firstly when <code class="inline"><span class="w">inflate</span></code> has returned a status other than <code class="inline"><span class="w">Z_OK</span></code> or <code class="inline"><span class="w">Z_BUF_ERROR</span></code> . This means that either the end of the compressed data stream has been reached (<code class="inline"><span class="w">Z_STREAM_END</span></code> ) or there is an error in the compressed data. In either of these cases there is no point in continuing with reading the compressed data, so both loops are terminated.</p> <p>The second exit point tests if there is any data left in the input buffer, <code class="inline"><span class="i">$input</span></code> - remember that the <code class="inline"><span class="w">ConsumeInput</span></code> option is automatically enabled when <code class="inline"><span class="w">LimitOutput</span></code> is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty <code class="inline"><span class="i">$input</span></code> .</p> </li> </ul> <h2 id="ACCESSING-ZIP-FILES">ACCESSING ZIP FILES</h2> <p>Although it is possible (with some effort on your part) to use this module to access .zip files, there are other perl modules available that will do all the hard work for you. Check out <code class="inline"><span class="w">Archive::Zip</span></code> , <code class="inline"><span class="w">Archive::Zip::SimpleZip</span></code> , <code class="inline"><span class="w">IO::Compress::Zip</span></code> and <code class="inline"><span class="w">IO::Uncompress::Unzip</span></code> .</p> <h2 id="FAQ">FAQ</h2> <h3 id="Compatibility-with-Unix-compress%2funcompress.">Compatibility with Unix compress/uncompress.</h3> <p>This module is not compatible with Unix <code class="inline"><span class="w">compress</span></code> .</p> <p>If you have the <code class="inline"><span class="w">uncompress</span></code> program available, you can use this to read compressed files</p> <pre class="verbatim" data-language="perl">open F, "uncompress -c $filename |";
while (&lt;F&gt;)
{
    ...
</pre>
<p>Alternatively, if you have the <code class="inline"><span class="w">gunzip</span></code> program available, you can use this to read compressed files</p> <pre class="verbatim" data-language="perl">open F, "gunzip -c $filename |";
while (&lt;F&gt;)
{
    ...
</pre>
<p>and this to write compress files, if you have the <code class="inline"><span class="w">compress</span></code> program available</p> <pre class="verbatim" data-language="perl">open F, "| compress -c $filename ";
print F "data";
...
close F ;
</pre>
<h3 id="Accessing-.tar.Z-files">Accessing .tar.Z files</h3> <p>See previous FAQ item.</p> <p>If the <code class="inline"><span class="w">Archive::Tar</span></code> module is installed and either the <code class="inline"><span class="w">uncompress</span></code> or <code class="inline"><span class="w">gunzip</span></code> programs are available, you can use one of these workarounds to read <code class="inline">.<span class="w">tar</span>.<span class="w">Z</span></code> files.</p> <p>Firstly with <code class="inline"><span class="w">uncompress</span></code> </p> <pre class="verbatim" data-language="perl">use strict;
use warnings;
use Archive::Tar;

open F, "uncompress -c $filename |";
my $tar = Archive::Tar-&gt;new(*F);
...
</pre>
<p>and this with <code class="inline"><span class="w">gunzip</span></code> </p> <pre class="verbatim" data-language="perl">use strict;
use warnings;
use Archive::Tar;

open F, "gunzip -c $filename |";
my $tar = Archive::Tar-&gt;new(*F);
...
</pre>
<p>Similarly, if the <code class="inline"><span class="w">compress</span></code> program is available, you can use this to write a <code class="inline">.<span class="w">tar</span>.<span class="w">Z</span></code> file</p> <pre class="verbatim" data-language="perl">use strict;
use warnings;
use Archive::Tar;
use IO::File;

my $fh = new IO::File "| compress -c &gt;$filename";
my $tar = Archive::Tar-&gt;new();
...
$tar-&gt;write($fh);
$fh-&gt;close ;
</pre>
<h3 id="Zlib-Library-Version-Support">Zlib Library Version Support</h3> <p>By default <code class="inline"><span class="w">Compress::Raw::Zlib</span></code> will build with a private copy of version 1.2.5 of the zlib library. (See the <i>README</i> file for details of how to override this behaviour)</p> <p>If you decide to use a different version of the zlib library, you need to be aware of the following issues</p> <ul> <li> <p>First off, you must have zlib 1.0.5 or better.</p> </li> <li> <p>You need to have zlib 1.2.1 or better if you want to use the <code class="inline">-<span class="w">Merge</span></code> option with <code class="inline"><span class="w">IO::Compress::Gzip</span></code> , <code class="inline"><span class="w">IO::Compress::Deflate</span></code> and <code class="inline"><span class="w">IO::Compress::RawDeflate</span></code> .</p> </li> </ul> <h2 id="CONSTANTS">CONSTANTS</h2> <p>All the <i>zlib</i> constants are automatically imported when you make use of <i>Compress::Raw::Zlib</i>.</p> <h2 id="SEE-ALSO">SEE ALSO</h2> <p><a href="../zlib">Compress::Zlib</a>, <a href="../../io/compress/gzip">IO::Compress::Gzip</a>, <a href="../../io/uncompress/gunzip">IO::Uncompress::Gunzip</a>, <a href="../../io/compress/deflate">IO::Compress::Deflate</a>, <a href="../../io/uncompress/inflate">IO::Uncompress::Inflate</a>, <a href="../../io/compress/rawdeflate">IO::Compress::RawDeflate</a>, <a href="../../io/uncompress/rawinflate">IO::Uncompress::RawInflate</a>, <a href="../../io/compress/bzip2">IO::Compress::Bzip2</a>, <a href="../../io/uncompress/bunzip2">IO::Uncompress::Bunzip2</a>, <a href="http://search.cpan.org/perldoc/IO::Compress::Lzma">IO::Compress::Lzma</a>, <a href="http://search.cpan.org/perldoc/IO::Uncompress::UnLzma">IO::Uncompress::UnLzma</a>, <a href="http://search.cpan.org/perldoc/IO::Compress::Xz">IO::Compress::Xz</a>, <a href="http://search.cpan.org/perldoc/IO::Uncompress::UnXz">IO::Uncompress::UnXz</a>, <a href="http://search.cpan.org/perldoc/IO::Compress::Lzop">IO::Compress::Lzop</a>, <a href="http://search.cpan.org/perldoc/IO::Uncompress::UnLzop">IO::Uncompress::UnLzop</a>, <a href="http://search.cpan.org/perldoc/IO::Compress::Lzf">IO::Compress::Lzf</a>, <a href="http://search.cpan.org/perldoc/IO::Uncompress::UnLzf">IO::Uncompress::UnLzf</a>, <a href="../../io/uncompress/anyinflate">IO::Uncompress::AnyInflate</a>, <a href="../../io/uncompress/anyuncompress">IO::Uncompress::AnyUncompress</a></p> <p><a href="../../io/compress/faq">IO::Compress::FAQ</a></p> <p><a href="../../file/globmapper">File::GlobMapper</a>, <a href="http://search.cpan.org/perldoc/Archive::Zip">Archive::Zip</a>, <a href="../../archive/tar">Archive::Tar</a>, <a href="../../io/zlib">IO::Zlib</a></p> <p>For RFC 1950, 1951 and 1952 see <i><a href="http://www.faqs.org/rfcs/rfc1950.html">http://www.faqs.org/rfcs/rfc1950.html</a></i>, <i><a href="http://www.faqs.org/rfcs/rfc1951.html">http://www.faqs.org/rfcs/rfc1951.html</a></i> and <i><a href="http://www.faqs.org/rfcs/rfc1952.html">http://www.faqs.org/rfcs/rfc1952.html</a></i></p> <p>The <i>zlib</i> compression library was written by Jean-loup Gailly <i>gzip@prep.ai.mit.edu</i> and Mark Adler <i>madler@alumni.caltech.edu</i>.</p> <p>The primary site for the <i>zlib</i> compression library is <i><a href="http://www.zlib.org">http://www.zlib.org</a></i>.</p> <p>The primary site for gzip is <i><a href="http://www.gzip.org">http://www.gzip.org</a></i>.</p> <h2 id="AUTHOR">AUTHOR</h2> <p>This module was written by Paul Marquess, <i>pmqs@cpan.org</i>.</p> <h2 id="MODIFICATION-HISTORY">MODIFICATION HISTORY</h2> <p>See the Changes file.</p> <h2 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h2> <p>Copyright (c) 2005-2014 Paul Marquess. All rights reserved.</p> <p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1993–2016 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.26.0/Compress/Raw/Zlib.html" class="_attribution-link">https://perldoc.perl.org/5.26.0/Compress/Raw/Zlib.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
