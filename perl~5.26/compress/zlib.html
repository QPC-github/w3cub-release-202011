
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Compress&#58;&#58;Zlib - Perl 5.26 - W3cubDocs</title>
  
  <meta name="description" content=" Compress&#58;&#58;Zlib - Interface to zlib compression library ">
  <meta name="keywords" content="compress, zlib, perl, perl~5.26">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/perl~5.26/compress/zlib.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/perl~5.26.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/perl~5.26/" class="_nav-link" title="" style="margin-left:0;">Perl 5.26</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _perl">
				
				
<h1>Compress::Zlib</h1>  <ul>
<li><a href="#NAME">NAME</a></li>
<li><a href="#SYNOPSIS">SYNOPSIS</a></li>
<li>
<a href="#DESCRIPTION">DESCRIPTION</a><ul><li><a href="#Notes-for-users-of-Compress%3a%3aZlib-version-1">Notes for users of Compress::Zlib version 1</a></li></ul>
</li>
<li>
<a href="#GZIP-INTERFACE">GZIP INTERFACE</a><ul>
<li><a href="#Examples">Examples</a></li>
<li><a href="#Compress%3a%3aZlib%3a%3amemGzip">Compress::Zlib::memGzip</a></li>
<li><a href="#Compress%3a%3aZlib%3a%3amemGunzip">Compress::Zlib::memGunzip</a></li>
</ul>
</li>
<li><a href="#COMPRESS%2fUNCOMPRESS">COMPRESS/UNCOMPRESS</a></li>
<li>
<a href="#Deflate-Interface">Deflate Interface</a><ul>
<li><a href="#*(%24d%2c-%24status)-%3d-deflateInit(-%5bOPT%5d-)*">*($d, $status) = deflateInit( [OPT] )*</a></li>
<li><a href="#*(%24out%2c-%24status)-%3d-%24d-%3edeflate(%24buffer)*">*($out, $status) = $d-&gt;deflate($buffer)*</a></li>
<li><a href="#*(%24out%2c-%24status)-%3d-%24d-%3eflush()*-%3dhead2-*(%24out%2c-%24status)-%3d-%24d-%3eflush(%24flush_type)*">*($out, $status) = $d-&gt;flush()* =head2 *($out, $status) = $d-&gt;flush($flush_type)*</a></li>
<li><a href="#*%24status-%3d-%24d-%3edeflateParams(%5bOPT%5d)*">*$status = $d-&gt;deflateParams([OPT])*</a></li>
<li><a href="#*%24d-%3edict_adler()*">*$d-&gt;dict_adler()*</a></li>
<li><a href="#*%24d-%3emsg()*">*$d-&gt;msg()*</a></li>
<li><a href="#*%24d-%3etotal_in()*">*$d-&gt;total_in()*</a></li>
<li><a href="#*%24d-%3etotal_out()*">*$d-&gt;total_out()*</a></li>
<li><a href="#Example">Example</a></li>
</ul>
</li>
<li>
<a href="#Inflate-Interface">Inflate Interface</a><ul>
<li><a href="#*(%24i%2c-%24status)-%3d-inflateInit()*">*($i, $status) = inflateInit()*</a></li>
<li><a href="#*(%24out%2c-%24status)-%3d-%24i-%3einflate(%24buffer)*">*($out, $status) = $i-&gt;inflate($buffer)*</a></li>
<li><a href="#*%24status-%3d-%24i-%3einflateSync(%24buffer)*">*$status = $i-&gt;inflateSync($buffer)*</a></li>
<li><a href="#*%24i-%3edict_adler()*">*$i-&gt;dict_adler()*</a></li>
<li><a href="#*%24i-%3emsg()*">*$i-&gt;msg()*</a></li>
<li><a href="#*%24i-%3etotal_in()*">*$i-&gt;total_in()*</a></li>
<li><a href="#*%24i-%3etotal_out()*">*$i-&gt;total_out()*</a></li>
<li><a href="#Example">Example</a></li>
</ul>
</li>
<li><a href="#CHECKSUM-FUNCTIONS">CHECKSUM FUNCTIONS</a></li>
<li>
<a href="#Misc">Misc</a><ul><li><a href="#my-%24version-%3d-Compress%3a%3aZlib%3a%3azlib_version()%3b">my $version = Compress::Zlib::zlib_version();</a></li></ul>
</li>
<li><a href="#CONSTANTS">CONSTANTS</a></li>
<li><a href="#SEE-ALSO">SEE ALSO</a></li>
<li><a href="#AUTHOR">AUTHOR</a></li>
<li><a href="#MODIFICATION-HISTORY">MODIFICATION HISTORY</a></li>
<li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>
<h2 id="NAME">NAME</h2> <p>Compress::Zlib - Interface to zlib compression library</p> <h2 id="SYNOPSIS">SYNOPSIS</h2> <pre class="verbatim" data-language="perl">use Compress::Zlib ;

($d, $status) = deflateInit( [OPT] ) ;
$status = $d-&gt;deflate($input, $output) ;
$status = $d-&gt;flush([$flush_type]) ;
$d-&gt;deflateParams(OPTS) ;
$d-&gt;deflateTune(OPTS) ;
$d-&gt;dict_adler() ;
$d-&gt;crc32() ;
$d-&gt;adler32() ;
$d-&gt;total_in() ;
$d-&gt;total_out() ;
$d-&gt;msg() ;
$d-&gt;get_Strategy();
$d-&gt;get_Level();
$d-&gt;get_BufSize();

($i, $status) = inflateInit( [OPT] ) ;
$status = $i-&gt;inflate($input, $output [, $eof]) ;
$status = $i-&gt;inflateSync($input) ;
$i-&gt;dict_adler() ;
$d-&gt;crc32() ;
$d-&gt;adler32() ;
$i-&gt;total_in() ;
$i-&gt;total_out() ;
$i-&gt;msg() ;
$d-&gt;get_BufSize();

$dest = compress($source) ;
$dest = uncompress($source) ;

$gz = gzopen($filename or filehandle, $mode) ;
$bytesread = $gz-&gt;gzread($buffer [,$size]) ;
$bytesread = $gz-&gt;gzreadline($line) ;
$byteswritten = $gz-&gt;gzwrite($buffer) ;
$status = $gz-&gt;gzflush($flush) ;
$offset = $gz-&gt;gztell() ;
$status = $gz-&gt;gzseek($offset, $whence) ;
$status = $gz-&gt;gzclose() ;
$status = $gz-&gt;gzeof() ;
$status = $gz-&gt;gzsetparams($level, $strategy) ;
$errstring = $gz-&gt;gzerror() ; 
$gzerrno

$dest = Compress::Zlib::memGzip($buffer) ;
$dest = Compress::Zlib::memGunzip($buffer) ;

$crc = adler32($buffer [,$crc]) ;
$crc = crc32($buffer [,$crc]) ;

$crc = crc32_combine($crc1, $crc2, $len2);
$adler = adler32_combine($adler1, $adler2, $len2);

my $version = Compress::Raw::Zlib::zlib_version();
</pre>
<h2 id="DESCRIPTION">DESCRIPTION</h2> <p>The <i>Compress::Zlib</i> module provides a Perl interface to the <i>zlib</i> compression library (see <a href="#AUTHOR">AUTHOR</a> for details about where to get <i>zlib</i>).</p> <p>The <code class="inline"><span class="w">Compress::Zlib</span></code> module can be split into two general areas of functionality, namely a simple read/write interface to <i>gzip</i> files and a low-level in-memory compression/decompression interface.</p> <p>Each of these areas will be discussed in the following sections.</p> <h3 id="Notes-for-users-of-Compress%3a%3aZlib-version-1">Notes for users of Compress::Zlib version 1</h3> <p>The main change in <code class="inline"><span class="w">Compress::Zlib</span></code> version 2.x is that it does not now interface directly to the zlib library. Instead it uses the <code class="inline"><span class="w">IO::Compress::Gzip</span></code> and <code class="inline"><span class="w">IO::Uncompress::Gunzip</span></code> modules for reading/writing gzip files, and the <code class="inline"><span class="w">Compress::Raw::Zlib</span></code> module for some low-level zlib access.</p> <p>The interface provided by version 2 of this module should be 100% backward compatible with version 1. If you find a difference in the expected behaviour please contact the author (See <a href="#AUTHOR">AUTHOR</a>). See <a href="#GZIP-INTERFACE">GZIP INTERFACE</a></p> <p>With the creation of the <code class="inline"><span class="w">IO::Compress</span></code> and <code class="inline"><span class="w">IO::Uncompress</span></code> modules no new features are planned for <code class="inline"><span class="w">Compress::Zlib</span></code> - the new modules do everything that <code class="inline"><span class="w">Compress::Zlib</span></code> does and then some. Development on <code class="inline"><span class="w">Compress::Zlib</span></code> will be limited to bug fixes only.</p> <p>If you are writing new code, your first port of call should be one of the new <code class="inline"><span class="w">IO::Compress</span></code> or <code class="inline"><span class="w">IO::Uncompress</span></code> modules.</p> <h2 id="GZIP-INTERFACE">GZIP INTERFACE</h2> <p>A number of functions are supplied in <i>zlib</i> for reading and writing <i>gzip</i> files that conform to RFC 1952. This module provides an interface to most of them.</p> <p>If you have previously used <code class="inline"><span class="w">Compress::Zlib</span></code> 1.x, the following enhancements/changes have been made to the <code class="inline"><span class="w">gzopen</span></code> interface:</p> <dl> <dt>1</dt>
<dd> <p>If you want to open either STDIN or STDOUT with <code class="inline"><span class="w">gzopen</span></code> , you can now optionally use the special filename "<code class="inline">-</code> " as a synonym for <code class="inline">\<span class="i">*STDIN</span></code> and <code class="inline">\<span class="i">*STDOUT</span></code> .</p> </dd> <dt>2</dt>
<dd> <p>In <code class="inline"><span class="w">Compress::Zlib</span></code> version 1.x, <code class="inline"><span class="w">gzopen</span></code> used the zlib library to open the underlying file. This made things especially tricky when a Perl filehandle was passed to <code class="inline"><span class="w">gzopen</span></code> . Behind the scenes the numeric C file descriptor had to be extracted from the Perl filehandle and this passed to the zlib library.</p> <p>Apart from being non-portable to some operating systems, this made it difficult to use <code class="inline"><span class="w">gzopen</span></code> in situations where you wanted to extract/create a gzip data stream that is embedded in a larger file, without having to resort to opening and closing the file multiple times.</p> <p>It also made it impossible to pass a perl filehandle that wasn't associated with a real filesystem file, like, say, an <code class="inline"><span class="w">IO::String</span></code> .</p> <p>In <code class="inline"><span class="w">Compress::Zlib</span></code> version 2.x, the <code class="inline"><span class="w">gzopen</span></code> interface has been completely rewritten to use the <a href="../io/compress/gzip">IO::Compress::Gzip</a> for writing gzip files and <a href="../io/uncompress/gunzip">IO::Uncompress::Gunzip</a> for reading gzip files. None of the limitations mentioned above apply.</p> </dd> <dt>3</dt>
<dd> <p>Addition of <code class="inline"><span class="w">gzseek</span></code> to provide a restricted <code class="inline"><a class="l_k" href="../functions/seek">seek</a></code> interface.</p> </dd> <dt>4.</dt>
<dd> <p>Added <code class="inline"><span class="w">gztell</span></code> .</p> </dd> </dl> <p>A more complete and flexible interface for reading/writing gzip files/buffers is included with the module <code class="inline"><span class="w">IO</span>-<span class="w">Compress</span>-<span class="w">Zlib</span></code> . See <a href="../io/compress/gzip">IO::Compress::Gzip</a> and <a href="../io/uncompress/gunzip">IO::Uncompress::Gunzip</a> for more details.</p> <ul> <li id="*%24gz-%3d-gzopen(%24filename%2c-%24mode)*">
<b><b>$gz = gzopen($filename, $mode)</b></b> </li> <li id="*%24gz-%3d-gzopen(%24filehandle%2c-%24mode)*">
<b><b>$gz = gzopen($filehandle, $mode)</b></b> <p>This function opens either the <i>gzip</i> file <code class="inline"><span class="i">$filename</span></code> for reading or writing or attaches to the opened filehandle, <code class="inline"><span class="i">$filehandle</span></code> . It returns an object on success and <code class="inline"><a class="l_k" href="../functions/undef">undef</a></code> on failure.</p> <p>When writing a gzip file this interface will <i>always</i> create the smallest possible gzip header (exactly 10 bytes). If you want greater control over what gets stored in the gzip header (like the original filename or a comment) use <a href="../io/compress/gzip">IO::Compress::Gzip</a> instead. Similarly if you want to read the contents of the gzip header use <a href="../io/uncompress/gunzip">IO::Uncompress::Gunzip</a>.</p> <p>The second parameter, <code class="inline"><span class="i">$mode</span></code> , is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the <code class="inline"><span class="i">$mode</span></code> parameter is similar to the mode parameter to the 'C' function <code class="inline"><span class="w">fopen</span></code> , so "rb" is used to open for reading, "wb" for writing and "ab" for appending (writing at the end of the file).</p> <p>To specify a compression level when writing, append a digit between 0 and 9 to the mode string -- 0 means no compression and 9 means maximum compression. If no compression level is specified Z_DEFAULT_COMPRESSION is used.</p> <p>To specify the compression strategy when writing, append 'f' for filtered data, 'h' for Huffman only compression, or 'R' for run-length encoding. If no strategy is specified Z_DEFAULT_STRATEGY is used.</p> <p>So, for example, "wb9" means open for writing with the maximum compression using the default strategy and "wb4R" means open for writing with compression level 4 and run-length encoding.</p> <p>Refer to the <i>zlib</i> documentation for the exact format of the <code class="inline"><span class="i">$mode</span></code> parameter.</p> </li> <li id="*%24bytesread-%3d-%24gz-%3egzread(%24buffer-%5b%2c-%24size%5d)-%3b*">
<b><b>$bytesread = $gz-&gt;gzread($buffer [, $size]) ;</b></b> <p>Reads <code class="inline"><span class="i">$size</span></code> bytes from the compressed file into <code class="inline"><span class="i">$buffer</span></code> . If <code class="inline"><span class="i">$size</span></code> is not specified, it will default to 4096. If the scalar <code class="inline"><span class="i">$buffer</span></code> is not large enough, it will be extended automatically.</p> <p>Returns the number of bytes actually read. On EOF it returns 0 and in the case of an error, -1.</p> </li> <li id="*%24bytesread-%3d-%24gz-%3egzreadline(%24line)-%3b*">
<b><b>$bytesread = $gz-&gt;gzreadline($line) ;</b></b> <p>Reads the next line from the compressed file into <code class="inline"><span class="i">$line</span></code> .</p> <p>Returns the number of bytes actually read. On EOF it returns 0 and in the case of an error, -1.</p> <p>It is legal to intermix calls to <code class="inline"><span class="w">gzread</span></code> and <code class="inline"><span class="w">gzreadline</span></code> .</p> <p>To maintain backward compatibility with version 1.x of this module <code class="inline"><span class="w">gzreadline</span></code> ignores the <code class="inline"><span class="i">$/</span></code> variable - it <i>always</i> uses the string <code class="inline"><span class="q">"\n"</span></code> as the line delimiter.</p> <p>If you want to read a gzip file a line at a time and have it respect the <code class="inline"><span class="i">$/</span></code> variable (or <code class="inline"><span class="i">$INPUT_RECORD_SEPARATOR</span></code> , or <code class="inline"><span class="i">$RS</span></code> when <code class="inline"><span class="w">English</span></code> is in use) see <a href="../io/uncompress/gunzip">IO::Uncompress::Gunzip</a>.</p> </li> <li id="*%24byteswritten-%3d-%24gz-%3egzwrite(%24buffer)-%3b*">
<b><b>$byteswritten = $gz-&gt;gzwrite($buffer) ;</b></b> <p>Writes the contents of <code class="inline"><span class="i">$buffer</span></code> to the compressed file. Returns the number of bytes actually written, or 0 on error.</p> </li> <li id="*%24status-%3d-%24gz-%3egzflush(%24flush_type)-%3b*">
<b><b>$status = $gz-&gt;gzflush($flush_type) ;</b></b> <p>Flushes all pending output into the compressed file.</p> <p>This method takes an optional parameter, <code class="inline"><span class="i">$flush_type</span></code> , that controls how the flushing will be carried out. By default the <code class="inline"><span class="i">$flush_type</span></code> used is <code class="inline"><span class="w">Z_FINISH</span></code> . Other valid values for <code class="inline"><span class="i">$flush_type</span></code> are <code class="inline"><span class="w">Z_NO_FLUSH</span></code> , <code class="inline"><span class="w">Z_SYNC_FLUSH</span></code> , <code class="inline"><span class="w">Z_FULL_FLUSH</span></code> and <code class="inline"><span class="w">Z_BLOCK</span></code> . It is strongly recommended that you only set the <code class="inline"><span class="w">flush_type</span></code> parameter if you fully understand the implications of what it does - overuse of <code class="inline"><span class="w">flush</span></code> can seriously degrade the level of compression achieved. See the <code class="inline"><span class="w">zlib</span></code> documentation for details.</p> <p>Returns 0 on success.</p> </li> <li id="*%24offset-%3d-%24gz-%3egztell()-%3b*">
<b><b>$offset = $gz-&gt;gztell() ;</b></b> <p>Returns the uncompressed file offset.</p> </li> <li id="*%24status-%3d-%24gz-%3egzseek(%24offset%2c-%24whence)-%3b*">
<b><b>$status = $gz-&gt;gzseek($offset, $whence) ;</b></b> <p>Provides a sub-set of the <code class="inline"><a class="l_k" href="../functions/seek">seek</a></code> functionality, with the restriction that it is only legal to seek forward in the compressed file. It is a fatal error to attempt to seek backward.</p> <p>When opened for writing, empty parts of the file will have NULL (0x00) bytes written to them.</p> <p>The <code class="inline"><span class="i">$whence</span></code> parameter should be one of SEEK_SET, SEEK_CUR or SEEK_END.</p> <p>Returns 1 on success, 0 on failure.</p> </li> <li id="*%24gz-%3egzclose*">
<b><b>$gz-&gt;gzclose</b></b> <p>Closes the compressed file. Any pending data is flushed to the file before it is closed.</p> <p>Returns 0 on success.</p> </li> <li id="*%24gz-%3egzsetparams(%24level%2c-%24strategy*">
<b><b>$gz-&gt;gzsetparams($level, $strategy</b></b> <p>Change settings for the deflate stream <code class="inline"><span class="i">$gz</span></code> .</p> <p>The list of the valid options is shown below. Options not specified will remain unchanged.</p> <p>Note: This method is only available if you are running zlib 1.0.6 or better.</p> <ul> <li id="*%24level*">
<b><b>$level</b></b> <p>Defines the compression level. Valid values are 0 through 9, <code class="inline"><span class="w">Z_NO_COMPRESSION</span></code> , <code class="inline"><span class="w">Z_BEST_SPEED</span></code> , <code class="inline"><span class="w">Z_BEST_COMPRESSION</span></code> , and <code class="inline"><span class="w">Z_DEFAULT_COMPRESSION</span></code> .</p> </li> <li id="*%24strategy*">
<b><b>$strategy</b></b> <p>Defines the strategy used to tune the compression. The valid values are <code class="inline"><span class="w">Z_DEFAULT_STRATEGY</span></code> , <code class="inline"><span class="w">Z_FILTERED</span></code> and <code class="inline"><span class="w">Z_HUFFMAN_ONLY</span></code> .</p> </li> </ul> </li> <li id="*%24gz-%3egzerror*">
<b><b>$gz-&gt;gzerror</b></b> <p>Returns the <i>zlib</i> error message or number for the last operation associated with <code class="inline"><span class="i">$gz</span></code> . The return value will be the <i>zlib</i> error number when used in a numeric context and the <i>zlib</i> error message when used in a string context. The <i>zlib</i> error number constants, shown below, are available for use.</p> <pre class="verbatim" data-language="perl">Z_OK
Z_STREAM_END
Z_ERRNO
Z_STREAM_ERROR
Z_DATA_ERROR
Z_MEM_ERROR
Z_BUF_ERROR
</pre>
</li> <li id="*%24gzerrno*">
<b><b>$gzerrno</b></b> <p>The <code class="inline"><span class="i">$gzerrno</span></code> scalar holds the error code associated with the most recent <i>gzip</i> routine. Note that unlike <code class="inline"><span class="i">gzerror</span><span class="s">(</span><span class="s">)</span></code> , the error is <i>not</i> associated with a particular file.</p> <p>As with <code class="inline"><span class="i">gzerror</span><span class="s">(</span><span class="s">)</span></code> it returns an error number in numeric context and an error message in string context. Unlike <code class="inline"><span class="i">gzerror</span><span class="s">(</span><span class="s">)</span></code> though, the error message will correspond to the <i>zlib</i> message when the error is associated with <i>zlib</i> itself, or the UNIX error message when it is not (i.e. <i>zlib</i> returned <code class="inline"><span class="w">Z_ERRORNO</span></code> ).</p> <p>As there is an overlap between the error numbers used by <i>zlib</i> and UNIX, <code class="inline"><span class="i">$gzerrno</span></code> should only be used to check for the presence of <i>an</i> error in numeric context. Use <code class="inline"><span class="i">gzerror</span><span class="s">(</span><span class="s">)</span></code> to check for specific <i>zlib</i> errors. The <i>gzcat</i> example below shows how the variable can be used safely.</p> </li> </ul> <h3 id="Examples">Examples</h3> <p>Here is an example script which uses the interface. It implements a <i>gzcat</i> function.</p> <pre class="verbatim" data-language="perl">use strict ;
use warnings ;

use Compress::Zlib ;

# use stdin if no files supplied
@ARGV = '-' unless @ARGV ;

foreach my $file (@ARGV) {
    my $buffer ;

    my $gz = gzopen($file, "rb") 
         or die "Cannot open $file: $gzerrno\n" ;

    print $buffer while $gz-&gt;gzread($buffer) &gt; 0 ;

    die "Error reading from $file: $gzerrno" . ($gzerrno+0) . "\n" 
        if $gzerrno != Z_STREAM_END ;
    
    $gz-&gt;gzclose() ;
}
</pre>
<p>Below is a script which makes use of <code class="inline"><span class="w">gzreadline</span></code> . It implements a very simple <i>grep</i> like script.</p> <pre class="verbatim" data-language="perl">use strict ;
use warnings ;

use Compress::Zlib ;

die "Usage: gzgrep pattern [file...]\n"
    unless @ARGV &gt;= 1;

my $pattern = shift ;

# use stdin if no files supplied
@ARGV = '-' unless @ARGV ;

foreach my $file (@ARGV) {
    my $gz = gzopen($file, "rb") 
         or die "Cannot open $file: $gzerrno\n" ;

    while ($gz-&gt;gzreadline($_) &gt; 0) {
        print if /$pattern/ ;
    }

    die "Error reading from $file: $gzerrno\n" 
        if $gzerrno != Z_STREAM_END ;
    
    $gz-&gt;gzclose() ;
}
</pre>
<p>This script, <i>gzstream</i>, does the opposite of the <i>gzcat</i> script above. It reads from standard input and writes a gzip data stream to standard output.</p> <pre class="verbatim" data-language="perl">use strict ;
use warnings ;

use Compress::Zlib ;

binmode STDOUT;  # gzopen only sets it on the fd

my $gz = gzopen(\*STDOUT, "wb")
      or die "Cannot open stdout: $gzerrno\n" ;

while (&lt;&gt;) {
    $gz-&gt;gzwrite($_) 
      or die "error writing: $gzerrno\n" ;
}

$gz-&gt;gzclose ;
</pre>
<h3 id="Compress%3a%3aZlib%3a%3amemGzip">Compress::Zlib::memGzip</h3> <p>This function is used to create an in-memory gzip file with the minimum possible gzip header (exactly 10 bytes).</p> <pre class="verbatim" data-language="perl">$dest = Compress::Zlib::memGzip($buffer) 
    or die "Cannot compress: $gzerrno\n";
</pre>
<p>If successful, it returns the in-memory gzip file. Otherwise it returns <code class="inline"><a class="l_k" href="../functions/undef">undef</a></code> and the <code class="inline"><span class="i">$gzerrno</span></code> variable will store the zlib error code.</p> <p>The <code class="inline"><span class="i">$buffer</span></code> parameter can either be a scalar or a scalar reference.</p> <p>See <a href="../io/compress/gzip">IO::Compress::Gzip</a> for an alternative way to carry out in-memory gzip compression.</p> <h3 id="Compress%3a%3aZlib%3a%3amemGunzip">Compress::Zlib::memGunzip</h3> <p>This function is used to uncompress an in-memory gzip file.</p> <pre class="verbatim" data-language="perl">$dest = Compress::Zlib::memGunzip($buffer) 
    or die "Cannot uncompress: $gzerrno\n";
</pre>
<p>If successful, it returns the uncompressed gzip file. Otherwise it returns <code class="inline"><a class="l_k" href="../functions/undef">undef</a></code> and the <code class="inline"><span class="i">$gzerrno</span></code> variable will store the zlib error code.</p> <p>The <code class="inline"><span class="i">$buffer</span></code> parameter can either be a scalar or a scalar reference. The contents of the <code class="inline"><span class="i">$buffer</span></code> parameter are destroyed after calling this function.</p> <p>If <code class="inline"><span class="i">$buffer</span></code> consists of multiple concatenated gzip data streams only the first will be uncompressed. Use <code class="inline"><span class="w">gunzip</span></code> with the <code class="inline"><span class="w">MultiStream</span></code> option in the <code class="inline"><span class="w">IO::Uncompress::Gunzip</span></code> module if you need to deal with concatenated data streams.</p> <p>See <a href="../io/uncompress/gunzip">IO::Uncompress::Gunzip</a> for an alternative way to carry out in-memory gzip uncompression.</p> <h2 id="COMPRESS%2fUNCOMPRESS">COMPRESS/UNCOMPRESS</h2> <p>Two functions are provided to perform in-memory compression/uncompression of RFC 1950 data streams. They are called <code class="inline"><span class="w">compress</span></code> and <code class="inline"><span class="w">uncompress</span></code> .</p> <ul> <li id="*%24dest-%3d-compress(%24source-%5b%2c-%24level%5d-)-%3b*">
<b><b>$dest = compress($source [, $level] ) ;</b></b> <p>Compresses <code class="inline"><span class="i">$source</span></code> . If successful it returns the compressed data. Otherwise it returns <i>undef</i>.</p> <p>The source buffer, <code class="inline"><span class="i">$source</span></code> , can either be a scalar or a scalar reference.</p> <p>The <code class="inline"><span class="i">$level</span></code> parameter defines the compression level. Valid values are 0 through 9, <code class="inline"><span class="w">Z_NO_COMPRESSION</span></code> , <code class="inline"><span class="w">Z_BEST_SPEED</span></code> , <code class="inline"><span class="w">Z_BEST_COMPRESSION</span></code> , and <code class="inline"><span class="w">Z_DEFAULT_COMPRESSION</span></code> . If <code class="inline"><span class="i">$level</span></code> is not specified <code class="inline"><span class="w">Z_DEFAULT_COMPRESSION</span></code> will be used.</p> </li> <li id="*%24dest-%3d-uncompress(%24source)-%3b*">
<b><b>$dest = uncompress($source) ;</b></b> <p>Uncompresses <code class="inline"><span class="i">$source</span></code> . If successful it returns the uncompressed data. Otherwise it returns <i>undef</i>.</p> <p>The source buffer can either be a scalar or a scalar reference.</p> </li> </ul> <p>Please note: the two functions defined above are <i>not</i> compatible with the Unix commands of the same name.</p> <p>See <a href="http://search.cpan.org/perldoc/IO::Deflate">IO::Deflate</a> and <a href="http://search.cpan.org/perldoc/IO::Inflate">IO::Inflate</a> included with this distribution for an alternative interface for reading/writing RFC 1950 files/buffers.</p> <h2 id="Deflate-Interface">Deflate Interface</h2> <p>This section defines an interface that allows in-memory compression using the <i>deflate</i> interface provided by zlib.</p> <p>Here is a definition of the interface available:</p> <h3 id="*(%24d%2c-%24status)-%3d-deflateInit(-%5bOPT%5d-)*"><b>($d, $status) = deflateInit( [OPT] )</b></h3> <p>Initialises a deflation stream.</p> <p>It combines the features of the <i>zlib</i> functions <code class="inline"><span class="w">deflateInit</span></code> , <code class="inline"><span class="w">deflateInit2</span></code> and <code class="inline"><span class="w">deflateSetDictionary</span></code> .</p> <p>If successful, it will return the initialised deflation stream, <code class="inline"><span class="i">$d</span></code> and <code class="inline"><span class="i">$status</span></code> of <code class="inline"><span class="w">Z_OK</span></code> in a list context. In scalar context it returns the deflation stream, <code class="inline"><span class="i">$d</span></code> , only.</p> <p>If not successful, the returned deflation stream (<code class="inline"><span class="i">$d</span></code> ) will be <i>undef</i> and <code class="inline"><span class="i">$status</span></code> will hold the exact <i>zlib</i> error code.</p> <p>The function optionally takes a number of named options specified as <code class="inline">-<span class="w">Name</span><span class="cm">=&gt;</span><span class="w">value</span></code> pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</p> <p>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the name=&gt;value pairs.</p> <p>The function takes one optional parameter, a reference to a hash. The contents of the hash allow the deflation interface to be tailored.</p> <p>Here is a list of the valid options:</p> <ul> <li id="*-Level*">
<b><b>-Level</b></b> <p>Defines the compression level. Valid values are 0 through 9, <code class="inline"><span class="w">Z_NO_COMPRESSION</span></code> , <code class="inline"><span class="w">Z_BEST_SPEED</span></code> , <code class="inline"><span class="w">Z_BEST_COMPRESSION</span></code> , and <code class="inline"><span class="w">Z_DEFAULT_COMPRESSION</span></code> .</p> <p>The default is Z_DEFAULT_COMPRESSION.</p> </li> <li id="*-Method*">
<b><b>-Method</b></b> <p>Defines the compression method. The only valid value at present (and the default) is Z_DEFLATED.</p> </li> <li id="*-WindowBits*">
<b><b>-WindowBits</b></b> <p>To create an RFC 1950 data stream, set <code class="inline"><span class="w">WindowBits</span></code> to a positive number.</p> <p>To create an RFC 1951 data stream, set <code class="inline"><span class="w">WindowBits</span></code> to <code class="inline">-<span class="w">MAX_WBITS</span></code> .</p> <p>For a full definition of the meaning and valid values for <code class="inline"><span class="w">WindowBits</span></code> refer to the <i>zlib</i> documentation for <i>deflateInit2</i>.</p> <p>Defaults to MAX_WBITS.</p> </li> <li id="*-MemLevel*">
<b><b>-MemLevel</b></b> <p>For a definition of the meaning and valid values for <code class="inline"><span class="w">MemLevel</span></code> refer to the <i>zlib</i> documentation for <i>deflateInit2</i>.</p> <p>Defaults to MAX_MEM_LEVEL.</p> </li> <li id="*-Strategy*">
<b><b>-Strategy</b></b> <p>Defines the strategy used to tune the compression. The valid values are <code class="inline"><span class="w">Z_DEFAULT_STRATEGY</span></code> , <code class="inline"><span class="w">Z_FILTERED</span></code> and <code class="inline"><span class="w">Z_HUFFMAN_ONLY</span></code> .</p> <p>The default is Z_DEFAULT_STRATEGY.</p> </li> <li id="*-Dictionary*">
<b><b>-Dictionary</b></b> <p>When a dictionary is specified <i>Compress::Zlib</i> will automatically call <code class="inline"><span class="w">deflateSetDictionary</span></code> directly after calling <code class="inline"><span class="w">deflateInit</span></code> . The Adler32 value for the dictionary can be obtained by calling the method <code class="inline"><span class="i">$d</span>-</code> dict_adler()&gt;.</p> <p>The default is no dictionary.</p> </li> <li id="*-Bufsize*">
<b><b>-Bufsize</b></b> <p>Sets the initial size for the deflation buffer. If the buffer has to be reallocated to increase the size, it will grow in increments of <code class="inline"><span class="w">Bufsize</span></code> .</p> <p>The default is 4096.</p> </li> </ul> <p>Here is an example of using the <code class="inline"><span class="w">deflateInit</span></code> optional parameter list to override the default buffer size and compression level. All other options will take their default values.</p> <pre class="verbatim" data-language="perl">deflateInit( -Bufsize =&gt; 300, 
             -Level =&gt; Z_BEST_SPEED  ) ;
</pre>
<h3 id="*(%24out%2c-%24status)-%3d-%24d-%3edeflate(%24buffer)*"><b>($out, $status) = $d-&gt;deflate($buffer)</b></h3> <p>Deflates the contents of <code class="inline"><span class="i">$buffer</span></code> . The buffer can either be a scalar or a scalar reference. When finished, <code class="inline"><span class="i">$buffer</span></code> will be completely processed (assuming there were no errors). If the deflation was successful it returns the deflated output, <code class="inline"><span class="i">$out</span></code> , and a status value, <code class="inline"><span class="i">$status</span></code> , of <code class="inline"><span class="w">Z_OK</span></code> .</p> <p>On error, <code class="inline"><span class="i">$out</span></code> will be <i>undef</i> and <code class="inline"><span class="i">$status</span></code> will contain the <i>zlib</i> error code.</p> <p>In a scalar context <code class="inline"><span class="w">deflate</span></code> will return <code class="inline"><span class="i">$out</span></code> only.</p> <p>As with the <i>deflate</i> function in <i>zlib</i>, it is not necessarily the case that any output will be produced by this method. So don't rely on the fact that <code class="inline"><span class="i">$out</span></code> is empty for an error test.</p> <h3 id="*(%24out%2c-%24status)-%3d-%24d-%3eflush()*-%3dhead2-*(%24out%2c-%24status)-%3d-%24d-%3eflush(%24flush_type)*">
<b>($out, $status) = $d-&gt;flush()</b> =head2 <b>($out, $status) = $d-&gt;flush($flush_type)</b>
</h3> <p>Typically used to finish the deflation. Any pending output will be returned via <code class="inline"><span class="i">$out</span></code> . <code class="inline"><span class="i">$status</span></code> will have a value <code class="inline"><span class="w">Z_OK</span></code> if successful.</p> <p>In a scalar context <code class="inline"><span class="w">flush</span></code> will return <code class="inline"><span class="i">$out</span></code> only.</p> <p>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using <code class="inline"><span class="w">Z_FINISH</span></code> ) or when you want to create a <i>full flush point</i> (using <code class="inline"><span class="w">Z_FULL_FLUSH</span></code> ).</p> <p>By default the <code class="inline"><span class="w">flush_type</span></code> used is <code class="inline"><span class="w">Z_FINISH</span></code> . Other valid values for <code class="inline"><span class="w">flush_type</span></code> are <code class="inline"><span class="w">Z_NO_FLUSH</span></code> , <code class="inline"><span class="w">Z_PARTIAL_FLUSH</span></code> , <code class="inline"><span class="w">Z_SYNC_FLUSH</span></code> and <code class="inline"><span class="w">Z_FULL_FLUSH</span></code> . It is strongly recommended that you only set the <code class="inline"><span class="w">flush_type</span></code> parameter if you fully understand the implications of what it does. See the <code class="inline"><span class="w">zlib</span></code> documentation for details.</p> <h3 id="*%24status-%3d-%24d-%3edeflateParams(%5bOPT%5d)*"><b>$status = $d-&gt;deflateParams([OPT])</b></h3> <p>Change settings for the deflate stream <code class="inline"><span class="i">$d</span></code> .</p> <p>The list of the valid options is shown below. Options not specified will remain unchanged.</p> <ul> <li id="*-Level*">
<b><b>-Level</b></b> <p>Defines the compression level. Valid values are 0 through 9, <code class="inline"><span class="w">Z_NO_COMPRESSION</span></code> , <code class="inline"><span class="w">Z_BEST_SPEED</span></code> , <code class="inline"><span class="w">Z_BEST_COMPRESSION</span></code> , and <code class="inline"><span class="w">Z_DEFAULT_COMPRESSION</span></code> .</p> </li> <li id="*-Strategy*">
<b><b>-Strategy</b></b> <p>Defines the strategy used to tune the compression. The valid values are <code class="inline"><span class="w">Z_DEFAULT_STRATEGY</span></code> , <code class="inline"><span class="w">Z_FILTERED</span></code> and <code class="inline"><span class="w">Z_HUFFMAN_ONLY</span></code> .</p> </li> </ul> <h3 id="*%24d-%3edict_adler()*"><b>$d-&gt;dict_adler()</b></h3> <p>Returns the adler32 value for the dictionary.</p> <h3 id="*%24d-%3emsg()*"><b>$d-&gt;msg()</b></h3> <p>Returns the last error message generated by zlib.</p> <h3 id="*%24d-%3etotal_in()*"><b>$d-&gt;total_in()</b></h3> <p>Returns the total number of bytes uncompressed bytes input to deflate.</p> <h3 id="*%24d-%3etotal_out()*"><b>$d-&gt;total_out()</b></h3> <p>Returns the total number of compressed bytes output from deflate.</p> <h3 id="Example">Example</h3> <p>Here is a trivial example of using <code class="inline"><span class="w">deflate</span></code> . It simply reads standard input, deflates it and writes it to standard output.</p> <pre class="verbatim" data-language="perl">use strict ;
use warnings ;

use Compress::Zlib ;

binmode STDIN;
binmode STDOUT;
my $x = deflateInit()
   or die "Cannot create a deflation stream\n" ;

my ($output, $status) ;
while (&lt;&gt;)
{
    ($output, $status) = $x-&gt;deflate($_) ;

    $status == Z_OK
        or die "deflation failed\n" ;

    print $output ;
}

($output, $status) = $x-&gt;flush() ;

$status == Z_OK
    or die "deflation failed\n" ;

print $output ;
</pre>
<h2 id="Inflate-Interface">Inflate Interface</h2> <p>This section defines the interface available that allows in-memory uncompression using the <i>deflate</i> interface provided by zlib.</p> <p>Here is a definition of the interface:</p> <h3 id="*(%24i%2c-%24status)-%3d-inflateInit()*"><b>($i, $status) = inflateInit()</b></h3> <p>Initialises an inflation stream.</p> <p>In a list context it returns the inflation stream, <code class="inline"><span class="i">$i</span></code> , and the <i>zlib</i> status code in <code class="inline"><span class="i">$status</span></code> . In a scalar context it returns the inflation stream only.</p> <p>If successful, <code class="inline"><span class="i">$i</span></code> will hold the inflation stream and <code class="inline"><span class="i">$status</span></code> will be <code class="inline"><span class="w">Z_OK</span></code> .</p> <p>If not successful, <code class="inline"><span class="i">$i</span></code> will be <i>undef</i> and <code class="inline"><span class="i">$status</span></code> will hold the <i>zlib</i> error code.</p> <p>The function optionally takes a number of named options specified as <code class="inline">-<span class="w">Name</span><span class="cm">=&gt;</span><span class="w">value</span></code> pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</p> <p>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the name=&gt;value pairs.</p> <p>The function takes one optional parameter, a reference to a hash. The contents of the hash allow the deflation interface to be tailored.</p> <p>Here is a list of the valid options:</p> <ul> <li id="*-WindowBits*">
<b><b>-WindowBits</b></b> <p>To uncompress an RFC 1950 data stream, set <code class="inline"><span class="w">WindowBits</span></code> to a positive number.</p> <p>To uncompress an RFC 1951 data stream, set <code class="inline"><span class="w">WindowBits</span></code> to <code class="inline">-<span class="w">MAX_WBITS</span></code> .</p> <p>For a full definition of the meaning and valid values for <code class="inline"><span class="w">WindowBits</span></code> refer to the <i>zlib</i> documentation for <i>inflateInit2</i>.</p> <p>Defaults to MAX_WBITS.</p> </li> <li id="*-Bufsize*">
<b><b>-Bufsize</b></b> <p>Sets the initial size for the inflation buffer. If the buffer has to be reallocated to increase the size, it will grow in increments of <code class="inline"><span class="w">Bufsize</span></code> .</p> <p>Default is 4096.</p> </li> <li id="*-Dictionary*">
<b><b>-Dictionary</b></b> <p>The default is no dictionary.</p> </li> </ul> <p>Here is an example of using the <code class="inline"><span class="w">inflateInit</span></code> optional parameter to override the default buffer size.</p> <pre class="verbatim" data-language="perl">inflateInit( -Bufsize =&gt; 300 ) ;
</pre>
<h3 id="*(%24out%2c-%24status)-%3d-%24i-%3einflate(%24buffer)*"><b>($out, $status) = $i-&gt;inflate($buffer)</b></h3> <p>Inflates the complete contents of <code class="inline"><span class="i">$buffer</span></code> . The buffer can either be a scalar or a scalar reference.</p> <p>Returns <code class="inline"><span class="w">Z_OK</span></code> if successful and <code class="inline"><span class="w">Z_STREAM_END</span></code> if the end of the compressed data has been successfully reached. If not successful, <code class="inline"><span class="i">$out</span></code> will be <i>undef</i> and <code class="inline"><span class="i">$status</span></code> will hold the <i>zlib</i> error code.</p> <p>The <code class="inline"><span class="i">$buffer</span></code> parameter is modified by <code class="inline"><span class="w">inflate</span></code> . On completion it will contain what remains of the input buffer after inflation. This means that <code class="inline"><span class="i">$buffer</span></code> will be an empty string when the return status is <code class="inline"><span class="w">Z_OK</span></code> . When the return status is <code class="inline"><span class="w">Z_STREAM_END</span></code> the <code class="inline"><span class="i">$buffer</span></code> parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</p> <p>This feature is useful when processing a file format that encapsulates a compressed data stream (e.g. gzip, zip).</p> <h3 id="*%24status-%3d-%24i-%3einflateSync(%24buffer)*"><b>$status = $i-&gt;inflateSync($buffer)</b></h3> <p>Scans <code class="inline"><span class="i">$buffer</span></code> until it reaches either a <i>full flush point</i> or the end of the buffer.</p> <p>If a <i>full flush point</i> is found, <code class="inline"><span class="w">Z_OK</span></code> is returned and <code class="inline"><span class="i">$buffer</span></code> will be have all data up to the flush point removed. This can then be passed to the <code class="inline"><span class="w">deflate</span></code> method.</p> <p>Any other return code means that a flush point was not found. If more data is available, <code class="inline"><span class="w">inflateSync</span></code> can be called repeatedly with more compressed data until the flush point is found.</p> <h3 id="*%24i-%3edict_adler()*"><b>$i-&gt;dict_adler()</b></h3> <p>Returns the adler32 value for the dictionary.</p> <h3 id="*%24i-%3emsg()*"><b>$i-&gt;msg()</b></h3> <p>Returns the last error message generated by zlib.</p> <h3 id="*%24i-%3etotal_in()*"><b>$i-&gt;total_in()</b></h3> <p>Returns the total number of bytes compressed bytes input to inflate.</p> <h3 id="*%24i-%3etotal_out()*"><b>$i-&gt;total_out()</b></h3> <p>Returns the total number of uncompressed bytes output from inflate.</p> <h3 id="Example">Example</h3> <p>Here is an example of using <code class="inline"><span class="w">inflate</span></code> .</p> <pre class="verbatim" data-language="perl">use strict ;
use warnings ;

use Compress::Zlib ;

my $x = inflateInit()
   or die "Cannot create a inflation stream\n" ;

my $input = '' ;
binmode STDIN;
binmode STDOUT;

my ($output, $status) ;
while (read(STDIN, $input, 4096))
{
    ($output, $status) = $x-&gt;inflate(\$input) ;

    print $output 
        if $status == Z_OK or $status == Z_STREAM_END ;

    last if $status != Z_OK ;
}

die "inflation failed\n"
    unless $status == Z_STREAM_END ;
</pre>
<h2 id="CHECKSUM-FUNCTIONS">CHECKSUM FUNCTIONS</h2> <p>Two functions are provided by <i>zlib</i> to calculate checksums. For the Perl interface, the order of the two parameters in both functions has been reversed. This allows both running checksums and one off calculations to be done.</p> <pre class="verbatim" data-language="perl">$crc = adler32($buffer [,$crc]) ;
$crc = crc32($buffer [,$crc]) ;
</pre>
<p>The buffer parameters can either be a scalar or a scalar reference.</p> <p>If the $crc parameters is <code class="inline"><a class="l_k" href="../functions/undef">undef</a></code>, the crc value will be reset.</p> <p>If you have built this module with zlib 1.2.3 or better, two more CRC-related functions are available.</p> <pre class="verbatim" data-language="perl">$crc = crc32_combine($crc1, $crc2, $len2);
$adler = adler32_combine($adler1, $adler2, $len2);
</pre>
<p>These functions allow checksums to be merged. Refer to the <i>zlib</i> documentation for more details.</p> <h2 id="Misc">Misc</h2> <h3 id="my-%24version-%3d-Compress%3a%3aZlib%3a%3azlib_version()%3b">my $version = Compress::Zlib::zlib_version();</h3> <p>Returns the version of the zlib library.</p> <h2 id="CONSTANTS">CONSTANTS</h2> <p>All the <i>zlib</i> constants are automatically imported when you make use of <i>Compress::Zlib</i>.</p> <h2 id="SEE-ALSO">SEE ALSO</h2> <p><a href="../io/compress/gzip">IO::Compress::Gzip</a>, <a href="../io/uncompress/gunzip">IO::Uncompress::Gunzip</a>, <a href="../io/compress/deflate">IO::Compress::Deflate</a>, <a href="../io/uncompress/inflate">IO::Uncompress::Inflate</a>, <a href="../io/compress/rawdeflate">IO::Compress::RawDeflate</a>, <a href="../io/uncompress/rawinflate">IO::Uncompress::RawInflate</a>, <a href="../io/compress/bzip2">IO::Compress::Bzip2</a>, <a href="../io/uncompress/bunzip2">IO::Uncompress::Bunzip2</a>, <a href="http://search.cpan.org/perldoc/IO::Compress::Lzma">IO::Compress::Lzma</a>, <a href="http://search.cpan.org/perldoc/IO::Uncompress::UnLzma">IO::Uncompress::UnLzma</a>, <a href="http://search.cpan.org/perldoc/IO::Compress::Xz">IO::Compress::Xz</a>, <a href="http://search.cpan.org/perldoc/IO::Uncompress::UnXz">IO::Uncompress::UnXz</a>, <a href="http://search.cpan.org/perldoc/IO::Compress::Lzop">IO::Compress::Lzop</a>, <a href="http://search.cpan.org/perldoc/IO::Uncompress::UnLzop">IO::Uncompress::UnLzop</a>, <a href="http://search.cpan.org/perldoc/IO::Compress::Lzf">IO::Compress::Lzf</a>, <a href="http://search.cpan.org/perldoc/IO::Uncompress::UnLzf">IO::Uncompress::UnLzf</a>, <a href="../io/uncompress/anyinflate">IO::Uncompress::AnyInflate</a>, <a href="../io/uncompress/anyuncompress">IO::Uncompress::AnyUncompress</a></p> <p><a href="../io/compress/faq">IO::Compress::FAQ</a></p> <p><a href="../file/globmapper">File::GlobMapper</a>, <a href="http://search.cpan.org/perldoc/Archive::Zip">Archive::Zip</a>, <a href="../archive/tar">Archive::Tar</a>, <a href="../io/zlib">IO::Zlib</a></p> <p>For RFC 1950, 1951 and 1952 see <i><a href="http://www.faqs.org/rfcs/rfc1950.html">http://www.faqs.org/rfcs/rfc1950.html</a></i>, <i><a href="http://www.faqs.org/rfcs/rfc1951.html">http://www.faqs.org/rfcs/rfc1951.html</a></i> and <i><a href="http://www.faqs.org/rfcs/rfc1952.html">http://www.faqs.org/rfcs/rfc1952.html</a></i></p> <p>The <i>zlib</i> compression library was written by Jean-loup Gailly <i>gzip@prep.ai.mit.edu</i> and Mark Adler <i>madler@alumni.caltech.edu</i>.</p> <p>The primary site for the <i>zlib</i> compression library is <i><a href="http://www.zlib.org">http://www.zlib.org</a></i>.</p> <p>The primary site for gzip is <i><a href="http://www.gzip.org">http://www.gzip.org</a></i>.</p> <h2 id="AUTHOR">AUTHOR</h2> <p>This module was written by Paul Marquess, <i>pmqs@cpan.org</i>.</p> <h2 id="MODIFICATION-HISTORY">MODIFICATION HISTORY</h2> <p>See the Changes file.</p> <h2 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h2> <p>Copyright (c) 1995-2014 Paul Marquess. All rights reserved.</p> <p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1993–2016 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.26.0/Compress/Zlib.html" class="_attribution-link">https://perldoc.perl.org/5.26.0/Compress/Zlib.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
