
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Perlrequick - Perl 5.26 - W3cubDocs</title>
  
  <meta name="description" content=" perlrequick - Perl regular expressions quick start ">
  <meta name="keywords" content="perlrequick, perl, perl~5.26">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/perl~5.26/perlrequick.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/perl~5.26.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/perl~5.26/" class="_nav-link" title="" style="margin-left:0;">Perl 5.26</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _perl">
				
				
<h1>perlrequick</h1>  <ul>
<li><a href="#NAME">NAME</a></li>
<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
<li>
<a href="#The-Guide">The Guide</a><ul>
<li><a href="#Simple-word-matching">Simple word matching</a></li>
<li><a href="#Using-character-classes">Using character classes</a></li>
<li><a href="#Matching-this-or-that">Matching this or that</a></li>
<li><a href="#Grouping-things-and-hierarchical-matching">Grouping things and hierarchical matching</a></li>
<li><a href="#Extracting-matches">Extracting matches</a></li>
<li><a href="#Matching-repetitions">Matching repetitions</a></li>
<li><a href="#More-matching">More matching</a></li>
<li><a href="#Search-and-replace">Search and replace</a></li>
<li><a href="#The-split-operator">The split operator</a></li>
<li><a href="#use-re-'strict'">use re 'strict'</a></li>
</ul>
</li>
<li><a href="#BUGS">BUGS</a></li>
<li><a href="#SEE-ALSO">SEE ALSO</a></li>
<li>
<a href="#AUTHOR-AND-COPYRIGHT">AUTHOR AND COPYRIGHT</a><ul><li><a href="#Acknowledgments">Acknowledgments</a></li></ul>
</li>
</ul>
<h2 id="NAME">NAME</h2> <p>perlrequick - Perl regular expressions quick start</p> <h2 id="DESCRIPTION">DESCRIPTION</h2> <p>This page covers the very basics of understanding, creating and using regular expressions ('regexes') in Perl.</p> <h2 id="The-Guide">The Guide</h2> <h3 id="Simple-word-matching">Simple word matching</h3> <p>The simplest regex is simply a word, or more generally, a string of characters. A regex consisting of a word matches any string that contains that word:</p> <pre class="verbatim" data-language="perl">"Hello World" =~ /World/;  # matches
</pre>
<p>In this statement, <code class="inline"><span class="w">World</span></code> is a regex and the <code class="inline"><span class="q">//</span></code> enclosing <code class="inline"><span class="q">/World/</span></code> tells Perl to search a string for a match. The operator <code class="inline">=~</code> associates the string with the regex match and produces a true value if the regex matched, or false if the regex did not match. In our case, <code class="inline"><span class="w">World</span></code> matches the second word in <code class="inline"><span class="q">"Hello World"</span></code> , so the expression is true. This idea has several variations.</p> <p>Expressions like this are useful in conditionals:</p> <pre class="verbatim" data-language="perl">print "It matches\n" if "Hello World" =~ /World/;
</pre>
<p>The sense of the match can be reversed by using <code class="inline">!~</code> operator:</p> <pre class="verbatim" data-language="perl">print "It doesn't match\n" if "Hello World" !~ /World/;
</pre>
<p>The literal string in the regex can be replaced by a variable:</p> <pre class="verbatim" data-language="perl">$greeting = "World";
print "It matches\n" if "Hello World" =~ /$greeting/;
</pre>
<p>If you're matching against <code class="inline"><span class="i">$_</span></code> , the <code class="inline"><span class="i">$_</span> =~</code> part can be omitted:</p> <pre class="verbatim" data-language="perl">$_ = "Hello World";
print "It matches\n" if /World/;
</pre>
<p>Finally, the <code class="inline"><span class="q">//</span></code> default delimiters for a match can be changed to arbitrary delimiters by putting an <code class="inline"><span class="q">'m'</span></code> out front:</p> <pre class="verbatim" data-language="perl">"Hello World" =~ m!World!;   # matches, delimited by '!'
"Hello World" =~ m{World};   # matches, note the matching '{}'
"/usr/bin/perl" =~ m"/perl"; # matches after '/usr/bin',
                             # '/' becomes an ordinary char
</pre>
<p>Regexes must match a part of the string <i>exactly</i> in order for the statement to be true:</p> <pre class="verbatim" data-language="perl">"Hello World" =~ /world/;  # doesn't match, case sensitive
"Hello World" =~ /o W/;    # matches, ' ' is an ordinary char
"Hello World" =~ /World /; # doesn't match, no ' ' at end
</pre>
<p>Perl will always match at the earliest possible point in the string:</p> <pre class="verbatim" data-language="perl">"Hello World" =~ /o/;       # matches 'o' in 'Hello'
"That hat is red" =~ /hat/; # matches 'hat' in 'That'
</pre>
<p>Not all characters can be used 'as is' in a match. Some characters, called <b>metacharacters</b>, are reserved for use in regex notation. The metacharacters are</p> <pre class="verbatim" data-language="perl">{}[]()^$.|*+?\
</pre>
<p>A metacharacter can be matched by putting a backslash before it:</p> <pre class="verbatim" data-language="perl">"2+2=4" =~ /2+2/;    # doesn't match, + is a metacharacter
"2+2=4" =~ /2\+2/;   # matches, \+ is treated like an ordinary +
'C:\WIN32' =~ /C:\\WIN/;                       # matches
"/usr/bin/perl" =~ /\/usr\/bin\/perl/;  # matches
</pre>
<p>In the last regex, the forward slash <code class="inline"><span class="q">'/'</span></code> is also backslashed, because it is used to delimit the regex.</p> <p>Non-printable ASCII characters are represented by <b>escape sequences</b>. Common examples are <code class="inline">\<span class="w">t</span></code> for a tab, <code class="inline">\<span class="w">n</span></code> for a newline, and <code class="inline">\<span class="w">r</span></code> for a carriage return. Arbitrary bytes are represented by octal escape sequences, e.g., <code class="inline">\<span class="n">033</span></code> , or hexadecimal escape sequences, e.g., <code class="inline">\<span class="w">x1B</span></code> :</p> <pre class="verbatim" data-language="perl">"1000\t2000" =~ m(0\t2)  # matches
"cat" =~ /\143\x61\x74/  # matches in ASCII, but 
                         # a weird way to spell cat
</pre>
<p>Regexes are treated mostly as double-quoted strings, so variable substitution works:</p> <pre class="verbatim" data-language="perl">$foo = 'house';
'cathouse' =~ /cat$foo/;   # matches
'housecat' =~ /${foo}cat/; # matches
</pre>
<p>With all of the regexes above, if the regex matched anywhere in the string, it was considered a match. To specify <i>where</i> it should match, we would use the <b>anchor</b> metacharacters <code class="inline">^</code> and <code class="inline"><span class="i">$</span></code> . The anchor <code class="inline">^</code> means match at the beginning of the string and the anchor <code class="inline"><span class="i">$</span></code> means match at the end of the string, or before a newline at the end of the string. Some examples:</p> <pre class="verbatim" data-language="perl">"housekeeper" =~ /keeper/;         # matches
"housekeeper" =~ /^keeper/;        # doesn't match
"housekeeper" =~ /keeper$/;        # matches
"housekeeper\n" =~ /keeper$/;      # matches
"housekeeper" =~ /^housekeeper$/;  # matches
</pre>
<h3 id="Using-character-classes">Using character classes</h3> <p>A <b>character class</b> allows a set of possible characters, rather than just a single character, to match at a particular point in a regex. Character classes are denoted by brackets <code class="inline"><span class="s">[</span>...<span class="s">]</span></code> , with the set of characters to be possibly matched inside. Here are some examples:</p> <pre class="verbatim" data-language="perl">/cat/;            # matches 'cat'
/[bcr]at/;        # matches 'bat', 'cat', or 'rat'
"abc" =~ /[cab]/; # matches 'a'
</pre>
<p>In the last statement, even though <code class="inline"><span class="q">'c'</span></code> is the first character in the class, the earliest point at which the regex can match is <code class="inline"><span class="q">'a'</span></code> .</p> <pre class="verbatim" data-language="perl">/[yY][eE][sS]/; # match 'yes' in a case-insensitive way
                # 'yes', 'Yes', 'YES', etc.
/yes/i;         # also match 'yes' in a case-insensitive way
</pre>
<p>The last example shows a match with an <code class="inline"><span class="q">'i'</span></code> <b>modifier</b>, which makes the match case-insensitive.</p> <p>Character classes also have ordinary and special characters, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are <code class="inline">-]\^$</code> and are matched using an escape:</p> <pre class="verbatim" data-language="perl">/[\]c]def/; # matches ']def' or 'cdef'
$x = 'bcr';
/[$x]at/;   # matches 'bat, 'cat', or 'rat'
/[\$x]at/;  # matches '$at' or 'xat'
/[\\$x]at/; # matches '\at', 'bat, 'cat', or 'rat'
</pre>
<p>The special character <code class="inline"><span class="q">'-'</span></code> acts as a range operator within character classes, so that the unwieldy <code class="inline">[0123456789]</code> and <code class="inline"><span class="s">[</span><span class="w">abc</span>...<span class="w">xyz</span><span class="s">]</span></code> become the svelte <code class="inline"><span class="s">[</span><span class="n">0</span>-<span class="n">9</span><span class="s">]</span></code> and <code class="inline"><span class="s">[</span><span class="w">a</span>-z<span class="s">]</span></code> :</p> <pre class="verbatim" data-language="perl">/item[0-9]/;  # matches 'item0' or ... or 'item9'
/[0-9a-fA-F]/;  # matches a hexadecimal digit
</pre>
<p>If <code class="inline"><span class="q">'-'</span></code> is the first or last character in a character class, it is treated as an ordinary character.</p> <p>The special character <code class="inline">^</code> in the first position of a character class denotes a <b>negated character class</b>, which matches any character but those in the brackets. Both <code class="inline"><span class="s">[</span>...<span class="s">]</span></code> and <code class="inline">[^...]</code> must match a character, or the match fails. Then</p> <pre class="verbatim" data-language="perl">/[^a]at/;  # doesn't match 'aat' or 'at', but matches
           # all other 'bat', 'cat, '0at', '%at', etc.
/[^0-9]/;  # matches a non-numeric character
/[a^]at/;  # matches 'aat' or '^at'; here '^' is ordinary
</pre>
<p>Perl has several abbreviations for common character classes. (These definitions are those that Perl uses in ASCII-safe mode with the <code class="inline"><span class="q">/a</span></code> modifier. Otherwise they could match many more non-ASCII Unicode characters as well. See <a href="perlrecharclass#Backslash-sequences">Backslash sequences in perlrecharclass</a> for details.)</p> <ul> <li> <p>\d is a digit and represents</p> <pre class="verbatim" data-language="perl">[0-9]
</pre>
</li> <li> <p>\s is a whitespace character and represents</p> <pre class="verbatim" data-language="perl">[\ \t\r\n\f]
</pre>
</li> <li> <p>\w is a word character (alphanumeric or _) and represents</p> <pre class="verbatim" data-language="perl">[0-9a-zA-Z_]
</pre>
</li> <li> <p>\D is a negated \d; it represents any character but a digit</p> <pre class="verbatim" data-language="perl">[^0-9]
</pre>
</li> <li> <p>\S is a negated \s; it represents any non-whitespace character</p> <pre class="verbatim" data-language="perl">[^\s]
</pre>
</li> <li> <p>\W is a negated \w; it represents any non-word character</p> <pre class="verbatim" data-language="perl">[^\w]
</pre>
</li> <li> <p>The period '.' matches any character but "\n"</p> </li> </ul> <p>The <code class="inline">\d\s\w\D\S\W</code> abbreviations can be used both inside and outside of character classes. Here are some in use:</p> <pre class="verbatim" data-language="perl">/\d\d:\d\d:\d\d/; # matches a hh:mm:ss time format
/[\d\s]/;         # matches any digit or whitespace character
/\w\W\w/;         # matches a word char, followed by a
                  # non-word char, followed by a word char
/..rt/;           # matches any two chars, followed by 'rt'
/end\./;          # matches 'end.'
/end[.]/;         # same thing, matches 'end.'
</pre>
<p>The <b>word anchor</b> <code class="inline">\<span class="w">b</span></code> matches a boundary between a word character and a non-word character <code class="inline">\<span class="w">w</span>\<span class="w">W</span></code> or <code class="inline">\<span class="w">W</span>\<span class="w">w</span></code> :</p> <pre class="verbatim" data-language="perl">$x = "Housecat catenates house and cat";
$x =~ /\bcat/;  # matches cat in 'catenates'
$x =~ /cat\b/;  # matches cat in 'housecat'
$x =~ /\bcat\b/;  # matches 'cat' at end of string
</pre>
<p>In the last example, the end of the string is considered a word boundary.</p> <p>For natural language processing (so that, for example, apostrophes are included in words), use instead <code class="inline">\<span class="i">b</span><span class="s">{</span><span class="w">wb</span><span class="s">}</span></code> </p> <pre class="verbatim" data-language="perl">"don't" =~ / .+? \b{wb} /x;  # matches the whole string
</pre>
<h3 id="Matching-this-or-that">Matching this or that</h3> <p>We can match different character strings with the <b>alternation</b> metacharacter <code class="inline"><span class="q">'|'</span></code> . To match <code class="inline"><span class="w">dog</span></code> or <code class="inline"><span class="w">cat</span></code> , we form the regex <code class="inline"><span class="w">dog</span>|<span class="w">cat</span></code> . As before, Perl will try to match the regex at the earliest possible point in the string. At each character position, Perl will first try to match the first alternative, <code class="inline"><span class="w">dog</span></code> . If <code class="inline"><span class="w">dog</span></code> doesn't match, Perl will then try the next alternative, <code class="inline"><span class="w">cat</span></code> . If <code class="inline"><span class="w">cat</span></code> doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</p> <pre class="verbatim" data-language="perl">"cats and dogs" =~ /cat|dog|bird/;  # matches "cat"
"cats and dogs" =~ /dog|cat|bird/;  # matches "cat"
</pre>
<p>Even though <code class="inline"><span class="w">dog</span></code> is the first alternative in the second regex, <code class="inline"><span class="w">cat</span></code> is able to match earlier in the string.</p> <pre class="verbatim" data-language="perl">"cats"          =~ /c|ca|cat|cats/; # matches "c"
"cats"          =~ /cats|cat|ca|c/; # matches "cats"
</pre>
<p>At a given character position, the first alternative that allows the regex match to succeed will be the one that matches. Here, all the alternatives match at the first string position, so the first matches.</p> <h3 id="Grouping-things-and-hierarchical-matching">Grouping things and hierarchical matching</h3> <p>The <b>grouping</b> metacharacters <code class="inline"><span class="s">(</span><span class="s">)</span></code> allow a part of a regex to be treated as a single unit. Parts of a regex are grouped by enclosing them in parentheses. The regex <code class="inline"><span class="i">house</span><span class="s">(</span><span class="w">cat</span>|<span class="w">keeper</span><span class="s">)</span></code> means match <code class="inline"><span class="w">house</span></code> followed by either <code class="inline"><span class="w">cat</span></code> or <code class="inline"><span class="w">keeper</span></code> . Some more examples are</p> <pre class="verbatim" data-language="perl">/(a|b)b/;    # matches 'ab' or 'bb'
/(^a|b)c/;   # matches 'ac' at start of string or 'bc' anywhere

/house(cat|)/;  # matches either 'housecat' or 'house'
/house(cat(s|)|)/;  # matches either 'housecats' or 'housecat' or
                    # 'house'.  Note groups can be nested.

"20" =~ /(19|20|)\d\d/;  # matches the null alternative '()\d\d',
                         # because '20\d\d' can't match
</pre>
<h3 id="Extracting-matches">Extracting matches</h3> <p>The grouping metacharacters <code class="inline"><span class="s">(</span><span class="s">)</span></code> also allow the extraction of the parts of a string that matched. For each grouping, the part that matched inside goes into the special variables <code class="inline"><span class="i">$1</span></code> , <code class="inline"><span class="i">$2</span></code> , etc. They can be used just as ordinary variables:</p> <pre class="verbatim" data-language="perl"># extract hours, minutes, seconds
$time =~ /(\d\d):(\d\d):(\d\d)/;  # match hh:mm:ss format
$hours = $1;
$minutes = $2;
$seconds = $3;
</pre>
<p>In list context, a match <code class="inline"><span class="q">/regex/</span></code> with groupings will return the list of matched values <code class="inline"><span class="s">(</span><span class="i">$1</span><span class="cm">,</span><span class="i">$2</span><span class="cm">,</span>...<span class="s">)</span></code> . So we could rewrite it as</p> <pre class="verbatim" data-language="perl">($hours, $minutes, $second) = ($time =~ /(\d\d):(\d\d):(\d\d)/);
</pre>
<p>If the groupings in a regex are nested, <code class="inline"><span class="i">$1</span></code> gets the group with the leftmost opening parenthesis, <code class="inline"><span class="i">$2</span></code> the next opening parenthesis, etc. For example, here is a complex regex and the matching variables indicated below it:</p> <pre class="verbatim" data-language="perl">/(ab(cd|ef)((gi)|j))/;
 1  2      34
</pre>
<p>Associated with the matching variables <code class="inline"><span class="i">$1</span></code> , <code class="inline"><span class="i">$2</span></code> , ... are the <b>backreferences</b> <code class="inline">\<span class="w">g1</span></code> , <code class="inline">\<span class="w">g2</span></code> , ... Backreferences are matching variables that can be used <i>inside</i> a regex:</p> <pre class="verbatim" data-language="perl">/(\w\w\w)\s\g1/; # find sequences like 'the the' in string
</pre>
<p><code class="inline"><span class="i">$1</span></code> , <code class="inline"><span class="i">$2</span></code> , ... should only be used outside of a regex, and <code class="inline">\<span class="w">g1</span></code> , <code class="inline">\<span class="w">g2</span></code> , ... only inside a regex.</p> <h3 id="Matching-repetitions">Matching repetitions</h3> <p>The <b>quantifier</b> metacharacters <code class="inline">?</code>, <code class="inline"><span class="i">*</span></code> , <code class="inline">+</code> , and <code class="inline"><span class="s">{</span><span class="s">}</span></code> allow us to determine the number of repeats of a portion of a regex we consider to be a match. Quantifiers are put immediately after the character, character class, or grouping that we want to specify. They have the following meanings:</p> <ul> <li> <p><code class="inline">a?</code> = match 'a' 1 or 0 times</p> </li> <li> <p><code class="inline"><span class="w">a</span>*</code> = match 'a' 0 or more times, i.e., any number of times</p> </li> <li> <p><code class="inline"><span class="w">a</span>+</code> = match 'a' 1 or more times, i.e., at least once</p> </li> <li> <p><code class="inline">a{n,m}</code> = match at least <code class="inline"><span class="w">n</span></code> times, but not more than <code class="inline"><a class="l_k" href="functions/m">m</a></code> times.</p> </li> <li> <p><code class="inline"><span class="w">a</span><span class="s">{</span><span class="w">n</span><span class="cm">,</span><span class="s">}</span></code> = match at least <code class="inline"><span class="w">n</span></code> or more times</p> </li> <li> <p><code class="inline"><span class="i">a</span><span class="s">{</span><span class="w">n</span><span class="s">}</span></code> = match exactly <code class="inline"><span class="w">n</span></code> times</p> </li> </ul> <p>Here are some examples:</p> <pre class="verbatim" data-language="perl">/[a-z]+\s+\d*/;  # match a lowercase word, at least some space, and
                 # any number of digits
/(\w+)\s+\g1/;    # match doubled words of arbitrary length
$year =~ /^\d{2,4}$/;  # make sure year is at least 2 but not more
                       # than 4 digits
$year =~ /^\d{4}$|^\d{2}$/; # better match; throw out 3 digit dates
</pre>
<p>These quantifiers will try to match as much of the string as possible, while still allowing the regex to match. So we have</p> <pre class="verbatim" data-language="perl">$x = 'the cat in the hat';
$x =~ /^(.*)(at)(.*)$/; # matches,
                        # $1 = 'the cat in the h'
                        # $2 = 'at'
                        # $3 = ''   (0 matches)
</pre>
<p>The first quantifier <code class="inline">.*</code> grabs as much of the string as possible while still having the regex match. The second quantifier <code class="inline">.*</code> has no string left to it, so it matches 0 times.</p> <h3 id="More-matching">More matching</h3> <p>There are a few more things you might want to know about matching operators. The global modifier <code class="inline"><span class="q">//g</span></code> allows the matching operator to match within a string as many times as possible. In scalar context, successive matches against a string will have <code class="inline"><span class="q">//g</span></code> jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the <code class="inline"><a class="l_k" href="functions/pos">pos()</a></code> function. For example,</p> <pre class="verbatim" data-language="perl">$x = "cat dog house"; # 3 words
while ($x =~ /(\w+)/g) {
    print "Word is $1, ends at position ", pos $x, "\n";
}
</pre>
<p>prints</p> <pre class="verbatim" data-language="perl">Word is cat, ends at position 3
Word is dog, ends at position 7
Word is house, ends at position 13
</pre>
<p>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the <code class="inline"><span class="q">//c</span></code> , as in <code class="inline"><span class="q">/regex/gc</span></code> .</p> <p>In list context, <code class="inline"><span class="q">//g</span></code> returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regex. So</p> <pre class="verbatim" data-language="perl">@words = ($x =~ /(\w+)/g);  # matches,
                            # $word[0] = 'cat'
                            # $word[1] = 'dog'
                            # $word[2] = 'house'
</pre>
<h3 id="Search-and-replace">Search and replace</h3> <p>Search and replace is performed using <code class="inline"><a class="l_k" href="functions/s">s/regex/replacement/modifiers</a></code>. The <code class="inline"><span class="w">replacement</span></code> is a Perl double-quoted string that replaces in the string whatever is matched with the <code class="inline"><span class="w">regex</span></code> . The operator <code class="inline">=~</code> is also used here to associate a string with <code class="inline"><a class="l_k" href="functions/s">s///</a></code>. If matching against <code class="inline"><span class="i">$_</span></code> , the <code class="inline"><span class="i">$_</span> =~</code> can be dropped. If there is a match, <code class="inline"><a class="l_k" href="functions/s">s///</a></code> returns the number of substitutions made; otherwise it returns false. Here are a few examples:</p> <pre class="verbatim" data-language="perl">$x = "Time to feed the cat!";
$x =~ s/cat/hacker/;   # $x contains "Time to feed the hacker!"
$y = "'quoted words'";
$y =~ s/^'(.*)'$/$1/;  # strip single quotes,
                       # $y contains "quoted words"
</pre>
<p>With the <code class="inline"><a class="l_k" href="functions/s">s///</a></code> operator, the matched variables <code class="inline"><span class="i">$1</span></code> , <code class="inline"><span class="i">$2</span></code> , etc. are immediately available for use in the replacement expression. With the global modifier, <code class="inline"><a class="l_k" href="functions/s">s///g</a></code> will search and replace all occurrences of the regex in the string:</p> <pre class="verbatim" data-language="perl">$x = "I batted 4 for 4";
$x =~ s/4/four/;   # $x contains "I batted four for 4"
$x = "I batted 4 for 4";
$x =~ s/4/four/g;  # $x contains "I batted four for four"
</pre>
<p>The non-destructive modifier <code class="inline"><a class="l_k" href="functions/s">s///r</a></code> causes the result of the substitution to be returned instead of modifying <code class="inline"><span class="i">$_</span></code> (or whatever variable the substitute was bound to with <code class="inline">=~</code> ):</p> <pre class="verbatim" data-language="perl">$x = "I like dogs.";
$y = $x =~ s/dogs/cats/r;
print "$x $y\n"; # prints "I like dogs. I like cats."

$x = "Cats are great.";
print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~
    s/Frogs/Hedgehogs/r, "\n";
# prints "Hedgehogs are great."

@foo = map { s/[a-z]/X/r } qw(a b c 1 2 3);
# @foo is now qw(X X X 1 2 3)
</pre>
<p>The evaluation modifier <code class="inline"><a class="l_k" href="functions/s">s///e</a></code> wraps an <code class="inline"><a class="l_k" href="functions/eval">eval{...}</a></code> around the replacement string and the evaluated result is substituted for the matched substring. Some examples:</p> <pre class="verbatim" data-language="perl"># reverse all the words in a string
$x = "the cat in the hat";
$x =~ s/(\w+)/reverse $1/ge;   # $x contains "eht tac ni eht tah"

# convert percentage to decimal
$x = "A 39% hit rate";
$x =~ s!(\d+)%!$1/100!e;       # $x contains "A 0.39 hit rate"
</pre>
<p>The last example shows that <code class="inline"><a class="l_k" href="functions/s">s///</a></code> can use other delimiters, such as <code class="inline"><a class="l_k" href="functions/s">s!!!</a></code> and <code class="inline"><a class="l_k" href="functions/s">s{}{}</a></code>, and even <code class="inline"><a class="l_k" href="functions/s">s{}//</a></code>. If single quotes are used <code class="inline"><a class="l_k" href="functions/s">s'''</a></code>, then the regex and replacement are treated as single-quoted strings.</p> <h3 id="The-split-operator">The split operator</h3> <p><code class="inline"><a class="l_k" href="functions/split">split</a> <span class="q">/regex/</span><span class="cm">,</span> <span class="w">string</span></code> splits <code class="inline"><span class="w">string</span></code> into a list of substrings and returns that list. The regex determines the character sequence that <code class="inline"><span class="w">string</span></code> is split with respect to. For example, to split a string into words, use</p> <pre class="verbatim" data-language="perl">$x = "Calvin and Hobbes";
@word = split /\s+/, $x;  # $word[0] = 'Calvin'
                          # $word[1] = 'and'
                          # $word[2] = 'Hobbes'
</pre>
<p>To extract a comma-delimited list of numbers, use</p> <pre class="verbatim" data-language="perl">$x = "1.618,2.718,   3.142";
@const = split /,\s*/, $x;  # $const[0] = '1.618'
                            # $const[1] = '2.718'
                            # $const[2] = '3.142'
</pre>
<p>If the empty regex <code class="inline"><span class="q">//</span></code> is used, the string is split into individual characters. If the regex has groupings, then the list produced contains the matched substrings from the groupings as well:</p> <pre class="verbatim" data-language="perl">$x = "/usr/bin";
@parts = split m!(/)!, $x;  # $parts[0] = ''
                            # $parts[1] = '/'
                            # $parts[2] = 'usr'
                            # $parts[3] = '/'
                            # $parts[4] = 'bin'
</pre>
<p>Since the first character of $x matched the regex, <code class="inline"><a class="l_k" href="functions/split">split</a></code> prepended an empty initial element to the list.</p> <h3 id="use-re-'strict'">
<code class="inline"><a class="l_k" href="functions/use">use</a> <span class="w">re</span> <span class="q">'strict'</span></code> </h3> <p>New in v5.22, this applies stricter rules than otherwise when compiling regular expression patterns. It can find things that, while legal, may not be what you intended.</p> <p>See <a href="re#'strict'-mode">'strict' in re</a>.</p> <h2 id="BUGS">BUGS</h2> <p>None.</p> <h2 id="SEE-ALSO">SEE ALSO</h2> <p>This is just a quick start guide. For a more in-depth tutorial on regexes, see <a href="perlretut">perlretut</a> and for the reference page, see <a href="perlre">perlre</a>.</p> <h2 id="AUTHOR-AND-COPYRIGHT">AUTHOR AND COPYRIGHT</h2> <p>Copyright (c) 2000 Mark Kvale All rights reserved.</p> <p>This document may be distributed under the same terms as Perl itself.</p> <h3 id="Acknowledgments">Acknowledgments</h3> <p>The author would like to thank Mark-Jason Dominus, Tom Christiansen, Ilya Zakharevich, Brad Hughes, and Mike Giroux for all their helpful comments.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1993–2016 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.26.0/perlrequick.html" class="_attribution-link">https://perldoc.perl.org/5.26.0/perlrequick.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
