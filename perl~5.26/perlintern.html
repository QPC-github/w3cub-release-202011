
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Perlintern - Perl 5.26 - W3cubDocs</title>
  
  <meta name="description" content=" perlintern - autogenerated documentation of purely internal Perl functions ">
  <meta name="keywords" content="perlintern, perl, perl~5.26">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/perl~5.26/perlintern.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/perl~5.26.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/perl~5.26/" class="_nav-link" title="" style="margin-left:0;">Perl 5.26</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _perl">
				
				
<h1>perlintern</h1>  <ul>
<li><a href="#NAME">NAME</a></li>
<li><a href="#DESCRIPTION">DESCRIPTION </a></li>
<li><a href="#Compile-time-scope-hooks">Compile-time scope hooks</a></li>
<li><a href="#Custom-Operators">Custom Operators</a></li>
<li><a href="#CV-Manipulation-Functions">CV Manipulation Functions</a></li>
<li><a href="#CV-reference-counts-and-CvOUTSIDE">CV reference counts and CvOUTSIDE</a></li>
<li><a href="#Embedding-Functions">Embedding Functions</a></li>
<li><a href="#GV-Functions">GV Functions</a></li>
<li><a href="#Hash-Manipulation-Functions">Hash Manipulation Functions</a></li>
<li><a href="#IO-Functions">IO Functions</a></li>
<li><a href="#Lexer-interface">Lexer interface</a></li>
<li><a href="#Magical-Functions">Magical Functions</a></li>
<li><a href="#Miscellaneous-Functions">Miscellaneous Functions</a></li>
<li><a href="#MRO-Functions">MRO Functions</a></li>
<li><a href="#Optree-Manipulation-Functions">Optree Manipulation Functions</a></li>
<li><a href="#Pad-Data-Structures">Pad Data Structures</a></li>
<li><a href="#Per-Interpreter-Variables">Per-Interpreter Variables</a></li>
<li><a href="#Stack-Manipulation-Macros">Stack Manipulation Macros</a></li>
<li><a href="#SV-Manipulation-Functions">SV Manipulation Functions</a></li>
<li><a href="#SV-Body-Allocation">SV-Body Allocation</a></li>
<li><a href="#Unicode-Support">Unicode Support</a></li>
<li><a href="#Undocumented-functions">Undocumented functions</a></li>
<li><a href="#AUTHORS">AUTHORS</a></li>
<li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>
<h2 id="NAME">NAME</h2> <p>perlintern - autogenerated documentation of purely <b>internal</b> Perl functions</p> <h2 id="DESCRIPTION">DESCRIPTION </h2> <p>This file is the autogenerated documentation of functions in the Perl interpreter that are documented using Perl's internal documentation format but are not marked as part of the Perl API. In other words, <b>they are not for use in extensions</b>!</p> <h2 id="Compile-time-scope-hooks">Compile-time scope hooks</h2> <ul> <li id="BhkENTRY">
<b>BhkENTRY </b> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>Return an entry from the BHK structure. <i>which</i> is a preprocessor token indicating which entry to return. If the appropriate flag is not set this will return NULL. The type of the return value depends on which entry you ask for.</p> <pre class="verbatim" data-language="perl">void *	BhkENTRY(BHK *hk, which)
</pre>
</li> <li id="BhkFLAGS">
<b>BhkFLAGS </b> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>Return the BHK's flags.</p> <pre class="verbatim" data-language="perl">U32	BhkFLAGS(BHK *hk)
</pre>
</li> <li id="CALL_BLOCK_HOOKS">
<b>CALL_BLOCK_HOOKS </b> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>Call all the registered block hooks for type <i>which</i>. <i>which</i> is a preprocessing token; the type of <i>arg</i> depends on <i>which</i>.</p> <pre class="verbatim" data-language="perl">void	CALL_BLOCK_HOOKS(which, arg)
</pre>
</li> </ul> <h2 id="Custom-Operators">Custom Operators</h2> <ul> <li id="core_prototype">
<b>core_prototype </b> <p>This function assigns the prototype of the named core function to <code class="inline"><span class="w">sv</span></code> , or to a new mortal SV if <code class="inline"><span class="w">sv</span></code> is NULL. It returns the modified <code class="inline"><span class="w">sv</span></code> , or NULL if the core function has no prototype. <code class="inline"><span class="w">code</span></code> is a code as returned by <code class="inline"><span class="i">keyword</span><span class="s">(</span><span class="s">)</span></code> . It must not be equal to 0.</p> <pre class="verbatim" data-language="perl">SV *	core_prototype(SV *sv, const char *name,
	               const int code,
	               int * const opnum)
</pre>
</li> </ul> <h2 id="CV-Manipulation-Functions">CV Manipulation Functions</h2> <ul> <li id="docatch">
<b>docatch </b> <p>Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.</p> <p>0 is used as continue inside eval,</p> <p>3 is used for a die caught by an inner eval - continue inner loop</p> <p>See cop.h: je_mustcatch, when set at any runlevel to TRUE, means eval ops must establish a local jmpenv to handle exception traps.</p> <pre class="verbatim" data-language="perl">OP*	docatch(OP *o)
</pre>
</li> </ul> <h2 id="CV-reference-counts-and-CvOUTSIDE">CV reference counts and CvOUTSIDE</h2> <ul> <li id="CvWEAKOUTSIDE">
<b>CvWEAKOUTSIDE </b> <p>Each CV has a pointer, <code class="inline"><span class="i">CvOUTSIDE</span><span class="s">(</span><span class="s">)</span></code> , to its lexically enclosing CV (if any). Because pointers to anonymous sub prototypes are stored in <code class="inline"><span class="i">&amp;</span></code> pad slots, it is a possible to get a circular reference, with the parent pointing to the child and vice-versa. To avoid the ensuing memory leak, we do not increment the reference count of the CV pointed to by <code class="inline"><span class="w">CvOUTSIDE</span></code> in the <i>one specific instance</i> that the parent has a <code class="inline"><span class="i">&amp;</span></code> pad slot pointing back to us. In this case, we set the <code class="inline"><span class="w">CvWEAKOUTSIDE</span></code> flag in the child. This allows us to determine under what circumstances we should decrement the refcount of the parent when freeing the child.</p> <p>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children, eg</p> <pre class="verbatim" data-language="perl">BEGIN { $a = sub { eval '$x' } }
</pre>
<p>In this case, the BEGIN is freed immediately after execution since there are no active references to it: the anon sub prototype has <code class="inline"><span class="w">CvWEAKOUTSIDE</span></code> set since it's not a closure, and $a points to the same CV, so it doesn't contribute to BEGIN's refcount either. When $a is executed, the <code class="inline"><a class="l_k" href="functions/eval">eval</a> <span class="q">'$x'</span></code> causes the chain of <code class="inline"><span class="w">CvOUTSIDE</span></code> s to be followed, and the freed BEGIN is accessed.</p> <p>To avoid this, whenever a CV and its associated pad is freed, any <code class="inline"><span class="i">&amp;</span></code> entries in the pad are explicitly removed from the pad, and if the refcount of the pointed-to anon sub is still positive, then that child's <code class="inline"><span class="w">CvOUTSIDE</span></code> is set to point to its grandparent. This will only occur in the single specific case of a non-closure anon prototype having one or more active references (such as <code class="inline"><span class="i">$a</span></code> above).</p> <p>One other thing to consider is that a CV may be merely undefined rather than freed, eg <code class="inline"><a class="l_k" href="functions/undef">undef</a> <span class="i">&amp;foo</span></code> . In this case, its refcount may not have reached zero, but we still delete its pad and its <code class="inline"><span class="w">CvROOT</span></code> etc. Since various children may still have their <code class="inline"><span class="w">CvOUTSIDE</span></code> pointing at this undefined CV, we keep its own <code class="inline"><span class="w">CvOUTSIDE</span></code> for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</p> <pre class="verbatim" data-language="perl">    my $x = 123;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &amp;tmp;
    print  $a-&gt;();

bool	CvWEAKOUTSIDE(CV *cv)
</pre>
</li> </ul> <h2 id="Embedding-Functions">Embedding Functions</h2> <ul> <li id="cv_dump">
<b>cv_dump </b> <p>dump the contents of a CV</p> <pre class="verbatim" data-language="perl">void	cv_dump(CV *cv, const char *title)
</pre>
</li> <li id="cv_forget_slab">
<b>cv_forget_slab </b> <p>When a CV has a reference count on its slab (CvSLABBED), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and CvROOT attached, it has finished its job, so it can forget the slab.</p> <pre class="verbatim" data-language="perl">void	cv_forget_slab(CV *cv)
</pre>
</li> <li id="do_dump_pad">
<b>do_dump_pad </b> <p>Dump the contents of a padlist</p> <pre class="verbatim" data-language="perl">void	do_dump_pad(I32 level, PerlIO *file,
	            PADLIST *padlist, int full)
</pre>
</li> <li id="padlist_dup">
<b>padlist_dup </b> <p>Duplicates a pad.</p> <pre class="verbatim" data-language="perl">PADLIST * padlist_dup(PADLIST *srcpad,
                      CLONE_PARAMS *param)
</pre>
</li> <li id="padnamelist_dup">
<b>padnamelist_dup </b> <p>Duplicates a pad name list.</p> <pre class="verbatim" data-language="perl">PADNAMELIST * padnamelist_dup(PADNAMELIST *srcpad,
                              CLONE_PARAMS *param)
</pre>
</li> <li id="padname_dup">
<b>padname_dup </b> <p>Duplicates a pad name.</p> <pre class="verbatim" data-language="perl">PADNAME * padname_dup(PADNAME *src, CLONE_PARAMS *param)
</pre>
</li> <li id="pad_alloc_name">
<b>pad_alloc_name </b> <p>Allocates a place in the currently-compiling pad (via <a href="perlapi#pad_alloc">pad_alloc in perlapi</a>) and then stores a name for that entry. <i>name</i> is adopted and becomes the name entry; it must already contain the name string. <i>typestash</i> and <i>ourstash</i> and the <code class="inline"><span class="w">padadd_STATE</span></code> flag get added to <i>name</i>. None of the other processing of <a href="perlapi#pad_add_name_pvn">pad_add_name_pvn in perlapi</a> is done. Returns the offset of the allocated pad slot.</p> <pre class="verbatim" data-language="perl">PADOFFSET pad_alloc_name(PADNAME *name, U32 flags,
                         HV *typestash, HV *ourstash)
</pre>
</li> <li id="pad_block_start">
<b>pad_block_start </b> <p>Update the pad compilation state variables on entry to a new block.</p> <pre class="verbatim" data-language="perl">void	pad_block_start(int full)
</pre>
</li> <li id="pad_check_dup">
<b>pad_check_dup </b> <p>Check for duplicate declarations: report any of:</p> <pre class="verbatim" data-language="perl">* a my in the current scope with the same name;
* an our (anywhere in the pad) with the same name and the
  same stash as C&lt;ourstash&gt;
</pre>
<p><code class="inline"><span class="w">is_our</span></code> indicates that the name to check is an 'our' declaration.</p> <pre class="verbatim" data-language="perl">void	pad_check_dup(PADNAME *name, U32 flags,
	              const HV *ourstash)
</pre>
</li> <li id="pad_findlex">
<b>pad_findlex </b> <p>Find a named lexical anywhere in a chain of nested pads. Add fake entries in the inner pads if it's found in an outer one.</p> <p>Returns the offset in the bottom pad of the lex or the fake lex. cv is the CV in which to start the search, and seq is the current cop_seq to match against. If warn is true, print appropriate warnings. The out_* vars return values, and so are pointers to where the returned values should be stored. out_capture, if non-null, requests that the innermost instance of the lexical is captured; out_name is set to the innermost matched pad name or fake pad name; out_flags returns the flags normally associated with the PARENT_FAKELEX_FLAGS field of a fake pad name.</p> <p>Note that pad_findlex() is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in xlow the index into the parent pad.</p> <pre class="verbatim" data-language="perl">PADOFFSET pad_findlex(const char *namepv,
                      STRLEN namelen, U32 flags,
                      const CV* cv, U32 seq, int warn,
                      SV** out_capture,
                      PADNAME** out_name,
                      int *out_flags)
</pre>
</li> <li id="pad_fixup_inner_anons">
<b>pad_fixup_inner_anons </b> <p>For any anon CVs in the pad, change CvOUTSIDE of that CV from old_cv to new_cv if necessary. Needed when a newly-compiled CV has to be moved to a pre-existing CV struct.</p> <pre class="verbatim" data-language="perl">void	pad_fixup_inner_anons(PADLIST *padlist,
	                      CV *old_cv, CV *new_cv)
</pre>
</li> <li id="pad_free">
<b>pad_free </b> <p>Free the SV at offset po in the current pad.</p> <pre class="verbatim" data-language="perl">void	pad_free(PADOFFSET po)
</pre>
</li> <li id="pad_leavemy">
<b>pad_leavemy </b> <p>Cleanup at end of scope during compilation: set the max seq number for lexicals in this scope and warn of any lexicals that never got introduced.</p> <pre class="verbatim" data-language="perl">void	pad_leavemy()
</pre>
</li> <li id="pad_push">
<b>pad_push </b> <p>Push a new pad frame onto the padlist, unless there's already a pad at this depth, in which case don't bother creating a new one. Then give the new pad an @_ in slot zero.</p> <pre class="verbatim" data-language="perl">void	pad_push(PADLIST *padlist, int depth)
</pre>
</li> <li id="pad_reset">
<b>pad_reset </b> <p>Mark all the current temporaries for reuse</p> <pre class="verbatim" data-language="perl">void	pad_reset()
</pre>
</li> <li id="pad_swipe">
<b>pad_swipe </b> <p>Abandon the tmp in the current pad at offset po and replace with a new one.</p> <pre class="verbatim" data-language="perl">void	pad_swipe(PADOFFSET po, bool refadjust)
</pre>
</li> </ul> <h2 id="GV-Functions">GV Functions</h2> <ul> <li id="gv_try_downgrade">
<b>gv_try_downgrade </b> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>If the typeglob <code class="inline"><span class="w">gv</span></code> can be expressed more succinctly, by having something other than a real GV in its place in the stash, replace it with the optimised form. Basic requirements for this are that <code class="inline"><span class="w">gv</span></code> is a real typeglob, is sufficiently ordinary, and is only referenced from its package. This function is meant to be used when a GV has been looked up in part to see what was there, causing upgrading, but based on what was found it turns out that the real GV isn't required after all.</p> <p>If <code class="inline"><span class="w">gv</span></code> is a completely empty typeglob, it is deleted from the stash.</p> <p>If <code class="inline"><span class="w">gv</span></code> is a typeglob containing only a sufficiently-ordinary constant sub, the typeglob is replaced with a scalar-reference placeholder that more compactly represents the same thing.</p> <pre class="verbatim" data-language="perl">void	gv_try_downgrade(GV* gv)
</pre>
</li> </ul> <h2 id="Hash-Manipulation-Functions">Hash Manipulation Functions</h2> <ul> <li id="hv_ename_add">
<b>hv_ename_add </b> <p>Adds a name to a stash's internal list of effective names. See <code class="inline"><span class="w">hv_ename_delete</span></code> .</p> <p>This is called when a stash is assigned to a new location in the symbol table.</p> <pre class="verbatim" data-language="perl">void	hv_ename_add(HV *hv, const char *name, U32 len,
	             U32 flags)
</pre>
</li> <li id="hv_ename_delete">
<b>hv_ename_delete </b> <p>Removes a name from a stash's internal list of effective names. If this is the name returned by <code class="inline"><span class="w">HvENAME</span></code> , then another name in the list will take its place (<code class="inline"><span class="w">HvENAME</span></code> will use it).</p> <p>This is called when a stash is deleted from the symbol table.</p> <pre class="verbatim" data-language="perl">void	hv_ename_delete(HV *hv, const char *name,
	                U32 len, U32 flags)
</pre>
</li> <li id="refcounted_he_chain_2hv">
<b>refcounted_he_chain_2hv </b> <p>Generates and returns a <code class="inline"><span class="w">HV</span> *</code> representing the content of a <code class="inline"><span class="w">refcounted_he</span></code> chain. <i>flags</i> is currently unused and must be zero.</p> <pre class="verbatim" data-language="perl">HV *	refcounted_he_chain_2hv(
	    const struct refcounted_he *c, U32 flags
	)
</pre>
</li> <li id="refcounted_he_fetch_pv">
<b>refcounted_he_fetch_pv </b> <p>Like <a href="#refcounted_he_fetch_pvn">refcounted_he_fetch_pvn</a>, but takes a nul-terminated string instead of a string/length pair.</p> <pre class="verbatim" data-language="perl">SV *	refcounted_he_fetch_pv(
	    const struct refcounted_he *chain,
	    const char *key, U32 hash, U32 flags
	)
</pre>
</li> <li id="refcounted_he_fetch_pvn">
<b>refcounted_he_fetch_pvn </b> <p>Search along a <code class="inline"><span class="w">refcounted_he</span></code> chain for an entry with the key specified by <i>keypv</i> and <i>keylen</i>. If <i>flags</i> has the <code class="inline"><span class="w">REFCOUNTED_HE_KEY_UTF8</span></code> bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. <i>hash</i> is a precomputed hash of the key string, or zero if it has not been precomputed. Returns a mortal scalar representing the value associated with the key, or <code class="inline"><span class="i">&amp;PL_sv_placeholder</span></code> if there is no value associated with the key.</p> <pre class="verbatim" data-language="perl">SV *	refcounted_he_fetch_pvn(
	    const struct refcounted_he *chain,
	    const char *keypv, STRLEN keylen, U32 hash,
	    U32 flags
	)
</pre>
</li> <li id="refcounted_he_fetch_pvs">
<b>refcounted_he_fetch_pvs </b> <p>Like <a href="#refcounted_he_fetch_pvn">refcounted_he_fetch_pvn</a>, but takes a literal string instead of a string/length pair, and no precomputed hash.</p> <pre class="verbatim" data-language="perl">SV *	refcounted_he_fetch_pvs(
	    const struct refcounted_he *chain,
	    const char *key, U32 flags
	)
</pre>
</li> <li id="refcounted_he_fetch_sv">
<b>refcounted_he_fetch_sv </b> <p>Like <a href="#refcounted_he_fetch_pvn">refcounted_he_fetch_pvn</a>, but takes a Perl scalar instead of a string/length pair.</p> <pre class="verbatim" data-language="perl">SV *	refcounted_he_fetch_sv(
	    const struct refcounted_he *chain, SV *key,
	    U32 hash, U32 flags
	)
</pre>
</li> <li id="refcounted_he_free">
<b>refcounted_he_free </b> <p>Decrements the reference count of a <code class="inline"><span class="w">refcounted_he</span></code> by one. If the reference count reaches zero the structure's memory is freed, which (recursively) causes a reduction of its parent <code class="inline"><span class="w">refcounted_he</span></code> 's reference count. It is safe to pass a null pointer to this function: no action occurs in this case.</p> <pre class="verbatim" data-language="perl">void	refcounted_he_free(struct refcounted_he *he)
</pre>
</li> <li id="refcounted_he_inc">
<b>refcounted_he_inc </b> <p>Increment the reference count of a <code class="inline"><span class="w">refcounted_he</span></code> . The pointer to the <code class="inline"><span class="w">refcounted_he</span></code> is also returned. It is safe to pass a null pointer to this function: no action occurs and a null pointer is returned.</p> <pre class="verbatim" data-language="perl">struct refcounted_he * refcounted_he_inc(
                           struct refcounted_he *he
                       )
</pre>
</li> <li id="refcounted_he_new_pv">
<b>refcounted_he_new_pv </b> <p>Like <a href="#refcounted_he_new_pvn">refcounted_he_new_pvn</a>, but takes a nul-terminated string instead of a string/length pair.</p> <pre class="verbatim" data-language="perl">struct refcounted_he * refcounted_he_new_pv(
                           struct refcounted_he *parent,
                           const char *key, U32 hash,
                           SV *value, U32 flags
                       )
</pre>
</li> <li id="refcounted_he_new_pvn">
<b>refcounted_he_new_pvn </b> <p>Creates a new <code class="inline"><span class="w">refcounted_he</span></code> . This consists of a single key/value pair and a reference to an existing <code class="inline"><span class="w">refcounted_he</span></code> chain (which may be empty), and thus forms a longer chain. When using the longer chain, the new key/value pair takes precedence over any entry for the same key further along the chain.</p> <p>The new key is specified by <i>keypv</i> and <i>keylen</i>. If <i>flags</i> has the <code class="inline"><span class="w">REFCOUNTED_HE_KEY_UTF8</span></code> bit set, the key octets are interpreted as UTF-8, otherwise they are interpreted as Latin-1. <i>hash</i> is a precomputed hash of the key string, or zero if it has not been precomputed.</p> <p><i>value</i> is the scalar value to store for this key. <i>value</i> is copied by this function, which thus does not take ownership of any reference to it, and later changes to the scalar will not be reflected in the value visible in the <code class="inline"><span class="w">refcounted_he</span></code> . Complex types of scalar will not be stored with referential integrity, but will be coerced to strings. <i>value</i> may be either null or <code class="inline"><span class="i">&amp;PL_sv_placeholder</span></code> to indicate that no value is to be associated with the key; this, as with any non-null value, takes precedence over the existence of a value for the key further along the chain.</p> <p><i>parent</i> points to the rest of the <code class="inline"><span class="w">refcounted_he</span></code> chain to be attached to the new <code class="inline"><span class="w">refcounted_he</span></code> . This function takes ownership of one reference to <i>parent</i>, and returns one reference to the new <code class="inline"><span class="w">refcounted_he</span></code> .</p> <pre class="verbatim" data-language="perl">struct refcounted_he * refcounted_he_new_pvn(
                           struct refcounted_he *parent,
                           const char *keypv,
                           STRLEN keylen, U32 hash,
                           SV *value, U32 flags
                       )
</pre>
</li> <li id="refcounted_he_new_pvs">
<b>refcounted_he_new_pvs </b> <p>Like <a href="#refcounted_he_new_pvn">refcounted_he_new_pvn</a>, but takes a literal string instead of a string/length pair, and no precomputed hash.</p> <pre class="verbatim" data-language="perl">struct refcounted_he * refcounted_he_new_pvs(
                           struct refcounted_he *parent,
                           const char *key, SV *value,
                           U32 flags
                       )
</pre>
</li> <li id="refcounted_he_new_sv">
<b>refcounted_he_new_sv </b> <p>Like <a href="#refcounted_he_new_pvn">refcounted_he_new_pvn</a>, but takes a Perl scalar instead of a string/length pair.</p> <pre class="verbatim" data-language="perl">struct refcounted_he * refcounted_he_new_sv(
                           struct refcounted_he *parent,
                           SV *key, U32 hash, SV *value,
                           U32 flags
                       )
</pre>
</li> </ul> <h2 id="IO-Functions">IO Functions</h2> <ul> <li id="start_glob">
<b>start_glob </b> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>Function called by <code class="inline"><span class="w">do_readline</span></code> to spawn a glob (or do the glob inside perl on VMS). This code used to be inline, but now perl uses <code class="inline"><span class="w">File::Glob</span></code> this glob starter is only used by miniperl during the build process. Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl up.</p> <pre class="verbatim" data-language="perl">PerlIO*	start_glob(SV *tmpglob, IO *io)
</pre>
</li> </ul> <h2 id="Lexer-interface">Lexer interface</h2> <ul> <li id="validate_proto">
<b>validate_proto </b> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>This function performs syntax checking on a prototype, <code class="inline"><span class="w">proto</span></code> . If <code class="inline"><a class="l_k" href="functions/warn">warn</a></code> is true, any illegal characters or mismatched brackets will trigger illegalproto warnings, declaring that they were detected in the prototype for <code class="inline"><span class="w">name</span></code> .</p> <p>The return value is <code class="inline"><span class="w">true</span></code> if this is a valid prototype, and <code class="inline"><span class="w">false</span></code> if it is not, regardless of whether <code class="inline"><a class="l_k" href="functions/warn">warn</a></code> was <code class="inline"><span class="w">true</span></code> or <code class="inline"><span class="w">false</span></code> .</p> <p>Note that <code class="inline"><span class="w">NULL</span></code> is a valid <code class="inline"><span class="w">proto</span></code> and will always return <code class="inline"><span class="w">true</span></code> .</p> <p>NOTE: the perl_ form of this function is deprecated.</p> <pre class="verbatim" data-language="perl">bool	validate_proto(SV *name, SV *proto, bool warn)
</pre>
</li> </ul> <h2 id="Magical-Functions">Magical Functions</h2> <ul> <li id="magic_clearhint">
<b>magic_clearhint </b> <p>Triggered by a delete from %^H, records the key to <code class="inline"><span class="w">PL_compiling</span>.<span class="w">cop_hints_hash</span></code> .</p> <pre class="verbatim" data-language="perl">int	magic_clearhint(SV* sv, MAGIC* mg)
</pre>
</li> <li id="magic_clearhints">
<b>magic_clearhints </b> <p>Triggered by clearing %^H, resets <code class="inline"><span class="w">PL_compiling</span>.<span class="w">cop_hints_hash</span></code> .</p> <pre class="verbatim" data-language="perl">int	magic_clearhints(SV* sv, MAGIC* mg)
</pre>
</li> <li id="magic_methcall">
<b>magic_methcall </b> <p>Invoke a magic method (like FETCH).</p> <p><code class="inline"><span class="w">sv</span></code> and <code class="inline"><span class="w">mg</span></code> are the tied thingy and the tie magic.</p> <p><code class="inline"><span class="w">meth</span></code> is the name of the method to call.</p> <p><code class="inline"><span class="w">argc</span></code> is the number of args (in addition to $self) to pass to the method.</p> <p>The <code class="inline"><span class="w">flags</span></code> can be:</p> <pre class="verbatim" data-language="perl">G_DISCARD     invoke method with G_DISCARD flag and don't
              return a value
G_UNDEF_FILL  fill the stack with argc pointers to
              PL_sv_undef
</pre>
<p>The arguments themselves are any values following the <code class="inline"><span class="w">flags</span></code> argument.</p> <p>Returns the SV (if any) returned by the method, or NULL on failure.</p> <pre class="verbatim" data-language="perl">SV*	magic_methcall(SV *sv, const MAGIC *mg,
	               SV *meth, U32 flags, U32 argc,
	               ...)
</pre>
</li> <li id="magic_sethint">
<b>magic_sethint </b> <p>Triggered by a store to %^H, records the key/value pair to <code class="inline"><span class="w">PL_compiling</span>.<span class="w">cop_hints_hash</span></code> . It is assumed that hints aren't storing anything that would need a deep copy. Maybe we should warn if we find a reference.</p> <pre class="verbatim" data-language="perl">int	magic_sethint(SV* sv, MAGIC* mg)
</pre>
</li> <li id="mg_localize">
<b>mg_localize </b> <p>Copy some of the magic from an existing SV to new localized version of that SV. Container magic (eg %ENV, $1, tie) gets copied, value magic doesn't (eg taint, pos).</p> <p>If setmagic is false then no set magic will be called on the new (empty) SV. This typically means that assignment will soon follow (e.g. 'local $x = $y'), and that will handle the magic.</p> <pre class="verbatim" data-language="perl">void	mg_localize(SV* sv, SV* nsv, bool setmagic)
</pre>
</li> </ul> <h2 id="Miscellaneous-Functions">Miscellaneous Functions</h2> <ul> <li id="free_c_backtrace">
<b>free_c_backtrace </b> <p>Deallocates a backtrace received from get_c_bracktrace.</p> <pre class="verbatim" data-language="perl">void	free_c_backtrace(Perl_c_backtrace* bt)
</pre>
</li> <li id="get_c_backtrace">
<b>get_c_backtrace </b> <p>Collects the backtrace (aka "stacktrace") into a single linear malloced buffer, which the caller <b>must</b> Perl_free_c_backtrace().</p> <p>Scans the frames back by depth + skip, then drops the skip innermost, returning at most depth frames.</p> <pre class="verbatim" data-language="perl">Perl_c_backtrace* get_c_backtrace(int max_depth,
                                  int skip)
</pre>
</li> </ul> <h2 id="MRO-Functions">MRO Functions</h2> <ul> <li id="mro_get_linear_isa_dfs">
<b>mro_get_linear_isa_dfs </b> <p>Returns the Depth-First Search linearization of @ISA the given stash. The return value is a read-only AV*. <code class="inline"><span class="w">level</span></code> should be 0 (it is used internally in this function's recursion).</p> <p>You are responsible for <code class="inline"><span class="i">SvREFCNT_inc</span><span class="s">(</span><span class="s">)</span></code> on the return value if you plan to store it anywhere semi-permanently (otherwise it might be deleted out from under you the next time the cache is invalidated).</p> <pre class="verbatim" data-language="perl">AV*	mro_get_linear_isa_dfs(HV* stash, U32 level)
</pre>
</li> <li id="mro_isa_changed_in">
<b>mro_isa_changed_in </b> <p>Takes the necessary steps (cache invalidations, mostly) when the @ISA of the given package has changed. Invoked by the <code class="inline"><span class="w">setisa</span></code> magic, should not need to invoke directly.</p> <pre class="verbatim" data-language="perl">void	mro_isa_changed_in(HV* stash)
</pre>
</li> <li id="mro_package_moved">
<b>mro_package_moved </b> <p>Call this function to signal to a stash that it has been assigned to another spot in the stash hierarchy. <code class="inline"><span class="w">stash</span></code> is the stash that has been assigned. <code class="inline"><span class="w">oldstash</span></code> is the stash it replaces, if any. <code class="inline"><span class="w">gv</span></code> is the glob that is actually being assigned to.</p> <p>This can also be called with a null first argument to indicate that <code class="inline"><span class="w">oldstash</span></code> has been deleted.</p> <p>This function invalidates isa caches on the old stash, on all subpackages nested inside it, and on the subclasses of all those, including non-existent packages that have corresponding entries in <code class="inline"><span class="w">stash</span></code> .</p> <p>It also sets the effective names (<code class="inline"><span class="w">HvENAME</span></code> ) on all the stashes as appropriate.</p> <p>If the <code class="inline"><span class="w">gv</span></code> is present and is not in the symbol table, then this function simply returns. This checked will be skipped if <code class="inline"><span class="w">flags</span> <span class="i">&amp; 1</span></code> .</p> <pre class="verbatim" data-language="perl">void	mro_package_moved(HV * const stash,
	                  HV * const oldstash,
	                  const GV * const gv,
	                  U32 flags)
</pre>
</li> </ul> <h2 id="Optree-Manipulation-Functions">Optree Manipulation Functions</h2> <ul> <li id="finalize_optree">
<b>finalize_optree </b> <p>This function finalizes the optree. Should be called directly after the complete optree is built. It does some additional checking which can't be done in the normal ck_xxx functions and makes the tree thread-safe.</p> <pre class="verbatim" data-language="perl">void	finalize_optree(OP* o)
</pre>
</li> </ul> <h2 id="Pad-Data-Structures">Pad Data Structures</h2> <ul> <li id="CX_CURPAD_SAVE">
<b>CX_CURPAD_SAVE </b> <p>Save the current pad in the given context block structure.</p> <pre class="verbatim" data-language="perl">void	CX_CURPAD_SAVE(struct context)
</pre>
</li> <li id="CX_CURPAD_SV">
<b>CX_CURPAD_SV </b> <p>Access the SV at offset po in the saved current pad in the given context block structure (can be used as an lvalue).</p> <pre class="verbatim" data-language="perl">SV *	CX_CURPAD_SV(struct context, PADOFFSET po)
</pre>
</li> <li id="PadnameIsOUR">
<b>PadnameIsOUR </b> <p>Whether this is an "our" variable.</p> <pre class="verbatim" data-language="perl">bool	PadnameIsOUR(PADNAME pn)
</pre>
</li> <li id="PadnameIsSTATE">
<b>PadnameIsSTATE </b> <p>Whether this is a "state" variable.</p> <pre class="verbatim" data-language="perl">bool	PadnameIsSTATE(PADNAME pn)
</pre>
</li> <li id="PadnameOURSTASH">
<b>PadnameOURSTASH </b> <p>The stash in which this "our" variable was declared.</p> <pre class="verbatim" data-language="perl">HV *	PadnameOURSTASH()
</pre>
</li> <li id="PadnameOUTER">
<b>PadnameOUTER </b> <p>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as 'fake'.</p> <pre class="verbatim" data-language="perl">bool	PadnameOUTER(PADNAME pn)
</pre>
</li> <li id="PadnameTYPE">
<b>PadnameTYPE </b> <p>The stash associated with a typed lexical. This returns the %Foo:: hash for <code class="inline"><a class="l_k" href="functions/my">my</a> <span class="w">Foo</span> <span class="i">$bar</span></code> .</p> <pre class="verbatim" data-language="perl">HV *	PadnameTYPE(PADNAME pn)
</pre>
</li> <li id="PAD_BASE_SV">
<b>PAD_BASE_SV </b> <p>Get the value from slot <code class="inline"><span class="w">po</span></code> in the base (DEPTH=1) pad of a padlist</p> <pre class="verbatim" data-language="perl">SV *	PAD_BASE_SV(PADLIST padlist, PADOFFSET po)
</pre>
</li> <li id="PAD_CLONE_VARS">
<b>PAD_CLONE_VARS </b> <p>Clone the state variables associated with running and compiling pads.</p> <pre class="verbatim" data-language="perl">void	PAD_CLONE_VARS(PerlInterpreter *proto_perl,
	               CLONE_PARAMS* param)
</pre>
</li> <li id="PAD_COMPNAME_FLAGS">
<b>PAD_COMPNAME_FLAGS </b> <p>Return the flags for the current compiling pad name at offset <code class="inline"><span class="w">po</span></code> . Assumes a valid slot entry.</p> <pre class="verbatim" data-language="perl">U32	PAD_COMPNAME_FLAGS(PADOFFSET po)
</pre>
</li> <li id="PAD_COMPNAME_GEN">
<b>PAD_COMPNAME_GEN </b> <p>The generation number of the name at offset <code class="inline"><span class="w">po</span></code> in the current compiling pad (lvalue). Note that <code class="inline"><span class="w">SvUVX</span></code> is hijacked for this purpose.</p> <pre class="verbatim" data-language="perl">STRLEN	PAD_COMPNAME_GEN(PADOFFSET po)
</pre>
</li> <li id="PAD_COMPNAME_GEN_set">
<b>PAD_COMPNAME_GEN_set </b> <p>Sets the generation number of the name at offset <code class="inline"><span class="w">po</span></code> in the current ling pad (lvalue) to <code class="inline"><span class="w">gen</span></code> . Note that <code class="inline"><span class="w">SvUV_set</span></code> is hijacked for this purpose.</p> <pre class="verbatim" data-language="perl">STRLEN	PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)
</pre>
</li> <li id="PAD_COMPNAME_OURSTASH">
<b>PAD_COMPNAME_OURSTASH </b> <p>Return the stash associated with an <code class="inline"><a class="l_k" href="functions/our">our</a></code> variable. Assumes the slot entry is a valid <code class="inline"><a class="l_k" href="functions/our">our</a></code> lexical.</p> <pre class="verbatim" data-language="perl">HV *	PAD_COMPNAME_OURSTASH(PADOFFSET po)
</pre>
</li> <li id="PAD_COMPNAME_PV">
<b>PAD_COMPNAME_PV </b> <p>Return the name of the current compiling pad name at offset <code class="inline"><span class="w">po</span></code> . Assumes a valid slot entry.</p> <pre class="verbatim" data-language="perl">char *	PAD_COMPNAME_PV(PADOFFSET po)
</pre>
</li> <li id="PAD_COMPNAME_TYPE">
<b>PAD_COMPNAME_TYPE </b> <p>Return the type (stash) of the current compiling pad name at offset <code class="inline"><span class="w">po</span></code> . Must be a valid name. Returns null if not typed.</p> <pre class="verbatim" data-language="perl">HV *	PAD_COMPNAME_TYPE(PADOFFSET po)
</pre>
</li> <li id="PAD_RESTORE_LOCAL">
<b>PAD_RESTORE_LOCAL </b> <p>Restore the old pad saved into the local variable opad by PAD_SAVE_LOCAL()</p> <pre class="verbatim" data-language="perl">void	PAD_RESTORE_LOCAL(PAD *opad)
</pre>
</li> <li id="PAD_SAVE_LOCAL">
<b>PAD_SAVE_LOCAL </b> <p>Save the current pad to the local variable opad, then make the current pad equal to npad</p> <pre class="verbatim" data-language="perl">void	PAD_SAVE_LOCAL(PAD *opad, PAD *npad)
</pre>
</li> <li id="PAD_SAVE_SETNULLPAD">
<b>PAD_SAVE_SETNULLPAD </b> <p>Save the current pad then set it to null.</p> <pre class="verbatim" data-language="perl">void	PAD_SAVE_SETNULLPAD()
</pre>
</li> <li id="PAD_SETSV">
<b>PAD_SETSV </b> <p>Set the slot at offset <code class="inline"><span class="w">po</span></code> in the current pad to <code class="inline"><span class="w">sv</span></code> </p> <pre class="verbatim" data-language="perl">SV *	PAD_SETSV(PADOFFSET po, SV* sv)
</pre>
</li> <li id="PAD_SET_CUR">
<b>PAD_SET_CUR </b> <p>Set the current pad to be pad <code class="inline"><span class="w">n</span></code> in the padlist, saving the previous current pad. NB currently this macro expands to a string too long for some compilers, so it's best to replace it with</p> <pre class="verbatim" data-language="perl">    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(padlist,n);


void	PAD_SET_CUR(PADLIST padlist, I32 n)
</pre>
</li> <li id="PAD_SET_CUR_NOSAVE">
<b>PAD_SET_CUR_NOSAVE </b> <p>like PAD_SET_CUR, but without the save</p> <pre class="verbatim" data-language="perl">void	PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)
</pre>
</li> <li id="PAD_SV">
<b>PAD_SV </b> <p>Get the value at offset <code class="inline"><span class="w">po</span></code> in the current pad</p> <pre class="verbatim" data-language="perl">SV *	PAD_SV(PADOFFSET po)
</pre>
</li> <li id="PAD_SVl">
<b>PAD_SVl </b> <p>Lightweight and lvalue version of <code class="inline"><span class="w">PAD_SV</span></code> . Get or set the value at offset <code class="inline"><span class="w">po</span></code> in the current pad. Unlike <code class="inline"><span class="w">PAD_SV</span></code> , does not print diagnostics with -DX. For internal use only.</p> <pre class="verbatim" data-language="perl">SV *	PAD_SVl(PADOFFSET po)
</pre>
</li> <li id="SAVECLEARSV">
<b>SAVECLEARSV </b> <p>Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')</p> <pre class="verbatim" data-language="perl">void	SAVECLEARSV(SV **svp)
</pre>
</li> <li id="SAVECOMPPAD">
<b>SAVECOMPPAD </b> <p>save PL_comppad and PL_curpad</p> <pre class="verbatim" data-language="perl">void	SAVECOMPPAD()
</pre>
</li> <li id="SAVEPADSV">
<b>SAVEPADSV </b> <p>Save a pad slot (used to restore after an iteration)</p> <p>XXX DAPM it would make more sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET po)</p> </li> </ul> <h2 id="Per-Interpreter-Variables">Per-Interpreter Variables</h2> <ul> <li id="PL_DBsingle">
<b>PL_DBsingle </b> <p>When Perl is run in debugging mode, with the <b>-d</b> switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See <code class="inline"><span class="w">PL_DBsub</span></code> .</p> <pre class="verbatim" data-language="perl">SV *	PL_DBsingle
</pre>
</li> <li id="PL_DBsub">
<b>PL_DBsub </b> <p>When Perl is run in debugging mode, with the <b>-d</b> switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See <code class="inline"><span class="w">PL_DBsingle</span></code> .</p> <pre class="verbatim" data-language="perl">GV *	PL_DBsub
</pre>
</li> <li id="PL_DBtrace">
<b>PL_DBtrace </b> <p>Trace variable used when Perl is run in debugging mode, with the <b>-d</b> switch. This is the C variable which corresponds to Perl's $DB::trace variable. See <code class="inline"><span class="w">PL_DBsingle</span></code> .</p> <pre class="verbatim" data-language="perl">SV *	PL_DBtrace
</pre>
</li> <li id="PL_dowarn">
<b>PL_dowarn </b> <p>The C variable which corresponds to Perl's $^W warning variable.</p> <pre class="verbatim" data-language="perl">bool	PL_dowarn
</pre>
</li> <li id="PL_last_in_gv">
<b>PL_last_in_gv </b> <p>The GV which was last used for a filehandle input operation. (<code class="inline"><span class="q">&lt;FH&gt;</span></code> )</p> <pre class="verbatim" data-language="perl">GV*	PL_last_in_gv
</pre>
</li> <li id="PL_ofsgv">
<b>PL_ofsgv </b> <p>The glob containing the output field separator - <code class="inline"><span class="i">*,</span></code> in Perl space.</p> <pre class="verbatim" data-language="perl">GV*	PL_ofsgv
</pre>
</li> <li id="PL_rs">
<b>PL_rs </b> <p>The input record separator - <code class="inline"><span class="i">$/</span></code> in Perl space.</p> <pre class="verbatim" data-language="perl">SV*	PL_rs
</pre>
</li> </ul> <h2 id="Stack-Manipulation-Macros">Stack Manipulation Macros</h2> <ul> <li id="djSP">
<b>djSP </b> <p>Declare Just <code class="inline"><span class="w">SP</span></code> . This is actually identical to <code class="inline"><span class="w">dSP</span></code> , and declares a local copy of perl's stack pointer, available via the <code class="inline"><span class="w">SP</span></code> macro. See <code class="inline"><span class="w">SP</span></code> . (Available for backward source code compatibility with the old (Perl 5.005) thread model.)</p> <pre class="verbatim" data-language="perl">djSP;
</pre>
</li> <li id="LVRET">
<b>LVRET </b> <p>True if this op will be the return value of an lvalue subroutine</p> </li> </ul> <h2 id="SV-Manipulation-Functions">SV Manipulation Functions</h2> <p>An SV (or AV, HV, etc.) is allocated in two parts: the head (struct sv, av, hv...) contains type and reference count information, and for many types, a pointer to the body (struct xrv, xpv, xpviv...), which contains fields specific to each type. Some types store all they need in the head, so don't have a body.</p> <p>In all but the most memory-paranoid configurations (ex: PURIFY), heads and bodies are allocated out of arenas, which by default are approximately 4K chunks of memory parcelled up into N heads or bodies. Sv-bodies are allocated by their sv-type, guaranteeing size consistency needed to allocate safely from arrays.</p> <p>For SV-heads, the first slot in each arena is reserved, and holds a link to the next arena, some flags, and a note of the number of slots. Snaked through each arena chain is a linked list of free items; when this becomes empty, an extra arena is allocated and divided up into N items which are threaded into the free list.</p> <p>SV-bodies are similar, but they use arena-sets by default, which separate the link and info from the arena itself, and reclaim the 1st slot in the arena. SV-bodies are further described later.</p> <p>The following global variables are associated with arenas:</p> <pre class="verbatim" data-language="perl">PL_sv_arenaroot     pointer to list of SV arenas
PL_sv_root          pointer to list of free SV structures

PL_body_arenas      head of linked-list of body arenas
PL_body_roots[]     array of pointers to list of free bodies of svtype
                    arrays are indexed by the svtype needed
</pre>
<p>A few special SV heads are not allocated from an arena, but are instead directly created in the interpreter structure, eg PL_sv_undef. The size of arenas can be changed from the default by setting PERL_ARENA_SIZE appropriately at compile time.</p> <p>The SV arena serves the secondary purpose of allowing still-live SVs to be located and destroyed during final cleanup.</p> <p>At the lowest level, the macros new_SV() and del_SV() grab and free an SV head. (If debugging with -DD, del_SV() calls the function S_del_sv() to return the SV to the free list with error checking.) new_SV() calls more_sv() / sv_add_arena() to add an extra arena if the free list is empty. SVs in the free list have their SvTYPE field set to all ones.</p> <p>At the time of very final cleanup, sv_free_arenas() is called from perl_destruct() to physically free all the arenas allocated since the start of the interpreter.</p> <p>The function visit() scans the SV arenas list, and calls a specified function for each SV it finds which is still live - ie which has an SvTYPE other than all 1's, and a non-zero SvREFCNT. visit() is used by the following functions (specified as [function that calls visit()] / [function called by visit() for each SV]):</p> <pre class="verbatim" data-language="perl">    sv_report_used() / do_report_used()
dump all remaining SVs (debugging aid)

    sv_clean_objs() / do_clean_objs(),do_clean_named_objs(),
		      do_clean_named_io_objs(),do_curse()
Attempt to free all objects pointed to by RVs,
try to do the same for all objects indir-
ectly referenced by typeglobs too, and
then do a final sweep, cursing any
objects that remain.  Called once from
perl_destruct(), prior to calling sv_clean_all()
below.

    sv_clean_all() / do_clean_all()
SvREFCNT_dec(sv) each remaining SV, possibly
triggering an sv_free(). It also sets the
SVf_BREAK flag on the SV to indicate that the
refcnt has been artificially lowered, and thus
stopping sv_free() from giving spurious warnings
about SVs which unexpectedly have a refcnt
of zero.  called repeatedly from perl_destruct()
until there are no SVs left.
</pre>
<ul> <li id="SvTHINKFIRST">
<b>SvTHINKFIRST </b> <p>A quick flag check to see whether an sv should be passed to sv_force_normal to be "downgraded" before SvIVX or SvPVX can be modified directly.</p> <p>For example, if your scalar is a reference and you want to modify the SvIVX slot, you can't just do SvROK_off, as that will leak the referent.</p> <p>This is used internally by various sv-modifying functions, such as sv_setsv, sv_setiv and sv_pvn_force.</p> <p>One case that this does not handle is a gv without SvFAKE set. After</p> <pre class="verbatim" data-language="perl">if (SvTHINKFIRST(gv)) sv_force_normal(gv);
</pre>
<p>it will still be a gv.</p> <p>SvTHINKFIRST sometimes produces false positives. In those cases sv_force_normal does nothing.</p> <pre class="verbatim" data-language="perl">U32	SvTHINKFIRST(SV *sv)
</pre>
</li> <li id="sv_add_arena">
<b>sv_add_arena </b> <p>Given a chunk of memory, link it to the head of the list of arenas, and split it into a list of free SVs.</p> <pre class="verbatim" data-language="perl">void	sv_add_arena(char *const ptr, const U32 size,
	             const U32 flags)
</pre>
</li> <li id="sv_clean_all">
<b>sv_clean_all </b> <p>Decrement the refcnt of each remaining SV, possibly triggering a cleanup. This function may have to be called multiple times to free SVs which are in complex self-referential hierarchies.</p> <pre class="verbatim" data-language="perl">I32	sv_clean_all()
</pre>
</li> <li id="sv_clean_objs">
<b>sv_clean_objs </b> <p>Attempt to destroy all objects not yet freed.</p> <pre class="verbatim" data-language="perl">void	sv_clean_objs()
</pre>
</li> <li id="sv_free_arenas">
<b>sv_free_arenas </b> <p>Deallocate the memory used by all arenas. Note that all the individual SV heads and bodies within the arenas must already have been freed.</p> <pre class="verbatim" data-language="perl">void	sv_free_arenas()
</pre>
</li> </ul> <h2 id="SV-Body-Allocation">SV-Body Allocation</h2> <ul> <li id="sv_2num">
<b>sv_2num </b> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>Return an SV with the numeric value of the source SV, doing any necessary reference or overload conversion. The caller is expected to have handled get-magic already.</p> <pre class="verbatim" data-language="perl">SV*	sv_2num(SV *const sv)
</pre>
</li> <li id="sv_copypv">
<b>sv_copypv </b> <p>Copies a stringified representation of the source SV into the destination SV. Automatically performs any necessary mg_get and coercion of numeric values into strings. Guaranteed to preserve UTF8 flag even from overloaded objects. Similar in nature to sv_2pv[_flags] but operates directly on an SV instead of just the string. Mostly uses sv_2pv_flags to do its work, except when that would lose the UTF-8'ness of the PV.</p> <pre class="verbatim" data-language="perl">void	sv_copypv(SV *const dsv, SV *const ssv)
</pre>
</li> <li id="sv_ref">
<b>sv_ref </b> <p>Returns a SV describing what the SV passed in is a reference to.</p> <pre class="verbatim" data-language="perl">SV*	sv_ref(SV *dst, const SV *const sv,
	       const int ob)
</pre>
</li> </ul> <h2 id="Unicode-Support">Unicode Support</h2> <ul> <li id="find_uninit_var">
<b>find_uninit_var </b> <p>NOTE: this function is experimental and may change or be removed without notice.</p> <p>Find the name of the undefined variable (if any) that caused the operator to issue a "Use of uninitialized value" warning. If match is true, only return a name if its value matches uninit_sv. So roughly speaking, if a unary operator (such as OP_COS) generates a warning, then following the direct child of the op may yield an OP_PADSV or OP_GV that gives the name of the undefined variable. On the other hand, with OP_ADD there are two branches to follow, so we only print the variable name if we get an exact match. desc_p points to a string pointer holding the description of the op. This may be updated if needed.</p> <p>The name is returned as a mortal SV.</p> <p>Assumes that PL_op is the op that originally triggered the error, and that PL_comppad/PL_curpad points to the currently executing pad.</p> <pre class="verbatim" data-language="perl">SV*	find_uninit_var(const OP *const obase,
	                const SV *const uninit_sv,
	                bool match, const char **desc_p)
</pre>
</li> <li id="report_uninit">
<b>report_uninit </b> <p>Print appropriate "Use of uninitialized variable" warning.</p> <pre class="verbatim" data-language="perl">void	report_uninit(const SV *uninit_sv)
</pre>
</li> </ul> <h2 id="Undocumented-functions">Undocumented functions</h2> <p>The following functions are currently undocumented. If you use one of them, you may wish to consider creating and submitting documentation for it.</p> <ul> <li id="PerlIO_restore_errno">
<b>PerlIO_restore_errno </b> </li> <li id="PerlIO_save_errno">
<b>PerlIO_save_errno </b> </li> <li id="Slab_Alloc">
<b>Slab_Alloc </b> </li> <li id="Slab_Free">
<b>Slab_Free </b> </li> <li id="Slab_to_ro">
<b>Slab_to_ro </b> </li> <li id="Slab_to_rw">
<b>Slab_to_rw </b> </li> <li id="_add_range_to_invlist">
<b>_add_range_to_invlist </b> </li> <li id="_core_swash_init">
<b>_core_swash_init </b> </li> <li id="_get_encoding">
<b>_get_encoding </b> </li> <li id="_get_swash_invlist">
<b>_get_swash_invlist </b> </li> <li id="_invlist_array_init">
<b>_invlist_array_init </b> </li> <li id="_invlist_contains_cp">
<b>_invlist_contains_cp </b> </li> <li id="_invlist_contents">
<b>_invlist_contents </b> </li> <li id="_invlist_dump">
<b>_invlist_dump </b> </li> <li id="_invlist_intersection">
<b>_invlist_intersection </b> </li> <li id="_invlist_intersection_maybe_complement_2nd">
<b>_invlist_intersection_maybe_complement_2nd </b> </li> <li id="_invlist_invert">
<b>_invlist_invert </b> </li> <li id="_invlist_len">
<b>_invlist_len </b> </li> <li id="_invlist_populate_swatch">
<b>_invlist_populate_swatch </b> </li> <li id="_invlist_search">
<b>_invlist_search </b> </li> <li id="_invlist_subtract">
<b>_invlist_subtract </b> </li> <li id="_invlist_union">
<b>_invlist_union </b> </li> <li id="_invlist_union_maybe_complement_2nd">
<b>_invlist_union_maybe_complement_2nd </b> </li> <li id="_load_PL_utf8_foldclosures">
<b>_load_PL_utf8_foldclosures </b> </li> <li id="_new_invlist">
<b>_new_invlist </b> </li> <li id="_setup_canned_invlist">
<b>_setup_canned_invlist </b> </li> <li id="_swash_inversion_hash">
<b>_swash_inversion_hash </b> </li> <li id="_swash_to_invlist">
<b>_swash_to_invlist </b> </li> <li id="_to_fold_latin1">
<b>_to_fold_latin1 </b> </li> <li id="_to_upper_title_latin1">
<b>_to_upper_title_latin1 </b> </li> <li id="_warn_problematic_locale">
<b>_warn_problematic_locale </b> </li> <li id="aassign_common_vars">
<b>aassign_common_vars </b> </li> <li id="add_cp_to_invlist">
<b>add_cp_to_invlist </b> </li> <li id="alloc_maybe_populate_EXACT">
<b>alloc_maybe_populate_EXACT </b> </li> <li id="allocmy">
<b>allocmy </b> </li> <li id="amagic_is_enabled">
<b>amagic_is_enabled </b> </li> <li id="apply">
<b>apply </b> </li> <li id="av_extend_guts">
<b>av_extend_guts </b> </li> <li id="av_reify">
<b>av_reify </b> </li> <li id="bind_match">
<b>bind_match </b> </li> <li id="boot_core_PerlIO">
<b>boot_core_PerlIO </b> </li> <li id="boot_core_UNIVERSAL">
<b>boot_core_UNIVERSAL </b> </li> <li id="boot_core_mro">
<b>boot_core_mro </b> </li> <li id="cando">
<b>cando </b> </li> <li id="check_utf8_print">
<b>check_utf8_print </b> </li> <li id="ck_anoncode">
<b>ck_anoncode </b> </li> <li id="ck_backtick">
<b>ck_backtick </b> </li> <li id="ck_bitop">
<b>ck_bitop </b> </li> <li id="ck_cmp">
<b>ck_cmp </b> </li> <li id="ck_concat">
<b>ck_concat </b> </li> <li id="ck_defined">
<b>ck_defined </b> </li> <li id="ck_delete">
<b>ck_delete </b> </li> <li id="ck_each">
<b>ck_each </b> </li> <li id="ck_entersub_args_core">
<b>ck_entersub_args_core </b> </li> <li id="ck_eof">
<b>ck_eof </b> </li> <li id="ck_eval">
<b>ck_eval </b> </li> <li id="ck_exec">
<b>ck_exec </b> </li> <li id="ck_exists">
<b>ck_exists </b> </li> <li id="ck_ftst">
<b>ck_ftst </b> </li> <li id="ck_fun">
<b>ck_fun </b> </li> <li id="ck_glob">
<b>ck_glob </b> </li> <li id="ck_grep">
<b>ck_grep </b> </li> <li id="ck_index">
<b>ck_index </b> </li> <li id="ck_join">
<b>ck_join </b> </li> <li id="ck_length">
<b>ck_length </b> </li> <li id="ck_lfun">
<b>ck_lfun </b> </li> <li id="ck_listiob">
<b>ck_listiob </b> </li> <li id="ck_match">
<b>ck_match </b> </li> <li id="ck_method">
<b>ck_method </b> </li> <li id="ck_null">
<b>ck_null </b> </li> <li id="ck_open">
<b>ck_open </b> </li> <li id="ck_prototype">
<b>ck_prototype </b> </li> <li id="ck_readline">
<b>ck_readline </b> </li> <li id="ck_refassign">
<b>ck_refassign </b> </li> <li id="ck_repeat">
<b>ck_repeat </b> </li> <li id="ck_require">
<b>ck_require </b> </li> <li id="ck_return">
<b>ck_return </b> </li> <li id="ck_rfun">
<b>ck_rfun </b> </li> <li id="ck_rvconst">
<b>ck_rvconst </b> </li> <li id="ck_sassign">
<b>ck_sassign </b> </li> <li id="ck_select">
<b>ck_select </b> </li> <li id="ck_shift">
<b>ck_shift </b> </li> <li id="ck_smartmatch">
<b>ck_smartmatch </b> </li> <li id="ck_sort">
<b>ck_sort </b> </li> <li id="ck_spair">
<b>ck_spair </b> </li> <li id="ck_split">
<b>ck_split </b> </li> <li id="ck_stringify">
<b>ck_stringify </b> </li> <li id="ck_subr">
<b>ck_subr </b> </li> <li id="ck_substr">
<b>ck_substr </b> </li> <li id="ck_svconst">
<b>ck_svconst </b> </li> <li id="ck_tell">
<b>ck_tell </b> </li> <li id="ck_trunc">
<b>ck_trunc </b> </li> <li id="closest_cop">
<b>closest_cop </b> </li> <li id="compute_EXACTish">
<b>compute_EXACTish </b> </li> <li id="coresub_op">
<b>coresub_op </b> </li> <li id="create_eval_scope">
<b>create_eval_scope </b> </li> <li id="croak_no_mem">
<b>croak_no_mem </b> </li> <li id="croak_popstack">
<b>croak_popstack </b> </li> <li id="current_re_engine">
<b>current_re_engine </b> </li> <li id="custom_op_get_field">
<b>custom_op_get_field </b> </li> <li id="cv_ckproto_len_flags">
<b>cv_ckproto_len_flags </b> </li> <li id="cv_clone_into">
<b>cv_clone_into </b> </li> <li id="cv_const_sv_or_av">
<b>cv_const_sv_or_av </b> </li> <li id="cv_undef_flags">
<b>cv_undef_flags </b> </li> <li id="cvgv_from_hek">
<b>cvgv_from_hek </b> </li> <li id="cvgv_set">
<b>cvgv_set </b> </li> <li id="cvstash_set">
<b>cvstash_set </b> </li> <li id="deb_stack_all">
<b>deb_stack_all </b> </li> <li id="defelem_target">
<b>defelem_target </b> </li> <li id="delete_eval_scope">
<b>delete_eval_scope </b> </li> <li id="die_unwind">
<b>die_unwind </b> </li> <li id="do_aexec">
<b>do_aexec </b> </li> <li id="do_aexec5">
<b>do_aexec5 </b> </li> <li id="do_eof">
<b>do_eof </b> </li> <li id="do_exec">
<b>do_exec </b> </li> <li id="do_exec3">
<b>do_exec3 </b> </li> <li id="do_execfree">
<b>do_execfree </b> </li> <li id="do_ipcctl">
<b>do_ipcctl </b> </li> <li id="do_ipcget">
<b>do_ipcget </b> </li> <li id="do_msgrcv">
<b>do_msgrcv </b> </li> <li id="do_msgsnd">
<b>do_msgsnd </b> </li> <li id="do_ncmp">
<b>do_ncmp </b> </li> <li id="do_open6">
<b>do_open6 </b> </li> <li id="do_open_raw">
<b>do_open_raw </b> </li> <li id="do_print">
<b>do_print </b> </li> <li id="do_readline">
<b>do_readline </b> </li> <li id="do_seek">
<b>do_seek </b> </li> <li id="do_semop">
<b>do_semop </b> </li> <li id="do_shmio">
<b>do_shmio </b> </li> <li id="do_sysseek">
<b>do_sysseek </b> </li> <li id="do_tell">
<b>do_tell </b> </li> <li id="do_trans">
<b>do_trans </b> </li> <li id="do_vecget">
<b>do_vecget </b> </li> <li id="do_vecset">
<b>do_vecset </b> </li> <li id="do_vop">
<b>do_vop </b> </li> <li id="dofile">
<b>dofile </b> </li> <li id="drand48_init_r">
<b>drand48_init_r </b> </li> <li id="drand48_r">
<b>drand48_r </b> </li> <li id="dump_all_perl">
<b>dump_all_perl </b> </li> <li id="dump_packsubs_perl">
<b>dump_packsubs_perl </b> </li> <li id="dump_sub_perl">
<b>dump_sub_perl </b> </li> <li id="dump_sv_child">
<b>dump_sv_child </b> </li> <li id="emulate_cop_io">
<b>emulate_cop_io </b> </li> <li id="feature_is_enabled">
<b>feature_is_enabled </b> </li> <li id="find_lexical_cv">
<b>find_lexical_cv </b> </li> <li id="find_runcv_where">
<b>find_runcv_where </b> </li> <li id="find_rundefsv2">
<b>find_rundefsv2 </b> </li> <li id="find_script">
<b>find_script </b> </li> <li id="free_tied_hv_pool">
<b>free_tied_hv_pool </b> </li> <li id="get_and_check_backslash_N_name">
<b>get_and_check_backslash_N_name </b> </li> <li id="get_db_sub">
<b>get_db_sub </b> </li> <li id="get_debug_opts">
<b>get_debug_opts </b> </li> <li id="get_hash_seed">
<b>get_hash_seed </b> </li> <li id="get_invlist_iter_addr">
<b>get_invlist_iter_addr </b> </li> <li id="get_invlist_offset_addr">
<b>get_invlist_offset_addr </b> </li> <li id="get_invlist_previous_index_addr">
<b>get_invlist_previous_index_addr </b> </li> <li id="get_no_modify">
<b>get_no_modify </b> </li> <li id="get_opargs">
<b>get_opargs </b> </li> <li id="get_re_arg">
<b>get_re_arg </b> </li> <li id="getenv_len">
<b>getenv_len </b> </li> <li id="grok_atoUV">
<b>grok_atoUV </b> </li> <li id="grok_bslash_x">
<b>grok_bslash_x </b> </li> <li id="gv_fetchmeth_internal">
<b>gv_fetchmeth_internal </b> </li> <li id="gv_override">
<b>gv_override </b> </li> <li id="gv_setref">
<b>gv_setref </b> </li> <li id="gv_stashpvn_internal">
<b>gv_stashpvn_internal </b> </li> <li id="gv_stashsvpvn_cached">
<b>gv_stashsvpvn_cached </b> </li> <li id="hfree_next_entry">
<b>hfree_next_entry </b> </li> <li id="hv_backreferences_p">
<b>hv_backreferences_p </b> </li> <li id="hv_kill_backrefs">
<b>hv_kill_backrefs </b> </li> <li id="hv_placeholders_p">
<b>hv_placeholders_p </b> </li> <li id="hv_undef_flags">
<b>hv_undef_flags </b> </li> <li id="init_argv_symbols">
<b>init_argv_symbols </b> </li> <li id="init_constants">
<b>init_constants </b> </li> <li id="init_dbargs">
<b>init_dbargs </b> </li> <li id="init_debugger">
<b>init_debugger </b> </li> <li id="invert">
<b>invert </b> </li> <li id="invlist_array">
<b>invlist_array </b> </li> <li id="invlist_clone">
<b>invlist_clone </b> </li> <li id="invlist_highest">
<b>invlist_highest </b> </li> <li id="invlist_is_iterating">
<b>invlist_is_iterating </b> </li> <li id="invlist_iterfinish">
<b>invlist_iterfinish </b> </li> <li id="invlist_iterinit">
<b>invlist_iterinit </b> </li> <li id="invlist_max">
<b>invlist_max </b> </li> <li id="invlist_previous_index">
<b>invlist_previous_index </b> </li> <li id="invlist_set_len">
<b>invlist_set_len </b> </li> <li id="invlist_set_previous_index">
<b>invlist_set_previous_index </b> </li> <li id="invlist_trim">
<b>invlist_trim </b> </li> <li id="io_close">
<b>io_close </b> </li> <li id="is_utf8_common">
<b>is_utf8_common </b> </li> <li id="isinfnansv">
<b>isinfnansv </b> </li> <li id="jmaybe">
<b>jmaybe </b> </li> <li id="keyword">
<b>keyword </b> </li> <li id="keyword_plugin_standard">
<b>keyword_plugin_standard </b> </li> <li id="list">
<b>list </b> </li> <li id="localize">
<b>localize </b> </li> <li id="magic_clear_all_env">
<b>magic_clear_all_env </b> </li> <li id="magic_cleararylen_p">
<b>magic_cleararylen_p </b> </li> <li id="magic_clearenv">
<b>magic_clearenv </b> </li> <li id="magic_clearisa">
<b>magic_clearisa </b> </li> <li id="magic_clearpack">
<b>magic_clearpack </b> </li> <li id="magic_clearsig">
<b>magic_clearsig </b> </li> <li id="magic_copycallchecker">
<b>magic_copycallchecker </b> </li> <li id="magic_existspack">
<b>magic_existspack </b> </li> <li id="magic_freearylen_p">
<b>magic_freearylen_p </b> </li> <li id="magic_freeovrld">
<b>magic_freeovrld </b> </li> <li id="magic_get">
<b>magic_get </b> </li> <li id="magic_getarylen">
<b>magic_getarylen </b> </li> <li id="magic_getdebugvar">
<b>magic_getdebugvar </b> </li> <li id="magic_getdefelem">
<b>magic_getdefelem </b> </li> <li id="magic_getnkeys">
<b>magic_getnkeys </b> </li> <li id="magic_getpack">
<b>magic_getpack </b> </li> <li id="magic_getpos">
<b>magic_getpos </b> </li> <li id="magic_getsig">
<b>magic_getsig </b> </li> <li id="magic_getsubstr">
<b>magic_getsubstr </b> </li> <li id="magic_gettaint">
<b>magic_gettaint </b> </li> <li id="magic_getuvar">
<b>magic_getuvar </b> </li> <li id="magic_getvec">
<b>magic_getvec </b> </li> <li id="magic_killbackrefs">
<b>magic_killbackrefs </b> </li> <li id="magic_nextpack">
<b>magic_nextpack </b> </li> <li id="magic_regdata_cnt">
<b>magic_regdata_cnt </b> </li> <li id="magic_regdatum_get">
<b>magic_regdatum_get </b> </li> <li id="magic_regdatum_set">
<b>magic_regdatum_set </b> </li> <li id="magic_scalarpack">
<b>magic_scalarpack </b> </li> <li id="magic_set">
<b>magic_set </b> </li> <li id="magic_set_all_env">
<b>magic_set_all_env </b> </li> <li id="magic_setarylen">
<b>magic_setarylen </b> </li> <li id="magic_setcollxfrm">
<b>magic_setcollxfrm </b> </li> <li id="magic_setdbline">
<b>magic_setdbline </b> </li> <li id="magic_setdebugvar">
<b>magic_setdebugvar </b> </li> <li id="magic_setdefelem">
<b>magic_setdefelem </b> </li> <li id="magic_setenv">
<b>magic_setenv </b> </li> <li id="magic_setisa">
<b>magic_setisa </b> </li> <li id="magic_setlvref">
<b>magic_setlvref </b> </li> <li id="magic_setmglob">
<b>magic_setmglob </b> </li> <li id="magic_setnkeys">
<b>magic_setnkeys </b> </li> <li id="magic_setpack">
<b>magic_setpack </b> </li> <li id="magic_setpos">
<b>magic_setpos </b> </li> <li id="magic_setregexp">
<b>magic_setregexp </b> </li> <li id="magic_setsig">
<b>magic_setsig </b> </li> <li id="magic_setsubstr">
<b>magic_setsubstr </b> </li> <li id="magic_settaint">
<b>magic_settaint </b> </li> <li id="magic_setutf8">
<b>magic_setutf8 </b> </li> <li id="magic_setuvar">
<b>magic_setuvar </b> </li> <li id="magic_setvec">
<b>magic_setvec </b> </li> <li id="magic_sizepack">
<b>magic_sizepack </b> </li> <li id="magic_wipepack">
<b>magic_wipepack </b> </li> <li id="malloc_good_size">
<b>malloc_good_size </b> </li> <li id="malloced_size">
<b>malloced_size </b> </li> <li id="mem_collxfrm">
<b>mem_collxfrm </b> </li> <li id="mg_find_mglob">
<b>mg_find_mglob </b> </li> <li id="mode_from_discipline">
<b>mode_from_discipline </b> </li> <li id="more_bodies">
<b>more_bodies </b> </li> <li id="mro_meta_dup">
<b>mro_meta_dup </b> </li> <li id="mro_meta_init">
<b>mro_meta_init </b> </li> <li id="multideref_stringify">
<b>multideref_stringify </b> </li> <li id="my_attrs">
<b>my_attrs </b> </li> <li id="my_clearenv">
<b>my_clearenv </b> </li> <li id="my_lstat_flags">
<b>my_lstat_flags </b> </li> <li id="my_stat_flags">
<b>my_stat_flags </b> </li> <li id="my_unexec">
<b>my_unexec </b> </li> <li id="newATTRSUB_x">
<b>newATTRSUB_x </b> </li> <li id="newGP">
<b>newGP </b> </li> <li id="newMETHOP_internal">
<b>newMETHOP_internal </b> </li> <li id="newSTUB">
<b>newSTUB </b> </li> <li id="newSVavdefelem">
<b>newSVavdefelem </b> </li> <li id="newXS_deffile">
<b>newXS_deffile </b> </li> <li id="newXS_len_flags">
<b>newXS_len_flags </b> </li> <li id="new_warnings_bitfield">
<b>new_warnings_bitfield </b> </li> <li id="nextargv">
<b>nextargv </b> </li> <li id="noperl_die">
<b>noperl_die </b> </li> <li id="oopsAV">
<b>oopsAV </b> </li> <li id="oopsHV">
<b>oopsHV </b> </li> <li id="op_clear">
<b>op_clear </b> </li> <li id="op_integerize">
<b>op_integerize </b> </li> <li id="op_lvalue_flags">
<b>op_lvalue_flags </b> </li> <li id="op_refcnt_dec">
<b>op_refcnt_dec </b> </li> <li id="op_refcnt_inc">
<b>op_refcnt_inc </b> </li> <li id="op_relocate_sv">
<b>op_relocate_sv </b> </li> <li id="op_std_init">
<b>op_std_init </b> </li> <li id="op_unscope">
<b>op_unscope </b> </li> <li id="opmethod_stash">
<b>opmethod_stash </b> </li> <li id="opslab_force_free">
<b>opslab_force_free </b> </li> <li id="opslab_free">
<b>opslab_free </b> </li> <li id="opslab_free_nopad">
<b>opslab_free_nopad </b> </li> <li id="package">
<b>package </b> </li> <li id="package_version">
<b>package_version </b> </li> <li id="pad_add_weakref">
<b>pad_add_weakref </b> </li> <li id="padlist_store">
<b>padlist_store </b> </li> <li id="padname_free">
<b>padname_free </b> </li> <li id="padnamelist_free">
<b>padnamelist_free </b> </li> <li id="parse_subsignature">
<b>parse_subsignature </b> </li> <li id="parse_unicode_opts">
<b>parse_unicode_opts </b> </li> <li id="parser_free">
<b>parser_free </b> </li> <li id="parser_free_nexttoke_ops">
<b>parser_free_nexttoke_ops </b> </li> <li id="path_is_searchable">
<b>path_is_searchable </b> </li> <li id="peep">
<b>peep </b> </li> <li id="pmruntime">
<b>pmruntime </b> </li> <li id="populate_isa">
<b>populate_isa </b> </li> <li id="ptr_hash">
<b>ptr_hash </b> </li> <li id="qerror">
<b>qerror </b> </li> <li id="re_op_compile">
<b>re_op_compile </b> </li> <li id="reg_named_buff">
<b>reg_named_buff </b> </li> <li id="reg_named_buff_iter">
<b>reg_named_buff_iter </b> </li> <li id="reg_numbered_buff_fetch">
<b>reg_numbered_buff_fetch </b> </li> <li id="reg_numbered_buff_length">
<b>reg_numbered_buff_length </b> </li> <li id="reg_numbered_buff_store">
<b>reg_numbered_buff_store </b> </li> <li id="reg_qr_package">
<b>reg_qr_package </b> </li> <li id="reg_skipcomment">
<b>reg_skipcomment </b> </li> <li id="reg_temp_copy">
<b>reg_temp_copy </b> </li> <li id="regcurly">
<b>regcurly </b> </li> <li id="regpposixcc">
<b>regpposixcc </b> </li> <li id="regprop">
<b>regprop </b> </li> <li id="report_evil_fh">
<b>report_evil_fh </b> </li> <li id="report_redefined_cv">
<b>report_redefined_cv </b> </li> <li id="report_wrongway_fh">
<b>report_wrongway_fh </b> </li> <li id="rpeep">
<b>rpeep </b> </li> <li id="rsignal_restore">
<b>rsignal_restore </b> </li> <li id="rsignal_save">
<b>rsignal_save </b> </li> <li id="rxres_save">
<b>rxres_save </b> </li> <li id="same_dirent">
<b>same_dirent </b> </li> <li id="save_aliased_sv">
<b>save_aliased_sv </b> </li> <li id="save_strlen">
<b>save_strlen </b> </li> <li id="sawparens">
<b>sawparens </b> </li> <li id="scalar">
<b>scalar </b> </li> <li id="scalarvoid">
<b>scalarvoid </b> </li> <li id="set_caret_X">
<b>set_caret_X </b> </li> <li id="set_padlist">
<b>set_padlist </b> </li> <li id="should_warn_nl">
<b>should_warn_nl </b> </li> <li id="sighandler">
<b>sighandler </b> </li> <li id="softref2xv">
<b>softref2xv </b> </li> <li id="ssc_add_range">
<b>ssc_add_range </b> </li> <li id="ssc_clear_locale">
<b>ssc_clear_locale </b> </li> <li id="ssc_cp_and">
<b>ssc_cp_and </b> </li> <li id="ssc_intersection">
<b>ssc_intersection </b> </li> <li id="ssc_union">
<b>ssc_union </b> </li> <li id="sub_crush_depth">
<b>sub_crush_depth </b> </li> <li id="sv_add_backref">
<b>sv_add_backref </b> </li> <li id="sv_buf_to_ro">
<b>sv_buf_to_ro </b> </li> <li id="sv_del_backref">
<b>sv_del_backref </b> </li> <li id="sv_free2">
<b>sv_free2 </b> </li> <li id="sv_kill_backrefs">
<b>sv_kill_backrefs </b> </li> <li id="sv_len_utf8_nomg">
<b>sv_len_utf8_nomg </b> </li> <li id="sv_magicext_mglob">
<b>sv_magicext_mglob </b> </li> <li id="sv_mortalcopy_flags">
<b>sv_mortalcopy_flags </b> </li> <li id="sv_only_taint_gmagic">
<b>sv_only_taint_gmagic </b> </li> <li id="sv_or_pv_pos_u2b">
<b>sv_or_pv_pos_u2b </b> </li> <li id="sv_resetpvn">
<b>sv_resetpvn </b> </li> <li id="sv_sethek">
<b>sv_sethek </b> </li> <li id="sv_setsv_cow">
<b>sv_setsv_cow </b> </li> <li id="sv_unglob">
<b>sv_unglob </b> </li> <li id="tied_method">
<b>tied_method </b> </li> <li id="tmps_grow_p">
<b>tmps_grow_p </b> </li> <li id="translate_substr_offsets">
<b>translate_substr_offsets </b> </li> <li id="try_amagic_bin">
<b>try_amagic_bin </b> </li> <li id="try_amagic_un">
<b>try_amagic_un </b> </li> <li id="unshare_hek">
<b>unshare_hek </b> </li> <li id="utilize">
<b>utilize </b> </li> <li id="varname">
<b>varname </b> </li> <li id="vivify_defelem">
<b>vivify_defelem </b> </li> <li id="vivify_ref">
<b>vivify_ref </b> </li> <li id="wait4pid">
<b>wait4pid </b> </li> <li id="was_lvalue_sub">
<b>was_lvalue_sub </b> </li> <li id="watch">
<b>watch </b> </li> <li id="win32_croak_not_implemented">
<b>win32_croak_not_implemented </b> </li> <li id="write_to_stderr">
<b>write_to_stderr </b> </li> <li id="xs_boot_epilog">
<b>xs_boot_epilog </b> </li> <li id="xs_handshake">
<b>xs_handshake </b> </li> <li id="yyerror">
<b>yyerror </b> </li> <li id="yyerror_pv">
<b>yyerror_pv </b> </li> <li id="yyerror_pvn">
<b>yyerror_pvn </b> </li> <li id="yylex">
<b>yylex </b> </li> <li id="yyparse">
<b>yyparse </b> </li> <li id="yyunlex">
<b>yyunlex </b> </li> </ul> <h2 id="AUTHORS">AUTHORS</h2> <p>The autodocumentation system was originally added to the Perl core by Benjamin Stuhl. Documentation is by whoever was kind enough to document their functions.</p> <h2 id="SEE-ALSO">SEE ALSO</h2> <p><a href="perlguts">perlguts</a>, <a href="perlapi">perlapi</a></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1993–2016 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.26.0/perlintern.html" class="_attribution-link">https://perldoc.perl.org/5.26.0/perlintern.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
