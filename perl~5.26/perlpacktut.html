
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Perlpacktut - Perl 5.26 - W3cubDocs</title>
  
  <meta name="description" content=" perlpacktut - tutorial on pack and unpack ">
  <meta name="keywords" content="perlpacktut, perl, perl~5.26">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/perl~5.26/perlpacktut.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/perl~5.26.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/perl~5.26/" class="_nav-link" title="" style="margin-left:0;">Perl 5.26</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _perl">
				
				
<h1>perlpacktut</h1>  <ul>
<li><a href="#NAME">NAME</a></li>
<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
<li><a href="#The-Basic-Principle">The Basic Principle</a></li>
<li><a href="#Packing-Text">Packing Text</a></li>
<li>
<a href="#Packing-Numbers">Packing Numbers</a><ul>
<li><a href="#Integers">Integers</a></li>
<li><a href="#Unpacking-a-Stack-Frame">Unpacking a Stack Frame</a></li>
<li><a href="#How-to-Eat-an-Egg-on-a-Net">How to Eat an Egg on a Net</a></li>
<li><a href="#Byte-order-modifiers">Byte-order modifiers</a></li>
<li><a href="#Floating-point-Numbers">Floating point Numbers</a></li>
</ul>
</li>
<li>
<a href="#Exotic-Templates">Exotic Templates</a><ul>
<li><a href="#Bit-Strings">Bit Strings</a></li>
<li><a href="#Uuencoding">Uuencoding</a></li>
<li><a href="#Doing-Sums">Doing Sums</a></li>
<li><a href="#Unicode">Unicode</a></li>
<li><a href="#Another-Portable-Binary-Encoding">Another Portable Binary Encoding</a></li>
</ul>
</li>
<li><a href="#Template-Grouping">Template Grouping</a></li>
<li>
<a href="#Lengths-and-Widths">Lengths and Widths</a><ul>
<li><a href="#String-Lengths">String Lengths</a></li>
<li><a href="#Dynamic-Templates">Dynamic Templates</a></li>
<li><a href="#Counting-Repetitions">Counting Repetitions</a></li>
<li><a href="#Intel-HEX">Intel HEX</a></li>
</ul>
</li>
<li>
<a href="#Packing-and-Unpacking-C-Structures">Packing and Unpacking C Structures</a><ul>
<li><a href="#The-Alignment-Pit">The Alignment Pit</a></li>
<li><a href="#Dealing-with-Endian-ness">Dealing with Endian-ness</a></li>
<li><a href="#Alignment%2c-Take-2">Alignment, Take 2</a></li>
<li><a href="#Alignment%2c-Take-3">Alignment, Take 3</a></li>
<li><a href="#Pointers-for-How-to-Use-Them">Pointers for How to Use Them</a></li>
</ul>
</li>
<li><a href="#Pack-Recipes">Pack Recipes</a></li>
<li><a href="#Funnies-Section">Funnies Section</a></li>
<li><a href="#Authors">Authors</a></li>
</ul>
<h2 id="NAME">NAME</h2> <p>perlpacktut - tutorial on <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> and <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code></p> <h2 id="DESCRIPTION">DESCRIPTION</h2> <p><code class="inline"><a class="l_k" href="functions/pack">pack</a></code> and <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> are two functions for transforming data according to a user-defined template, between the guarded way Perl stores values and some well-defined representation as might be required in the environment of a Perl program. Unfortunately, they're also two of the most misunderstood and most often overlooked functions that Perl provides. This tutorial will demystify them for you.</p> <h2 id="The-Basic-Principle">The Basic Principle</h2> <p>Most programming languages don't shelter the memory where variables are stored. In C, for instance, you can take the address of some variable, and the <code class="inline"><span class="w">sizeof</span></code> operator tells you how many bytes are allocated to the variable. Using the address and the size, you may access the storage to your heart's content.</p> <p>In Perl, you just can't access memory at random, but the structural and representational conversion provided by <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> and <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> is an excellent alternative. The <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> function converts values to a byte sequence containing representations according to a given specification, the so-called "template" argument. <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> is the reverse process, deriving some values from the contents of a string of bytes. (Be cautioned, however, that not all that has been packed together can be neatly unpacked - a very common experience as seasoned travellers are likely to confirm.)</p> <p>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: <code class="inline"><a class="l_k" href="functions/syscall">syscall</a></code> requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</p> <p>To see how (un)packing works, we'll start with a simple template code where the conversion is in low gear: between the contents of a byte sequence and a string of hexadecimal digits. Let's use <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code>, since this is likely to remind you of a dump program, or some desperate last message unfortunate programs are wont to throw at you before they expire into the wild blue yonder. Assuming that the variable <code class="inline"><span class="i">$mem</span></code> holds a sequence of bytes that we'd like to inspect without assuming anything about its meaning, we can write</p> <pre class="verbatim" data-language="perl">my( $hex ) = unpack( 'H*', $mem );
print "$hex\n";
</pre>
<p>whereupon we might see something like this, with each pair of hex digits corresponding to a byte:</p> <pre class="verbatim" data-language="perl">41204d414e204120504c414e20412043414e414c2050414e414d41
</pre>
<p>What was in this chunk of memory? Numbers, characters, or a mixture of both? Assuming that we're on a computer where ASCII (or some similar) encoding is used: hexadecimal values in the range <code class="inline"><span class="n">0x40</span></code> - <code class="inline"><span class="n">0x5A</span></code> indicate an uppercase letter, and <code class="inline"><span class="n">0x20</span></code> encodes a space. So we might assume it is a piece of text, which some are able to read like a tabloid; but others will have to get hold of an ASCII table and relive that firstgrader feeling. Not caring too much about which way to read this, we note that <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> with the template code <code class="inline"><span class="w">H</span></code> converts the contents of a sequence of bytes into the customary hexadecimal notation. Since "a sequence of" is a pretty vague indication of quantity, <code class="inline"><span class="w">H</span></code> has been defined to convert just a single hexadecimal digit unless it is followed by a repeat count. An asterisk for the repeat count means to use whatever remains.</p> <p>The inverse operation - packing byte contents from a string of hexadecimal digits - is just as easily written. For instance:</p> <pre class="verbatim" data-language="perl">my $s = pack( 'H2' x 10, 30..39 );
print "$s\n";
</pre>
<p>Since we feed a list of ten 2-digit hexadecimal strings to <code class="inline"><a class="l_k" href="functions/pack">pack</a></code>, the pack template should contain ten pack codes. If this is run on a computer with ASCII character coding, it will print <code class="inline"><span class="n">0123456789</span></code> .</p> <h2 id="Packing-Text">Packing Text</h2> <p>Let's suppose you've got to read in a data file like this:</p> <pre class="verbatim" data-language="perl">Date      |Description                | Income|Expenditure
01/24/2001 Zed's Camel Emporium                    1147.99
01/28/2001 Flea spray                                24.99
01/29/2001 Camel rides to tourists      235.00
</pre>
<p>How do we do it? You might think first to use <code class="inline"><a class="l_k" href="functions/split">split</a></code>; however, since <code class="inline"><a class="l_k" href="functions/split">split</a></code> collapses blank fields, you'll never know whether a record was income or expenditure. Oops. Well, you could always use <code class="inline"><a class="l_k" href="functions/substr">substr</a></code>:</p> <pre class="verbatim" data-language="perl">while (&lt;&gt;) { 
    my $date   = substr($_,  0, 11);
    my $desc   = substr($_, 12, 27);
    my $income = substr($_, 40,  7);
    my $expend = substr($_, 52,  7);
    ...
}
</pre>
<p>It's not really a barrel of laughs, is it? In fact, it's worse than it may seem; the eagle-eyed may notice that the first field should only be 10 characters wide, and the error has propagated right through the other numbers - which we've had to count by hand. So it's error-prone as well as horribly unfriendly.</p> <p>Or maybe we could use regular expressions:</p> <pre class="verbatim" data-language="perl">while (&lt;&gt;) { 
    my($date, $desc, $income, $expend) = 
        m|(\d\d/\d\d/\d{4}) (.{27}) (.{7})(.*)|;
    ...
}
</pre>
<p>Urgh. Well, it's a bit better, but - well, would you want to maintain that?</p> <p>Hey, isn't Perl supposed to make this sort of thing easy? Well, it does, if you use the right tools. <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> and <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> are designed to help you out when dealing with fixed-width data like the above. Let's have a look at a solution with <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code>:</p> <pre class="verbatim" data-language="perl">while (&lt;&gt;) { 
    my($date, $desc, $income, $expend) = unpack("A10xA27xA7A*", $_);
    ...
}
</pre>
<p>That looks a bit nicer; but we've got to take apart that weird template. Where did I pull that out of?</p> <p>OK, let's have a look at some of our data again; in fact, we'll include the headers, and a handy ruler so we can keep track of where we are.</p> <pre class="verbatim" data-language="perl">         1         2         3         4         5        
1234567890123456789012345678901234567890123456789012345678
Date      |Description                | Income|Expenditure
01/28/2001 Flea spray                                24.99
01/29/2001 Camel rides to tourists      235.00
</pre>
<p>From this, we can see that the date column stretches from column 1 to column 10 - ten characters wide. The <code class="inline"><a class="l_k" href="functions/pack">pack</a></code>-ese for "character" is <code class="inline"><span class="w">A</span></code> , and ten of them are <code class="inline"><span class="w">A10</span></code> . So if we just wanted to extract the dates, we could say this:</p> <pre class="verbatim" data-language="perl">my($date) = unpack("A10", $_);
</pre>
<p>OK, what's next? Between the date and the description is a blank column; we want to skip over that. The <code class="inline"><span class="w">x</span></code> template means "skip forward", so we want one of those. Next, we have another batch of characters, from 12 to 38. That's 27 more characters, hence <code class="inline"><span class="w">A27</span></code> . (Don't make the fencepost error - there are 27 characters between 12 and 38, not 26. Count 'em!)</p> <p>Now we skip another character and pick up the next 7 characters:</p> <pre class="verbatim" data-language="perl">my($date,$description,$income) = unpack("A10xA27xA7", $_);
</pre>
<p>Now comes the clever bit. Lines in our ledger which are just income and not expenditure might end at column 46. Hence, we don't want to tell our <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> pattern that we <b>need</b> to find another 12 characters; we'll just say "if there's anything left, take it". As you might guess from regular expressions, that's what the <code class="inline"><span class="i">*</span></code> means: "use everything remaining".</p> <ul> <li> <p>Be warned, though, that unlike regular expressions, if the <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> template doesn't match the incoming data, Perl will scream and die.</p> </li> </ul> <p>Hence, putting it all together:</p> <pre class="verbatim" data-language="perl">my ($date, $description, $income, $expend) =
    unpack("A10xA27xA7xA*", $_);
</pre>
<p>Now, that's our data parsed. I suppose what we might want to do now is total up our income and expenditure, and add another line to the end of our ledger - in the same format - saying how much we've brought in and how much we've spent:</p> <pre class="verbatim" data-language="perl">while (&lt;&gt;) {
    my ($date, $desc, $income, $expend) =
        unpack("A10xA27xA7xA*", $_);
    $tot_income += $income;
    $tot_expend += $expend;
}

$tot_income = sprintf("%.2f", $tot_income); # Get them into 
$tot_expend = sprintf("%.2f", $tot_expend); # "financial" format

$date = POSIX::strftime("%m/%d/%Y", localtime); 

# OK, let's go:

print pack("A10xA27xA7xA*", $date, "Totals",
    $tot_income, $tot_expend);
</pre>
<p>Oh, hmm. That didn't quite work. Let's see what happened:</p> <pre class="verbatim" data-language="perl">01/24/2001 Zed's Camel Emporium                     1147.99
01/28/2001 Flea spray                                 24.99
01/29/2001 Camel rides to tourists     1235.00
03/23/2001Totals                     1235.001172.98
</pre>
<p>OK, it's a start, but what happened to the spaces? We put <code class="inline"><span class="w">x</span></code> , didn't we? Shouldn't it skip forward? Let's look at what <a href="functions/pack">pack</a> says:</p> <pre class="verbatim" data-language="perl">x   A null byte.
</pre>
<p>Urgh. No wonder. There's a big difference between "a null byte", character zero, and "a space", character 32. Perl's put something between the date and the description - but unfortunately, we can't see it!</p> <p>What we actually need to do is expand the width of the fields. The <code class="inline"><span class="w">A</span></code> format pads any non-existent characters with spaces, so we can use the additional spaces to line up our fields, like this:</p> <pre class="verbatim" data-language="perl">print pack("A11 A28 A8 A*", $date, "Totals",
    $tot_income, $tot_expend);
</pre>
<p>(Note that you can put spaces in the template to make it more readable, but they don't translate to spaces in the output.) Here's what we got this time:</p> <pre class="verbatim" data-language="perl">01/24/2001 Zed's Camel Emporium                     1147.99
01/28/2001 Flea spray                                 24.99
01/29/2001 Camel rides to tourists     1235.00
03/23/2001 Totals                      1235.00 1172.98
</pre>
<p>That's a bit better, but we still have that last column which needs to be moved further over. There's an easy way to fix this up: unfortunately, we can't get <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> to right-justify our fields, but we can get <code class="inline"><a class="l_k" href="functions/sprintf">sprintf</a></code> to do it:</p> <pre class="verbatim" data-language="perl">$tot_income = sprintf("%.2f", $tot_income); 
$tot_expend = sprintf("%12.2f", $tot_expend);
$date = POSIX::strftime("%m/%d/%Y", localtime); 
print pack("A11 A28 A8 A*", $date, "Totals",
    $tot_income, $tot_expend);
</pre>
<p>This time we get the right answer:</p> <pre class="verbatim" data-language="perl">01/28/2001 Flea spray                                 24.99
01/29/2001 Camel rides to tourists     1235.00
03/23/2001 Totals                      1235.00      1172.98
</pre>
<p>So that's how we consume and produce fixed-width data. Let's recap what we've seen of <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> and <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> so far:</p> <ul> <li> <p>Use <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> to go from several pieces of data to one fixed-width version; use <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> to turn a fixed-width-format string into several pieces of data.</p> </li> <li> <p>The pack format <code class="inline"><span class="w">A</span></code> means "any character"; if you're <code class="inline"><a class="l_k" href="functions/pack">pack</a></code>ing and you've run out of things to pack, <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> will fill the rest up with spaces.</p> </li> <li> <p><code class="inline"><span class="w">x</span></code> means "skip a byte" when <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code>ing; when <code class="inline"><a class="l_k" href="functions/pack">pack</a></code>ing, it means "introduce a null byte" - that's probably not what you mean if you're dealing with plain text.</p> </li> <li> <p>You can follow the formats with numbers to say how many characters should be affected by that format: <code class="inline"><span class="w">A12</span></code> means "take 12 characters"; <code class="inline"><span class="w">x6</span></code> means "skip 6 bytes" or "character 0, 6 times".</p> </li> <li> <p>Instead of a number, you can use <code class="inline"><span class="i">*</span></code> to mean "consume everything else left".</p> <p><b>Warning</b>: when packing multiple pieces of data, <code class="inline"><span class="i">*</span></code> only means "consume all of the current piece of data". That's to say</p> <pre class="verbatim" data-language="perl">pack("A*A*", $one, $two)
</pre>
<p>packs all of <code class="inline"><span class="i">$one</span></code> into the first <code class="inline"><span class="w">A</span>*</code> and then all of <code class="inline"><span class="i">$two</span></code> into the second. This is a general principle: each format character corresponds to one piece of data to be <code class="inline"><a class="l_k" href="functions/pack">pack</a></code>ed.</p> </li> </ul> <h2 id="Packing-Numbers">Packing Numbers</h2> <p>So much for textual data. Let's get onto the meaty stuff that <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> and <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> are best at: handling binary formats for numbers. There is, of course, not just one binary format - life would be too simple - but Perl will do all the finicky labor for you.</p> <h3 id="Integers">Integers</h3> <p>Packing and unpacking numbers implies conversion to and from some <i>specific</i> binary representation. Leaving floating point numbers aside for the moment, the salient properties of any such representation are:</p> <ul> <li> <p>the number of bytes used for storing the integer,</p> </li> <li> <p>whether the contents are interpreted as a signed or unsigned number,</p> </li> <li> <p>the byte ordering: whether the first byte is the least or most significant byte (or: little-endian or big-endian, respectively).</p> </li> </ul> <p>So, for instance, to pack 20302 to a signed 16 bit integer in your computer's representation you write</p> <pre class="verbatim" data-language="perl">my $ps = pack( 's', 20302 );
</pre>
<p>Again, the result is a string, now containing 2 bytes. If you print this string (which is, generally, not recommended) you might see <code class="inline"><span class="w">ON</span></code> or <code class="inline"><span class="w">NO</span></code> (depending on your system's byte ordering) - or something entirely different if your computer doesn't use ASCII character encoding. Unpacking <code class="inline"><span class="i">$ps</span></code> with the same template returns the original integer value:</p> <pre class="verbatim" data-language="perl">my( $s ) = unpack( 's', $ps );
</pre>
<p>This is true for all numeric template codes. But don't expect miracles: if the packed value exceeds the allotted byte capacity, high order bits are silently discarded, and unpack certainly won't be able to pull them back out of some magic hat. And, when you pack using a signed template code such as <code class="inline"><a class="l_k" href="functions/s">s</a></code>, an excess value may result in the sign bit getting set, and unpacking this will smartly return a negative value.</p> <p>16 bits won't get you too far with integers, but there is <code class="inline"><span class="w">l</span></code> and <code class="inline"><span class="w">L</span></code> for signed and unsigned 32-bit integers. And if this is not enough and your system supports 64 bit integers you can push the limits much closer to infinity with pack codes <code class="inline"><a class="l_k" href="functions/q">q</a></code> and <code class="inline"><span class="w">Q</span></code> . A notable exception is provided by pack codes <code class="inline"><span class="w">i</span></code> and <code class="inline"><span class="w">I</span></code> for signed and unsigned integers of the "local custom" variety: Such an integer will take up as many bytes as a local C compiler returns for <code class="inline"><span class="i">sizeof</span><span class="s">(</span><a class="l_k" href="functions/int">int</a><span class="s">)</span></code> , but it'll use <i>at least</i> 32 bits.</p> <p>Each of the integer pack codes <code class="inline"><span class="w">sSlLqQ</span></code> results in a fixed number of bytes, no matter where you execute your program. This may be useful for some applications, but it does not provide for a portable way to pass data structures between Perl and C programs (bound to happen when you call XS extensions or the Perl function <code class="inline"><a class="l_k" href="functions/syscall">syscall</a></code>), or when you read or write binary files. What you'll need in this case are template codes that depend on what your local C compiler compiles when you code <code class="inline"><span class="w">short</span></code> or <code class="inline"><span class="w">unsigned</span> <span class="w">long</span></code> , for instance. These codes and their corresponding byte lengths are shown in the table below. Since the C standard leaves much leeway with respect to the relative sizes of these data types, actual values may vary, and that's why the values are given as expressions in C and Perl. (If you'd like to use values from <code class="inline"><span class="i">%Config</span></code> in your program you have to import it with <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="w">Config</span></code> .)</p> <pre class="verbatim" data-language="perl">signed unsigned  byte length in C   byte length in Perl       
  s!     S!      sizeof(short)      $Config{shortsize}
  i!     I!      sizeof(int)        $Config{intsize}
  l!     L!      sizeof(long)       $Config{longsize}
  q!     Q!      sizeof(long long)  $Config{longlongsize}
</pre>
<p>The <code class="inline"><span class="w">i</span>!</code> and <code class="inline"><span class="w">I</span>!</code> codes aren't different from <code class="inline"><span class="w">i</span></code> and <code class="inline"><span class="w">I</span></code> ; they are tolerated for completeness' sake.</p> <h3 id="Unpacking-a-Stack-Frame">Unpacking a Stack Frame</h3> <p>Requesting a particular byte ordering may be necessary when you work with binary data coming from some specific architecture whereas your program could run on a totally different system. As an example, assume you have 24 bytes containing a stack frame as it happens on an Intel 8086:</p> <pre class="verbatim" data-language="perl">     +---------+        +----+----+               +---------+
TOS: |   IP    |  TOS+4:| FL | FH | FLAGS  TOS+14:|   SI    |
     +---------+        +----+----+               +---------+
     |   CS    |        | AL | AH | AX            |   DI    |
     +---------+        +----+----+               +---------+
                        | BL | BH | BX            |   BP    |
                        +----+----+               +---------+
                        | CL | CH | CX            |   DS    |
                        +----+----+               +---------+
                        | DL | DH | DX            |   ES    |
                        +----+----+               +---------+
</pre>
<p>First, we note that this time-honored 16-bit CPU uses little-endian order, and that's why the low order byte is stored at the lower address. To unpack such a (unsigned) short we'll have to use code <code class="inline"><span class="w">v</span></code> . A repeat count unpacks all 12 shorts:</p> <pre class="verbatim" data-language="perl">my( $ip, $cs, $flags, $ax, $bx, $cd, $dx, $si, $di, $bp, $ds, $es ) =
  unpack( 'v12', $frame );
</pre>
<p>Alternatively, we could have used <code class="inline"><span class="w">C</span></code> to unpack the individually accessible byte registers FL, FH, AL, AH, etc.:</p> <pre class="verbatim" data-language="perl">my( $fl, $fh, $al, $ah, $bl, $bh, $cl, $ch, $dl, $dh ) =
  unpack( 'C10', substr( $frame, 4, 10 ) );
</pre>
<p>It would be nice if we could do this in one fell swoop: unpack a short, back up a little, and then unpack 2 bytes. Since Perl <i>is</i> nice, it proffers the template code <code class="inline"><span class="w">X</span></code> to back up one byte. Putting this all together, we may now write:</p> <pre class="verbatim" data-language="perl">my( $ip, $cs,
    $flags,$fl,$fh,
    $ax,$al,$ah, $bx,$bl,$bh, $cx,$cl,$ch, $dx,$dl,$dh, 
    $si, $di, $bp, $ds, $es ) =
unpack( 'v2' . ('vXXCC' x 5) . 'v5', $frame );
</pre>
<p>(The clumsy construction of the template can be avoided - just read on!)</p> <p>We've taken some pains to construct the template so that it matches the contents of our frame buffer. Otherwise we'd either get undefined values, or <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> could not unpack all. If <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> runs out of items, it will supply null strings (which are coerced into zeroes whenever the pack code says so).</p> <h3 id="How-to-Eat-an-Egg-on-a-Net">How to Eat an Egg on a Net</h3> <p>The pack code for big-endian (high order byte at the lowest address) is <code class="inline"><span class="w">n</span></code> for 16 bit and <code class="inline"><span class="w">N</span></code> for 32 bit integers. You use these codes if you know that your data comes from a compliant architecture, but, surprisingly enough, you should also use these pack codes if you exchange binary data, across the network, with some system that you know next to nothing about. The simple reason is that this order has been chosen as the <i>network order</i>, and all standard-fearing programs ought to follow this convention. (This is, of course, a stern backing for one of the Lilliputian parties and may well influence the political development there.) So, if the protocol expects you to send a message by sending the length first, followed by just so many bytes, you could write:</p> <pre class="verbatim" data-language="perl">my $buf = pack( 'N', length( $msg ) ) . $msg;
</pre>
<p>or even:</p> <pre class="verbatim" data-language="perl">my $buf = pack( 'NA*', length( $msg ), $msg );
</pre>
<p>and pass <code class="inline"><span class="i">$buf</span></code> to your send routine. Some protocols demand that the count should include the length of the count itself: then just add 4 to the data length. (But make sure to read <a href="#Lengths-and-Widths">Lengths and Widths</a> before you really code this!)</p> <h3 id="Byte-order-modifiers">Byte-order modifiers</h3> <p>In the previous sections we've learned how to use <code class="inline"><span class="w">n</span></code> , <code class="inline"><span class="w">N</span></code> , <code class="inline"><span class="w">v</span></code> and <code class="inline"><span class="w">V</span></code> to pack and unpack integers with big- or little-endian byte-order. While this is nice, it's still rather limited because it leaves out all kinds of signed integers as well as 64-bit integers. For example, if you wanted to unpack a sequence of signed big-endian 16-bit integers in a platform-independent way, you would have to write:</p> <pre class="verbatim" data-language="perl">my @data = unpack 's*', pack 'S*', unpack 'n*', $buf;
</pre>
<p>This is ugly. As of Perl 5.9.2, there's a much nicer way to express your desire for a certain byte-order: the <code class="inline">&gt;</code> and <code class="inline">&lt;</code> modifiers. <code class="inline">&gt;</code> is the big-endian modifier, while <code class="inline">&lt;</code> is the little-endian modifier. Using them, we could rewrite the above code as:</p> <pre class="verbatim" data-language="perl">my @data = unpack 's&gt;*', $buf;
</pre>
<p>As you can see, the "big end" of the arrow touches the <code class="inline"><a class="l_k" href="functions/s">s</a></code>, which is a nice way to remember that <code class="inline">&gt;</code> is the big-endian modifier. The same obviously works for <code class="inline">&lt;</code> , where the "little end" touches the code.</p> <p>You will probably find these modifiers even more useful if you have to deal with big- or little-endian C structures. Be sure to read <a href="#Packing-and-Unpacking-C-Structures">Packing and Unpacking C Structures</a> for more on that.</p> <h3 id="Floating-point-Numbers">Floating point Numbers</h3> <p>For packing floating point numbers you have the choice between the pack codes <code class="inline"><span class="w">f</span></code> , <code class="inline"><span class="w">d</span></code> , <code class="inline"><span class="w">F</span></code> and <code class="inline"><span class="w">D</span></code> . <code class="inline"><span class="w">f</span></code> and <code class="inline"><span class="w">d</span></code> pack into (or unpack from) single-precision or double-precision representation as it is provided by your system. If your systems supports it, <code class="inline"><span class="w">D</span></code> can be used to pack and unpack (<code class="inline"><span class="w">long</span> <span class="w">double</span></code> ) values, which can offer even more resolution than <code class="inline"><span class="w">f</span></code> or <code class="inline"><span class="w">d</span></code> . <b>Note that there are different long double formats.</b></p> <p><code class="inline"><span class="w">F</span></code> packs an <code class="inline"><span class="w">NV</span></code> , which is the floating point type used by Perl internally.</p> <p>There is no such thing as a network representation for reals, so if you want to send your real numbers across computer boundaries, you'd better stick to text representation, possibly using the hexadecimal float format (avoiding the decimal conversion loss), unless you're absolutely sure what's on the other end of the line. For the even more adventuresome, you can use the byte-order modifiers from the previous section also on floating point codes.</p> <h2 id="Exotic-Templates">Exotic Templates</h2> <h3 id="Bit-Strings">Bit Strings</h3> <p>Bits are the atoms in the memory world. Access to individual bits may have to be used either as a last resort or because it is the most convenient way to handle your data. Bit string (un)packing converts between strings containing a series of <code class="inline"><span class="n">0</span></code> and <code class="inline"><span class="n">1</span></code> characters and a sequence of bytes each containing a group of 8 bits. This is almost as simple as it sounds, except that there are two ways the contents of a byte may be written as a bit string. Let's have a look at an annotated byte:</p> <pre class="verbatim" data-language="perl">  7 6 5 4 3 2 1 0
+-----------------+
| 1 0 0 0 1 1 0 0 |
+-----------------+
 MSB           LSB
</pre>
<p>It's egg-eating all over again: Some think that as a bit string this should be written "10001100" i.e. beginning with the most significant bit, others insist on "00110001". Well, Perl isn't biased, so that's why we have two bit string codes:</p> <pre class="verbatim" data-language="perl">$byte = pack( 'B8', '10001100' ); # start with MSB
$byte = pack( 'b8', '00110001' ); # start with LSB
</pre>
<p>It is not possible to pack or unpack bit fields - just integral bytes. <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> always starts at the next byte boundary and "rounds up" to the next multiple of 8 by adding zero bits as required. (If you do want bit fields, there is <a href="functions/vec">vec</a>. Or you could implement bit field handling at the character string level, using split, substr, and concatenation on unpacked bit strings.)</p> <p>To illustrate unpacking for bit strings, we'll decompose a simple status register (a "-" stands for a "reserved" bit):</p> <pre class="verbatim" data-language="perl">+-----------------+-----------------+
| S Z - A - P - C | - - - - O D I T |
+-----------------+-----------------+
 MSB           LSB MSB           LSB
</pre>
<p>Converting these two bytes to a string can be done with the unpack template <code class="inline"><span class="q">'b16'</span></code> . To obtain the individual bit values from the bit string we use <code class="inline"><a class="l_k" href="functions/split">split</a></code> with the "empty" separator pattern which dissects into individual characters. Bit values from the "reserved" positions are simply assigned to <code class="inline"><a class="l_k" href="functions/undef">undef</a></code>, a convenient notation for "I don't care where this goes".</p> <pre class="verbatim" data-language="perl">($carry, undef, $parity, undef, $auxcarry, undef, $zero, $sign,
 $trace, $interrupt, $direction, $overflow) =
   split( //, unpack( 'b16', $status ) );
</pre>
<p>We could have used an unpack template <code class="inline"><span class="q">'b12'</span></code> just as well, since the last 4 bits can be ignored anyway.</p> <h3 id="Uuencoding">Uuencoding</h3> <p>Another odd-man-out in the template alphabet is <code class="inline"><span class="w">u</span></code> , which packs a "uuencoded string". ("uu" is short for Unix-to-Unix.) Chances are that you won't ever need this encoding technique which was invented to overcome the shortcomings of old-fashioned transmission mediums that do not support other than simple ASCII data. The essential recipe is simple: Take three bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to each. Repeat until all of the data is blended. Fold groups of 4 bytes into lines no longer than 60 and garnish them in front with the original byte count (incremented by 0x20) and a <code class="inline"><span class="q">"\n"</span></code> at the end. - The <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> chef will prepare this for you, a la minute, when you select pack code <code class="inline"><span class="w">u</span></code> on the menu:</p> <pre class="verbatim" data-language="perl">my $uubuf = pack( 'u', $bindat );
</pre>
<p>A repeat count after <code class="inline"><span class="w">u</span></code> sets the number of bytes to put into an uuencoded line, which is the maximum of 45 by default, but could be set to some (smaller) integer multiple of three. <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> simply ignores the repeat count.</p> <h3 id="Doing-Sums">Doing Sums</h3> <p>An even stranger template code is <code class="inline"><span class="i">%</span></code> &lt;<i>number</i>&gt;. First, because it's used as a prefix to some other template code. Second, because it cannot be used in <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> at all, and third, in <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code>, doesn't return the data as defined by the template code it precedes. Instead it'll give you an integer of <i>number</i> bits that is computed from the data value by doing sums. For numeric unpack codes, no big feat is achieved:</p> <pre class="verbatim" data-language="perl">my $buf = pack( 'iii', 100, 20, 3 );
print unpack( '%32i3', $buf ), "\n";  # prints 123
</pre>
<p>For string values, <code class="inline"><span class="i">%</span></code> returns the sum of the byte values saving you the trouble of a sum loop with <code class="inline"><a class="l_k" href="functions/substr">substr</a></code> and <code class="inline"><a class="l_k" href="functions/ord">ord</a></code>:</p> <pre class="verbatim" data-language="perl">print unpack( '%32A*', "\x01\x10" ), "\n";  # prints 17
</pre>
<p>Although the <code class="inline"><span class="i">%</span></code> code is documented as returning a "checksum": don't put your trust in such values! Even when applied to a small number of bytes, they won't guarantee a noticeable Hamming distance.</p> <p>In connection with <code class="inline"><span class="w">b</span></code> or <code class="inline"><span class="w">B</span></code> , <code class="inline"><span class="i">%</span></code> simply adds bits, and this can be put to good use to count set bits efficiently:</p> <pre class="verbatim" data-language="perl">my $bitcount = unpack( '%32b*', $mask );
</pre>
<p>And an even parity bit can be determined like this:</p> <pre class="verbatim" data-language="perl">my $evenparity = unpack( '%1b*', $mask );
</pre>
<h3 id="Unicode">Unicode</h3> <p>Unicode is a character set that can represent most characters in most of the world's languages, providing room for over one million different characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin characters are assigned to the numbers 0 - 127. The Latin-1 Supplement with characters that are used in several European languages is in the next range, up to 255. After some more Latin extensions we find the character sets from languages using non-Roman alphabets, interspersed with a variety of symbol sets such as currency symbols, Zapf Dingbats or Braille. (You might want to visit <a href="http://www.unicode.org/">http://www.unicode.org/</a> for a look at some of them - my personal favourites are Telugu and Kannada.)</p> <p>The Unicode character sets associates characters with integers. Encoding these numbers in an equal number of bytes would more than double the requirements for storing texts written in Latin alphabets. The UTF-8 encoding avoids this by storing the most common (from a western point of view) characters in a single byte while encoding the rarer ones in three or more bytes.</p> <p>Perl uses UTF-8, internally, for most Unicode strings.</p> <p>So what has this got to do with <code class="inline"><a class="l_k" href="functions/pack">pack</a></code>? Well, if you want to compose a Unicode string (that is internally encoded as UTF-8), you can do so by using template code <code class="inline"><span class="w">U</span></code> . As an example, let's produce the Euro currency symbol (code number 0x20AC):</p> <pre class="verbatim" data-language="perl">$UTF8{Euro} = pack( 'U', 0x20AC );
# Equivalent to: $UTF8{Euro} = "\x{20ac}";
</pre>
<p>Inspecting <code class="inline"><span class="i">$UTF8</span>{<span class="w">Euro</span>}</code> shows that it contains 3 bytes: "\xe2\x82\xac". However, it contains only 1 character, number 0x20AC. The round trip can be completed with <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code>:</p> <pre class="verbatim" data-language="perl">$Unicode{Euro} = unpack( 'U', $UTF8{Euro} );
</pre>
<p>Unpacking using the <code class="inline"><span class="w">U</span></code> template code also works on UTF-8 encoded byte strings.</p> <p>Usually you'll want to pack or unpack UTF-8 strings:</p> <pre class="verbatim" data-language="perl"># pack and unpack the Hebrew alphabet
my $alefbet = pack( 'U*', 0x05d0..0x05ea );
my @hebrew = unpack( 'U*', $utf );
</pre>
<p>Please note: in the general case, you're better off using Encode::decode_utf8 to decode a UTF-8 encoded byte string to a Perl Unicode string, and Encode::encode_utf8 to encode a Perl Unicode string to UTF-8 bytes. These functions provide means of handling invalid byte sequences and generally have a friendlier interface.</p> <h3 id="Another-Portable-Binary-Encoding">Another Portable Binary Encoding</h3> <p>The pack code <code class="inline"><span class="w">w</span></code> has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at <a href="http://Casbah.org/">http://Casbah.org/</a>, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</p> <pre class="verbatim" data-language="perl">my $berbuf = pack( 'w*', 1, 128, 128+1, 128*128+127 );
</pre>
<p>A hex dump of <code class="inline"><span class="i">$berbuf</span></code> , with spaces inserted at the right places, shows 01 8100 8101 81807F. Since the last byte is always less than 128, <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> knows where to stop.</p> <h2 id="Template-Grouping">Template Grouping</h2> <p>Prior to Perl 5.8, repetitions of templates had to be made by <code class="inline"><span class="w">x</span></code> -multiplication of template strings. Now there is a better way as we may use the pack codes <code class="inline">(</code> and <code class="inline">)</code> combined with a repeat count. The <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> template from the Stack Frame example can simply be written like this:</p> <pre class="verbatim" data-language="perl">unpack( 'v2 (vXXCC)5 v5', $frame )
</pre>
<p>Let's explore this feature a little more. We'll begin with the equivalent of</p> <pre class="verbatim" data-language="perl">join( '', map( substr( $_, 0, 1 ), @str ) )
</pre>
<p>which returns a string consisting of the first character from each string. Using pack, we can write</p> <pre class="verbatim" data-language="perl">pack( '(A)'.@str, @str )
</pre>
<p>or, because a repeat count <code class="inline"><span class="i">*</span></code> means "repeat as often as required", simply</p> <pre class="verbatim" data-language="perl">pack( '(A)*', @str )
</pre>
<p>(Note that the template <code class="inline"><span class="w">A</span>*</code> would only have packed <code class="inline"><span class="i">$str</span>[<span class="n">0</span>]</code> in full length.)</p> <p>To pack dates stored as triplets ( day, month, year ) in an array <code class="inline"><span class="i">@dates</span></code> into a sequence of byte, byte, short integer we can write</p> <pre class="verbatim" data-language="perl">$pd = pack( '(CCS)*', map( @$_, @dates ) );
</pre>
<p>To swap pairs of characters in a string (with even length) one could use several techniques. First, let's use <code class="inline"><span class="w">x</span></code> and <code class="inline"><span class="w">X</span></code> to skip forward and back:</p> <pre class="verbatim" data-language="perl">$s = pack( '(A)*', unpack( '(xAXXAx)*', $s ) );
</pre>
<p>We can also use <code class="inline"><span class="i">@</span></code> to jump to an offset, with 0 being the position where we were when the last <code class="inline">(</code> was encountered:</p> <pre class="verbatim" data-language="perl">$s = pack( '(A)*', unpack( '(@1A @0A @2)*', $s ) );
</pre>
<p>Finally, there is also an entirely different approach by unpacking big endian shorts and packing them in the reverse byte order:</p> <pre class="verbatim" data-language="perl">$s = pack( '(v)*', unpack( '(n)*', $s );
</pre>
<h2 id="Lengths-and-Widths">Lengths and Widths</h2> <h3 id="String-Lengths">String Lengths</h3> <p>In the previous section we've seen a network message that was constructed by prefixing the binary message length to the actual message. You'll find that packing a length followed by so many bytes of data is a frequently used recipe since appending a null byte won't work if a null byte may be part of the data. Here is an example where both techniques are used: after two null terminated strings with source and destination address, a Short Message (to a mobile phone) is sent after a length byte:</p> <pre class="verbatim" data-language="perl">my $msg = pack( 'Z*Z*CA*', $src, $dst, length( $sm ), $sm );
</pre>
<p>Unpacking this message can be done with the same template:</p> <pre class="verbatim" data-language="perl">( $src, $dst, $len, $sm ) = unpack( 'Z*Z*CA*', $msg );
</pre>
<p>There's a subtle trap lurking in the offing: Adding another field after the Short Message (in variable <code class="inline"><span class="i">$sm</span></code> ) is all right when packing, but this cannot be unpacked naively:</p> <pre class="verbatim" data-language="perl"># pack a message
my $msg = pack( 'Z*Z*CA*C', $src, $dst, length( $sm ), $sm, $prio );

# unpack fails - $prio remains undefined!
( $src, $dst, $len, $sm, $prio ) = unpack( 'Z*Z*CA*C', $msg );
</pre>
<p>The pack code <code class="inline"><span class="w">A</span>*</code> gobbles up all remaining bytes, and <code class="inline"><span class="i">$prio</span></code> remains undefined! Before we let disappointment dampen the morale: Perl's got the trump card to make this trick too, just a little further up the sleeve. Watch this:</p> <pre class="verbatim" data-language="perl"># pack a message: ASCIIZ, ASCIIZ, length/string, byte
my $msg = pack( 'Z* Z* C/A* C', $src, $dst, $sm, $prio );

# unpack
( $src, $dst, $sm, $prio ) = unpack( 'Z* Z* C/A* C', $msg );
</pre>
<p>Combining two pack codes with a slash (<code class="inline">/</code>) associates them with a single value from the argument list. In <code class="inline"><a class="l_k" href="functions/pack">pack</a></code>, the length of the argument is taken and packed according to the first code while the argument itself is added after being converted with the template code after the slash. This saves us the trouble of inserting the <code class="inline"><a class="l_k" href="functions/length">length</a></code> call, but it is in <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> where we really score: The value of the length byte marks the end of the string to be taken from the buffer. Since this combination doesn't make sense except when the second pack code isn't <code class="inline"><span class="w">a</span>*</code> , <code class="inline"><span class="w">A</span>*</code> or <code class="inline"><span class="w">Z</span>*</code> , Perl won't let you.</p> <p>The pack code preceding <code class="inline">/</code> may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as <code class="inline"><span class="w">A4</span></code> or <code class="inline"><span class="w">Z</span>*</code> :</p> <pre class="verbatim" data-language="perl"># pack/unpack a string preceded by its length in ASCII
my $buf = pack( 'A4/A*', "Humpty-Dumpty" );
# unpack $buf: '13  Humpty-Dumpty'
my $txt = unpack( 'A4/A*', $buf );
</pre>
<p><code class="inline">/</code> is not implemented in Perls before 5.6, so if your code is required to work on older Perls you'll need to <code class="inline"><a class="l_k" href="functions/unpack">unpack</a><span class="s">(</span> <span class="q">'Z* Z* C'</span><span class="s">)</span></code> to get the length, then use it to make a new unpack string. For example</p> <pre class="verbatim" data-language="perl"># pack a message: ASCIIZ, ASCIIZ, length, string, byte
# (5.005 compatible)
my $msg = pack( 'Z* Z* C A* C', $src, $dst, length $sm, $sm, $prio );

# unpack
( undef, undef, $len) = unpack( 'Z* Z* C', $msg );
($src, $dst, $sm, $prio) = unpack ( "Z* Z* x A$len C", $msg );
</pre>
<p>But that second <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</p> <h3 id="Dynamic-Templates">Dynamic Templates</h3> <p>So far, we've seen literals used as templates. If the list of pack items doesn't have fixed length, an expression constructing the template is required (whenever, for some reason, <code class="inline"><span class="s">(</span><span class="s">)</span>*</code> cannot be used). Here's an example: To store named string values in a way that can be conveniently parsed by a C program, we create a sequence of names and null terminated ASCII strings, with <code class="inline">=</code> between the name and the value, followed by an additional delimiting null byte. Here's how:</p> <pre class="verbatim" data-language="perl">my $env = pack( '(A*A*Z*)' . keys( %Env ) . 'C',
                map( { ( $_, '=', $Env{$_} ) } keys( %Env ) ), 0 );
</pre>
<p>Let's examine the cogs of this byte mill, one by one. There's the <code class="inline"><a class="l_k" href="functions/map">map</a></code> call, creating the items we intend to stuff into the <code class="inline"><span class="i">$env</span></code> buffer: to each key (in <code class="inline"><span class="i">$_</span></code> ) it adds the <code class="inline">=</code> separator and the hash entry value. Each triplet is packed with the template code sequence <code class="inline"><span class="w">A</span>*<span class="w">A</span>*<span class="w">Z</span>*</code> that is repeated according to the number of keys. (Yes, that's what the <code class="inline"><a class="l_k" href="functions/keys">keys</a></code> function returns in scalar context.) To get the very last null byte, we add a <code class="inline"><span class="n">0</span></code> at the end of the <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> list, to be packed with <code class="inline"><span class="w">C</span></code> . (Attentive readers may have noticed that we could have omitted the 0.)</p> <p>For the reverse operation, we'll have to determine the number of items in the buffer before we can let <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> rip it apart:</p> <pre class="verbatim" data-language="perl">my $n = $env =~ tr/\0// - 1;
my %env = map( split( /=/, $_ ), unpack( "(Z*)$n", $env ) );
</pre>
<p>The <code class="inline"><a class="l_k" href="functions/tr">tr</a></code> counts the null bytes. The <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> call returns a list of name-value pairs each of which is taken apart in the <code class="inline"><a class="l_k" href="functions/map">map</a></code> block.</p> <h3 id="Counting-Repetitions">Counting Repetitions</h3> <p>Rather than storing a sentinel at the end of a data item (or a list of items), we could precede the data with a count. Again, we pack keys and values of a hash, preceding each with an unsigned short length count, and up front we store the number of pairs:</p> <pre class="verbatim" data-language="perl">my $env = pack( 'S(S/A* S/A*)*', scalar keys( %Env ), %Env );
</pre>
<p>This simplifies the reverse operation as the number of repetitions can be unpacked with the <code class="inline">/</code> code:</p> <pre class="verbatim" data-language="perl">my %env = unpack( 'S/(S/A* S/A*)', $env );
</pre>
<p>Note that this is one of the rare cases where you cannot use the same template for <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> and <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> because <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> can't determine a repeat count for a <code class="inline"><span class="s">(</span><span class="s">)</span></code> -group.</p> <h3 id="Intel-HEX">Intel HEX</h3> <p>Intel HEX is a file format for representing binary data, mostly for programming various chips, as a text file. (See <a href="http://en.wikipedia.org/wiki/.hex">http://en.wikipedia.org/wiki/.hex</a> for a detailed description, and <a href="http://en.wikipedia.org/wiki/SREC_">http://en.wikipedia.org/wiki/SREC_</a>(file_format) for the Motorola S-record format, which can be unravelled using the same technique.) Each line begins with a colon (':') and is followed by a sequence of hexadecimal characters, specifying a byte count <i>n</i> (8 bit), an address (16 bit, big endian), a record type (8 bit), <i>n</i> data bytes and a checksum (8 bit) computed as the least significant byte of the two's complement sum of the preceding bytes. Example: <code class="inline">:0300300002337A1E</code>.</p> <p>The first step of processing such a line is the conversion, to binary, of the hexadecimal data, to obtain the four fields, while checking the checksum. No surprise here: we'll start with a simple <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> call to convert everything to binary:</p> <pre class="verbatim" data-language="perl">my $binrec = pack( 'H*', substr( $hexrec, 1 ) );
</pre>
<p>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the <code class="inline"><a class="l_k" href="functions/ord">ord</a></code> values of this string's bytes - the <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> code <code class="inline"><span class="i">%</span></code> is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</p> <pre class="verbatim" data-language="perl">die unless unpack( "%8C*", $binrec ) == 0;
</pre>
<p>Finally, let's get those four fields. By now, you shouldn't have any problems with the first three fields - but how can we use the byte count of the data in the first field as a length for the data field? Here the codes <code class="inline"><span class="w">x</span></code> and <code class="inline"><span class="w">X</span></code> come to the rescue, as they permit jumping back and forth in the string to unpack.</p> <pre class="verbatim" data-language="perl">my( $addr, $type, $data ) = unpack( "x n C X4 C x3 /a", $bin );
</pre>
<p>Code <code class="inline"><span class="w">x</span></code> skips a byte, since we don't need the count yet. Code <code class="inline"><span class="w">n</span></code> takes care of the 16-bit big-endian integer address, and <code class="inline"><span class="w">C</span></code> unpacks the record type. Being at offset 4, where the data begins, we need the count. <code class="inline"><span class="w">X4</span></code> brings us back to square one, which is the byte at offset 0. Now we pick up the count, and zoom forth to offset 4, where we are now fully furnished to extract the exact number of data bytes, leaving the trailing checksum byte alone.</p> <h2 id="Packing-and-Unpacking-C-Structures">Packing and Unpacking C Structures</h2> <p>In previous sections we have seen how to pack numbers and character strings. If it were not for a couple of snags we could conclude this section right away with the terse remark that C structures don't contain anything else, and therefore you already know all there is to it. Sorry, no: read on, please.</p> <p>If you have to deal with a lot of C structures, and don't want to hack all your template strings manually, you'll probably want to have a look at the CPAN module <code class="inline"><span class="w">Convert::Binary::C</span></code> . Not only can it parse your C source directly, but it also has built-in support for all the odds and ends described further on in this section.</p> <h3 id="The-Alignment-Pit">The Alignment Pit</h3> <p>In the consideration of speed against memory requirements the balance has been tilted in favor of faster execution. This has influenced the way C compilers allocate memory for structures: On architectures where a 16-bit or 32-bit operand can be moved faster between places in memory, or to or from a CPU register, if it is aligned at an even or multiple-of-four or even at a multiple-of eight address, a C compiler will give you this speed benefit by stuffing extra bytes into structures. If you don't cross the C shoreline this is not likely to cause you any grief (although you should care when you design large data structures, or you want your code to be portable between architectures (you do want that, don't you?)).</p> <p>To see how this affects <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> and <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code>, we'll compare these two C structures:</p> <pre class="verbatim" data-language="perl">typedef struct {
  char     c1;
  short    s;
       char     c2;
       long     l;
} gappy_t;

typedef struct {
  long     l;
  short    s;
       char     c1;
       char     c2;
} dense_t;
</pre>
<p>Typically, a C compiler allocates 12 bytes to a <code class="inline"><span class="w">gappy_t</span></code> variable, but requires only 8 bytes for a <code class="inline"><span class="w">dense_t</span></code> . After investigating this further, we can draw memory maps, showing where the extra 4 bytes are hidden:</p> <pre class="verbatim" data-language="perl">0           +4          +8          +12
+--+--+--+--+--+--+--+--+--+--+--+--+
|c1|xx|  s  |c2|xx|xx|xx|     l     |    xx = fill byte
+--+--+--+--+--+--+--+--+--+--+--+--+
gappy_t

0           +4          +8
+--+--+--+--+--+--+--+--+
|     l     |  h  |c1|c2|
+--+--+--+--+--+--+--+--+
dense_t
</pre>
<p>And that's where the first quirk strikes: <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> and <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> templates have to be stuffed with <code class="inline"><span class="w">x</span></code> codes to get those extra fill bytes.</p> <p>The natural question: "Why can't Perl compensate for the gaps?" warrants an answer. One good reason is that C compilers might provide (non-ANSI) extensions permitting all sorts of fancy control over the way structures are aligned, even at the level of an individual structure field. And, if this were not enough, there is an insidious thing called <code class="inline"><span class="w">union</span></code> where the amount of fill bytes cannot be derived from the alignment of the next item alone.</p> <p>OK, so let's bite the bullet. Here's one way to get the alignment right by inserting template codes <code class="inline"><span class="w">x</span></code> , which don't take a corresponding item from the list:</p> <pre class="verbatim" data-language="perl">my $gappy = pack( 'cxs cxxx l!', $c1, $s, $c2, $l );
</pre>
<p>Note the <code class="inline">!</code> after <code class="inline"><span class="w">l</span></code> : We want to make sure that we pack a long integer as it is compiled by our C compiler. And even now, it will only work for the platforms where the compiler aligns things as above. And somebody somewhere has a platform where it doesn't. [Probably a Cray, where <code class="inline"><span class="w">short</span></code> s, <code class="inline"><a class="l_k" href="functions/int">int</a></code>s and <code class="inline"><span class="w">long</span></code> s are all 8 bytes. :-)]</p> <p>Counting bytes and watching alignments in lengthy structures is bound to be a drag. Isn't there a way we can create the template with a simple program? Here's a C program that does the trick:</p> <pre class="verbatim" data-language="perl">#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;

typedef struct {
  char     fc1;
  short    fs;
  char     fc2;
  long     fl;
} gappy_t;

#define Pt(struct,field,tchar) \
  printf( "@%d%s ", offsetof(struct,field), # tchar );

int main() {
  Pt( gappy_t, fc1, c  );
  Pt( gappy_t, fs,  s! );
  Pt( gappy_t, fc2, c  );
  Pt( gappy_t, fl,  l! );
  printf( "\n" );
}
</pre>
<p>The output line can be used as a template in a <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> or <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> call:</p> <pre class="verbatim" data-language="perl">my $gappy = pack( '@0c @2s! @4c @8l!', $c1, $s, $c2, $l );
</pre>
<p>Gee, yet another template code - as if we hadn't plenty. But <code class="inline"><span class="i">@</span></code> saves our day by enabling us to specify the offset from the beginning of the pack buffer to the next item: This is just the value the <code class="inline"><span class="w">offsetof</span></code> macro (defined in <code class="inline"><span class="q">&lt;stddef.h&gt;</span></code> ) returns when given a <code class="inline"><span class="w">struct</span></code> type and one of its field names ("member-designator" in C standardese).</p> <p>Neither using offsets nor adding <code class="inline"><span class="w">x</span></code> 's to bridge the gaps is satisfactory. (Just imagine what happens if the structure changes.) What we really need is a way of saying "skip as many bytes as required to the next multiple of N". In fluent Templatese, you say this with <code class="inline"><span class="w">x</span>!<span class="w">N</span></code> where N is replaced by the appropriate value. Here's the next version of our struct packaging:</p> <pre class="verbatim" data-language="perl">my $gappy = pack( 'c x!2 s c x!4 l!', $c1, $s, $c2, $l );
</pre>
<p>That's certainly better, but we still have to know how long all the integers are, and portability is far away. Rather than <code class="inline"><span class="n">2</span></code> , for instance, we want to say "however long a short is". But this can be done by enclosing the appropriate pack code in brackets: <code class="inline">[s]</code>. So, here's the very best we can do:</p> <pre class="verbatim" data-language="perl">my $gappy = pack( 'c x![s] s c x![l!] l!', $c1, $s, $c2, $l );
</pre>
<h3 id="Dealing-with-Endian-ness">Dealing with Endian-ness</h3> <p>Now, imagine that we want to pack the data for a machine with a different byte-order. First, we'll have to figure out how big the data types on the target machine really are. Let's assume that the longs are 32 bits wide and the shorts are 16 bits wide. You can then rewrite the template as:</p> <pre class="verbatim" data-language="perl">my $gappy = pack( 'c x![s] s c x![l] l', $c1, $s, $c2, $l );
</pre>
<p>If the target machine is little-endian, we could write:</p> <pre class="verbatim" data-language="perl">my $gappy = pack( 'c x![s] s&lt; c x![l] l&lt;', $c1, $s, $c2, $l );
</pre>
<p>This forces the short and the long members to be little-endian, and is just fine if you don't have too many struct members. But we could also use the byte-order modifier on a group and write the following:</p> <pre class="verbatim" data-language="perl">my $gappy = pack( '( c x![s] s c x![l] l )&lt;', $c1, $s, $c2, $l );
</pre>
<p>This is not as short as before, but it makes it more obvious that we intend to have little-endian byte-order for a whole group, not only for individual template codes. It can also be more readable and easier to maintain.</p> <h3 id="Alignment%2c-Take-2">Alignment, Take 2</h3> <p>I'm afraid that we're not quite through with the alignment catch yet. The hydra raises another ugly head when you pack arrays of structures:</p> <pre class="verbatim" data-language="perl">typedef struct {
  short    count;
  char     glyph;
} cell_t;

typedef cell_t buffer_t[BUFLEN];
</pre>
<p>Where's the catch? Padding is neither required before the first field <code class="inline"><span class="w">count</span></code> , nor between this and the next field <code class="inline"><span class="w">glyph</span></code> , so why can't we simply pack like this:</p> <pre class="verbatim" data-language="perl"># something goes wrong here:
pack( 's!a' x @buffer,
      map{ ( $_-&gt;{count}, $_-&gt;{glyph} ) } @buffer );
</pre>
<p>This packs <code class="inline"><span class="n">3</span>*<span class="i">@buffer</span></code> bytes, but it turns out that the size of <code class="inline"><span class="w">buffer_t</span></code> is four times <code class="inline"><span class="w">BUFLEN</span></code> ! The moral of the story is that the required alignment of a structure or array is propagated to the next higher level where we have to consider padding <i>at the end</i> of each component as well. Thus the correct template is:</p> <pre class="verbatim" data-language="perl">pack( 's!ax' x @buffer,
      map{ ( $_-&gt;{count}, $_-&gt;{glyph} ) } @buffer );
</pre>
<h3 id="Alignment%2c-Take-3">Alignment, Take 3</h3> <p>And even if you take all the above into account, ANSI still lets this:</p> <pre class="verbatim" data-language="perl">typedef struct {
  char     foo[2];
} foo_t;
</pre>
<p>vary in size. The alignment constraint of the structure can be greater than any of its elements. [And if you think that this doesn't affect anything common, dismember the next cellphone that you see. Many have ARM cores, and the ARM structure rules make <code class="inline"><span class="w">sizeof</span> <span class="s">(</span><span class="w">foo_t</span><span class="s">)</span></code> == 4]</p> <h3 id="Pointers-for-How-to-Use-Them">Pointers for How to Use Them</h3> <p>The title of this section indicates the second problem you may run into sooner or later when you pack C structures. If the function you intend to call expects a, say, <code class="inline"><span class="w">void</span> *</code> value, you <i>cannot</i> simply take a reference to a Perl variable. (Although that value certainly is a memory address, it's not the address where the variable's contents are stored.)</p> <p>Template code <code class="inline"><span class="w">P</span></code> promises to pack a "pointer to a fixed length string". Isn't this what we want? Let's try:</p> <pre class="verbatim" data-language="perl"># allocate some storage and pack a pointer to it
my $memory = "\x00" x $size;
my $memptr = pack( 'P', $memory );
</pre>
<p>But wait: doesn't <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by <code class="inline"><a class="l_k" href="functions/pack">pack</a></code>.</p> <pre class="verbatim" data-language="perl">my $ptr = unpack( 'L!', $memptr );
</pre>
<p>Obviously this assumes that it is possible to typecast a pointer to an unsigned long and vice versa, which frequently works but should not be taken as a universal law. - Now that we have this pointer the next question is: How can we put it to good use? We need a call to some C function where a pointer is expected. The read(2) system call comes to mind:</p> <pre class="verbatim" data-language="perl">ssize_t read(int fd, void *buf, size_t count);
</pre>
<p>After reading <a href="perlfunc">perlfunc</a> explaining how to use <code class="inline"><a class="l_k" href="functions/syscall">syscall</a></code> we can write this Perl function copying a file to standard output:</p> <pre class="verbatim" data-language="perl">require 'syscall.ph'; # run h2ph to generate this file
sub cat($){
    my $path = shift();
    my $size = -s $path;
    my $memory = "\x00" x $size;  # allocate some memory
    my $ptr = unpack( 'L', pack( 'P', $memory ) );
    open( F, $path ) || die( "$path: cannot open ($!)\n" );
    my $fd = fileno(F);
    my $res = syscall( &amp;SYS_read, fileno(F), $ptr, $size );
    print $memory;
    close( F );
}
</pre>
<p>This is neither a specimen of simplicity nor a paragon of portability but it illustrates the point: We are able to sneak behind the scenes and access Perl's otherwise well-guarded memory! (Important note: Perl's <code class="inline"><a class="l_k" href="functions/syscall">syscall</a></code> does <i>not</i> require you to construct pointers in this roundabout way. You simply pass a string variable, and Perl forwards the address.)</p> <p>How does <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> with <code class="inline"><span class="w">P</span></code> work? Imagine some pointer in the buffer about to be unpacked: If it isn't the null pointer (which will smartly produce the <code class="inline"><a class="l_k" href="functions/undef">undef</a></code> value) we have a start address - but then what? Perl has no way of knowing how long this "fixed length string" is, so it's up to you to specify the actual size as an explicit length after <code class="inline"><span class="w">P</span></code> .</p> <pre class="verbatim" data-language="perl">my $mem = "abcdefghijklmn";
print unpack( 'P5', pack( 'P', $mem ) ); # prints "abcde"
</pre>
<p>As a consequence, <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> ignores any number or <code class="inline"><span class="i">*</span></code> after <code class="inline"><span class="w">P</span></code> .</p> <p>Now that we have seen <code class="inline"><span class="w">P</span></code> at work, we might as well give <code class="inline"><span class="w">p</span></code> a whirl. Why do we need a second template code for packing pointers at all? The answer lies behind the simple fact that an <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code> with <code class="inline"><span class="w">p</span></code> promises a null-terminated string starting at the address taken from the buffer, and that implies a length for the data item to be returned:</p> <pre class="verbatim" data-language="perl">my $buf = pack( 'p', "abc\x00efhijklmn" );
print unpack( 'p', $buf );    # prints "abc"
</pre>
<p>Albeit this is apt to be confusing: As a consequence of the length being implied by the string's length, a number after pack code <code class="inline"><span class="w">p</span></code> is a repeat count, not a length as after <code class="inline"><span class="w">P</span></code> .</p> <p>Using <code class="inline"><a class="l_k" href="functions/pack">pack</a><span class="s">(</span>...<span class="cm">,</span> <span class="i">$x</span><span class="s">)</span></code> with <code class="inline"><span class="w">P</span></code> or <code class="inline"><span class="w">p</span></code> to get the address where <code class="inline"><span class="i">$x</span></code> is actually stored must be used with circumspection. Perl's internal machinery considers the relation between a variable and that address as its very own private matter and doesn't really care that we have obtained a copy. Therefore:</p> <ul> <li> <p>Do not use <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> with <code class="inline"><span class="w">p</span></code> or <code class="inline"><span class="w">P</span></code> to obtain the address of variable that's bound to go out of scope (and thereby freeing its memory) before you are done with using the memory at that address.</p> </li> <li> <p>Be very careful with Perl operations that change the value of the variable. Appending something to the variable, for instance, might require reallocation of its storage, leaving you with a pointer into no-man's land.</p> </li> <li> <p>Don't think that you can get the address of a Perl variable when it is stored as an integer or double number! <code class="inline"><a class="l_k" href="functions/pack">pack</a><span class="s">(</span><span class="q">'P'</span><span class="cm">,</span> <span class="i">$x</span><span class="s">)</span></code> will force the variable's internal representation to string, just as if you had written something like <code class="inline"><span class="i">$x</span> .= <span class="q">''</span></code> .</p> </li> </ul> <p>It's safe, however, to P- or p-pack a string literal, because Perl simply allocates an anonymous variable.</p> <h2 id="Pack-Recipes">Pack Recipes</h2> <p>Here are a collection of (possibly) useful canned recipes for <code class="inline"><a class="l_k" href="functions/pack">pack</a></code> and <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code>:</p> <pre class="verbatim" data-language="perl"># Convert IP address for socket functions
pack( "C4", split /\./, "123.4.5.6" ); 

# Count the bits in a chunk of memory (e.g. a select vector)
unpack( '%32b*', $mask );

# Determine the endianness of your system
$is_little_endian = unpack( 'c', pack( 's', 1 ) );
$is_big_endian = unpack( 'xc', pack( 's', 1 ) );

# Determine the number of bits in a native integer
$bits = unpack( '%32I!', ~0 );

# Prepare argument for the nanosleep system call
my $timespec = pack( 'L!L!', $secs, $nanosecs );
</pre>
<p>For a simple memory dump we unpack some bytes into just as many pairs of hex digits, and use <code class="inline"><a class="l_k" href="functions/map">map</a></code> to handle the traditional spacing - 16 bytes to a line:</p> <pre class="verbatim" data-language="perl">my $i;
print map( ++$i % 16 ? "$_ " : "$_\n",
           unpack( 'H2' x length( $mem ), $mem ) ),
      length( $mem ) % 16 ? "\n" : '';
</pre>
<h2 id="Funnies-Section">Funnies Section</h2> <pre class="verbatim" data-language="perl"># Pulling digits out of nowhere...
print unpack( 'C', pack( 'x' ) ),
      unpack( '%B*', pack( 'A' ) ),
      unpack( 'H', pack( 'A' ) ),
      unpack( 'A', unpack( 'C', pack( 'A' ) ) ), "\n";

# One for the road ;-)
my $advice = pack( 'all u can in a van' );
</pre>
<h2 id="Authors">Authors</h2> <p>Simon Cozens and Wolfgang Laun.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1993–2016 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.26.0/perlpacktut.html" class="_attribution-link">https://perldoc.perl.org/5.26.0/perlpacktut.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
