
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Open - Perl 5.26 - W3cubDocs</title>
  
  <meta name="description" content=" Opens the file whose filename is given by EXPR, and associates it with FILEHANDLE. ">
  <meta name="keywords" content="open, perl, perl~5.26">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/perl~5.26/functions/open.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/perl~5.26.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/perl~5.26/" class="_nav-link" title="" style="margin-left:0;">Perl 5.26</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _perl">
				
				
<h1>open</h1>   <h2 id="open-FILEHANDLE%2cEXPR">open FILEHANDLE,EXPR</h2>   <h2 id="open-FILEHANDLE%2cMODE%2cEXPR">open FILEHANDLE,MODE,EXPR</h2> <h2 id="open-FILEHANDLE%2cMODE%2cEXPR%2cLIST">open FILEHANDLE,MODE,EXPR,LIST</h2> <h2 id="open-FILEHANDLE%2cMODE%2cREFERENCE">open FILEHANDLE,MODE,REFERENCE</h2> <h2 id="open-FILEHANDLE">open FILEHANDLE</h2> <p>Opens the file whose filename is given by EXPR, and associates it with FILEHANDLE.</p> <p>Simple examples to open a file for reading:</p> <pre class="verbatim" data-language="perl">    open(my $fh, "&lt;", "input.txt") 
or die "cannot open &lt; input.txt: $!";
</pre>
<p>and for writing:</p> <pre class="verbatim" data-language="perl">    open(my $fh, "&gt;", "output.txt") 
or die "cannot open &gt; output.txt: $!";
</pre>
<p>(The following is a comprehensive reference to open(): for a gentler introduction you may consider <a href="../perlopentut">perlopentut</a>.)</p> <p>If FILEHANDLE is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so <code class="inline"><a class="l_k" href="use">use</a> <span class="w">strict</span> <span class="q">"refs"</span></code> should <i>not</i> be in effect.)</p> <p>If three (or more) arguments are specified, the open mode (including optional encoding) in the second argument are distinct from the filename in the third. If MODE is <code class="inline">&lt;</code> or nothing, the file is opened for input. If MODE is <code class="inline">&gt;</code>, the file is opened for output, with existing files first being truncated ("clobbered") and nonexisting files newly created. If MODE is <code class="inline">&gt;&gt;</code> , the file is opened for appending, again being created if necessary.</p> <p>You can put a <code class="inline">+</code> in front of the <code class="inline">&gt;</code> or <code class="inline">&lt;</code> to indicate that you want both read and write access to the file; thus <code class="inline">+&lt;</code> is almost always preferred for read/write updates--the <code class="inline">+&gt;</code> mode would clobber the file first. You can't usually use either read-write mode for updating textfiles, since they have variable-length records. See the <b>-i</b> switch in <a href="../perlrun">perlrun</a> for a better approach. The file is created with permissions of <code class="inline"><span class="n">0666</span></code> modified by the process's <code class="inline"><a class="l_k" href="umask">umask</a></code> value.</p> <p>These various prefixes correspond to the fopen(3) modes of <code class="inline"><span class="w">r</span></code> , <code class="inline"><span class="w">r</span>+</code> , <code class="inline"><span class="w">w</span></code> , <code class="inline"><span class="w">w</span>+</code> , <code class="inline"><span class="w">a</span></code> , and <code class="inline"><span class="w">a</span>+</code> .</p> <p>In the one- and two-argument forms of the call, the mode and filename should be concatenated (in that order), preferably separated by white space. You can--but shouldn't--omit the mode in these forms when that mode is <code class="inline">&lt;</code> . It is always safe to use the two-argument form of <code class="inline"><a class="l_k" href="open">open</a></code> if the filename argument is a known literal.</p> <p>For three or more arguments if MODE is <code class="inline">|-</code> , the filename is interpreted as a command to which output is to be piped, and if MODE is <code class="inline">-|</code> , the filename is interpreted as a command that pipes output to us. In the two-argument (and one-argument) form, one should replace dash (<code class="inline">-</code> ) with the command. See <a href="../perlipc#Using-open()-for-IPC">Using open() for IPC in perlipc</a> for more examples of this. (You are not allowed to <code class="inline"><a class="l_k" href="open">open</a></code> to a command that pipes both in <i>and</i> out, but see <a href="../ipc/open2">IPC::Open2</a>, <a href="../ipc/open3">IPC::Open3</a>, and <a href="../perlipc#Bidirectional-Communication-with-Another-Process">Bidirectional Communication with Another Process in perlipc</a> for alternatives.)</p> <p>In the form of pipe opens taking three or more arguments, if LIST is specified (extra arguments after the command name) then LIST becomes arguments to the command invoked if the platform supports it. The meaning of <code class="inline"><a class="l_k" href="open">open</a></code> with more than three arguments for non-pipe modes is not yet defined, but experimental "layers" may give extra LIST arguments meaning.</p> <p>In the two-argument (and one-argument) form, opening <code class="inline">&lt;-</code> or <code class="inline">-</code> opens STDIN and opening <code class="inline">&gt;-</code> opens STDOUT.</p> <p>You may (and usually should) use the three-argument form of open to specify I/O layers (sometimes referred to as "disciplines") to apply to the handle that affect how the input and output are processed (see <a href="../open">open</a> and <a href="../perlio">PerlIO</a> for more details). For example:</p> <pre class="verbatim" data-language="perl">open(my $fh, "&lt;:encoding(UTF-8)", "filename")
  || die "can't open UTF-8 encoded filename: $!";
</pre>
<p>opens the UTF8-encoded file containing Unicode characters; see <a href="../perluniintro">perluniintro</a>. Note that if layers are specified in the three-argument form, then default layers stored in ${^OPEN} (see <a href="../perlvar">perlvar</a>; usually set by the <b>open</b> pragma or the switch <b>-CioD</b>) are ignored. Those layers will also be ignored if you specifying a colon with no name following it. In that case the default layer for the operating system (:raw on Unix, :crlf on Windows) is used.</p> <p>Open returns nonzero on success, the undefined value otherwise. If the <code class="inline"><a class="l_k" href="open">open</a></code> involved a pipe, the return value happens to be the pid of the subprocess.</p> <p>If you're running Perl on a system that distinguishes between text files and binary files, then you should check out <a href="binmode">binmode</a> for tips for dealing with this. The key distinction between systems that need <code class="inline"><a class="l_k" href="binmode">binmode</a></code> and those that don't is their text file formats. Systems like Unix, Mac OS, and Plan 9, that end lines with a single character and encode that character in C as <code class="inline"><span class="q">"\n"</span></code> do not need <code class="inline"><a class="l_k" href="binmode">binmode</a></code>. The rest need it.</p> <p>When opening a file, it's seldom a good idea to continue if the request failed, so <code class="inline"><a class="l_k" href="open">open</a></code> is frequently used with <code class="inline"><a class="l_k" href="die">die</a></code>. Even if <code class="inline"><a class="l_k" href="die">die</a></code> won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</p> <p>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with <code class="inline"><a class="l_k" href="my">my</a></code>, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</p> <pre class="verbatim" data-language="perl">close($handle)
   || warn "close failed: $!";
</pre>
<p>An older style is to use a bareword as the filehandle, as</p> <pre class="verbatim" data-language="perl">open(FH, "&lt;", "input.txt")
   or die "cannot open &lt; input.txt: $!";
</pre>
<p>Then you can use <code class="inline"><span class="w">FH</span></code> as the filehandle, in <code class="inline"><a class="l_k" href="close">close</a> <span class="w">FH</span></code> and <code class="inline"><span class="q">&lt;FH&gt;</span></code> and so on. Note that it's a global variable, so this form is not recommended in new code.</p> <p>As a shortcut a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</p> <pre class="verbatim" data-language="perl">$ARTICLE = 100;
open(ARTICLE) or die "Can't find article $ARTICLE: $!\n";
</pre>
<p>Here <code class="inline"><span class="i">$ARTICLE</span></code> must be a global (package) scalar variable - not one declared with <code class="inline"><a class="l_k" href="my">my</a></code> or <code class="inline"><a class="l_k" href="state">state</a></code>.</p> <p>As a special case the three-argument form with a read/write mode and the third argument being <code class="inline"><a class="l_k" href="undef">undef</a></code>:</p> <pre class="verbatim" data-language="perl">open(my $tmp, "+&gt;", undef) or die ...
</pre>
<p>opens a filehandle to an anonymous temporary file. Also using <code class="inline">+&lt;</code> works for symmetry, but you really should consider writing something to the temporary file first. You will need to seek() to do the reading.</p> <p>Perl is built using PerlIO by default; Unless you've changed this (such as building Perl with <code class="inline"><span class="w">Configure</span> -<span class="w">Uuseperlio</span></code> ), you can open filehandles directly to Perl scalars via:</p> <pre class="verbatim" data-language="perl">open($fh, "&gt;", \$variable) || ..
</pre>
<p>To (re)open <code class="inline"><span class="w">STDOUT</span></code> or <code class="inline"><span class="w">STDERR</span></code> as an in-memory file, close it first:</p> <pre class="verbatim" data-language="perl">    close STDOUT;
    open(STDOUT, "&gt;", \$variable)
or die "Can't open STDOUT: $!";
</pre>
<p>General examples:</p> <pre class="verbatim" data-language="perl">open(LOG, "&gt;&gt;/usr/spool/news/twitlog");  # (log is reserved)
# if the open fails, output is discarded

open(my $dbase, "+&lt;", "dbase.mine")      # open for update
    or die "Can't open 'dbase.mine' for update: $!";

open(my $dbase, "+&lt;dbase.mine")          # ditto
    or die "Can't open 'dbase.mine' for update: $!";

open(ARTICLE, "-|", "caesar &lt;$article")  # decrypt article
    or die "Can't start caesar: $!";

open(ARTICLE, "caesar &lt;$article |")      # ditto
    or die "Can't start caesar: $!";

open(EXTRACT, "|sort &gt;Tmp$$")            # $$ is our process id
    or die "Can't start sort: $!";

# in-memory files
open(MEMORY, "&gt;", \$var)
    or die "Can't open memory file: $!";
print MEMORY "foo!\n";              # output will appear in $var

# process argument list of files along with any includes

foreach $file (@ARGV) {
    process($file, "fh00");
}

sub process {
    my($filename, $input) = @_;
    $input++;    # this is a string increment
    unless (open($input, "&lt;", $filename)) {
        print STDERR "Can't open $filename: $!\n";
        return;
    }

    local $_;
    while (&lt;$input&gt;) {    # note use of indirection
        if (/^#include "(.*)"/) {
            process($1, $input);
            next;
        }
        #...          # whatever
    }
}
</pre>
<p>See <a href="../perliol">perliol</a> for detailed info on PerlIO.</p> <p>You may also, in the Bourne shell tradition, specify an EXPR beginning with <code class="inline">&gt;&amp;</code>, in which case the rest of the string is interpreted as the name of a filehandle (or file descriptor, if numeric) to be duped (as <code class="inline"><span class="i">dup</span><span class="s">(</span><span class="n">2</span><span class="s">)</span></code> ) and opened. You may use <code class="inline"><span class="i">&amp;</span></code> after <code class="inline">&gt;</code>, <code class="inline">&gt;&gt;</code> , <code class="inline">&lt;</code> , <code class="inline">+&gt;</code>, <code class="inline">+&gt;&gt;</code> , and <code class="inline">+&lt;</code> . The mode you specify should match the mode of the original filehandle. (Duping a filehandle does not take into account any existing contents of IO buffers.) If you use the three-argument form, then you can pass either a number, the name of a filehandle, or the normal "reference to a glob".</p> <p>Here is a script that saves, redirects, and restores <code class="inline"><span class="w">STDOUT</span></code> and <code class="inline"><span class="w">STDERR</span></code> using various methods:</p> <pre class="verbatim" data-language="perl">#!/usr/bin/perl
open(my $oldout, "&gt;&amp;STDOUT")     or die "Can't dup STDOUT: $!";
open(OLDERR,     "&gt;&amp;", \*STDERR) or die "Can't dup STDERR: $!";

open(STDOUT, '&gt;', "foo.out") or die "Can't redirect STDOUT: $!";
open(STDERR, "&gt;&amp;STDOUT")     or die "Can't dup STDOUT: $!";

select STDERR; $| = 1;  # make unbuffered
select STDOUT; $| = 1;  # make unbuffered

print STDOUT "stdout 1\n";  # this works for
print STDERR "stderr 1\n";  # subprocesses too

open(STDOUT, "&gt;&amp;", $oldout) or die "Can't dup \$oldout: $!";
open(STDERR, "&gt;&amp;OLDERR")    or die "Can't dup OLDERR: $!";

print STDOUT "stdout 2\n";
print STDERR "stderr 2\n";
</pre>
<p>If you specify <code class="inline"><span class="q">'&lt;&amp;=X'</span></code> , where <code class="inline"><span class="w">X</span></code> is a file descriptor number or a filehandle, then Perl will do an equivalent of C's <code class="inline"><span class="w">fdopen</span></code> of that file descriptor (and not call <code class="inline"><span class="i">dup</span><span class="s">(</span><span class="n">2</span><span class="s">)</span></code> ); this is more parsimonious of file descriptors. For example:</p> <pre class="verbatim" data-language="perl"># open for input, reusing the fileno of $fd
open(FILEHANDLE, "&lt;&amp;=$fd")
</pre>
<p>or</p> <pre class="verbatim" data-language="perl">open(FILEHANDLE, "&lt;&amp;=", $fd)
</pre>
<p>or</p> <pre class="verbatim" data-language="perl"># open for append, using the fileno of OLDFH
open(FH, "&gt;&gt;&amp;=", OLDFH)
</pre>
<p>or</p> <pre class="verbatim" data-language="perl">open(FH, "&gt;&gt;&amp;=OLDFH")
</pre>
<p>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just <code class="inline"><a class="l_k" href="open">open</a><span class="s">(</span><span class="w">A</span><span class="cm">,</span> <span class="q">"&gt;&gt;&amp;B"</span><span class="s">)</span></code> , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with <code class="inline"><a class="l_k" href="open">open</a><span class="s">(</span><span class="w">A</span><span class="cm">,</span> <span class="q">"&gt;&gt;&amp;=B"</span><span class="s">)</span></code> , the filehandles will share the same underlying system file descriptor.</p> <p>Note that under Perls older than 5.8.0, Perl uses the standard C library's' fdopen() to implement the <code class="inline">=</code> functionality. On many Unix systems, fdopen() fails when file descriptors exceed a certain value, typically 255. For Perls 5.8.0 and later, PerlIO is (most often) the default.</p> <p>You can see whether your Perl was built with PerlIO by running <code class="inline"><span class="w">perl</span> -<span class="w">V</span></code> and looking for the <code class="inline"><span class="w">useperlio</span>=</code> line. If <code class="inline"><span class="w">useperlio</span></code> is <code class="inline"><span class="w">define</span></code> , you have PerlIO; otherwise you don't.</p> <p>If you open a pipe on the command <code class="inline">-</code> (that is, specify either <code class="inline">|-</code> or <code class="inline">-|</code> with the one- or two-argument forms of <code class="inline"><a class="l_k" href="open">open</a></code>), an implicit <code class="inline"><a class="l_k" href="fork">fork</a></code> is done, so <code class="inline"><a class="l_k" href="open">open</a></code> returns twice: in the parent process it returns the pid of the child process, and in the child process it returns (a defined) <code class="inline"><span class="n">0</span></code> . Use <code class="inline"><a class="l_k" href="defined">defined($pid)</a></code> or <code class="inline"><span class="q">//</span></code> to determine whether the open was successful.</p> <p>For example, use either</p> <pre class="verbatim" data-language="perl">$child_pid = open(FROM_KID, "-|") 	// die "can't fork: $!";
</pre>
<p>or</p> <pre class="verbatim" data-language="perl">$child_pid = open(TO_KID,   "|-") 	// die "can't fork: $!";
</pre>
<p>followed by</p> <pre class="verbatim" data-language="perl">    if ($child_pid) {
# am the parent:
# either write TO_KID or else read FROM_KID
...
       waitpid $child_pid, 0;
    } else {
# am the child; use STDIN/STDOUT normally
...
exit;
    }
</pre>
<p>The filehandle behaves normally for the parent, but I/O to that filehandle is piped from/to the STDOUT/STDIN of the child process. In the child process, the filehandle isn't opened--I/O happens from/to the new STDOUT/STDIN. Typically this is used like the normal piped open when you want to exercise more control over just how the pipe command gets executed, such as when running setuid and you don't want to have to scan shell commands for metacharacters.</p> <p>The following blocks are more or less equivalent:</p> <pre class="verbatim" data-language="perl">open(FOO, "|tr '[a-z]' '[A-Z]'");
open(FOO, "|-", "tr '[a-z]' '[A-Z]'");
open(FOO, "|-") || exec 'tr', '[a-z]', '[A-Z]';
open(FOO, "|-", "tr", '[a-z]', '[A-Z]');

open(FOO, "cat -n '$file'|");
open(FOO, "-|", "cat -n '$file'");
open(FOO, "-|") || exec "cat", "-n", $file;
open(FOO, "-|", "cat", "-n", $file);
</pre>
<p>The last two examples in each block show the pipe as "list form", which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real <code class="inline"><a class="l_k" href="fork">fork()</a></code> (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</p> <pre class="verbatim" data-language="perl">    open(FOO, "|cat -n | expand -4 | lpr")
// die "Can't open pipeline to lpr: $!";
</pre>
<p>See <a href="../perlipc#Safe-Pipe-Opens">Safe Pipe Opens in perlipc</a> for more examples of this.</p> <p>Perl will attempt to flush all files opened for output before any operation that may do a fork, but this may not be supported on some platforms (see <a href="../perlport">perlport</a>). To be safe, you may need to set <code class="inline"><span class="i">$|</span></code> ($AUTOFLUSH in English) or call the <code class="inline"><span class="i">autoflush</span><span class="s">(</span><span class="s">)</span></code> method of <code class="inline"><span class="w">IO::Handle</span></code> on any open handles.</p> <p>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of <code class="inline"><span class="i">$^F</span></code> . See <a href="../perlvar#%24%5eF">$^F in perlvar</a>.</p> <p>Closing any piped filehandle causes the parent process to wait for the child to finish, then returns the status value in <code class="inline"><span class="i">$?</span></code> and <code class="inline"><span class="i">$</span>{<span class="w">^CHILD_ERROR_NATIVE</span>}</code> .</p> <p>The filename passed to the one- and two-argument forms of open() will have leading and trailing whitespace deleted and normal redirection characters honored. This property, known as "magic open", can often be used to good effect. A user could specify a filename of <i>"rsh cat file |"</i>, or you could change certain filenames as needed:</p> <pre class="verbatim" data-language="perl">$filename =~ s/(.*\.gz)\s*$/gzip -dc &lt; $1|/;
open(FH, $filename) or die "Can't open $filename: $!";
</pre>
<p>Use the three-argument form to open a file with arbitrary weird characters in it,</p> <pre class="verbatim" data-language="perl">    open(FOO, "&lt;", $file)
|| die "can't open &lt; $file: $!";
</pre>
<p>otherwise it's necessary to protect any leading and trailing whitespace:</p> <pre class="verbatim" data-language="perl">    $file =~ s#^(\s)#./$1#;
    open(FOO, "&lt; $file\0")
|| die "open failed: $!";
</pre>
<p>(this may not work on some bizarre filesystems). One should conscientiously choose between the <i>magic</i> and <i>three-argument</i> form of open():</p> <pre class="verbatim" data-language="perl">open(IN, $ARGV[0]) || die "can't open $ARGV[0]: $!";
</pre>
<p>will allow the user to specify an argument of the form <code class="inline"><span class="q">"rsh cat file |"</span></code> , but will not work on a filename that happens to have a trailing space, while</p> <pre class="verbatim" data-language="perl">    open(IN, "&lt;", $ARGV[0])
|| die "can't open &lt; $ARGV[0]: $!";
</pre>
<p>will have exactly the opposite restrictions.</p> <p>If you want a "real" C <code class="inline"><a class="l_k" href="open">open</a></code> (see <i>open(2)</i> on your system), then you should use the <code class="inline"><a class="l_k" href="sysopen">sysopen</a></code> function, which involves no such magic (but may use subtly different filemodes than Perl open(), which is mapped to C fopen()). This is another way to protect your filenames from interpretation. For example:</p> <pre class="verbatim" data-language="perl">use IO::Handle;
sysopen(HANDLE, $path, O_RDWR|O_CREAT|O_EXCL)
    or die "sysopen $path: $!";
$oldfh = select(HANDLE); $| = 1; select($oldfh);
print HANDLE "stuff $$\n";
seek(HANDLE, 0, 0);
print "File contains: ", &lt;HANDLE&gt;;
</pre>
<p>See <a href="seek">seek</a> for some details about mixing reading and writing.</p> <p>Portability issues: <a href="../perlport#open">open in perlport</a>.</p> <div class="_attribution">
  <p class="_attribution-p">
    © 1993–2016 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.26.0/functions/open.html" class="_attribution-link">https://perldoc.perl.org/5.26.0/functions/open.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
