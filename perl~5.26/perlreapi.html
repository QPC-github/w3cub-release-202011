
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Perlreapi - Perl 5.26 - W3cubDocs</title>
  
  <meta name="description" content=" perlreapi - Perl regular expression plugin interface ">
  <meta name="keywords" content="perlreapi, perl, perl~5.26">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/perl~5.26/perlreapi.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/perl~5.26.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/perl~5.26/" class="_nav-link" title="" style="margin-left:0;">Perl 5.26</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _perl">
				
				
<h1>perlreapi</h1>  <ul>
<li><a href="#NAME">NAME</a></li>
<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
<li>
<a href="#Callbacks">Callbacks</a><ul>
<li><a href="#comp">comp</a></li>
<li><a href="#exec">exec</a></li>
<li><a href="#intuit">intuit</a></li>
<li><a href="#checkstr">checkstr</a></li>
<li><a href="#free">free</a></li>
<li><a href="#Numbered-capture-callbacks">Numbered capture callbacks</a></li>
<li><a href="#Named-capture-callbacks">Named capture callbacks</a></li>
<li><a href="#qr_package">qr_package</a></li>
<li><a href="#dupe">dupe</a></li>
<li><a href="#op_comp">op_comp</a></li>
</ul>
</li>
<li>
<a href="#The-REGEXP-structure">The REGEXP structure</a><ul>
<li><a href="#engine">engine</a></li>
<li><a href="#mother_re">mother_re</a></li>
<li><a href="#extflags">extflags</a></li>
<li><a href="#minlen-minlenret">minlen minlenret</a></li>
<li><a href="#gofs">gofs</a></li>
<li><a href="#substrs">substrs</a></li>
<li><a href="#nparens%2c-lastparen%2c-and-lastcloseparen">nparens, lastparen, and lastcloseparen</a></li>
<li><a href="#intflags">intflags</a></li>
<li><a href="#pprivate">pprivate</a></li>
<li><a href="#swap">swap</a></li>
<li><a href="#offs">offs</a></li>
<li><a href="#precomp-prelen">precomp prelen</a></li>
<li><a href="#paren_names">paren_names</a></li>
<li><a href="#substrs">substrs</a></li>
<li><a href="#subbeg-sublen-saved_copy-suboffset-subcoffset">subbeg sublen saved_copy suboffset subcoffset</a></li>
<li><a href="#wrapped-wraplen">wrapped wraplen</a></li>
<li><a href="#seen_evals">seen_evals</a></li>
<li><a href="#refcnt">refcnt</a></li>
</ul>
</li>
<li><a href="#HISTORY">HISTORY</a></li>
<li><a href="#AUTHORS">AUTHORS</a></li>
<li><a href="#LICENSE">LICENSE</a></li>
</ul>
<h2 id="NAME">NAME</h2> <p>perlreapi - Perl regular expression plugin interface</p> <h2 id="DESCRIPTION">DESCRIPTION</h2> <p>As of Perl 5.9.5 there is a new interface for plugging and using regular expression engines other than the default one.</p> <p>Each engine is supposed to provide access to a constant structure of the following format:</p> <pre class="verbatim" data-language="perl">    typedef struct regexp_engine {
        REGEXP* (*comp) (pTHX_
                         const SV * const pattern, const U32 flags);
        I32     (*exec) (pTHX_
                         REGEXP * const rx,
                         char* stringarg,
                         char* strend, char* strbeg,
                         SSize_t minend, SV* sv,
                         void* data, U32 flags);
        char*   (*intuit) (pTHX_
                           REGEXP * const rx, SV *sv,
const char * const strbeg,
                           char *strpos, char *strend, U32 flags,
                           struct re_scream_pos_data_s *data);
        SV*     (*checkstr) (pTHX_ REGEXP * const rx);
        void    (*free) (pTHX_ REGEXP * const rx);
        void    (*numbered_buff_FETCH) (pTHX_
                                        REGEXP * const rx,
                                        const I32 paren,
                                        SV * const sv);
        void    (*numbered_buff_STORE) (pTHX_
                                        REGEXP * const rx,
                                        const I32 paren,
                                        SV const * const value);
        I32     (*numbered_buff_LENGTH) (pTHX_
                                         REGEXP * const rx,
                                         const SV * const sv,
                                         const I32 paren);
        SV*     (*named_buff) (pTHX_
                               REGEXP * const rx,
                               SV * const key,
                               SV * const value,
                               U32 flags);
        SV*     (*named_buff_iter) (pTHX_
                                    REGEXP * const rx,
                                    const SV * const lastkey,
                                    const U32 flags);
        SV*     (*qr_package)(pTHX_ REGEXP * const rx);
    #ifdef USE_ITHREADS
        void*   (*dupe) (pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
    #endif
        REGEXP* (*op_comp) (...);
</pre>
<p>When a regexp is compiled, its <code class="inline"><span class="w">engine</span></code> field is then set to point at the appropriate structure, so that when it needs to be used Perl can find the right routines to do so.</p> <p>In order to install a new regexp handler, <code class="inline"><span class="i">$^H</span>{<span class="w">regcomp</span>}</code> is set to an integer which (when casted appropriately) resolves to one of these structures. When compiling, the <code class="inline"><span class="w">comp</span></code> method is executed, and the resulting <code class="inline"><span class="w">regexp</span></code> structure's engine field is expected to point back at the same structure.</p> <p>The pTHX_ symbol in the definition is a macro used by Perl under threading to provide an extra argument to the routine holding a pointer back to the interpreter that is executing the regexp. So under threading all routines get an extra argument.</p> <h2 id="Callbacks">Callbacks</h2> <h3 id="comp">comp</h3> <pre class="verbatim" data-language="perl">REGEXP* comp(pTHX_ const SV * const pattern, const U32 flags);
</pre>
<p>Compile the pattern stored in <code class="inline"><span class="w">pattern</span></code> using the given <code class="inline"><span class="w">flags</span></code> and return a pointer to a prepared <code class="inline"><span class="w">REGEXP</span></code> structure that can perform the match. See <a href="#The-REGEXP-structure">The REGEXP structure</a> below for an explanation of the individual fields in the REGEXP struct.</p> <p>The <code class="inline"><span class="w">pattern</span></code> parameter is the scalar that was used as the pattern. Previous versions of Perl would pass two <code class="inline"><span class="w">char</span>*</code> indicating the start and end of the stringified pattern; the following snippet can be used to get the old parameters:</p> <pre class="verbatim" data-language="perl">STRLEN plen;
char*  exp = SvPV(pattern, plen);
char* xend = exp + plen;
</pre>
<p>Since any scalar can be passed as a pattern, it's possible to implement an engine that does something with an array (<code class="inline"><span class="q">"ook"</span> =~ <span class="s">[</span> <span class="q">qw/ eek</span>
<span class="q">hlagh /</span> <span class="s">]</span></code> ) or with the non-stringified form of a compiled regular expression (<code class="inline"><span class="q">"ook"</span> =~ <span class="q">qr/eek/</span></code> ). Perl's own engine will always stringify everything using the snippet above, but that doesn't mean other engines have to.</p> <p>The <code class="inline"><span class="w">flags</span></code> parameter is a bitfield which indicates which of the <code class="inline"><span class="w">msixpn</span></code> flags the regex was compiled with. It also contains additional info, such as if <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="w">locale</span></code> is in effect.</p> <p>The <code class="inline"><span class="w">eogc</span></code> flags are stripped out before being passed to the comp routine. The regex engine does not need to know if any of these are set, as those flags should only affect what Perl does with the pattern and its match variables, not how it gets compiled and executed.</p> <p>By the time the comp callback is called, some of these flags have already had effect (noted below where applicable). However most of their effect occurs after the comp callback has run, in routines that read the <code class="inline"><span class="w">rx</span><span class="w">-&gt;extflags</span></code> field which it populates.</p> <p>In general the flags should be preserved in <code class="inline"><span class="w">rx</span><span class="w">-&gt;extflags</span></code> after compilation, although the regex engine might want to add or delete some of them to invoke or disable some special behavior in Perl. The flags along with any special behavior they cause are documented below:</p> <p>The pattern modifiers:</p> <ul> <li id="%2fm---RXf_PMf_MULTILINE">
<b><code class="inline">/m</code> - RXf_PMf_MULTILINE</b> <p>If this is in <code class="inline"><span class="w">rx</span><span class="w">-&gt;extflags</span></code> it will be passed to <code class="inline"><span class="w">Perl_fbm_instr</span></code> by <code class="inline"><span class="w">pp_split</span></code> which will treat the subject string as a multi-line string.</p> </li> <li id="%2fs---RXf_PMf_SINGLELINE">
<b><code class="inline">/s</code> - RXf_PMf_SINGLELINE</b> </li> <li id="%2fi---RXf_PMf_FOLD">
<b><code class="inline">/i</code> - RXf_PMf_FOLD</b> </li> <li id="%2fx---RXf_PMf_EXTENDED">
<b><code class="inline">/x</code> - RXf_PMf_EXTENDED</b> <p>If present on a regex, <code class="inline"><span class="q">"#"</span></code> comments will be handled differently by the tokenizer in some cases.</p> <p>TODO: Document those cases.</p> </li> <li id="%2fp---RXf_PMf_KEEPCOPY">
<b><code class="inline">/p</code> - RXf_PMf_KEEPCOPY</b> <p>TODO: Document this</p> </li> <li id="Character-set">
<b>Character set</b> <p>The character set rules are determined by an enum that is contained in this field. This is still experimental and subject to change, but the current interface returns the rules by use of the in-line function <code class="inline"><span class="i">get_regex_charset</span><span class="s">(</span><span class="w">const</span> <span class="w">U32</span> <span class="w">flags</span><span class="s">)</span></code> . The only currently documented value returned from it is REGEX_LOCALE_CHARSET, which is set if <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="w">locale</span></code> is in effect. If present in <code class="inline"><span class="w">rx</span><span class="w">-&gt;extflags</span></code> , <code class="inline"><a class="l_k" href="functions/split">split</a></code> will use the locale dependent definition of whitespace when RXf_SKIPWHITE or RXf_WHITE is in effect. ASCII whitespace is defined as per <a href="perlapi#isSPACE">isSPACE</a>, and by the internal macros <code class="inline"><span class="w">is_utf8_space</span></code> under UTF-8, and <code class="inline"><span class="w">isSPACE_LC</span></code> under <code class="inline"><a class="l_k" href="functions/use">use</a>
<span class="w">locale</span></code> .</p> </li> </ul> <p>Additional flags:</p> <ul> <li id="RXf_SPLIT">
<b>RXf_SPLIT</b> <p>This flag was removed in perl 5.18.0. <code class="inline"><a class="l_k" href="functions/split">split</a> <span class="q">' '</span></code> is now special-cased solely in the parser. RXf_SPLIT is still #defined, so you can test for it. This is how it used to work:</p> <p>If <code class="inline"><a class="l_k" href="functions/split">split</a></code> is invoked as <code class="inline"><a class="l_k" href="functions/split">split</a> <span class="q">' '</span></code> or with no arguments (which really means <code class="inline"><a class="l_k" href="functions/split">split</a><span class="s">(</span><span class="q">' '</span><span class="cm">,</span> <span class="i">$_</span><span class="s">)</span></code> , see <a href="functions/split">split</a>), Perl will set this flag. The regex engine can then check for it and set the SKIPWHITE and WHITE extflags. To do this, the Perl engine does:</p> <pre class="verbatim" data-language="perl">if (flags &amp; RXf_SPLIT &amp;&amp; r-&gt;prelen == 1 &amp;&amp; r-&gt;precomp[0] == ' ')
    r-&gt;extflags |= (RXf_SKIPWHITE|RXf_WHITE);
</pre>
</li> </ul> <p>These flags can be set during compilation to enable optimizations in the <code class="inline"><a class="l_k" href="functions/split">split</a></code> operator.</p> <ul> <li id="RXf_SKIPWHITE">
<b>RXf_SKIPWHITE</b> <p>This flag was removed in perl 5.18.0. It is still #defined, so you can set it, but doing so will have no effect. This is how it used to work:</p> <p>If the flag is present in <code class="inline"><span class="w">rx</span><span class="w">-&gt;extflags</span></code> <code class="inline"><a class="l_k" href="functions/split">split</a></code> will delete whitespace from the start of the subject string before it's operated on. What is considered whitespace depends on if the subject is a UTF-8 string and if the <code class="inline"><span class="w">RXf_PMf_LOCALE</span></code> flag is set.</p> <p>If RXf_WHITE is set in addition to this flag, <code class="inline"><a class="l_k" href="functions/split">split</a></code> will behave like <code class="inline"><a class="l_k" href="functions/split">split</a> <span class="q">" "</span></code> under the Perl engine.</p> </li> <li id="RXf_START_ONLY">
<b>RXf_START_ONLY</b> <p>Tells the split operator to split the target string on newlines (<code class="inline">\<span class="w">n</span></code> ) without invoking the regex engine.</p> <p>Perl's engine sets this if the pattern is <code class="inline"><span class="q">/^/</span></code> (<code class="inline"><span class="w">plen</span> == <span class="n">1</span> &amp;&amp; <span class="i">*exp</span>
== <span class="q">'^'</span></code> ), even under <code class="inline"><span class="q">/^/s</span></code> ; see <a href="perlfunc">split</a>. Of course a different regex engine might want to use the same optimizations with a different syntax.</p> </li> <li id="RXf_WHITE">
<b>RXf_WHITE</b> <p>Tells the split operator to split the target string on whitespace without invoking the regex engine. The definition of whitespace varies depending on if the target string is a UTF-8 string and on if RXf_PMf_LOCALE is set.</p> <p>Perl's engine sets this flag if the pattern is <code class="inline">\s+</code>.</p> </li> <li id="RXf_NULL">
<b>RXf_NULL</b> <p>Tells the split operator to split the target string on characters. The definition of character varies depending on if the target string is a UTF-8 string.</p> <p>Perl's engine sets this flag on empty patterns, this optimization makes <code class="inline"><a class="l_k" href="functions/split">split</a> <span class="q">//</span></code> much faster than it would otherwise be. It's even faster than <code class="inline"><a class="l_k" href="functions/unpack">unpack</a></code>.</p> </li> <li id="RXf_NO_INPLACE_SUBST">
<b>RXf_NO_INPLACE_SUBST</b> <p>Added in perl 5.18.0, this flag indicates that a regular expression might perform an operation that would interfere with inplace substitution. For instance it might contain lookbehind, or assign to non-magical variables (such as $REGMARK and $REGERROR) during matching. <code class="inline"><a class="l_k" href="functions/s">s///</a></code> will skip certain optimisations when this is set.</p> </li> </ul> <h3 id="exec">exec</h3> <pre class="verbatim" data-language="perl">I32 exec(pTHX_ REGEXP * const rx,
         char *stringarg, char* strend, char* strbeg,
         SSize_t minend, SV* sv,
         void* data, U32 flags);
</pre>
<p>Execute a regexp. The arguments are</p> <ul> <li id="rx">
<b>rx</b> <p>The regular expression to execute.</p> </li> <li id="sv">
<b>sv</b> <p>This is the SV to be matched against. Note that the actual char array to be matched against is supplied by the arguments described below; the SV is just used to determine UTF8ness, <code class="inline"><a class="l_k" href="functions/pos">pos()</a></code> etc.</p> </li> <li id="strbeg">
<b>strbeg</b> <p>Pointer to the physical start of the string.</p> </li> <li id="strend">
<b>strend</b> <p>Pointer to the character following the physical end of the string (i.e. the <code class="inline">\<span class="n">0</span></code> , if any).</p> </li> <li id="stringarg">
<b>stringarg</b> <p>Pointer to the position in the string where matching should start; it might not be equal to <code class="inline"><span class="w">strbeg</span></code> (for example in a later iteration of <code class="inline"><span class="q">/.../g</span></code> ).</p> </li> <li id="minend">
<b>minend</b> <p>Minimum length of string (measured in bytes from <code class="inline"><span class="w">stringarg</span></code> ) that must match; if the engine reaches the end of the match but hasn't reached this position in the string, it should fail.</p> </li> <li id="data">
<b>data</b> <p>Optimisation data; subject to change.</p> </li> <li id="flags">
<b>flags</b> <p>Optimisation flags; subject to change.</p> </li> </ul> <h3 id="intuit">intuit</h3> <pre class="verbatim" data-language="perl">    char* intuit(pTHX_
REGEXP * const rx,
SV *sv,
const char * const strbeg,
char *strpos,
char *strend,
const U32 flags,
struct re_scream_pos_data_s *data);
</pre>
<p>Find the start position where a regex match should be attempted, or possibly if the regex engine should not be run because the pattern can't match. This is called, as appropriate, by the core, depending on the values of the <code class="inline"><span class="w">extflags</span></code> member of the <code class="inline"><span class="w">regexp</span></code> structure.</p> <p>Arguments:</p> <pre class="verbatim" data-language="perl">    rx:     the regex to match against
    sv:     the SV being matched: only used for utf8 flag; the string
itself is accessed via the pointers below. Note that on
something like an overloaded SV, SvPOK(sv) may be false
and the string pointers may point to something unrelated to
the SV itself.
    strbeg: real beginning of string
    strpos: the point in the string at which to begin matching
    strend: pointer to the byte following the last char of the string
    flags   currently unused; set to 0
    data:   currently unused; set to NULL
</pre>
<h3 id="checkstr">checkstr</h3> <pre class="verbatim" data-language="perl">SV*	checkstr(pTHX_ REGEXP * const rx);
</pre>
<p>Return a SV containing a string that must appear in the pattern. Used by <code class="inline"><a class="l_k" href="functions/split">split</a></code> for optimising matches.</p> <h3 id="free">free</h3> <pre class="verbatim" data-language="perl">void free(pTHX_ REGEXP * const rx);
</pre>
<p>Called by Perl when it is freeing a regexp pattern so that the engine can release any resources pointed to by the <code class="inline"><span class="w">pprivate</span></code> member of the <code class="inline"><span class="w">regexp</span></code> structure. This is only responsible for freeing private data; Perl will handle releasing anything else contained in the <code class="inline"><span class="w">regexp</span></code> structure.</p> <h3 id="Numbered-capture-callbacks">Numbered capture callbacks</h3> <p>Called to get/set the value of <code class="inline"><span class="i">$`</span></code> , <code class="inline"><span class="i">$'</span></code> , <code class="inline"><span class="i">$&amp;</span></code> and their named equivalents, ${^PREMATCH}, ${^POSTMATCH} and ${^MATCH}, as well as the numbered capture groups (<code class="inline"><span class="i">$1</span></code> , <code class="inline"><span class="i">$2</span></code> , ...).</p> <p>The <code class="inline"><span class="w">paren</span></code> parameter will be <code class="inline"><span class="n">1</span></code> for <code class="inline"><span class="i">$1</span></code> , <code class="inline"><span class="n">2</span></code> for <code class="inline"><span class="i">$2</span></code> and so forth, and have these symbolic values for the special variables:</p> <pre class="verbatim" data-language="perl">${^PREMATCH}  RX_BUFF_IDX_CARET_PREMATCH
${^POSTMATCH} RX_BUFF_IDX_CARET_POSTMATCH
${^MATCH}     RX_BUFF_IDX_CARET_FULLMATCH
$`            RX_BUFF_IDX_PREMATCH
$'            RX_BUFF_IDX_POSTMATCH
$&amp;            RX_BUFF_IDX_FULLMATCH
</pre>
<p>Note that in Perl 5.17.3 and earlier, the last three constants were also used for the caret variants of the variables.</p> <p>The names have been chosen by analogy with <a href="tie/scalar">Tie::Scalar</a> methods names with an additional <b>LENGTH</b> callback for efficiency. However named capture variables are currently not tied internally but implemented via magic.</p> <h4 id="numbered_buff_FETCH">numbered_buff_FETCH</h4> <pre class="verbatim" data-language="perl">void numbered_buff_FETCH(pTHX_ REGEXP * const rx, const I32 paren,
                         SV * const sv);
</pre>
<p>Fetch a specified numbered capture. <code class="inline"><span class="w">sv</span></code> should be set to the scalar to return, the scalar is passed as an argument rather than being returned from the function because when it's called Perl already has a scalar to store the value, creating another one would be redundant. The scalar can be set with <code class="inline"><span class="w">sv_setsv</span></code> , <code class="inline"><span class="w">sv_setpvn</span></code> and friends, see <a href="perlapi">perlapi</a>.</p> <p>This callback is where Perl untaints its own capture variables under taint mode (see <a href="perlsec">perlsec</a>). See the <code class="inline"><span class="w">Perl_reg_numbered_buff_fetch</span></code> function in <i>regcomp.c</i> for how to untaint capture variables if that's something you'd like your engine to do as well.</p> <h4 id="numbered_buff_STORE">numbered_buff_STORE</h4> <pre class="verbatim" data-language="perl">void    (*numbered_buff_STORE) (pTHX_
                                REGEXP * const rx,
                                const I32 paren,
                                SV const * const value);
</pre>
<p>Set the value of a numbered capture variable. <code class="inline"><span class="w">value</span></code> is the scalar that is to be used as the new value. It's up to the engine to make sure this is used as the new value (or reject it).</p> <p>Example:</p> <pre class="verbatim" data-language="perl">if ("ook" =~ /(o*)/) {
    # 'paren' will be '1' and 'value' will be 'ee'
    $1 =~ tr/o/e/;
}
</pre>
<p>Perl's own engine will croak on any attempt to modify the capture variables, to do this in another engine use the following callback (copied from <code class="inline"><span class="w">Perl_reg_numbered_buff_store</span></code> ):</p> <pre class="verbatim" data-language="perl">void
Example_reg_numbered_buff_store(pTHX_
                                REGEXP * const rx,
                                const I32 paren,
                                SV const * const value)
{
    PERL_UNUSED_ARG(rx);
    PERL_UNUSED_ARG(paren);
    PERL_UNUSED_ARG(value);

    if (!PL_localizing)
        Perl_croak(aTHX_ PL_no_modify);
}
</pre>
<p>Actually Perl will not <i>always</i> croak in a statement that looks like it would modify a numbered capture variable. This is because the STORE callback will not be called if Perl can determine that it doesn't have to modify the value. This is exactly how tied variables behave in the same situation:</p> <pre class="verbatim" data-language="perl">package CaptureVar;
use parent 'Tie::Scalar';

sub TIESCALAR { bless [] }
sub FETCH { undef }
sub STORE { die "This doesn't get called" }

package main;

tie my $sv =&gt; "CaptureVar";
$sv =~ y/a/b/;
</pre>
<p>Because <code class="inline"><span class="i">$sv</span></code> is <code class="inline"><a class="l_k" href="functions/undef">undef</a></code> when the <code class="inline"><a class="l_k" href="functions/y">y///</a></code> operator is applied to it, the transliteration won't actually execute and the program won't <code class="inline"><a class="l_k" href="functions/die">die</a></code>. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</p> <h4 id="numbered_buff_LENGTH">numbered_buff_LENGTH</h4> <pre class="verbatim" data-language="perl">I32 numbered_buff_LENGTH (pTHX_
                          REGEXP * const rx,
                          const SV * const sv,
                          const I32 paren);
</pre>
<p>Get the <code class="inline"><a class="l_k" href="functions/length">length</a></code> of a capture variable. There's a special callback for this so that Perl doesn't have to do a FETCH and run <code class="inline"><a class="l_k" href="functions/length">length</a></code> on the result, since the length is (in Perl's case) known from an offset stored in <code class="inline"><span class="w">rx</span><span class="w">-&gt;offs</span></code> , this is much more efficient:</p> <pre class="verbatim" data-language="perl">I32 s1  = rx-&gt;offs[paren].start;
I32 s2  = rx-&gt;offs[paren].end;
I32 len = t1 - s1;
</pre>
<p>This is a little bit more complex in the case of UTF-8, see what <code class="inline"><span class="w">Perl_reg_numbered_buff_length</span></code> does with <a href="perlapi#is_utf8_string_loclen">is_utf8_string_loclen</a>.</p> <h3 id="Named-capture-callbacks">Named capture callbacks</h3> <p>Called to get/set the value of <code class="inline"><span class="i">%+</span></code> and <code class="inline"><span class="i">%-</span></code> , as well as by some utility functions in <a href="re">re</a>.</p> <p>There are two callbacks, <code class="inline"><span class="w">named_buff</span></code> is called in all the cases the FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR <a href="tie/hash">Tie::Hash</a> callbacks would be on changes to <code class="inline"><span class="i">%+</span></code> and <code class="inline"><span class="i">%-</span></code> and <code class="inline"><span class="w">named_buff_iter</span></code> in the same cases as FIRSTKEY and NEXTKEY.</p> <p>The <code class="inline"><span class="w">flags</span></code> parameter can be used to determine which of these operations the callbacks should respond to. The following flags are currently defined:</p> <p>Which <a href="tie/hash">Tie::Hash</a> operation is being performed from the Perl level on <code class="inline"><span class="i">%+</span></code> or <code class="inline"><span class="i">%+</span></code> , if any:</p> <pre class="verbatim" data-language="perl">RXapif_FETCH
RXapif_STORE
RXapif_DELETE
RXapif_CLEAR
RXapif_EXISTS
RXapif_SCALAR
RXapif_FIRSTKEY
RXapif_NEXTKEY
</pre>
<p>If <code class="inline"><span class="i">%+</span></code> or <code class="inline"><span class="i">%-</span></code> is being operated on, if any.</p> <pre class="verbatim" data-language="perl">RXapif_ONE /* %+ */
RXapif_ALL /* %- */
</pre>
<p>If this is being called as <code class="inline"><span class="w">re::regname</span></code> , <code class="inline"><span class="w">re::regnames</span></code> or <code class="inline"><span class="w">re::regnames_count</span></code> , if any. The first two will be combined with <code class="inline"><span class="w">RXapif_ONE</span></code> or <code class="inline"><span class="w">RXapif_ALL</span></code> .</p> <pre class="verbatim" data-language="perl">RXapif_REGNAME
RXapif_REGNAMES
RXapif_REGNAMES_COUNT
</pre>
<p>Internally <code class="inline"><span class="i">%+</span></code> and <code class="inline"><span class="i">%-</span></code> are implemented with a real tied interface via <a href="tie/hash/namedcapture">Tie::Hash::NamedCapture</a>. The methods in that package will call back into these functions. However the usage of <a href="tie/hash/namedcapture">Tie::Hash::NamedCapture</a> for this purpose might change in future releases. For instance this might be implemented by magic instead (would need an extension to mgvtbl).</p> <h4 id="named_buff">named_buff</h4> <pre class="verbatim" data-language="perl">SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,
                       SV * const value, U32 flags);
</pre>
<h4 id="named_buff_iter">named_buff_iter</h4> <pre class="verbatim" data-language="perl">SV*     (*named_buff_iter) (pTHX_
                            REGEXP * const rx,
                            const SV * const lastkey,
                            const U32 flags);
</pre>
<h3 id="qr_package">qr_package</h3> <pre class="verbatim" data-language="perl">SV* qr_package(pTHX_ REGEXP * const rx);
</pre>
<p>The package the qr// magic object is blessed into (as seen by <code class="inline"><a class="l_k" href="functions/ref">ref</a>
<span class="q">qr//</span></code> ). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</p> <p>The package this method returns should also have the internal <code class="inline"><span class="w">Regexp</span></code> package in its <code class="inline"><span class="i">@ISA</span></code> . <code class="inline"><a class="l_k" href="functions/qr">qr//-&gt;isa("Regexp")</a></code> should always be true regardless of what engine is being used.</p> <p>Example implementation might be:</p> <pre class="verbatim" data-language="perl">SV*
Example_qr_package(pTHX_ REGEXP * const rx)
{
	PERL_UNUSED_ARG(rx);
	return newSVpvs("re::engine::Example");
}
</pre>
<p>Any method calls on an object created with <code class="inline"><a class="l_k" href="functions/qr">qr//</a></code> will be dispatched to the package as a normal object.</p> <pre class="verbatim" data-language="perl">use re::engine::Example;
my $re = qr//;
$re-&gt;meth; # dispatched to re::engine::Example::meth()
</pre>
<p>To retrieve the <code class="inline"><span class="w">REGEXP</span></code> object from the scalar in an XS function use the <code class="inline"><span class="w">SvRX</span></code> macro, see <a href="perlapi#REGEXP-Functions">REGEXP Functions in perlapi</a>.</p> <pre class="verbatim" data-language="perl">void meth(SV * rv)
PPCODE:
    REGEXP * re = SvRX(sv);
</pre>
<h3 id="dupe">dupe</h3> <pre class="verbatim" data-language="perl">void* dupe(pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
</pre>
<p>On threaded builds a regexp may need to be duplicated so that the pattern can be used by multiple threads. This routine is expected to handle the duplication of any private data pointed to by the <code class="inline"><span class="w">pprivate</span></code> member of the <code class="inline"><span class="w">regexp</span></code> structure. It will be called with the preconstructed new <code class="inline"><span class="w">regexp</span></code> structure as an argument, the <code class="inline"><span class="w">pprivate</span></code> member will point at the <b>old</b> private structure, and it is this routine's responsibility to construct a copy and return a pointer to it (which Perl will then use to overwrite the field as passed to this routine.)</p> <p>This allows the engine to dupe its private data but also if necessary modify the final structure if it really must.</p> <p>On unthreaded builds this field doesn't exist.</p> <h3 id="op_comp">op_comp</h3> <p>This is private to the Perl core and subject to change. Should be left null.</p> <h2 id="The-REGEXP-structure">The REGEXP structure</h2> <p>The REGEXP struct is defined in <i>regexp.h</i>. All regex engines must be able to correctly build such a structure in their <a href="#comp">comp</a> routine.</p> <p>The REGEXP structure contains all the data that Perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that Perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts, such as if the pattern anchored in some way, or what flags were used during the compile, or if the program contains special constructs that Perl needs to be aware of.</p> <p>In addition it contains two fields that are intended for the private use of the regex engine that compiled the pattern. These are the <code class="inline"><span class="w">intflags</span></code> and <code class="inline"><span class="w">pprivate</span></code> members. <code class="inline"><span class="w">pprivate</span></code> is a void pointer to an arbitrary structure, whose use and management is the responsibility of the compiling engine. Perl will never modify either of these values.</p> <pre class="verbatim" data-language="perl">    typedef struct regexp {
        /* what engine created this regexp? */
        const struct regexp_engine* engine;

        /* what re is this a lightweight copy of? */
        struct regexp* mother_re;

        /* Information about the match that the Perl core uses to manage
                  * things */
        U32 extflags;   /* Flags used both externally and internally */
I32 minlen;	/* mininum possible number of chars in */
                           string to match */
	I32 minlenret;	/* mininum possible number of chars in $&amp; */
        U32 gofs;       /* chars left of pos that we search from */

        /* substring data about strings that must appear
           in the final match, used for optimisations */
                struct reg_substr_data *substrs;

                U32 nparens;  /* number of capture groups */

                /* private engine specific data */
                U32 intflags;   /* Engine Specific Internal flags */
                void *pprivate; /* Data private to the regex engine which 
                           created this object. */

        /* Data about the last/current match. These are modified during
                  * matching*/
        U32 lastparen;            /* highest close paren matched ($+) */
        U32 lastcloseparen;       /* last close paren matched ($^N) */
        regexp_paren_pair *swap;  /* Swap copy of *offs */
        regexp_paren_pair *offs;  /* Array of offsets for (@-) and
                                                                          (@+) */

        char *subbeg;  /* saved or original string so \digit works
                                                    forever. */
        SV_SAVED_COPY  /* If non-NULL, SV which is COW from original */
        I32 sublen;    /* Length of string pointed by subbeg */
        I32 suboffset;	/* byte offset of subbeg from logical start of
                                                      str */
I32 subcoffset;	/* suboffset equiv, but in chars (for @-/@+) */

                /* Information about the match that isn't often used */
                I32 prelen;           /* length of precomp */
                const char *precomp;  /* pre-compilation regular expression */

                char *wrapped;  /* wrapped version of the pattern */
                I32 wraplen;    /* length of wrapped */

                I32 seen_evals;   /* number of eval groups in the pattern - for
                             security checks */
                HV *paren_names;  /* Optional hash of paren names */

                /* Refcount of this regexp */
                I32 refcnt;             /* Refcount of this regexp */
        } regexp;
</pre>
<p>The fields are discussed in more detail below:</p> <h3 id="engine">
<code class="inline"><span class="w">engine</span></code> </h3> <p>This field points at a <code class="inline"><span class="w">regexp_engine</span></code> structure which contains pointers to the subroutines that are to be used for performing a match. It is the compiling routine's responsibility to populate this field before returning the regexp object.</p> <p>Internally this is set to <code class="inline"><span class="w">NULL</span></code> unless a custom engine is specified in <code class="inline"><span class="i">$^H</span>{<span class="w">regcomp</span>}</code> , Perl's own set of callbacks can be accessed in the struct pointed to by <code class="inline"><span class="w">RE_ENGINE_PTR</span></code> .</p> <h3 id="mother_re">
<code class="inline"><span class="w">mother_re</span></code> </h3> <p>TODO, see <a href="http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html">http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html</a></p> <h3 id="extflags">
<code class="inline"><span class="w">extflags</span></code> </h3> <p>This will be used by Perl to see what flags the regexp was compiled with, this will normally be set to the value of the flags parameter by the <a href="#comp">comp</a> callback. See the <a href="#comp">comp</a> documentation for valid flags.</p> <h3 id="minlen-minlenret">
<code class="inline"><span class="w">minlen</span></code> <code class="inline"><span class="w">minlenret</span></code> </h3> <p>The minimum string length (in characters) required for the pattern to match. This is used to prune the search space by not bothering to match any closer to the end of a string than would allow a match. For instance there is no point in even starting the regex engine if the minlen is 10 but the string is only 5 characters long. There is no way that the pattern can match.</p> <p><code class="inline"><span class="w">minlenret</span></code> is the minimum length (in characters) of the string that would be found in $&amp; after a match.</p> <p>The difference between <code class="inline"><span class="w">minlen</span></code> and <code class="inline"><span class="w">minlenret</span></code> can be seen in the following pattern:</p> <pre class="verbatim" data-language="perl">/ns(?=\d)/
</pre>
<p>where the <code class="inline"><span class="w">minlen</span></code> would be 3 but <code class="inline"><span class="w">minlenret</span></code> would only be 2 as the \d is required to match but is not actually included in the matched content. This distinction is particularly important as the substitution logic uses the <code class="inline"><span class="w">minlenret</span></code> to tell if it can do in-place substitutions (these can result in considerable speed-up).</p> <h3 id="gofs">
<code class="inline"><span class="w">gofs</span></code> </h3> <p>Left offset from pos() to start match at.</p> <h3 id="substrs">
<code class="inline"><span class="w">substrs</span></code> </h3> <p>Substring data about strings that must appear in the final match. This is currently only used internally by Perl's engine, but might be used in the future for all engines for optimisations.</p> <h3 id="nparens%2c-lastparen%2c-and-lastcloseparen">
<code class="inline"><span class="w">nparens</span></code> , <code class="inline"><span class="w">lastparen</span></code> , and <code class="inline"><span class="w">lastcloseparen</span></code> </h3> <p>These fields are used to keep track of how many paren groups could be matched in the pattern, which was the last open paren to be entered, and which was the last close paren to be entered.</p> <h3 id="intflags">
<code class="inline"><span class="w">intflags</span></code> </h3> <p>The engine's private copy of the flags the pattern was compiled with. Usually this is the same as <code class="inline"><span class="w">extflags</span></code> unless the engine chose to modify one of them.</p> <h3 id="pprivate">
<code class="inline"><span class="w">pprivate</span></code> </h3> <p>A void* pointing to an engine-defined data structure. The Perl engine uses the <code class="inline"><span class="w">regexp_internal</span></code> structure (see <a href="perlreguts#Base-Structures">Base Structures in perlreguts</a>) but a custom engine should use something else.</p> <h3 id="swap">
<code class="inline"><span class="w">swap</span></code> </h3> <p>Unused. Left in for compatibility with Perl 5.10.0.</p> <h3 id="offs">
<code class="inline"><span class="w">offs</span></code> </h3> <p>A <code class="inline"><span class="w">regexp_paren_pair</span></code> structure which defines offsets into the string being matched which correspond to the <code class="inline"><span class="i">$&amp;</span></code> and <code class="inline"><span class="i">$1</span></code> , <code class="inline"><span class="i">$2</span></code> etc. captures, the <code class="inline"><span class="w">regexp_paren_pair</span></code> struct is defined as follows:</p> <pre class="verbatim" data-language="perl">typedef struct regexp_paren_pair {
    I32 start;
    I32 end;
} regexp_paren_pair;
</pre>
<p>If <code class="inline"><span class="i">-&gt;offs</span>[<span class="w">num</span>].<span class="w">start</span></code> or <code class="inline"><span class="i">-&gt;offs</span>[<span class="w">num</span>].<span class="w">end</span></code> is <code class="inline"><span class="n">-1</span></code> then that capture group did not match. <code class="inline"><span class="i">-&gt;offs</span>[<span class="n">0</span>].<span class="w">start</span>/<span class="w">end</span></code> represents <code class="inline"><span class="i">$&amp;</span></code> (or <code class="inline"><span class="i">$</span>{<span class="w">^MATCH</span>}</code> under <code class="inline"><span class="q">//p</span></code> ) and <code class="inline"><span class="i">-&gt;offs</span>[<span class="w">paren</span>].<span class="w">end</span></code> matches <code class="inline"><span class="i">$$paren</span></code> where <code class="inline"><span class="i">$paren</span> </code> = 1&gt;.</p> <h3 id="precomp-prelen">
<code class="inline"><span class="w">precomp</span></code> <code class="inline"><span class="w">prelen</span></code> </h3> <p>Used for optimisations. <code class="inline"><span class="w">precomp</span></code> holds a copy of the pattern that was compiled and <code class="inline"><span class="w">prelen</span></code> its length. When a new pattern is to be compiled (such as inside a loop) the internal <code class="inline"><span class="w">regcomp</span></code> operator checks if the last compiled <code class="inline"><span class="w">REGEXP</span></code> 's <code class="inline"><span class="w">precomp</span></code> and <code class="inline"><span class="w">prelen</span></code> are equivalent to the new one, and if so uses the old pattern instead of compiling a new one.</p> <p>The relevant snippet from <code class="inline"><span class="w">Perl_pp_regcomp</span></code> :</p> <pre class="verbatim" data-language="perl">if (!re || !re-&gt;precomp || re-&gt;prelen != (I32)len ||
    memNE(re-&gt;precomp, t, len))
        /* Compile a new pattern */
</pre>
<h3 id="paren_names">
<code class="inline"><span class="w">paren_names</span></code> </h3> <p>This is a hash used internally to track named capture groups and their offsets. The keys are the names of the buffers the values are dualvars, with the IV slot holding the number of buffers with the given name and the pv being an embedded array of I32. The values may also be contained independently in the data array in cases where named backreferences are used.</p> <h3 id="substrs">
<code class="inline"><span class="w">substrs</span></code> </h3> <p>Holds information on the longest string that must occur at a fixed offset from the start of the pattern, and the longest string that must occur at a floating offset from the start of the pattern. Used to do Fast-Boyer-Moore searches on the string to find out if its worth using the regex engine at all, and if so where in the string to search.</p> <h3 id="subbeg-sublen-saved_copy-suboffset-subcoffset">
<code class="inline"><span class="w">subbeg</span></code> <code class="inline"><span class="w">sublen</span></code> <code class="inline"><span class="w">saved_copy</span></code> <code class="inline"><span class="w">suboffset</span></code> <code class="inline"><span class="w">subcoffset</span></code> </h3> <p>Used during the execution phase for managing search and replace patterns, and for providing the text for <code class="inline"><span class="i">$&amp;</span></code> , <code class="inline"><span class="i">$1</span></code> etc. <code class="inline"><span class="w">subbeg</span></code> points to a buffer (either the original string, or a copy in the case of <code class="inline"><span class="i">RX_MATCH_COPIED</span><span class="s">(</span><span class="w">rx</span><span class="s">)</span></code> ), and <code class="inline"><span class="w">sublen</span></code> is the length of the buffer. The <code class="inline"><span class="w">RX_OFFS</span></code> start and end indices index into this buffer.</p> <p>In the presence of the <code class="inline"><span class="w">REXEC_COPY_STR</span></code> flag, but with the addition of the <code class="inline"><span class="w">REXEC_COPY_SKIP_PRE</span></code> or <code class="inline"><span class="w">REXEC_COPY_SKIP_POST</span></code> flags, an engine can choose not to copy the full buffer (although it must still do so in the presence of <code class="inline"><span class="w">RXf_PMf_KEEPCOPY</span></code> or the relevant bits being set in <code class="inline"><span class="w">PL_sawampersand</span></code> ). In this case, it may set <code class="inline"><span class="w">suboffset</span></code> to indicate the number of bytes from the logical start of the buffer to the physical start (i.e. <code class="inline"><span class="w">subbeg</span></code> ). It should also set <code class="inline"><span class="w">subcoffset</span></code> , the number of characters in the offset. The latter is needed to support <code class="inline"><span class="i">@-</span></code> and <code class="inline"><span class="i">@+</span></code> which work in characters, not bytes.</p> <h3 id="wrapped-wraplen">
<code class="inline"><span class="w">wrapped</span></code> <code class="inline"><span class="w">wraplen</span></code> </h3> <p>Stores the string <code class="inline"><a class="l_k" href="functions/qr">qr//</a></code> stringifies to. The Perl engine for example stores <code class="inline"><span class="s">(</span><span class="q">?^:eek)</span></code> in the case of <code class="inline"><a class="l_k" href="functions/qr">qr/eek/</a></code>.</p> <p>When using a custom engine that doesn't support the <code class="inline">(?:)</code> construct for inline modifiers, it's probably best to have <code class="inline"><a class="l_k" href="functions/qr">qr//</a></code> stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</p> <pre class="verbatim" data-language="perl">my $x = qr/a|b/;  # "a|b"
my $y = qr/c/i;   # "c"
my $z = qr/$x$y/; # "a|bc"
</pre>
<p>There's no solution for this problem other than making the custom engine understand a construct like <code class="inline">(?:)</code>.</p> <h3 id="seen_evals">
<code class="inline"><span class="w">seen_evals</span></code> </h3> <p>This stores the number of eval groups in the pattern. This is used for security purposes when embedding compiled regexes into larger patterns with <code class="inline"><a class="l_k" href="functions/qr">qr//</a></code>.</p> <h3 id="refcnt">
<code class="inline"><span class="w">refcnt</span></code> </h3> <p>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's <a href="#comp">comp</a> routine.</p> <h2 id="HISTORY">HISTORY</h2> <p>Originally part of <a href="perlreguts">perlreguts</a>.</p> <h2 id="AUTHORS">AUTHORS</h2> <p>Originally written by Yves Orton, expanded by Ævar Arnfjörð Bjarmason.</p> <h2 id="LICENSE">LICENSE</h2> <p>Copyright 2006 Yves Orton and 2007 Ævar Arnfjörð Bjarmason.</p> <p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1993–2016 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.26.0/perlreapi.html" class="_attribution-link">https://perldoc.perl.org/5.26.0/perlreapi.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
