
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Perldsc - Perl 5.26 - W3cubDocs</title>
  
  <meta name="description" content=" perldsc - Perl Data Structures Cookbook ">
  <meta name="keywords" content="perldsc, perl, perl~5.26">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/perl~5.26/perldsc.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/perl~5.26.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/perl~5.26/" class="_nav-link" title="" style="margin-left:0;">Perl 5.26</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _perl">
				
				
<h1>perldsc</h1>  <ul>
<li><a href="#NAME">NAME </a></li>
<li><a href="#DESCRIPTION">DESCRIPTION</a></li>
<li><a href="#REFERENCES">REFERENCES </a></li>
<li><a href="#COMMON-MISTAKES">COMMON MISTAKES</a></li>
<li><a href="#CAVEAT-ON-PRECEDENCE">CAVEAT ON PRECEDENCE </a></li>
<li><a href="#WHY-YOU-SHOULD-ALWAYS-use-strict">WHY YOU SHOULD ALWAYS use strict</a></li>
<li><a href="#DEBUGGING">DEBUGGING </a></li>
<li><a href="#CODE-EXAMPLES">CODE EXAMPLES</a></li>
<li>
<a href="#ARRAYS-OF-ARRAYS">ARRAYS OF ARRAYS </a><ul>
<li><a href="#Declaration-of-an-ARRAY-OF-ARRAYS">Declaration of an ARRAY OF ARRAYS</a></li>
<li><a href="#Generation-of-an-ARRAY-OF-ARRAYS">Generation of an ARRAY OF ARRAYS</a></li>
<li><a href="#Access-and-Printing-of-an-ARRAY-OF-ARRAYS">Access and Printing of an ARRAY OF ARRAYS</a></li>
</ul>
</li>
<li>
<a href="#HASHES-OF-ARRAYS">HASHES OF ARRAYS </a><ul>
<li><a href="#Declaration-of-a-HASH-OF-ARRAYS">Declaration of a HASH OF ARRAYS</a></li>
<li><a href="#Generation-of-a-HASH-OF-ARRAYS">Generation of a HASH OF ARRAYS</a></li>
<li><a href="#Access-and-Printing-of-a-HASH-OF-ARRAYS">Access and Printing of a HASH OF ARRAYS</a></li>
</ul>
</li>
<li>
<a href="#ARRAYS-OF-HASHES">ARRAYS OF HASHES </a><ul>
<li><a href="#Declaration-of-an-ARRAY-OF-HASHES">Declaration of an ARRAY OF HASHES</a></li>
<li><a href="#Generation-of-an-ARRAY-OF-HASHES">Generation of an ARRAY OF HASHES</a></li>
<li><a href="#Access-and-Printing-of-an-ARRAY-OF-HASHES">Access and Printing of an ARRAY OF HASHES</a></li>
</ul>
</li>
<li>
<a href="#HASHES-OF-HASHES">HASHES OF HASHES </a><ul>
<li><a href="#Declaration-of-a-HASH-OF-HASHES">Declaration of a HASH OF HASHES</a></li>
<li><a href="#Generation-of-a-HASH-OF-HASHES">Generation of a HASH OF HASHES</a></li>
<li><a href="#Access-and-Printing-of-a-HASH-OF-HASHES">Access and Printing of a HASH OF HASHES</a></li>
</ul>
</li>
<li>
<a href="#MORE-ELABORATE-RECORDS">MORE ELABORATE RECORDS </a><ul>
<li><a href="#Declaration-of-MORE-ELABORATE-RECORDS">Declaration of MORE ELABORATE RECORDS</a></li>
<li><a href="#Declaration-of-a-HASH-OF-COMPLEX-RECORDS">Declaration of a HASH OF COMPLEX RECORDS</a></li>
<li><a href="#Generation-of-a-HASH-OF-COMPLEX-RECORDS">Generation of a HASH OF COMPLEX RECORDS</a></li>
</ul>
</li>
<li><a href="#Database-Ties">Database Ties</a></li>
<li><a href="#SEE-ALSO">SEE ALSO</a></li>
<li><a href="#AUTHOR">AUTHOR</a></li>
</ul>
<h2 id="NAME">NAME </h2> <p>perldsc - Perl Data Structures Cookbook</p> <h2 id="DESCRIPTION">DESCRIPTION</h2> <p>Perl lets us have complex data structures. You can write something like this and all of a sudden, you'd have an array with three dimensions!</p> <pre class="verbatim" data-language="perl">for my $x (1 .. 10) {
    for my $y (1 .. 10) {
        for my $z (1 .. 10) {
            $AoA[$x][$y][$z] =
                $x ** $y + $z;
        }
    }
}
</pre>
<p>Alas, however simple this may appear, underneath it's a much more elaborate construct than meets the eye!</p> <p>How do you print it out? Why can't you say just <code class="inline"><a class="l_k" href="functions/print">print</a> <span class="i">@AoA</span></code> ? How do you sort it? How can you pass it to a function or get one of these back from a function? Is it an object? Can you save it to disk to read back later? How do you access whole rows or columns of that matrix? Do all the values have to be numeric?</p> <p>As you see, it's quite easy to become confused. While some small portion of the blame for this can be attributed to the reference-based implementation, it's really more due to a lack of existing documentation with examples designed for the beginner.</p> <p>This document is meant to be a detailed but understandable treatment of the many different sorts of data structures you might want to develop. It should also serve as a cookbook of examples. That way, when you need to create one of these complex data structures, you can just pinch, pilfer, or purloin a drop-in example from here.</p> <p>Let's look at each of these possible constructs in detail. There are separate sections on each of the following:</p> <ul> <li id="*-arrays-of-arrays">
<b>arrays of arrays</b> </li> <li id="*-hashes-of-arrays">
<b>hashes of arrays</b> </li> <li id="*-arrays-of-hashes">
<b>arrays of hashes</b> </li> <li id="*-hashes-of-hashes">
<b>hashes of hashes</b> </li> <li id="*-more-elaborate-constructs">
<b>more elaborate constructs</b> </li> </ul> <p>But for now, let's look at general issues common to all these types of data structures.</p> <h2 id="REFERENCES">REFERENCES </h2> <p>The most important thing to understand about all data structures in Perl--including multidimensional arrays--is that even though they might appear otherwise, Perl <code class="inline"><span class="i">@ARRAY</span></code> s and <code class="inline"><span class="i">%HASH</span></code> es are all internally one-dimensional. They can hold only scalar values (meaning a string, number, or a reference). They cannot directly contain other arrays or hashes, but instead contain <i>references</i> to other arrays or hashes. </p> <p>You can't use a reference to an array or hash in quite the same way that you would a real array or hash. For C or C++ programmers unused to distinguishing between arrays and pointers to the same, this can be confusing. If so, just think of it as the difference between a structure and a pointer to a structure.</p> <p>You can (and should) read more about references in <a href="perlref">perlref</a>. Briefly, references are rather like pointers that know what they point to. (Objects are also a kind of reference, but we won't be needing them right away--if ever.) This means that when you have something which looks to you like an access to a two-or-more-dimensional array and/or hash, what's really going on is that the base type is merely a one-dimensional entity that contains references to the next level. It's just that you can <i>use</i> it as though it were a two-dimensional one. This is actually the way almost all C multidimensional arrays work as well.</p> <pre class="verbatim" data-language="perl">$array[7][12]                       # array of arrays
$array[7]{string}                   # array of hashes
$hash{string}[7]                    # hash of arrays
$hash{string}{'another string'}     # hash of hashes
</pre>
<p>Now, because the top level contains only references, if you try to print out your array in with a simple print() function, you'll get something that doesn't look very nice, like this:</p> <pre class="verbatim" data-language="perl">  my @AoA = ( [2, 3], [4, 5, 7], [0] );
  print $AoA[1][2];
7
  print @AoA;
ARRAY(0x83c38)ARRAY(0x8b194)ARRAY(0x8b1d0)
</pre>
<p>That's because Perl doesn't (ever) implicitly dereference your variables. If you want to get at the thing a reference is referring to, then you have to do this yourself using either prefix typing indicators, like <code class="inline"><span class="i">$</span>{<span class="i">$blah</span>}</code> , <code class="inline"><span class="i">@</span>{<span class="i">$blah</span>}</code> , <code class="inline"><span class="i">@</span>{<span class="i">$blah</span>[<span class="i">$i</span>]}</code> , or else postfix pointer arrows, like <code class="inline"><span class="i">$a</span>-&gt;[<span class="n">3</span>]</code> , <code class="inline"><span class="i">$h</span>-&gt;{<span class="w">fred</span>}</code> , or even <code class="inline"><span class="i">$ob</span><span class="i">-&gt;method</span><span class="s">(</span><span class="s">)</span>-&gt;[<span class="n">3</span>]</code> .</p> <h2 id="COMMON-MISTAKES">COMMON MISTAKES</h2> <p>The two most common mistakes made in constructing something like an array of arrays is either accidentally counting the number of elements or else taking a reference to the same memory location repeatedly. Here's the case where you just get the count instead of a nested array:</p> <pre class="verbatim" data-language="perl">for my $i (1..10) {
    my @array = somefunc($i);
    $AoA[$i] = @array;      # WRONG!
}
</pre>
<p>That's just the simple case of assigning an array to a scalar and getting its element count. If that's what you really and truly want, then you might do well to consider being a tad more explicit about it, like this:</p> <pre class="verbatim" data-language="perl">for my $i (1..10) {
    my @array = somefunc($i);
    $counts[$i] = scalar @array;
}
</pre>
<p>Here's the case of taking a reference to the same memory location again and again:</p> <pre class="verbatim" data-language="perl"># Either without strict or having an outer-scope my @array;
# declaration.

for my $i (1..10) {
    @array = somefunc($i);
    $AoA[$i] = \@array;     # WRONG!
}
</pre>
<p>So, what's the big problem with that? It looks right, doesn't it? After all, I just told you that you need an array of references, so by golly, you've made me one!</p> <p>Unfortunately, while this is true, it's still broken. All the references in @AoA refer to the <i>very same place</i>, and they will therefore all hold whatever was last in @array! It's similar to the problem demonstrated in the following C program:</p> <pre class="verbatim" data-language="perl">#include &lt;pwd.h&gt;
main() {
    struct passwd *getpwnam(), *rp, *dp;
    rp = getpwnam("root");
    dp = getpwnam("daemon");

    printf("daemon name is %s\nroot name is %s\n",
            dp-&gt;pw_name, rp-&gt;pw_name);
}
</pre>
<p>Which will print</p> <pre class="verbatim" data-language="perl">daemon name is daemon
root name is daemon
</pre>
<p>The problem is that both <code class="inline"><span class="w">rp</span></code> and <code class="inline"><span class="w">dp</span></code> are pointers to the same location in memory! In C, you'd have to remember to malloc() yourself some new memory. In Perl, you'll want to use the array constructor <code class="inline"><span class="s">[</span><span class="s">]</span></code> or the hash constructor <code class="inline"><span class="s">{</span><span class="s">}</span></code> instead. Here's the right way to do the preceding broken code fragments: </p> <pre class="verbatim" data-language="perl"># Either without strict or having an outer-scope my @array;
# declaration.

for my $i (1..10) {
    @array = somefunc($i);
    $AoA[$i] = [ @array ];
}
</pre>
<p>The square brackets make a reference to a new array with a <i>copy</i> of what's in @array at the time of the assignment. This is what you want.</p> <p>Note that this will produce something similar, but it's much harder to read:</p> <pre class="verbatim" data-language="perl"># Either without strict or having an outer-scope my @array;
# declaration.
for my $i (1..10) {
    @array = 0 .. $i;
    @{$AoA[$i]} = @array;
}
</pre>
<p>Is it the same? Well, maybe so--and maybe not. The subtle difference is that when you assign something in square brackets, you know for sure it's always a brand new reference with a new <i>copy</i> of the data. Something else could be going on in this new case with the <code class="inline"><span class="i">@</span>{<span class="i">$AoA</span>[<span class="i">$i</span>]}</code> dereference on the left-hand-side of the assignment. It all depends on whether <code class="inline"><span class="i">$AoA</span>[<span class="i">$i</span>]</code> had been undefined to start with, or whether it already contained a reference. If you had already populated @AoA with references, as in</p> <pre class="verbatim" data-language="perl">$AoA[3] = \@another_array;
</pre>
<p>Then the assignment with the indirection on the left-hand-side would use the existing reference that was already there:</p> <pre class="verbatim" data-language="perl">@{$AoA[3]} = @array;
</pre>
<p>Of course, this <i>would</i> have the "interesting" effect of clobbering @another_array. (Have you ever noticed how when a programmer says something is "interesting", that rather than meaning "intriguing", they're disturbingly more apt to mean that it's "annoying", "difficult", or both? :-)</p> <p>So just remember always to use the array or hash constructors with <code class="inline"><span class="s">[</span><span class="s">]</span></code> or <code class="inline"><span class="s">{</span><span class="s">}</span></code> , and you'll be fine, although it's not always optimally efficient.</p> <p>Surprisingly, the following dangerous-looking construct will actually work out fine:</p> <pre class="verbatim" data-language="perl">for my $i (1..10) {
    my @array = somefunc($i);
    $AoA[$i] = \@array;
}
</pre>
<p>That's because my() is more of a run-time statement than it is a compile-time declaration <i>per se</i>. This means that the my() variable is remade afresh each time through the loop. So even though it <i>looks</i> as though you stored the same variable reference each time, you actually did not! This is a subtle distinction that can produce more efficient code at the risk of misleading all but the most experienced of programmers. So I usually advise against teaching it to beginners. In fact, except for passing arguments to functions, I seldom like to see the gimme-a-reference operator (backslash) used much at all in code. Instead, I advise beginners that they (and most of the rest of us) should try to use the much more easily understood constructors <code class="inline"><span class="s">[</span><span class="s">]</span></code> and <code class="inline"><span class="s">{</span><span class="s">}</span></code> instead of relying upon lexical (or dynamic) scoping and hidden reference-counting to do the right thing behind the scenes.</p> <p>In summary:</p> <pre class="verbatim" data-language="perl">$AoA[$i] = [ @array ];     # usually best
$AoA[$i] = \@array;        # perilous; just how my() was that array?
@{ $AoA[$i] } = @array;    # way too tricky for most programmers
</pre>
<h2 id="CAVEAT-ON-PRECEDENCE">CAVEAT ON PRECEDENCE </h2> <p>Speaking of things like <code class="inline"><span class="i">@</span>{<span class="i">$AoA</span>[<span class="i">$i</span>]}</code> , the following are actually the same thing: </p> <pre class="verbatim" data-language="perl">$aref-&gt;[2][2]       # clear
$$aref[2][2]        # confusing
</pre>
<p>That's because Perl's precedence rules on its five prefix dereferencers (which look like someone swearing: <code class="inline"><span class="i">$ @</span> * <span class="i">% &amp;</span></code> ) make them bind more tightly than the postfix subscripting brackets or braces! This will no doubt come as a great shock to the C or C++ programmer, who is quite accustomed to using <code class="inline"><span class="i">*a</span>[<span class="w">i</span>]</code> to mean what's pointed to by the <i>i'th</i> element of <code class="inline"><span class="w">a</span></code> . That is, they first take the subscript, and only then dereference the thing at that subscript. That's fine in C, but this isn't C.</p> <p>The seemingly equivalent construct in Perl, <code class="inline"><span class="i">$$aref</span>[<span class="i">$i</span>]</code> first does the deref of $aref, making it take $aref as a reference to an array, and then dereference that, and finally tell you the <i>i'th</i> value of the array pointed to by $AoA. If you wanted the C notion, you'd have to write <code class="inline"><span class="i">$</span>{<span class="i">$AoA</span>[<span class="i">$i</span>]}</code> to force the <code class="inline"><span class="i">$AoA</span>[<span class="i">$i</span>]</code> to get evaluated first before the leading <code class="inline"><span class="i">$</span></code> dereferencer.</p> <h2 id="WHY-YOU-SHOULD-ALWAYS-use-strict">WHY YOU SHOULD ALWAYS <code class="inline"><a class="l_k" href="functions/use">use</a> <span class="w">strict</span></code> </h2> <p>If this is starting to sound scarier than it's worth, relax. Perl has some features to help you avoid its most common pitfalls. The best way to avoid getting confused is to start every program like this:</p> <pre class="verbatim" data-language="perl">#!/usr/bin/perl -w
use strict;
</pre>
<p>This way, you'll be forced to declare all your variables with my() and also disallow accidental "symbolic dereferencing". Therefore if you'd done this:</p> <pre class="verbatim" data-language="perl">my $aref = [
    [ "fred", "barney", "pebbles", "bambam", "dino", ],
    [ "homer", "bart", "marge", "maggie", ],
    [ "george", "jane", "elroy", "judy", ],
];

print $aref[2][2];
</pre>
<p>The compiler would immediately flag that as an error <i>at compile time</i>, because you were accidentally accessing <code class="inline"><span class="i">@aref</span></code> , an undeclared variable, and it would thereby remind you to write instead:</p> <pre class="verbatim" data-language="perl">print $aref-&gt;[2][2]
</pre>
<h2 id="DEBUGGING">DEBUGGING </h2> <p>You can use the debugger's <code class="inline"><span class="w">x</span></code> command to dump out complex data structures. For example, given the assignment to $AoA above, here's the debugger output:</p> <pre class="verbatim" data-language="perl">DB&lt;1&gt; x $AoA
$AoA = ARRAY(0x13b5a0)
   0  ARRAY(0x1f0a24)
      0  'fred'
      1  'barney'
      2  'pebbles'
      3  'bambam'
      4  'dino'
   1  ARRAY(0x13b558)
      0  'homer'
      1  'bart'
      2  'marge'
      3  'maggie'
   2  ARRAY(0x13b540)
      0  'george'
      1  'jane'
      2  'elroy'
      3  'judy'
</pre>
<h2 id="CODE-EXAMPLES">CODE EXAMPLES</h2> <p>Presented with little comment (these will get their own manpages someday) here are short code examples illustrating access of various types of data structures.</p> <h2 id="ARRAYS-OF-ARRAYS">ARRAYS OF ARRAYS </h2> <h3 id="Declaration-of-an-ARRAY-OF-ARRAYS">Declaration of an ARRAY OF ARRAYS</h3> <pre class="verbatim" data-language="perl">@AoA = (
       [ "fred", "barney" ],
       [ "george", "jane", "elroy" ],
       [ "homer", "marge", "bart" ],
     );
</pre>
<h3 id="Generation-of-an-ARRAY-OF-ARRAYS">Generation of an ARRAY OF ARRAYS</h3> <pre class="verbatim" data-language="perl"># reading from file
while ( &lt;&gt; ) {
    push @AoA, [ split ];
}

# calling a function
for $i ( 1 .. 10 ) {
    $AoA[$i] = [ somefunc($i) ];
}

# using temp vars
for $i ( 1 .. 10 ) {
    @tmp = somefunc($i);
    $AoA[$i] = [ @tmp ];
}

# add to an existing row
push @{ $AoA[0] }, "wilma", "betty";
</pre>
<h3 id="Access-and-Printing-of-an-ARRAY-OF-ARRAYS">Access and Printing of an ARRAY OF ARRAYS</h3> <pre class="verbatim" data-language="perl"># one element
$AoA[0][0] = "Fred";

# another element
$AoA[1][1] =~ s/(\w)/\u$1/;

# print the whole thing with refs
for $aref ( @AoA ) {
    print "\t [ @$aref ],\n";
}

# print the whole thing with indices
for $i ( 0 .. $#AoA ) {
    print "\t [ @{$AoA[$i]} ],\n";
}

# print the whole thing one at a time
for $i ( 0 .. $#AoA ) {
    for $j ( 0 .. $#{ $AoA[$i] } ) {
        print "elt $i $j is $AoA[$i][$j]\n";
    }
}
</pre>
<h2 id="HASHES-OF-ARRAYS">HASHES OF ARRAYS </h2> <h3 id="Declaration-of-a-HASH-OF-ARRAYS">Declaration of a HASH OF ARRAYS</h3> <pre class="verbatim" data-language="perl">%HoA = (
       flintstones        =&gt; [ "fred", "barney" ],
       jetsons            =&gt; [ "george", "jane", "elroy" ],
       simpsons           =&gt; [ "homer", "marge", "bart" ],
     );
</pre>
<h3 id="Generation-of-a-HASH-OF-ARRAYS">Generation of a HASH OF ARRAYS</h3> <pre class="verbatim" data-language="perl"># reading from file
# flintstones: fred barney wilma dino
while ( &lt;&gt; ) {
    next unless s/^(.*?):\s*//;
    $HoA{$1} = [ split ];
}

# reading from file; more temps
# flintstones: fred barney wilma dino
while ( $line = &lt;&gt; ) {
    ($who, $rest) = split /:\s*/, $line, 2;
    @fields = split ' ', $rest;
    $HoA{$who} = [ @fields ];
}

# calling a function that returns a list
for $group ( "simpsons", "jetsons", "flintstones" ) {
    $HoA{$group} = [ get_family($group) ];
}

# likewise, but using temps
for $group ( "simpsons", "jetsons", "flintstones" ) {
    @members = get_family($group);
    $HoA{$group} = [ @members ];
}

# append new members to an existing family
push @{ $HoA{"flintstones"} }, "wilma", "betty";
</pre>
<h3 id="Access-and-Printing-of-a-HASH-OF-ARRAYS">Access and Printing of a HASH OF ARRAYS</h3> <pre class="verbatim" data-language="perl"># one element
$HoA{flintstones}[0] = "Fred";

# another element
$HoA{simpsons}[1] =~ s/(\w)/\u$1/;

# print the whole thing
foreach $family ( keys %HoA ) {
    print "$family: @{ $HoA{$family} }\n"
}

# print the whole thing with indices
foreach $family ( keys %HoA ) {
    print "family: ";
    foreach $i ( 0 .. $#{ $HoA{$family} } ) {
        print " $i = $HoA{$family}[$i]";
    }
    print "\n";
}

# print the whole thing sorted by number of members
foreach $family ( sort { @{$HoA{$b}} &lt;=&gt; @{$HoA{$a}} } keys %HoA ) {
    print "$family: @{ $HoA{$family} }\n"
}

# print the whole thing sorted by number of members and name
foreach $family ( sort {
                           @{$HoA{$b}} &lt;=&gt; @{$HoA{$a}}
                                       ||
                                   $a cmp $b
           } keys %HoA )
{
    print "$family: ", join(", ", sort @{ $HoA{$family} }), "\n";
}
</pre>
<h2 id="ARRAYS-OF-HASHES">ARRAYS OF HASHES </h2> <h3 id="Declaration-of-an-ARRAY-OF-HASHES">Declaration of an ARRAY OF HASHES</h3> <pre class="verbatim" data-language="perl">@AoH = (
       {
           Lead     =&gt; "fred",
           Friend   =&gt; "barney",
       },
       {
           Lead     =&gt; "george",
           Wife     =&gt; "jane",
           Son      =&gt; "elroy",
       },
       {
           Lead     =&gt; "homer",
           Wife     =&gt; "marge",
           Son      =&gt; "bart",
       }
 );
</pre>
<h3 id="Generation-of-an-ARRAY-OF-HASHES">Generation of an ARRAY OF HASHES</h3> <pre class="verbatim" data-language="perl"># reading from file
# format: LEAD=fred FRIEND=barney
while ( &lt;&gt; ) {
    $rec = {};
    for $field ( split ) {
        ($key, $value) = split /=/, $field;
        $rec-&gt;{$key} = $value;
    }
    push @AoH, $rec;
}


# reading from file
# format: LEAD=fred FRIEND=barney
# no temp
while ( &lt;&gt; ) {
    push @AoH, { split /[\s+=]/ };
}

# calling a function  that returns a key/value pair list, like
# "lead","fred","daughter","pebbles"
while ( %fields = getnextpairset() ) {
    push @AoH, { %fields };
}

# likewise, but using no temp vars
while (&lt;&gt;) {
    push @AoH, { parsepairs($_) };
}

# add key/value to an element
$AoH[0]{pet} = "dino";
$AoH[2]{pet} = "santa's little helper";
</pre>
<h3 id="Access-and-Printing-of-an-ARRAY-OF-HASHES">Access and Printing of an ARRAY OF HASHES</h3> <pre class="verbatim" data-language="perl"># one element
$AoH[0]{lead} = "fred";

# another element
$AoH[1]{lead} =~ s/(\w)/\u$1/;

# print the whole thing with refs
for $href ( @AoH ) {
    print "{ ";
    for $role ( keys %$href ) {
        print "$role=$href-&gt;{$role} ";
    }
    print "}\n";
}

# print the whole thing with indices
for $i ( 0 .. $#AoH ) {
    print "$i is { ";
    for $role ( keys %{ $AoH[$i] } ) {
        print "$role=$AoH[$i]{$role} ";
    }
    print "}\n";
}

# print the whole thing one at a time
for $i ( 0 .. $#AoH ) {
    for $role ( keys %{ $AoH[$i] } ) {
        print "elt $i $role is $AoH[$i]{$role}\n";
    }
}
</pre>
<h2 id="HASHES-OF-HASHES">HASHES OF HASHES </h2> <h3 id="Declaration-of-a-HASH-OF-HASHES">Declaration of a HASH OF HASHES</h3> <pre class="verbatim" data-language="perl">%HoH = (
       flintstones =&gt; {
               lead      =&gt; "fred",
               pal       =&gt; "barney",
       },
       jetsons     =&gt; {
               lead      =&gt; "george",
               wife      =&gt; "jane",
               "his boy" =&gt; "elroy",
       },
       simpsons    =&gt; {
               lead      =&gt; "homer",
               wife      =&gt; "marge",
               kid       =&gt; "bart",
       },
);
</pre>
<h3 id="Generation-of-a-HASH-OF-HASHES">Generation of a HASH OF HASHES</h3> <pre class="verbatim" data-language="perl"># reading from file
# flintstones: lead=fred pal=barney wife=wilma pet=dino
while ( &lt;&gt; ) {
    next unless s/^(.*?):\s*//;
    $who = $1;
    for $field ( split ) {
        ($key, $value) = split /=/, $field;
        $HoH{$who}{$key} = $value;
    }


# reading from file; more temps
while ( &lt;&gt; ) {
    next unless s/^(.*?):\s*//;
    $who = $1;
    $rec = {};
    $HoH{$who} = $rec;
    for $field ( split ) {
        ($key, $value) = split /=/, $field;
        $rec-&gt;{$key} = $value;
    }
}

# calling a function  that returns a key,value hash
for $group ( "simpsons", "jetsons", "flintstones" ) {
    $HoH{$group} = { get_family($group) };
}

# likewise, but using temps
for $group ( "simpsons", "jetsons", "flintstones" ) {
    %members = get_family($group);
    $HoH{$group} = { %members };
}

# append new members to an existing family
%new_folks = (
    wife =&gt; "wilma",
    pet  =&gt; "dino",
);

for $what (keys %new_folks) {
    $HoH{flintstones}{$what} = $new_folks{$what};
}
</pre>
<h3 id="Access-and-Printing-of-a-HASH-OF-HASHES">Access and Printing of a HASH OF HASHES</h3> <pre class="verbatim" data-language="perl"># one element
$HoH{flintstones}{wife} = "wilma";

# another element
$HoH{simpsons}{lead} =~ s/(\w)/\u$1/;

# print the whole thing
foreach $family ( keys %HoH ) {
    print "$family: { ";
    for $role ( keys %{ $HoH{$family} } ) {
        print "$role=$HoH{$family}{$role} ";
    }
    print "}\n";
}

# print the whole thing  somewhat sorted
foreach $family ( sort keys %HoH ) {
    print "$family: { ";
    for $role ( sort keys %{ $HoH{$family} } ) {
        print "$role=$HoH{$family}{$role} ";
    }
    print "}\n";
}


# print the whole thing sorted by number of members
foreach $family ( sort { keys %{$HoH{$b}} &lt;=&gt; keys %{$HoH{$a}} }
                                                            keys %HoH )
{
    print "$family: { ";
    for $role ( sort keys %{ $HoH{$family} } ) {
        print "$role=$HoH{$family}{$role} ";
    }
    print "}\n";
}

# establish a sort order (rank) for each role
$i = 0;
for ( qw(lead wife son daughter pal pet) ) { $rank{$_} = ++$i }

# now print the whole thing sorted by number of members
foreach $family ( sort { keys %{ $HoH{$b} } &lt;=&gt; keys %{ $HoH{$a} } }
                                                            keys %HoH )
{
    print "$family: { ";
    # and print these according to rank order
    for $role ( sort { $rank{$a} &lt;=&gt; $rank{$b} }
                                              keys %{ $HoH{$family} } )
    {
        print "$role=$HoH{$family}{$role} ";
    }
    print "}\n";
}
</pre>
<h2 id="MORE-ELABORATE-RECORDS">MORE ELABORATE RECORDS </h2> <h3 id="Declaration-of-MORE-ELABORATE-RECORDS">Declaration of MORE ELABORATE RECORDS</h3> <p>Here's a sample showing how to create and use a record whose fields are of many different sorts:</p> <pre class="verbatim" data-language="perl">$rec = {
    TEXT      =&gt; $string,
    SEQUENCE  =&gt; [ @old_values ],
    LOOKUP    =&gt; { %some_table },
    THATCODE  =&gt; \&amp;some_function,
    THISCODE  =&gt; sub { $_[0] ** $_[1] },
    HANDLE    =&gt; \*STDOUT,
};

print $rec-&gt;{TEXT};

print $rec-&gt;{SEQUENCE}[0];
$last = pop @ { $rec-&gt;{SEQUENCE} };

print $rec-&gt;{LOOKUP}{"key"};
($first_k, $first_v) = each %{ $rec-&gt;{LOOKUP} };

$answer = $rec-&gt;{THATCODE}-&gt;($arg);
$answer = $rec-&gt;{THISCODE}-&gt;($arg1, $arg2);

# careful of extra block braces on fh ref
print { $rec-&gt;{HANDLE} } "a string\n";

use FileHandle;
$rec-&gt;{HANDLE}-&gt;autoflush(1);
$rec-&gt;{HANDLE}-&gt;print(" a string\n");
</pre>
<h3 id="Declaration-of-a-HASH-OF-COMPLEX-RECORDS">Declaration of a HASH OF COMPLEX RECORDS</h3> <pre class="verbatim" data-language="perl">%TV = (
   flintstones =&gt; {
       series   =&gt; "flintstones",
       nights   =&gt; [ qw(monday thursday friday) ],
       members  =&gt; [
           { name =&gt; "fred",    role =&gt; "lead", age  =&gt; 36, },
           { name =&gt; "wilma",   role =&gt; "wife", age  =&gt; 31, },
           { name =&gt; "pebbles", role =&gt; "kid",  age  =&gt;  4, },
       ],
   },

   jetsons     =&gt; {
       series   =&gt; "jetsons",
       nights   =&gt; [ qw(wednesday saturday) ],
       members  =&gt; [
           { name =&gt; "george",  role =&gt; "lead", age  =&gt; 41, },
           { name =&gt; "jane",    role =&gt; "wife", age  =&gt; 39, },
           { name =&gt; "elroy",   role =&gt; "kid",  age  =&gt;  9, },
       ],
    },

   simpsons    =&gt; {
       series   =&gt; "simpsons",
       nights   =&gt; [ qw(monday) ],
       members  =&gt; [
           { name =&gt; "homer", role =&gt; "lead", age  =&gt; 34, },
           { name =&gt; "marge", role =&gt; "wife", age =&gt; 37, },
           { name =&gt; "bart",  role =&gt; "kid",  age  =&gt;  11, },
       ],
    },
 );
</pre>
<h3 id="Generation-of-a-HASH-OF-COMPLEX-RECORDS">Generation of a HASH OF COMPLEX RECORDS</h3> <pre class="verbatim" data-language="perl"># reading from file
# this is most easily done by having the file itself be
# in the raw data format as shown above.  perl is happy
# to parse complex data structures if declared as data, so
# sometimes it's easiest to do that

# here's a piece by piece build up
$rec = {};
$rec-&gt;{series} = "flintstones";
$rec-&gt;{nights} = [ find_days() ];

@members = ();
# assume this file in field=value syntax
while (&lt;&gt;) {
    %fields = split /[\s=]+/;
    push @members, { %fields };
}
$rec-&gt;{members} = [ @members ];

# now remember the whole thing
$TV{ $rec-&gt;{series} } = $rec;

###########################################################
# now, you might want to make interesting extra fields that
# include pointers back into the same data structure so if
# change one piece, it changes everywhere, like for example
# if you wanted a {kids} field that was a reference
# to an array of the kids' records without having duplicate
# records and thus update problems.
###########################################################
foreach $family (keys %TV) {
    $rec = $TV{$family}; # temp pointer
    @kids = ();
    for $person ( @{ $rec-&gt;{members} } ) {
        if ($person-&gt;{role} =~ /kid|son|daughter/) {
            push @kids, $person;
        }
    }
    # REMEMBER: $rec and $TV{$family} point to same data!!
    $rec-&gt;{kids} = [ @kids ];
}

# you copied the array, but the array itself contains pointers
# to uncopied objects. this means that if you make bart get
# older via

$TV{simpsons}{kids}[0]{age}++;

# then this would also change in
print $TV{simpsons}{members}[2]{age};

# because $TV{simpsons}{kids}[0] and $TV{simpsons}{members}[2]
# both point to the same underlying anonymous hash table

# print the whole thing
foreach $family ( keys %TV ) {
    print "the $family";
    print " is on during @{ $TV{$family}{nights} }\n";
    print "its members are:\n";
    for $who ( @{ $TV{$family}{members} } ) {
        print " $who-&gt;{name} ($who-&gt;{role}), age $who-&gt;{age}\n";
    }
    print "it turns out that $TV{$family}{lead} has ";
    print scalar ( @{ $TV{$family}{kids} } ), " kids named ";
    print join (", ", map { $_-&gt;{name} } @{ $TV{$family}{kids} } );
    print "\n";
}
</pre>
<h2 id="Database-Ties">Database Ties</h2> <p>You cannot easily tie a multilevel data structure (such as a hash of hashes) to a dbm file. The first problem is that all but GDBM and Berkeley DB have size limitations, but beyond that, you also have problems with how references are to be represented on disk. One experimental module that does partially attempt to address this need is the MLDBM module. Check your nearest CPAN site as described in <a href="perlmodlib">perlmodlib</a> for source code to MLDBM.</p> <h2 id="SEE-ALSO">SEE ALSO</h2> <p><a href="perlref">perlref</a>, <a href="perllol">perllol</a>, <a href="perldata">perldata</a>, <a href="perlobj">perlobj</a></p> <h2 id="AUTHOR">AUTHOR</h2> <p>Tom Christiansen &lt;<i>tchrist@perl.com</i>&gt;</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 1993–2016 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.26.0/perldsc.html" class="_attribution-link">https://perldoc.perl.org/5.26.0/perldsc.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
