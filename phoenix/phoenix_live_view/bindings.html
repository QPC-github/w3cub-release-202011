
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Bindings - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" Phoenix supports DOM element bindings for client-server interaction. For example, to react to a click on a button, you would render the element&#58; ">
  <meta name="keywords" content="bindings, phoenix">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/phoenix/phoenix_live_view/bindings.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1>Bindings</h1>
<p>Phoenix supports DOM element bindings for client-server interaction. For example, to react to a click on a button, you would render the element:</p>
<pre data-language="elixir">&lt;button phx-click="inc_temperature"&gt;+&lt;/button&gt;</pre>
<p>Then on the server, all LiveView bindings are handled with the <code class="inline">handle_event</code> callback, for example:</p>
<pre data-language="elixir">def handle_event("inc_temperature", _value, socket) do
  {:ok, new_temp} = Thermostat.inc_temperature(socket.assigns.id)
  {:noreply, assign(socket, :temperature, new_temp)}
end</pre>
<table>
<thead><tr>
<th style="text-align: left;">Binding</th>
<th style="text-align: left;">Attributes</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align: left;"><a href="#click-events">Params</a></td>
<td style="text-align: left;"><code class="inline">phx-value-*</code></td>
</tr>
<tr>
<td style="text-align: left;"><a href="#click-events">Click Events</a></td>
<td style="text-align: left;">
<code class="inline">phx-capture-click</code>, <code class="inline">phx-click</code>
</td>
</tr>
<tr>
<td style="text-align: left;"><a href="#focus-and-blur-events">Focus/Blur Events</a></td>
<td style="text-align: left;">
<code class="inline">phx-window-focus</code>, <code class="inline">phx-window-blur</code>, <code class="inline">phx-focus</code>, <code class="inline">phx-blur</code>
</td>
</tr>
<tr>
<td style="text-align: left;"><a href="#key-events">Key Events</a></td>
<td style="text-align: left;">
<code class="inline">phx-window-keyup</code>, <code class="inline">phx-window-keydown</code>, <code class="inline">phx-keyup</code>, <code class="inline">phx-keydown</code>
</td>
</tr>
<tr>
<td style="text-align: left;"><a href="form-bindings">Form Events</a></td>
<td style="text-align: left;">
<code class="inline">phx-auto-recover</code>, <code class="inline">phx-trigger-action</code>, <code class="inline">phx-disable-with</code>, <code class="inline">phx-feedback-for</code>, <code class="inline">phx-submit</code>, <code class="inline">phx-change</code>
</td>
</tr>
<tr>
<td style="text-align: left;"><a href="#rate-limiting-events-with-debounce-and-throttle">Rate Limiting</a></td>
<td style="text-align: left;">
<code class="inline">phx-throttle</code>, <code class="inline">phx-debounce</code>
</td>
</tr>
<tr>
<td style="text-align: left;"><a href="dom-patching">DOM Patching</a></td>
<td style="text-align: left;"><code class="inline">phx-update</code></td>
</tr>
<tr>
<td style="text-align: left;"><a href="js-interop#client-hooks">JS Interop</a></td>
<td style="text-align: left;"><code class="inline">phx-hook</code></td>
</tr>
</tbody>
</table>
<h2 id="click-events" class="section-heading">  Click Events </h2> <p>The <code class="inline">phx-click</code> binding is used to send click events to the server. When any client event, such as a <code class="inline">phx-click</code> click is pushed, the value sent to the server will be chosen with the following priority:</p>
<ul>
<li>
<p>Any number of optional <code class="inline">phx-value-</code> prefixed attributes, such as:</p>
<pre data-language="elixir">&lt;div phx-click="inc" phx-value-myvar1="val1" phx-value-myvar2="val2"&gt;</pre>
<p>will send the following map of params to the server:</p>
<pre data-language="elixir">def handle_event("inc", %{"myvar1" =&gt; "val1", "myvar2" =&gt; "val2"}, socket) do</pre>
<p>If the <code class="inline">phx-value-</code> prefix is used, the server payload will also contain a <code class="inline">"value"</code> if the element's value attribute exists.</p>
</li>
<li>
<p>When receiving a map on the server, the payload will also include user defined metadata of the client event, or an empty map if none is set. For example, the following <code class="inline">LiveSocket</code> client option would send the coordinates and <code class="inline">altKey</code> information for all clicks:</p>
<pre data-language="elixir">let liveSocket = new LiveSocket("/live", Socket, {
  params: {_csrf_token: csrfToken},
  metadata: {
    click: (e, el) =&gt; {
      return {
        altKey: e.altKey,
        clientX: e.clientX,
        clientY: e.clientY
      }
    }
  }
})</pre>
</li>
</ul>
<p>The <code class="inline">phx-capture-click</code> event is just like <code class="inline">phx-click</code>, but instead of the click event being dispatched to the closest <code class="inline">phx-click</code> element as it bubbles up through the DOM, the event is dispatched as it propagates from the top of the DOM tree down to the target element. This is useful when wanting to bind click events without receiving bubbled events from child UI elements. Since capturing happens before bubbling, this can also be important for preparing or preventing behaviour that will be applied during the bubbling phase.</p>
<h2 id="focus-and-blur-events" class="section-heading">  Focus and Blur Events </h2> <p>Focus and blur events may be bound to DOM elements that emit such events, using the <code class="inline">phx-blur</code>, and <code class="inline">phx-focus</code> bindings, for example:</p>
<pre data-language="elixir">&lt;input name="email" phx-focus="myfocus" phx-blur="myblur"/&gt;</pre>
<p>To detect when the page itself has received focus or blur, <code class="inline">phx-window-focus</code> and <code class="inline">phx-window-blur</code> may be specified. These window level events may also be necessary if the element in consideration (most often a <code class="inline">div</code> with no tabindex) cannot receive focus. Like other bindings, <code class="inline">phx-value-*</code> can be provided on the bound element, and those values will be sent as part of the payload. For example:</p>
<pre data-language="elixir">&lt;div class="container"
    phx-window-focus="page-active"
    phx-window-blur="page-inactive"
    phx-value-page="123"&gt;
  ...
&lt;/div&gt;</pre>
<p>The following window-level bindings are supported:</p>
<ul>
<li><code class="inline">phx-window-focus</code></li>
<li><code class="inline">phx-window-blur</code></li>
<li><code class="inline">phx-window-keydown</code></li>
<li><code class="inline">phx-window-keyup</code></li>
</ul>
<h2 id="key-events" class="section-heading">  Key Events </h2> <p>The <code class="inline">onkeydown</code>, and <code class="inline">onkeyup</code> events are supported via the <code class="inline">phx-keydown</code>, and <code class="inline">phx-keyup</code> bindings. Each binding supports a <code class="inline">phx-key</code> attribute, which triggers the event for the specific key press. If no <code class="inline">phx-key</code> is provided, the event is triggered for any key press. When pushed, the value sent to the server will contain the <code class="inline">"key"</code> that was pressed, plus any user-defined metadata. For example, pressing the Escape key looks like this:</p>
<pre data-language="elixir">%{"key" =&gt; "Escape"}</pre>
<p>To capture additional user-defined metadata, the <code class="inline">metadata</code> option for keydown events may be provided to the <code class="inline">LiveSocket</code> constructor. For example:</p>
<pre data-language="elixir">let liveSocket = new LiveSocket("/live", Socket, {
  params: {_csrf_token: csrfToken},
  metadata: {
    keydown: (e, el) =&gt; {
      return {
        key: e.key,
        metaKey: e.metaKey,
        repeat: e.repeat
      }
    }
  }
})</pre>
<p>To determine which key has been pressed you should use <code class="inline">key</code> value. The available options can be found on <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values">MDN</a> or via the <a href="https://w3c.github.io/uievents/tools/key-event-viewer.html">Key Event Viewer</a>.</p>
<p>By default, the bound element will be the event listener, but a window-level binding may be provided via <code class="inline">phx-window-keydown</code> or <code class="inline">phx-window-keyup</code>, for example:</p>
<pre data-language="elixir">def render(assigns) do
  ~L"""
  &lt;div id="thermostat" phx-window-keyup="update_temp"&gt;
    Current temperature: &lt;%= @temperature %&gt;
  &lt;/div&gt;
  """
end

def handle_event("update_temp", %{"key" =&gt; "ArrowUp"}, socket) do
  {:ok, new_temp} = Thermostat.inc_temperature(socket.assigns.id)
  {:noreply, assign(socket, :temperature, new_temp)}
end

def handle_event("update_temp", %{"key" =&gt; "ArrowDown"}, socket) do
  {:ok, new_temp} = Thermostat.dec_temperature(socket.assigns.id)
  {:noreply, assign(socket, :temperature, new_temp)}
end

def handle_event("update_temp", _key, socket) do
  {:noreply, socket}
end</pre>
<h2 id="rate-limiting-events-with-debounce-and-throttle" class="section-heading">  Rate limiting events with Debounce and Throttle </h2> <p>All events can be rate-limited on the client by using the <code class="inline">phx-debounce</code> and <code class="inline">phx-throttle</code> bindings, with the following behavior:</p>
<ul>
<li><p><code class="inline">phx-debounce</code> - Accepts either an integer timeout value (in milliseconds), or <code class="inline">"blur"</code>. When an integer is provided, emitting the event is delayed by the specified milliseconds. When <code class="inline">"blur"</code> is provided, emitting the event is delayed until the field is blurred by the user. Debouncing is typically used for input elements.</p></li>
<li><p><code class="inline">phx-throttle</code> - Accepts an integer timeout value to throttle the event in milliseconds. Unlike debounce, throttle will immediately emit the event, then rate limit it at once per provided timeout. Throttling is typically used to rate limit clicks, mouse and keyboard actions.</p></li>
</ul>
<p>For example, to avoid validating an email until the field is blurred, while validating the username at most every 2 seconds after a user changes the field:</p>
<pre data-language="elixir">&lt;form phx-change="validate" phx-submit="save"&gt;
  &lt;input type="text" name="user[email]" phx-debounce="blur"/&gt;
  &lt;input type="text" name="user[username]" phx-debounce="2000"/&gt;
&lt;/form&gt;</pre>
<p>And to rate limit a volume up click to once every second:</p>
<pre data-language="elixir">&lt;button phx-click="volume_up" phx-throttle="1000"&gt;+&lt;/button&gt;</pre>
<p>Likewise, you may throttle held-down keydown:</p>
<pre data-language="elixir">&lt;div phx-window-keydown="keydown" phx-throttle="500"&gt;
  ...
&lt;/div&gt;</pre>
<p>Unless held-down keys are required, a better approach is generally to use <code class="inline">phx-keyup</code> bindings which only trigger on key up, thereby being self-limiting. However, <code class="inline">phx-keydown</code> is useful for games and other use cases where a constant press on a key is desired. In such cases, throttle should always be used.</p>
<h3 id="debounce-and-throttle-special-behavior" class="section-heading">  Debounce and Throttle special behavior </h3> <p>The following specialized behavior is performed for forms and keydown bindings:</p>
<ul>
<li><p>When a <code class="inline">phx-submit</code>, or a <code class="inline">phx-change</code> for a different input is triggered, any current debounce or throttle timers are reset for existing inputs.</p></li>
<li><p>A <code class="inline">phx-keydown</code> binding is only throttled for key repeats. Unique keypresses back-to-back will dispatch the pressed key events.</p></li>
</ul>
<h2 id="liveview-specific-events" class="section-heading">  LiveView Specific Events </h2> <p>The <code class="inline">lv:</code> event prefix supports LiveView specific features that are handled by LiveView without calling the user's <code class="inline">handle_event/3</code> callbacks. Today, the following events are supported:</p>
<ul><li>
<code class="inline">lv:clear-flash</code> – clears the flash when sent to the server. If a <code class="inline">phx-value-key</code> is provided, the specific key will be removed from the flash.</li></ul>
<p>For example:</p>
<pre data-language="elixir">&lt;p class="alert" phx-click="lv:clear-flash" phx-value-key="info"&gt;
  &lt;%= live_flash(@flash, :info) %&gt;
&lt;/p&gt;</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2018 Chris McCord<br>Licensed under the MIT License.<br>
    <a href="https://hexdocs.pm/phoenix_live_view/bindings.html" class="_attribution-link">https://hexdocs.pm/phoenix_live_view/bindings.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
