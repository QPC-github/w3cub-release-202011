
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Winlean - Nim - W3cubDocs</title>
  
  <meta name="description" content=" This module implements a small wrapper for some needed Win API procedures, so that the Nim compiler does not depend on the huge Windows module. ">
  <meta name="keywords" content="module, winlean, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nim/winlean.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="title">Module winlean</h1>  <p class="module-desc">This module implements a small wrapper for some needed Win API procedures, so that the Nim compiler does not depend on the huge Windows module.</p>  <h2 id="6">Imports</h2> <dl> <a href="dynlib">dynlib</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre>WinChar = Utf16Char</pre></dt>   <dt><pre>Handle = int</pre></dt>   <dt><pre>LONG = int32</pre></dt>   <dt><pre>ULONG = int32</pre></dt>   <dt><pre>PULONG = ptr int</pre></dt>   <dt><pre>WINBOOL = int32</pre></dt>   <dt><pre>DWORD = int32</pre></dt>   <dt><pre>PDWORD = ptr DWORD</pre></dt>   <dt><pre>LPINT = ptr int32</pre></dt>   <dt><pre>ULONG_PTR = uint</pre></dt>   <dt><pre>PULONG_PTR = ptr uint</pre></dt>   <dt><pre>HDC = Handle</pre></dt>   <dt><pre>HGLRC = Handle</pre></dt>   <dt><pre data-language="nim">SECURITY_ATTRIBUTES {...}{.final, pure.} = object
  nLength*: int32
  lpSecurityDescriptor*: pointer
  bInheritHandle*: WINBOOL</pre></dt>   <dt><pre data-language="nim">STARTUPINFO {...}{.final, pure.} = object
  cb*: int32
  lpReserved*: cstring
  lpDesktop*: cstring
  lpTitle*: cstring
  dwX*: int32
  dwY*: int32
  dwXSize*: int32
  dwYSize*: int32
  dwXCountChars*: int32
  dwYCountChars*: int32
  dwFillAttribute*: int32
  dwFlags*: int32
  wShowWindow*: int16
  cbReserved2*: int16
  lpReserved2*: pointer
  hStdInput*: Handle
  hStdOutput*: Handle
  hStdError*: Handle</pre></dt>   <dt><pre data-language="nim">PROCESS_INFORMATION {...}{.final, pure.} = object
  hProcess*: Handle
  hThread*: Handle
  dwProcessId*: int32
  dwThreadId*: int32</pre></dt>   <dt><pre data-language="nim">FILETIME {...}{.final, pure.} = object
  dwLowDateTime*: DWORD
  dwHighDateTime*: DWORD</pre></dt> <dd> CANNOT BE int64 BECAUSE OF ALIGNMENT   </dd>  <dt><pre data-language="nim">BY_HANDLE_FILE_INFORMATION {...}{.final, pure.} = object
  dwFileAttributes*: DWORD
  ftCreationTime*: FILETIME
  ftLastAccessTime*: FILETIME
  ftLastWriteTime*: FILETIME
  dwVolumeSerialNumber*: DWORD
  nFileSizeHigh*: DWORD
  nFileSizeLow*: DWORD
  nNumberOfLinks*: DWORD
  nFileIndexHigh*: DWORD
  nFileIndexLow*: DWORD</pre></dt>   <dt><pre data-language="nim">OSVERSIONINFO {...}{.final, pure.} = object
  dwOSVersionInfoSize*: DWORD
  dwMajorVersion*: DWORD
  dwMinorVersion*: DWORD
  dwBuildNumber*: DWORD
  dwPlatformId*: DWORD
  szCSDVersion*: array[0 .. 127, WinChar]</pre></dt>   <dt><pre data-language="nim">WIN32_FIND_DATA {...}{.pure.} = object
  dwFileAttributes*: int32
  ftCreationTime*: FILETIME
  ftLastAccessTime*: FILETIME
  ftLastWriteTime*: FILETIME
  nFileSizeHigh*: int32
  nFileSizeLow*: int32
  dwReserved0: int32
  dwReserved1: int32
  cFileName*: array[0 .. 260 - 1, WinChar]
  cAlternateFileName*: array[0 .. 13, WinChar]</pre></dt>   <dt><pre>SocketHandle = distinct int</pre></dt>   <dt><pre data-language="nim">WSAData {...}{.importc: "WSADATA", header: "winsock2.h".} = object
  wVersion, wHighVersion: int16
  szDescription: array[0 .. WSADESCRIPTION_LEN, char]
  szSystemStatus: array[0 .. WSASYS_STATUS_LEN, char]
  iMaxSockets, iMaxUdpDg: int16
  lpVendorInfo: cstring</pre></dt>   <dt><pre data-language="nim">SockAddr {...}{.importc: "SOCKADDR", header: "winsock2.h".} = object
  sa_family*: uint16
  sa_data*: array[0 .. 13, char]</pre></dt>   <dt><pre data-language="nim">InAddr {...}{.importc: "IN_ADDR", header: "winsock2.h".} = object
  s_addr*: uint32</pre></dt>   <dt><pre data-language="nim">Sockaddr_in {...}{.importc: "SOCKADDR_IN", header: "winsock2.h".} = object
  sin_family*: uint16
  sin_port*: uint16
  sin_addr*: InAddr
  sin_zero*: array[0 .. 7, char]</pre></dt>   <dt><pre data-language="nim">In6_addr {...}{.importc: "IN6_ADDR", header: "winsock2.h".} = object
  bytes* {...}{.importc: "u.Byte".}: array[0 .. 15, char]</pre></dt>   <dt><pre data-language="nim">Sockaddr_in6 {...}{.importc: "SOCKADDR_IN6", header: "ws2tcpip.h".} = object
  sin6_family*: uint16
  sin6_port*: uint16
  sin6_flowinfo*: int32
  sin6_addr*: In6_addr
  sin6_scope_id*: int32</pre></dt>   <dt><pre data-language="nim">Sockaddr_in6_old = object
  sin6_family*: uint16
  sin6_port*: int16
  sin6_flowinfo*: int32
  sin6_addr*: In6_addr</pre></dt>   <dt><pre data-language="nim">Sockaddr_storage {...}{.importc: "SOCKADDR_STORAGE", header: "winsock2.h".} = object
  ss_family*: uint16
  ss_pad1: array[6, byte]
  ss_align: int64
  ss_pad2: array[112, byte]</pre></dt>   <dt><pre data-language="nim">Servent = object
  s_name*: cstring
  s_aliases*: cstringArray
  when defined(cpu64):
      s_proto*: cstring
      s_port*: int16

  else:
      s_port*: int16
      s_proto*: cstring</pre></dt>   <dt><pre data-language="nim">Hostent = object
  h_name*: cstring
  h_aliases*: cstringArray
  h_addrtype*: int16
  h_length*: int16
  h_addr_list*: cstringArray</pre></dt>   <dt><pre data-language="nim">TFdSet = object
  fd_count*: cint
  fd_array*: array[0 .. 64 - 1, SocketHandle]</pre></dt>   <dt><pre data-language="nim">Timeval = object
  tv_sec*, tv_usec*: int32</pre></dt>   <dt><pre data-language="nim">AddrInfo = object
  ai_flags*: cint
  ai_family*: cint             ## Address family of socket.
  ai_socktype*: cint           ## Socket type.
  ai_protocol*: cint           ## Protocol of socket.
  ai_addrlen*: csize           ## Length of socket address.
  ai_canonname*: cstring       ## Canonical name of service location.
  ai_addr*: ptr SockAddr        ## Socket address of socket.
  ai_next*: ptr AddrInfo        ## Pointer to next in list.</pre></dt> <dd> Input flags.   </dd>  <dt><pre>SockLen = cuint</pre></dt>   <dt><pre data-language="nim">WOHandleArray = array[0 .. 0x00000040 - 1, Handle]</pre></dt>   <dt><pre>PWOHandleArray = ptr WOHandleArray</pre></dt>   <dt><pre data-language="nim">OVERLAPPED {...}{.pure, inheritable.} = object
  internal*: PULONG
  internalHigh*: PULONG
  offset*: DWORD
  offsetHigh*: DWORD
  hEvent*: Handle</pre></dt>   <dt><pre>POVERLAPPED = ptr OVERLAPPED</pre></dt>   <dt><pre data-language="nim">POVERLAPPED_COMPLETION_ROUTINE = proc (para1: DWORD; para2: DWORD; para3: POVERLAPPED) {...}{.
    stdcall.}</pre></dt>   <dt><pre data-language="nim">GUID {...}{.final, pure.} = object
  D1*: int32
  D2*: int16
  D3*: int16
  D4*: array[0 .. 7, int8]</pre></dt>   <dt><pre data-language="nim">TWSABuf {...}{.importc: "WSABUF", header: "winsock2.h".} = object
  len*: ULONG
  buf*: cstring</pre></dt>   <dt><pre data-language="nim">WSAPROC_ACCEPTEX = proc (sListenSocket: SocketHandle; sAcceptSocket: SocketHandle;
                      lpOutputBuffer: pointer; dwReceiveDataLength: DWORD;
                      dwLocalAddressLength: DWORD; dwRemoteAddressLength: DWORD;
                      lpdwBytesReceived: ptr DWORD; lpOverlapped: POVERLAPPED): bool {...}{.
    stdcall, gcsafe.}</pre></dt>   <dt><pre data-language="nim">WSAPROC_CONNECTEX = proc (s: SocketHandle; name: ptr SockAddr; namelen: cint;
                       lpSendBuffer: pointer; dwSendDataLength: DWORD;
                       lpdwBytesSent: ptr DWORD; lpOverlapped: POVERLAPPED): bool {...}{.
    stdcall, gcsafe.}</pre></dt>   <dt><pre data-language="nim">WSAPROC_GETACCEPTEXSOCKADDRS = proc (lpOutputBuffer: pointer;
                                  dwReceiveDataLength: DWORD;
                                  dwLocalAddressLength: DWORD;
                                  dwRemoteAddressLength: DWORD;
                                  LocalSockaddr: ptr PSockAddr;
                                  LocalSockaddrLength: ptr cint;
                                  RemoteSockaddr: ptr PSockAddr;
                                  RemoteSockaddrLength: ptr cint) {...}{.stdcall, gcsafe.}</pre></dt>   <dt><pre data-language="nim">WAITORTIMERCALLBACK = proc (para1: pointer; para2: int32): void {...}{.stdcall.}</pre></dt>   <dt><pre data-language="nim">KEY_EVENT_RECORD {...}{.final, pure.} = object
  eventType*: int16
  bKeyDown*: WINBOOL
  wRepeatCount*: int16
  wVirtualKeyCode*: int16
  wVirtualScanCode*: int16
  uChar*: int16
  dwControlKeyState*: DWORD</pre></dt>   <dt><pre data-language="nim">LPFIBER_START_ROUTINE = proc (param: pointer): void {...}{.stdcall.}</pre></dt>   <dt><pre>LPFILETIME = ptr FILETIME</pre></dt>  </dl>  <h2 id="8">Vars</h2> <dl>  <dt><pre>SOMAXCONN: cint</pre></dt>   <dt><pre>INVALID_SOCKET: SocketHandle</pre></dt>   <dt><pre>SOL_SOCKET: cint</pre></dt>   <dt><pre>SO_DEBUG: cint</pre></dt> <dd> turn on debugging info recording   </dd>  <dt><pre>SO_ACCEPTCONN: cint</pre></dt>   <dt><pre>SO_REUSEADDR: cint</pre></dt>   <dt><pre>SO_REUSEPORT: cint</pre></dt>   <dt><pre>SO_KEEPALIVE: cint</pre></dt>   <dt><pre>SO_DONTROUTE: cint</pre></dt>   <dt><pre>SO_BROADCAST: cint</pre></dt>   <dt><pre>SO_USELOOPBACK: cint</pre></dt>   <dt><pre>SO_LINGER: cint</pre></dt>   <dt><pre>SO_OOBINLINE: cint</pre></dt>   <dt><pre>SO_DONTLINGER: cint</pre></dt>   <dt><pre>SO_EXCLUSIVEADDRUSE: cint</pre></dt>   <dt><pre>SO_ERROR: cint</pre></dt>   <dt><pre>TCP_NODELAY: cint</pre></dt>   <dt><pre data-language="nim">WSAID_CONNECTEX: GUID = GUID(D1: 0x25A207B9, D2: 0xDDF3'i16, D3: 0x00004660, D4: [0x8E'i8,
    0xE9'i8, 0x76'i8, 0xE5'i8, 0x8C'i8, 0x74'i8, 0x06'i8, 0x3E'i8])</pre></dt>   <dt><pre data-language="nim">WSAID_ACCEPTEX: GUID = GUID(D1: 0xB5367DF1'i32, D2: 0xCBAC'i16, D3: 0x000011CF, D4: [
    0x95'i8, 0xCA'i8, 0x00'i8, 0x80'i8, 0x5F'i8, 0x48'i8, 0xA1'i8, 0x92'i8])</pre></dt>   <dt><pre data-language="nim">WSAID_GETACCEPTEXSOCKADDRS: GUID = GUID(D1: 0xB5367DF2'i32, D2: 0xCBAC'i16,
                                     D3: 0x000011CF, D4: [0x95'i8, 0xCA'i8, 0x00'i8,
    0x80'i8, 0x5F'i8, 0x48'i8, 0xA1'i8, 0x92'i8])</pre></dt>  </dl>  <h2 id="10">Consts</h2> <dl>  <dt><pre>useWinUnicode = true</pre></dt>   <dt><pre data-language="nim">STARTF_USESHOWWINDOW = 1'i32</pre></dt>   <dt><pre data-language="nim">STARTF_USESTDHANDLES = 256'i32</pre></dt>   <dt><pre data-language="nim">HIGH_PRIORITY_CLASS = 128'i32</pre></dt>   <dt><pre data-language="nim">IDLE_PRIORITY_CLASS = 64'i32</pre></dt>   <dt><pre data-language="nim">NORMAL_PRIORITY_CLASS = 32'i32</pre></dt>   <dt><pre data-language="nim">REALTIME_PRIORITY_CLASS = 256'i32</pre></dt>   <dt><pre data-language="nim">WAIT_OBJECT_0 = 0'i32</pre></dt>   <dt><pre data-language="nim">WAIT_TIMEOUT = 0x00000102'i32</pre></dt>   <dt><pre data-language="nim">WAIT_FAILED = 0xFFFFFFFF'i32</pre></dt>   <dt><pre>INFINITE = -1</pre></dt>   <dt><pre data-language="nim">STILL_ACTIVE = 0x00000103'i32</pre></dt>   <dt><pre>STD_INPUT_HANDLE = -10</pre></dt>   <dt><pre>STD_OUTPUT_HANDLE = -11</pre></dt>   <dt><pre>STD_ERROR_HANDLE = -12</pre></dt>   <dt><pre data-language="nim">DETACHED_PROCESS = 8'i32</pre></dt>   <dt><pre data-language="nim">SW_SHOWNORMAL = 1'i32</pre></dt>   <dt><pre>INVALID_HANDLE_VALUE = -1</pre></dt>   <dt><pre data-language="nim">CREATE_UNICODE_ENVIRONMENT = 1024'i32</pre></dt>   <dt><pre data-language="nim">PIPE_ACCESS_DUPLEX = 0x00000003'i32</pre></dt>   <dt><pre data-language="nim">PIPE_ACCESS_INBOUND = 1'i32</pre></dt>   <dt><pre data-language="nim">PIPE_ACCESS_OUTBOUND = 2'i32</pre></dt>   <dt><pre data-language="nim">PIPE_NOWAIT = 0x00000001'i32</pre></dt>   <dt><pre data-language="nim">SYNCHRONIZE = 0x00100000'i32</pre></dt>   <dt><pre data-language="nim">CREATE_NO_WINDOW = 0x08000000'i32</pre></dt>   <dt><pre data-language="nim">FILE_ATTRIBUTE_READONLY = 0x00000001'i32</pre></dt>   <dt><pre data-language="nim">FILE_ATTRIBUTE_HIDDEN = 0x00000002'i32</pre></dt>   <dt><pre data-language="nim">FILE_ATTRIBUTE_SYSTEM = 0x00000004'i32</pre></dt>   <dt><pre data-language="nim">FILE_ATTRIBUTE_DIRECTORY = 0x00000010'i32</pre></dt>   <dt><pre data-language="nim">FILE_ATTRIBUTE_ARCHIVE = 0x00000020'i32</pre></dt>   <dt><pre data-language="nim">FILE_ATTRIBUTE_DEVICE = 0x00000040'i32</pre></dt>   <dt><pre data-language="nim">FILE_ATTRIBUTE_NORMAL = 0x00000080'i32</pre></dt>   <dt><pre data-language="nim">FILE_ATTRIBUTE_TEMPORARY = 0x00000100'i32</pre></dt>   <dt><pre data-language="nim">FILE_ATTRIBUTE_SPARSE_FILE = 0x00000200'i32</pre></dt>   <dt><pre data-language="nim">FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400'i32</pre></dt>   <dt><pre data-language="nim">FILE_ATTRIBUTE_COMPRESSED = 0x00000800'i32</pre></dt>   <dt><pre data-language="nim">FILE_ATTRIBUTE_OFFLINE = 0x00001000'i32</pre></dt>   <dt><pre data-language="nim">FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x00002000'i32</pre></dt>   <dt><pre data-language="nim">FILE_FLAG_FIRST_PIPE_INSTANCE = 0x00080000'i32</pre></dt>   <dt><pre data-language="nim">FILE_FLAG_OPEN_NO_RECALL = 0x00100000'i32</pre></dt>   <dt><pre data-language="nim">FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000'i32</pre></dt>   <dt><pre data-language="nim">FILE_FLAG_POSIX_SEMANTICS = 0x01000000'i32</pre></dt>   <dt><pre data-language="nim">FILE_FLAG_BACKUP_SEMANTICS = 0x02000000'i32</pre></dt>   <dt><pre data-language="nim">FILE_FLAG_DELETE_ON_CLOSE = 0x04000000'i32</pre></dt>   <dt><pre data-language="nim">FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000'i32</pre></dt>   <dt><pre data-language="nim">FILE_FLAG_RANDOM_ACCESS = 0x10000000'i32</pre></dt>   <dt><pre data-language="nim">FILE_FLAG_NO_BUFFERING = 0x20000000'i32</pre></dt>   <dt><pre data-language="nim">FILE_FLAG_OVERLAPPED = 0x40000000'i32</pre></dt>   <dt><pre data-language="nim">FILE_FLAG_WRITE_THROUGH = 0x80000000'i32</pre></dt>   <dt><pre>MAX_PATH = 260</pre></dt>   <dt><pre data-language="nim">MOVEFILE_COPY_ALLOWED = 0x00000002'i32</pre></dt>   <dt><pre data-language="nim">MOVEFILE_CREATE_HARDLINK = 0x00000010'i32</pre></dt>   <dt><pre data-language="nim">MOVEFILE_DELAY_UNTIL_REBOOT = 0x00000004'i32</pre></dt>   <dt><pre data-language="nim">MOVEFILE_FAIL_IF_NOT_TRACKABLE = 0x00000020'i32</pre></dt>   <dt><pre data-language="nim">MOVEFILE_REPLACE_EXISTING = 0x00000001'i32</pre></dt>   <dt><pre data-language="nim">MOVEFILE_WRITE_THROUGH = 0x00000008'i32</pre></dt>   <dt><pre>WSADESCRIPTION_LEN = 256</pre></dt>   <dt><pre>WSASYS_STATUS_LEN = 128</pre></dt>   <dt><pre>FD_SETSIZE = 64</pre></dt>   <dt><pre>MSG_PEEK = 2</pre></dt>   <dt><pre data-language="nim">INADDR_ANY = 0'u32</pre></dt>   <dt><pre>INADDR_LOOPBACK = 0x7F000001</pre></dt>   <dt><pre>INADDR_BROADCAST = -1</pre></dt>   <dt><pre>INADDR_NONE = -1</pre></dt>   <dt><pre>MAXIMUM_WAIT_OBJECTS = 0x00000040</pre></dt>   <dt><pre data-language="nim">GENERIC_READ = 0x80000000'i32</pre></dt>   <dt><pre data-language="nim">GENERIC_WRITE = 0x40000000'i32</pre></dt>   <dt><pre data-language="nim">GENERIC_ALL = 0x10000000'i32</pre></dt>   <dt><pre data-language="nim">FILE_SHARE_READ = 1'i32</pre></dt>   <dt><pre data-language="nim">FILE_SHARE_DELETE = 4'i32</pre></dt>   <dt><pre data-language="nim">FILE_SHARE_WRITE = 2'i32</pre></dt>   <dt><pre data-language="nim">CREATE_ALWAYS = 2'i32</pre></dt>   <dt><pre data-language="nim">CREATE_NEW = 1'i32</pre></dt>   <dt><pre data-language="nim">OPEN_EXISTING = 3'i32</pre></dt>   <dt><pre data-language="nim">OPEN_ALWAYS = 4'i32</pre></dt>   <dt><pre data-language="nim">FILE_BEGIN = 0'i32</pre></dt>   <dt><pre>INVALID_SET_FILE_POINTER = -1</pre></dt>   <dt><pre data-language="nim">NO_ERROR = 0'i32</pre></dt>   <dt><pre data-language="nim">PAGE_READONLY = 2'i32</pre></dt>   <dt><pre data-language="nim">PAGE_READWRITE = 4'i32</pre></dt>   <dt><pre data-language="nim">FILE_MAP_READ = 4'i32</pre></dt>   <dt><pre data-language="nim">FILE_MAP_WRITE = 2'i32</pre></dt>   <dt><pre>INVALID_FILE_SIZE = -1</pre></dt>   <dt><pre>DUPLICATE_SAME_ACCESS = 2</pre></dt>   <dt><pre>FILE_READ_DATA = 0x00000001</pre></dt>   <dt><pre>FILE_WRITE_DATA = 0x00000002</pre></dt>   <dt><pre>ERROR_FILE_NOT_FOUND = 2</pre></dt>   <dt><pre>ERROR_PATH_NOT_FOUND = 3</pre></dt>   <dt><pre>ERROR_ACCESS_DENIED = 5</pre></dt>   <dt><pre>ERROR_NO_MORE_FILES = 18</pre></dt>   <dt><pre>ERROR_LOCK_VIOLATION = 33</pre></dt>   <dt><pre>ERROR_HANDLE_EOF = 38</pre></dt>   <dt><pre>ERROR_BAD_ARGUMENTS = 165</pre></dt>   <dt><pre>ERROR_IO_PENDING = 997</pre></dt>   <dt><pre>WSAECONNABORTED = 10053</pre></dt>   <dt><pre>WSAEADDRINUSE = 10048</pre></dt>   <dt><pre>WSAECONNRESET = 10054</pre></dt>   <dt><pre>WSAEDISCON = 10101</pre></dt>   <dt><pre>WSAENETRESET = 10052</pre></dt>   <dt><pre>WSAETIMEDOUT = 10060</pre></dt>   <dt><pre>WSANOTINITIALISED = 10093</pre></dt>   <dt><pre>WSAENOTSOCK = 10038</pre></dt>   <dt><pre>WSAEINPROGRESS = 10036</pre></dt>   <dt><pre>WSAEINTR = 10004</pre></dt>   <dt><pre>WSAEWOULDBLOCK = 10035</pre></dt>   <dt><pre>ERROR_NETNAME_DELETED = 64</pre></dt>   <dt><pre>STATUS_PENDING = 0x00000103</pre></dt>   <dt><pre>IOC_OUT = 0x40000000</pre></dt>   <dt><pre data-language="nim">IOC_IN = 0x0000000080000000'i64</pre></dt>   <dt><pre>IOC_WS2 = 0x08000000</pre></dt>   <dt><pre>IOC_INOUT = 3221225472</pre></dt>   <dt><pre>SIO_GET_EXTENSION_FUNCTION_POINTER = 3355443206</pre></dt>   <dt><pre>SO_UPDATE_ACCEPT_CONTEXT = 0x0000700B</pre></dt>   <dt><pre>AI_V4MAPPED = 0x00000008</pre></dt>   <dt><pre>AF_UNSPEC = 0</pre></dt>   <dt><pre>AF_INET = 2</pre></dt>   <dt><pre>AF_INET6 = 23</pre></dt>   <dt><pre data-language="nim">WT_EXECUTEDEFAULT = 0x00000000'i32</pre></dt>   <dt><pre data-language="nim">WT_EXECUTEINIOTHREAD = 0x00000001'i32</pre></dt>   <dt><pre data-language="nim">WT_EXECUTEINUITHREAD = 0x00000002'i32</pre></dt>   <dt><pre data-language="nim">WT_EXECUTEINWAITTHREAD = 0x00000004'i32</pre></dt>   <dt><pre data-language="nim">WT_EXECUTEONLYONCE = 0x00000008'i32</pre></dt>   <dt><pre data-language="nim">WT_EXECUTELONGFUNCTION = 0x00000010'i32</pre></dt>   <dt><pre data-language="nim">WT_EXECUTEINTIMERTHREAD = 0x00000020'i32</pre></dt>   <dt><pre data-language="nim">WT_EXECUTEINPERSISTENTIOTHREAD = 0x00000040'i32</pre></dt>   <dt><pre data-language="nim">WT_EXECUTEINPERSISTENTTHREAD = 0x00000080'i32</pre></dt>   <dt><pre data-language="nim">WT_TRANSFER_IMPERSONATION = 0x00000100'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_TERMINATE = 0x00000001'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_CREATE_THREAD = 0x00000002'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_SET_SESSIONID = 0x00000004'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_VM_OPERATION = 0x00000008'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_VM_READ = 0x00000010'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_VM_WRITE = 0x00000020'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_DUP_HANDLE = 0x00000040'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_CREATE_PROCESS = 0x00000080'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_SET_QUOTA = 0x00000100'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_SET_INFORMATION = 0x00000200'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_QUERY_INFORMATION = 0x00000400'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_SUSPEND_RESUME = 0x00000800'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_QUERY_LIMITED_INFORMATION = 0x00001000'i32</pre></dt>   <dt><pre data-language="nim">PROCESS_SET_LIMITED_INFORMATION = 0x00002000'i32</pre></dt>   <dt><pre data-language="nim">FD_READ = 0x00000001'i32</pre></dt>   <dt><pre data-language="nim">FD_WRITE = 0x00000002'i32</pre></dt>   <dt><pre data-language="nim">FD_OOB = 0x00000004'i32</pre></dt>   <dt><pre data-language="nim">FD_ACCEPT = 0x00000008'i32</pre></dt>   <dt><pre data-language="nim">FD_CONNECT = 0x00000010'i32</pre></dt>   <dt><pre data-language="nim">FD_CLOSE = 0x00000020'i32</pre></dt>   <dt><pre data-language="nim">FD_QQS = 0x00000040'i32</pre></dt>   <dt><pre data-language="nim">FD_GROUP_QQS = 0x00000080'i32</pre></dt>   <dt><pre data-language="nim">FD_ROUTING_INTERFACE_CHANGE = 0x00000100'i32</pre></dt>   <dt><pre data-language="nim">FD_ADDRESS_LIST_CHANGE = 0x00000200'i32</pre></dt>   <dt><pre data-language="nim">FD_ALL_EVENTS = 0x000003FF'i32</pre></dt>   <dt><pre>FIBER_FLAG_FLOAT_SWITCH = 0x00000001</pre></dt>  </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre data-language="nim">proc getVersionExW(lpVersionInfo: ptr OSVERSIONINFO): WINBOOL {...}{.stdcall,
    dynlib: "kernel32", importc: "GetVersionExW".}</pre></dt>   <dt><pre data-language="nim">proc getVersion(): DWORD {...}{.stdcall, dynlib: "kernel32", importc: "GetVersion".}</pre></dt>   <dt><pre data-language="nim">proc closeHandle(hObject: Handle): WINBOOL {...}{.stdcall, dynlib: "kernel32",
    importc: "CloseHandle".}</pre></dt>   <dt><pre data-language="nim">proc readFile(hFile: Handle; Buffer: pointer; nNumberOfBytesToRead: int32;
             lpNumberOfBytesRead: ptr int32; lpOverlapped: pointer): WINBOOL {...}{.
    stdcall, dynlib: "kernel32", importc: "ReadFile".}</pre></dt>   <dt><pre data-language="nim">proc writeFile(hFile: Handle; Buffer: pointer; nNumberOfBytesToWrite: int32;
              lpNumberOfBytesWritten: ptr int32; lpOverlapped: pointer): WINBOOL {...}{.
    stdcall, dynlib: "kernel32", importc: "WriteFile".}</pre></dt>   <dt><pre data-language="nim">proc createPipe(hReadPipe, hWritePipe: var Handle;
               lpPipeAttributes: var SECURITY_ATTRIBUTES; nSize: int32): WINBOOL {...}{.
    stdcall, dynlib: "kernel32", importc: "CreatePipe".}</pre></dt>   <dt><pre data-language="nim">proc createNamedPipe(lpName: WideCString; dwOpenMode, dwPipeMode, nMaxInstances,
                                       nOutBufferSize, nInBufferSize,
                                       nDefaultTimeOut: int32;
                    lpSecurityAttributes: ptr SECURITY_ATTRIBUTES): Handle {...}{.
    stdcall, dynlib: "kernel32", importc: "CreateNamedPipeW".}</pre></dt>   <dt><pre data-language="nim">proc peekNamedPipe(hNamedPipe: Handle; lpBuffer: pointer = nil; nBufferSize: int32 = 0;
                  lpBytesRead: ptr int32 = nil; lpTotalBytesAvail: ptr int32 = nil;
                  lpBytesLeftThisMessage: ptr int32 = nil): bool {...}{.stdcall,
    dynlib: "kernel32", importc: "PeekNamedPipe".}</pre></dt>   <dt><pre data-language="nim">proc createProcessW(lpApplicationName, lpCommandLine: WideCString;
                   lpProcessAttributes: ptr SECURITY_ATTRIBUTES;
                   lpThreadAttributes: ptr SECURITY_ATTRIBUTES;
                   bInheritHandles: WINBOOL; dwCreationFlags: int32;
                   lpEnvironment, lpCurrentDirectory: WideCString;
                   lpStartupInfo: var STARTUPINFO;
                   lpProcessInformation: var PROCESS_INFORMATION): WINBOOL {...}{.
    stdcall, dynlib: "kernel32", importc: "CreateProcessW".}</pre></dt>   <dt><pre data-language="nim">proc suspendThread(hThread: Handle): int32 {...}{.stdcall, dynlib: "kernel32",
    importc: "SuspendThread".}</pre></dt>   <dt><pre data-language="nim">proc resumeThread(hThread: Handle): int32 {...}{.stdcall, dynlib: "kernel32",
                                        importc: "ResumeThread".}</pre></dt>   <dt><pre data-language="nim">proc waitForSingleObject(hHandle: Handle; dwMilliseconds: int32): int32 {...}{.stdcall,
    dynlib: "kernel32", importc: "WaitForSingleObject".}</pre></dt>   <dt><pre data-language="nim">proc terminateProcess(hProcess: Handle; uExitCode: int): WINBOOL {...}{.stdcall,
    dynlib: "kernel32", importc: "TerminateProcess".}</pre></dt>   <dt><pre data-language="nim">proc getExitCodeProcess(hProcess: Handle; lpExitCode: var int32): WINBOOL {...}{.stdcall,
    dynlib: "kernel32", importc: "GetExitCodeProcess".}</pre></dt>   <dt><pre data-language="nim">proc getStdHandle(nStdHandle: int32): Handle {...}{.stdcall, dynlib: "kernel32",
    importc: "GetStdHandle".}</pre></dt>   <dt><pre data-language="nim">proc setStdHandle(nStdHandle: int32; hHandle: Handle): WINBOOL {...}{.stdcall,
    dynlib: "kernel32", importc: "SetStdHandle".}</pre></dt>   <dt><pre data-language="nim">proc flushFileBuffers(hFile: Handle): WINBOOL {...}{.stdcall, dynlib: "kernel32",
    importc: "FlushFileBuffers".}</pre></dt>   <dt><pre data-language="nim">proc getLastError(): int32 {...}{.importc: "GetLastError", stdcall, dynlib: "kernel32".}</pre></dt>   <dt><pre data-language="nim">proc setLastError(error: int32) {...}{.importc: "SetLastError", stdcall, dynlib: "kernel32".}</pre></dt>   <dt><pre data-language="nim">proc formatMessageW(dwFlags: int32; lpSource: pointer;
                   dwMessageId, dwLanguageId: int32; lpBuffer: pointer; nSize: int32;
                   Arguments: pointer): int32 {...}{.importc: "FormatMessageW", stdcall,
    dynlib: "kernel32".}</pre></dt>   <dt><pre data-language="nim">proc localFree(p: pointer) {...}{.importc: "LocalFree", stdcall, dynlib: "kernel32".}</pre></dt>   <dt><pre data-language="nim">proc getCurrentDirectoryW(nBufferLength: int32; lpBuffer: WideCString): int32 {...}{.
    importc: "GetCurrentDirectoryW", dynlib: "kernel32", stdcall.}</pre></dt>   <dt><pre data-language="nim">proc setCurrentDirectoryW(lpPathName: WideCString): int32 {...}{.
    importc: "SetCurrentDirectoryW", dynlib: "kernel32", stdcall.}</pre></dt>   <dt><pre data-language="nim">proc createDirectoryW(pathName: WideCString; security: pointer = nil): int32 {...}{.
    importc: "CreateDirectoryW", dynlib: "kernel32", stdcall.}</pre></dt>   <dt><pre data-language="nim">proc removeDirectoryW(lpPathName: WideCString): int32 {...}{.importc: "RemoveDirectoryW",
    dynlib: "kernel32", stdcall.}</pre></dt>   <dt><pre data-language="nim">proc setEnvironmentVariableW(lpName, lpValue: WideCString): int32 {...}{.stdcall,
    dynlib: "kernel32", importc: "SetEnvironmentVariableW".}</pre></dt>   <dt><pre data-language="nim">proc getModuleFileNameW(handle: Handle; buf: WideCString; size: int32): int32 {...}{.
    importc: "GetModuleFileNameW", dynlib: "kernel32", stdcall.}</pre></dt>   <dt><pre data-language="nim">proc createSymbolicLinkW(lpSymlinkFileName, lpTargetFileName: WideCString;
                        flags: DWORD): int32 {...}{.importc: "CreateSymbolicLinkW",
    dynlib: "kernel32", stdcall.}</pre></dt>   <dt><pre data-language="nim">proc createHardLinkW(lpFileName, lpExistingFileName: WideCString;
                    security: pointer = nil): int32 {...}{.importc: "CreateHardLinkW",
    dynlib: "kernel32", stdcall.}</pre></dt>   <dt><pre data-language="nim">proc findFirstFileW(lpFileName: WideCString; lpFindFileData: var WIN32_FIND_DATA): Handle {...}{.
    stdcall, dynlib: "kernel32", importc: "FindFirstFileW".}</pre></dt>   <dt><pre data-language="nim">proc findNextFileW(hFindFile: Handle; lpFindFileData: var WIN32_FIND_DATA): int32 {...}{.
    stdcall, dynlib: "kernel32", importc: "FindNextFileW".}</pre></dt>   <dt><pre data-language="nim">proc findClose(hFindFile: Handle) {...}{.stdcall, dynlib: "kernel32", importc: "FindClose".}</pre></dt>   <dt><pre data-language="nim">proc getFullPathNameW(lpFileName: WideCString; nBufferLength: int32;
                     lpBuffer: WideCString; lpFilePart: var WideCString): int32 {...}{.
    stdcall, dynlib: "kernel32", importc: "GetFullPathNameW".}</pre></dt>   <dt><pre data-language="nim">proc getFileAttributesW(lpFileName: WideCString): int32 {...}{.stdcall,
    dynlib: "kernel32", importc: "GetFileAttributesW".}</pre></dt>   <dt><pre data-language="nim">proc setFileAttributesW(lpFileName: WideCString; dwFileAttributes: int32): WINBOOL {...}{.
    stdcall, dynlib: "kernel32", importc: "SetFileAttributesW".}</pre></dt>   <dt><pre data-language="nim">proc copyFileW(lpExistingFileName, lpNewFileName: WideCString;
              bFailIfExists: WINBOOL): WINBOOL {...}{.importc: "CopyFileW", stdcall,
    dynlib: "kernel32".}</pre></dt>   <dt><pre data-language="nim">proc moveFileW(lpExistingFileName, lpNewFileName: WideCString): WINBOOL {...}{.
    importc: "MoveFileW", stdcall, dynlib: "kernel32".}</pre></dt>   <dt><pre data-language="nim">proc moveFileExW(lpExistingFileName, lpNewFileName: WideCString; flags: DWORD): WINBOOL {...}{.
    importc: "MoveFileExW", stdcall, dynlib: "kernel32".}</pre></dt>   <dt><pre data-language="nim">proc getEnvironmentStringsW(): WideCString {...}{.stdcall, dynlib: "kernel32",
    importc: "GetEnvironmentStringsW".}</pre></dt>   <dt><pre data-language="nim">proc freeEnvironmentStringsW(para1: WideCString): int32 {...}{.stdcall,
    dynlib: "kernel32", importc: "FreeEnvironmentStringsW".}</pre></dt>   <dt><pre data-language="nim">proc getCommandLineW(): WideCString {...}{.importc: "GetCommandLineW", stdcall,
                                   dynlib: "kernel32".}</pre></dt>   <dt><pre data-language="nim">proc rdFileTime(f: FILETIME): int64 {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc rdFileSize(f: WIN32_FIND_DATA): int64 {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc getSystemTimeAsFileTime(lpSystemTimeAsFileTime: var FILETIME) {...}{.
    importc: "GetSystemTimeAsFileTime", dynlib: "kernel32", stdcall.}</pre></dt>   <dt><pre data-language="nim">proc sleep(dwMilliseconds: int32) {...}{.stdcall, dynlib: "kernel32", importc: "Sleep".}</pre></dt>   <dt><pre data-language="nim">proc shellExecuteW(HWND: Handle;
                  lpOperation, lpFile, lpParameters, lpDirectory: WideCString;
                  nShowCmd: int32): Handle {...}{.stdcall, dynlib: "shell32.dll",
    importc: "ShellExecuteW".}</pre></dt>   <dt><pre data-language="nim">proc getFileInformationByHandle(hFile: Handle; lpFileInformation: ptr BY_HANDLE_FILE_INFORMATION): WINBOOL {...}{.
    stdcall, dynlib: "kernel32", importc: "GetFileInformationByHandle".}</pre></dt>   <dt><pre data-language="nim">proc wsaGetLastError(): cint {...}{.importc: "WSAGetLastError", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc `==`(x, y: SocketHandle): bool {...}{.borrow.}</pre></dt>   <dt><pre data-language="nim">proc getservbyname(name, proto: cstring): ptr Servent {...}{.stdcall,
    importc: "getservbyname", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc getservbyport(port: cint; proto: cstring): ptr Servent {...}{.stdcall,
    importc: "getservbyport", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc gethostbyaddr(ip: ptr InAddr; len: cuint; theType: cint): ptr Hostent {...}{.stdcall,
    importc: "gethostbyaddr", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc gethostbyname(name: cstring): ptr Hostent {...}{.stdcall, importc: "gethostbyname",
    dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc gethostname(hostname: cstring; len: cint): cint {...}{.stdcall, importc: "gethostname",
    dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc socket(af, typ, protocol: cint): SocketHandle {...}{.stdcall, importc: "socket",
    dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc closesocket(s: SocketHandle): cint {...}{.stdcall, importc: "closesocket",
                                      dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc accept(s: SocketHandle; a: ptr SockAddr; addrlen: ptr SockLen): SocketHandle {...}{.
    stdcall, importc: "accept", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc bindSocket(s: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint {...}{.stdcall,
    importc: "bind", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc connect(s: SocketHandle; name: ptr SockAddr; namelen: SockLen): cint {...}{.stdcall,
    importc: "connect", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc getsockname(s: SocketHandle; name: ptr SockAddr; namelen: ptr SockLen): cint {...}{.
    stdcall, importc: "getsockname", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc getpeername(s: SocketHandle; name: ptr SockAddr; namelen: ptr SockLen): cint {...}{.
    stdcall, importc, dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc getsockopt(s: SocketHandle; level, optname: cint; optval: pointer;
               optlen: ptr SockLen): cint {...}{.stdcall, importc: "getsockopt",
                                        dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc setsockopt(s: SocketHandle; level, optname: cint; optval: pointer; optlen: SockLen): cint {...}{.
    stdcall, importc: "setsockopt", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc listen(s: SocketHandle; backlog: cint): cint {...}{.stdcall, importc: "listen",
    dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc recv(s: SocketHandle; buf: pointer; len, flags: cint): cint {...}{.stdcall,
    importc: "recv", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc recvfrom(s: SocketHandle; buf: cstring; len, flags: cint; fromm: ptr SockAddr;
             fromlen: ptr SockLen): cint {...}{.stdcall, importc: "recvfrom", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc select(nfds: cint; readfds, writefds, exceptfds: ptr TFdSet; timeout: ptr Timeval): cint {...}{.
    stdcall, importc: "select", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc send(s: SocketHandle; buf: pointer; len, flags: cint): cint {...}{.stdcall,
    importc: "send", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc sendto(s: SocketHandle; buf: pointer; len, flags: cint; to: ptr SockAddr;
           tolen: SockLen): cint {...}{.stdcall, importc: "sendto", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc shutdown(s: SocketHandle; how: cint): cint {...}{.stdcall, importc: "shutdown",
    dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc getnameinfo(a1: ptr SockAddr; a2: SockLen; a3: cstring; a4: SockLen; a5: cstring;
                a6: SockLen; a7: cint): cint {...}{.stdcall, importc: "getnameinfo",
    dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc inet_addr(cp: cstring): uint32 {...}{.stdcall, importc: "inet_addr", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc FD_ISSET(socket: SocketHandle; set: var TFdSet): cint {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc FD_SET(socket: SocketHandle; s: var TFdSet) {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc FD_ZERO(s: var TFdSet) {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc wsaStartup(wVersionRequired: int16; WSData: ptr WSAData): cint {...}{.stdcall,
    importc: "WSAStartup", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc getaddrinfo(nodename, servname: cstring; hints: ptr AddrInfo;
                res: var ptr AddrInfo): cint {...}{.stdcall, importc: "getaddrinfo",
    dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc freeaddrinfo(ai: ptr AddrInfo) {...}{.stdcall, importc: "freeaddrinfo", dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc inet_ntoa(i: InAddr): cstring {...}{.stdcall, importc, dynlib: ws2dll.}</pre></dt>   <dt><pre data-language="nim">proc waitForMultipleObjects(nCount: DWORD; lpHandles: PWOHandleArray;
                           bWaitAll: WINBOOL; dwMilliseconds: DWORD): DWORD {...}{.
    stdcall, dynlib: "kernel32", importc: "WaitForMultipleObjects".}</pre></dt>   <dt><pre data-language="nim">proc duplicateHandle(hSourceProcessHandle: Handle; hSourceHandle: Handle;
                    hTargetProcessHandle: Handle; lpTargetHandle: ptr Handle;
                    dwDesiredAccess: DWORD; bInheritHandle: WINBOOL;
                    dwOptions: DWORD): WINBOOL {...}{.stdcall, dynlib: "kernel32",
    importc: "DuplicateHandle".}</pre></dt>   <dt><pre data-language="nim">proc setHandleInformation(hObject: Handle; dwMask: DWORD; dwFlags: DWORD): WINBOOL {...}{.
    stdcall, dynlib: "kernel32", importc: "SetHandleInformation".}</pre></dt>   <dt><pre data-language="nim">proc getCurrentProcess(): Handle {...}{.stdcall, dynlib: "kernel32",
                                importc: "GetCurrentProcess".}</pre></dt>   <dt><pre data-language="nim">proc createFileW(lpFileName: WideCString; dwDesiredAccess, dwShareMode: DWORD;
                lpSecurityAttributes: pointer;
                dwCreationDisposition, dwFlagsAndAttributes: DWORD;
                hTemplateFile: Handle): Handle {...}{.stdcall, dynlib: "kernel32",
    importc: "CreateFileW".}</pre></dt>   <dt><pre data-language="nim">proc deleteFileW(pathName: WideCString): int32 {...}{.importc: "DeleteFileW",
    dynlib: "kernel32", stdcall.}</pre></dt>   <dt><pre data-language="nim">proc setEndOfFile(hFile: Handle): WINBOOL {...}{.stdcall, dynlib: "kernel32",
                                        importc: "SetEndOfFile".}</pre></dt>   <dt><pre data-language="nim">proc setFilePointer(hFile: Handle; lDistanceToMove: LONG;
                   lpDistanceToMoveHigh: ptr LONG; dwMoveMethod: DWORD): DWORD {...}{.
    stdcall, dynlib: "kernel32", importc: "SetFilePointer".}</pre></dt>   <dt><pre data-language="nim">proc getFileSize(hFile: Handle; lpFileSizeHigh: ptr DWORD): DWORD {...}{.stdcall,
    dynlib: "kernel32", importc: "GetFileSize".}</pre></dt>   <dt><pre data-language="nim">proc mapViewOfFileEx(hFileMappingObject: Handle; dwDesiredAccess: DWORD;
                    dwFileOffsetHigh, dwFileOffsetLow: DWORD;
                    dwNumberOfBytesToMap: DWORD; lpBaseAddress: pointer): pointer {...}{.
    stdcall, dynlib: "kernel32", importc: "MapViewOfFileEx".}</pre></dt>   <dt><pre data-language="nim">proc createFileMappingW(hFile: Handle; lpFileMappingAttributes: pointer;
                       flProtect, dwMaximumSizeHigh: DWORD;
                       dwMaximumSizeLow: DWORD; lpName: pointer): Handle {...}{.stdcall,
    dynlib: "kernel32", importc: "CreateFileMappingW".}</pre></dt>   <dt><pre data-language="nim">proc unmapViewOfFile(lpBaseAddress: pointer): WINBOOL {...}{.stdcall, dynlib: "kernel32",
    importc: "UnmapViewOfFile".}</pre></dt>   <dt><pre data-language="nim">proc flushViewOfFile(lpBaseAddress: pointer; dwNumberOfBytesToFlush: DWORD): WINBOOL {...}{.
    stdcall, dynlib: "kernel32", importc: "FlushViewOfFile".}</pre></dt>   <dt><pre data-language="nim">proc createIoCompletionPort(FileHandle: Handle; ExistingCompletionPort: Handle;
                           CompletionKey: ULONG_PTR;
                           NumberOfConcurrentThreads: DWORD): Handle {...}{.stdcall,
    dynlib: "kernel32", importc: "CreateIoCompletionPort".}</pre></dt>   <dt><pre data-language="nim">proc getQueuedCompletionStatus(CompletionPort: Handle;
                              lpNumberOfBytesTransferred: PDWORD;
                              lpCompletionKey: PULONG_PTR;
                              lpOverlapped: ptr POVERLAPPED; dwMilliseconds: DWORD): WINBOOL {...}{.
    stdcall, dynlib: "kernel32", importc: "GetQueuedCompletionStatus".}</pre></dt>   <dt><pre data-language="nim">proc getOverlappedResult(hFile: Handle; lpOverlapped: POVERLAPPED;
                        lpNumberOfBytesTransferred: var DWORD; bWait: WINBOOL): WINBOOL {...}{.
    stdcall, dynlib: "kernel32", importc: "GetOverlappedResult".}</pre></dt>   <dt><pre data-language="nim">proc WSAIoctl(s: SocketHandle; dwIoControlCode: DWORD; lpvInBuffer: pointer;
             cbInBuffer: DWORD; lpvOutBuffer: pointer; cbOutBuffer: DWORD;
             lpcbBytesReturned: PDWORD; lpOverlapped: POVERLAPPED;
             lpCompletionRoutine: POVERLAPPED_COMPLETION_ROUTINE): cint {...}{.stdcall,
    importc: "WSAIoctl", dynlib: "Ws2_32.dll".}</pre></dt>   <dt><pre data-language="nim">proc WSARecv(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD;
            bytesReceived, flags: PDWORD; lpOverlapped: POVERLAPPED;
            completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint {...}{.stdcall,
    importc: "WSARecv", dynlib: "Ws2_32.dll".}</pre></dt>   <dt><pre data-language="nim">proc WSARecvFrom(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD;
                bytesReceived: PDWORD; flags: PDWORD; name: ptr SockAddr;
                namelen: ptr cint; lpOverlapped: POVERLAPPED;
                completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint {...}{.stdcall,
    importc: "WSARecvFrom", dynlib: "Ws2_32.dll".}</pre></dt>   <dt><pre data-language="nim">proc WSASend(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD; bytesSent: PDWORD;
            flags: DWORD; lpOverlapped: POVERLAPPED;
            completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint {...}{.stdcall,
    importc: "WSASend", dynlib: "Ws2_32.dll".}</pre></dt>   <dt><pre data-language="nim">proc WSASendTo(s: SocketHandle; buf: ptr TWSABuf; bufCount: DWORD; bytesSent: PDWORD;
              flags: DWORD; name: ptr SockAddr; namelen: cint;
              lpOverlapped: POVERLAPPED;
              completionProc: POVERLAPPED_COMPLETION_ROUTINE): cint {...}{.stdcall,
    importc: "WSASendTo", dynlib: "Ws2_32.dll".}</pre></dt>   <dt><pre data-language="nim">proc get_osfhandle(fd: FileHandle): Handle {...}{.importc: "_get_osfhandle",
    header: "&lt;io.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc getSystemTimes(lpIdleTime, lpKernelTime, lpUserTime: var FILETIME): WINBOOL {...}{.
    stdcall, dynlib: "kernel32", importc: "GetSystemTimes".}</pre></dt>   <dt><pre data-language="nim">proc getProcessTimes(hProcess: Handle; lpCreationTime, lpExitTime, lpKernelTime,
                                    lpUserTime: var FILETIME): WINBOOL {...}{.stdcall,
    dynlib: "kernel32", importc: "GetProcessTimes".}</pre></dt>   <dt><pre data-language="nim">proc inet_ntop(family: cint; paddr: pointer; pStringBuffer: cstring;
              stringBufSize: int32): cstring {...}{.stdcall, raises: [Exception],
    tags: [RootEffect].}</pre></dt> <dd> "is greater or equals" operator. This is the same as <code>y &lt;= x</code>.   </dd>  <dt><pre data-language="nim">proc postQueuedCompletionStatus(CompletionPort: Handle;
                               dwNumberOfBytesTransferred: DWORD;
                               dwCompletionKey: ULONG_PTR; lpOverlapped: pointer): bool {...}{.
    stdcall, dynlib: "kernel32", importc: "PostQueuedCompletionStatus".}</pre></dt>   <dt><pre data-language="nim">proc registerWaitForSingleObject(phNewWaitObject: ptr Handle; hObject: Handle;
                                Callback: WAITORTIMERCALLBACK; Context: pointer;
                                dwMilliseconds: ULONG; dwFlags: ULONG): bool {...}{.
    stdcall, dynlib: "kernel32", importc: "RegisterWaitForSingleObject".}</pre></dt>   <dt><pre data-language="nim">proc unregisterWait(WaitHandle: Handle): DWORD {...}{.stdcall, dynlib: "kernel32",
    importc: "UnregisterWait".}</pre></dt>   <dt><pre data-language="nim">proc openProcess(dwDesiredAccess: DWORD; bInheritHandle: WINBOOL; dwProcessId: DWORD): Handle {...}{.
    stdcall, dynlib: "kernel32", importc: "OpenProcess".}</pre></dt>   <dt><pre data-language="nim">proc createEvent(lpEventAttributes: ptr SECURITY_ATTRIBUTES; bManualReset: DWORD;
                bInitialState: DWORD; lpName: ptr Utf16Char): Handle {...}{.stdcall,
    dynlib: "kernel32", importc: "CreateEventW".}</pre></dt>   <dt><pre data-language="nim">proc setEvent(hEvent: Handle): cint {...}{.stdcall, dynlib: "kernel32", importc: "SetEvent".}</pre></dt>   <dt><pre data-language="nim">proc wsaEventSelect(s: SocketHandle; hEventObject: Handle; lNetworkEvents: clong): cint {...}{.
    stdcall, importc: "WSAEventSelect", dynlib: "ws2_32.dll".}</pre></dt>   <dt><pre data-language="nim">proc wsaCreateEvent(): Handle {...}{.stdcall, importc: "WSACreateEvent",
                             dynlib: "ws2_32.dll".}</pre></dt>   <dt><pre data-language="nim">proc wsaCloseEvent(hEvent: Handle): bool {...}{.stdcall, importc: "WSACloseEvent",
                                       dynlib: "ws2_32.dll".}</pre></dt>   <dt><pre data-language="nim">proc wsaResetEvent(hEvent: Handle): bool {...}{.stdcall, importc: "WSAResetEvent",
                                       dynlib: "ws2_32.dll".}</pre></dt>   <dt><pre data-language="nim">proc readConsoleInput(hConsoleInput: Handle; lpBuffer: pointer; nLength: cint;
                     lpNumberOfEventsRead: ptr cint): cint {...}{.stdcall,
    dynlib: "kernel32", importc: "ReadConsoleInputW".}</pre></dt>   <dt><pre data-language="nim">proc CreateFiber(stackSize: int; fn: LPFIBER_START_ROUTINE; param: pointer): pointer {...}{.
    stdcall, discardable, dynlib: "kernel32", importc.}</pre></dt>   <dt><pre data-language="nim">proc CreateFiberEx(stkCommit: int; stkReserve: int; flags: int32;
                  fn: LPFIBER_START_ROUTINE; param: pointer): pointer {...}{.stdcall,
    discardable, dynlib: "kernel32", importc.}</pre></dt>   <dt><pre data-language="nim">proc ConvertThreadToFiber(param: pointer): pointer {...}{.stdcall, discardable,
    dynlib: "kernel32", importc.}</pre></dt>   <dt><pre data-language="nim">proc ConvertThreadToFiberEx(param: pointer; flags: int32): pointer {...}{.stdcall,
    discardable, dynlib: "kernel32", importc.}</pre></dt>   <dt><pre data-language="nim">proc DeleteFiber(fiber: pointer): void {...}{.stdcall, discardable, dynlib: "kernel32",
                                     importc.}</pre></dt>   <dt><pre data-language="nim">proc SwitchToFiber(fiber: pointer): void {...}{.stdcall, discardable, dynlib: "kernel32",
                                       importc.}</pre></dt>   <dt><pre data-language="nim">proc GetCurrentFiber(): pointer {...}{.stdcall, importc, header: "Windows.h".}</pre></dt>   <dt><pre data-language="nim">proc toFILETIME(t: int64): FILETIME {...}{.raises: [], tags: [].}</pre></dt> <dd> Convert the Windows file time timestamp <code>t</code> to <code>FILETIME</code>.   </dd>  <dt><pre data-language="nim">proc setFileTime(hFile: Handle; lpCreationTime: LPFILETIME;
                lpLastAccessTime: LPFILETIME; lpLastWriteTime: LPFILETIME): WINBOOL {...}{.
    stdcall, dynlib: "kernel32", importc: "SetFileTime".}</pre></dt>  </dl>  <h2 id="18">Templates</h2> <dl>  <dt><pre data-language="nim">template hasOverlappedIoCompleted(lpOverlapped): bool</pre></dt>   <dt><pre data-language="nim">template WSAIORW(x, y): untyped</pre></dt>  </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2018 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/winlean.html" class="_attribution-link">https://nim-lang.org/docs/winlean.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
