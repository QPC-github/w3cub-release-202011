
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Internals of the Nim Compiler - Nim - W3cubDocs</title>
  
  <meta name="description" content=" &#34;Abstraction is layering ignorance on top of reality.&#34; -- Richard Gabriel ">
  <meta name="keywords" content="internals, nim, compiler">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nim/intern.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/nim.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="title">Internals of the Nim Compiler</h1>  
<blockquote><p>"Abstraction is layering ignorance on top of reality." -- Richard Gabriel</p></blockquote> <h2 id="directory-structure">Directory structure</h2>
<p>The Nim project's directory structure is:</p> <table>
<tr>
<th>Path</th>
<th>Purpose</th>
</tr> <tr>
<td><code>bin</code></td>
<td>generated binary files</td>
</tr> <tr>
<td><code>build</code></td>
<td>generated C code for the installation</td>
</tr> <tr>
<td><code>compiler</code></td>
<td>the Nim compiler itself; note that this code has been translated from a bootstrapping version written in Pascal, so the code is <strong>not</strong> a poster child of good Nim code</td>
</tr> <tr>
<td><code>config</code></td>
<td>configuration files for Nim</td>
</tr> <tr>
<td><code>dist</code></td>
<td>additional packages for the distribution</td>
</tr> <tr>
<td><code>doc</code></td>
<td>the documentation; it is a bunch of reStructuredText files</td>
</tr> <tr>
<td><code>lib</code></td>
<td>the Nim library</td>
</tr> <tr>
<td><code>web</code></td>
<td>website of Nim; generated by <code>nimweb</code> from the <code>*.txt</code> and <code>*.tmpl</code> files</td>
</tr> </table> <h2 id="bootstrapping-the-compiler">Bootstrapping the compiler</h2>
<p>Compiling the compiler is a simple matter of running:</p>
<pre data-language="nim">nim c koch.nim
./koch boot</pre> <p>For a release version use:</p>
<pre data-language="nim">nim c koch.nim
./koch boot -d:release</pre> <p>And for a debug version compatible with GDB:</p>
<pre data-language="nim">nim c koch.nim
./koch boot --debuginfo --linedir:on</pre> <p>The <code>koch</code> program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. More information about its options can be found in the <a href="koch">koch</a> documentation.</p> <h2 id="coding-guidelines">Coding Guidelines</h2>
<ul class="simple">
<li>Use CamelCase, not underscored_identifiers.</li> <li>Indent with two spaces.</li> <li>Max line length is 80 characters.</li> <li>Provide spaces around binary operators if that enhances readability.</li> <li>Use a space after a colon, but not before it.</li> <li>Start types with a capital <code>T</code>, unless they are pointers/references which start with <code>P</code>.</li> </ul> <p>See also the <a href="apis">API naming design</a> document.</p> <h2 id="porting-to-new-platforms">Porting to new platforms</h2>
<p>Porting Nim to a new architecture is pretty easy, since C is the most portable programming language (within certain limits) and Nim generates C code, porting the code generator is not necessary.</p> <p>POSIX-compliant systems on conventional hardware are usually pretty easy to port: Add the platform to <code>platform</code> (if it is not already listed there), check that the OS, System modules work and recompile Nim.</p> <p>The only case where things aren't as easy is when the garbage collector needs some assembler tweaking to work. The standard version of the GC uses C's <code>setjmp</code> function to store all registers on the hardware stack. It may be necessary that the new platform needs to replace this generic code by some assembler code.</p> <h2 id="runtime-type-information">Runtime type information</h2>
<p><em>Runtime type information</em> (RTTI) is needed for several aspects of the Nim programming language:</p> <dl>
<dt>Garbage collection</dt> <dd>The most important reason for RTTI. Generating traversal procedures produces bigger code and is likely to be slower on modern hardware as dynamic procedure binding is hard to predict.</dd> <dt>Complex assignments</dt> <dd>Sequences and strings are implemented as pointers to resizeable buffers, but Nim requires copying for assignments. Apart from RTTI the compiler could generate copy procedures for any type that needs one. However, this would make the code bigger and the RTTI is likely already there for the GC.</dd> </dl> <p>We already know the type information as a graph in the compiler. Thus we need to serialize this graph as RTTI for C code generation. Look at the file <code>lib/system/hti.nim</code> for more information.</p> <h2 id="debugging-the-compiler">Debugging the compiler</h2>
<p>You can of course use GDB or Visual Studio to debug the compiler (via <code>--debuginfo --lineDir:on</code>). However, there are also lots of procs that aid in debugging:</p> <pre class="listing" data-language="nim"># pretty prints the Nim AST
echo renderTree(someNode)
# outputs some JSON representation
debug(someNode)
# pretty prints some type
echo typeToString(someType)
debug(someType)
echo symbol.name.s
debug(symbol)
# pretty prints the Nim ast, but annotates symbol IDs:
echo renderTree(someNode, {renderIds})
if n.info ?? "temp.nim":
  # only output when it comes from "temp.nim"
  echo renderTree(n)
if n.info ?? "temp.nim":
  # why does it process temp.nim here?
  writeStackTrace()</pre>
<p>To create a new compiler for each run, use <code>koch temp</code>:</p>
<pre data-language="nim">./koch temp c /tmp/test.nim</pre> <p><code>koch temp</code> creates a debug build of the compiler, which is useful to create stacktraces for compiler debugging.</p> <p><code>koch temp</code> returns 125 as the exit code in case the compiler compilation fails. This exit code tells <code>git bisect</code> to skip the current commit.:</p>
<pre data-language="nim">git bisect start bad-commit good-commit
git bisect run ./koch temp -r c test-source.nim</pre> <h2 id="the-compiler-s-architecture">The compiler's architecture</h2>
<p>Nim uses the classic compiler architecture: A lexer/scanner feds tokens to a parser. The parser builds a syntax tree that is used by the code generator. This syntax tree is the interface between the parser and the code generator. It is essential to understand most of the compiler's code.</p> <p>In order to compile Nim correctly, type-checking has to be separated from parsing. Otherwise generics cannot work.</p> <h3 id="the-compiler-s-architecture-short-description-of-nim-s-modules">Short description of Nim's modules</h3>
<table>
<tr>
<th>Module</th>
<th>Description</th>
</tr> <tr>
<td>nim</td>
<td>main module: parses the command line and calls <code>main.MainCommand</code>
</td>
</tr> <tr>
<td>main</td>
<td>implements the top-level command dispatching</td>
</tr> <tr>
<td>nimconf</td>
<td>implements the config file reader</td>
</tr> <tr>
<td>syntaxes</td>
<td>dispatcher for the different parsers and filters</td>
</tr> <tr>
<td>filter_tmpl</td>
<td>standard template filter (<code>#? stdtempl</code>)</td>
</tr> <tr>
<td>lexbase</td>
<td>buffer handling of the lexical analyser</td>
</tr> <tr>
<td>lexer</td>
<td>lexical analyser</td>
</tr> <tr>
<td>parser</td>
<td>Nim's parser</td>
</tr> <tr>
<td>renderer</td>
<td>Nim code renderer (AST back to its textual form)</td>
</tr> <tr>
<td>options</td>
<td>contains global and local compiler options</td>
</tr> <tr>
<td>ast</td>
<td>type definitions of the abstract syntax tree (AST) and node constructors</td>
</tr> <tr>
<td>astalgo</td>
<td>algorithms for containers of AST nodes; converting the AST to YAML; the symbol table</td>
</tr> <tr>
<td>passes</td>
<td>implement the passes manager for passes over the AST</td>
</tr> <tr>
<td>trees</td>
<td>some algorithms for nodes; this module is less important</td>
</tr> <tr>
<td>types</td>
<td>module for traversing type graphs; also contain several helpers for dealing with types</td>
</tr> <tr>
<td></td>
<td></td>
</tr> <tr>
<td>sigmatch</td>
<td>contains the matching algorithm that is used for proc calls</td>
</tr> <tr>
<td>semexprs</td>
<td>contains the semantic checking phase for expressions</td>
</tr> <tr>
<td>semstmts</td>
<td>contains the semantic checking phase for statements</td>
</tr> <tr>
<td>semtypes</td>
<td>contains the semantic checking phase for types</td>
</tr> <tr>
<td>seminst</td>
<td>instantiation of generic procs and types</td>
</tr> <tr>
<td>semfold</td>
<td>contains code to deal with constant folding</td>
</tr> <tr>
<td>semthreads</td>
<td>deep program analysis for threads</td>
</tr> <tr>
<td>evals</td>
<td>contains an AST interpreter for compile time evaluation</td>
</tr> <tr>
<td>pragmas</td>
<td>semantic checking of pragmas</td>
</tr> <tr>
<td></td>
<td></td>
</tr> <tr>
<td>idents</td>
<td>implements a general mapping from identifiers to an internal representation (<code>PIdent</code>) that is used so that a simple id-comparison suffices to say whether two Nim identifiers are equivalent</td>
</tr> <tr>
<td>ropes</td>
<td>implements long strings represented as trees for lazy evaluation; used mainly by the code generators</td>
</tr> <tr>
<td></td>
<td></td>
</tr> <tr>
<td>transf</td>
<td>transformations on the AST that need to be done before code generation</td>
</tr> <tr>
<td>cgen</td>
<td>main file of the C code generator</td>
</tr> <tr>
<td>ccgutils</td>
<td>contains helpers for the C code generator</td>
</tr> <tr>
<td>ccgtypes</td>
<td>the generator for C types</td>
</tr> <tr>
<td>ccgstmts</td>
<td>the generator for statements</td>
</tr> <tr>
<td>ccgexprs</td>
<td>the generator for expressions</td>
</tr> <tr>
<td>extccomp</td>
<td>this module calls the C compiler and linker; interesting if you want to add support for a new C compiler</td>
</tr> </table> <h3 id="the-compiler-s-architecture-the-syntax-tree">The syntax tree</h3>
<p>The syntax tree consists of nodes which may have an arbitrary number of children. Types and symbols are represented by other nodes, because they may contain cycles. The AST changes its shape after semantic checking. This is needed to make life easier for the code generators. See the "ast" module for the type definitions. The <a href="macros">macros</a> module contains many examples how the AST represents each syntactic structure.</p> <h2 id="how-the-rtl-is-compiled">How the RTL is compiled</h2>
<p>The <code>system</code> module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it just like any other module. However, calls to some procedures like <code>addInt</code> are inserted by the CCG. Therefore the module <code>magicsys</code> contains a table (<code>compilerprocs</code>) with all symbols that are marked as <code>compilerproc</code>. <code>compilerprocs</code> are needed by the code generator. A <code>magic</code> proc is not the same as a <code>compilerproc</code>: A <code>magic</code> is a proc that needs compiler magic for its semantic checking, a <code>compilerproc</code> is a proc that is used by the code generator.</p> <h2 id="compilation-cache">Compilation cache</h2>
<p>The implementation of the compilation cache is tricky: There are lots of issues to be solved for the front- and backend.</p> <h3 id="compilation-cache-general-approachcolon-ast-replay">General approach: AST replay</h3>
<p>We store a module's AST of a successful semantic check in a SQLite database. There are plenty of features that require a sub sequence to be re-applied, for example:</p> <pre class="listing" data-language="nim">{.compile: "foo.c".} # even if the module is loaded from the DB,
                     # "foo.c" needs to be compiled/linked.</pre>
<p>The solution is to <strong>re-play</strong> the module's top level statements. This solves the problem without having to special case the logic that fills the internal seqs which are affected by the pragmas.</p> <p>In fact, this decribes how the AST should be stored in the database, as a "shallow" tree. Let's assume we compile module <code>m</code> with the following contents:</p> <pre class="listing" data-language="nim">import strutils

var x*: int = 90
{.compile: "foo.c".}
proc p = echo "p"
proc q = echo "q"
static:
  echo "static"</pre>
<p>Conceptually this is the AST we store for the module:</p> <pre class="listing" data-language="nim">import strutils

var x*
{.compile: "foo.c".}
proc p
proc q
static:
  echo "static"</pre>
<p>The symbol's <code>ast</code> field is loaded lazily, on demand. This is where most savings come from, only the shallow outer AST is reconstructed immediately.</p> <p>It is also important that the replay involves the <code>import</code> statement so that the dependencies are resolved properly.</p> <h3 id="compilation-cache-shared-global-compiletime-state">Shared global compiletime state</h3>
<p>Nim allows <code>.global, compiletime</code> variables that can be filled by macro invokations across different modules. This feature breaks modularity in a severe way. Plenty of different solutions have been proposed:</p> <ul class="simple">
<li>Restrict the types of global compiletime variables to <code>Set[T]</code> or similar unordered, only-growable collections so that we can track the module's write effects to these variables and reapply the changes in a different order.</li> <li>In every module compilation, reset the variable to its default value.</li> <li>Provide a restrictive API that can load/save the compiletime state to a file.</li> </ul> <p>(These solutions are not mutually exclusive.)</p> <p>Since we adopt the "replay the top level statements" idea, the natural solution to this problem is to emit pseudo top level statements that reflect the mutations done to the global variable. However, this is MUCH harder than it sounds, for example <code>squeaknim</code> uses this snippet:</p> <pre class="listing" data-language="nim">apicall.add(") module: '" &amp; dllName &amp; "'&gt;\C" &amp;
            "\t^self externalCallFailed\C!\C\C")
stCode.add(st &amp; "\C\t\"Generated by NimSqueak\"\C\t" &amp; apicall)</pre>
<p>We can "replay" <code>stCode.add</code> only if the values of <code>st</code> and <code>apicall</code> are known. And even then a hash table's <code>add</code> with its hashing mechanism is too hard to replay.</p> <p>In practice, things are worse still, consider <code>someGlobal[i][j].add arg</code>. We only know the root is <code>someGlobal</code> but the concrete path to the data is unknown as is the value that is added. We could compute a "diff" between the global states and use that to compute a symbol patchset, but this is quite some work, expensive to do at runtime (it would need to run after every module has been compiled) and also would break for hash tables.</p> <p>We need an API that hides the complex aliasing problems by not relying on Nim's global variables. The obvious solution is to use string keys instead of global variables:</p> <pre class="listing" data-language="nim">proc cachePut*(key: string; value: string)
proc cacheGet*(key: string): string</pre>
<p>However, the values being strings/json is quite problematic: Many lookup tables that are built at compiletime embed <em>proc vars</em> and types which have no obvious string representation... Seems like AST diffing is still the best idea as it will not require to use an alien API and works with some existing Nimble packages, at least.</p> <p>On the other hand, in Nim's future I would like to replace the VM by native code. A diff algorithm wouldn't work for that. Instead the native code would work with an API like <code>put</code>, <code>get</code>:</p> <pre class="listing" data-language="nim">proc cachePut*(key: string; value: NimNode)
proc cacheGet*(key: string): NimNode</pre>
<p>The API should embrace the AST diffing notion: See the module <code>macrocache</code> for the final details.</p> <h3 id="compilation-cache-methods-and-type-converters">Methods and type converters</h3>
<p>In the following sections <em>global</em> means <em>shared between modules</em> or <em>property of the whole program</em>.</p> <p>Nim contains language features that are <em>global</em>. The best example for that are multi methods: Introducing a new method with the same name and some compatible object parameter means that the method's dispatcher needs to take the new method into account. So the dispatching logic is only completely known after the whole program has been translated!</p> <p>Other features that are <em>implicitly</em> triggered cause problems for modularity too. Type converters fall into this category:</p> <pre class="listing" data-language="nim"># module A
converter toBool(x: int): bool =
  result = x != 0</pre>
<pre class="listing" data-language="nim"># module B
import A

if 1:
  echo "ugly, but should work"</pre>
<p>If in the above example module <code>B</code> is re-compiled, but <code>A</code> is not then <code>B</code> needs to be aware of <code>toBool</code> even though <code>toBool</code> is not referenced in <code>B</code> <em>explicitly</em>.</p> <p>Both the multi method and the type converter problems are solved by the AST replay implementation.</p> <h4 id="methods-and-type-converters-generics">Generics</h4>
<p>We cache generic instantiations and need to ensure this caching works well with the incremental compilation feature. Since the cache is attached to the <code>PSym</code> datastructure, it should work without any special logic.</p> <h3 id="compilation-cache-backend-issues">Backend issues</h3>
<ul class="simple">
<li>Init procs must not be "forgotten" to be called.</li> <li>Files must not be "forgotten" to be linked.</li> <li>Method dispatchers are global.</li> <li>DLL loading via <code>dlsym</code> is global.</li> <li>Emulated thread vars are global.</li> </ul> <p>However the biggest problem is that dead code elimination breaks modularity! To see why, consider this scenario: The module <code>G</code> (for example the huge Gtk2 module...) is compiled with dead code elimination turned on. So none of <code>G</code>'s procs is generated at all.</p> <p>Then module <code>B</code> is compiled that requires <code>G.P1</code>. Ok, no problem, <code>G.P1</code> is loaded from the symbol file and <code>G.c</code> now contains <code>G.P1</code>.</p> <p>Then module <code>A</code> (that depends on <code>B</code> and <code>G</code>) is compiled and <code>B</code> and <code>G</code> are left unchanged. <code>A</code> requires <code>G.P2</code>.</p> <p>So now <code>G.c</code> MUST contain both <code>P1</code> and <code>P2</code>, but we haven't even loaded <code>P1</code> from the symbol file, nor do we want to because we then quickly would restore large parts of the whole program.</p> <p>Solution ~~~~~~~~ </p> <p>The backend must have some logic so that if the currently processed module is from the compilation cache, the <code>ast</code> field is not accessed. Instead the generated C(++) for the symbol's body needs to be cached too and inserted back into the produced C file. This approach seems to deal with all the outlined problems above.</p> <h2 id="debugging-nim-s-memory-management">Debugging Nim's memory management</h2>
<p>The following paragraphs are mostly a reminder for myself. Things to keep in mind:</p> <ul class="simple">
<li>If an assertion in Nim's memory manager or GC fails, the stack trace keeps allocating memory! Thus a stack overflow may happen, hiding the real issue.</li> <li>What seem to be C code generation problems is often a bug resulting from not producing prototypes, so that some types default to <code>cint</code>. Testing without the <code>-w</code> option helps!</li> </ul> <h2 id="the-garbage-collector">The Garbage Collector</h2> <h3 id="the-garbage-collector-introduction">Introduction</h3>
<p>I use the term <em>cell</em> here to refer to everything that is traced (sequences, refs, strings). This section describes how the GC works.</p> <p>The basic algorithm is <em>Deferrent Reference Counting</em> with cycle detection. References on the stack are not counted for better performance and easier C code generation.</p> <p>Each cell has a header consisting of a RC and a pointer to its type descriptor. However the program does not know about these, so they are placed at negative offsets. In the GC code the type <code>PCell</code> denotes a pointer decremented by the right offset, so that the header can be accessed easily. It is extremely important that <code>pointer</code> is not confused with a <code>PCell</code> as this would lead to a memory corruption.</p> <h3 id="the-garbage-collector-the-cellset-data-structure">The CellSet data structure</h3>
<p>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a <code>TCellSet</code> in the source code. Inserting, deleting and searching are done in constant time. However, modifying a <code>TCellSet</code> during traversation leads to undefined behaviour.</p> <pre class="listing" data-language="nim">type
  TCellSet # hidden

proc cellSetInit(s: var TCellSet) # initialize a new set
proc cellSetDeinit(s: var TCellSet) # empty the set and free its memory
proc incl(s: var TCellSet, elem: PCell) # include an element
proc excl(s: var TCellSet, elem: PCell) # exclude an element

proc `in`(elem: PCell, s: TCellSet): bool # tests membership

iterator elements(s: TCellSet): (elem: PCell)</pre>
<p>All the operations have to perform efficiently. Because a Cellset can become huge a hash table alone is not suitable for this.</p> <p>We use a mixture of bitset and hash table for this. The hash table maps <em>pages</em> to a page descriptor. The page descriptor contains a bit for any possible cell address within this page. So including a cell is done as follows:</p> <ul class="simple">
<li>Find the page descriptor for the page the cell belongs to.</li> <li>Set the appropriate bit in the page descriptor indicating that the cell points to the start of a memory block.</li> </ul> <p>Removing a cell is analogous - the bit has to be set to zero. Single page descriptors are never deleted from the hash table. This is not needed as the data structures needs to be rebuilt periodically anyway.</p> <p>Complete traversal is done in this way:</p>
<pre data-language="nim">for each page descriptor d:
  for each bit in d:
    if bit == 1:
      traverse the pointer belonging to this bit</pre> <h3 id="the-garbage-collector-further-complications">Further complications</h3>
<p>In Nim the compiler cannot always know if a reference is stored on the stack or not. This is caused by var parameters. Consider this example:</p> <pre class="listing" data-language="nim">proc setRef(r: var ref TNode) =
  new(r)

proc usage =
  var
    r: ref TNode
  setRef(r) # here we should not update the reference counts, because
            # r is on the stack
  setRef(r.left) # here we should update the refcounts!</pre>
<p>We have to decide at runtime whether the reference is on the stack or not. The generated code looks roughly like this:</p> <pre class="listing" data-language="nim">void setref(TNode** ref) {
  unsureAsgnRef(ref, newObj(TNode_TI, sizeof(TNode)))
}
void usage(void) {
  setRef(&amp;r)
  setRef(&amp;r-&gt;left)
}</pre>
<p>Note that for systems with a continuous stack (which most systems have) the check whether the ref is on the stack is very cheap (only two comparisons).</p> <h2 id="code-generation-for-closures">Code generation for closures</h2>
<p>Code generation for closures is implemented by <span id="lambda-lifting_1">lambda lifting</span>.</p> <h3 id="code-generation-for-closures-design">Design</h3>
<p>A <code>closure</code> proc var can call ordinary procs of the default Nim calling convention. But not the other way round! A closure is implemented as a <code>tuple[prc, env]</code>. <code>env</code> can be nil implying a call without a closure. This means that a call through a closure generates an <code>if</code> but the interoperability is worth the cost of the <code>if</code>. Thunk generation would be possible too, but it's slightly more effort to implement.</p> <p>Tests with GCC on Amd64 showed that it's really beneficical if the 'environment' pointer is passed as the last argument, not as the first argument.</p> <p>Proper thunk generation is harder because the proc that is to wrap could stem from a complex expression:</p> <pre class="listing" data-language="nim">receivesClosure(returnsDefaultCC[i])</pre>
<p>A thunk would need to call 'returnsDefaultCC[i]' somehow and that would require an <em>additional</em> closure generation... Ok, not really, but it requires to pass the function to call. So we'd end up with 2 indirect calls instead of one. Another much more severe problem which this solution is that it's not GC-safe to pass a proc pointer around via a generic <code>ref</code> type.</p> <p>Example code:</p> <pre class="listing" data-language="nim">proc add(x: int): proc (y: int): int {.closure.} =
  return proc (y: int): int =
    return x + y

var add2 = add(2)
echo add2(5) #OUT 7</pre>
<p>This should produce roughly this code:</p> <pre class="listing" data-language="nim">type
  PEnv = ref object
    x: int # data

proc anon(y: int, c: PEnv): int =
  return y + c.x

proc add(x: int): tuple[prc, data] =
  var env: PEnv
  new env
  env.x = x
  result = (anon, env)

var add2 = add(2)
let tmp = if add2.data == nil: add2.prc(5) else: add2.prc(5, add2.data)
echo tmp</pre>
<p>Beware of nesting:</p> <pre class="listing" data-language="nim">proc add(x: int): proc (y: int): proc (z: int): int {.closure.} {.closure.} =
  return lamba (y: int): proc (z: int): int {.closure.} =
    return lambda (z: int): int =
      return x + y + z

var add24 = add(2)(4)
echo add24(5) #OUT 11</pre>
<p>This should produce roughly this code:</p> <pre class="listing" data-language="nim">type
  PEnvX = ref object
    x: int # data
  
  PEnvY = ref object
    y: int
    ex: PEnvX

proc lambdaZ(z: int, ey: PEnvY): int =
  return ey.ex.x + ey.y + z

proc lambdaY(y: int, ex: PEnvX): tuple[prc, data: PEnvY] =
  var ey: PEnvY
  new ey
  ey.y = y
  ey.ex = ex
  result = (lambdaZ, ey)

proc add(x: int): tuple[prc, data: PEnvX] =
  var ex: PEnvX
  ex.x = x
  result = (labmdaY, ex)

var tmp = add(2)
var tmp2 = tmp.fn(4, tmp.data)
var add24 = tmp2.fn(4, tmp2.data)
echo add24(5)</pre>
<p>We could get rid of nesting environments by always inlining inner anon procs. More useful is escape analysis and stack allocation of the environment, however.</p> <h3 id="code-generation-for-closures-alternative">Alternative</h3>
<p>Process the closure of all inner procs in one pass and accumulate the environments. This is however not always possible.</p> <h3 id="code-generation-for-closures-accumulator">Accumulator</h3>
<pre class="listing" data-language="nim">proc getAccumulator(start: int): proc (): int {.closure} =
  var i = start
  return lambda: int =
    inc i
    return i

proc p =
  var delta = 7
  proc accumulator(start: int): proc(): int =
    var x = start-1
    result = proc (): int =
      x = x + delta
      inc delta
      return x
  
  var a = accumulator(3)
  var b = accumulator(4)
  echo a() + b()</pre> <h3 id="code-generation-for-closures-internals">Internals</h3>
<p>Lambda lifting is implemented as part of the <code>transf</code> pass. The <code>transf</code> pass generates code to setup the environment and to pass it around. However, this pass does not change the types! So we have some kind of mismatch here; on the one hand the proc expression becomes an explicit tuple, on the other hand the tyProc(ccClosure) type is not changed. For C code generation it's also important the hidden formal param is <code>void*</code> and not something more specialized. However the more specialized env type needs to passed to the backend somehow. We deal with this by modifying <code>s.ast[paramPos]</code> to contain the formal hidden parameter, but not <code>s.typ</code>!</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2018 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/intern.html" class="_attribution-link">https://nim-lang.org/docs/intern.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
