
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Nim Tutorial (Part II) - Nim - W3cubDocs</title>
  
  <meta name="description" content=" &#34;Repetition renders the ridiculous reasonable.&#34; -- Norman Wildberger ">
  <meta name="keywords" content="nim, tutorial, part, ii">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nim/tut2.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="title">Nim Tutorial (Part II)</h1>   <h2 id="introduction">Introduction</h2>
<blockquote><p>"Repetition renders the ridiculous reasonable." -- Norman Wildberger</p></blockquote> <p>This document is a tutorial for the advanced constructs of the <em>Nim</em> programming language. <strong>Note that this document is somewhat obsolete as the</strong> <a href="manual">manual</a> <strong>contains many more examples of the advanced language features.</strong></p> <h2 id="pragmas">Pragmas</h2>
<p>Pragmas are Nim's method to give the compiler additional information/ commands without introducing a massive number of new keywords. Pragmas are enclosed in the special <code>{.</code> and <code>.}</code> curly dot brackets. This tutorial does not cover pragmas. See the <a href="manual#pragmas">manual</a> or <a href="nimc#additional-features">user guide</a> for a description of the available pragmas.</p> <h2 id="object-oriented-programming">Object Oriented Programming</h2>
<p>While Nim's support for object oriented programming (OOP) is minimalistic, powerful OOP techniques can be used. OOP is seen as <em>one</em> way to design a program, not <em>the only</em> way. Often a procedural approach leads to simpler and more efficient code. In particular, preferring composition over inheritance is often the better design.</p> <h3 id="object-oriented-programming-objects">Objects</h3>
<p>Like tuples, objects are a means to pack different values together in a structured way. However, objects provide many features that tuples do not: They provide inheritance and information hiding. Because objects encapsulate data, the <code>T()</code> object constructor should only be used internally and the programmer should provide a proc to initialize the object (this is called a <em>constructor</em>).</p> <p>Objects have access to their type at runtime. There is an <code>of</code> operator that can be used to check the object's type:</p> <pre class="listing" data-language="nim">type
  Person = ref object of RootObj
    name*: string  # the * means that `name` is accessible from other modules
    age: int       # no * means that the field is hidden from other modules
  
  Student = ref object of Person # Student inherits from Person
    id: int                      # with an id field

var
  student: Student
  person: Person
assert(student of Student) # is true
# object construction:
student = Student(name: "Anton", age: 5, id: 2)
echo student[]</pre>
<p>Object fields that should be visible from outside the defining module have to be marked by <code>*</code>. In contrast to tuples, different object types are never <em>equivalent</em>. New object types can only be defined within a type section.</p> <p>Inheritance is done with the <code>object of</code> syntax. Multiple inheritance is currently not supported. If an object type has no suitable ancestor, <code>RootObj</code> can be used as its ancestor, but this is only a convention. Objects that have no ancestor are implicitly <code>final</code>. You can use the <code>inheritable</code> pragma to introduce new object roots apart from <code>system.RootObj</code>. (This is used in the GTK wrapper for instance.)</p> <p>Ref objects should be used whenever inheritance is used. It isn't strictly necessary, but with non-ref objects assignments such as <code>let person: Person = Student(id: 123)</code> will truncate subclass fields.</p> <p><strong>Note</strong>: Composition (<em>has-a</em> relation) is often preferable to inheritance (<em>is-a</em> relation) for simple code reuse. Since objects are value types in Nim, composition is as efficient as inheritance.</p> <h3 id="object-oriented-programming-mutually-recursive-types">Mutually recursive types</h3>
<p>Objects, tuples and references can model quite complex data structures which depend on each other; they are <em>mutually recursive</em>. In Nim these types can only be declared within a single type section. (Anything else would require arbitrary symbol lookahead which slows down compilation.)</p> <p>Example:</p> <pre class="listing" data-language="nim">type
  Node = ref object  # a reference to an object with the following field:
    le, ri: Node     # left and right subtrees
    sym: ref Sym     # leaves contain a reference to a Sym
  
  Sym = object       # a symbol
    name: string     # the symbol's name
    line: int        # the line the symbol was declared in
    code: Node       # the symbol's abstract syntax tree</pre> <h3 id="object-oriented-programming-type-conversions">Type conversions</h3>
<p>Nim distinguishes between <span id="type-casts_1">type casts</span> and <span id="type-conversions_1">type conversions</span>. Casts are done with the <code>cast</code> operator and force the compiler to interpret a bit pattern to be of another type.</p> <p>Type conversions are a much more polite way to convert a type into another: They preserve the abstract <em>value</em>, not necessarily the <em>bit-pattern</em>. If a type conversion is not possible, the compiler complains or an exception is raised.</p> <p>The syntax for type conversions is <code>destination_type(expression_to_convert)</code> (like an ordinary call):</p> <pre class="listing" data-language="nim">proc getID(x: Person): int =
  Student(x).id</pre>
<p>The <code>InvalidObjectConversionError</code> exception is raised if <code>x</code> is not a <code>Student</code>.</p> <h3 id="object-oriented-programming-object-variants">Object variants</h3>
<p>Often an object hierarchy is overkill in certain situations where simple variant types are needed.</p> <p>An example:</p> <pre class="listing" data-language="nim"># This is an example how an abstract syntax tree could be modelled in Nim
type
  NodeKind = enum  # the different node types
    nkInt,          # a leaf with an integer value
    nkFloat,        # a leaf with a float value
    nkString,       # a leaf with a string value
    nkAdd,          # an addition
    nkSub,          # a subtraction
    nkIf            # an if statement
  Node = ref object
    case kind: NodeKind  # the ``kind`` field is the discriminator
    of nkInt: intVal: int
    of nkFloat: floatVal: float
    of nkString: strVal: string
    of nkAdd, nkSub:
      leftOp, rightOp: Node
    of nkIf:
      condition, thenPart, elsePart: Node

var n = Node(kind: nkFloat, floatVal: 1.0)
# the following statement raises an `FieldError` exception, because
# n.kind's value does not fit:
n.strVal = ""</pre>
<p>As can been seen from the example, an advantage to an object hierarchy is that no conversion between different object types is needed. Yet, access to invalid object fields raises an exception.</p> <h3 id="object-oriented-programming-methods">Methods</h3>
<p>In ordinary object oriented languages, procedures (also called <em>methods</em>) are bound to a class. This has disadvantages:</p> <ul class="simple">
<li>Adding a method to a class the programmer has no control over is impossible or needs ugly workarounds.</li> <li>Often it is unclear where the method should belong to: is <code>join</code> a string method or an array method?</li> </ul> <p>Nim avoids these problems by not assigning methods to a class. All methods in Nim are multi-methods. As we will see later, multi-methods are distinguished from procs only for dynamic binding purposes.</p> <h3 id="object-oriented-programming-method-call-syntax">Method call syntax</h3>
<p>There is a syntactic sugar for calling routines: The syntax <code>obj.method(args)</code> can be used instead of <code>method(obj, args)</code>. If there are no remaining arguments, the parentheses can be omitted: <code>obj.len</code> (instead of <code>len(obj)</code>).</p> <p>This method call syntax is not restricted to objects, it can be used for any type:</p> <pre class="listing" data-language="nim">import strutils

echo "abc".len # is the same as echo len("abc")
echo "abc".toUpperAscii()
echo({'a', 'b', 'c'}.card)
stdout.writeLine("Hallo") # the same as writeLine(stdout, "Hallo")</pre>
<p>(Another way to look at the method call syntax is that it provides the missing postfix notation.)</p> <p>So "pure object oriented" code is easy to write:</p> <pre class="listing" data-language="nim">import strutils, sequtils

stdout.writeLine("Give a list of numbers (separated by spaces): ")
stdout.write(stdin.readLine.splitWhitespace.map(parseInt).max.`$`)
stdout.writeLine(" is the maximum!")</pre> <h3 id="object-oriented-programming-properties">Properties</h3>
<p>As the above example shows, Nim has no need for <em>get-properties</em>: Ordinary get-procedures that are called with the <em>method call syntax</em> achieve the same. But setting a value is different; for this a special setter syntax is needed:</p> <pre class="listing" data-language="nim">type
  Socket* = ref object of RootObj
    h: int # cannot be accessed from the outside of the module due to missing star

proc `host=`*(s: var Socket, value: int) {.inline.} =
  ## setter of host address
  s.h = value

proc host*(s: Socket): int {.inline.} =
  ## getter of host address
  s.h

var s: Socket
new s
s.host = 34  # same as `host=`(s, 34)</pre>
<p>(The example also shows <code>inline</code> procedures.)</p> <p>The <code>[]</code> array access operator can be overloaded to provide <span id="array-properties_1">array properties</span>:</p> <pre class="listing" data-language="nim">type
  Vector* = object
    x, y, z: float

proc `[]=`* (v: var Vector, i: int, value: float) =
  # setter
  case i
  of 0: v.x = value
  of 1: v.y = value
  of 2: v.z = value
  else: assert(false)

proc `[]`* (v: Vector, i: int): float =
  # getter
  case i
  of 0: result = v.x
  of 1: result = v.y
  of 2: result = v.z
  else: assert(false)</pre>
<p>The example is silly, since a vector is better modelled by a tuple which already provides <code>v[]</code> access.</p> <h3 id="object-oriented-programming-dynamic-dispatch">Dynamic dispatch</h3>
<p>Procedures always use static dispatch. For dynamic dispatch replace the <code>proc</code> keyword by <code>method</code>:</p> <pre class="listing" data-language="nim">type
  Expression = ref object of RootObj ## abstract base class for an expression
  Literal = ref object of Expression
    x: int
  PlusExpr = ref object of Expression
    a, b: Expression

# watch out: 'eval' relies on dynamic binding
method eval(e: Expression): int =
  # override this base method
  quit "to override!"

method eval(e: Literal): int = e.x
method eval(e: PlusExpr): int = eval(e.a) + eval(e.b)

proc newLit(x: int): Literal = Literal(x: x)
proc newPlus(a, b: Expression): PlusExpr = PlusExpr(a: a, b: b)

echo eval(newPlus(newPlus(newLit(1), newLit(2)), newLit(4)))</pre>
<p>Note that in the example the constructors <code>newLit</code> and <code>newPlus</code> are procs because it makes more sense for them to use static binding, but <code>eval</code> is a method because it requires dynamic binding.</p> <p>In a multi-method all parameters that have an object type are used for the dispatching:</p> <pre class="listing" data-language="nim">type
  Thing = ref object of RootObj
  Unit = ref object of Thing
    x: int

method collide(a, b: Thing) {.inline.} =
  quit "to override!"

method collide(a: Thing, b: Unit) {.inline.} =
  echo "1"

method collide(a: Unit, b: Thing) {.inline.} =
  echo "2"

var a, b: Unit
new a
new b
collide(a, b) # output: 2</pre>
<p>As the example demonstrates, invocation of a multi-method cannot be ambiguous: Collide 2 is preferred over collide 1 because the resolution works from left to right. Thus <code>Unit, Thing</code> is preferred over <code>Thing, Unit</code>.</p> <p><strong>Performance note</strong>: Nim does not produce a virtual method table, but generates dispatch trees. This avoids the expensive indirect branch for method calls and enables inlining. However, other optimizations like compile time evaluation or dead code elimination do not work with methods.</p> <h2 id="exceptions">Exceptions</h2>
<p>In Nim exceptions are objects. By convention, exception types are suffixed with 'Error'. The <a href="system">system</a> module defines an exception hierarchy that you might want to stick to. Exceptions derive from <code>system.Exception</code>, which provides the common interface.</p> <p>Exceptions have to be allocated on the heap because their lifetime is unknown. The compiler will prevent you from raising an exception created on the stack. All raised exceptions should at least specify the reason for being raised in the <code>msg</code> field.</p> <p>A convention is that exceptions should be raised in <em>exceptional</em> cases: For example, if a file cannot be opened, this should not raise an exception since this is quite common (the file may not exist).</p> <h3 id="exceptions-raise-statement">Raise statement</h3>
<p>Raising an exception is done with the <code>raise</code> statement:</p> <pre class="listing" data-language="nim">var
  e: ref OSError
new(e)
e.msg = "the request to the OS failed"
raise e</pre>
<p>If the <code>raise</code> keyword is not followed by an expression, the last exception is <em>re-raised</em>. For the purpose of avoiding repeating this common code pattern, the template <code>newException</code> in the <code>system</code> module can be used:</p> <pre class="listing" data-language="nim">raise newException(OSError, "the request to the OS failed")</pre> <h3 id="exceptions-try-statement">Try statement</h3>
<p>The <code>try</code> statement handles exceptions:</p> <pre class="listing" data-language="nim">from strutils import parseInt

# read the first two lines of a text file that should contain numbers
# and tries to add them
var
  f: File
if open(f, "numbers.txt"):
  try:
    let a = readLine(f)
    let b = readLine(f)
    echo "sum: ", parseInt(a) + parseInt(b)
  except OverflowError:
    echo "overflow!"
  except ValueError:
    echo "could not convert string to integer"
  except IOError:
    echo "IO error!"
  except:
    echo "Unknown exception!"
    # reraise the unknown exception:
    raise
  finally:
    close(f)</pre>
<p>The statements after the <code>try</code> are executed unless an exception is raised. Then the appropriate <code>except</code> part is executed.</p> <p>The empty <code>except</code> part is executed if there is an exception that is not explicitly listed. It is similar to an <code>else</code> part in <code>if</code> statements.</p> <p>If there is a <code>finally</code> part, it is always executed after the exception handlers.</p> <p>The exception is <em>consumed</em> in an <code>except</code> part. If an exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a <code>finally</code> clause - is not executed (if an exception occurs).</p> <p>If you need to <em>access</em> the actual exception object or message inside an <code>except</code> branch you can use the <a href="system#getCurrentException">getCurrentException()</a> and <a href="system#getCurrentExceptionMsg">getCurrentExceptionMsg()</a> procs from the <a href="system">system</a> module. Example:</p> <pre class="listing" data-language="nim">try:
  doSomethingHere()
except:
  let
    e = getCurrentException()
    msg = getCurrentExceptionMsg()
  echo "Got exception ", repr(e), " with message ", msg</pre> <h3 id="exceptions-annotating-procs-with-raised-exceptions">Annotating procs with raised exceptions</h3>
<p>Through the use of the optional <code>{.raises.}</code> pragma you can specify that a proc is meant to raise a specific set of exceptions, or none at all. If the <code>{.raises.}</code> pragma is used, the compiler will verify that this is true. For instance, if you specify that a proc raises <code>IOError</code>, and at some point it (or one of the procs it calls) starts raising a new exception the compiler will prevent that proc from compiling. Usage example:</p> <pre class="listing" data-language="nim">proc complexProc() {.raises: [IOError, ArithmeticError].} =
  ...

proc simpleProc() {.raises: [].} =
  ...</pre>
<p>Once you have code like this in place, if the list of raised exception changes the compiler will stop with an error specifying the line of the proc which stopped validating the pragma and the raised exception not being caught, along with the file and line where the uncaught exception is being raised, which may help you locate the offending code which has changed.</p> <p>If you want to add the <code>{.raises.}</code> pragma to existing code, the compiler can also help you. You can add the <code>{.effects.}</code> pragma statement to your proc and the compiler will output all inferred effects up to that point (exception tracking is part of Nim's effect system). Another more roundabout way to find out the list of exceptions raised by a proc is to use the Nim <code>doc2</code> command which generates documentation for a whole module and decorates all procs with the list of raised exceptions. You can read more about Nim's <a href="manual#effect-system">effect system and related pragmas in the manual</a>.</p> <h2 id="generics">Generics</h2>
<p>Generics are Nim's means to parametrize procs, iterators or types with <span id="type-parameters_1">type parameters</span>. They are most useful for efficient type safe containers:</p> <pre class="listing" data-language="nim">type
  BinaryTree*[T] = ref object # BinaryTree is a generic type with
                              # generic param ``T``
    le, ri: BinaryTree[T]     # left and right subtrees; may be nil
    data: T                   # the data stored in a node

proc newNode*[T](data: T): BinaryTree[T] =
  # constructor for a node
  new(result)
  result.data = data

proc add*[T](root: var BinaryTree[T], n: BinaryTree[T]) =
  # insert a node into the tree
  if root == nil:
    root = n
  else:
    var it = root
    while it != nil:
      # compare the data items; uses the generic ``cmp`` proc
      # that works for any type that has a ``==`` and ``&lt;`` operator
      var c = cmp(it.data, n.data)
      if c &lt; 0:
        if it.le == nil:
          it.le = n
          return
        it = it.le
      else:
        if it.ri == nil:
          it.ri = n
          return
        it = it.ri

proc add*[T](root: var BinaryTree[T], data: T) =
  # convenience proc:
  add(root, newNode(data))

iterator preorder*[T](root: BinaryTree[T]): T =
  # Preorder traversal of a binary tree.
  # Since recursive iterators are not yet implemented,
  # this uses an explicit stack (which is more efficient anyway):
  var stack: seq[BinaryTree[T]] = @[root]
  while stack.len &gt; 0:
    var n = stack.pop()
    while n != nil:
      yield n.data
      add(stack, n.ri)  # push right subtree onto the stack
      n = n.le          # and follow the left pointer

var
  root: BinaryTree[string] # instantiate a BinaryTree with ``string``
add(root, newNode("hello")) # instantiates ``newNode`` and ``add``
add(root, "world")          # instantiates the second ``add`` proc
for str in preorder(root):
  stdout.writeLine(str)</pre>
<p>The example shows a generic binary tree. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type. As the example shows, generics work with overloading: the best match of <code>add</code> is used. The built-in <code>add</code> procedure for sequences is not hidden and is used in the <code>preorder</code> iterator.</p> <h2 id="templates">Templates</h2>
<p>Templates are a simple substitution mechanism that operates on Nim's abstract syntax trees. Templates are processed in the semantic pass of the compiler. They integrate well with the rest of the language and share none of C's preprocessor macros flaws.</p> <p>To <em>invoke</em> a template, call it like a procedure.</p> <p>Example:</p> <pre class="listing" data-language="nim">template `!=` (a, b: untyped): untyped =
  # this definition exists in the System module
  not (a == b)

assert(5 != 6) # the compiler rewrites that to: assert(not (5 == 6))</pre>
<p>The <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>in</code>, <code>notin</code>, <code>isnot</code> operators are in fact templates: this has the benefit that if you overload the <code>==</code> operator, the <code>!=</code> operator is available automatically and does the right thing. (Except for IEEE floating point numbers - NaN breaks basic boolean logic.)</p> <p><code>a &gt; b</code> is transformed into <code>b &lt; a</code>. <code>a in b</code> is transformed into <code>contains(b, a)</code>. <code>notin</code> and <code>isnot</code> have the obvious meanings.</p> <p>Templates are especially useful for lazy evaluation purposes. Consider a simple proc for logging:</p> <pre class="listing" data-language="nim">const
  debug = true

proc log(msg: string) {.inline.} =
  if debug: stdout.writeLine(msg)

var
  x = 4
log("x has the value: " &amp; $x)</pre>
<p>This code has a shortcoming: if <code>debug</code> is set to false someday, the quite expensive <code>$</code> and <code>&amp;</code> operations are still performed! (The argument evaluation for procedures is <em>eager</em>).</p> <p>Turning the <code>log</code> proc into a template solves this problem:</p> <pre class="listing" data-language="nim">const
  debug = true

template log(msg: string) =
  if debug: stdout.writeLine(msg)

var
  x = 4
log("x has the value: " &amp; $x)</pre>
<p>The parameters' types can be ordinary types or the meta types <code>untyped</code>, <code>typed</code>, or <code>type</code>. <code>type</code> suggests that only a type symbol may be given as an argument, and <code>untyped</code> means symbol lookups and type resolution is not performed before the expression is passed to the template.</p> <p>If the template has no explicit return type, <code>void</code> is used for consistency with procs and methods.</p> <p>To pass a block of statements to a template, use 'untyped' for the last parameter:</p> <pre class="listing" data-language="nim">template withFile(f: untyped, filename: string, mode: FileMode,
                  body: untyped): typed =
  let fn = filename
  var f: File
  if open(f, fn, mode):
    try:
      body
    finally:
      close(f)
  else:
    quit("cannot open: " &amp; fn)

withFile(txt, "ttempl3.txt", fmWrite):
  txt.writeLine("line 1")
  txt.writeLine("line 2")</pre>
<p>In the example the two <code>writeLine</code> statements are bound to the <code>body</code> parameter. The <code>withFile</code> template contains boilerplate code and helps to avoid a common bug: to forget to close the file. Note how the <code>let fn = filename</code> statement ensures that <code>filename</code> is evaluated only once.</p> <h2 id="macros">Macros</h2>
<p>Macros enable advanced compile-time code transformations, but they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway. Macros have to be implemented in pure Nim code if the <a href="manual#foreign-function-interface">foreign function interface (FFI)</a> is not enabled in the compiler, but other than that restriction (which at some point in the future will go away) you can write any kind of Nim code and the compiler will run it at compile time.</p> <p>There are two ways to write a macro, either <em>generating</em> Nim source code and letting the compiler parse it, or creating manually an abstract syntax tree (AST) which you feed to the compiler. In order to build the AST one needs to know how the Nim concrete syntax is converted to an abstract syntax tree (AST). The AST is documented in the <a href="macros">macros</a> module.</p> <p>Once your macro is finished, there are two ways to invoke it:</p> <ol class="simple">
<li>invoking a macro like a procedure call (expression macros)</li> <li>invoking a macro with the special <code>macrostmt</code> syntax (statement macros)</li> </ol> <h3 id="macros-expression-macros">Expression Macros</h3>
<p>The following example implements a powerful <code>debug</code> command that accepts a variable number of arguments:</p> <pre class="listing" data-language="nim"># to work with Nim syntax trees, we need an API that is defined in the
# ``macros`` module:
import macros

macro debug(n: varargs[untyped]): typed =
  # `n` is a Nim AST that contains a list of expressions;
  # this macro returns a list of statements (n is passed for proper line
  # information):
  result = newNimNode(nnkStmtList, n)
  # iterate over any argument that is passed to this macro:
  for x in n:
    # add a call to the statement list that writes the expression;
    # `toStrLit` converts an AST to its string representation:
    result.add(newCall("write", newIdentNode("stdout"), toStrLit(x)))
    # add a call to the statement list that writes ": "
    result.add(newCall("write", newIdentNode("stdout"), newStrLitNode(": ")))
    # add a call to the statement list that writes the expressions value:
    result.add(newCall("writeLine", newIdentNode("stdout"), x))

var
  a: array[0..10, int]
  x = "some string"
a[0] = 42
a[1] = 45

debug(a[0], a[1], x)</pre>
<p>The macro call expands to:</p> <pre class="listing" data-language="nim">write(stdout, "a[0]")
write(stdout, ": ")
writeLine(stdout, a[0])

write(stdout, "a[1]")
write(stdout, ": ")
writeLine(stdout, a[1])

write(stdout, "x")
write(stdout, ": ")
writeLine(stdout, x)</pre> <h3 id="macros-statement-macros">Statement Macros</h3>
<p>Statement macros are defined just as expression macros. However, they are invoked by an expression following a colon.</p> <p>The following example outlines a macro that generates a lexical analyzer from regular expressions:</p> <pre class="listing" data-language="nim">macro case_token(n: varargs[untyped]): typed =
  # creates a lexical analyzer from regular expressions
  # ... (implementation is an exercise for the reader :-)
  discard

case_token: # this colon tells the parser it is a macro statement
of r"[A-Za-z_]+[A-Za-z_0-9]*":
  return tkIdentifier
of r"0-9+":
  return tkInteger
of r"[\+\-\*\?]+":
  return tkOperator
else:
  return tkUnknown</pre> <h3 id="macros-building-your-first-macro">Building your first macro</h3>
<p>To give a footstart to writing macros we will show now how to turn your typical dynamic code into something that compiles statically. For the exercise we will use the following snippet of code as the starting point:</p> <pre class="listing" data-language="nim">import strutils, tables

proc readCfgAtRuntime(cfgFilename: string): Table[string, string] =
  let
    inputString = readFile(cfgFilename)
  var
    source = ""
  
  result = initTable[string, string]()
  for line in inputString.splitLines:
    # Ignore empty lines
    if line.len &lt; 1: continue
    var chunks = split(line, ',')
    if chunks.len != 2:
      quit("Input needs comma split values, got: " &amp; line)
    result[chunks[0]] = chunks[1]
  
  if result.len &lt; 1: quit("Input file empty!")

let info = readCfgAtRuntime("data.cfg")

when isMainModule:
  echo info["licenseOwner"]
  echo info["licenseKey"]
  echo info["version"]</pre>
<p>Presumably this snippet of code could be used in a commercial software, reading a configuration file to display information about the person who bought the software. This external file would be generated by an online web shopping cart to be included along the program containing the license information:</p>
<pre data-language="nim">version,1.1
licenseOwner,Hyori Lee
licenseKey,M1Tl3PjBWO2CC48m</pre> <p>The <code>readCfgAtRuntime</code> proc will open the given filename and return a <code>Table</code> from the <a href="tables">tables module</a>. The parsing of the file is done (without much care for handling invalid data or corner cases) using the <a href="strutils#splitLines">splitLines proc from the strutils module</a>. There are many things which can fail; mind the purpose is explaining how to make this run at compile time, not how to properly implement a DRM scheme.</p> <p>The reimplementation of this code as a compile time proc will allow us to get rid of the <code>data.cfg</code> file we would need to distribute along the binary, plus if the information is really constant, it doesn't make from a logical point of view to have it <em>mutable</em> in a global variable, it would be better if it was a constant. Finally, and likely the most valuable feature, we can implement some verification at compile time. You could think of this as a <em>better unit testing</em>, since it is impossible to obtain a binary unless everything is correct, preventing you to ship to users a broken program which won't start because a small critical file is missing or its contents changed by mistake to something invalid.</p> <h4 id="building-your-first-macro-generating-source-code">Generating source code</h4>
<p>Our first attempt will start by modifying the program to generate a compile time string with the <em>generated source code</em>, which we then pass to the <code>parseStmt</code> proc from the <a href="macros">macros module</a>. Here is the modified source code implementing the macro:</p> <table><tbody><tr>
<td class="blob-line-nums"><pre class="line-nums" data-language="nim">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></td>
<td><pre class="listing" data-language="nim">import macros, strutils

macro readCfgAndBuildSource(cfgFilename: string): typed =
  let
    inputString = slurp(cfgFilename.strVal)
  var
    source = ""
  
  for line in inputString.splitLines:
    # Ignore empty lines
    if line.len &lt; 1: continue
    var chunks = split(line, ',')
    if chunks.len != 2:
      error("Input needs comma split values, got: " &amp; line)
    source &amp;= "const cfg" &amp; chunks[0] &amp; "= \"" &amp; chunks[1] &amp; "\"\n"
  
  if source.len &lt; 1: error("Input file empty!")
  result = parseStmt(source)

readCfgAndBuildSource("data.cfg")

when isMainModule:
  echo cfglicenseOwner
  echo cfglicenseKey
  echo cfgversion</pre></td>
</tr></tbody></table>
<p>The good news is not much has changed! First, we need to change the handling of the input parameter (line 3). In the dynamic version the <code>readCfgAtRuntime</code> proc receives a string parameter. However, in the macro version it is also declared as string, but this is the <em>outside</em> interface of the macro. When the macro is run, it actually gets a <code>PNimNode</code> object instead of a string, and we have to call the <a href="macros#strVal">strVal proc</a> (line 5) from the <a href="macros">macros module</a> to obtain the string being passed in to the macro.</p> <p>Second, we cannot use the <a href="system#readFile">readFile proc</a> from the <a href="system">system module</a> due to FFI restriction at compile time. If we try to use this proc, or any other which depends on FFI, the compiler will error with the message <code>cannot evaluate</code> and a dump of the macro's source code, along with a stack trace where the compiler reached before bailing out. We can get around this limitation by using the <a href="system#slurp">slurp proc</a> from the <a href="system">system module</a>, which was precisely made for compilation time (just like <a href="system#gorge">gorge</a> which executes an external program and captures its output).</p> <p>The interesting thing is that our macro does not return a runtime <a href="tables#Table">Table</a> object. Instead, it builds up Nim source code into the <code>source</code> variable. For each line of the configuration file a <code>const</code> variable will be generated (line 15). To avoid conflicts we prefix these variables with <code>cfg</code>. In essence, what the compiler is doing is replacing the line calling the macro with the following snippet of code:</p> <pre class="listing" data-language="nim">const cfgversion = "1.1"
const cfglicenseOwner = "Hyori Lee"
const cfglicenseKey = "M1Tl3PjBWO2CC48m"</pre>
<p>You can verify this yourself adding the line <code>echo source</code> somewhere at the end of the macro and compiling the program. Another difference is that instead of calling the usual <a href="system#quit">quit proc</a> to abort (which we could still call) this version calls the <a href="macros#error">error proc</a> (line 14). The <code>error</code> proc has the same behavior as <code>quit</code> but will dump also the source and file line information where the error happened, making it easier for the programmer to find where compilation failed. In this situation it would point to the line invoking the macro, but <strong>not</strong> the line of <code>data.cfg</code> we are processing, that's something the macro itself would need to control.</p> <h4 id="building-your-first-macro-generating-ast-by-hand">Generating AST by hand</h4>
<p>To generate an AST we would need to intimately know the structures used by the Nim compiler exposed in the <a href="macros">macros module</a>, which at first look seems a daunting task. But we can use as helper shortcut the <a href="macros#dumpTree">dumpTree macro</a>, which is used as a statement macro instead of an expression macro. Since we know that we want to generate a bunch of <code>const</code> symbols we can create the following source file and compile it to see what the compiler <em>expects</em> from us:</p> <pre class="listing" data-language="nim">import macros

dumpTree:
  const cfgversion: string = "1.1"
  const cfglicenseOwner = "Hyori Lee"
  const cfglicenseKey = "M1Tl3PjBWO2CC48m"</pre>
<p>During compilation of the source code we should see the following lines in the output (again, since this is a macro, compilation is enough, you don't have to run any binary):</p>
<pre data-language="nim">StmtList
  ConstSection
    ConstDef
      Ident !"cfgversion"
      Ident !"string"
      StrLit 1.1
  ConstSection
    ConstDef
      Ident !"cfglicenseOwner"
      Empty
      StrLit Hyori Lee
  ConstSection
    ConstDef
      Ident !"cfglicenseKey"
      Empty
      StrLit M1Tl3PjBWO2CC48m</pre> <p>With this output we have a better idea of what kind of input the compiler expects. We need to generate a list of statements. For each constant the source code generates a <code>ConstSection</code> and a <code>ConstDef</code>. If we were to move all the constants to a single <code>const</code> block we would see only a single <code>ConstSection</code> with three children.</p> <p>Maybe you didn't notice, but in the <code>dumpTree</code> example the first constant explicitly specifies the type of the constant. That's why in the tree output the two last constants have their second child <code>Empty</code> but the first has a string identifier. So basically a <code>const</code> definition is made up from an identifier, optionally a type (can be an <em>empty</em> node) and the value. Armed with this knowledge, let's look at the finished version of the AST building macro:</p> <table><tbody><tr>
<td class="blob-line-nums"><pre class="line-nums" data-language="nim">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></td>
<td><pre class="listing" data-language="nim">import macros, strutils

macro readCfgAndBuildAST(cfgFilename: string): typed =
  let
    inputString = slurp(cfgFilename.strVal)
  
  result = newNimNode(nnkStmtList)
  for line in inputString.splitLines:
    # Ignore empty lines
    if line.len &lt; 1: continue
    var chunks = split(line, ',')
    if chunks.len != 2:
      error("Input needs comma split values, got: " &amp; line)
    var
      section = newNimNode(nnkConstSection)
      constDef = newNimNode(nnkConstDef)
    constDef.add(newIdentNode("cfg" &amp; chunks[0]))
    constDef.add(newEmptyNode())
    constDef.add(newStrLitNode(chunks[1]))
    section.add(constDef)
    result.add(section)
  
  if result.len &lt; 1: error("Input file empty!")

readCfgAndBuildAST("data.cfg")

when isMainModule:
  echo cfglicenseOwner
  echo cfglicenseKey
  echo cfgversion</pre></td>
</tr></tbody></table>
<p>Since we are building on the previous example generating source code, we will only mention the differences to it. Instead of creating a temporary <code>string</code> variable and writing into it source code as if it were written <em>by hand</em>, we use the <code>result</code> variable directly and create a statement list node (<code>nnkStmtList</code>) which will hold our children (line 7).</p> <p>For each input line we have to create a constant definition (<code>nnkConstDef</code>) and wrap it inside a constant section (<code>nnkConstSection</code>). Once these variables are created, we fill them hierarchichally (line 17) like the previous AST dump tree showed: the constant definition is a child of the section definition, and the constant definition has an identifier node, an empty node (we let the compiler figure out the type), and a string literal with the value.</p> <p>A last tip when writing a macro: if you are not sure the AST you are building looks ok, you may be tempted to use the <code>dumpTree</code> macro. But you can't use it <em>inside</em> the macro you are writting/debugging. Instead <code>echo</code> the string generated by <a href="macros#treeRepr">treeRepr</a>. If at the end of the this example you add <code>echo treeRepr(result)</code> you should get the same output as using the <code>dumpTree</code> macro, but of course you can call that at any point of the macro where you might be having troubles.</p> <h2 id="example-templates-and-macros">Example Templates and Macros</h2> <h4 id="example-templates-and-macros-lifting-procs">Lifting Procs</h4>
<pre class="listing" data-language="nim">import math

template liftScalarProc(fname) =
  ## Lift a proc taking one scalar parameter and returning a
  ## scalar value (eg ``proc sssss[T](x: T): float``),
  ## to provide templated procs that can handle a single
  ## parameter of seq[T] or nested seq[seq[]] or the same type
  ##
  ## .. code-block:: Nim
  ##  liftScalarProc(abs)
  ##  # now abs(@[@[1,-2], @[-2,-3]]) == @[@[1,2], @[2,3]]
  proc fname[T](x: openarray[T]): auto =
    var temp: T
    type outType = type(fname(temp))
    result = newSeq[outType](x.len)
    for i in 0..&lt;x.len:
      result[i] = fname(x[i])

liftScalarProc(sqrt)   # make sqrt() work for sequences
echo sqrt(@[4.0, 16.0, 25.0, 36.0])   # =&gt; @[2.0, 4.0, 5.0, 6.0]</pre> <h4 id="example-templates-and-macros-identifier-mangling">Identifier Mangling</h4>
<pre class="listing" data-language="nim">proc echoHW() =
  echo "Hello world"
proc echoHW0() =
  echo "Hello world 0"
proc echoHW1() =
  echo "Hello world 1"

template joinSymbols(a, b: untyped): untyped =
  `a b`()

joinSymbols(echo, HW)

macro str2Call(s1, s2): typed =
  result = newNimNode(nnkStmtList)
  for i in 0..1:
    # combines s1, s2 and an integer into an proc identifier
    # that is called in a statement list
    result.add(newCall(!($s1 &amp; $s2 &amp; $i)))

str2Call("echo", "HW")

# Output:
#   Hello world
#   Hello world 0
#   Hello world 1</pre> <h2 id="compilation-to-javascript">Compilation to JavaScript</h2>
<p>Nim code can be compiled to JavaScript. However in order to write JavaScript-compatible code you should remember the following:</p> <ul class="simple">
<li>
<code>addr</code> and <code>ptr</code> have slightly different semantic meaning in JavaScript. It is recommended to avoid those if you're not sure how they are translated to JavaScript.</li> <li>
<code>cast[T](x)</code> in JavaScript is translated to <code>(x)</code>, except for casting between signed/unsigned ints, in which case it behaves as static cast in C language.</li> <li>
<code>cstring</code> in JavaScript means JavaScript string. It is a good practice to use <code>cstring</code> only when it is semantically appropriate. E.g. don't use <code>cstring</code> as a binary data buffer.</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2018 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/tut2.html" class="_attribution-link">https://nim-lang.org/docs/tut2.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
