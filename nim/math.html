
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Math - Nim - W3cubDocs</title>
  
  <meta name="description" content=" Constructive mathematics is naturally typed. -- Simon Thompson ">
  <meta name="keywords" content="module, math, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nim/math.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/nim.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="title">Module math</h1>  
<p>Constructive mathematics is naturally typed. -- Simon Thompson</p> <p>Basic math routines for Nim. This module is available for the <a href="backends#the-javascript-target">JavaScript target</a>.</p> <p>Note that the trigonometric functions naturally operate on radians. The helper functions <em>degToRad</em> and <em>radToDeg</em> provide conversion between radians and degrees.</p>  <h2 id="6">Imports</h2> <dl> <a href="bitops">bitops</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre data-language="nim">FloatClass = enum
  fcNormal,                   ## value is an ordinary nonzero floating point value
  fcSubnormal,                ## value is a subnormal (a very small) floating point value
  fcZero,                     ## value is zero
  fcNegZero,                  ## value is the negative zero
  fcNan,                      ## value is Not-A-Number (NAN)
  fcInf,                      ## value is positive infinity
  fcNegInf                    ## value is negative infinity</pre></dt> <dd> describes the class a floating point value belongs to. This is the type that is returned by <em>classify</em>.   </dd> </dl>  <h2 id="10">Consts</h2> <dl>  <dt><pre data-language="nim">PI = 3.141592653589793</pre></dt> <dd> the circle constant PI (Ludolph's number)   </dd>  <dt><pre data-language="nim">TAU = 6.283185307179586</pre></dt> <dd> the circle constant TAU (= 2 * PI)   </dd>  <dt><pre data-language="nim">E = 2.718281828459045</pre></dt> <dd> Euler's number   </dd>  <dt><pre>MaxFloat64Precision = 16</pre></dt> <dd> maximum number of meaningful digits after the decimal point for Nim's <code>float64</code> type.   </dd>  <dt><pre>MaxFloat32Precision = 8</pre></dt> <dd> maximum number of meaningful digits after the decimal point for Nim's <code>float32</code> type.   </dd>  <dt><pre>MaxFloatPrecision = 16</pre></dt> <dd> maximum number of meaningful digits after the decimal point for Nim's <code>float</code> type.   </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre data-language="nim">proc binom(n, k: int): int {...}{.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Computes the binomial coefficient   </dd>  <dt><pre data-language="nim">proc fac(n: int): int {...}{.raises: [], tags: [].}</pre></dt> <dd> Computes the faculty/factorial function.   </dd>  <dt><pre data-language="nim">proc classify(x: float): FloatClass {...}{.raises: [], tags: [].}</pre></dt> <dd> Classifies a floating point value. Returns <em>x</em>'s class as specified by <em>FloatClass</em>.   </dd>  <dt><pre data-language="nim">proc isPowerOfTwo(x: int): bool {...}{.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Returns true, if <em>x</em> is a power of two, false otherwise. Zero and negative numbers are not a power of two.   </dd>  <dt><pre data-language="nim">proc nextPowerOfTwo(x: int): int {...}{.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Returns <em>x</em> rounded up to the nearest power of two. Zero and negative numbers get rounded up to 1.   </dd>  <dt><pre data-language="nim">proc countBits32(n: int32): int {...}{.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Counts the set bits in <em>n</em>.   </dd>  <dt><pre data-language="nim">proc sum[T](x: openArray[T]): T {...}{.noSideEffect.}</pre></dt> <dd> Computes the sum of the elements in <em>x</em>. If <em>x</em> is empty, 0 is returned.   </dd>  <dt><pre data-language="nim">proc prod[T](x: openArray[T]): T {...}{.noSideEffect.}</pre></dt> <dd> Computes the product of the elements in <code>x</code>. If <code>x</code> is empty, 1 is returned.   </dd>  <dt><pre data-language="nim">proc sqrt(x: float32): float32 {...}{.importc: "sqrtf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc sqrt(x: float64): float64 {...}{.importc: "sqrt", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the square root of <em>x</em>.   </dd>  <dt><pre data-language="nim">proc cbrt(x: float32): float32 {...}{.importc: "cbrtf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc cbrt(x: float64): float64 {...}{.importc: "cbrt", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the cubic root of <em>x</em>   </dd>  <dt><pre data-language="nim">proc ln(x: float32): float32 {...}{.importc: "logf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc ln(x: float64): float64 {...}{.importc: "log", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the natural log of <em>x</em>   </dd>  <dt><pre data-language="nim">proc log[T: SomeFloat](x, base: T): T</pre></dt> <dd> Computes the logarithm <code>base</code> of <code>x</code>   </dd>  <dt><pre data-language="nim">proc log10(x: float32): float32 {...}{.importc: "log10f", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc log10(x: float64): float64 {...}{.importc: "log10", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the common logarithm (base 10) of <em>x</em>   </dd>  <dt><pre data-language="nim">proc exp(x: float32): float32 {...}{.importc: "expf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc exp(x: float64): float64 {...}{.importc: "exp", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the exponential function of <em>x</em> (pow(E, x))   </dd>  <dt><pre data-language="nim">proc sin(x: float32): float32 {...}{.importc: "sinf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc sin(x: float64): float64 {...}{.importc: "sin", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the sine of <em>x</em>   </dd>  <dt><pre data-language="nim">proc cos(x: float32): float32 {...}{.importc: "cosf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc cos(x: float64): float64 {...}{.importc: "cos", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the cosine of <em>x</em>   </dd>  <dt><pre data-language="nim">proc tan(x: float32): float32 {...}{.importc: "tanf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc tan(x: float64): float64 {...}{.importc: "tan", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the tangent of <em>x</em>   </dd>  <dt><pre data-language="nim">proc sinh(x: float32): float32 {...}{.importc: "sinhf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc sinh(x: float64): float64 {...}{.importc: "sinh", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the hyperbolic sine of <em>x</em>   </dd>  <dt><pre data-language="nim">proc cosh(x: float32): float32 {...}{.importc: "coshf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc cosh(x: float64): float64 {...}{.importc: "cosh", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the hyperbolic cosine of <em>x</em>   </dd>  <dt><pre data-language="nim">proc tanh(x: float32): float32 {...}{.importc: "tanhf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc tanh(x: float64): float64 {...}{.importc: "tanh", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the hyperbolic tangent of <em>x</em>   </dd>  <dt><pre data-language="nim">proc arccos(x: float32): float32 {...}{.importc: "acosf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc arccos(x: float64): float64 {...}{.importc: "acos", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the arc cosine of <em>x</em>   </dd>  <dt><pre data-language="nim">proc arcsin(x: float32): float32 {...}{.importc: "asinf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc arcsin(x: float64): float64 {...}{.importc: "asin", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the arc sine of <em>x</em>   </dd>  <dt><pre data-language="nim">proc arctan(x: float32): float32 {...}{.importc: "atanf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc arctan(x: float64): float64 {...}{.importc: "atan", header: "&lt;math.h&gt;".}</pre></dt> <dd> Calculate the arc tangent of <em>y</em> / <em>x</em>   </dd>  <dt><pre data-language="nim">proc arctan2(y, x: float32): float32 {...}{.importc: "atan2f", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc arctan2(y, x: float64): float64 {...}{.importc: "atan2", header: "&lt;math.h&gt;".}</pre></dt> <dd> Calculate the arc tangent of <em>y</em> / <em>x</em>. <em>atan2</em> returns the arc tangent of <em>y</em> / <em>x</em>; it produces correct results even when the resulting angle is near pi/2 or -pi/2 (<em>x</em> near 0).   </dd>  <dt><pre data-language="nim">proc arcsinh(x: float32): float32 {...}{.importc: "asinhf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc arcsinh(x: float64): float64 {...}{.importc: "asinh", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the inverse hyperbolic sine of <em>x</em>   </dd>  <dt><pre data-language="nim">proc arccosh(x: float32): float32 {...}{.importc: "acoshf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc arccosh(x: float64): float64 {...}{.importc: "acosh", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the inverse hyperbolic cosine of <em>x</em>   </dd>  <dt><pre data-language="nim">proc arctanh(x: float32): float32 {...}{.importc: "atanhf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc arctanh(x: float64): float64 {...}{.importc: "atanh", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the inverse hyperbolic tangent of <em>x</em>   </dd>  <dt><pre data-language="nim">proc cot[T: float32 | float64](x: T): T</pre></dt> <dd> Computes the cotangent of <em>x</em>   </dd>  <dt><pre data-language="nim">proc sec[T: float32 | float64](x: T): T</pre></dt> <dd> Computes the secant of <em>x</em>.   </dd>  <dt><pre data-language="nim">proc csc[T: float32 | float64](x: T): T</pre></dt> <dd> Computes the cosecant of <em>x</em>   </dd>  <dt><pre data-language="nim">proc coth[T: float32 | float64](x: T): T</pre></dt> <dd> Computes the hyperbolic cotangent of <em>x</em>   </dd>  <dt><pre data-language="nim">proc sech[T: float32 | float64](x: T): T</pre></dt> <dd> Computes the hyperbolic secant of <em>x</em>   </dd>  <dt><pre data-language="nim">proc csch[T: float32 | float64](x: T): T</pre></dt> <dd> Computes the hyperbolic cosecant of <em>x</em>   </dd>  <dt><pre data-language="nim">proc arccot[T: float32 | float64](x: T): T</pre></dt> <dd> Computes the inverse cotangent of <em>x</em>   </dd>  <dt><pre data-language="nim">proc arcsec[T: float32 | float64](x: T): T</pre></dt> <dd> Computes the inverse secant of <em>x</em>   </dd>  <dt><pre data-language="nim">proc arccsc[T: float32 | float64](x: T): T</pre></dt> <dd> Computes the inverse cosecant of <em>x</em>   </dd>  <dt><pre data-language="nim">proc arccoth[T: float32 | float64](x: T): T</pre></dt> <dd> Computes the inverse hyperbolic cotangent of <em>x</em>   </dd>  <dt><pre data-language="nim">proc arcsech[T: float32 | float64](x: T): T</pre></dt> <dd> Computes the inverse hyperbolic secant of <em>x</em>   </dd>  <dt><pre data-language="nim">proc arccsch[T: float32 | float64](x: T): T</pre></dt> <dd> Computes the inverse hyperbolic cosecant of <em>x</em>   </dd>  <dt><pre data-language="nim">proc hypot(x, y: float32): float32 {...}{.importc: "hypotf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc hypot(x, y: float64): float64 {...}{.importc: "hypot", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the hypotenuse of a right-angle triangle with <em>x</em> and <em>y</em> as its base and height. Equivalent to <code>sqrt(x*x + y*y)</code>.   </dd>  <dt><pre data-language="nim">proc pow(x, y: float32): float32 {...}{.importc: "powf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc pow(x, y: float64): float64 {...}{.importc: "pow", header: "&lt;math.h&gt;".}</pre></dt> <dd> <p>computes x to power raised of y.</p> <p>To compute power between integers, use <em>^</em> e.g. 2 ^ 6</p>   </dd>  <dt><pre data-language="nim">proc erf(x: float32): float32 {...}{.importc: "erff", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc erf(x: float64): float64 {...}{.importc: "erf", header: "&lt;math.h&gt;".}</pre></dt> <dd> The error function   </dd>  <dt><pre data-language="nim">proc erfc(x: float32): float32 {...}{.importc: "erfcf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc erfc(x: float64): float64 {...}{.importc: "erfc", header: "&lt;math.h&gt;".}</pre></dt> <dd> The complementary error function   </dd>  <dt><pre data-language="nim">proc gamma(x: float32): float32 {...}{.importc: "tgammaf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc gamma(x: float64): float64 {...}{.importc: "tgamma", header: "&lt;math.h&gt;".}</pre></dt> <dd> The gamma function   </dd>  <dt><pre data-language="nim">proc tgamma(x: float32): float32 {...}{.deprecated: "use gamma instead",
                               importc: "tgammaf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc tgamma(x: float64): float64 {...}{.deprecated: "use gamma instead", importc: "tgamma",
                               header: "&lt;math.h&gt;".}</pre></dt> <dd> The gamma function <strong>Deprecated since version 0.19.0</strong>: Use <code>gamma</code> instead.   </dd>  <dt><pre data-language="nim">proc lgamma(x: float32): float32 {...}{.importc: "lgammaf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc lgamma(x: float64): float64 {...}{.importc: "lgamma", header: "&lt;math.h&gt;".}</pre></dt> <dd> Natural log of the gamma function   </dd>  <dt><pre data-language="nim">proc floor(x: float32): float32 {...}{.importc: "floorf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc floor(x: float64): float64 {...}{.importc: "floor", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the floor function (i.e., the largest integer not greater than <em>x</em>)<pre class="listing" data-language="nim">echo floor(-3.5) ## -4.0</pre>   </dd>  <dt><pre data-language="nim">proc ceil(x: float32): float32 {...}{.importc: "ceilf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc ceil(x: float64): float64 {...}{.importc: "ceil", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the ceiling function (i.e., the smallest integer not less than <em>x</em>)<pre class="listing" data-language="nim">echo ceil(-2.1) ## -2.0</pre>   </dd>  <dt><pre data-language="nim">proc trunc(x: float32): float32 {...}{.importc: "truncf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc trunc(x: float64): float64 {...}{.importc: "trunc", header: "&lt;math.h&gt;".}</pre></dt> <dd> Truncates <em>x</em> to the decimal point<pre class="listing" data-language="nim">echo trunc(PI) # 3.0</pre>   </dd>  <dt><pre data-language="nim">proc fmod(x, y: float32): float32 {...}{.deprecated: "use mod instead", importc: "fmodf",
                               header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc fmod(x, y: float64): float64 {...}{.deprecated: "use mod instead", importc: "fmod",
                               header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the remainder of <em>x</em> divided by <em>y</em><pre class="listing" data-language="nim">echo fmod(-2.5, 0.3) ## -0.1</pre>   </dd>  <dt><pre data-language="nim">proc `mod`(x, y: float32): float32 {...}{.importc: "fmodf", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc `mod`(x, y: float64): float64 {...}{.importc: "fmod", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the modulo operation for float operators.   </dd>  <dt><pre data-language="nim">proc round[T: float32 | float64](x: T; places: int = 0): T</pre></dt> <dd> <p>Round a floating point number.</p> <p>If <em>places</em> is 0 (or omitted), round to the nearest integral value following normal mathematical rounding rules (e.g. <em>round(54.5) -&gt; 55.0</em>). If <em>places</em> is greater than 0, round to the given number of decimal places, e.g. <em>round(54.346, 2) -&gt; 54.35</em>. If <em>places</em> is negative, round to the left of the decimal place, e.g. <em>round(537.345, -1) -&gt; 540.0</em></p>   </dd>  <dt><pre data-language="nim">proc floorDiv[T: SomeInteger](x, y: T): T</pre></dt> <dd> Floor division is conceptually defined as <code>floor(x / y)</code>. This is different from the <code>div</code> operator, which is defined as <code>trunc(x / y)</code>. That is, <code>div</code> rounds towards <code>0</code> and <code>floorDiv</code> rounds down.   </dd>  <dt><pre data-language="nim">proc floorMod[T: SomeNumber](x, y: T): T</pre></dt> <dd> Floor modulus is conceptually defined as <code>x - (floorDiv(x, y) * y). This proc behaves the same as the ``%</code> operator in python.   </dd>  <dt><pre data-language="nim">proc c_frexp(x: float32; exponent: var int32): float32 {...}{.importc: "frexp",
    header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc c_frexp(x: float64; exponent: var int32): float64 {...}{.importc: "frexp",
    header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc frexp[T, U](x: T; exponent: var U): T</pre></dt> <dd> Split a number into mantissa and exponent. <em>frexp</em> calculates the mantissa m (a float greater than or equal to 0.5 and less than 1) and the integer value n such that <em>x</em> (the original float value) equals m * 2**n. frexp stores n in <em>exponent</em> and returns m.   </dd>  <dt><pre data-language="nim">proc log2(x: float32): float32 {...}{.importc: "log2f", header: "&lt;math.h&gt;".}</pre></dt>   <dt><pre data-language="nim">proc log2(x: float64): float64 {...}{.importc: "log2", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the binary logarithm (base 2) of <em>x</em>   </dd>  <dt><pre data-language="nim">proc splitDecimal[T: float32 | float64](x: T): tuple[intpart: T, floatpart: T]</pre></dt> <dd> <p>Breaks <em>x</em> into an integral and a fractional part.</p> <p>Returns a tuple containing intpart and floatpart representing the integer part and the fractional part respectively.</p> <p>Both parts have the same sign as <em>x</em>. Analogous to the <em>modf</em> function in C.</p>   </dd>  <dt><pre data-language="nim">proc degToRad[T: float32 | float64](d: T): T {...}{.inline.}</pre></dt> <dd> Convert from degrees to radians   </dd>  <dt><pre data-language="nim">proc radToDeg[T: float32 | float64](d: T): T {...}{.inline.}</pre></dt> <dd> Convert from radians to degrees   </dd>  <dt><pre data-language="nim">proc sgn[T: SomeNumber](x: T): int {...}{.inline.}</pre></dt> <dd> Sign function. Returns -1 for negative numbers and <em>NegInf</em>, 1 for positive numbers and <em>Inf</em>, and 0 for positive zero, negative zero and <em>NaN</em>.   </dd>  <dt><pre data-language="nim">proc `^`[T](x: T; y: Natural): T</pre></dt> <dd> Computes <code>x</code> to the power <code>y</code>. <code>x</code> must be non-negative, use <a href="#pow,float,float">pow</a> for negative exponents.   </dd>  <dt><pre data-language="nim">proc gcd[T](x, y: T): T</pre></dt> <dd> Computes the greatest common (positive) divisor of <code>x</code> and <code>y</code>. Note that for floats, the result cannot always be interpreted as "greatest decimal <em>z</em> such that <code>z*N == x and z*M == y</code> where N and M are positive integers."   </dd>  <dt><pre data-language="nim">proc gcd(x, y: SomeInteger): SomeInteger</pre></dt> <dd> Computes the greatest common (positive) divisor of <code>x</code> and <code>y</code>. Using binary GCD (aka Stein's) algorithm.   </dd>  <dt><pre data-language="nim">proc lcm[T](x, y: T): T</pre></dt> <dd> Computes the least common multiple of <code>x</code> and <code>y</code>.   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2018 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/math.html" class="_attribution-link">https://nim-lang.org/docs/math.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
