
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Pegs - Nim - W3cubDocs</title>
  
  <meta name="description" content="Simple PEG (Parsing expression grammar) matching. Uses no memorization, but uses superoperators and symbol inlining to improve performance. Note&#58 &hellip;">
  <meta name="keywords" content="module, pegs, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nim/pegs.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="title">Module pegs</h1>  <p class="module-desc">Simple PEG (Parsing expression grammar) matching. Uses no memorization, but uses superoperators and symbol inlining to improve performance. Note: Matching performance is hopefully competitive with optimized regular expression engines. </p>
<h2 id="peg-syntax-and-semantics">PEG syntax and semantics</h2>
<p>A PEG (Parsing expression grammar) is a simple deterministic grammar, that can be directly used for parsing. The current implementation has been designed as a more powerful replacement for regular expressions. UTF-8 is supported.</p> <p>The notation used for a PEG is similar to that of EBNF:</p> <table>
<tr>
<th>notation</th>
<th>meaning</th>
</tr> <tr>
<td><code>A / ... / Z</code></td>
<td>Ordered choice: Apply expressions <em>A</em>, ..., <em>Z</em>, in this order, to the text ahead, until one of them succeeds and possibly consumes some text. Indicate success if one of expressions succeeded. Otherwise do not consume any text and indicate failure.</td>
</tr> <tr>
<td><code>A ... Z</code></td>
<td>Sequence: Apply expressions <em>A</em>, ..., <em>Z</em>, in this order, to consume consecutive portions of the text ahead, as long as they succeed. Indicate success if all succeeded. Otherwise do not consume any text and indicate failure. The sequence's precedence is higher than that of ordered choice: <code>A B / C</code> means <code>(A B) / Z</code> and not <code>A (B / Z)</code>.</td>
</tr> <tr>
<td><code>(E)</code></td>
<td>Grouping: Parenthesis can be used to change operator priority.</td>
</tr> <tr>
<td><code>{E}</code></td>
<td>Capture: Apply expression <em>E</em> and store the substring that matched <em>E</em> into a <em>capture</em> that can be accessed after the matching process.</td>
</tr> <tr>
<td><code>$i</code></td>
<td>Back reference to the <code>i``th capture. ``i</code> counts from 1.</td>
</tr> <tr>
<td><code>$</code></td>
<td>Anchor: Matches at the end of the input. No character is consumed. Same as <code>!.</code>.</td>
</tr> <tr>
<td><code>^</code></td>
<td>Anchor: Matches at the start of the input. No character is consumed.</td>
</tr> <tr>
<td><code>&amp;E</code></td>
<td>And predicate: Indicate success if expression <em>E</em> matches the text ahead; otherwise indicate failure. Do not consume any text.</td>
</tr> <tr>
<td><code>!E</code></td>
<td>Not predicate: Indicate failure if expression E matches the text ahead; otherwise indicate success. Do not consume any text.</td>
</tr> <tr>
<td><code>E+</code></td>
<td>One or more: Apply expression <em>E</em> repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any) and indicate success if there was at least one match. Otherwise indicate failure.</td>
</tr> <tr>
<td><code>E*</code></td>
<td>Zero or more: Apply expression <em>E</em> repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any). Always indicate success.</td>
</tr> <tr>
<td><code>E?</code></td>
<td>Zero or one: If expression <em>E</em> matches the text ahead, consume it. Always indicate success.</td>
</tr> <tr>
<td><code>[s]</code></td>
<td>Character class: If the character ahead appears in the string <em>s</em>, consume it and indicate success. Otherwise indicate failure.</td>
</tr> <tr>
<td><code>[a-b]</code></td>
<td>Character range: If the character ahead is one from the range <em>a</em> through <em>b</em>, consume it and indicate success. Otherwise indicate failure.</td>
</tr> <tr>
<td><code>'s'</code></td>
<td>String: If the text ahead is the string <em>s</em>, consume it and indicate success. Otherwise indicate failure.</td>
</tr> <tr>
<td><code>i's'</code></td>
<td>String match ignoring case.</td>
</tr> <tr>
<td><code>y's'</code></td>
<td>String match ignoring style.</td>
</tr> <tr>
<td><code>v's'</code></td>
<td>Verbatim string match: Use this to override a global <code>\i</code> or <code>\y</code> modifier.</td>
</tr> <tr>
<td><code>i$j</code></td>
<td>String match ignoring case for back reference.</td>
</tr> <tr>
<td><code>y$j</code></td>
<td>String match ignoring style for back reference.</td>
</tr> <tr>
<td><code>v$j</code></td>
<td>Verbatim string match for back reference.</td>
</tr> <tr>
<td><code>.</code></td>
<td>Any character: If there is a character ahead, consume it and indicate success. Otherwise (that is, at the end of input) indicate failure.</td>
</tr> <tr>
<td><code>_</code></td>
<td>Any Unicode character: If there is an UTF-8 character ahead, consume it and indicate success. Otherwise indicate failure.</td>
</tr> <tr>
<td><code>@E</code></td>
<td>Search: Shorthand for <code>(!E .)* E</code>. (Search loop for the pattern <em>E</em>.)</td>
</tr> <tr>
<td><code>{@} E</code></td>
<td>Captured Search: Shorthand for <code>{(!E .)*} E</code>. (Search loop for the pattern <em>E</em>.) Everything until and exluding <em>E</em> is captured.</td>
</tr> <tr>
<td><code>@@ E</code></td>
<td>Same as <code>{@} E</code>.</td>
</tr> <tr>
<td><code>A &lt;- E</code></td>
<td>Rule: Bind the expression <em>E</em> to the <em>nonterminal symbol</em> <em>A</em>. <strong>Left recursive rules are not possible and crash the matching engine.</strong>
</td>
</tr> <tr>
<td><code>\identifier</code></td>
<td>Built-in macro for a longer expression.</td>
</tr> <tr>
<td><code>\ddd</code></td>
<td>Character with decimal code <em>ddd</em>.</td>
</tr> <tr>
<td>
<code>\"</code>, etc</td>
<td>Literal <code>"</code>, etc.</td>
</tr> </table> <h3 id="peg-syntax-and-semantics-builtminusin-macros">Built-in macros</h3>
<table>
<tr>
<th>macro</th>
<th>meaning</th>
</tr> <tr>
<td><code>\d</code></td>
<td>any decimal digit: <code>[0-9]</code>
</td>
</tr> <tr>
<td><code>\D</code></td>
<td>any character that is not a decimal digit: <code>[^0-9]</code>
</td>
</tr> <tr>
<td><code>\s</code></td>
<td>any whitespace character: <code>[ \9-\13]</code>
</td>
</tr> <tr>
<td><code>\S</code></td>
<td>any character that is not a whitespace character: <code>[^ \9-\13]</code>
</td>
</tr> <tr>
<td><code>\w</code></td>
<td>any "word" character: <code>[a-zA-Z0-9_]</code>
</td>
</tr> <tr>
<td><code>\W</code></td>
<td>any "non-word" character: <code>[^a-zA-Z0-9_]</code>
</td>
</tr> <tr>
<td><code>\a</code></td>
<td>same as <code>[a-zA-Z]</code>
</td>
</tr> <tr>
<td><code>\A</code></td>
<td>same as <code>[^a-zA-Z]</code>
</td>
</tr> <tr>
<td><code>\n</code></td>
<td>any newline combination: <code>\10 / \13\10 / \13</code>
</td>
</tr> <tr>
<td><code>\i</code></td>
<td>ignore case for matching; use this at the start of the PEG</td>
</tr> <tr>
<td><code>\y</code></td>
<td>ignore style for matching; use this at the start of the PEG</td>
</tr> <tr>
<td>
<code>\skip</code> pat</td>
<td>skip pattern <em>pat</em> before trying to match other tokens; this is useful for whitespace skipping, for example: <code>\skip(\s*) {\ident} ':' {\ident}</code> matches key value pairs ignoring whitespace around the <code>':'</code>.</td>
</tr> <tr>
<td><code>\ident</code></td>
<td>a standard ASCII identifier: <code>[a-zA-Z_][a-zA-Z_0-9]*</code>
</td>
</tr> <tr>
<td><code>\letter</code></td>
<td>any Unicode letter</td>
</tr> <tr>
<td><code>\upper</code></td>
<td>any Unicode uppercase letter</td>
</tr> <tr>
<td><code>\lower</code></td>
<td>any Unicode lowercase letter</td>
</tr> <tr>
<td><code>\title</code></td>
<td>any Unicode title letter</td>
</tr> <tr>
<td><code>\white</code></td>
<td>any Unicode whitespace character</td>
</tr> </table>
<p>A backslash followed by a letter is a built-in macro, otherwise it is used for ordinary escaping:</p> <table>
<tr>
<th>notation</th>
<th>meaning</th>
</tr> <tr>
<td><code>\\</code></td>
<td>a single backslash</td>
</tr> <tr>
<td><code>\*</code></td>
<td>same as <code>'*'</code>
</td>
</tr> <tr>
<td><code>\t</code></td>
<td>not a tabulator, but an (unknown) built-in</td>
</tr> </table> <h3 id="peg-syntax-and-semantics-supported-peg-grammar">Supported PEG grammar</h3>
<p>The PEG parser implements this grammar (written in PEG syntax):</p>
<pre data-language="nim"># Example grammar of PEG in PEG syntax.
# Comments start with '#'.
# First symbol is the start symbol.

grammar &lt;- rule* / expr

identifier &lt;- [A-Za-z][A-Za-z0-9_]*
charsetchar &lt;- "\\" . / [^\]]
charset &lt;- "[" "^"? (charsetchar ("-" charsetchar)?)+ "]"
stringlit &lt;- identifier? ("\"" ("\\" . / [^"])* "\"" /
                          "'" ("\\" . / [^'])* "'")
builtin &lt;- "\\" identifier / [^\13\10]

comment &lt;- '#' @ \n
ig &lt;- (\s / comment)* # things to ignore

rule &lt;- identifier \s* "&lt;-" expr ig
identNoArrow &lt;- identifier !(\s* "&lt;-")
prefixOpr &lt;- ig '&amp;' / ig '!' / ig '@' / ig '{@}' / ig '@@'
literal &lt;- ig identifier? '$' [0-9]+ / '$' / '^' /
           ig identNoArrow /
           ig charset /
           ig stringlit /
           ig builtin /
           ig '.' /
           ig '_' /
           (ig "(" expr ig ")")
postfixOpr &lt;- ig '?' / ig '*' / ig '+'
primary &lt;- prefixOpr* (literal postfixOpr*)

# Concatenation has higher priority than choice:
# ``a b / c`` means ``(a b) / c``

seqExpr &lt;- primary+
expr &lt;- seqExpr (ig "/" expr)*</pre> <p><strong>Note</strong>: As a special syntactic extension if the whole PEG is only a single expression, identifiers are not interpreted as non-terminals, but are interpreted as verbatim string:</p> <pre class="listing" data-language="nim">abc =~ peg"abc" # is true</pre>
<p>So it is not necessary to write <code>peg" 'abc' "</code> in the above example.</p> <h3 id="peg-syntax-and-semantics-examples">Examples</h3>
<p>Check if <em>s</em> matches Nim's "while" keyword:</p> <pre class="listing" data-language="nim">s =~ peg" y'while'"</pre>
<p>Exchange (key, val)-pairs:</p> <pre class="listing" data-language="nim">"key: val; key2: val2".replacef(peg"{\ident} \s* ':' \s* {\ident}", "$2: $1")</pre>
<p>Determine the <code>#include</code>'ed files of a C file:</p> <pre class="listing" data-language="nim">for line in lines("myfile.c"):
  if line =~ peg"""s &lt;- ws '#include' ws '"' {[^"]+} '"' ws
                   comment &lt;- '/*' @ '*/' / '//' .*
                   ws &lt;- (comment / \s+)* """:
    echo matches[0]</pre> <h3 id="peg-syntax-and-semantics-peg-vs-regular-expression">PEG vs regular expression</h3>
<p>As a regular expression <code>\[.*\]</code> matches the longest possible text between <code>'['</code> and <code>']'</code>. As a PEG it never matches anything, because a PEG is deterministic: <code>.*</code> consumes the rest of the input, so <code>\]</code> never matches. As a PEG this needs to be written as: <code>\[ ( !\] . )* \]</code> (or <code>\[ @ \]</code>).</p> <p>Note that the regular expression does not behave as intended either: in the example <code>*</code> should not be greedy, so <code>\[.*?\]</code> should be used instead.</p> <h3 id="peg-syntax-and-semantics-peg-construction">PEG construction</h3>
<p>There are two ways to construct a PEG in Nim code:</p> <ol class="simple">
<li>Parsing a string into an AST which consists of <em>Peg</em> nodes with the <em>peg</em> proc.</li> <li>Constructing the AST directly with proc calls. This method does not support constructing rules, only simple expressions and is not as convenient. Its only advantage is that it does not pull in the whole PEG parser into your executable.</li> </ol>  <h2 id="5">Exports</h2> <dl> <a href="unicode#=="><span class="Identifier">==</span></a> </dl>  <h2 id="6">Imports</h2> <dl> <a href="strutils">strutils</a>, <a href="macros">macros</a>, <a href="unicode">unicode</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre data-language="nim">PegKind = enum
  pkEmpty, pkAny,              ## any character (.)
  pkAnyRune,                  ## any Unicode character (_)
  pkNewLine,                  ## CR-LF, LF, CR
  pkLetter,                   ## Unicode letter
  pkLower,                    ## Unicode lower case letter
  pkUpper,                    ## Unicode upper case letter
  pkTitle,                    ## Unicode title character
  pkWhitespace,               ## Unicode whitespace character
  pkTerminal, pkTerminalIgnoreCase, pkTerminalIgnoreStyle, pkChar, ## single character to match
  pkCharChoice, pkNonTerminal, pkSequence, ## a b c ... --&gt; Internal DSL: peg(a, b, c)
  pkOrderedChoice,            ## a / b / ... --&gt; Internal DSL: a / b or /[a, b, c]
  pkGreedyRep,                ## a*     --&gt; Internal DSL: *a
              ## a+     --&gt; (a a*)
  pkGreedyRepChar,            ## x* where x is a single character (superop)
  pkGreedyRepSet,             ## [set]* (superop)
  pkGreedyAny,                ## .* or _* (superop)
  pkOption,                   ## a?     --&gt; Internal DSL: ?a
  pkAndPredicate,             ## &amp;a     --&gt; Internal DSL: &amp;a
  pkNotPredicate,             ## !a     --&gt; Internal DSL: !a
  pkCapture,                  ## {a}    --&gt; Internal DSL: capture(a)
  pkBackRef,                  ## $i     --&gt; Internal DSL: backref(i)
  pkBackRefIgnoreCase, pkBackRefIgnoreStyle, pkSearch, ## @a     --&gt; Internal DSL: !*a
  pkCapturedSearch,           ## {@} a  --&gt; Internal DSL: !*\a
  pkRule,                     ## a &lt;- b
  pkList,                     ## a, b
  pkStartAnchor               ## ^      --&gt; Internal DSL: startAnchor()</pre></dt>   <dt><pre data-language="nim">NonTerminalFlag = enum
  ntDeclared, ntUsed</pre></dt>   <dt><pre data-language="nim">Peg {...}{.shallow.} = object
  case kind: PegKind
  of pkEmpty .. pkWhitespace:
    nil
  of pkTerminal, pkTerminalIgnoreCase, pkTerminalIgnoreStyle:
    term: string
  of pkChar, pkGreedyRepChar:
    ch: char
  of pkCharChoice, pkGreedyRepSet:
    charChoice: ref set[char]
  of pkNonTerminal:
    nt: NonTerminal
  of pkBackRef .. pkBackRefIgnoreStyle:
    index: range[0 .. MaxSubpatterns]
  else:
    sons: seq[Peg]</pre></dt> <dd> type that represents a PEG   </dd>  <dt><pre>NonTerminal = ref NonTerminalObj</pre></dt>   <dt><pre data-language="nim">Captures = object
  matches: array[0 .. 20 - 1, tuple[first, last: int]]
  ml: int
  origStart: int</pre></dt> <dd> contains the captured substrings.   </dd>  <dt><pre>EInvalidPeg = object of ValueError</pre></dt> <dd> raised if an invalid PEG has been detected   </dd> </dl>  <h2 id="10">Consts</h2> <dl>  <dt><pre>MaxSubpatterns = 20</pre></dt> <dd> defines the maximum number of subpatterns that can be captured. More subpatterns cannot be captured!   </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre data-language="nim">proc kind(p: Peg): PegKind {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the <em>PegKind</em> of a given <em>Peg</em> object.   </dd>  <dt><pre data-language="nim">proc term(p: Peg): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the <em>string</em> representation of a given <em>Peg</em> variant object where present.   </dd>  <dt><pre data-language="nim">proc ch(p: Peg): char {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the <em>char</em> representation of a given <em>Peg</em> variant object where present.   </dd>  <dt><pre data-language="nim">proc charChoice(p: Peg): ref set[char] {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the <em>charChoice</em> field of a given <em>Peg</em> variant object where present.   </dd>  <dt><pre data-language="nim">proc nt(p: Peg): NonTerminal {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the <em>NonTerminal</em> object of a given <em>Peg</em> variant object where present.   </dd>  <dt><pre data-language="nim">proc index(p: Peg): range[0 .. MaxSubpatterns] {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the back-reference index of a captured sub-pattern in the <em>Captures</em> object for a given <em>Peg</em> variant object where present.   </dd>  <dt><pre data-language="nim">proc name(nt: NonTerminal): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Gets the name of the symbol represented by the parent <em>Peg</em> object variant of a given <em>NonTerminal</em>.   </dd>  <dt><pre data-language="nim">proc line(nt: NonTerminal): int {...}{.raises: [], tags: [].}</pre></dt> <dd> Gets the line number of the definition of the parent <em>Peg</em> object variant of a given <em>NonTerminal</em>.   </dd>  <dt><pre data-language="nim">proc col(nt: NonTerminal): int {...}{.raises: [], tags: [].}</pre></dt> <dd> Gets the column number of the definition of the parent <em>Peg</em> object variant of a given <em>NonTerminal</em>.   </dd>  <dt><pre data-language="nim">proc flags(nt: NonTerminal): set[NonTerminalFlag] {...}{.raises: [], tags: [].}</pre></dt> <dd> Gets the <em>NonTerminalFlag</em>-typed flags field of the parent <em>Peg</em> variant object of a given <em>NonTerminal</em>.   </dd>  <dt><pre data-language="nim">proc rule(nt: NonTerminal): Peg {...}{.raises: [], tags: [].}</pre></dt> <dd> Gets the <em>Peg</em> object representing the rule definition of the parent <em>Peg</em> object variant of a given <em>NonTerminal</em>.   </dd>  <dt><pre data-language="nim">proc term(t: string): Peg {...}{.nosideEffect, gcsafe, extern: "npegs$1Str", raises: [],
                        tags: [].}</pre></dt> <dd> constructs a PEG from a terminal string   </dd>  <dt><pre data-language="nim">proc termIgnoreCase(t: string): Peg {...}{.nosideEffect, gcsafe, extern: "npegs$1",
                                  raises: [], tags: [].}</pre></dt> <dd> constructs a PEG from a terminal string; ignore case for matching   </dd>  <dt><pre data-language="nim">proc termIgnoreStyle(t: string): Peg {...}{.nosideEffect, gcsafe, extern: "npegs$1",
                                   raises: [], tags: [].}</pre></dt> <dd> constructs a PEG from a terminal string; ignore style for matching   </dd>  <dt><pre data-language="nim">proc term(t: char): Peg {...}{.nosideEffect, gcsafe, extern: "npegs$1Char", raises: [],
                      tags: [].}</pre></dt> <dd> constructs a PEG from a terminal char   </dd>  <dt><pre data-language="nim">proc charSet(s: set[char]): Peg {...}{.nosideEffect, gcsafe, extern: "npegs$1", raises: [],
                              tags: [].}</pre></dt> <dd> constructs a PEG from a character set <em>s</em>   </dd>  <dt><pre data-language="nim">proc `/`(a: varargs[Peg]): Peg {...}{.nosideEffect, gcsafe, extern: "npegsOrderedChoice",
                             raises: [], tags: [].}</pre></dt> <dd> constructs an ordered choice with the PEGs in <em>a</em>   </dd>  <dt><pre data-language="nim">proc sequence(a: varargs[Peg]): Peg {...}{.nosideEffect, gcsafe, extern: "npegs$1",
                                  raises: [], tags: [].}</pre></dt> <dd> constructs a sequence with all the PEGs from <em>a</em>   </dd>  <dt><pre data-language="nim">proc `?`(a: Peg): Peg {...}{.nosideEffect, gcsafe, extern: "npegsOptional", raises: [],
                    tags: [].}</pre></dt> <dd> constructs an optional for the PEG <em>a</em>   </dd>  <dt><pre data-language="nim">proc `*`(a: Peg): Peg {...}{.nosideEffect, gcsafe, extern: "npegsGreedyRep", raises: [],
                    tags: [].}</pre></dt> <dd> constructs a "greedy repetition" for the PEG <em>a</em>   </dd>  <dt><pre data-language="nim">proc `!*`(a: Peg): Peg {...}{.nosideEffect, gcsafe, extern: "npegsSearch", raises: [], tags: [].}</pre></dt> <dd> constructs a "search" for the PEG <em>a</em>   </dd>  <dt><pre data-language="nim">proc `!*\`(a: Peg): Peg {...}{.noSideEffect, gcsafe, extern: "npgegsCapturedSearch",
                      raises: [], tags: [].}</pre></dt> <dd> constructs a "captured search" for the PEG <em>a</em>   </dd>  <dt><pre data-language="nim">proc `+`(a: Peg): Peg {...}{.nosideEffect, gcsafe, extern: "npegsGreedyPosRep", raises: [],
                    tags: [].}</pre></dt> <dd> constructs a "greedy positive repetition" with the PEG <em>a</em>   </dd>  <dt><pre data-language="nim">proc `&amp;`(a: Peg): Peg {...}{.nosideEffect, gcsafe, extern: "npegsAndPredicate", raises: [],
                    tags: [].}</pre></dt> <dd> constructs an "and predicate" with the PEG <em>a</em>   </dd>  <dt><pre data-language="nim">proc `!`(a: Peg): Peg {...}{.nosideEffect, gcsafe, extern: "npegsNotPredicate", raises: [],
                    tags: [].}</pre></dt> <dd> constructs a "not predicate" with the PEG <em>a</em>   </dd>  <dt><pre data-language="nim">proc any(): Peg {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> constructs the PEG <span id="any-character_1">any character</span> (<code>.</code>)   </dd>  <dt><pre data-language="nim">proc anyRune(): Peg {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> constructs the PEG <span id="any-rune_1">any rune</span> (<code>_</code>)   </dd>  <dt><pre data-language="nim">proc newLine(): Peg {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> constructs the PEG <span id="newline_1">newline</span> (<code>\n</code>)   </dd>  <dt><pre data-language="nim">proc unicodeLetter(): Peg {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> constructs the PEG <code>\letter</code> which matches any Unicode letter.   </dd>  <dt><pre data-language="nim">proc unicodeLower(): Peg {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> constructs the PEG <code>\lower</code> which matches any Unicode lowercase letter.   </dd>  <dt><pre data-language="nim">proc unicodeUpper(): Peg {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> constructs the PEG <code>\upper</code> which matches any Unicode uppercase letter.   </dd>  <dt><pre data-language="nim">proc unicodeTitle(): Peg {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> constructs the PEG <code>\title</code> which matches any Unicode title letter.   </dd>  <dt><pre data-language="nim">proc unicodeWhitespace(): Peg {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> constructs the PEG <code>\white</code> which matches any Unicode whitespace character.   </dd>  <dt><pre data-language="nim">proc startAnchor(): Peg {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> constructs the PEG <code>^</code> which matches the start of the input.   </dd>  <dt><pre data-language="nim">proc endAnchor(): Peg {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> constructs the PEG <code>$</code> which matches the end of the input.   </dd>  <dt><pre data-language="nim">proc capture(a: Peg): Peg {...}{.nosideEffect, gcsafe, extern: "npegsCapture", raises: [],
                        tags: [].}</pre></dt> <dd> constructs a capture with the PEG <em>a</em>   </dd>  <dt><pre data-language="nim">proc backref(index: range[1 .. MaxSubpatterns]): Peg {...}{.nosideEffect, gcsafe,
    extern: "npegs$1", raises: [], tags: [].}</pre></dt> <dd> constructs a back reference of the given <em>index</em>. <em>index</em> starts counting from 1.   </dd>  <dt><pre data-language="nim">proc backrefIgnoreCase(index: range[1 .. MaxSubpatterns]): Peg {...}{.nosideEffect, gcsafe,
    extern: "npegs$1", raises: [], tags: [].}</pre></dt> <dd> constructs a back reference of the given <em>index</em>. <em>index</em> starts counting from 1. Ignores case for matching.   </dd>  <dt><pre data-language="nim">proc backrefIgnoreStyle(index: range[1 .. MaxSubpatterns]): Peg {...}{.nosideEffect, gcsafe,
    extern: "npegs$1", raises: [], tags: [].}</pre></dt> <dd> constructs a back reference of the given <em>index</em>. <em>index</em> starts counting from 1. Ignores style for matching.   </dd>  <dt><pre data-language="nim">proc nonterminal(n: NonTerminal): Peg {...}{.nosideEffect, gcsafe, extern: "npegs$1",
                                    raises: [], tags: [].}</pre></dt> <dd> constructs a PEG that consists of the nonterminal symbol   </dd>  <dt><pre data-language="nim">proc newNonTerminal(name: string; line, column: int): NonTerminal {...}{.nosideEffect,
    gcsafe, extern: "npegs$1", raises: [], tags: [].}</pre></dt> <dd> constructs a nonterminal symbol   </dd>  <dt><pre data-language="nim">proc `$`(r: Peg): string {...}{.nosideEffect, gcsafe, extern: "npegsToString", raises: [],
                       tags: [].}</pre></dt> <dd> converts a PEG to its string representation   </dd>  <dt><pre data-language="nim">proc bounds(c: Captures; i: range[0 .. 20 - 1]): tuple[first, last: int] {...}{.raises: [],
    tags: [].}</pre></dt> <dd> returns the bounds <code>[first..last]</code> of the <em>i</em>'th capture.   </dd>  <dt><pre data-language="nim">proc rawMatch(s: string; p: Peg; start: int; c: var Captures): int {...}{.noSideEffect, gcsafe,
    extern: "npegs$1", raises: [], tags: [].}</pre></dt> <dd> low-level matching proc that implements the PEG interpreter. Use this for maximum efficiency (every other PEG operation ends up calling this proc). Returns -1 if it does not match, else the length of the match   </dd>  <dt><pre data-language="nim">proc matchLen(s: string; pattern: Peg; matches: var openArray[string]; start = 0): int {...}{.
    nosideEffect, gcsafe, extern: "npegs$1Capture", raises: [], tags: [].}</pre></dt> <dd> the same as <code>match</code>, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen. It's possible that a suffix of <em>s</em> remains that does not belong to the match.   </dd>  <dt><pre data-language="nim">proc matchLen(s: string; pattern: Peg; start = 0): int {...}{.nosideEffect, gcsafe,
    extern: "npegs$1", raises: [], tags: [].}</pre></dt> <dd> the same as <code>match</code>, but it returns the length of the match, if there is no match, -1 is returned. Note that a match length of zero can happen. It's possible that a suffix of <em>s</em> remains that does not belong to the match.   </dd>  <dt><pre data-language="nim">proc match(s: string; pattern: Peg; matches: var openArray[string]; start = 0): bool {...}{.
    nosideEffect, gcsafe, extern: "npegs$1Capture", raises: [], tags: [].}</pre></dt> <dd> returns <code>true</code> if <code>s[start..]</code> matches the <code>pattern</code> and the captured substrings in the array <code>matches</code>. If it does not match, nothing is written into <code>matches</code> and <code>false</code> is returned.   </dd>  <dt><pre data-language="nim">proc match(s: string; pattern: Peg; start = 0): bool {...}{.nosideEffect, gcsafe,
    extern: "npegs$1", raises: [], tags: [].}</pre></dt> <dd> returns <code>true</code> if <code>s</code> matches the <code>pattern</code> beginning from <code>start</code>.   </dd>  <dt><pre data-language="nim">proc find(s: string; pattern: Peg; matches: var openArray[string]; start = 0): int {...}{.
    nosideEffect, gcsafe, extern: "npegs$1Capture", raises: [], tags: [].}</pre></dt> <dd> returns the starting position of <code>pattern</code> in <code>s</code> and the captured substrings in the array <code>matches</code>. If it does not match, nothing is written into <code>matches</code> and -1 is returned.   </dd>  <dt><pre data-language="nim">proc findBounds(s: string; pattern: Peg; matches: var openArray[string]; start = 0): tuple[
    first, last: int] {...}{.nosideEffect, gcsafe, extern: "npegs$1Capture", raises: [],
                     tags: [].}</pre></dt> <dd> returns the starting position and end position of <code>pattern</code> in <code>s</code> and the captured substrings in the array <code>matches</code>. If it does not match, nothing is written into <code>matches</code> and (-1,0) is returned.   </dd>  <dt><pre data-language="nim">proc find(s: string; pattern: Peg; start = 0): int {...}{.nosideEffect, gcsafe,
    extern: "npegs$1", raises: [], tags: [].}</pre></dt> <dd> returns the starting position of <code>pattern</code> in <code>s</code>. If it does not match, -1 is returned.   </dd>  <dt><pre data-language="nim">proc findAll(s: string; pattern: Peg; start = 0): seq[string] {...}{.nosideEffect, gcsafe,
    extern: "npegs$1", raises: [], tags: [].}</pre></dt> <dd> returns all matching <em>substrings</em> of <em>s</em> that match <em>pattern</em>. If it does not match, @[] is returned.   </dd>  <dt><pre data-language="nim">proc contains(s: string; pattern: Peg; start = 0): bool {...}{.nosideEffect, gcsafe,
    extern: "npegs$1", raises: [], tags: [].}</pre></dt> <dd> same as <code>find(s, pattern, start) &gt;= 0</code>   </dd>  <dt><pre data-language="nim">proc contains(s: string; pattern: Peg; matches: var openArray[string]; start = 0): bool {...}{.
    nosideEffect, gcsafe, extern: "npegs$1Capture", raises: [], tags: [].}</pre></dt> <dd> same as <code>find(s, pattern, matches, start) &gt;= 0</code>   </dd>  <dt><pre data-language="nim">proc startsWith(s: string; prefix: Peg; start = 0): bool {...}{.nosideEffect, gcsafe,
    extern: "npegs$1", raises: [], tags: [].}</pre></dt> <dd> returns true if <em>s</em> starts with the pattern <em>prefix</em>   </dd>  <dt><pre data-language="nim">proc endsWith(s: string; suffix: Peg; start = 0): bool {...}{.nosideEffect, gcsafe,
    extern: "npegs$1", raises: [], tags: [].}</pre></dt> <dd> returns true if <em>s</em> ends with the pattern <em>suffix</em>   </dd>  <dt><pre data-language="nim">proc replacef(s: string; sub: Peg; by: string): string {...}{.nosideEffect, gcsafe,
    extern: "npegs$1", raises: [ValueError], tags: [].}</pre></dt> <dd> Replaces <em>sub</em> in <em>s</em> by the string <em>by</em>. Captures can be accessed in <em>by</em> with the notation <code>$i</code> and <code>$#</code> (see strutils.`%`). Examples:<pre class="listing" data-language="nim">"var1=key; var2=key2".replacef(peg"{\ident}'='{\ident}", "$1&lt;-$2$2")</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"var1&lt;-keykey; val2&lt;-key2key2"</pre>   </dd>  <dt><pre data-language="nim">proc replace(s: string; sub: Peg; by = ""): string {...}{.nosideEffect, gcsafe,
    extern: "npegs$1", raises: [], tags: [].}</pre></dt> <dd> Replaces <em>sub</em> in <em>s</em> by the string <em>by</em>. Captures cannot be accessed in <em>by</em>.   </dd>  <dt><pre data-language="nim">proc parallelReplace(s: string; subs: varargs[tuple[pattern: Peg, repl: string]]): string {...}{.
    nosideEffect, gcsafe, extern: "npegs$1", raises: [ValueError], tags: [].}</pre></dt> <dd> Returns a modified copy of <em>s</em> with the substitutions in <em>subs</em> applied in parallel.   </dd>  <dt><pre data-language="nim">proc replace(s: string; sub: Peg;
            cb: proc (match: int; cnt: int; caps: openArray[string]): string): string {...}{.
    gcsafe, extern: "npegs$1cb", raises: [], tags: [].}</pre></dt> <dd> Replaces <em>sub</em> in <em>s</em> by the resulting strings from the callback. The callback proc receives the index of the current match (starting with 0), the count of captures and an open array with the captures of each match. Examples:<pre class="listing" data-language="nim">proc handleMatches*(m: int, n: int, c: openArray[string]): string =
  result = ""
  if m &gt; 0:
    result.add ", "
  result.add case n:
    of 2: c[0].toLower &amp; ": '" &amp; c[1] &amp; "'"
    of 1: c[0].toLower &amp; ": ''"
    else: ""

let s = "Var1=key1;var2=Key2;   VAR3"
echo s.replace(peg"{\ident}('='{\ident})* ';'* \s*", handleMatches)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"var1: 'key1', var2: 'Key2', var3: ''"</pre>   </dd>  <dt><pre data-language="nim">proc transformFile(infile, outfile: string;
                  subs: varargs[tuple[pattern: Peg, repl: string]]) {...}{.gcsafe,
    extern: "npegs$1", raises: [IOError, ValueError],
    tags: [ReadIOEffect, WriteIOEffect].}</pre></dt> <dd> <p>reads in the file <em>infile</em>, performs a parallel replacement (calls <em>parallelReplace</em>) and writes back to <em>outfile</em>. Raises <code>EIO</code> if an error occurs. This is supposed to be used for quick scripting.</p> <p><strong>Note</strong>: this proc does not exist while using the JS backend.</p>   </dd>  <dt><pre data-language="nim">proc split(s: string; sep: Peg): seq[string] {...}{.nosideEffect, gcsafe, extern: "npegs$1",
    raises: [], tags: [].}</pre></dt> <dd> Splits the string <em>s</em> into substrings.   </dd>  <dt><pre data-language="nim">proc parsePeg(pattern: string; filename = "pattern"; line = 1; col = 0): Peg {...}{.
    raises: [ValueError, EInvalidPeg, Exception], tags: [RootEffect].}</pre></dt> <dd> constructs a Peg object from <em>pattern</em>. <em>filename</em>, <em>line</em>, <em>col</em> are used for error messages, but they only provide start offsets. <em>parsePeg</em> keeps track of line and column numbers within <em>pattern</em>.   </dd>  <dt><pre data-language="nim">proc peg(pattern: string): Peg {...}{.raises: [ValueError, EInvalidPeg, Exception],
                             tags: [RootEffect].}</pre></dt> <dd> constructs a Peg object from the <em>pattern</em>. The short name has been chosen to encourage its use as a raw string modifier:<pre data-language="nim">peg"{\ident} \s* '=' \s* {.*}"</pre>   </dd>  <dt><pre data-language="nim">proc escapePeg(s: string): string {...}{.raises: [], tags: [].}</pre></dt> <dd> escapes <em>s</em> so that it is matched verbatim when used as a peg.   </dd>  <dt><pre data-language="nim">proc handleMatches(m: int; n: int; c: openArray[string]): string {...}{.raises: [], tags: [].}</pre></dt> <dd> "is greater" operator. This is the same as <code>y &lt; x</code>.   </dd> </dl>  <h2 id="15">Iterators</h2> <dl>  <dt><pre data-language="nim">iterator items(p: Peg): Peg {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Yields the child nodes of a <em>Peg</em> variant object where present.   </dd>  <dt><pre data-language="nim">iterator pairs(p: Peg): (int, Peg) {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Yields the indices and child nodes of a <em>Peg</em> variant object where present.   </dd>  <dt><pre data-language="nim">iterator findAll(s: string; pattern: Peg; start = 0): string {...}{.raises: [], tags: [].}</pre></dt> <dd> yields all matching <em>substrings</em> of <em>s</em> that match <em>pattern</em>.   </dd>  <dt><pre data-language="nim">iterator split(s: string; sep: Peg): string {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <em>s</em> into substrings.</p> <p>Substrings are separated by the PEG <em>sep</em>. Examples:</p> <pre class="listing" data-language="nim">for word in split("00232this02939is39an22example111", peg"\d+"):
  writeLine(stdout, word)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"this"
"is"
"an"
"example"</pre>   </dd> </dl>  <h2 id="18">Templates</h2> <dl>  <dt><pre data-language="nim">template letters(): Peg</pre></dt> <dd> expands to <code>charset({'A'..'Z', 'a'..'z'})</code>   </dd>  <dt><pre data-language="nim">template digits(): Peg</pre></dt> <dd> expands to <code>charset({'0'..'9'})</code>   </dd>  <dt><pre data-language="nim">template whitespace(): Peg</pre></dt> <dd> expands to <code>charset({' ', '\9'..'\13'})</code>   </dd>  <dt><pre data-language="nim">template identChars(): Peg</pre></dt> <dd> expands to <code>charset({'a'..'z', 'A'..'Z', '0'..'9', '_'})</code>   </dd>  <dt><pre data-language="nim">template identStartChars(): Peg</pre></dt> <dd> expands to <code>charset({'A'..'Z', 'a'..'z', '_'})</code>   </dd>  <dt><pre data-language="nim">template ident(): Peg</pre></dt> <dd> same as <code>[a-zA-Z_][a-zA-z_0-9]*</code>; standard identifier   </dd>  <dt><pre data-language="nim">template natural(): Peg</pre></dt> <dd> same as <code>\d+</code>   </dd>  <dt><pre data-language="nim">template eventParser(pegAst, handlers: untyped): (proc (s: string): int)</pre></dt> <dd> Generates an interpreting event parser <em>proc</em> according to the specified PEG AST and handler code blocks. The <em>proc</em> can be called with a string to be parsed and will execute the handler code blocks whenever their associated grammar element is matched. It returns -1 if the string does not match, else the length of the total match. The following example code evaluates an arithmetic expression defined by a simple PEG:<pre class="listing" data-language="nim">import strutils, pegs

let
  pegAst = """
Expr    &lt;- Sum
Sum     &lt;- Product (('+' / '-')Product)*
Product &lt;- Value (('*' / '/')Value)*
Value   &lt;- [0-9]+ / '(' Expr ')'
  """.peg
  txt = "(5+3)/2-7*22"

var
  pStack: seq[string] = @[]
  valStack: seq[float] = @[]
  opStack = ""
let
  parseArithExpr = pegAst.eventParser:
    pkNonTerminal:
      enter:
        pStack.add p.nt.name
      leave:
        pStack.setLen pStack.high
        if length &gt; 0:
          let matchStr = s.substr(start, start+length-1)
          case p.nt.name
          of "Value":
            try:
              valStack.add matchStr.parseFloat
              echo valStack
            except ValueError:
              discard
          of "Sum", "Product":
            try:
              let val = matchStr.parseFloat
            except ValueError:
              if valStack.len &gt; 1 and opStack.len &gt; 0:
                valStack[^2] = case opStack[^1]
                of '+': valStack[^2] + valStack[^1]
                of '-': valStack[^2] - valStack[^1]
                of '*': valStack[^2] * valStack[^1]
                else: valStack[^2] / valStack[^1]
                valStack.setLen valStack.high
                echo valStack
                opStack.setLen opStack.high
                echo opStack
    pkChar:
      leave:
        if length == 1 and "Value" != pStack[^1]:
          let matchChar = s[start]
          opStack.add matchChar
          echo opStack

let pLen = parseArithExpr(txt)</pre>
<p>The <em>handlers</em> parameter consists of code blocks for <em>PegKinds</em>, which define the grammar elements of interest. Each block can contain handler code to be executed when the parser enters and leaves text matching the grammar element. An <em>enter</em> handler can access the specific PEG AST node being matched as <em>p</em>, the entire parsed string as <em>s</em> and the position of the matched text segment in <em>s</em> as <em>start</em>. A <em>leave</em> handler can access <em>p</em>, <em>s</em>, <em>start</em> and also the length of the matched text segment as <em>length</em>. For an unsuccessful match, the <em>enter</em> and <em>leave</em> handlers will be executed, with <em>length</em> set to -1.</p> <p>Symbols declared in an <em>enter</em> handler can be made visible in the corresponding <em>leave</em> handler by annotating them with an <em>inject</em> pragma.</p>   </dd>  <dt><pre data-language="nim">template `=~`(s: string; pattern: Peg): bool</pre></dt> <dd> This calls <code>match</code> with an implicit declared <code>matches</code> array that can be used in the scope of the <code>=~</code> call:<pre class="listing" data-language="nim">if line =~ peg"\s* {\w+} \s* '=' \s* {\w+}":
  # matches a key=value pair:
  echo("Key: ", matches[0])
  echo("Value: ", matches[1])
elif line =~ peg"\s*{'#'.*}":
  # matches a comment
  # note that the implicit ``matches`` array is different from the
  # ``matches`` array of the first branch
  echo("comment: ", matches[0])
else:
  echo("syntax error")</pre>   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2018 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/pegs.html" class="_attribution-link">https://nim-lang.org/docs/pegs.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
