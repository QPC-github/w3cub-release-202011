
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Net - Nim - W3cubDocs</title>
  
  <meta name="description" content="This module implements a high-level cross-platform sockets interface. The procedures implemented in this module are primarily for blocking sockets. &hellip;">
  <meta name="keywords" content="module, net, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nim/net.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/nim.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="title">Module net</h1>  
<p>This module implements a high-level cross-platform sockets interface. The procedures implemented in this module are primarily for blocking sockets. For asynchronous non-blocking sockets use the <code>asyncnet</code> module together with the <code>asyncdispatch</code> module.</p> <p>The first thing you will always need to do in order to start using sockets, is to create a new instance of the <code>Socket</code> type using the <code>newSocket</code> procedure.</p> <h2 id="ssl">SSL</h2>
<p>In order to use the SSL procedures defined in this module, you will need to compile your application with the <code>-d:ssl</code> flag.</p> <h2 id="examples">Examples</h2> <h3 id="examples-connecting-to-a-server">Connecting to a server</h3>
<p>After you create a socket with the <code>newSocket</code> procedure, you can easily connect it to a server running at a known hostname (or IP address) and port. To do so over TCP, use the example below.</p> <pre class="listing" data-language="nim">var socket = newSocket()
socket.connect("google.com", Port(80))</pre>
<p>UDP is a connectionless protocol, so UDP sockets don't have to explicitly call the <code>connect</code> procedure. They can simply start sending data immediately.</p> <pre class="listing" data-language="nim">var socket = newSocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
socket.sendTo("192.168.0.1", Port(27960), "status\n")</pre> <h3 id="examples-creating-a-server">Creating a server</h3>
<p>After you create a socket with the <code>newSocket</code> procedure, you can create a TCP server by calling the <code>bindAddr</code> and <code>listen</code> procedures.</p> <pre class="listing" data-language="nim">var socket = newSocket()
socket.bindAddr(Port(1234))
socket.listen()</pre>
<p>You can then begin accepting connections using the <code>accept</code> procedure.</p> <pre class="listing" data-language="nim">var client: Socket
var address = ""
while true:
  socket.acceptAddr(client, address)
  echo("Client connected from: ", address)</pre>  <h2 id="5">Exports</h2> <dl> <a href="nativesockets#Port"><span class="Identifier">Port</span></a>, <a href="times#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="times#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="times#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="times#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="times#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="nativesockets#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="times#%24"><span class="Identifier">$</span></a>, <a href="system#%24"><span class="Identifier">$</span></a>, <a href="ospaths#%24"><span class="Identifier">$</span></a>, <a href="sets#%24"><span class="Identifier">$</span></a>, <a href="sets#%24"><span class="Identifier">$</span></a>, <a href="options#%24"><span class="Identifier">$</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="options#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="winlean#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="ospaths#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="nativesockets#=="><span class="Identifier">==</span></a>, <a href="times#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="times#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="times#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="times#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="system#=="><span class="Identifier">==</span></a>, <a href="sets#=="><span class="Identifier">==</span></a>, <a href="sets#=="><span class="Identifier">==</span></a>, <a href="nativesockets#Domain"><span class="Identifier">Domain</span></a>, <a href="nativesockets#SockType"><span class="Identifier">SockType</span></a>, <a href="nativesockets#Protocol"><span class="Identifier">Protocol</span></a> </dl>  <h2 id="6">Imports</h2> <dl> <a href="nativesockets">nativesockets</a>, <a href="os">os</a>, <a href="strutils">strutils</a>, <a href="parseutils">parseutils</a>, <a href="times">times</a>, <a href="sets">sets</a>, <a href="options">options</a>, <a href="openssl">openssl</a>, <a href="winlean">winlean</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre>SslError = object of Exception</pre></dt>   <dt><pre data-language="nim">SslCVerifyMode = enum
  CVerifyNone, CVerifyPeer</pre></dt>   <dt><pre data-language="nim">SslProtVersion = enum
  protSSLv2, protSSLv3, protTLSv1, protSSLv23</pre></dt>   <dt><pre data-language="nim">SslContext = ref object
  context*: SslCtx
  referencedData: HashSet[int]
  extraInternal: SslContextExtraInternal</pre></dt>   <dt><pre data-language="nim">SslAcceptResult = enum
  AcceptNoClient = 0, AcceptNoHandshake, AcceptSuccess</pre></dt>   <dt><pre data-language="nim">SslHandshakeType = enum
  handshakeAsClient, handshakeAsServer</pre></dt>   <dt><pre data-language="nim">SslClientGetPskFunc = proc (hint: string): tuple[identity: string, psk: string]</pre></dt>   <dt><pre data-language="nim">SslServerGetPskFunc = proc (identity: string): string</pre></dt>   <dt><pre data-language="nim">SocketImpl = object
  fd: SocketHandle
  case isBuffered: bool
  of true:
      buffer: array[0 .. BufferSize, char]
      currPos: int
      bufLen: int

  of false:
    nil
  when defineSsl:
      case isSsl: bool
      of true:
          sslHandle: SslPtr
          sslContext: SslContext
          sslNoHandshake: bool
          sslHasPeekChar: bool
          sslPeekChar: char

      of false:
        nil
    
  lastError: OSErrorCode       ## stores the last error on this socket
  domain: Domain
  sockType: SockType
  protocol: Protocol</pre></dt> <dd> socket type   </dd>  <dt><pre>Socket = ref SocketImpl</pre></dt>   <dt><pre data-language="nim">SOBool = enum
  OptAcceptConn, OptBroadcast, OptDebug, OptDontRoute, OptKeepAlive, OptOOBInline,
  OptReuseAddr, OptReusePort, OptNoDelay</pre></dt> <dd> Boolean socket options.   </dd>  <dt><pre data-language="nim">ReadLineResult = enum
  ReadFullLine, ReadPartialLine, ReadDisconnected, ReadNone</pre></dt> <dd> result for readLineAsync   </dd>  <dt><pre>TimeoutError = object of Exception</pre></dt>   <dt><pre data-language="nim">SocketFlag {...}{.pure.} = enum
  Peek, SafeDisconn            ## Ensures disconnection exceptions (ECONNRESET, EPIPE etc) are not thrown.</pre></dt>   <dt><pre data-language="nim">IpAddressFamily {...}{.pure.} = enum
  IPv6,                       ## IPv6 address
  IPv4                        ## IPv4 address</pre></dt> <dd> Describes the type of an IP address   </dd>  <dt><pre data-language="nim">IpAddress = object
  case family*: IpAddressFamily ## the type of the IP address (IPv4 or IPv6)
  of IpAddressFamily.IPv6:
      address_v6*: array[0 .. 15, uint8] ## Contains the IP address in bytes in
                                    ## case of IPv6
    
  of IpAddressFamily.IPv4:
      address_v4*: array[0 .. 3, uint8] ## Contains the IP address in bytes in
                                   ## case of IPv4</pre></dt> <dd> stores an arbitrary IP address   </dd> </dl>  <h2 id="10">Consts</h2> <dl>  <dt><pre>BufferSize: int = 4000</pre></dt> <dd> size of a buffered socket's buffer   </dd>  <dt><pre>MaxLineLength = 1000000</pre></dt>  </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre data-language="nim">proc isDisconnectionError(flags: set[SocketFlag]; lastError: OSErrorCode): bool {...}{.
    raises: [], tags: [].}</pre></dt> <dd> Determines whether <code>lastError</code> is a disconnection error. Only does this if flags contains <code>SafeDisconn</code>.   </dd>  <dt><pre data-language="nim">proc toOSFlags(socketFlags: set[SocketFlag]): cint {...}{.raises: [], tags: [].}</pre></dt> <dd> Converts the flags into the underlying OS representation.   </dd>  <dt><pre data-language="nim">proc newSocket(fd: SocketHandle; domain: Domain = AF_INET;
              sockType: SockType = SOCK_STREAM; protocol: Protocol = IPPROTO_TCP;
              buffered = true): Socket {...}{.raises: [], tags: [].}</pre></dt> <dd> Creates a new socket as specified by the params.   </dd>  <dt><pre data-language="nim">proc newSocket(domain, sockType, protocol: cint; buffered = true): Socket {...}{.
    raises: [OSError], tags: [].}</pre></dt> <dd> <p>Creates a new socket.</p> <p>If an error occurs EOS will be raised.</p>   </dd>  <dt><pre data-language="nim">proc newSocket(domain: Domain = AF_INET; sockType: SockType = SOCK_STREAM;
              protocol: Protocol = IPPROTO_TCP; buffered = true): Socket {...}{.
    raises: [OSError], tags: [].}</pre></dt> <dd> <p>Creates a new socket.</p> <p>If an error occurs EOS will be raised.</p>   </dd>  <dt><pre data-language="nim">proc parseIpAddress(addressStr: string): IpAddress {...}{.raises: [ValueError], tags: [].}</pre></dt> <dd> Parses an IP address Raises EInvalidValue on error   </dd>  <dt><pre data-language="nim">proc isIpAddress(addressStr: string): bool {...}{.tags: [], raises: [].}</pre></dt> <dd> Checks if a string is an IP address Returns true if it is, false otherwise   </dd>  <dt><pre data-language="nim">proc toSockAddr(address: IpAddress; port: Port; sa: var Sockaddr_storage;
               sl: var SockLen) {...}{.raises: [], tags: [].}</pre></dt> <dd> Converts <em>IpAddress</em> and <em>Port</em> to <em>SockAddr</em> and <em>Socklen</em>   </dd>  <dt><pre data-language="nim">proc fromSockAddr(sa: Sockaddr_storage | SockAddr | Sockaddr_in | Sockaddr_in6;
                 sl: SockLen; address: var IpAddress; port: var Port) {...}{.inline.}</pre></dt> <dd> Converts <em>SockAddr</em> and <em>Socklen</em> to <em>IpAddress</em> and <em>Port</em>. Raises <em>ObjectConversionError</em> in case of invalid <em>sa</em> and <em>sl</em> arguments.   </dd>  <dt><pre data-language="nim">proc raiseSSLError(s = "") {...}{.raises: [SslError, OSError], tags: [].}</pre></dt> <dd> Raises a new SSL error.   </dd>  <dt><pre data-language="nim">proc getExtraData(ctx: SslContext; index: int): RootRef {...}{.
    raises: [IndexError, SslError, OSError], tags: [].}</pre></dt> <dd> Retrieves arbitrary data stored inside SSLContext.   </dd>  <dt><pre data-language="nim">proc setExtraData(ctx: SslContext; index: int; data: RootRef) {...}{.
    raises: [IndexError, SslError, OSError], tags: [].}</pre></dt> <dd> Stores arbitrary data inside SSLContext. The unique <em>index</em> should be retrieved using getSslContextExtraDataIndex.   </dd>  <dt><pre data-language="nim">proc newContext(protVersion = protSSLv23; verifyMode = CVerifyPeer; certFile = "";
               keyFile = ""; cipherList = "ALL"): SslContext {...}{.
    raises: [Exception, SslError, OSError, IOError],
    tags: [RootEffect, ReadDirEffect].}</pre></dt> <dd> <p>Creates an SSL context.</p> <p>Protocol version specifies the protocol to use. SSLv2, SSLv3, TLSv1 are available with the addition of <code>protSSLv23</code> which allows for compatibility with all of them.</p> <p>There are currently only two options for verify mode; one is <code>CVerifyNone</code> and with it certificates will not be verified the other is <code>CVerifyPeer</code> and certificates will be verified for it, <code>CVerifyPeer</code> is the safest choice.</p> <p>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these. Certificates can be generated using the following command: <code>openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem</code>.</p>   </dd>  <dt><pre data-language="nim">proc destroyContext(ctx: SslContext) {...}{.raises: [IndexError, SslError, OSError],
                                    tags: [].}</pre></dt> <dd> Free memory referenced by SSLContext.   </dd>  <dt><pre data-language="nim">proc pskIdentityHint=(ctx: SslContext; hint: string) {...}{.raises: [SslError, OSError],
    tags: [].}</pre></dt> <dd> <p>Sets the identity hint passed to server.</p> <p>Only used in PSK ciphersuites.</p>   </dd>  <dt><pre data-language="nim">proc clientGetPskFunc(ctx: SslContext): SslClientGetPskFunc {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc clientGetPskFunc=(ctx: SslContext; fun: SslClientGetPskFunc) {...}{.
    raises: [Exception], tags: [RootEffect].}</pre></dt> <dd> <p>Sets function that returns the client identity and the PSK based on identity hint from the server.</p> <p>Only used in PSK ciphersuites.</p>   </dd>  <dt><pre data-language="nim">proc serverGetPskFunc(ctx: SslContext): SslServerGetPskFunc {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc serverGetPskFunc=(ctx: SslContext; fun: SslServerGetPskFunc) {...}{.
    raises: [Exception], tags: [RootEffect].}</pre></dt> <dd> <p>Sets function that returns PSK based on the client identity.</p> <p>Only used in PSK ciphersuites.</p>   </dd>  <dt><pre data-language="nim">proc getPskIdentity(socket: Socket): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Gets the PSK identity provided by the client.   </dd>  <dt><pre data-language="nim">proc wrapSocket(ctx: SslContext; socket: Socket) {...}{.raises: [SslError, OSError], tags: [].}</pre></dt> <dd> <p>Wraps a socket in an SSL context. This function effectively turns <code>socket</code> into an SSL socket.</p> <p>This must be called on an unconnected socket; an SSL session will be started when the socket is connected.</p> <p><strong>Disclaimer</strong>: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</p>   </dd>  <dt><pre data-language="nim">proc wrapConnectedSocket(ctx: SslContext; socket: Socket;
                        handshake: SslHandshakeType; hostname: string = "") {...}{.
    raises: [SslError, OSError, Exception], tags: [RootEffect].}</pre></dt> <dd> <p>Wraps a connected socket in an SSL context. This function effectively turns <code>socket</code> into an SSL socket. <code>hostname</code> should be specified so that the client knows which hostname the server certificate should be validated against.</p> <p>This should be called on a connected socket, and will perform an SSL handshake immediately.</p> <p><strong>Disclaimer</strong>: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</p>   </dd>  <dt><pre data-language="nim">proc getSocketError(socket: Socket): OSErrorCode {...}{.raises: [OSError], tags: [].}</pre></dt> <dd> Checks <code>osLastError</code> for a valid error. If it has been reset it uses the last error stored in the socket object.   </dd>  <dt><pre data-language="nim">proc socketError(socket: Socket; err: int = -1; async = false; lastError = -1.OSErrorCode): void {...}{.
    gcsafe, raises: [SslError, OSError], tags: [].}</pre></dt> <dd> <p>Raises an OSError based on the error code returned by <code>SSLGetError</code> (for SSL sockets) and <code>osLastError</code> otherwise.</p> <p>If <code>async</code> is <code>true</code> no error will be thrown in the case when the error was caused by no data being available to be read.</p> <p>If <code>err</code> is not lower than 0 no exception will be raised.</p>   </dd>  <dt><pre data-language="nim">proc listen(socket: Socket; backlog = SOMAXCONN) {...}{.tags: [ReadIOEffect],
    raises: [OSError].}</pre></dt> <dd> <p>Marks <code>socket</code> as accepting connections. <code>Backlog</code> specifies the maximum length of the queue of pending connections.</p> <p>Raises an EOS error upon failure.</p>   </dd>  <dt><pre data-language="nim">proc bindAddr(socket: Socket; port = Port(0); address = "") {...}{.tags: [ReadIOEffect],
    raises: [OSError].}</pre></dt> <dd> <p>Binds <code>address</code>:<code>port</code> to the socket.</p> <p>If <code>address</code> is "" then ADDR_ANY will be bound.</p>   </dd>  <dt><pre data-language="nim">proc acceptAddr(server: Socket; client: var Socket; address: var string;
               flags = {SafeDisconn}) {...}{.tags: [ReadIOEffect], gcsafe, locks: 0,
                                     raises: [OSError, IOError, SslError].}</pre></dt> <dd> <p>Blocks until a connection is being made from a client. When a connection is made sets <code>client</code> to the client socket and <code>address</code> to the address of the connecting client. This function will raise EOS if an error occurs.</p> <p>The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.</p> <p>The <code>accept</code> call may result in an error if the connecting socket disconnects during the duration of the <code>accept</code>. If the <code>SafeDisconn</code> flag is specified then this error will not be raised and instead accept will be called again.</p>   </dd>  <dt><pre data-language="nim">proc accept(server: Socket; client: var Socket; flags = {SafeDisconn}) {...}{.
    tags: [ReadIOEffect], raises: [OSError, IOError, SslError].}</pre></dt> <dd> <p>Equivalent to <code>acceptAddr</code> but doesn't return the address, only the socket.</p> <p>The <code>accept</code> call may result in an error if the connecting socket disconnects during the duration of the <code>accept</code>. If the <code>SafeDisconn</code> flag is specified then this error will not be raised and instead accept will be called again.</p>   </dd>  <dt><pre data-language="nim">proc close(socket: Socket) {...}{.raises: [SslError, OSError], tags: [].}</pre></dt> <dd> Closes a socket.   </dd>  <dt><pre data-language="nim">proc toCInt(opt: SOBool): cint {...}{.raises: [], tags: [].}</pre></dt> <dd> Converts a <code>SOBool</code> into its Socket Option cint representation.   </dd>  <dt><pre data-language="nim">proc getSockOpt(socket: Socket; opt: SOBool; level = SOL_SOCKET): bool {...}{.
    tags: [ReadIOEffect], raises: [OSError].}</pre></dt> <dd> Retrieves option <code>opt</code> as a boolean value.   </dd>  <dt><pre data-language="nim">proc getLocalAddr(socket: Socket): (string, Port) {...}{.raises: [OSError, Exception],
    tags: [RootEffect].}</pre></dt> <dd> <p>Get the socket's local address and port number.</p> <p>This is high-level interface for <span id="getsockname_1">getsockname</span>.</p>   </dd>  <dt><pre data-language="nim">proc getPeerAddr(socket: Socket): (string, Port) {...}{.raises: [OSError, Exception],
    tags: [RootEffect].}</pre></dt> <dd> <p>Get the socket's peer address and port number.</p> <p>This is high-level interface for <span id="getpeername_1">getpeername</span>.</p>   </dd>  <dt><pre data-language="nim">proc setSockOpt(socket: Socket; opt: SOBool; value: bool; level = SOL_SOCKET) {...}{.
    tags: [WriteIOEffect], raises: [OSError].}</pre></dt> <dd> Sets option <code>opt</code> to a boolean value specified by <code>value</code>.<pre class="listing" data-language="nim">var socket = newSocket()
socket.setSockOpt(OptReusePort, true)
socket.setSockOpt(OptNoDelay, true, level=IPPROTO_TCP.toInt)</pre>   </dd>  <dt><pre data-language="nim">proc connectUnix(socket: Socket; path: string) {...}{.raises: [], tags: [].}</pre></dt> <dd> Connects to Unix socket on <em>path</em>. This only works on Unix-style systems: Mac OS X, BSD and Linux   </dd>  <dt><pre data-language="nim">proc bindUnix(socket: Socket; path: string) {...}{.raises: [], tags: [].}</pre></dt> <dd> Binds Unix socket to <em>path</em>. This only works on Unix-style systems: Mac OS X, BSD and Linux   </dd>  <dt><pre data-language="nim">proc hasDataBuffered(s: Socket): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Determines whether a socket has data buffered.   </dd>  <dt><pre data-language="nim">proc recv(socket: Socket; data: pointer; size: int): int {...}{.tags: [ReadIOEffect],
    raises: [].}</pre></dt> <dd> <p>Receives data from a socket.</p> <p><strong>Note</strong>: This is a low-level function, you may be interested in the higher level versions of this function which are also named <code>recv</code>.</p>   </dd>  <dt><pre data-language="nim">proc recv(socket: Socket; data: pointer; size: int; timeout: int): int {...}{.
    tags: [ReadIOEffect, TimeEffect], raises: [TimeoutError, OSError].}</pre></dt> <dd> overload with a <code>timeout</code> parameter in milliseconds.   </dd>  <dt><pre data-language="nim">proc recv(socket: Socket; data: var string; size: int; timeout = -1; flags = {SafeDisconn}): int {...}{.
    raises: [TimeoutError, OSError, SslError], tags: [ReadIOEffect, TimeEffect].}</pre></dt> <dd> <p>Higher-level version of <code>recv</code>.</p> <p>When 0 is returned the socket's connection has been closed.</p> <p>This function will throw an OSError exception when an error occurs. A value lower than 0 is never returned.</p> <p>A timeout may be specified in milliseconds, if enough data is not received within the time specified an TimeoutError exception will be raised.</p> <p><strong>Note</strong>: <code>data</code> must be initialised.</p> <p><strong>Warning</strong>: Only the <code>SafeDisconn</code> flag is currently supported.</p>   </dd>  <dt><pre data-language="nim">proc recv(socket: Socket; size: int; timeout = -1; flags = {SafeDisconn}): string {...}{.inline,
    raises: [TimeoutError, OSError, SslError], tags: [ReadIOEffect, TimeEffect].}</pre></dt> <dd> <p>Higher-level version of <code>recv</code> which returns a string.</p> <p>When <code>""</code> is returned the socket's connection has been closed.</p> <p>This function will throw an EOS exception when an error occurs.</p> <p>A timeout may be specified in milliseconds, if enough data is not received within the time specified an ETimeout exception will be raised.</p> <p><strong>Warning</strong>: Only the <code>SafeDisconn</code> flag is currently supported.</p>   </dd>  <dt><pre data-language="nim">proc readLine(socket: Socket; line: var TaintedString; timeout = -1;
             flags = {SafeDisconn}; maxLength = MaxLineLength) {...}{.
    tags: [ReadIOEffect, TimeEffect], raises: [TimeoutError, OSError, SslError].}</pre></dt> <dd> <p>Reads a line of data from <code>socket</code>.</p> <p>If a full line is read <code>\r\L</code> is not added to <code>line</code>, however if solely <code>\r\L</code> is read then <code>line</code> will be set to it.</p> <p>If the socket is disconnected, <code>line</code> will be set to <code>""</code>.</p> <p>An EOS exception will be raised in the case of a socket error.</p> <p>A timeout can be specified in milliseconds, if data is not received within the specified time an ETimeout exception will be raised.</p> <p>The <code>maxLength</code> parameter determines the maximum amount of characters that can be read. The result is truncated after that.</p> <p><strong>Warning</strong>: Only the <code>SafeDisconn</code> flag is currently supported.</p>   </dd>  <dt><pre data-language="nim">proc recvLine(socket: Socket; timeout = -1; flags = {SafeDisconn};
             maxLength = MaxLineLength): TaintedString {...}{.
    raises: [TimeoutError, OSError, SslError], tags: [ReadIOEffect, TimeEffect].}</pre></dt> <dd> <p>Reads a line of data from <code>socket</code>.</p> <p>If a full line is read <code>\r\L</code> is not added to the result, however if solely <code>\r\L</code> is read then the result will be set to it.</p> <p>If the socket is disconnected, the result will be set to <code>""</code>.</p> <p>An EOS exception will be raised in the case of a socket error.</p> <p>A timeout can be specified in milliseconds, if data is not received within the specified time an ETimeout exception will be raised.</p> <p>The <code>maxLength</code> parameter determines the maximum amount of characters that can be read. The result is truncated after that.</p> <p><strong>Warning</strong>: Only the <code>SafeDisconn</code> flag is currently supported.</p>   </dd>  <dt><pre data-language="nim">proc recvFrom(socket: Socket; data: var string; length: int; address: var string;
             port: var Port; flags = 0'i32): int {...}{.tags: [ReadIOEffect],
    raises: [OSError].}</pre></dt> <dd> <p>Receives data from <code>socket</code>. This function should normally be used with connection-less sockets (UDP sockets).</p> <p>If an error occurs an EOS exception will be raised. Otherwise the return value will be the length of data received.</p> <p><strong>Warning:</strong> This function does not yet have a buffered implementation, so when <code>socket</code> is buffered the non-buffered implementation will be used. Therefore if <code>socket</code> contains something in its buffer this function will make no effort to return it.</p>   </dd>  <dt><pre data-language="nim">proc skip(socket: Socket; size: int; timeout = -1) {...}{.
    raises: [Exception, TimeoutError, OSError], tags: [TimeEffect, ReadIOEffect].}</pre></dt> <dd> <p>Skips <code>size</code> amount of bytes.</p> <p>An optional timeout can be specified in milliseconds, if skipping the bytes takes longer than specified an ETimeout exception will be raised.</p> <p>Returns the number of skipped bytes.</p>   </dd>  <dt><pre data-language="nim">proc send(socket: Socket; data: pointer; size: int): int {...}{.tags: [WriteIOEffect],
    raises: [].}</pre></dt> <dd> <p>Sends data to a socket.</p> <p><strong>Note</strong>: This is a low-level version of <code>send</code>. You likely should use the version below.</p>   </dd>  <dt><pre data-language="nim">proc send(socket: Socket; data: string; flags = {SafeDisconn}) {...}{.tags: [WriteIOEffect],
    raises: [SslError, OSError].}</pre></dt> <dd> sends data to a socket.   </dd>  <dt><pre data-language="nim">proc trySend(socket: Socket; data: string): bool {...}{.tags: [WriteIOEffect], raises: [].}</pre></dt> <dd> Safe alternative to <code>send</code>. Does not raise an EOS when an error occurs, and instead returns <code>false</code> on failure.   </dd>  <dt><pre data-language="nim">proc sendTo(socket: Socket; address: string; port: Port; data: pointer; size: int;
           af: Domain = AF_INET; flags = 0'i32) {...}{.tags: [WriteIOEffect],
    raises: [OSError].}</pre></dt> <dd> <p>This proc sends <code>data</code> to the specified <code>address</code>, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.</p> <p>If an error occurs an OSError exception will be raised.</p> <p><strong>Note:</strong> You may wish to use the high-level version of this function which is defined below.</p> <p><strong>Note:</strong> This proc is not available for SSL sockets.</p>   </dd>  <dt><pre data-language="nim">proc sendTo(socket: Socket; address: string; port: Port; data: string) {...}{.
    tags: [WriteIOEffect], raises: [OSError].}</pre></dt> <dd> <p>This proc sends <code>data</code> to the specified <code>address</code>, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.</p> <p>If an error occurs an OSError exception will be raised.</p> <p>This is the high-level version of the above <code>sendTo</code> function.</p>   </dd>  <dt><pre data-language="nim">proc isSsl(socket: Socket): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Determines whether <code>socket</code> is a SSL socket.   </dd>  <dt><pre data-language="nim">proc getFd(socket: Socket): SocketHandle {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the socket's file descriptor   </dd>  <dt><pre data-language="nim">proc IPv4_any(): IpAddress {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the IPv4 any address, which can be used to listen on all available network adapters   </dd>  <dt><pre data-language="nim">proc IPv4_loopback(): IpAddress {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the IPv4 loopback address (127.0.0.1)   </dd>  <dt><pre data-language="nim">proc IPv4_broadcast(): IpAddress {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the IPv4 broadcast address (255.255.255.255)   </dd>  <dt><pre data-language="nim">proc IPv6_any(): IpAddress {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the IPv6 any address (::0), which can be used to listen on all available network adapters   </dd>  <dt><pre data-language="nim">proc IPv6_loopback(): IpAddress {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the IPv6 loopback address (::1)   </dd>  <dt><pre data-language="nim">proc `==`(lhs, rhs: IpAddress): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Compares two IpAddresses for Equality. Returns true if the addresses are equal   </dd>  <dt><pre data-language="nim">proc `$`(address: IpAddress): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Converts an IpAddress into the textual representation   </dd>  <dt><pre data-language="nim">proc dial(address: string; port: Port; protocol = IPPROTO_TCP; buffered = true): Socket {...}{.
    tags: [ReadIOEffect, WriteIOEffect], raises: [OSError, IOError].}</pre></dt> <dd> Establishes connection to the specified <code>address</code>:<code>port</code> pair via the specified protocol. The procedure iterates through possible resolutions of the <code>address</code> until it succeeds, meaning that it seamlessly works with both IPv4 and IPv6. Returns Socket ready to send or receive data.   </dd>  <dt><pre data-language="nim">proc connect(socket: Socket; address: string; port = Port(0)) {...}{.tags: [ReadIOEffect],
    raises: [OSError, SslError].}</pre></dt> <dd> <p>Connects socket to <code>address</code>:<code>port</code>. <code>Address</code> can be an IP address or a host name. If <code>address</code> is a host name, this function will try each IP of that host name. <code>htons</code> is already performed on <code>port</code> so you must not do it.</p> <p>If <code>socket</code> is an SSL socket a handshake will be automatically performed.</p>   </dd>  <dt><pre data-language="nim">proc connect(socket: Socket; address: string; port = Port(0); timeout: int) {...}{.
    tags: [ReadIOEffect, WriteIOEffect], raises: [OSError, TimeoutError].}</pre></dt> <dd> <p>Connects to server as specified by <code>address</code> on port specified by <code>port</code>.</p> <p>The <code>timeout</code> paremeter specifies the time in milliseconds to allow for the connection to the server to be made.</p>   </dd> </dl>  <h2 id="18">Templates</h2> <dl>  <dt><pre data-language="nim">template `&amp;=`(socket: Socket; data: typed)</pre></dt> <dd> an alias for 'send'.   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2018 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/net.html" class="_attribution-link">https://nim-lang.org/docs/net.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
