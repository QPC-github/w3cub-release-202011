
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Json - Nim - W3cubDocs</title>
  
  <meta name="description" content="This module implements a simple high performance JSON parser. JSON (JavaScript Object Notation) is a lightweight data-interchange format that is &hellip;">
  <meta name="keywords" content="module, json, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nim/json.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/nim.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="title">Module json</h1>  <p class="module-desc">This module implements a simple high performance <span id="json_1">JSON</span> parser. JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write (unlike XML). It is easy for machines to parse and generate. JSON is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999. </p>
<h2 id="dynamically-retrieving-fields-from-json">Dynamically retrieving fields from JSON</h2>
<p>This module allows you to access fields in a parsed JSON object in two different ways, one of them is described in this section.</p> <p>The <code>parseJson</code> procedure takes a string containing JSON and returns a <code>JsonNode</code> object. This is an object variant and it is either a <code>JObject</code>, <code>JArray</code>, <code>JString</code>, <code>JInt</code>, <code>JFloat</code>, <code>JBool</code> or <code>JNull</code>. You check the kind of this object variant by using the <code>kind</code> accessor.</p> <p>For a <code>JsonNode</code> who's kind is <code>JObject</code>, you can acess its fields using the <code>[]</code> operator. The following example shows how to do this:</p> <pre class="listing" data-language="nim">let jsonNode = parseJson("""{"key": 3.14}""")
doAssert jsonNode.kind == JObject
doAssert jsonNode["key"].kind == JFloat</pre>
<p>Retrieving the value of a JSON node can then be achieved using one of the helper procedures, which include:</p> <ul class="simple">
<li><code>getInt</code></li> <li><code>getFloat</code></li> <li><code>getStr</code></li> <li><code>getBool</code></li> </ul> <p>To retrieve the value of <code>"key"</code> you can do the following:</p> <pre class="listing" data-language="nim">doAssert jsonNode["key"].getFloat() == 3.14</pre>
<p>The <code>[]</code> operator will raise an exception when the specified field does not exist. If you wish to avoid this behaviour you can use the <code>{}</code> operator instead, it will simply return <code>nil</code> when the field is not found. The <code>get</code>-family of procedures will return a default value when called on <code>nil</code>.</p> <h2 id="unmarshalling-json-into-a-type">Unmarshalling JSON into a type</h2>
<p>This module allows you to access fields in a parsed JSON object in two different ways, one of them is described in this section.</p> <p>This is done using the <code>to</code> macro. Take a look at <a href="#to.m,JsonNode,typedesc">its documentation</a> to see an example of its use.</p> <h2 id="creating-json">Creating JSON</h2>
<p>This module can also be used to comfortably create JSON using the <em>%*</em> operator:</p> <pre class="listing" data-language="nim">var hisName = "John"
let herAge = 31
var j = %*
  [
    {
      "name": hisName,
      "age": 30
    },
    {
      "name": "Susan",
      "age": herAge
    }
  ]
 
 var j2 = %* {"name": "Isaac", "books": ["Robot Dreams"]}
 j2["details"] = %* {"age":35, "pi":3.1415}
 echo j2</pre>  <h2 id="5">Exports</h2> <dl> <a href="tables#%24"><span class="Identifier">$</span></a>, <a href="tables#%24"><span class="Identifier">$</span></a>, <a href="tables#%24"><span class="Identifier">$</span></a>, <a href="tables#%24"><span class="Identifier">$</span></a>, <a href="tables#%24"><span class="Identifier">$</span></a>, <a href="tables#%24"><span class="Identifier">$</span></a>, <a href="parsejson#JsonEventKind"><span class="Identifier">JsonEventKind</span></a>, <a href="parsejson#JsonError"><span class="Identifier">JsonError</span></a>, <a href="parsejson#JsonParser"><span class="Identifier">JsonParser</span></a>, <a href="parsejson#JsonKindError"><span class="Identifier">JsonKindError</span></a>, <a href="system#open"><span class="Identifier">open</span></a>, <a href="system#open"><span class="Identifier">open</span></a>, <a href="lexbase#open"><span class="Identifier">open</span></a>, <a href="system#open"><span class="Identifier">open</span></a>, <a href="parsejson#open"><span class="Identifier">open</span></a>, <a href="streams#close"><span class="Identifier">close</span></a>, <a href="streams#close"><span class="Identifier">close</span></a>, <a href="lexbase#close"><span class="Identifier">close</span></a>, <a href="system#close"><span class="Identifier">close</span></a>, <a href="parsejson#close"><span class="Identifier">close</span></a>, <a href="parsejson#str"><span class="Identifier">str</span></a>, <a href="parsejson#getInt"><span class="Identifier">getInt</span></a>, <a href="parsejson#getFloat"><span class="Identifier">getFloat</span></a>, <a href="macros#kind"><span class="Identifier">kind</span></a>, <a href="parsejson#kind"><span class="Identifier">kind</span></a>, <a href="parsejson#getColumn"><span class="Identifier">getColumn</span></a>, <a href="parsejson#getLine"><span class="Identifier">getLine</span></a>, <a href="parsejson#getFilename"><span class="Identifier">getFilename</span></a>, <a href="parsejson#errorMsg"><span class="Identifier">errorMsg</span></a>, <a href="parsejson#errorMsgExpected"><span class="Identifier">errorMsgExpected</span></a>, <a href="parsejson#next"><span class="Identifier">next</span></a>, <a href="parsejson#JsonParsingError"><span class="Identifier">JsonParsingError</span></a>, <a href="parsejson#raiseParseErr"><span class="Identifier">raiseParseErr</span></a> </dl>  <h2 id="6">Imports</h2> <dl> <a href="hashes">hashes</a>, <a href="tables">tables</a>, <a href="strutils">strutils</a>, <a href="lexbase">lexbase</a>, <a href="streams">streams</a>, <a href="unicode">unicode</a>, <a href="macros">macros</a>, <a href="parsejson">parsejson</a>, <a href="options">options</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre data-language="nim">JsonNodeKind = enum
  JNull, JBool, JInt, JFloat, JString, JObject, JArray</pre></dt> <dd> possible JSON node types   </dd>  <dt><pre>JsonNode = ref JsonNodeObj</pre></dt> <dd> JSON node   </dd>  <dt><pre data-language="nim">JsonNodeObj {...}{.acyclic.} = object
  case kind*: JsonNodeKind
  of JString:
      str*: string

  of JInt:
      num*: BiggestInt

  of JFloat:
      fnum*: float

  of JBool:
      bval*: bool

  of JNull:
      nil

  of JObject:
      fields*: OrderedTable[string, JsonNode]

  of JArray:
      elems*: seq[JsonNode]</pre></dt>  </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre data-language="nim">proc newJString(s: string): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Creates a new <em>JString JsonNode</em>.   </dd>  <dt><pre data-language="nim">proc newJInt(n: BiggestInt): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Creates a new <em>JInt JsonNode</em>.   </dd>  <dt><pre data-language="nim">proc newJFloat(n: float): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Creates a new <em>JFloat JsonNode</em>.   </dd>  <dt><pre data-language="nim">proc newJBool(b: bool): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Creates a new <em>JBool JsonNode</em>.   </dd>  <dt><pre data-language="nim">proc newJNull(): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Creates a new <em>JNull JsonNode</em>.   </dd>  <dt><pre data-language="nim">proc newJObject(): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Creates a new <em>JObject JsonNode</em>   </dd>  <dt><pre data-language="nim">proc newJArray(): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Creates a new <em>JArray JsonNode</em>   </dd>  <dt><pre data-language="nim">proc getStr(n: JsonNode; default: string = ""): string {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Retrieves the string value of a <em>JString JsonNode</em>.</p> <p>Returns <code>default</code> if <code>n</code> is not a <code>JString</code>, or if <code>n</code> is nil.</p>   </dd>  <dt><pre data-language="nim">proc getInt(n: JsonNode; default: int = 0): int {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Retrieves the int value of a <em>JInt JsonNode</em>.</p> <p>Returns <code>default</code> if <code>n</code> is not a <code>JInt</code>, or if <code>n</code> is nil.</p>   </dd>  <dt><pre data-language="nim">proc getBiggestInt(n: JsonNode; default: BiggestInt = 0): BiggestInt {...}{.raises: [],
    tags: [].}</pre></dt> <dd> <p>Retrieves the BiggestInt value of a <em>JInt JsonNode</em>.</p> <p>Returns <code>default</code> if <code>n</code> is not a <code>JInt</code>, or if <code>n</code> is nil.</p>   </dd>  <dt><pre data-language="nim">proc getNum(n: JsonNode; default: BiggestInt = 0): BiggestInt {...}{.
    deprecated: "use getInt or getBiggestInt instead", raises: [], tags: [].}</pre></dt> <dd> <strong>Deprecated since v0.18.2:</strong> use <code>getInt</code> or <code>getBiggestInt</code> instead.   </dd>  <dt><pre data-language="nim">proc getFloat(n: JsonNode; default: float = 0.0): float {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Retrieves the float value of a <em>JFloat JsonNode</em>.</p> <p>Returns <code>default</code> if <code>n</code> is not a <code>JFloat</code> or <code>JInt</code>, or if <code>n</code> is nil.</p>   </dd>  <dt><pre data-language="nim">proc getFNum(n: JsonNode; default: float = 0.0): float {...}{.
    deprecated: "use getFloat instead", raises: [], tags: [].}</pre></dt> <dd> <strong>Deprecated since v0.18.2:</strong> use <code>getFloat</code> instead.   </dd>  <dt><pre data-language="nim">proc getBool(n: JsonNode; default: bool = false): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Retrieves the bool value of a <em>JBool JsonNode</em>.</p> <p>Returns <code>default</code> if <code>n</code> is not a <code>JBool</code>, or if <code>n</code> is nil.</p>   </dd>  <dt><pre data-language="nim">proc getBVal(n: JsonNode; default: bool = false): bool {...}{.
    deprecated: "use getBool instead", raises: [], tags: [].}</pre></dt> <dd> <strong>Deprecated since v0.18.2:</strong> use <code>getBool</code> instead.   </dd>  <dt><pre data-language="nim">proc getFields(n: JsonNode; default = initOrderedTable(4)): OrderedTable[string,
    JsonNode] {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Retrieves the key, value pairs of a <em>JObject JsonNode</em>.</p> <p>Returns <code>default</code> if <code>n</code> is not a <code>JObject</code>, or if <code>n</code> is nil.</p>   </dd>  <dt><pre data-language="nim">proc getElems(n: JsonNode; default: seq[JsonNode] = @[]): seq[JsonNode] {...}{.raises: [],
    tags: [].}</pre></dt> <dd> <p>Retrieves the array of a <em>JArray JsonNode</em>.</p> <p>Returns <code>default</code> if <code>n</code> is not a <code>JArray</code>, or if <code>n</code> is nil.</p>   </dd>  <dt><pre data-language="nim">proc add(father, child: JsonNode) {...}{.raises: [], tags: [].}</pre></dt> <dd> Adds <em>child</em> to a JArray node <em>father</em>.   </dd>  <dt><pre data-language="nim">proc add(obj: JsonNode; key: string; val: JsonNode) {...}{.raises: [], tags: [].}</pre></dt> <dd> Sets a field from a <em>JObject</em>.   </dd>  <dt><pre data-language="nim">proc `%`(s: string): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Generic constructor for JSON data. Creates a new <em>JString JsonNode</em>.   </dd>  <dt><pre data-language="nim">proc `%`(n: BiggestInt): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Generic constructor for JSON data. Creates a new <em>JInt JsonNode</em>.   </dd>  <dt><pre data-language="nim">proc `%`(n: float): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Generic constructor for JSON data. Creates a new <em>JFloat JsonNode</em>.   </dd>  <dt><pre data-language="nim">proc `%`(b: bool): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Generic constructor for JSON data. Creates a new <em>JBool JsonNode</em>.   </dd>  <dt><pre data-language="nim">proc `%`(keyVals: openArray[tuple[key: string, val: JsonNode]]): JsonNode {...}{.raises: [],
    tags: [].}</pre></dt> <dd> Generic constructor for JSON data. Creates a new <em>JObject JsonNode</em>   </dd>  <dt><pre data-language="nim">proc `%`[T](elements: openArray[T]): JsonNode</pre></dt> <dd> Generic constructor for JSON data. Creates a new <em>JArray JsonNode</em>   </dd>  <dt><pre data-language="nim">proc `%`(o: object): JsonNode</pre></dt> <dd> Generic constructor for JSON data. Creates a new <em>JObject JsonNode</em>   </dd>  <dt><pre data-language="nim">proc `%`(o: ref object): JsonNode</pre></dt> <dd> Generic constructor for JSON data. Creates a new <em>JObject JsonNode</em>   </dd>  <dt><pre data-language="nim">proc `%`(o: enum): JsonNode</pre></dt> <dd> Construct a JsonNode that represents the specified enum value as a string. Creates a new <code>JString JsonNode</code>.   </dd>  <dt><pre data-language="nim">proc `==`(a, b: JsonNode): bool {...}{.raises: [KeyError], tags: [].}</pre></dt> <dd> Check two nodes for equality   </dd>  <dt><pre data-language="nim">proc hash(n: JsonNode): Hash {...}{.raises: [Exception], tags: [RootEffect].}</pre></dt> <dd> Compute the hash for a JSON node   </dd>  <dt><pre data-language="nim">proc hash(n: OrderedTable[string, JsonNode]): Hash {...}{.noSideEffect,
    raises: [Exception], tags: [RootEffect].}</pre></dt> <dd> iterates over any (key, value) pair in the table <em>t</em> in insertion order.   </dd>  <dt><pre data-language="nim">proc len(n: JsonNode): int {...}{.raises: [], tags: [].}</pre></dt> <dd> If <em>n</em> is a <em>JArray</em>, it returns the number of elements. If <em>n</em> is a <em>JObject</em>, it returns the number of pairs. Else it returns 0.   </dd>  <dt><pre data-language="nim">proc `[]`(node: JsonNode; name: string): JsonNode {...}{.inline, raises: [KeyError], tags: [].}</pre></dt> <dd> <p>Gets a field from a <em>JObject</em>, which must not be nil. If the value at <em>name</em> does not exist, raises KeyError.</p> <p><strong>Note:</strong> The behaviour of this procedure changed in version 0.14.0. To get a list of usages and to restore the old behaviour of this procedure, compile with the <code>-d:nimJsonGet</code> flag.</p>   </dd>  <dt><pre data-language="nim">proc `[]`(node: JsonNode; index: int): JsonNode {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Gets the node at <em>index</em> in an Array. Result is undefined if <em>index</em> is out of bounds, but as long as array bound checks are enabled it will result in an exception.   </dd>  <dt><pre data-language="nim">proc hasKey(node: JsonNode; key: string): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Checks if <em>key</em> exists in <em>node</em>.   </dd>  <dt><pre data-language="nim">proc contains(node: JsonNode; key: string): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Checks if <em>key</em> exists in <em>node</em>.   </dd>  <dt><pre data-language="nim">proc contains(node: JsonNode; val: JsonNode): bool {...}{.raises: [KeyError], tags: [].}</pre></dt> <dd> Checks if <em>val</em> exists in array <em>node</em>.   </dd>  <dt><pre data-language="nim">proc existsKey(node: JsonNode; key: string): bool {...}{.deprecated: "use hasKey instead",
    raises: [], tags: [].}</pre></dt> <dd> <strong>Deprecated:</strong> use <em>hasKey</em> instead.   </dd>  <dt><pre data-language="nim">proc `[]=`(obj: JsonNode; key: string; val: JsonNode) {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Sets a field from a <em>JObject</em>.   </dd>  <dt><pre data-language="nim">proc `{}`(node: JsonNode; keys: varargs[string]): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Traverses the node and gets the given value. If any of the keys do not exist, returns <code>nil</code>. Also returns <code>nil</code> if one of the intermediate data structures is not an object.</p> <p>This proc can be used to create tree structures on the fly (sometimes called <span id="autovivification_1">autovivification</span>):</p> <pre class="listing" data-language="nim">myjson{"parent", "child", "grandchild"} = newJInt(1)</pre>   </dd>  <dt><pre data-language="nim">proc `{}`(node: JsonNode; index: varargs[int]): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Traverses the node and gets the given value. If any of the indexes do not exist, returns <code>nil</code>. Also returns <code>nil</code> if one of the intermediate data structures is not an array.   </dd>  <dt><pre data-language="nim">proc getOrDefault(node: JsonNode; key: string): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Gets a field from a <em>node</em>. If <em>node</em> is nil or not an object or value at <em>key</em> does not exist, returns nil   </dd>  <dt><pre data-language="nim">proc `{}=`(node: JsonNode; keys: varargs[string]; value: JsonNode) {...}{.
    raises: [KeyError], tags: [].}</pre></dt> <dd> Traverses the node and tries to set the value at the given location to <code>value</code>. If any of the keys are missing, they are added.   </dd>  <dt><pre data-language="nim">proc delete(obj: JsonNode; key: string) {...}{.raises: [KeyError], tags: [].}</pre></dt> <dd> Deletes <code>obj[key]</code>.   </dd>  <dt><pre data-language="nim">proc copy(p: JsonNode): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Performs a deep copy of <em>a</em>.   </dd>  <dt><pre data-language="nim">proc escapeJsonUnquoted(s: string; result: var string) {...}{.raises: [], tags: [].}</pre></dt> <dd> Converts a string <em>s</em> to its JSON representation without quotes. Appends to <code>result</code>.   </dd>  <dt><pre data-language="nim">proc escapeJsonUnquoted(s: string): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Converts a string <em>s</em> to its JSON representation without quotes.   </dd>  <dt><pre data-language="nim">proc escapeJson(s: string; result: var string) {...}{.raises: [], tags: [].}</pre></dt> <dd> Converts a string <em>s</em> to its JSON representation with quotes. Appends to <code>result</code>.   </dd>  <dt><pre data-language="nim">proc escapeJson(s: string): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Converts a string <em>s</em> to its JSON representation with quotes.   </dd>  <dt><pre data-language="nim">proc pretty(node: JsonNode; indent = 2): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns a JSON Representation of <em>node</em>, with indentation and on multiple lines.   </dd>  <dt><pre data-language="nim">proc toUgly(result: var string; node: JsonNode) {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>node</em> to its JSON Representation, without regard for human readability. Meant to improve <code>$</code> string conversion performance.</p> <p>JSON representation is stored in the passed <em>result</em></p> <p>This provides higher efficiency than the <code>pretty</code> procedure as it does <strong>not</strong> attempt to format the resulting JSON to make it human readable.</p>   </dd>  <dt><pre data-language="nim">proc `$`(node: JsonNode): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Converts <em>node</em> to its JSON Representation on one line.   </dd>  <dt><pre data-language="nim">proc parseJson(s: Stream; filename: string = ""): JsonNode {...}{.
    raises: [Exception, Exception, ValueError, JsonParsingError],
    tags: [ReadIOEffect].}</pre></dt> <dd> Parses from a stream <em>s</em> into a <em>JsonNode</em>. <em>filename</em> is only needed for nice error messages. If <em>s</em> contains extra data, it will raise <em>JsonParsingError</em>.   </dd>  <dt><pre data-language="nim">proc parseJson(buffer: string): JsonNode {...}{.raises: [Exception, ValueError,
    JsonParsingError], tags: [ReadIOEffect].}</pre></dt> <dd> Parses JSON from <em>buffer</em>. If <em>buffer</em> contains extra data, it will raise <em>JsonParsingError</em>.   </dd>  <dt><pre data-language="nim">proc parseFile(filename: string): JsonNode {...}{.
    raises: [IOError, Exception, ValueError, JsonParsingError], tags: [ReadIOEffect].}</pre></dt> <dd> Parses <em>file</em> into a <em>JsonNode</em>. If <em>file</em> contains extra data, it will raise <em>JsonParsingError</em>.   </dd> </dl>  <h2 id="15">Iterators</h2> <dl>  <dt><pre data-language="nim">iterator items(node: JsonNode): JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Iterator for the items of <em>node</em>. <em>node</em> has to be a JArray.   </dd>  <dt><pre data-language="nim">iterator mitems(node: var JsonNode): var JsonNode {...}{.raises: [], tags: [].}</pre></dt> <dd> Iterator for the items of <em>node</em>. <em>node</em> has to be a JArray. Items can be modified.   </dd>  <dt><pre data-language="nim">iterator pairs(node: JsonNode): tuple[key: string, val: JsonNode] {...}{.raises: [], tags: [].}</pre></dt> <dd> Iterator for the child elements of <em>node</em>. <em>node</em> has to be a JObject.   </dd>  <dt><pre data-language="nim">iterator mpairs(node: var JsonNode): tuple[key: string, val: var JsonNode] {...}{.raises: [],
    tags: [].}</pre></dt> <dd> Iterator for the child elements of <em>node</em>. <em>node</em> has to be a JObject. Values can be modified   </dd> </dl>  <h2 id="17">Macros</h2> <dl>  <dt><pre data-language="nim">macro `%*`(x: untyped): untyped</pre></dt> <dd> Convert an expression to a JsonNode directly, without having to specify <em>%</em> for every element.   </dd>  <dt><pre data-language="nim">macro to(node: JsonNode; T: typedesc): untyped</pre></dt> <dd> <p><span id="unmarshals_1">Unmarshals</span> the specified node into the object type specified.</p> <p>Known limitations:</p> <blockquote>
<ul class="simple">
<li>Heterogeneous arrays are not supported.</li> <li>Sets in object variants are not supported.</li> <li>Not nil annotations are not supported.</li> </ul> </blockquote> <p>Example:</p> <pre class="listing" data-language="nim">let jsonNode = parseJson("""
   {
     "person": {
       "name": "Nimmer",
       "age": 21
     },
     "list": [1, 2, 3, 4]
   }
""")

type
  Person = object
    name: string
    age: int
  
  Data = object
    person: Person
    list: seq[int]

var data = to(jsonNode, Data)
doAssert data.person.name == "Nimmer"
doAssert data.person.age == 21
doAssert data.list == @[1, 2, 3, 4]</pre>   </dd> </dl>  <h2 id="18">Templates</h2> <dl>  <dt><pre data-language="nim">template `%`(j: JsonNode): JsonNode</pre></dt>   <dt><pre data-language="nim">template simpleGetOrDefault{
  {}(node, [key])
}(node: JsonNode; key: string): JsonNode</pre></dt>  </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2018 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/json.html" class="_attribution-link">https://nim-lang.org/docs/json.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
