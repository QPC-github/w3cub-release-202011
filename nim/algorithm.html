
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Algorithm - Nim - W3cubDocs</title>
  
  <meta name="description" content=" This module implements some common generic algorithms. ">
  <meta name="keywords" content="module, algorithm, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nim/algorithm.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="title">Module algorithm</h1>  <p class="module-desc">This module implements some common generic algorithms.</p>  <h2 id="7">Types</h2> <dl>  <dt><pre data-language="nim">SortOrder = enum
  Descending, Ascending</pre></dt> <dd> sort order   </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre data-language="nim">proc `*`(x: int; order: SortOrder): int {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> flips <em>x</em> if <code>order == Descending</code>; if <code>order == Ascending</code> then <em>x</em> is returned. <em>x</em> is supposed to be the result of a comparator, ie <code>&lt; 0</code> for <em>less than</em>, <code>== 0</code> for <em>equal</em>, <code>&gt; 0</code> for <em>greater than</em>.   </dd>  <dt><pre data-language="nim">proc fill[T](a: var openArray[T]; first, last: Natural; value: T)</pre></dt> <dd> fills the array <code>a[first..last]</code> with <em>value</em>.   </dd>  <dt><pre data-language="nim">proc fill[T](a: var openArray[T]; value: T)</pre></dt> <dd> fills the array <em>a</em> with <em>value</em>.   </dd>  <dt><pre data-language="nim">proc reverse[T](a: var openArray[T]; first, last: Natural)</pre></dt> <dd> reverses the array <code>a[first..last]</code>.   </dd>  <dt><pre data-language="nim">proc reverse[T](a: var openArray[T])</pre></dt> <dd> reverses the array <em>a</em>.   </dd>  <dt><pre data-language="nim">proc reversed[T](a: openArray[T]; first: Natural; last: int): seq[T]</pre></dt> <dd> returns the reverse of the array <em>a[first..last]</em>.   </dd>  <dt><pre data-language="nim">proc reversed[T](a: openArray[T]): seq[T]</pre></dt> <dd> returns the reverse of the array <em>a</em>.   </dd>  <dt><pre data-language="nim">proc binarySearch[T, K](a: openArray[T]; key: K;
                      cmp: proc (x: T; y: K): int {...}{.closure.}): int</pre></dt> <dd> <p>binary search for <em>key</em> in <em>a</em>. Returns -1 if not found.</p> <p><em>cmp</em> is the comparator function to use, the expected return values are the same as that of system.cmp.</p>   </dd>  <dt><pre data-language="nim">proc binarySearch[T](a: openArray[T]; key: T): int</pre></dt> <dd> binary search for <em>key</em> in <em>a</em>. Returns -1 if not found.   </dd>  <dt><pre data-language="nim">proc smartBinarySearch[T](a: openArray[T]; key: T): int {...}{.deprecated.}</pre></dt> <dd> <strong>Deprecated since version 0.18.1</strong>; Use <code>binarySearch</code> instead.   </dd>  <dt><pre data-language="nim">proc lowerBound[T, K](a: openArray[T]; key: K; cmp: proc (x: T; k: K): int {...}{.closure.}): int</pre></dt> <dd> <p>Returns a position to the first element in the <em>a</em> that is greater than <em>key</em>, or last if no such element is found. In other words if you have a sorted sequence and you call insert(thing, elm, lowerBound(thing, elm)) the sequence will still be sorted.</p> <p>The first version uses <em>cmp</em> to compare the elements. The expected return values are the same as that of system.cmp. The second version uses the default comparison function <em>cmp</em>.</p> <p>example:</p>
<pre data-language="nim">var arr = @[1,2,3,5,6,7,8,9]
arr.insert(4, arr.lowerBound(4))
# after running the above arr is `[1,2,3,4,5,6,7,8,9]`</pre>   </dd>  <dt><pre data-language="nim">proc lowerBound[T](a: openArray[T]; key: T): int</pre></dt>   <dt><pre data-language="nim">proc upperBound[T, K](a: openArray[T]; key: K; cmp: proc (x: T; k: K): int {...}{.closure.}): int</pre></dt> <dd> <p>Returns a position to the first element in the <em>a</em> that is not less (i.e. greater or equal to) than <em>key</em>, or last if no such element is found. In other words if you have a sorted sequence and you call insert(thing, elm, upperBound(thing, elm)) the sequence will still be sorted.</p> <p>The first version uses <em>cmp</em> to compare the elements. The expected return values are the same as that of system.cmp. The second version uses the default comparison function <em>cmp</em>.</p> <p>example:</p>
<pre data-language="nim">var arr = @[1,2,3,4,6,7,8,9]
arr.insert(5, arr.upperBound(4))
# after running the above arr is `[1,2,3,4,5,6,7,8,9]`</pre>   </dd>  <dt><pre data-language="nim">proc upperBound[T](a: openArray[T]; key: T): int</pre></dt>   <dt><pre data-language="nim">proc sort[T](a: var openArray[T]; cmp: proc (x, y: T): int {...}{.closure.};
            order = SortOrder.Ascending)</pre></dt> <dd> Default Nim sort (an implementation of merge sort). The sorting is guaranteed to be stable and the worst case is guaranteed to be O(n log n). The current implementation uses an iterative mergesort to achieve this. It uses a temporary sequence of length <code>a.len div 2</code>. Currently Nim does not support a sensible default argument for <code>cmp</code>, so you have to provide one of your own. However, the <code>system.cmp</code> procs can be used:<pre class="listing" data-language="nim">sort(myIntArray, system.cmp[int])

# do not use cmp[string] here as we want to use the specialized
# overload:
sort(myStrArray, system.cmp)</pre>
<p>You can inline adhoc comparison procs with the <a href="manual#procedures-do-notation">do notation</a>. Example:</p> <pre class="listing" data-language="nim">people.sort do (x, y: Person) -&gt; int:
  result = cmp(x.surname, y.surname)
  if result == 0:
    result = cmp(x.name, y.name)</pre>   </dd>  <dt><pre data-language="nim">proc sorted[T](a: openArray[T]; cmp: proc (x, y: T): int {...}{.closure.};
              order = SortOrder.Ascending): seq[T]</pre></dt> <dd> returns <em>a</em> sorted by <em>cmp</em> in the specified <em>order</em>.   </dd>  <dt><pre data-language="nim">proc isSorted[T](a: openArray[T]; cmp: proc (x, y: T): int {...}{.closure.};
                order = SortOrder.Ascending): bool</pre></dt> <dd> Checks to see whether <em>a</em> is already sorted in <em>order</em> using <em>cmp</em> for the comparison. Parameters identical to <em>sort</em>   </dd>  <dt><pre data-language="nim">proc product[T](x: openArray[seq[T]]): seq[seq[T]]</pre></dt> <dd> produces the Cartesian product of the array. Warning: complexity may explode.   </dd>  <dt><pre data-language="nim">proc nextPermutation[T](x: var openArray[T]): bool {...}{.discardable.}</pre></dt> <dd> Calculates the next lexicographic permutation, directly modifying <code>x</code>. The result is whether a permutation happened, otherwise we have reached the last-ordered permutation.<pre class="listing" data-language="nim">var v = @[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
v.nextPermutation()
echo v # @[0, 1, 2, 3, 4, 5, 6, 7, 9, 8]</pre>   </dd>  <dt><pre data-language="nim">proc prevPermutation[T](x: var openArray[T]): bool {...}{.discardable.}</pre></dt> <dd> Calculates the previous lexicographic permutation, directly modifying <code>x</code>. The result is whether a permutation happened, otherwise we have reached the first-ordered permutation.<pre class="listing" data-language="nim">var v = @[0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
v.prevPermutation()
echo v # @[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>   </dd>  <dt><pre data-language="nim">proc rotateLeft[T](arg: var openArray[T]; slice: HSlice[int, int]; dist: int): int</pre></dt> <dd> Performs a left rotation on a range of elements. If you want to rotate right, use a negative <code>dist</code>. Specifically, <code>rotateLeft</code> rotates the elements at <code>slice</code> by <code>dist</code> positions. The element at index <code>slice.a + dist</code> will be at index <code>slice.a</code>. The element at index <code>slice.b</code> will be at <code>slice.a + dist -1</code>. The element at index <code>slice.a</code> will be at <code>slice.b + 1 - dist</code>. The element at index <code>slice.a + dist - 1</code> will be at <code>slice.b</code>.   </dd>  <dt><pre data-language="nim">proc rotateLeft[T](arg: var openArray[T]; dist: int): int</pre></dt> <dd> default arguments for slice, so that this procedure operates on the entire <code>arg</code>, and not just on a part of it.   </dd>  <dt><pre data-language="nim">proc rotatedLeft[T](arg: openArray[T]; slice: HSlice[int, int]; dist: int): seq[T]</pre></dt> <dd> same as <code>rotateLeft</code>, just with the difference that it does not modify the argument. It creates a new <code>seq</code> instead   </dd>  <dt><pre data-language="nim">proc rotatedLeft[T](arg: openArray[T]; dist: int): seq[T]</pre></dt> <dd> same as <code>rotateLeft</code>, just with the difference that it does not modify the argument. It creates a new <code>seq</code> instead   </dd> </dl>  <h2 id="18">Templates</h2> <dl>  <dt><pre data-language="nim">template sortedByIt(seq1, op: untyped): untyped</pre></dt> <dd> <p>Convenience template around the <code>sorted</code> proc to reduce typing.</p> <p>The template injects the <code>it</code> variable which you can use directly in an expression. Example:</p> <pre class="listing" data-language="nim">type Person = tuple[name: string, age: int]
var
  p1: Person = (name: "p1", age: 60)
  p2: Person = (name: "p2", age: 20)
  p3: Person = (name: "p3", age: 30)
  p4: Person = (name: "p4", age: 30)
  people = @[p1,p2,p4,p3]

echo people.sortedByIt(it.name)</pre>
<p>Because the underlying <code>cmp()</code> is defined for tuples you can do a nested sort like in the following example:</p> <pre class="listing" data-language="nim">echo people.sortedByIt((it.age, it.name))</pre>   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2018 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/algorithm.html" class="_attribution-link">https://nim-lang.org/docs/algorithm.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
