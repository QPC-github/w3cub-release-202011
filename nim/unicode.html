
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Unicode - Nim - W3cubDocs</title>
  
  <meta name="description" content=" This module provides support to handle the Unicode UTF-8 encoding. ">
  <meta name="keywords" content="module, unicode, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/nim/unicode.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="title">Module unicode</h1>  <p class="module-desc">This module provides support to handle the Unicode UTF-8 encoding.</p>  <h2 id="7">Types</h2> <dl>  <dt><pre>Rune = distinct RuneImpl</pre></dt> <dd> type that can hold any Unicode character   </dd>  <dt><pre>Rune16 = distinct int16</pre></dt> <dd> 16 bit Unicode character   </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre data-language="nim">proc `&lt;=%`(a, b: Rune): bool {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc `&lt;%`(a, b: Rune): bool {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc `==`(a, b: Rune): bool {...}{.raises: [], tags: [].}</pre></dt>   <dt><pre data-language="nim">proc runeLen(s: string): int {...}{.gcsafe, extern: "nuc$1", raises: [], tags: [].}</pre></dt> <dd> Returns the number of Unicode characters of the string <code>s</code>   </dd>  <dt><pre data-language="nim">proc runeLenAt(s: string; i: Natural): int {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the number of bytes the rune starting at <code>s[i]</code> takes   </dd>  <dt><pre data-language="nim">proc validateUtf8(s: string): int {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the position of the invalid byte in <code>s</code> if the string <code>s</code> does not hold valid UTF-8 data. Otherwise <code>-1</code> is returned.   </dd>  <dt><pre data-language="nim">proc runeAt(s: string; i: Natural): Rune {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the unicode character in <code>s</code> at byte index <code>i</code>   </dd>  <dt><pre data-language="nim">proc toUTF8(c: Rune): string {...}{.gcsafe, extern: "nuc$1", raises: [], tags: [].}</pre></dt> <dd> Converts a rune into its UTF-8 representation   </dd>  <dt><pre data-language="nim">proc `$`(rune: Rune): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Converts a Rune to a string   </dd>  <dt><pre data-language="nim">proc `$`(runes: seq[Rune]): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Converts a sequence of Runes to a string   </dd>  <dt><pre data-language="nim">proc runeOffset(s: string; pos: Natural; start: Natural = 0): int {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Returns the byte position of unicode character at position pos in s with an optional start byte position. returns the special value -1 if it runs out of the string</p> <p>Beware: This can lead to unoptimized code and slow execution! Most problems are solve more efficient by using an iterator or conversion to a seq of Rune.</p>   </dd>  <dt><pre data-language="nim">proc runeAtPos(s: string; pos: int): Rune {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Returns the unicode character at position pos</p> <p>Beware: This can lead to unoptimized code and slow execution! Most problems are solve more efficient by using an iterator or conversion to a seq of Rune.</p>   </dd>  <dt><pre data-language="nim">proc runeStrAtPos(s: string; pos: Natural): string {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Returns the unicode character at position pos as UTF8 String</p> <p>Beware: This can lead to unoptimized code and slow execution! Most problems are solve more efficient by using an iterator or conversion to a seq of Rune.</p>   </dd>  <dt><pre data-language="nim">proc runeReverseOffset(s: string; rev: Positive): (int, int) {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Returns a tuple with the the byte offset of the unicode character at position <code>rev</code> in s counting from the end (starting with 1) and the total number of runes in the string. Returns a negative value for offset if there are to few runes in the string to satisfy the request.</p> <p>Beware: This can lead to unoptimized code and slow execution! Most problems are solve more efficient by using an iterator or conversion to a seq of Rune.</p>   </dd>  <dt><pre data-language="nim">proc runeSubStr(s: string; pos: int; len: int = int.high): string {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Returns the UTF-8 substring starting at codepoint pos with len codepoints. If pos or len is negative they count from the end of the string. If len is not given it means the longest possible string.</p> <p>(Needs some examples)</p>   </dd>  <dt><pre data-language="nim">proc toLower(c: Rune): Rune {...}{.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Converts <code>c</code> into lower case. This works for any Unicode character. If possible, prefer <code>toLower</code> over <code>toUpper</code>.   </dd>  <dt><pre data-language="nim">proc toUpper(c: Rune): Rune {...}{.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Converts <code>c</code> into upper case. This works for any Unicode character. If possible, prefer <code>toLower</code> over <code>toUpper</code>.   </dd>  <dt><pre data-language="nim">proc toTitle(c: Rune): Rune {...}{.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Converts <code>c</code> to title case   </dd>  <dt><pre data-language="nim">proc isLower(c: Rune): bool {...}{.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>c</code> is a lower case Unicode character. If possible, prefer <code>isLower</code> over <code>isUpper</code>.   </dd>  <dt><pre data-language="nim">proc isUpper(c: Rune): bool {...}{.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>c</code> is a upper case Unicode character. If possible, prefer <code>isLower</code> over <code>isUpper</code>.   </dd>  <dt><pre data-language="nim">proc isAlpha(c: Rune): bool {...}{.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>c</code> is an <em>alpha</em> Unicode character (i.e., a letter)   </dd>  <dt><pre data-language="nim">proc isTitle(c: Rune): bool {...}{.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>c</code> is a Unicode titlecase character   </dd>  <dt><pre data-language="nim">proc isWhiteSpace(c: Rune): bool {...}{.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>c</code> is a Unicode whitespace character   </dd>  <dt><pre data-language="nim">proc isCombining(c: Rune): bool {...}{.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>c</code> is a Unicode combining character   </dd>  <dt><pre data-language="nim">proc isAlpha(s: string): bool {...}{.noSideEffect, procvar, gcsafe, extern: "nuc$1Str",
                            raises: [], tags: [].}</pre></dt> <dd> Returns true iff <em>s</em> contains all alphabetic unicode characters.   </dd>  <dt><pre data-language="nim">proc isSpace(s: string): bool {...}{.noSideEffect, procvar, gcsafe, extern: "nuc$1Str",
                            raises: [], tags: [].}</pre></dt> <dd> Returns true iff <em>s</em> contains all whitespace unicode characters.   </dd>  <dt><pre data-language="nim">proc isLower(s: string; skipNonAlpha: bool): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether <code>s</code> is lower case.</p> <p>If <code>skipNonAlpha</code> is true, returns true if all alphabetical runes in <code>s</code> are lower case. Returns false if none of the runes in <code>s</code> are alphabetical.</p> <p>If <code>skipNonAlpha</code> is false, returns true only if all runes in <code>s</code> are alphabetical and lower case.</p> <p>For either value of <code>skipNonAlpha</code>, returns false if <code>s</code> is an empty string.</p>   </dd>  <dt><pre data-language="nim">proc isUpper(s: string; skipNonAlpha: bool): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether <code>s</code> is upper case.</p> <p>If <code>skipNonAlpha</code> is true, returns true if all alphabetical runes in <code>s</code> are upper case. Returns false if none of the runes in <code>s</code> are alphabetical.</p> <p>If <code>skipNonAlpha</code> is false, returns true only if all runes in <code>s</code> are alphabetical and upper case.</p> <p>For either value of <code>skipNonAlpha</code>, returns false if <code>s</code> is an empty string.</p>   </dd>  <dt><pre data-language="nim">proc toUpper(s: string): string {...}{.noSideEffect, procvar, gcsafe, extern: "nuc$1Str",
                              raises: [], tags: [].}</pre></dt> <dd> Converts <em>s</em> into upper-case unicode characters.   </dd>  <dt><pre data-language="nim">proc toLower(s: string): string {...}{.noSideEffect, procvar, gcsafe, extern: "nuc$1Str",
                              raises: [], tags: [].}</pre></dt> <dd> Converts <em>s</em> into lower-case unicode characters.   </dd>  <dt><pre data-language="nim">proc swapCase(s: string): string {...}{.noSideEffect, procvar, gcsafe, extern: "nuc$1",
                               raises: [], tags: [].}</pre></dt> <dd> <p>Swaps the case of unicode characters in <em>s</em></p> <p>Returns a new string such that the cases of all unicode characters are swapped if possible</p>   </dd>  <dt><pre data-language="nim">proc capitalize(s: string): string {...}{.noSideEffect, procvar, gcsafe, extern: "nuc$1",
                                 raises: [], tags: [].}</pre></dt> <dd> Converts the first character of <em>s</em> into an upper-case unicode character.   </dd>  <dt><pre data-language="nim">proc translate(s: string; replacements: proc (key: string): string): string {...}{.gcsafe,
    extern: "nuc$1", raises: [], tags: [].}</pre></dt> <dd> <p>Translates words in a string using the <em>replacements</em> proc to substitute words inside <em>s</em> with their replacements</p> <p><em>replacements</em> is any proc that takes a word and returns a new word to fill it's place.</p>   </dd>  <dt><pre data-language="nim">proc title(s: string): string {...}{.noSideEffect, procvar, gcsafe, extern: "nuc$1",
                            raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>s</em> to a unicode title.</p> <p>Returns a new string such that the first character in each word inside <em>s</em> is capitalized</p>   </dd>  <dt><pre data-language="nim">proc isTitle(s: string): bool {...}{.noSideEffect, procvar, gcsafe, extern: "nuc$1Str",
                            raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> is a unicode title.</p> <p>Returns true if the first character in each word inside <em>s</em> are upper case and there is at least one character in <em>s</em>.</p>   </dd>  <dt><pre data-language="nim">proc toRunes(s: string): seq[Rune] {...}{.raises: [], tags: [].}</pre></dt> <dd> Obtains a sequence containing the Runes in <code>s</code>   </dd>  <dt><pre data-language="nim">proc cmpRunesIgnoreCase(a, b: string): int {...}{.gcsafe, extern: "nuc$1", procvar,
                                        raises: [], tags: [].}</pre></dt> <dd> Compares two UTF-8 strings and ignores the case. Returns:<p>0 iff a == b<br>&lt; 0 iff a &lt; b<br>&gt; 0 iff a &gt; b<br></p>   </dd>  <dt><pre data-language="nim">proc reversed(s: string): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the reverse of <code>s</code>, interpreting it as Unicode characters. Unicode combining characters are correctly interpreted as well:<pre class="listing" data-language="nim">assert reversed("Reverse this!") == "!siht esreveR"
assert reversed("先秦兩漢") == "漢兩秦先"
assert reversed("as⃝df̅") == "f̅ds⃝a"
assert reversed("a⃞b⃞c⃞") == "c⃞b⃞a⃞"</pre>   </dd>  <dt><pre data-language="nim">proc graphemeLen(s: string; i: Natural): Natural {...}{.raises: [], tags: [].}</pre></dt> <dd> The number of bytes belonging to 's[i]' including following combining characters.   </dd>  <dt><pre data-language="nim">proc lastRune(s: string; last: int): (Rune, int) {...}{.raises: [], tags: [].}</pre></dt> <dd> length of the last rune in 's[0..last]'. Returns the rune and its length in bytes.   </dd> </dl>  <h2 id="15">Iterators</h2> <dl>  <dt><pre data-language="nim">iterator runes(s: string): Rune {...}{.raises: [], tags: [].}</pre></dt> <dd> Iterates over any unicode character of the string <code>s</code> returning runes   </dd>  <dt><pre data-language="nim">iterator utf8(s: string): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Iterates over any unicode character of the string <code>s</code> returning utf8 values   </dd> </dl>  <h2 id="18">Templates</h2> <dl>  <dt><pre data-language="nim">template fastRuneAt(s: string; i: int; result: untyped; doInc = true)</pre></dt> <dd> Returns the Unicode character <code>s[i]</code> in <code>result</code>. If <code>doInc == true</code> <code>i</code> is incremented by the number of bytes that have been processed.   </dd>  <dt><pre data-language="nim">template fastToUTF8Copy(c: Rune; s: var string; pos: int; doInc = true)</pre></dt> <dd> <p>Copies UTF-8 representation of <em>c</em> into the preallocated string <em>s</em> starting at position <em>pos</em>. If <em>doInc == true</em>, <em>pos</em> is incremented by the number of bytes that have been processed.</p> <p>To be the most efficient, make sure <em>s</em> is preallocated with an additional amount equal to the byte length of <em>c</em>.</p>   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2018 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/unicode.html" class="_attribution-link">https://nim-lang.org/docs/unicode.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
