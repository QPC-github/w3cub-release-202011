
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Custom Drawing - GTK 3.24 - W3cubDocs</title>
  
  <meta name="description" content="Many widgets, like buttons, do all their drawing themselves. You just tell them the label you want to see, and they figure out what font to use, &hellip;">
  <meta name="keywords" content="custom, drawing, gtk, gtk~3.24">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/gtk~3.24/ch01s05.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/gtk~3.24.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/gtk~3.24/" class="_nav-link" title="" style="margin-left:0;">GTK 3.24</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _gtk">
				
				
<h1>Custom Drawing</h1>
<div class="section">  <p>Many widgets, like buttons, do all their drawing themselves. You just tell them the label you want to see, and they figure out what font to use, draw the button outline and focus rectangle, etc. Sometimes, it is necessary to do some custom drawing. In that case, a <a class="link" href="gtkdrawingarea" title="GtkDrawingArea"><span class="type">GtkDrawingArea</span></a> might be the right widget to use. It offers a canvas on which you can draw by connecting to the <a class="link" href="gtkwidget#GtkWidget-draw" title="The “draw” signal"><span class="type">“draw”</span></a> signal. </p> <p>The contents of a widget often need to be partially or fully redrawn, e.g. when another window is moved and uncovers part of the widget, or when the window containing it is resized. It is also possible to explicitly cause part or all of the widget to be redrawn, by calling <a class="link" href="gtkwidget#gtk-widget-queue-draw" title="gtk_widget_queue_draw ()"><code class="function">gtk_widget_queue_draw()</code></a> or its variants. GTK+ takes care of most of the details by providing a ready-to-use cairo context to the ::draw signal handler.</p> <p>The following example shows a ::draw signal handler. It is a bit more complicated than the previous examples, since it also demonstrates input event handling by means of ::button-press and ::motion-notify handlers.</p> <div class="informalfigure"><div class="mediaobject"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANwAAACXCAMAAABJG8UcAAAAGXRFWHRTb2Z0d2FyZQBnbm9tZS1zY3JlZW5zaG907wO/PgAAAJBQTFRFzs7O////AAAApqamt7e3rKys7e3tp6enpqamqampp6un+vr68fHx9fX17u7u/v7++/v7/f398PDw9vb28/Pz+fn59/f3LjQ2x8fHv7+/0NDQ1dXVw8PD3d3d5OTky8vLTlNU6enpq6urfoKDcHR1OkBClJeYYGVmQ0hKsbKyuLm5Mzk7iIuNVltdphxYrP//OALJQwAAADB0Uk5TAv///xpx/83xav////////////////////////////////////////////////9xZYVbpAAABNBJREFUeNrt3Il2ojAUBmCQmdqWUrHEXJFFZHfh/V9vEkRsPQKOOGAy96cntQQin0EQyamiKMrb9FWTLK/TN4Xn13RtqKLG0zbX47vTXww3/ZjNhY2n+U3xporyey2wbdaC8+03ZWqYAsd79xrjTJVX1ZwLO83acN6ros2F7rnQaY6maCLb5l64clZN4Thd4DDcug2nL8QN2y3X6/WyYWK4hcjxwuUpDFmXxzAc7ZUAAJJsa7UvBUFznQMJuffZF962plDdWS4dnV7gFj2mAOI420Pc1gqlSdFcfwDY3f30Z5xr6Lrj6LrhfscZPXuOH7NysFuXUueNVSSP8rhHz7lV7JDqpqnT0D7NcRmO9MTxcse7Dni8qEiSbM36Y0dpxM0HVvDdErIsSeINX7rYQ72j2uCk4NPT6n6UJ5lDraqZrvg1zg1DXZ3pYej+wFl9EgAvN1BYFiRRlNI03ab7nHgQWR8JK0geUAsCVg15nLMZ1hbyKOZzysQF9UCzqtVJsU+1PH+xqmY6nt34hnNtfabq534rcR8PwWVs6wJ2WrVMc2HGrCuyhNgQ5cTlW17igpnp8xeh2PumecJt9kkQQGFUq68gNvUtbE/NdD29v7VPWR3PfKt6hs1xRp8EwMsdHAwDAvaIpMGe717GFtyo8GAZ7V+OVWU1L5Lcqv5i0cq9EVbVnO3xz7RupiNnnEvZ+42976j7HfdF+iQAVjg5OIRAwB4uId5YEXjkM4kSzSqiJDKOVWU1L4p6YZYi4JeccKjmrCHm16CLupmO+LuaQozw/T00yI+e+yRGj4mfCgpgu16NC7Q0Z1tlRAAbkgKX/MSF7N3F3nPl6g7rJEKsIPk61hsFxKF2ODfT8fRn3C5NQ9sO0/QC16/nIAniFa02nFhhsM8zvlWsE1ifQmZc4ihbpKh67lDa2Wuwq/ryK+Lrf2umq+fOxxP7XNYHlJdeuLmqzuamxR+qc17SuTozVSayVJO97rw4VpXVZcEWYYfXcvUFX5L/otXqROfrf2umC7dsDsNtPoaPF8PhIQ3dgCODTkt+PEy8h7S12a2bM0bPOYcsO/jkMT1nr/kF3dUffj23+Ro4hLIz9MeDGmu5Vh0F99D47spZOVd/OM7/FDnEs1ctXxB9fgk90c3589ZFOE7wkMYbCRLgmsM/oUgbxCEOcYhDHOL+E9y7NLmGUyUJ4hCHOMQhDnGIQxziJMVNTpEIN7ka4XGTrgiLm9wWkXDnjZYLd7HRkuCub3QDRSRcc4+0b/6T47p2t45tFxt34+qi4f5qZXFwd7xVRcDde3hVnxzX54Qo3SXPRF6cHB+cn6DfBsYNfUU3Fk7WrxmkuBIfuduGxE3+D5yEX+0NT0PcQ3Eq9pywBxSpcROpcRKe58bQIU5U3mjXcxPZcOpE6q8Z1EFv9IyP+4e+4UczDHijboyhGoPdixxnHMpAt1tHG2TT4+be8+Paji+P6sTxh0d14Poon2Ls1024O5BPNLDtJtxfAZ9y1F4H7mbi0w5J7MTdwHv68ZZS41rPGtLgrgGlwl0K5cPd/h2omAO4pcapUuME/oSCOMQhDnGIQxziEIc4xCEOcYhDHOIQhzjEIQ5xiEMc4hCHOMQhThKczP8wF/+PM+IQhzjEIU5GnMT5A+ZUzMYP4/YpAAAAAElFTkSuQmCC"></div></div> <div class="example"> <p class="title"><b>Example 4. Drawing in response to input</b></p> <div class="example-contents"> <p>Create a new file with the following content named example-4.c.</p> <pre class="programlisting" data-language="c">#include &lt;gtk/gtk.h&gt;

/* Surface to store current scribbles */
static cairo_surface_t *surface = NULL;

static void
clear_surface (void)
{
  cairo_t *cr;

  cr = cairo_create (surface);

  cairo_set_source_rgb (cr, 1, 1, 1);
  cairo_paint (cr);

  cairo_destroy (cr);
}

/* Create a new surface of the appropriate size to store our scribbles */
static gboolean
configure_event_cb (GtkWidget         *widget,
                    GdkEventConfigure *event,
                    gpointer           data)
{
  if (surface)
    cairo_surface_destroy (surface);

  surface = gdk_window_create_similar_surface (gtk_widget_get_window (widget),
                                               CAIRO_CONTENT_COLOR,
                                               gtk_widget_get_allocated_width (widget),
                                               gtk_widget_get_allocated_height (widget));

  /* Initialize the surface to white */
  clear_surface ();

  /* We've handled the configure event, no need for further processing. */
  return TRUE;
}

/* Redraw the screen from the surface. Note that the ::draw
 * signal receives a ready-to-be-used cairo_t that is already
 * clipped to only draw the exposed areas of the widget
 */
static gboolean
draw_cb (GtkWidget *widget,
         cairo_t   *cr,
         gpointer   data)
{
  cairo_set_source_surface (cr, surface, 0, 0);
  cairo_paint (cr);

  return FALSE;
}

/* Draw a rectangle on the surface at the given position */
static void
draw_brush (GtkWidget *widget,
            gdouble    x,
            gdouble    y)
{
  cairo_t *cr;

  /* Paint to the surface, where we store our state */
  cr = cairo_create (surface);

  cairo_rectangle (cr, x - 3, y - 3, 6, 6);
  cairo_fill (cr);

  cairo_destroy (cr);

  /* Now invalidate the affected region of the drawing area. */
  gtk_widget_queue_draw_area (widget, x - 3, y - 3, 6, 6);
}

/* Handle button press events by either drawing a rectangle
 * or clearing the surface, depending on which button was pressed.
 * The ::button-press signal handler receives a GdkEventButton
 * struct which contains this information.
 */
static gboolean
button_press_event_cb (GtkWidget      *widget,
                       GdkEventButton *event,
                       gpointer        data)
{
  /* paranoia check, in case we haven't gotten a configure event */
  if (surface == NULL)
    return FALSE;

  if (event-&gt;button == GDK_BUTTON_PRIMARY)
    {
      draw_brush (widget, event-&gt;x, event-&gt;y);
    }
  else if (event-&gt;button == GDK_BUTTON_SECONDARY)
    {
      clear_surface ();
      gtk_widget_queue_draw (widget);
    }

  /* We've handled the event, stop processing */
  return TRUE;
}

/* Handle motion events by continuing to draw if button 1 is
 * still held down. The ::motion-notify signal handler receives
 * a GdkEventMotion struct which contains this information.
 */
static gboolean
motion_notify_event_cb (GtkWidget      *widget,
                        GdkEventMotion *event,
                        gpointer        data)
{
  /* paranoia check, in case we haven't gotten a configure event */
  if (surface == NULL)
    return FALSE;

  if (event-&gt;state &amp; GDK_BUTTON1_MASK)
    draw_brush (widget, event-&gt;x, event-&gt;y);

  /* We've handled it, stop processing */
  return TRUE;
}

static void
close_window (void)
{
  if (surface)
    cairo_surface_destroy (surface);
}

static void
activate (GtkApplication *app,
          gpointer        user_data)
{
  GtkWidget *window;
  GtkWidget *frame;
  GtkWidget *drawing_area;

  window = gtk_application_window_new (app);
  gtk_window_set_title (GTK_WINDOW (window), "Drawing Area");

  g_signal_connect (window, "destroy", G_CALLBACK (close_window), NULL);

  gtk_container_set_border_width (GTK_CONTAINER (window), 8);

  frame = gtk_frame_new (NULL);
  gtk_frame_set_shadow_type (GTK_FRAME (frame), GTK_SHADOW_IN);
  gtk_container_add (GTK_CONTAINER (window), frame);

  drawing_area = gtk_drawing_area_new ();
  /* set a minimum size */
  gtk_widget_set_size_request (drawing_area, 100, 100);

  gtk_container_add (GTK_CONTAINER (frame), drawing_area);

  /* Signals used to handle the backing surface */
  g_signal_connect (drawing_area, "draw",
                    G_CALLBACK (draw_cb), NULL);
  g_signal_connect (drawing_area,"configure-event",
                    G_CALLBACK (configure_event_cb), NULL);

  /* Event signals */
  g_signal_connect (drawing_area, "motion-notify-event",
                    G_CALLBACK (motion_notify_event_cb), NULL);
  g_signal_connect (drawing_area, "button-press-event",
                    G_CALLBACK (button_press_event_cb), NULL);

  /* Ask to receive events the drawing area doesn't normally
   * subscribe to. In particular, we need to ask for the
   * button press and motion notify events that want to handle.
   */
  gtk_widget_set_events (drawing_area, gtk_widget_get_events (drawing_area)
                                     | GDK_BUTTON_PRESS_MASK
                                     | GDK_POINTER_MOTION_MASK);

  gtk_widget_show_all (window);
}

int
main (int    argc,
      char **argv)
{
  GtkApplication *app;
  int status;

  app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE);
  g_signal_connect (app, "activate", G_CALLBACK (activate), NULL);
  status = g_application_run (G_APPLICATION (app), argc, argv);
  g_object_unref (app);

  return status;
}
</pre> </div> </div> <p> You can compile the program above with GCC using: </p> <div class="literallayout">
<p> </p>
<pre class="literal" data-language="c">gcc `pkg-config --cflags gtk+-3.0` -o example-4 example-4.c `pkg-config --libs gtk+-3.0`</pre> </div>  </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2005–2020 The GNOME Project<br>Licensed under the GNU Lesser General Public License version 2.1 or later.<br>
    <a href="https://developer.gnome.org/gtk3/3.24/ch01s05.html" class="_attribution-link">https://developer.gnome.org/gtk3/3.24/ch01s05.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
