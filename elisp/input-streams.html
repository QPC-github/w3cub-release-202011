
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Input Streams - Elisp - W3cubDocs</title>
  
  <meta name="description" content="Most of the Lisp functions for reading text take an input stream as an argument. The input stream specifies where or how to get the characters of &hellip;">
  <meta name="keywords" content="input, streams, elisp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/elisp/input-streams.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/elisp.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elisp/" class="_nav-link" title="" style="margin-left:0;">Elisp</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elisp">
				
				
<h3 class="section">Input Streams</h3>   <p>Most of the Lisp functions for reading text take an <em>input stream</em> as an argument. The input stream specifies where or how to get the characters of the text to be read. Here are the possible types of input stream: </p> <dl compact> <dt><var>buffer</var></dt> <dd>
 <p>The input characters are read from <var>buffer</var>, starting with the character directly after point. Point advances as characters are read. </p> </dd> <dt><var>marker</var></dt> <dd>
 <p>The input characters are read from the buffer that <var>marker</var> is in, starting with the character directly after the marker. The marker position advances as characters are read. The value of point in the buffer has no effect when the stream is a marker. </p> </dd> <dt><var>string</var></dt> <dd>
 <p>The input characters are taken from <var>string</var>, starting at the first character in the string and using as many characters as required. </p> </dd> <dt><var>function</var></dt> <dd>
 <p>The input characters are generated by <var>function</var>, which must support two kinds of calls: </p> <ul> <li> When it is called with no arguments, it should return the next character. </li>
<li> When it is called with one argument (always a character), <var>function</var> should save the argument and arrange to return it on the next call. This is called <em>unreading</em> the character; it happens when the Lisp reader reads one character too many and wants to put it back where it came from. In this case, it makes no difference what value <var>function</var> returns. </li>
</ul> </dd> <dt><code>t</code></dt> <dd>
 <p><code>t</code> used as a stream means that the input is read from the minibuffer. In fact, the minibuffer is invoked once and the text given by the user is made into a string that is then used as the input stream. If Emacs is running in batch mode, standard input is used instead of the minibuffer. For example, </p>
<div class="example"> <pre class="example">(message "%s" (read t))
</pre>
</div> <p>will read a Lisp expression from standard input and print the result to standard output. </p> </dd> <dt><code>nil</code></dt> <dd>
 <p><code>nil</code> supplied as an input stream means to use the value of <code>standard-input</code> instead; that value is the <em>default input stream</em>, and must be a non-<code>nil</code> input stream. </p> </dd> <dt><var>symbol</var></dt> <dd><p>A symbol as input stream is equivalent to the symbol’s function definition (if any). </p></dd> </dl> <p>Here is an example of reading from a stream that is a buffer, showing where point is located before and after: </p> <div class="example"> <pre class="example">---------- Buffer: foo ----------
This∗ is the contents of foo.
---------- Buffer: foo ----------
</pre>

<pre class="example">(read (get-buffer "foo"))
     ⇒ is
</pre>
<pre class="example">(read (get-buffer "foo"))
     ⇒ the
</pre>

<pre class="example">---------- Buffer: foo ----------
This is the∗ contents of foo.
---------- Buffer: foo ----------
</pre>
</div> <p>Note that the first read skips a space. Reading skips any amount of whitespace preceding the significant text. </p> <p>Here is an example of reading from a stream that is a marker, initially positioned at the beginning of the buffer shown. The value read is the symbol <code>This</code>. </p> <div class="example"> <pre class="example">

---------- Buffer: foo ----------
This is the contents of foo.
---------- Buffer: foo ----------
</pre>

<pre class="example">(setq m (set-marker (make-marker) 1 (get-buffer "foo")))
     ⇒ #&lt;marker at 1 in foo&gt;
</pre>
<pre class="example">(read m)
     ⇒ This
</pre>
<pre class="example">m
     ⇒ #&lt;marker at 5 in foo&gt;   ;; <span class="roman">Before the first space.</span>
</pre>
</div> <p>Here we read from the contents of a string: </p> <div class="example"> <pre class="example">(read "(When in) the course")
     ⇒ (When in)
</pre>
</div> <p>The following example reads from the minibuffer. The prompt is: ‘<samp>Lisp expression: </samp>’. (That is always the prompt used when you read from the stream <code>t</code>.) The user’s input is shown following the prompt. </p> <div class="example"> <pre class="example">(read t)
     ⇒ 23
---------- Buffer: Minibuffer ----------
Lisp expression: <kbd>23 <span class="key">RET</span></kbd>
---------- Buffer: Minibuffer ----------
</pre>
</div> <p>Finally, here is an example of a stream that is a function, named <code>useless-stream</code>. Before we use the stream, we initialize the variable <code>useless-list</code> to a list of characters. Then each call to the function <code>useless-stream</code> obtains the next character in the list or unreads a character by adding it to the front of the list. </p> <div class="example"> <pre class="example">(setq useless-list (append "XY()" nil))
     ⇒ (88 89 40 41)
</pre>

<pre class="example">(defun useless-stream (&amp;optional unread)
  (if unread
      (setq useless-list (cons unread useless-list))
    (prog1 (car useless-list)
           (setq useless-list (cdr useless-list)))))
     ⇒ useless-stream
</pre>
</div> <p>Now we read using the stream thus constructed: </p> <div class="example"> <pre class="example">(read 'useless-stream)
     ⇒ XY
</pre>

<pre class="example">useless-list
     ⇒ (40 41)
</pre>
</div> <p>Note that the open and close parentheses remain in the list. The Lisp reader encountered the open parenthesis, decided that it ended the input, and unread it. Another attempt to read from the stream at this point would read ‘<samp>()</samp>’ and return <code>nil</code>. </p>
<div class="_attribution">
  <p class="_attribution-p">
    Copyright © 1990-1996, 1998-2019 Free Software Foundation, Inc. <br>Licensed under the GNU GPL license.<br>
    <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Input-Streams.html" class="_attribution-link">https://www.gnu.org/software/emacs/manual/html_node/elisp/Input-Streams.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
