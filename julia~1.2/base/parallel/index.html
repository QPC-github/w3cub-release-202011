
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Tasks - Julia 1.2 - W3cubDocs</title>
  
  <meta name="description" content="Create a Task (i.e. coroutine) to execute the given function func (which must be callable with no arguments). The task exits when this function &hellip;">
  <meta name="keywords" content="tasksscheduling, tasks, julia, julia~1.2">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/julia~1.2/base/parallel/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/julia~1.2.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia~1.2/" class="_nav-link" title="" style="margin-left:0;">Julia 1.2</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _julia">
				
				
<h1 id="Tasks-1">Tasks</h1>
<h3 id="Core.Task">
<code>Core.Task</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">Task(func)</pre>
<p>Create a <code>Task</code> (i.e. coroutine) to execute the given function <code>func</code> (which must be callable with no arguments). The task exits when this function returns.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a() = sum(i for i in 1:1000);

julia&gt; b = Task(a);</pre>
<p>In this example, <code>b</code> is a runnable <code>Task</code> that hasn't started yet.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L1128-L1142">source</a><h3 id="Base.@task">
<code>Base.@task</code><span class="docstring-category">Macro</span>
</h3>
<pre data-language="julia">@task</pre>
<p>Wrap an expression in a <a href="#Core.Task"><code>Task</code></a> without executing it, and return the <a href="#Core.Task"><code>Task</code></a>. This only creates a task, and does not run it.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a1() = sum(i for i in 1:1000);

julia&gt; b = @task a1();

julia&gt; istaskstarted(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskdone(b)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L63-L85">source</a><h3 id="Base.@async">
<code>Base.@async</code><span class="docstring-category">Macro</span>
</h3>
<pre data-language="julia">@async</pre>
<p>Wrap an expression in a <a href="#Core.Task"><code>Task</code></a> and add it to the local machine's scheduler queue.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L262-L266">source</a><h3 id="Base.@sync">
<code>Base.@sync</code><span class="docstring-category">Macro</span>
</h3>
<pre data-language="julia">@sync</pre>
<p>Wait until all lexically-enclosed uses of <code>@async</code>, <code>@spawn</code>, <code>@spawnat</code> and <code>@distributed</code> are complete. All exceptions thrown by enclosed async operations are collected and thrown as a <code>CompositeException</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L242-L248">source</a><h3 id="Base.asyncmap">
<code>Base.asyncmap</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">asyncmap(f, c...; ntasks=0, batch_size=nothing)</pre>
<p>Uses multiple concurrent tasks to map <code>f</code> over a collection (or multiple equal length collections). For multiple collection arguments, <code>f</code> is applied elementwise.</p>
<p><code>ntasks</code> specifies the number of tasks to run concurrently. Depending on the length of the collections, if <code>ntasks</code> is unspecified, up to 100 tasks will be used for concurrent mapping.</p>
<p><code>ntasks</code> can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of <code>ntasks_func</code> is less than the current number of tasks.</p>
<p>If <code>batch_size</code> is specified, the collection is processed in batch mode. <code>f</code> must then be a function that must accept a <code>Vector</code> of argument tuples and must return a vector of results. The input vector will have a length of <code>batch_size</code> or less.</p>
<p>The following examples highlight execution in different tasks by returning the <code>objectid</code> of the tasks in which the mapping function is executed.</p>
<p>First, with <code>ntasks</code> undefined, each element is processed in a different task.</p>
<pre data-language="julia">julia&gt; tskoid() = objectid(current_task());

julia&gt; asyncmap(x-&gt;tskoid(), 1:5)
5-element Array{UInt64,1}:
 0x6e15e66c75c75853
 0x440f8819a1baa682
 0x9fb3eeadd0c83985
 0xebd3e35fe90d4050
 0x29efc93edce2b961

julia&gt; length(unique(asyncmap(x-&gt;tskoid(), 1:5)))
5</pre>
<p>With <code>ntasks=2</code> all elements are processed in 2 tasks.</p>
<pre data-language="julia">julia&gt; asyncmap(x-&gt;tskoid(), 1:5; ntasks=2)
5-element Array{UInt64,1}:
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94

julia&gt; length(unique(asyncmap(x-&gt;tskoid(), 1:5; ntasks=2)))
2</pre>
<p>With <code>batch_size</code> defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. <code>map</code> is used in the modified mapping function to achieve this.</p>
<pre data-language="julia">julia&gt; batch_func(input) = map(x-&gt;string("args_tuple: ", x, ", element_val: ", x[1], ", task: ", tskoid()), input)
batch_func (generic function with 1 method)

julia&gt; asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)
5-element Array{String,1}:
 "args_tuple: (1,), element_val: 1, task: 9118321258196414413"
 "args_tuple: (2,), element_val: 2, task: 4904288162898683522"
 "args_tuple: (3,), element_val: 3, task: 9118321258196414413"
 "args_tuple: (4,), element_val: 4, task: 4904288162898683522"
 "args_tuple: (5,), element_val: 5, task: 9118321258196414413"</pre>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>Currently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, <code>asyncmap</code> is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/asyncmap.jl#L5-L79">source</a><h3 id="Base.asyncmap!">
<code>Base.asyncmap!</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)</pre>
<p>Like <a href="#Base.asyncmap"><code>asyncmap</code></a>, but stores output in <code>results</code> rather than returning a collection.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/asyncmap.jl#L412-L417">source</a><h3 id="Base.fetch-Tuple{Task}">
<code>Base.fetch</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">fetch(t::Task)</pre>
<p>Wait for a Task to finish, then return its result value. If the task fails with an exception, the exception is propagated (re-thrown in the task that called fetch).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L204-L209">source</a><h3 id="Base.current_task">
<code>Base.current_task</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">current_task()</pre>
<p>Get the currently running <a href="#Core.Task"><code>Task</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L90-L94">source</a><h3 id="Base.istaskdone">
<code>Base.istaskdone</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">istaskdone(t::Task) -&gt; Bool</pre>
<p>Determine whether a task has exited.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a2() = sum(i for i in 1:1000);

julia&gt; b = Task(a2);

julia&gt; istaskdone(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskdone(b)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L97-L118">source</a><h3 id="Base.istaskstarted">
<code>Base.istaskstarted</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">istaskstarted(t::Task) -&gt; Bool</pre>
<p>Determine whether a task has started executing.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a3() = sum(i for i in 1:1000);

julia&gt; b = Task(a3);

julia&gt; istaskstarted(b)
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L121-L135">source</a><h3 id="Base.task_local_storage-Tuple{Any}">
<code>Base.task_local_storage</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">task_local_storage(key)</pre>
<p>Look up the value of a key in the current task's task-local storage.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L152-L156">source</a><h3 id="Base.task_local_storage-Tuple{Any,Any}">
<code>Base.task_local_storage</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">task_local_storage(key, value)</pre>
<p>Assign a value to a key in the current task's task-local storage.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L159-L163">source</a><h3 id="Base.task_local_storage-Tuple{Function,Any,Any}">
<code>Base.task_local_storage</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">task_local_storage(body, key, value)</pre>
<p>Call the function <code>body</code> with a modified task-local storage, in which <code>value</code> is assigned to <code>key</code>; the previous value of <code>key</code>, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L166-L172">source</a><h1 id="Scheduling-1">Scheduling</h1>
<h3 id="Base.yield">
<code>Base.yield</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">yield()</pre>
<p>Switch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L472-L478">source</a><pre data-language="julia">yield(t::Task, arg = nothing)</pre>
<p>A fast, unfair-scheduling version of <code>schedule(t, arg); yield()</code> which immediately yields to <code>t</code> before calling the scheduler.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L481-L486">source</a><h3 id="Base.yieldto">
<code>Base.yieldto</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">yieldto(t::Task, arg = nothing)</pre>
<p>Switch to the given task. The first time a task is switched to, the task's function is called with no arguments. On subsequent switches, <code>arg</code> is returned from the task's last call to <code>yieldto</code>. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L493-L500">source</a><h3 id="Base.sleep">
<code>Base.sleep</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">sleep(seconds)</pre>
<p>Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of <code>0.001</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/asyncevent.jl#L180-L185">source</a><h3 id="Base.wait">
<code>Base.wait</code><span class="docstring-category">Function</span>
</h3>
<p>Special note for <a href="#Base.Threads.Condition"><code>Threads.Condition</code></a>:</p>
<p>The caller must be holding the <a href="#Base.lock"><code>lock</code></a> that owns <code>c</code> before calling this method. The calling task will be blocked until some other task wakes it, usually by calling <a href="#Base.notify"><code>notify</code></a>` on the same Condition object. The lock will be atomically released when blocking (even if it was locked recursively), and will be reacquired before returning.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/lock.jl#L168-L176">source</a><pre data-language="julia">wait([x])</pre>
<p>Block the current task until some event occurs, depending on the type of the argument:</p>
<ul>
<li>
<a href="#Base.Channel"><code>Channel</code></a>: Wait for a value to be appended to the channel.</li>
<li>
<a href="#Base.Condition"><code>Condition</code></a>: Wait for <a href="#Base.notify"><code>notify</code></a> on a condition.</li>
<li>
<code>Process</code>: Wait for a process or process chain to exit. The <code>exitcode</code> field of a process can be used to determine success or failure.</li>
<li>
<a href="#Core.Task"><code>Task</code></a>: Wait for a <code>Task</code> to finish. If the task fails with an exception, the exception is propagated (re-thrown in the task that called <code>wait</code>).</li>
<li>
<a href="../file/index#Base.Libc.RawFD"><code>RawFD</code></a>: Wait for changes on a file descriptor (see the <code>FileWatching</code> package).</li>
</ul>
<p>If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to <a href="#Base.schedule"><code>schedule</code></a> or <a href="#Base.yieldto"><code>yieldto</code></a>.</p>
<p>Often <code>wait</code> is called within a <code>while</code> loop to ensure a waited-for condition is met before proceeding.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/condition.jl#L79-L97">source</a><pre data-language="julia">wait(r::Future)</pre>
<p>Wait for a value to become available for the specified <a href="../../stdlib/distributed/index#Distributed.Future"><code>Future</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/stdlib/Distributed/src/remotecall.jl#L495-L499">source</a><pre data-language="julia">wait(r::RemoteChannel, args...)</pre>
<p>Wait for a value to become available on the specified <a href="../../stdlib/distributed/index#Distributed.RemoteChannel"><code>RemoteChannel</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/stdlib/Distributed/src/remotecall.jl#L502-L506">source</a><h3 id="Base.timedwait">
<code>Base.timedwait</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">timedwait(testcb::Function, secs::Float64; pollint::Float64=0.1)</pre>
<p>Waits until <code>testcb</code> returns <code>true</code> or for <code>secs</code> seconds, whichever is earlier. <code>testcb</code> is polled every <code>pollint</code> seconds.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/asyncevent.jl#L243-L248">source</a><h3 id="Base.Condition">
<code>Base.Condition</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">Condition()</pre>
<p>Create an edge-triggered event source that tasks can wait for. Tasks that call <a href="#Base.wait"><code>wait</code></a> on a <code>Condition</code> are suspended and queued. Tasks are woken up when <a href="#Base.notify"><code>notify</code></a> is later called on the <code>Condition</code>. Edge triggering means that only tasks waiting at the time <a href="#Base.notify"><code>notify</code></a> is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The <a href="#Base.Channel"><code>Channel</code></a> and <a href="#Base.Event"><code>Threads.Event</code></a> types do this, and can be used for level-triggered events.</p>
<p>This object is NOT thread-safe. See <a href="#Base.Threads.Condition"><code>Threads.Condition</code></a> for a thread-safe version.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/condition.jl#L149-L160">source</a><h3 id="Base.Threads.Condition">
<code>Base.Threads.Condition</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">Threads.Condition([lock])</pre>
<p>A thread-safe version of <a href="#Base.Condition"><code>Base.Condition</code></a>.</p>
<div class="admonition compat">
<div class="admonition-title">Julia 1.2</div>
<div class="admonition-text"><p>This functionality requires at least Julia 1.2.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/lock.jl#L158-L165">source</a><h3 id="Base.notify">
<code>Base.notify</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">notify(condition, val=nothing; all=true, error=false)</pre>
<p>Wake up tasks waiting for a condition, passing them <code>val</code>. If <code>all</code> is <code>true</code> (the default), all waiting tasks are woken, otherwise only one is. If <code>error</code> is <code>true</code>, the passed value is raised as an exception in the woken tasks.</p>
<p>Return the count of tasks woken up. Return 0 if no tasks are waiting on <code>condition</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/condition.jl#L113-L121">source</a><h3 id="Base.schedule">
<code>Base.schedule</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">schedule(t::Task, [val]; error=false)</pre>
<p>Add a <a href="#Core.Task"><code>Task</code></a> to the scheduler's queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as <a href="#Base.wait"><code>wait</code></a>.</p>
<p>If a second argument <code>val</code> is provided, it will be passed to the task (via the return value of <a href="#Base.yieldto"><code>yieldto</code></a>) when it runs again. If <code>error</code> is <code>true</code>, the value is raised as an exception in the woken task.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a5() = sum(i for i in 1:1000);

julia&gt; b = Task(a5);

julia&gt; istaskstarted(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskstarted(b)
true

julia&gt; istaskdone(b)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/task.jl#L428-L457">source</a><h3 id="Base.Event">
<code>Base.Event</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">Event()</pre>
<p>Create a level-triggered event source. Tasks that call <a href="#Base.wait"><code>wait</code></a> on an <code>Event</code> are suspended and queued until <code>notify</code> is called on the <code>Event</code>. After <code>notify</code> is called, the <code>Event</code> remains in a signaled state and tasks will no longer block when waiting for it.</p>
<div class="admonition compat">
<div class="admonition-title">Julia 1.1</div>
<div class="admonition-text"><p>This functionality requires at least Julia 1.1.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/lock.jl#L235-L245">source</a><h3 id="Base.Semaphore">
<code>Base.Semaphore</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">Semaphore(sem_size)</pre>
<p>Create a counting semaphore that allows at most <code>sem_size</code> acquires to be in use at any time. Each acquire must be matched with a release.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/lock.jl#L182-L188">source</a><h3 id="Base.acquire">
<code>Base.acquire</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">acquire(s::Semaphore)</pre>
<p>Wait for one of the <code>sem_size</code> permits to be available, blocking until one can be acquired.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/lock.jl#L196-L201">source</a><h3 id="Base.release">
<code>Base.release</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">release(s::Semaphore)</pre>
<p>Return one permit to the pool, possibly allowing another task to acquire it and resume execution.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/lock.jl#L215-L221">source</a><h3 id="Base.AbstractLock">
<code>Base.AbstractLock</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">AbstractLock</pre>
<p>Abstract supertype describing types that implement the synchronization primitives: <a href="#Base.lock"><code>lock</code></a>, <a href="#Base.trylock"><code>trylock</code></a>, <a href="#Base.unlock"><code>unlock</code></a>, and <a href="#Base.islocked"><code>islocked</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/condition.jl#L11-L17">source</a><h3 id="Base.lock">
<code>Base.lock</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">lock(lock)</pre>
<p>Acquire the <code>lock</code> when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.</p>
<p>Each <code>lock</code> must be matched by an <a href="#Base.unlock"><code>unlock</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/lock.jl#L58-L66">source</a><h3 id="Base.unlock">
<code>Base.unlock</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">unlock(lock)</pre>
<p>Releases ownership of the <code>lock</code>.</p>
<p>If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/lock.jl#L87-L94">source</a><h3 id="Base.trylock">
<code>Base.trylock</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">trylock(lock) -&gt; Success (Boolean)</pre>
<p>Acquire the lock if it is available, and return <code>true</code> if successful. If the lock is already locked by a different task/thread, return <code>false</code>.</p>
<p>Each successful <code>trylock</code> must be matched by an <a href="#Base.unlock"><code>unlock</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/lock.jl#L30-L39">source</a><h3 id="Base.islocked">
<code>Base.islocked</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">islocked(lock) -&gt; Status (Boolean)</pre>
<p>Check whether the <code>lock</code> is held by any task/thread. This should not be used for synchronization (see instead <a href="#Base.trylock"><code>trylock</code></a>).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/lock.jl#L20-L25">source</a><h3 id="Base.ReentrantLock">
<code>Base.ReentrantLock</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">ReentrantLock()</pre>
<p>Creates a re-entrant lock for synchronizing <a href="#Core.Task"><code>Task</code></a>s. The same task can acquire the lock as many times as required. Each <a href="#Base.lock"><code>lock</code></a> must be matched with an <a href="#Base.unlock"><code>unlock</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/lock.jl#L4-L10">source</a><h3 id="Base.Channel">
<code>Base.Channel</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">Channel{T}(sz::Int)</pre>
<p>Constructs a <code>Channel</code> with an internal buffer that can hold a maximum of <code>sz</code> objects of type <code>T</code>. <a href="#Base.put!-Tuple%7BChannel,Any%7D"><code>put!</code></a> calls on a full channel block until an object is removed with <a href="#Base.take!-Tuple%7BChannel%7D"><code>take!</code></a>.</p>
<p><code>Channel(0)</code> constructs an unbuffered channel. <code>put!</code> blocks until a matching <code>take!</code> is called. And vice-versa.</p>
<p>Other constructors:</p>
<ul>
<li>
<code>Channel(Inf)</code>: equivalent to <code>Channel{Any}(typemax(Int))</code>
</li>
<li>
<code>Channel(sz)</code>: equivalent to <code>Channel{Any}(sz)</code>
</li>
</ul>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/channels.jl#L10-L24">source</a><h3 id="Base.put!-Tuple{Channel,Any}">
<code>Base.put!</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">put!(c::Channel, v)</pre>
<p>Append an item <code>v</code> to the channel <code>c</code>. Blocks if the channel is full.</p>
<p>For unbuffered channels, blocks until a <a href="#Base.take!-Tuple%7BChannel%7D"><code>take!</code></a> is performed by a different task.</p>
<div class="admonition compat">
<div class="admonition-title">Julia 1.1</div>
<div class="admonition-text"><p><code>v</code> now gets converted to the channel's type with <a href="../base/index#Base.convert"><code>convert</code></a> as <code>put!</code> is called.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/channels.jl#L261-L271">source</a><h3 id="Base.take!-Tuple{Channel}">
<code>Base.take!</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">take!(c::Channel)</pre>
<p>Remove and return a value from a <a href="#Base.Channel"><code>Channel</code></a>. Blocks until data is available.</p>
<p>For unbuffered channels, blocks until a <a href="#Base.put!-Tuple%7BChannel,Any%7D"><code>put!</code></a> is performed by a different task.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/channels.jl#L336-L343">source</a><h3 id="Base.isready-Tuple{Channel}">
<code>Base.isready</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">isready(c::Channel)</pre>
<p>Determine whether a <a href="#Base.Channel"><code>Channel</code></a> has a value stored to it. Returns immediately, does not block.</p>
<p>For unbuffered channels returns <code>true</code> if there are tasks waiting on a <a href="#Base.put!-Tuple%7BChannel,Any%7D"><code>put!</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/channels.jl#L374-L382">source</a><h3 id="Base.fetch-Tuple{Channel}">
<code>Base.fetch</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">fetch(c::Channel)</pre>
<p>Wait for and get the first available item from the channel. Does not remove the item. <code>fetch</code> is unsupported on an unbuffered (0-size) channel.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/channels.jl#L314-L319">source</a><h3 id="Base.close-Tuple{Channel}">
<code>Base.close</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">close(c::Channel[, excp::Exception])</pre>
<p>Close a channel. An exception (optionally given by <code>excp</code>), is thrown by:</p>
<ul>
<li>
<a href="#Base.put!-Tuple%7BChannel,Any%7D"><code>put!</code></a> on a closed channel.</li>
<li>
<a href="#Base.take!-Tuple%7BChannel%7D"><code>take!</code></a> and <a href="#Base.fetch-Tuple%7BTask%7D"><code>fetch</code></a> on an empty, closed channel.</li>
</ul>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/channels.jl#L121-L128">source</a><h3 id="Base.bind-Tuple{Channel,Task}">
<code>Base.bind</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">bind(chnl::Channel, task::Task)</pre>
<p>Associate the lifetime of <code>chnl</code> with a task. <code>Channel</code> <code>chnl</code> is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on <code>chnl</code>.</p>
<p>The <code>chnl</code> object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed <code>Channel</code> objects.</p>
<p>When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; c = Channel(0);

julia&gt; task = @async foreach(i-&gt;put!(c, i), 1:4);

julia&gt; bind(c,task);

julia&gt; for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia&gt; isopen(c)
false</pre>
<pre data-language="julia">julia&gt; c = Channel(0);

julia&gt; task = @async (put!(c,1);error("foo"));

julia&gt; bind(c,task);

julia&gt; take!(c)
1

julia&gt; put!(c,1);
ERROR: foo
Stacktrace:
[...]</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/channels.jl#L144-L193">source</a><div class="_attribution">
  <p class="_attribution-p">
    © 2009–2019 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.julialang.org/en/v1.2.0/base/parallel/" class="_attribution-link">https://docs.julialang.org/en/v1.2.0/base/parallel/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
