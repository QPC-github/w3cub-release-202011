
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Arrays - Julia 1.2 - W3cubDocs</title>
  
  <meta name="description" content="Supertype for N-dimensional arrays (or array-like types) with elements of type T. Array and other types are subtypes of this. See the manual section &hellip;">
  <meta name="keywords" content="arrays, julia, julia~1.2">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/julia~1.2/base/arrays/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/julia~1.2.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia~1.2/" class="_nav-link" title="" style="margin-left:0;">Julia 1.2</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _julia">
				
				
<h1 id="lib-arrays-1">Arrays</h1>
<h2 id="Constructors-and-Types-1">Constructors and Types</h2>
<h3 id="Core.AbstractArray">
<code>Core.AbstractArray</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">AbstractArray{T,N}</pre>
<p>Supertype for <code>N</code>-dimensional arrays (or array-like types) with elements of type <code>T</code>. <a href="#Core.Array"><code>Array</code></a> and other types are subtypes of this. See the manual section on the <a href="../../manual/interfaces/index#man-interface-array-1"><code>AbstractArray</code> interface</a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L5-L11">source</a><h3 id="Base.AbstractVector">
<code>Base.AbstractVector</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">AbstractVector{T}</pre>
<p>Supertype for one-dimensional arrays (or array-like types) with elements of type <code>T</code>. Alias for <a href="#Core.AbstractArray"><code>AbstractArray{T,1}</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L17-L22">source</a><h3 id="Base.AbstractMatrix">
<code>Base.AbstractMatrix</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">AbstractMatrix{T}</pre>
<p>Supertype for two-dimensional arrays (or array-like types) with elements of type <code>T</code>. Alias for <a href="#Core.AbstractArray"><code>AbstractArray{T,2}</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L25-L30">source</a><h3 id="Base.AbstractVecOrMat">
<code>Base.AbstractVecOrMat</code><span class="docstring-category">Constant</span>
</h3>
<pre data-language="julia">AbstractVecOrMat{T}</pre>
<p>Union type of <a href="#Base.AbstractVector"><code>AbstractVector{T}</code></a> and <a href="#Base.AbstractMatrix"><code>AbstractMatrix{T}</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L33-L37">source</a><h3 id="Core.Array">
<code>Core.Array</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">Array{T,N} &lt;: AbstractArray{T,N}</pre>
<p><code>N</code>-dimensional dense array with elements of type <code>T</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L45-L49">source</a><h3 id="Core.Array-Tuple{UndefInitializer,Any}">
<code>Core.Array</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">Array{T}(undef, dims)
Array{T,N}(undef, dims)</pre>
<p>Construct an uninitialized <code>N</code>-dimensional <a href="#Core.Array"><code>Array</code></a> containing elements of type <code>T</code>. <code>N</code> can either be supplied explicitly, as in <code>Array{T,N}(undef, dims)</code>, or be determined by the length or number of <code>dims</code>. <code>dims</code> may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank <code>N</code> is supplied explicitly, then it must match the length or number of <code>dims</code>. See <a href="#Core.undef"><code>undef</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = Array{Float64,2}(undef, 2, 3) # N given explicitly
2×3 Array{Float64,2}:
 6.90198e-310  6.90198e-310  6.90198e-310
 6.90198e-310  6.90198e-310  0.0

julia&gt; B = Array{Float64}(undef, 2) # N determined by the input
2-element Array{Float64,1}:
 1.87103e-320
 0.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L1675-L1698">source</a><h3 id="Core.Array-Tuple{Nothing,Any}">
<code>Core.Array</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">Array{T}(nothing, dims)
Array{T,N}(nothing, dims)</pre>
<p>Construct an <code>N</code>-dimensional <a href="#Core.Array"><code>Array</code></a> containing elements of type <code>T</code>, initialized with <a href="../constants/index#Core.nothing"><code>nothing</code></a> entries. Element type <code>T</code> must be able to hold these values, i.e. <code>Nothing &lt;: T</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Array{Union{Nothing, String}}(nothing, 2)
2-element Array{Union{Nothing, String},1}:
 nothing
 nothing

julia&gt; Array{Union{Nothing, Int}}(nothing, 2, 3)
2×3 Array{Union{Nothing, Int64},2}:
 nothing  nothing  nothing
 nothing  nothing  nothing</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L1701-L1721">source</a><h3 id="Core.Array-Tuple{Missing,Any}">
<code>Core.Array</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">Array{T}(missing, dims)
Array{T,N}(missing, dims)</pre>
<p>Construct an <code>N</code>-dimensional <a href="#Core.Array"><code>Array</code></a> containing elements of type <code>T</code>, initialized with <a href="../base/index#Base.missing"><code>missing</code></a> entries. Element type <code>T</code> must be able to hold these values, i.e. <code>Missing &lt;: T</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Array{Union{Missing, String}}(missing, 2)
2-element Array{Union{Missing, String},1}:
 missing
 missing

julia&gt; Array{Union{Missing, Int}}(missing, 2, 3)
2×3 Array{Union{Missing, Int64},2}:
 missing  missing  missing
 missing  missing  missing</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L1725-L1745">source</a><h3 id="Core.UndefInitializer">
<code>Core.UndefInitializer</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">UndefInitializer</pre>
<p>Singleton type used in array initialization, indicating the array-constructor-caller would like an uninitialized array. See also <a href="#Core.undef"><code>undef</code></a>, an alias for <code>UndefInitializer()</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Array{Float64,1}(UndefInitializer(), 3)
3-element Array{Float64,1}:
 2.2752528595e-314
 2.202942107e-314
 2.275252907e-314</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L1748-L1763">source</a><h3 id="Core.undef">
<code>Core.undef</code><span class="docstring-category">Constant</span>
</h3>
<pre data-language="julia">undef</pre>
<p>Alias for <code>UndefInitializer()</code>, which constructs an instance of the singleton type <a href="#Core.UndefInitializer"><code>UndefInitializer</code></a>, used in array initialization to indicate the array-constructor-caller would like an uninitialized array.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Array{Float64,1}(undef, 3)
3-element Array{Float64,1}:
 2.2752528595e-314
 2.202942107e-314
 2.275252907e-314</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L1766-L1781">source</a><h3 id="Base.Vector">
<code>Base.Vector</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">Vector{T} &lt;: AbstractVector{T}</pre>
<p>One-dimensional dense array with elements of type <code>T</code>, often used to represent a mathematical vector. Alias for <a href="#Core.Array"><code>Array{T,1}</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L52-L57">source</a><h3 id="Base.Vector-Tuple{UndefInitializer,Any}">
<code>Base.Vector</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">Vector{T}(undef, n)</pre>
<p>Construct an uninitialized <a href="#Base.Vector"><code>Vector{T}</code></a> of length <code>n</code>. See <a href="#Core.undef"><code>undef</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Vector{Float64}(undef, 3)
3-element Array{Float64,1}:
 6.90966e-310
 6.90966e-310
 6.90966e-310</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L1576-L1589">source</a><h3 id="Base.Vector-Tuple{Nothing,Any}">
<code>Base.Vector</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">Vector{T}(nothing, m)</pre>
<p>Construct a <a href="#Base.Vector"><code>Vector{T}</code></a> of length <code>m</code>, initialized with <a href="../constants/index#Core.nothing"><code>nothing</code></a> entries. Element type <code>T</code> must be able to hold these values, i.e. <code>Nothing &lt;: T</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Vector{Union{Nothing, String}}(nothing, 2)
2-element Array{Union{Nothing, String},1}:
 nothing
 nothing</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L1592-L1606">source</a><h3 id="Base.Vector-Tuple{Missing,Any}">
<code>Base.Vector</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">Vector{T}(missing, m)</pre>
<p>Construct a <a href="#Base.Vector"><code>Vector{T}</code></a> of length <code>m</code>, initialized with <a href="../base/index#Base.missing"><code>missing</code></a> entries. Element type <code>T</code> must be able to hold these values, i.e. <code>Missing &lt;: T</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Vector{Union{Missing, String}}(missing, 2)
2-element Array{Union{Missing, String},1}:
 missing
 missing</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L1609-L1623">source</a><h3 id="Base.Matrix">
<code>Base.Matrix</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">Matrix{T} &lt;: AbstractMatrix{T}</pre>
<p>Two-dimensional dense array with elements of type <code>T</code>, often used to represent a mathematical matrix. Alias for <a href="#Core.Array"><code>Array{T,2}</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L60-L65">source</a><h3 id="Base.Matrix-Tuple{UndefInitializer,Any,Any}">
<code>Base.Matrix</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">Matrix{T}(undef, m, n)</pre>
<p>Construct an uninitialized <a href="#Base.Matrix"><code>Matrix{T}</code></a> of size <code>m</code>×<code>n</code>. See <a href="#Core.undef"><code>undef</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Matrix{Float64}(undef, 2, 3)
2×3 Array{Float64,2}:
 6.93517e-310  6.93517e-310  6.93517e-310
 6.93517e-310  6.93517e-310  1.29396e-320</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L1626-L1638">source</a><h3 id="Base.Matrix-Tuple{Nothing,Any,Any}">
<code>Base.Matrix</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">Matrix{T}(nothing, m, n)</pre>
<p>Construct a <a href="#Base.Matrix"><code>Matrix{T}</code></a> of size <code>m</code>×<code>n</code>, initialized with <a href="../constants/index#Core.nothing"><code>nothing</code></a> entries. Element type <code>T</code> must be able to hold these values, i.e. <code>Nothing &lt;: T</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Matrix{Union{Nothing, String}}(nothing, 2, 3)
2×3 Array{Union{Nothing, String},2}:
 nothing  nothing  nothing
 nothing  nothing  nothing</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L1641-L1655">source</a><h3 id="Base.Matrix-Tuple{Missing,Any,Any}">
<code>Base.Matrix</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">Matrix{T}(missing, m, n)</pre>
<p>Construct a <a href="#Base.Matrix"><code>Matrix{T}</code></a> of size <code>m</code>×<code>n</code>, initialized with <a href="../base/index#Base.missing"><code>missing</code></a> entries. Element type <code>T</code> must be able to hold these values, i.e. <code>Missing &lt;: T</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Matrix{Union{Missing, String}}(missing, 2, 3)
2×3 Array{Union{Missing, String},2}:
 missing  missing  missing
 missing  missing  missing</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L1658-L1672">source</a><h3 id="Base.VecOrMat">
<code>Base.VecOrMat</code><span class="docstring-category">Constant</span>
</h3>
<pre data-language="julia">VecOrMat{T}</pre>
<p>Union type of <a href="#Base.Vector"><code>Vector{T}</code></a> and <a href="#Base.Matrix"><code>Matrix{T}</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L67-L71">source</a><h3 id="Core.DenseArray">
<code>Core.DenseArray</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">DenseArray{T, N} &lt;: AbstractArray{T,N}</pre>
<p><code>N</code>-dimensional dense array with elements of type <code>T</code>. The elements of a dense array are stored contiguously in memory.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L74-L79">source</a><h3 id="Base.DenseVector">
<code>Base.DenseVector</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">DenseVector{T}</pre>
<p>One-dimensional <a href="#Core.DenseArray"><code>DenseArray</code></a> with elements of type <code>T</code>. Alias for <code>DenseArray{T,1}</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L82-L86">source</a><h3 id="Base.DenseMatrix">
<code>Base.DenseMatrix</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">DenseMatrix{T}</pre>
<p>Two-dimensional <a href="#Core.DenseArray"><code>DenseArray</code></a> with elements of type <code>T</code>. Alias for <code>DenseArray{T,2}</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L89-L93">source</a><h3 id="Base.DenseVecOrMat">
<code>Base.DenseVecOrMat</code><span class="docstring-category">Constant</span>
</h3>
<pre data-language="julia">DenseVecOrMat{T}</pre>
<p>Union type of <a href="#Base.DenseVector"><code>DenseVector{T}</code></a> and <a href="#Base.DenseMatrix"><code>DenseMatrix{T}</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L96-L100">source</a><h3 id="Base.StridedArray">
<code>Base.StridedArray</code><span class="docstring-category">Constant</span>
</h3>
<pre data-language="julia">StridedArray{T, N}</pre>
<p>An <code>N</code> dimensional <em>strided</em> array with elements of type <code>T</code>. These arrays follow the <a href="../../manual/interfaces/index#man-interface-strided-arrays-1">strided array interface</a>. If <code>A</code> is a <code>StridedArray</code>, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, <code>A</code> could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing <code>A</code> along dimension <code>d</code> jumps in memory by [<code>strides(A, d)</code>] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L2114-L2125">source</a><h3 id="Base.StridedVector">
<code>Base.StridedVector</code><span class="docstring-category">Constant</span>
</h3>
<pre data-language="julia">StridedVector{T}</pre>
<p>One dimensional <a href="#Base.StridedArray"><code>StridedArray</code></a> with elements of type <code>T</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L2128-L2132">source</a><h3 id="Base.StridedMatrix">
<code>Base.StridedMatrix</code><span class="docstring-category">Constant</span>
</h3>
<pre data-language="julia">StridedMatrix{T}</pre>
<p>Two dimensional <a href="#Base.StridedArray"><code>StridedArray</code></a> with elements of type <code>T</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L2135-L2139">source</a><h3 id="Base.StridedVecOrMat">
<code>Base.StridedVecOrMat</code><span class="docstring-category">Constant</span>
</h3>
<pre data-language="julia">StridedVecOrMat{T}</pre>
<p>Union type of <a href="#Base.StridedVector"><code>StridedVector</code></a> and <a href="#Base.StridedMatrix"><code>StridedMatrix</code></a> with elements of type <code>T</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/docs/basedocs.jl#L2142-L2146">source</a><h3 id="Base.getindex-Tuple{Type,Vararg{Any,N} where N}">
<code>Base.getindex</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">getindex(type[, elements...])</pre>
<p>Construct a 1-d array of the specified type. This is usually called with the syntax <code>Type[]</code>. Element values can be specified using <code>Type[a,b,c,...]</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Int8[1, 2, 3]
3-element Array{Int8,1}:
 1
 2
 3

julia&gt; getindex(Int8, 1, 2, 3)
3-element Array{Int8,1}:
 1
 2
 3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L322-L342">source</a><h3 id="Base.zeros">
<code>Base.zeros</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">zeros([T=Float64,] dims...)</pre>
<p>Create an <code>Array</code>, with element type <code>T</code>, of all zeros with size specified by <code>dims</code>. See also <a href="#Base.fill"><code>fill</code></a>, <a href="#Base.ones"><code>ones</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; zeros(1)
1-element Array{Float64,1}:
 0.0

julia&gt; zeros(Int8, 2, 3)
2×3 Array{Int8,2}:
 0  0  0
 0  0  0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L398-L415">source</a><h3 id="Base.ones">
<code>Base.ones</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">ones([T=Float64,] dims...)</pre>
<p>Create an <code>Array</code>, with element type <code>T</code>, of all ones with size specified by <code>dims</code>. See also: <a href="#Base.fill"><code>fill</code></a>, <a href="#Base.zeros"><code>zeros</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; ones(1,2)
1×2 Array{Float64,2}:
 1.0  1.0

julia&gt; ones(ComplexF64, 2, 3)
2×3 Array{Complex{Float64},2}:
 1.0+0.0im  1.0+0.0im  1.0+0.0im
 1.0+0.0im  1.0+0.0im  1.0+0.0im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L418-L435">source</a><h3 id="Base.BitArray">
<code>Base.BitArray</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">BitArray{N} &lt;: AbstractArray{Bool, N}</pre>
<p>Space-efficient <code>N</code>-dimensional boolean array, using just one bit for each boolean value.</p>
<p><code>BitArray</code>s pack up to 64 values into every 8 bytes, resulting in an 8x space efficiency over <code>Array{Bool, N}</code> and allowing some operations to work on 64 values at once.</p>
<p>By default, Julia returns <code>BitArrays</code> from <a href="../../manual/arrays/index#Broadcasting-1">broadcasting</a> operations that generate boolean elements (including dotted-comparisons like <code>.==</code>) as well as from the functions <a href="#Base.trues"><code>trues</code></a> and <a href="#Base.falses"><code>falses</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/bitarray.jl#L7-L18">source</a><h3 id="Base.BitArray-Tuple{UndefInitializer,Vararg{Integer,N} where N}">
<code>Base.BitArray</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">BitArray(undef, dims::Integer...)
BitArray{N}(undef, dims::NTuple{N,Int})</pre>
<p>Construct an undef <a href="#Base.BitArray"><code>BitArray</code></a> with the given dimensions. Behaves identically to the <a href="#Core.Array"><code>Array</code></a> constructor. See <a href="#Core.undef"><code>undef</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; BitArray(undef, 2, 2)
2×2 BitArray{2}:
 false  false
 false  true

julia&gt; BitArray(undef, (3, 1))
3×1 BitArray{2}:
 false
 true
 false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/bitarray.jl#L43-L63">source</a><h3 id="Base.BitArray-Tuple{Any}">
<code>Base.BitArray</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">BitArray(itr)</pre>
<p>Construct a <a href="#Base.BitArray"><code>BitArray</code></a> generated by the given iterable object. The shape is inferred from the <code>itr</code> object.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; BitArray([1 0; 0 1])
2×2 BitArray{2}:
 1  0
 0  1

julia&gt; BitArray(x+y == 3 for x = 1:2, y = 1:3)
2×3 BitArray{2}:
 0  1  0
 1  0  0

julia&gt; BitArray(x+y == 3 for x = 1:2 for y = 1:3)
6-element BitArray{1}:
 0
 1
 0
 1
 0
 0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/bitarray.jl#L517-L544">source</a><h3 id="Base.trues">
<code>Base.trues</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">trues(dims)</pre>
<p>Create a <code>BitArray</code> with all values set to <code>true</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; trues(2,3)
2×3 BitArray{2}:
 1  1  1
 1  1  1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/bitarray.jl#L381-L393">source</a><h3 id="Base.falses">
<code>Base.falses</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">falses(dims)</pre>
<p>Create a <code>BitArray</code> with all values set to <code>false</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; falses(2,3)
2×3 BitArray{2}:
 0  0  0
 0  0  0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/bitarray.jl#L363-L375">source</a><h3 id="Base.fill">
<code>Base.fill</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">fill(x, dims)</pre>
<p>Create an array filled with the value <code>x</code>. For example, <code>fill(1.0, (5,5))</code> returns a 5×5 array of floats, with each element initialized to <code>1.0</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; fill(1.0, (5,5))
5×5 Array{Float64,2}:
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0</pre>
<p>If <code>x</code> is an object reference, all elements will refer to the same object. <code>fill(Foo(), dims)</code> will return an array filled with the result of evaluating <code>Foo()</code> once.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L373-L392">source</a><h3 id="Base.fill!">
<code>Base.fill!</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">fill!(A, x)</pre>
<p>Fill array <code>A</code> with the value <code>x</code>. If <code>x</code> is an object reference, all elements will refer to the same object. <code>fill!(A, Foo())</code> will return <code>A</code> filled with the result of evaluating <code>Foo()</code> once.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = zeros(2,3)
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; fill!(A, 2.)
2×3 Array{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0

julia&gt; a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(undef, 3), a); a[1] = 2; A
3-element Array{Array{Int64,1},1}:
 [2, 1, 1]
 [2, 1, 1]
 [2, 1, 1]

julia&gt; x = 0; f() = (global x += 1; x); fill!(Vector{Int}(undef, 3), f())
3-element Array{Int64,1}:
 1
 1
 1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/multidimensional.jl#L832-L863">source</a><h3 id="Base.similar">
<code>Base.similar</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">similar(array, [element_type=eltype(array)], [dims=size(array)])</pre>
<p>Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array's <code>eltype</code> and <code>size</code>. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.</p>
<p>Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an <code>Array{element_type}(undef, dims...)</code>.</p>
<p>For example, <code>similar(1:10, 1, 4)</code> returns an uninitialized <code>Array{Int,2}</code> since ranges are neither mutable nor support 2 dimensions:</p>
<pre data-language="julia">julia&gt; similar(1:10, 1, 4)
1×4 Array{Int64,2}:
 4419743872  4374413872  4419743888  0</pre>
<p>Conversely, <code>similar(trues(10,10), 2)</code> returns an uninitialized <code>BitVector</code> with two elements since <code>BitArray</code>s are both mutable and can support 1-dimensional arrays:</p>
<pre data-language="julia">julia&gt; similar(trues(10,10), 2)
2-element BitArray{1}:
 0
 0</pre>
<p>Since <code>BitArray</code>s can only store elements of type <a href="../numbers/index#Core.Bool"><code>Bool</code></a>, however, if you request a different element type it will create a regular <code>Array</code> instead:</p>
<pre data-language="julia">julia&gt; similar(falses(10), Float64, 2, 4)
2×4 Array{Float64,2}:
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L583-L624">source</a><pre data-language="julia">similar(storagetype, axes)</pre>
<p>Create an uninitialized mutable array analogous to that specified by <code>storagetype</code>, but with <code>axes</code> specified by the last argument. <code>storagetype</code> might be a type or a function.</p>
<p><strong>Examples</strong>:</p>
<pre data-language="julia">similar(Array{Int}, axes(A))</pre>
<p>creates an array that "acts like" an <code>Array{Int}</code> (and might indeed be backed by one), but which is indexed identically to <code>A</code>. If <code>A</code> has conventional indexing, this will be identical to <code>Array{Int}(undef, size(A))</code>, but if <code>A</code> has unconventional indexing then the indices of the result will match <code>A</code>.</p>
<pre data-language="julia">similar(BitArray, (axes(A, 2),))</pre>
<p>would create a 1-dimensional logical array whose indices match those of the columns of <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L648-L669">source</a><h2 id="Basic-functions-1">Basic functions</h2>
<h3 id="Base.ndims">
<code>Base.ndims</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">ndims(A::AbstractArray) -&gt; Integer</pre>
<p>Return the number of dimensions of <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = fill(1, (3,4,5));

julia&gt; ndims(A)
3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L155-L167">source</a><h3 id="Base.size">
<code>Base.size</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">size(A::AbstractArray, [dim])</pre>
<p>Return a tuple containing the dimensions of <code>A</code>. Optionally you can specify a dimension to just get the length of that dimension.</p>
<p>Note that <code>size</code> may not be defined for arrays with non-standard indices, in which case <a href="#Base.axes-Tuple%7BAny%7D"><code>axes</code></a> may be useful. See the manual chapter on <a href="https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1">arrays with custom indices</a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = fill(1, (2,3,4));

julia&gt; size(A)
(2, 3, 4)

julia&gt; size(A, 2)
3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L18-L37">source</a><h3 id="Base.axes-Tuple{Any}">
<code>Base.axes</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">axes(A)</pre>
<p>Return the tuple of valid indices for array <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = fill(1, (5,6,7));

julia&gt; axes(A)
(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L60-L72">source</a><h3 id="Base.axes-Tuple{AbstractArray,Any}">
<code>Base.axes</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">axes(A, d)</pre>
<p>Return the valid range of indices for array <code>A</code> along dimension <code>d</code>.</p>
<p>See also <a href="#Base.size"><code>size</code></a>, and the manual chapter on <a href="https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1">arrays with custom indices</a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = fill(1, (5,6,7));

julia&gt; axes(A, 2)
Base.OneTo(6)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L40-L54">source</a><h3 id="Base.length-Tuple{AbstractArray}">
<code>Base.length</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">length(A::AbstractArray)</pre>
<p>Return the number of elements in the array, defaults to <code>prod(size(A))</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; length([1, 2, 3, 4])
4

julia&gt; length([1 2; 3 4])
4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L192-L205">source</a><h3 id="Base.eachindex">
<code>Base.eachindex</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">eachindex(A...)</pre>
<p>Create an iterable object for visiting each index of an <code>AbstractArray</code> <code>A</code> in an efficient manner. For array types that have opted into fast linear indexing (like <code>Array</code>), this is simply the range <code>1:length(A)</code>. For other array types, return a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, return an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).</p>
<p>If you supply more than one <code>AbstractArray</code> argument, <code>eachindex</code> will create an iterable object that is fast for all arguments (a <a href="../collections/index#Base.UnitRange"><code>UnitRange</code></a> if all inputs have fast linear indexing, a <a href="#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a> otherwise). If the arrays have different sizes and/or dimensionalities, <code>eachindex</code> will return an iterable that spans the largest range along each dimension.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1 2; 3 4];

julia&gt; for i in eachindex(A) # linear indexing
           println(i)
       end
1
2
3
4

julia&gt; for i in eachindex(view(A, 1:2, 1:1)) # Cartesian indexing
           println(i)
       end
CartesianIndex(1, 1)
CartesianIndex(2, 1)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L221-L256">source</a><h3 id="Base.IndexStyle">
<code>Base.IndexStyle</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">IndexStyle(A)
IndexStyle(typeof(A))</pre>
<p><code>IndexStyle</code> specifies the "native indexing style" for array <code>A</code>. When you define a new <a href="#Core.AbstractArray"><code>AbstractArray</code></a> type, you can choose to implement either linear indexing (with <a href="#Base.IndexLinear"><code>IndexLinear</code></a>) or cartesian indexing. If you decide to implement linear indexing, then you must set this trait for your array type:</p>
<pre data-language="julia">Base.IndexStyle(::Type{&lt;:MyArray}) = IndexLinear()</pre>
<p>The default is <a href="#Base.IndexCartesian"><code>IndexCartesian()</code></a>.</p>
<p>Julia's internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</p>
<p>If you define both styles of indexing for your <code>AbstractArray</code>, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, <a href="#Base.eachindex"><code>eachindex</code></a> creates an iterator whose type depends on the setting of this trait.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/indices.jl#L44-L69">source</a><h3 id="Base.IndexLinear">
<code>Base.IndexLinear</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">IndexLinear()</pre>
<p>Subtype of <a href="#Base.IndexStyle"><code>IndexStyle</code></a> used to describe arrays which are optimally indexed by one linear index.</p>
<p>A linear indexing style uses one integer to describe the position in the array (even if it's a multidimensional array) and column-major ordering is used to access the elements. For example, if <code>A</code> were a <code>(2, 3)</code> custom matrix type with linear indexing, and we referenced <code>A[5]</code> (using linear style), this would be equivalent to referencing <code>A[1, 3]</code> (since <code>2*1 + 3 = 5</code>). See also <a href="#Base.IndexCartesian"><code>IndexCartesian</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/indices.jl#L16-L29">source</a><h3 id="Base.IndexCartesian">
<code>Base.IndexCartesian</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">IndexCartesian()</pre>
<p>Subtype of <a href="#Base.IndexStyle"><code>IndexStyle</code></a> used to describe arrays which are optimally indexed by a Cartesian index.</p>
<p>A cartesian indexing style uses multiple integers/indices to describe the position in the array. For example, if <code>A</code> were a <code>(2, 3, 4)</code> custom matrix type with cartesian indexing, we could reference <code>A[2, 1, 3]</code> and Julia would automatically convert this into the correct location in the underlying memory. See also <a href="#Base.IndexLinear"><code>IndexLinear</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/indices.jl#L31-L41">source</a><h3 id="Base.conj!">
<code>Base.conj!</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">conj!(A)</pre>
<p>Transform an array to its complex conjugate in-place.</p>
<p>See also <a href="../math/index#Base.conj"><code>conj</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1+im 2-im; 2+2im 3+im]
2×2 Array{Complex{Int64},2}:
 1+1im  2-1im
 2+2im  3+1im

julia&gt; conj!(A);

julia&gt; A
2×2 Array{Complex{Int64},2}:
 1-1im  2+1im
 2-2im  3-1im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/arraymath.jl#L5-L26">source</a><h3 id="Base.stride">
<code>Base.stride</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">stride(A, k::Integer)</pre>
<p>Return the distance in memory (in number of elements) between adjacent elements in dimension <code>k</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = fill(1, (3,4,5));

julia&gt; stride(A,2)
3

julia&gt; stride(A,3)
12</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L380-L395">source</a><h3 id="Base.strides">
<code>Base.strides</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">strides(A)</pre>
<p>Return a tuple of the memory strides in each dimension.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = fill(1, (3,4,5));

julia&gt; strides(A)
(1, 3, 12)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L365-L377">source</a><h2 id="Broadcast-and-vectorization-1">Broadcast and vectorization</h2>
<p>See also the <a href="../../manual/functions/index#man-vectorized-1">dot syntax for vectorizing functions</a>; for example, <code>f.(args...)</code> implicitly calls <code>broadcast(f, args...)</code>. Rather than relying on "vectorized" methods of functions like <code>sin</code> to operate on arrays, you should use <code>sin.(a)</code> to vectorize via <code>broadcast</code>.</p>
<h3 id="Base.Broadcast.broadcast">
<code>Base.Broadcast.broadcast</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">broadcast(f, As...)</pre>
<p>Broadcast the function <code>f</code> over the arrays, tuples, collections, <a href="../c/index#Core.Ref"><code>Ref</code></a>s and/or scalars <code>As</code>.</p>
<p>Broadcasting applies the function <code>f</code> over the elements of the container arguments and the scalars themselves in <code>As</code>. Singleton and missing dimensions are expanded to match the extents of the other arguments by virtually repeating the value. By default, only a limited number of types are considered scalars, including <code>Number</code>s, <code>String</code>s, <code>Symbol</code>s, <code>Type</code>s, <code>Function</code>s and some common singletons like <a href="../base/index#Base.missing"><code>missing</code></a> and <a href="../constants/index#Core.nothing"><code>nothing</code></a>. All other arguments are iterated over or indexed into elementwise.</p>
<p>The resulting container type is established by the following rules:</p>
<ul>
<li>If all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.</li>
<li>If at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.</li>
<li>All other combinations of arguments default to returning an <code>Array</code>, but custom container types can define their own implementation and promotion-like rules to customize the result when they appear as arguments.</li>
</ul>
<p>A special syntax exists for broadcasting: <code>f.(args...)</code> is equivalent to <code>broadcast(f, args...)</code>, and nested <code>f.(g.(args...))</code> calls are fused into a single broadcast loop.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1, 2, 3, 4, 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; B = [1 2; 3 4; 5 6; 7 8; 9 10]
5×2 Array{Int64,2}:
 1   2
 3   4
 5   6
 7   8
 9  10

julia&gt; broadcast(+, A, B)
5×2 Array{Int64,2}:
  2   3
  5   6
  8   9
 11  12
 14  15

julia&gt; parse.(Int, ["1", "2"])
2-element Array{Int64,1}:
 1
 2

julia&gt; abs.((1, -2))
(1, 2)

julia&gt; broadcast(+, 1.0, (0, -2.0))
(1.0, -1.0)

julia&gt; (+).([[0,2], [1,3]], Ref{Vector{Int}}([1,-1]))
2-element Array{Array{Int64,1},1}:
 [1, 1]
 [2, 2]

julia&gt; string.(("one","two","three","four"), ": ", 1:4)
4-element Array{String,1}:
 "one: 1"
 "two: 2"
 "three: 3"
 "four: 4"
</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/broadcast.jl#L676-L751">source</a><h3 id="Base.Broadcast.broadcast!">
<code>Base.Broadcast.broadcast!</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">broadcast!(f, dest, As...)</pre>
<p>Like <a href="#Base.Broadcast.broadcast"><code>broadcast</code></a>, but store the result of <code>broadcast(f, As...)</code> in the <code>dest</code> array. Note that <code>dest</code> is only used to store the result, and does not supply arguments to <code>f</code> unless it is also listed in the <code>As</code>, as in <code>broadcast!(f, A, A, B)</code> to perform <code>A[:] = broadcast(f, A, B)</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1.0; 0.0]; B = [0.0; 0.0];

julia&gt; broadcast!(+, B, A, (0, -2.0));

julia&gt; B
2-element Array{Float64,1}:
  1.0
 -2.0

julia&gt; A
2-element Array{Float64,1}:
 1.0
 0.0

julia&gt; broadcast!(+, A, A, (0, -2.0));

julia&gt; A
2-element Array{Float64,1}:
  1.0
 -2.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/broadcast.jl#L758-L790">source</a><h3 id="Base.Broadcast.@__dot__">
<code>Base.Broadcast.@__dot__</code><span class="docstring-category">Macro</span>
</h3>
<pre data-language="julia">@. expr</pre>
<p>Convert every function call or operator in <code>expr</code> into a "dot call" (e.g. convert <code>f(x)</code> to <code>f.(x)</code>), and convert every assignment in <code>expr</code> to a "dot assignment" (e.g. convert <code>+=</code> to <code>.+=</code>).</p>
<p>If you want to <em>avoid</em> adding dots for selected function calls in <code>expr</code>, splice those function calls in with <code>$</code>. For example, <code>@. sqrt(abs($sort(x)))</code> is equivalent to <code>sqrt.(abs.(sort(x)))</code> (no dot for <code>sort</code>).</p>
<p>(<code>@.</code> is equivalent to a call to <code>@__dot__</code>.)</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; x = 1.0:3.0; y = similar(x);

julia&gt; @. y = x + 3 * sin(x)
3-element Array{Float64,1}:
 3.5244129544236893
 4.727892280477045
 3.4233600241796016</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/broadcast.jl#L1169-L1193">source</a><p>For specializing broadcast on custom types, see</p>
<h3 id="Base.Broadcast.BroadcastStyle">
<code>Base.Broadcast.BroadcastStyle</code><span class="docstring-category">Type</span>
</h3>
<p><code>BroadcastStyle</code> is an abstract type and trait-function used to determine behavior of objects under broadcasting. <code>BroadcastStyle(typeof(x))</code> returns the style associated with <code>x</code>. To customize the broadcasting behavior of a type, one can declare a style by defining a type/method pair</p>
<pre data-language="julia">struct MyContainerStyle &lt;: BroadcastStyle end
Base.BroadcastStyle(::Type{&lt;:MyContainer}) = MyContainerStyle()</pre>
<p>One then writes method(s) (at least <a href="#Base.similar"><code>similar</code></a>) operating on <code>Broadcasted{MyContainerStyle}</code>. There are also several pre-defined subtypes of <code>BroadcastStyle</code> that you may be able to leverage; see the <a href="../../manual/interfaces/index#man-interfaces-broadcasting-1">Interfaces chapter</a> for more information.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/broadcast.jl#L21-L34">source</a><h3 id="Base.Broadcast.AbstractArrayStyle">
<code>Base.Broadcast.AbstractArrayStyle</code><span class="docstring-category">Type</span>
</h3>
<p><code>Broadcast.AbstractArrayStyle{N} &lt;: BroadcastStyle</code> is the abstract supertype for any style associated with an <code>AbstractArray</code> type. The <code>N</code> parameter is the dimensionality, which can be handy for AbstractArray types that only support specific dimensionalities:</p>
<pre data-language="julia">struct SparseMatrixStyle &lt;: Broadcast.AbstractArrayStyle{2} end
Base.BroadcastStyle(::Type{&lt;:SparseMatrixCSC}) = SparseMatrixStyle()</pre>
<p>For <code>AbstractArray</code> types that support arbitrary dimensionality, <code>N</code> can be set to <code>Any</code>:</p>
<pre data-language="julia">struct MyArrayStyle &lt;: Broadcast.AbstractArrayStyle{Any} end
Base.BroadcastStyle(::Type{&lt;:MyArray}) = MyArrayStyle()</pre>
<p>In cases where you want to be able to mix multiple <code>AbstractArrayStyle</code>s and keep track of dimensionality, your style needs to support a <a href="../base/index#Base.Val"><code>Val</code></a> constructor:</p>
<pre data-language="julia">struct MyArrayStyleDim{N} &lt;: Broadcast.AbstractArrayStyle{N} end
(::Type{&lt;:MyArrayStyleDim})(::Val{N}) where N = MyArrayStyleDim{N}()</pre>
<p>Note that if two or more <code>AbstractArrayStyle</code> subtypes conflict, broadcasting machinery will fall back to producing <code>Array</code>s. If this is undesirable, you may need to define binary <a href="#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a> rules to control the output type.</p>
<p>See also <a href="#Base.Broadcast.DefaultArrayStyle"><code>Broadcast.DefaultArrayStyle</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/broadcast.jl#L51-L76">source</a><h3 id="Base.Broadcast.ArrayStyle">
<code>Base.Broadcast.ArrayStyle</code><span class="docstring-category">Type</span>
</h3>
<p><code>Broadcast.ArrayStyle{MyArrayType}()</code> is a <a href="#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a> indicating that an object behaves as an array for broadcasting. It presents a simple way to construct <a href="#Base.Broadcast.AbstractArrayStyle"><code>Broadcast.AbstractArrayStyle</code></a>s for specific <code>AbstractArray</code> container types. Broadcast styles created this way lose track of dimensionality; if keeping track is important for your type, you should create your own custom <a href="#Base.Broadcast.AbstractArrayStyle"><code>Broadcast.AbstractArrayStyle</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/broadcast.jl#L79-L85">source</a><h3 id="Base.Broadcast.DefaultArrayStyle">
<code>Base.Broadcast.DefaultArrayStyle</code><span class="docstring-category">Type</span>
</h3>
<p><code>Broadcast.DefaultArrayStyle{N}()</code> is a <a href="#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a> indicating that an object behaves as an <code>N</code>-dimensional array for broadcasting. Specifically, <code>DefaultArrayStyle</code> is used for any <code>AbstractArray</code> type that hasn't defined a specialized style, and in the absence of overrides from other <code>broadcast</code> arguments the resulting output type is <code>Array</code>. When there are multiple inputs to <code>broadcast</code>, <code>DefaultArrayStyle</code> "loses" to any other <a href="#Base.Broadcast.ArrayStyle"><code>Broadcast.ArrayStyle</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/broadcast.jl#L89-L96">source</a><h3 id="Base.Broadcast.broadcastable">
<code>Base.Broadcast.broadcastable</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">Broadcast.broadcastable(x)</pre>
<p>Return either <code>x</code> or an object like <code>x</code> such that it supports <a href="#Base.axes-Tuple%7BAny%7D"><code>axes</code></a>, indexing, and its type supports <a href="#Base.ndims"><code>ndims</code></a>.</p>
<p>If <code>x</code> supports iteration, the returned value should have the same <code>axes</code> and indexing behaviors as <a href="#"><code>collect(x)</code></a>.</p>
<p>If <code>x</code> is not an <code>AbstractArray</code> but it supports <code>axes</code>, indexing, and its type supports <code>ndims</code>, then <code>broadcastable(::typeof(x))</code> may be implemented to just return itself. Further, if <code>x</code> defines its own <a href="#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a>, then it must define its <code>broadcastable</code> method to return itself for the custom style to have any effect.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Broadcast.broadcastable([1,2,3]) # like `identity` since arrays already support axes and indexing
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; Broadcast.broadcastable(Int) # Types don't support axes, indexing, or iteration but are commonly used as scalars
Base.RefValue{Type{Int64}}(Int64)

julia&gt; Broadcast.broadcastable("hello") # Strings break convention of matching iteration and act like a scalar instead
Base.RefValue{String}("hello")</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/broadcast.jl#L627-L654">source</a><h3 id="Base.Broadcast.combine_axes">
<code>Base.Broadcast.combine_axes</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">combine_axes(As...) -&gt; Tuple</pre>
<p>Determine the result axes for broadcasting across all values in <code>As</code>.</p>
<pre data-language="julia">julia&gt; Broadcast.combine_axes([1], [1 2; 3 4; 5 6])
(Base.OneTo(3), Base.OneTo(2))

julia&gt; Broadcast.combine_axes(1, 1, 1)
()</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/broadcast.jl#L455-L467">source</a><h3 id="Base.Broadcast.combine_styles">
<code>Base.Broadcast.combine_styles</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">combine_styles(cs...) -&gt; BroadcastStyle</pre>
<p>Decides which <code>BroadcastStyle</code> to use for any number of value arguments. Uses <a href="#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a> to get the style for each argument, and uses <a href="#Base.Broadcast.result_style"><code>result_style</code></a> to combine styles.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Broadcast.combine_styles([1], [1 2; 3 4])
Base.Broadcast.DefaultArrayStyle{2}()</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/broadcast.jl#L388-L401">source</a><h3 id="Base.Broadcast.result_style">
<code>Base.Broadcast.result_style</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">result_style(s1::BroadcastStyle[, s2::BroadcastStyle]) -&gt; BroadcastStyle</pre>
<p>Takes one or two <code>BroadcastStyle</code>s and combines them using <a href="#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a> to determine a common <code>BroadcastStyle</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; Broadcast.result_style(Broadcast.DefaultArrayStyle{0}(), Broadcast.DefaultArrayStyle{3}())
Base.Broadcast.DefaultArrayStyle{3}()

julia&gt; Broadcast.result_style(Broadcast.Unknown(), Broadcast.DefaultArrayStyle{1}())
Base.Broadcast.DefaultArrayStyle{1}()</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/broadcast.jl#L409-L424">source</a><h2 id="Indexing-and-assignment-1">Indexing and assignment</h2>
<h3 id="Base.getindex-Tuple{AbstractArray,Vararg{Any,N} where N}">
<code>Base.getindex</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">getindex(A, inds...)</pre>
<p>Return a subset of array <code>A</code> as specified by <code>inds</code>, where each <code>ind</code> may be an <code>Int</code>, an <a href="../collections/index#Base.AbstractRange"><code>AbstractRange</code></a>, or a <a href="#Base.Vector"><code>Vector</code></a>. See the manual section on <a href="../../manual/arrays/index#man-array-indexing-1">array indexing</a> for details.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; getindex(A, 1)
1

julia&gt; getindex(A, [2, 1])
2-element Array{Int64,1}:
 3
 1

julia&gt; getindex(A, 2:4)
3-element Array{Int64,1}:
 3
 2
 4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L949-L977">source</a><h3 id="Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}">
<code>Base.setindex!</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">setindex!(A, X, inds...)
A[inds...] = X</pre>
<p>Store values from array <code>X</code> within some subset of <code>A</code> as specified by <code>inds</code>. The syntax <code>A[inds...] = X</code> is equivalent to <code>setindex!(A, X, inds...)</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = zeros(2,2);

julia&gt; setindex!(A, [10, 20], [1, 2]);

julia&gt; A[[3, 4]] = [30, 40];

julia&gt; A
2×2 Array{Float64,2}:
 10.0  30.0
 20.0  40.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L1050-L1070">source</a><h3 id="Base.copyto!-Tuple{AbstractArray,CartesianIndices,AbstractArray,CartesianIndices}">
<code>Base.copyto!</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -&gt; dest</pre>
<p>Copy the block of <code>src</code> in the range of <code>Rsrc</code> to the block of <code>dest</code> in the range of <code>Rdest</code>. The sizes of the two regions must match.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/multidimensional.jl#L936-L941">source</a><h3 id="Base.isassigned">
<code>Base.isassigned</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">isassigned(array, i) -&gt; Bool</pre>
<p>Test whether the given array has a value associated with index <code>i</code>. Return <code>false</code> if the index is out of bounds, or has an undefined reference.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; isassigned(rand(3, 3), 5)
true

julia&gt; isassigned(rand(3, 3), 3 * 3 + 1)
false

julia&gt; mutable struct Foo end

julia&gt; v = similar(rand(3), Foo)
3-element Array{Foo,1}:
 #undef
 #undef
 #undef

julia&gt; isassigned(v, 1)
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/essentials.jl#L623-L648">source</a><h3 id="Base.Colon">
<code>Base.Colon</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">Colon()</pre>
<p>Colons (:) are used to signify indexing entire objects or dimensions at once.</p>
<p>Very few operations are defined on Colons directly; instead they are converted by <a href="#Base.to_indices"><code>to_indices</code></a> to an internal vector type (<code>Base.Slice</code>) to represent the collection of indices they span before being used.</p>
<p>The singleton instance of <code>Colon</code> is also a function used to construct ranges; see <a href="../math/index#Base.::"><code>:</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/essentials.jl#L737-L748">source</a><h3 id="Base.IteratorsMD.CartesianIndex">
<code>Base.IteratorsMD.CartesianIndex</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">CartesianIndex(i, j, k...)   -&gt; I
CartesianIndex((i, j, k...)) -&gt; I</pre>
<p>Create a multidimensional index <code>I</code>, which can be used for indexing a multidimensional array <code>A</code>. In particular, <code>A[I]</code> is equivalent to <code>A[i,j,k...]</code>. One can freely mix integer and <code>CartesianIndex</code> indices; for example, <code>A[Ipre, i, Ipost]</code> (where <code>Ipre</code> and <code>Ipost</code> are <code>CartesianIndex</code> indices and <code>i</code> is an <code>Int</code>) can be a useful expression when writing algorithms that work along a single dimension of an array of arbitrary dimensionality.</p>
<p>A <code>CartesianIndex</code> is sometimes produced by <a href="#Base.eachindex"><code>eachindex</code></a>, and always when iterating with an explicit <a href="#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = reshape(Vector(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; A[CartesianIndex((1, 1, 1, 1))]
1

julia&gt; A[CartesianIndex((1, 1, 1, 2))]
9

julia&gt; A[CartesianIndex((1, 1, 2, 1))]
5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/multidimensional.jl#L16-L61">source</a><h3 id="Base.IteratorsMD.CartesianIndices">
<code>Base.IteratorsMD.CartesianIndices</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">CartesianIndices(sz::Dims) -&gt; R
CartesianIndices((istart:istop, jstart:jstop, ...)) -&gt; R</pre>
<p>Define a region <code>R</code> spanning a multidimensional rectangular range of integer indices. These are most commonly encountered in the context of iteration, where <code>for I in R ... end</code> will return <a href="#Base.IteratorsMD.CartesianIndex"><code>CartesianIndex</code></a> indices <code>I</code> equivalent to the nested loops</p>
<pre data-language="julia">for j = jstart:jstop
    for i = istart:istop
        ...
    end
end</pre>
<p>Consequently these can be useful for writing algorithms that work in arbitrary dimensions.</p>
<pre data-language="julia">CartesianIndices(A::AbstractArray) -&gt; R</pre>
<p>As a convenience, constructing a <code>CartesianIndices</code> from an array makes a range of its indices.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; foreach(println, CartesianIndices((2, 2, 2)))
CartesianIndex(1, 1, 1)
CartesianIndex(2, 1, 1)
CartesianIndex(1, 2, 1)
CartesianIndex(2, 2, 1)
CartesianIndex(1, 1, 2)
CartesianIndex(2, 1, 2)
CartesianIndex(1, 2, 2)
CartesianIndex(2, 2, 2)

julia&gt; CartesianIndices(fill(1, (2,3)))
2×3 CartesianIndices{2,Tuple{Base.OneTo{Int64},Base.OneTo{Int64}}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)  CartesianIndex(1, 3)
 CartesianIndex(2, 1)  CartesianIndex(2, 2)  CartesianIndex(2, 3)</pre>
<p><strong>Conversion between linear and cartesian indices</strong></p>
<p>Linear index to cartesian index conversion exploits the fact that a <code>CartesianIndices</code> is an <code>AbstractArray</code> and can be indexed linearly:</p>
<pre data-language="julia">julia&gt; cartesian = CartesianIndices((1:3, 1:2))
3×2 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)
 CartesianIndex(2, 1)  CartesianIndex(2, 2)
 CartesianIndex(3, 1)  CartesianIndex(3, 2)

julia&gt; cartesian[4]
CartesianIndex(1, 2)</pre>
<p><strong>Broadcasting</strong></p>
<p><code>CartesianIndices</code> support broadcasting arithmetic (+ and -) with a <code>CartesianIndex</code>.</p>
<div class="admonition compat">
<div class="admonition-title">Julia 1.1</div>
<div class="admonition-text"><p>Broadcasting of CartesianIndices requires at least Julia 1.1.</p></div>
</div>
<pre data-language="julia">julia&gt; CIs = CartesianIndices((2:3, 5:6))
2×2 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 CartesianIndex(2, 5)  CartesianIndex(2, 6)
 CartesianIndex(3, 5)  CartesianIndex(3, 6)

julia&gt; CI = CartesianIndex(3, 4)
CartesianIndex(3, 4)

julia&gt; CIs .+ CI
2×2 CartesianIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 CartesianIndex(5, 9)  CartesianIndex(5, 10)
 CartesianIndex(6, 9)  CartesianIndex(6, 10)</pre>
<p>For cartesian to linear index conversion, see <a href="#Base.LinearIndices"><code>LinearIndices</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/multidimensional.jl#L165-L245">source</a><h3 id="Base.Dims">
<code>Base.Dims</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">Dims{N}</pre>
<p>An <code>NTuple</code> of <code>N</code> <code>Int</code>s used to represent the dimensions of an <a href="#Core.AbstractArray"><code>AbstractArray</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/indices.jl#L3-L8">source</a><h3 id="Base.LinearIndices">
<code>Base.LinearIndices</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">LinearIndices(A::AbstractArray)</pre>
<p>Return a <code>LinearIndices</code> array with the same shape and <a href="#Base.axes-Tuple%7BAny%7D"><code>axes</code></a> as <code>A</code>, holding the linear index of each entry in <code>A</code>. Indexing this array with cartesian indices allows mapping them to linear indices.</p>
<p>For arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices range from 1 to <code>length(A)</code>. However, for <code>AbstractVector</code>s linear indices are <code>axes(A, 1)</code>, and therefore do not start at 1 for vectors with unconventional indexing.</p>
<p>Calling this function is the "safe" way to write algorithms that exploit linear indexing.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = fill(1, (5,6,7));

julia&gt; b = LinearIndices(A);

julia&gt; extrema(b)
(1, 210)</pre>
<pre data-language="julia">LinearIndices(inds::CartesianIndices) -&gt; R
LinearIndices(sz::Dims) -&gt; R
LinearIndices((istart:istop, jstart:jstop, ...)) -&gt; R</pre>
<p>Return a <code>LinearIndices</code> array with the specified shape or <a href="#Base.axes-Tuple%7BAny%7D"><code>axes</code></a>.</p>
<p><strong>Example</strong></p>
<p>The main purpose of this constructor is intuitive conversion from cartesian to linear indexing:</p>
<pre data-language="julia">julia&gt; linear = LinearIndices((1:3, 1:2))
3×2 LinearIndices{2,Tuple{UnitRange{Int64},UnitRange{Int64}}}:
 1  4
 2  5
 3  6

julia&gt; linear[1,2]
4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/indices.jl#L369-L415">source</a><h3 id="Base.to_indices">
<code>Base.to_indices</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">to_indices(A, I::Tuple)</pre>
<p>Convert the tuple <code>I</code> to a tuple of indices for use in indexing into array <code>A</code>.</p>
<p>The returned tuple must only contain either <code>Int</code>s or <code>AbstractArray</code>s of scalar indices that are supported by array <code>A</code>. It will error upon encountering a novel index type that it does not know how to process.</p>
<p>For simple index types, it defers to the unexported <code>Base.to_index(A, i)</code> to process each index <code>i</code>. While this internal function is not intended to be called directly, <code>Base.to_index</code> may be extended by custom array or index types to provide custom indexing behaviors.</p>
<p>More complicated index types may require more context about the dimension into which they index. To support those cases, <code>to_indices(A, I)</code> calls <code>to_indices(A, axes(A), I)</code>, which then recursively walks through both the given tuple of indices and the dimensional indices of <code>A</code> in tandem. As such, not all index types are guaranteed to propagate to <code>Base.to_index</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/indices.jl#L274-L293">source</a><h3 id="Base.checkbounds">
<code>Base.checkbounds</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">checkbounds(Bool, A, I...)</pre>
<p>Return <code>true</code> if the specified indices <code>I</code> are in bounds for the given array <code>A</code>. Subtypes of <code>AbstractArray</code> should specialize this method if they need to provide custom bounds checking behaviors; however, in many cases one can rely on <code>A</code>'s indices and <a href="#Base.checkindex"><code>checkindex</code></a>.</p>
<p>See also <a href="#Base.checkindex"><code>checkindex</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = rand(3, 3);

julia&gt; checkbounds(Bool, A, 2)
true

julia&gt; checkbounds(Bool, A, 3, 4)
false

julia&gt; checkbounds(Bool, A, 1:3)
true

julia&gt; checkbounds(Bool, A, 1:3, 2:4)
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L453-L479">source</a><pre data-language="julia">checkbounds(A, I...)</pre>
<p>Throw an error if the specified indices <code>I</code> are not in bounds for the given array <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L496-L500">source</a><h3 id="Base.checkindex">
<code>Base.checkindex</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">checkindex(Bool, inds::AbstractUnitRange, index)</pre>
<p>Return <code>true</code> if the given <code>index</code> is within the bounds of <code>inds</code>. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; checkindex(Bool, 1:20, 8)
true

julia&gt; checkindex(Bool, 1:20, 21)
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L541-L557">source</a><h2 id="Views-(SubArrays-and-other-view-types)-1">Views (SubArrays and other view types)</h2>
<h3 id="Base.view">
<code>Base.view</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">view(A, inds...)</pre>
<p>Like <a href="../collections/index#Base.getindex"><code>getindex</code></a>, but returns a view into the parent array <code>A</code> with the given indices instead of making a copy. Calling <a href="../collections/index#Base.getindex"><code>getindex</code></a> or <a href="../collections/index#Base.setindex!"><code>setindex!</code></a> on the returned <code>SubArray</code> computes the indices to the parent array on the fly without checking bounds.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; b = view(A, :, 1)
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 1
 3

julia&gt; fill!(b, 0)
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 0
 0

julia&gt; A # Note A has changed even though we modified b
2×2 Array{Int64,2}:
 0  2
 0  4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/subarray.jl#L123-L153">source</a><h3 id="Base.@view">
<code>Base.@view</code><span class="docstring-category">Macro</span>
</h3>
<pre data-language="julia">@view A[inds...]</pre>
<p>Creates a <code>SubArray</code> from an indexing expression. This can only be applied directly to a reference expression (e.g. <code>@view A[1,2:end]</code>), and should <em>not</em> be used as the target of an assignment (e.g. <code>@view(A[1,2:end]) = ...</code>). See also <a href="#Base.@views"><code>@views</code></a> to switch an entire block of code to use views for slicing.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; b = @view A[:, 1]
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 1
 3

julia&gt; fill!(b, 0)
2-element view(::Array{Int64,2}, :, 1) with eltype Int64:
 0
 0

julia&gt; A
2×2 Array{Int64,2}:
 0  2
 0  4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/views.jl#L72-L102">source</a><h3 id="Base.@views">
<code>Base.@views</code><span class="docstring-category">Macro</span>
</h3>
<pre data-language="julia">@views expression</pre>
<p>Convert every array-slicing operation in the given expression (which may be a <code>begin</code>/<code>end</code> block, loop, function, etc.) to return a view. Scalar indices, non-array types, and explicit <code>getindex</code> calls (as opposed to <code>array[...]</code>) are unaffected.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>The <code>@views</code> macro only affects <code>array[...]</code> expressions that appear explicitly in the given <code>expression</code>, not array slicing that occurs in functions called by that code.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = zeros(3, 3);

julia&gt; @views for row in 1:3
           b = A[row, :]
           b[:] .= row
       end

julia&gt; A
3×3 Array{Float64,2}:
 1.0  1.0  1.0
 2.0  2.0  2.0
 3.0  3.0  3.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/views.jl#L183-L212">source</a><h3 id="Base.parent">
<code>Base.parent</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">parent(A)</pre>
<p>Returns the "parent array" of an array view type (e.g., <code>SubArray</code>), or the array itself if it is not a view.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; V = view(A, 1:2, :)
2×2 view(::Array{Int64,2}, 1:2, :) with eltype Int64:
 1  2
 3  4

julia&gt; parent(V)
2×2 Array{Int64,2}:
 1  2
 3  4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L1113-L1136">source</a><h3 id="Base.parentindices">
<code>Base.parentindices</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">parentindices(A)</pre>
<p>Return the indices in the <a href="#Base.parent"><code>parent</code></a> which correspond to the array view <code>A</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1 2; 3 4];

julia&gt; V = view(A, 1, :)
2-element view(::Array{Int64,2}, 1, :) with eltype Int64:
 1
 2

julia&gt; parentindices(V)
(1, Base.Slice(Base.OneTo(2)))</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/subarray.jl#L76-L93">source</a><h3 id="Base.selectdim">
<code>Base.selectdim</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">selectdim(A, d::Integer, i)</pre>
<p>Return a view of all the data of <code>A</code> where the index for dimension <code>d</code> equals <code>i</code>.</p>
<p>Equivalent to <code>view(A,:,:,...,i,:,:,...)</code> where <code>i</code> is in position <code>d</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1 2 3 4; 5 6 7 8]
2×4 Array{Int64,2}:
 1  2  3  4
 5  6  7  8

julia&gt; selectdim(A, 2, 3)
2-element view(::Array{Int64,2}, :, 3) with eltype Int64:
 3
 7</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarraymath.jl#L102-L121">source</a><h3 id="Base.reinterpret">
<code>Base.reinterpret</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">reinterpret(type, A)</pre>
<p>Change the type-interpretation of a block of memory. For arrays, this constructs a view of the array with the same binary data as the given array, but with the specified element type. For example, <code>reinterpret(Float32, UInt32(7))</code> interprets the 4 bytes corresponding to <code>UInt32(7)</code> as a <a href="../numbers/index#Core.Float32"><code>Float32</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; reinterpret(Float32, UInt32(7))
1.0f-44

julia&gt; reinterpret(Float32, UInt32[1 2 3 4 5])
1×5 reinterpret(Float32, ::Array{UInt32,2}):
 1.4013e-45  2.8026e-45  4.2039e-45  5.60519e-45  7.00649e-45</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/essentials.jl#L397-L416">source</a><h3 id="Base.reshape">
<code>Base.reshape</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">reshape(A, dims...) -&gt; AbstractArray
reshape(A, dims) -&gt; AbstractArray</pre>
<p>Return an array with the same data as <code>A</code>, but with different dimension sizes or number of dimensions. The two arrays share the same underlying data, so that the result is mutable if and only if <code>A</code> is mutable, and setting elements of one alters the values of the other.</p>
<p>The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a <code>:</code>, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array <code>A</code>. The total number of elements must not change.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = Vector(1:16)
16-element Array{Int64,1}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16

julia&gt; reshape(A, (4, 4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; reshape(A, 2, :)
2×8 Array{Int64,2}:
 1  3  5  7   9  11  13  15
 2  4  6  8  10  12  14  16

julia&gt; reshape(1:6, 2, 3)
2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:
 1  3  5
 2  4  6</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/reshapedarray.jl#L54-L107">source</a><h3 id="Base.dropdims">
<code>Base.dropdims</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">dropdims(A; dims)</pre>
<p>Remove the dimensions specified by <code>dims</code> from array <code>A</code>. Elements of <code>dims</code> must be unique and within the range <code>1:ndims(A)</code>. <code>size(A,i)</code> must equal 1 for all <code>i</code> in <code>dims</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = reshape(Vector(1:4),(2,2,1,1))
2×2×1×1 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

julia&gt; dropdims(a; dims=3)
2×2×1 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarraymath.jl#L48-L69">source</a><h3 id="Base.vec">
<code>Base.vec</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">vec(a::AbstractArray) -&gt; AbstractVector</pre>
<p>Reshape the array <code>a</code> as a one-dimensional column vector. Return <code>a</code> if it is already an <code>AbstractVector</code>. The resulting array shares the same underlying data as <code>a</code>, so it will only be mutable if <code>a</code> is mutable, in which case modifying one will also modify the other.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; vec(a)
6-element Array{Int64,1}:
 1
 4
 2
 5
 3
 6

julia&gt; vec(1:3)
1:3</pre>
<p>See also <a href="#Base.reshape"><code>reshape</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarraymath.jl#L11-L40">source</a><h2 id="Concatenation-and-permutation-1">Concatenation and permutation</h2>
<h3 id="Base.cat">
<code>Base.cat</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">cat(A...; dims=dims)</pre>
<p>Concatenate the input arrays along the specified dimensions in the iterable <code>dims</code>. For dimensions not in <code>dims</code>, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in <code>dims</code>, the size of the output array is the sum of the sizes of the input arrays along that dimension. If <code>dims</code> is a single number, the different arrays are tightly stacked along that dimension. If <code>dims</code> is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, <code>cat(matrices...; dims=(1,2))</code> builds a block diagonal matrix, i.e. a block matrix with <code>matrices[1]</code>, <code>matrices[2]</code>, ... as diagonal blocks and matching zero blocks away from the diagonal.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L1550-L1564">source</a><h3 id="Base.vcat">
<code>Base.vcat</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">vcat(A...)</pre>
<p>Concatenate along dimension 1.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1 2 3 4 5]
1×5 Array{Int64,2}:
 1  2  3  4  5

julia&gt; b = [6 7 8 9 10; 11 12 13 14 15]
2×5 Array{Int64,2}:
  6   7   8   9  10
 11  12  13  14  15

julia&gt; vcat(a,b)
3×5 Array{Int64,2}:
  1   2   3   4   5
  6   7   8   9  10
 11  12  13  14  15

julia&gt; c = ([1 2 3], [4 5 6])
([1 2 3], [4 5 6])

julia&gt; vcat(c...)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L1472-L1502">source</a><h3 id="Base.hcat">
<code>Base.hcat</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">hcat(A...)</pre>
<p>Concatenate along dimension 2.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1; 2; 3; 4; 5]
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; b = [6 7; 8 9; 10 11; 12 13; 14 15]
5×2 Array{Int64,2}:
  6   7
  8   9
 10  11
 12  13
 14  15

julia&gt; hcat(a,b)
5×3 Array{Int64,2}:
 1   6   7
 2   8   9
 3  10  11
 4  12  13
 5  14  15

julia&gt; c = ([1; 2; 3], [4; 5; 6])
([1, 2, 3], [4, 5, 6])

julia&gt; hcat(c...)
3×2 Array{Int64,2}:
 1  4
 2  5
 3  6</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L1504-L1544">source</a><h3 id="Base.hvcat">
<code>Base.hvcat</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">hvcat(rows::Tuple{Vararg{Int}}, values...)</pre>
<p>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a, b, c, d, e, f = 1, 2, 3, 4, 5, 6
(1, 2, 3, 4, 5, 6)

julia&gt; [a b c; d e f]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; hvcat((3,3), a,b,c,d,e,f)
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; [a b;c d; e f]
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6

julia&gt; hvcat((2,2,2), a,b,c,d,e,f)
3×2 Array{Int64,2}:
 1  2
 3  4
 5  6</pre>
<p>If the first argument is a single integer <code>n</code>, then all block rows are assumed to have <code>n</code> block columns.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L1595-L1632">source</a><h3 id="Base.vect">
<code>Base.vect</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">vect(X...)</pre>
<p>Create a <a href="#Base.Vector"><code>Vector</code></a> with element type computed from the <code>promote_typeof</code> of the argument, containing the argument list.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = Base.vect(UInt8(1), 2.5, 1//2)
3-element Array{Float64,1}:
 1.0
 2.5
 0.5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L132-L146">source</a><h3 id="Base.circshift">
<code>Base.circshift</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">circshift(A, shifts)</pre>
<p>Circularly shift, i.e. rotate, the data in an array. The second argument is a tuple or vector giving the amount to shift in each dimension, or an integer to shift only in the first dimension.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; b = reshape(Vector(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; circshift(b, (0,2))
4×4 Array{Int64,2}:
  9  13  1  5
 10  14  2  6
 11  15  3  7
 12  16  4  8

julia&gt; circshift(b, (-1,0))
4×4 Array{Int64,2}:
 2  6  10  14
 3  7  11  15
 4  8  12  16
 1  5   9  13

julia&gt; a = BitArray([true, true, false, false, true])
5-element BitArray{1}:
 1
 1
 0
 0
 1

julia&gt; circshift(a, 1)
5-element BitArray{1}:
 1
 1
 1
 0
 0

julia&gt; circshift(a, -1)
5-element BitArray{1}:
 1
 0
 0
 1
 1</pre>
<p>See also <a href="#Base.circshift!"><code>circshift!</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarraymath.jl#L184-L240">source</a><h3 id="Base.circshift!">
<code>Base.circshift!</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">circshift!(dest, src, shifts)</pre>
<p>Circularly shift, i.e. rotate, the data in <code>src</code>, storing the result in <code>dest</code>. <code>shifts</code> specifies the amount to shift in each dimension.</p>
<p>The <code>dest</code> array must be distinct from the <code>src</code> array (they cannot alias each other).</p>
<p>See also <a href="#Base.circshift"><code>circshift</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/multidimensional.jl#L946-L956">source</a><h3 id="Base.circcopy!">
<code>Base.circcopy!</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">circcopy!(dest, src)</pre>
<p>Copy <code>src</code> to <code>dest</code>, indexing each dimension modulo its length. <code>src</code> and <code>dest</code> must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap <code>dest</code> agrees with <code>src</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; src = reshape(Vector(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; dest = OffsetArray{Int}(undef, (0:3,2:5))

julia&gt; circcopy!(dest, src)
OffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3×2:5:
 8  12  16  4
 5   9  13  1
 6  10  14  2
 7  11  15  3

julia&gt; dest[1:3,2:4] == src[1:3,2:4]
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/multidimensional.jl#L999-L1029">source</a><h3 id="Base.findall-Tuple{Any}">
<code>Base.findall</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findall(A)</pre>
<p>Return a vector <code>I</code> of the <code>true</code> indices or keys of <code>A</code>. If there are no such elements of <code>A</code>, return an empty array. To search for other kinds of values, pass a predicate as the first argument.</p>
<p>Indices or keys are of the same type as those returned by <a href="../collections/index#Base.keys"><code>keys(A)</code></a> and <a href="../collections/index#Base.pairs"><code>pairs(A)</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [true, false, false, true]
4-element Array{Bool,1}:
 1
 0
 0
 1

julia&gt; findall(A)
2-element Array{Int64,1}:
 1
 4

julia&gt; A = [true false; false true]
2×2 Array{Bool,2}:
 1  0
 0  1

julia&gt; findall(A)
2-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 2)

julia&gt; findall(falses(3))
0-element Array{Int64,1}</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L1984-L2021">source</a><h3 id="Base.findall-Tuple{Function,Any}">
<code>Base.findall</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findall(f::Function, A)</pre>
<p>Return a vector <code>I</code> of the indices or keys of <code>A</code> where <code>f(A[I])</code> returns <code>true</code>. If there are no such elements of <code>A</code>, return an empty array.</p>
<p>Indices or keys are of the same type as those returned by <a href="../collections/index#Base.keys"><code>keys(A)</code></a> and <a href="../collections/index#Base.pairs"><code>pairs(A)</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; x = [1, 3, 4]
3-element Array{Int64,1}:
 1
 3
 4

julia&gt; findall(isodd, x)
2-element Array{Int64,1}:
 1
 2

julia&gt; A = [1 2 0; 3 4 0]
2×3 Array{Int64,2}:
 1  2  0
 3  4  0
julia&gt; findall(isodd, A)
2-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)

julia&gt; findall(!iszero, A)
4-element Array{CartesianIndex{2},1}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)
 CartesianIndex(1, 2)
 CartesianIndex(2, 2)

julia&gt; d = Dict(:A =&gt; 10, :B =&gt; -1, :C =&gt; 0)
Dict{Symbol,Int64} with 3 entries:
  :A =&gt; 10
  :B =&gt; -1
  :C =&gt; 0

julia&gt; findall(x -&gt; x &gt;= 0, d)
2-element Array{Symbol,1}:
 :A
 :C
</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L1931-L1981">source</a><h3 id="Base.findfirst-Tuple{Any}">
<code>Base.findfirst</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findfirst(A)</pre>
<p>Return the index or key of the first <code>true</code> value in <code>A</code>. Return <code>nothing</code> if no such value is found. To search for other kinds of values, pass a predicate as the first argument.</p>
<p>Indices or keys are of the same type as those returned by <a href="../collections/index#Base.keys"><code>keys(A)</code></a> and <a href="../collections/index#Base.pairs"><code>pairs(A)</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [false, false, true, false]
4-element Array{Bool,1}:
 0
 0
 1
 0

julia&gt; findfirst(A)
3

julia&gt; findfirst(falses(3)) # returns nothing, but not printed in the REPL

julia&gt; A = [false false; true false]
2×2 Array{Bool,2}:
 0  0
 1  0

julia&gt; findfirst(A)
CartesianIndex(2, 1)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L1617-L1649">source</a><h3 id="Base.findfirst-Tuple{Function,Any}">
<code>Base.findfirst</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findfirst(predicate::Function, A)</pre>
<p>Return the index or key of the first element of <code>A</code> for which <code>predicate</code> returns <code>true</code>. Return <code>nothing</code> if there is no such element.</p>
<p>Indices or keys are of the same type as those returned by <a href="../collections/index#Base.keys"><code>keys(A)</code></a> and <a href="../collections/index#Base.pairs"><code>pairs(A)</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1, 4, 2, 2]
4-element Array{Int64,1}:
 1
 4
 2
 2

julia&gt; findfirst(iseven, A)
2

julia&gt; findfirst(x -&gt; x&gt;10, A) # returns nothing, but not printed in the REPL

julia&gt; findfirst(isequal(4), A)
2

julia&gt; A = [1 4; 2 2]
2×2 Array{Int64,2}:
 1  4
 2  2

julia&gt; findfirst(iseven, A)
CartesianIndex(2, 1)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L1699-L1733">source</a><h3 id="Base.findlast-Tuple{Any}">
<code>Base.findlast</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findlast(A)</pre>
<p>Return the index or key of the last <code>true</code> value in <code>A</code>. Return <code>nothing</code> if there is no <code>true</code> value in <code>A</code>.</p>
<p>Indices or keys are of the same type as those returned by <a href="../collections/index#Base.keys"><code>keys(A)</code></a> and <a href="../collections/index#Base.pairs"><code>pairs(A)</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [true, false, true, false]
4-element Array{Bool,1}:
 1
 0
 1
 0

julia&gt; findlast(A)
3

julia&gt; A = falses(2,2);

julia&gt; findlast(A) # returns nothing, but not printed in the REPL

julia&gt; A = [true false; true false]
2×2 Array{Bool,2}:
 1  0
 1  0

julia&gt; findlast(A)
CartesianIndex(2, 1)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L1797-L1830">source</a><h3 id="Base.findlast-Tuple{Function,Any}">
<code>Base.findlast</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findlast(predicate::Function, A)</pre>
<p>Return the index or key of the last element of <code>A</code> for which <code>predicate</code> returns <code>true</code>. Return <code>nothing</code> if there is no such element.</p>
<p>Indices or keys are of the same type as those returned by <a href="../collections/index#Base.keys"><code>keys(A)</code></a> and <a href="../collections/index#Base.pairs"><code>pairs(A)</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; findlast(isodd, A)
3

julia&gt; findlast(x -&gt; x &gt; 5, A) # returns nothing, but not printed in the REPL

julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; findlast(isodd, A)
CartesianIndex(2, 1)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L1888-L1919">source</a><h3 id="Base.findnext-Tuple{Any,Integer}">
<code>Base.findnext</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findnext(A, i)</pre>
<p>Find the next index after or including <code>i</code> of a <code>true</code> element of <code>A</code>, or <code>nothing</code> if not found.</p>
<p>Indices are of the same type as those returned by <a href="../collections/index#Base.keys"><code>keys(A)</code></a> and <a href="../collections/index#Base.pairs"><code>pairs(A)</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [false, false, true, false]
4-element Array{Bool,1}:
 0
 0
 1
 0

julia&gt; findnext(A, 1)
3

julia&gt; findnext(A, 4) # returns nothing, but not printed in the REPL

julia&gt; A = [false false; true false]
2×2 Array{Bool,2}:
 0  0
 1  0

julia&gt; findnext(A, CartesianIndex(1, 1))
CartesianIndex(2, 1)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L1572-L1603">source</a><h3 id="Base.findnext-Tuple{Function,Any,Integer}">
<code>Base.findnext</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findnext(predicate::Function, A, i)</pre>
<p>Find the next index after or including <code>i</code> of an element of <code>A</code> for which <code>predicate</code> returns <code>true</code>, or <code>nothing</code> if not found.</p>
<p>Indices are of the same type as those returned by <a href="../collections/index#Base.keys"><code>keys(A)</code></a> and <a href="../collections/index#Base.pairs"><code>pairs(A)</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1, 4, 2, 2];

julia&gt; findnext(isodd, A, 1)
1

julia&gt; findnext(isodd, A, 2) # returns nothing, but not printed in the REPL

julia&gt; A = [1 4; 2 2];

julia&gt; findnext(isodd, A, CartesianIndex(1, 1))
CartesianIndex(1, 1)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L1662-L1685">source</a><h3 id="Base.findprev-Tuple{Any,Integer}">
<code>Base.findprev</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findprev(A, i)</pre>
<p>Find the previous index before or including <code>i</code> of a <code>true</code> element of <code>A</code>, or <code>nothing</code> if not found.</p>
<p>Indices are of the same type as those returned by <a href="../collections/index#Base.keys"><code>keys(A)</code></a> and <a href="../collections/index#Base.pairs"><code>pairs(A)</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [false, false, true, true]
4-element Array{Bool,1}:
 0
 0
 1
 1

julia&gt; findprev(A, 3)
3

julia&gt; findprev(A, 1) # returns nothing, but not printed in the REPL

julia&gt; A = [false false; true true]
2×2 Array{Bool,2}:
 0  0
 1  1

julia&gt; findprev(A, CartesianIndex(2, 1))
CartesianIndex(2, 1)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L1752-L1783">source</a><h3 id="Base.findprev-Tuple{Function,Any,Integer}">
<code>Base.findprev</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">findprev(predicate::Function, A, i)</pre>
<p>Find the previous index before or including <code>i</code> of an element of <code>A</code> for which <code>predicate</code> returns <code>true</code>, or <code>nothing</code> if not found.</p>
<p>Indices are of the same type as those returned by <a href="../collections/index#Base.keys"><code>keys(A)</code></a> and <a href="../collections/index#Base.pairs"><code>pairs(A)</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [4, 6, 1, 2]
4-element Array{Int64,1}:
 4
 6
 1
 2

julia&gt; findprev(isodd, A, 1) # returns nothing, but not printed in the REPL

julia&gt; findprev(isodd, A, 3)
3

julia&gt; A = [4 6; 1 2]
2×2 Array{Int64,2}:
 4  6
 1  2

julia&gt; findprev(isodd, A, CartesianIndex(1, 2))
CartesianIndex(2, 1)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L1843-L1874">source</a><h3 id="Base.permutedims">
<code>Base.permutedims</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">permutedims(A::AbstractArray, perm)</pre>
<p>Permute the dimensions of array <code>A</code>. <code>perm</code> is a vector specifying a permutation of length <code>ndims(A)</code>.</p>
<p>See also: <a href="#Base.PermutedDimsArrays.PermutedDimsArray"><code>PermutedDimsArray</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = reshape(Vector(1:8), (2,2,2))
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 5  7
 6  8

julia&gt; permutedims(A, [3, 2, 1])
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  3
 5  7

[:, :, 2] =
 2  4
 6  8</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/permuteddimsarray.jl#L80-L110">source</a><pre data-language="julia">permutedims(m::AbstractMatrix)</pre>
<p>Permute the dimensions of the matrix <code>m</code>, by flipping the elements across the diagonal of the matrix. Differs from <code>LinearAlgebra</code>'s <a href="../../stdlib/linearalgebra/index#Base.transpose"><code>transpose</code></a> in that the operation is not recursive.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1 2; 3 4];

julia&gt; b = [5 6; 7 8];

julia&gt; c = [9 10; 11 12];

julia&gt; d = [13 14; 15 16];

julia&gt; X = [[a] [b]; [c] [d]]
2×2 Array{Array{Int64,2},2}:
 [1 2; 3 4]     [5 6; 7 8]
 [9 10; 11 12]  [13 14; 15 16]

julia&gt; permutedims(X)
2×2 Array{Array{Int64,2},2}:
 [1 2; 3 4]  [9 10; 11 12]
 [5 6; 7 8]  [13 14; 15 16]

julia&gt; transpose(X)
2×2 Transpose{Transpose{Int64,Array{Int64,2}},Array{Array{Int64,2},2}}:
 [1 3; 2 4]  [9 11; 10 12]
 [5 7; 6 8]  [13 15; 14 16]</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/permuteddimsarray.jl#L116-L148">source</a><pre data-language="julia">permutedims(v::AbstractVector)</pre>
<p>Reshape vector <code>v</code> into a <code>1 × length(v)</code> row matrix. Differs from <code>LinearAlgebra</code>'s <a href="../../stdlib/linearalgebra/index#Base.transpose"><code>transpose</code></a> in that the operation is not recursive.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; permutedims([1, 2, 3, 4])
1×4 Array{Int64,2}:
 1  2  3  4

julia&gt; V = [[[1 2; 3 4]]; [[5 6; 7 8]]]
2-element Array{Array{Int64,2},1}:
 [1 2; 3 4]
 [5 6; 7 8]

julia&gt; permutedims(V)
1×2 Array{Array{Int64,2},2}:
 [1 2; 3 4]  [5 6; 7 8]

julia&gt; transpose(V)
1×2 Transpose{Transpose{Int64,Array{Int64,2}},Array{Array{Int64,2},1}}:
 [1 3; 2 4]  [5 7; 6 8]</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/permuteddimsarray.jl#L151-L177">source</a><h3 id="Base.permutedims!">
<code>Base.permutedims!</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">permutedims!(dest, src, perm)</pre>
<p>Permute the dimensions of array <code>src</code> and store the result in the array <code>dest</code>. <code>perm</code> is a vector specifying a permutation of length <code>ndims(src)</code>. The preallocated array <code>dest</code> should have <code>size(dest) == size(src)[perm]</code> and is completely overwritten. No in-place permutation is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p>
<p>See also <a href="#Base.permutedims"><code>permutedims</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/permuteddimsarray.jl#L180-L190">source</a><h3 id="Base.PermutedDimsArrays.PermutedDimsArray">
<code>Base.PermutedDimsArrays.PermutedDimsArray</code><span class="docstring-category">Type</span>
</h3>
<pre data-language="julia">PermutedDimsArray(A, perm) -&gt; B</pre>
<p>Given an AbstractArray <code>A</code>, create a view <code>B</code> such that the dimensions appear to be permuted. Similar to <code>permutedims</code>, except that no copying occurs (<code>B</code> shares storage with <code>A</code>).</p>
<p>See also: <a href="#Base.permutedims"><code>permutedims</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = rand(3,5,4);

julia&gt; B = PermutedDimsArray(A, (3,1,2));

julia&gt; size(B)
(4, 3, 5)

julia&gt; B[3,1,2] == A[1,2,3]
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/permuteddimsarray.jl#L20-L41">source</a><h3 id="Base.promote_shape">
<code>Base.promote_shape</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">promote_shape(s1, s2)</pre>
<p>Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = fill(1, (3,4,1,1,1));

julia&gt; b = fill(1, (3,4));

julia&gt; promote_shape(a,b)
(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))

julia&gt; promote_shape((2,3,1,4), (2, 3, 1, 4, 1))
(2, 3, 1, 4, 1)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/indices.jl#L108-L126">source</a><h2 id="Array-functions-1">Array functions</h2>
<h3 id="Base.accumulate">
<code>Base.accumulate</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">accumulate(op, A; dims::Integer, [init])</pre>
<p>Cumulative operation <code>op</code> along the dimension <code>dims</code> of <code>A</code> (providing <code>dims</code> is optional for vectors). An initial value <code>init</code> may optionally be provided by a keyword argument. See also <a href="#Base.accumulate!"><code>accumulate!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of <code>accumulate</code>, see: <a href="#Base.cumsum"><code>cumsum</code></a>, <a href="#Base.cumprod"><code>cumprod</code></a></p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; accumulate(+, [1,2,3])
3-element Array{Int64,1}:
 1
 3
 6

julia&gt; accumulate(*, [1,2,3])
3-element Array{Int64,1}:
 1
 2
 6

julia&gt; accumulate(+, [1,2,3]; init=100)
3-element Array{Int64,1}:
 101
 103
 106

julia&gt; accumulate(min, [1,2,-1]; init=0)
3-element Array{Int64,1}:
  0
  0
 -1

julia&gt; accumulate(+, fill(1, 3, 3), dims=1)
3×3 Array{Int64,2}:
 1  1  1
 2  2  2
 3  3  3

julia&gt; accumulate(+, fill(1, 3, 3), dims=2)
3×3 Array{Int64,2}:
 1  2  3
 1  2  3
 1  2  3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/accumulate.jl#L190-L237">source</a><h3 id="Base.accumulate!">
<code>Base.accumulate!</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">accumulate!(op, B, A; [dims], [init])</pre>
<p>Cumulative operation <code>op</code> on <code>A</code> along the dimension <code>dims</code>, storing the result in <code>B</code>. Providing <code>dims</code> is optional for vectors. If the keyword argument <code>init</code> is given, its value is used to instantiate the accumulation. See also <a href="#Base.accumulate"><code>accumulate</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; x = [1, 0, 2, 0, 3];

julia&gt; y = [0, 0, 0, 0, 0];

julia&gt; accumulate!(+, y, x);

julia&gt; y
5-element Array{Int64,1}:
 1
 1
 3
 3
 6

julia&gt; A = [1 2; 3 4];

julia&gt; B = [0 0; 0 0];

julia&gt; accumulate!(-, B, A, dims=1);

julia&gt; B
2×2 Array{Int64,2}:
  1   2
 -2  -2

julia&gt; accumulate!(-, B, A, dims=2);

julia&gt; B
2×2 Array{Int64,2}:
 1  -1
 3  -1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/accumulate.jl#L250-L291">source</a><h3 id="Base.cumprod">
<code>Base.cumprod</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">cumprod(A; dims::Integer)</pre>
<p>Cumulative product along the dimension <code>dim</code>. See also <a href="#Base.cumprod!"><code>cumprod!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; cumprod(a, dims=1)
2×3 Array{Int64,2}:
 1   2   3
 4  10  18

julia&gt; cumprod(a, dims=2)
2×3 Array{Int64,2}:
 1   2    6
 4  20  120</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/accumulate.jl#L136-L160">source</a><pre data-language="julia">cumprod(x::AbstractVector)</pre>
<p>Cumulative product of a vector. See also <a href="#Base.cumprod!"><code>cumprod!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; cumprod(fill(1//2, 3))
3-element Array{Rational{Int64},1}:
 1//2
 1//4
 1//8

julia&gt; cumprod([fill(1//3, 2, 2) for i in 1:3])
3-element Array{Array{Rational{Int64},2},1}:
 [1//3 1//3; 1//3 1//3]
 [2//9 2//9; 2//9 2//9]
 [4//27 4//27; 4//27 4//27]</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/accumulate.jl#L165-L186">source</a><h3 id="Base.cumprod!">
<code>Base.cumprod!</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">cumprod!(B, A; dims::Integer)</pre>
<p>Cumulative product of <code>A</code> along the dimension <code>dims</code>, storing the result in <code>B</code>. See also <a href="#Base.cumprod"><code>cumprod</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/accumulate.jl#L119-L124">source</a><pre data-language="julia">cumprod!(y::AbstractVector, x::AbstractVector)</pre>
<p>Cumulative product of a vector <code>x</code>, storing the result in <code>y</code>. See also <a href="#Base.cumprod"><code>cumprod</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/accumulate.jl#L128-L133">source</a><h3 id="Base.cumsum">
<code>Base.cumsum</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">cumsum(A; dims::Integer)</pre>
<p>Cumulative sum along the dimension <code>dims</code>. See also <a href="#Base.cumsum!"><code>cumsum!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6

julia&gt; cumsum(a, dims=1)
2×3 Array{Int64,2}:
 1  2  3
 5  7  9

julia&gt; cumsum(a, dims=2)
2×3 Array{Int64,2}:
 1  3   6
 4  9  15</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/accumulate.jl#L64-L88">source</a><pre data-language="julia">cumsum(x::AbstractVector)</pre>
<p>Cumulative sum a vector. See also <a href="#Base.cumsum!"><code>cumsum!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; cumsum([1, 1, 1])
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; cumsum([fill(1, 2) for i in 1:3])
3-element Array{Array{Int64,1},1}:
 [1, 1]
 [2, 2]
 [3, 3]</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/accumulate.jl#L94-L115">source</a><h3 id="Base.cumsum!">
<code>Base.cumsum!</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">cumsum!(B, A; dims::Integer)</pre>
<p>Cumulative sum of <code>A</code> along the dimension <code>dims</code>, storing the result in <code>B</code>. See also <a href="#Base.cumsum"><code>cumsum</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/accumulate.jl#L41-L45">source</a><h3 id="Base.diff">
<code>Base.diff</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">diff(A::AbstractVector)
diff(A::AbstractArray; dims::Integer)</pre>
<p>Finite difference operator on a vector or a multidimensional array <code>A</code>. In the latter case the dimension to operate on needs to be specified with the <code>dims</code> keyword argument.</p>
<div class="admonition compat">
<div class="admonition-title">Julia 1.1</div>
<div class="admonition-text"><p><code>diff</code> for arrays with dimension higher than 2 requires at least Julia 1.1.</p></div>
</div>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [2 4; 6 16]
2×2 Array{Int64,2}:
 2   4
 6  16

julia&gt; diff(a, dims=2)
2×1 Array{Int64,2}:
  2
 10

julia&gt; diff(vec(a))
3-element Array{Int64,1}:
  4
 -2
 12</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/multidimensional.jl#L738-L767">source</a><h3 id="Base.repeat">
<code>Base.repeat</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">repeat(A::AbstractArray, counts::Integer...)</pre>
<p>Construct an array by repeating array <code>A</code> a given number of times in each dimension, specified by <code>counts</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; repeat([1, 2, 3], 2)
6-element Array{Int64,1}:
 1
 2
 3
 1
 2
 3

julia&gt; repeat([1, 2, 3], 2, 3)
6×3 Array{Int64,2}:
 1  1  1
 2  2  2
 3  3  3
 1  1  1
 2  2  2
 3  3  3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarraymath.jl#L247-L272">source</a><pre data-language="julia">repeat(A::AbstractArray; inner=ntuple(x-&gt;1, ndims(A)), outer=ntuple(x-&gt;1, ndims(A)))</pre>
<p>Construct an array by repeating the entries of <code>A</code>. The i-th element of <code>inner</code> specifies the number of times that the individual entries of the i-th dimension of <code>A</code> should be repeated. The i-th element of <code>outer</code> specifies the number of times that a slice along the i-th dimension of <code>A</code> should be repeated. If <code>inner</code> or <code>outer</code> are omitted, no repetition is performed.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; repeat(1:2, inner=2)
4-element Array{Int64,1}:
 1
 1
 2
 2

julia&gt; repeat(1:2, outer=2)
4-element Array{Int64,1}:
 1
 2
 1
 2

julia&gt; repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))
4×6 Array{Int64,2}:
 1  2  1  2  1  2
 1  2  1  2  1  2
 3  4  3  4  3  4
 3  4  3  4  3  4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarraymath.jl#L299-L331">source</a><pre data-language="julia">repeat(s::AbstractString, r::Integer)</pre>
<p>Repeat a string <code>r</code> times. This can be written as <code>s^r</code>.</p>
<p>See also: <a href="#Base.:%5E-Tuple%7BAbstractString,Integer%7D"><code>^</code></a></p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; repeat("ha", 3)
"hahaha"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L646-L658">source</a><pre data-language="julia">repeat(c::AbstractChar, r::Integer) -&gt; String</pre>
<p>Repeat a character <code>r</code> times. This can equivalently be accomplished by calling <a href="#Base.:%5E-Tuple%7BAbstractString,Integer%7D"><code>c^r</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; repeat('A', 3)
"AAA"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/string.jl#L305-L315">source</a><h3 id="Base.rot180">
<code>Base.rot180</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">rot180(A)</pre>
<p>Rotate matrix <code>A</code> 180 degrees.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rot180(a)
2×2 Array{Int64,2}:
 4  3
 2  1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/arraymath.jl#L177-L194">source</a><pre data-language="julia">rot180(A, k)</pre>
<p>Rotate matrix <code>A</code> 180 degrees an integer <code>k</code> number of times. If <code>k</code> is even, this is equivalent to a <code>copy</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rot180(a,1)
2×2 Array{Int64,2}:
 4  3
 2  1

julia&gt; rot180(a,2)
2×2 Array{Int64,2}:
 1  2
 3  4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/arraymath.jl#L279-L302">source</a><h3 id="Base.rotl90">
<code>Base.rotl90</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">rotl90(A)</pre>
<p>Rotate matrix <code>A</code> left 90 degrees.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotl90(a)
2×2 Array{Int64,2}:
 2  4
 1  3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/arraymath.jl#L122-L139">source</a><pre data-language="julia">rotl90(A, k)</pre>
<p>Left-rotate matrix <code>A</code> 90 degrees counterclockwise an integer <code>k</code> number of times. If <code>k</code> is a multiple of four (including zero), this is equivalent to a <code>copy</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotl90(a,1)
2×2 Array{Int64,2}:
 2  4
 1  3

julia&gt; rotl90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia&gt; rotl90(a,3)
2×2 Array{Int64,2}:
 3  1
 4  2

julia&gt; rotl90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/arraymath.jl#L204-L237">source</a><h3 id="Base.rotr90">
<code>Base.rotr90</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">rotr90(A)</pre>
<p>Rotate matrix <code>A</code> right 90 degrees.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotr90(a)
2×2 Array{Int64,2}:
 3  1
 4  2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/arraymath.jl#L150-L167">source</a><pre data-language="julia">rotr90(A, k)</pre>
<p>Right-rotate matrix <code>A</code> 90 degrees clockwise an integer <code>k</code> number of times. If <code>k</code> is a multiple of four (including zero), this is equivalent to a <code>copy</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rotr90(a,1)
2×2 Array{Int64,2}:
 3  1
 4  2

julia&gt; rotr90(a,2)
2×2 Array{Int64,2}:
 4  3
 2  1

julia&gt; rotr90(a,3)
2×2 Array{Int64,2}:
 2  4
 1  3

julia&gt; rotr90(a,4)
2×2 Array{Int64,2}:
 1  2
 3  4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/arraymath.jl#L244-L277">source</a><h3 id="Base.mapslices">
<code>Base.mapslices</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">mapslices(f, A; dims)</pre>
<p>Transform the given dimensions of array <code>A</code> using function <code>f</code>. <code>f</code> is called on each slice of <code>A</code> of the form <code>A[...,:,...,:,...]</code>. <code>dims</code> is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if <code>dims</code> is <code>[1,2]</code> and <code>A</code> is 4-dimensional, <code>f</code> is called on <code>A[:,:,i,j]</code> for all <code>i</code> and <code>j</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; a = reshape(Vector(1:16),(2,2,2,2))
2×2×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; mapslices(sum, a, dims = [1,2])
1×1×2×2 Array{Int64,4}:
[:, :, 1, 1] =
 10

[:, :, 2, 1] =
 26

[:, :, 1, 2] =
 42

[:, :, 2, 2] =
 58</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarray.jl#L1928-L1971">source</a><h2 id="Combinatorics-1">Combinatorics</h2>
<h3 id="Base.invperm">
<code>Base.invperm</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">invperm(v)</pre>
<p>Return the inverse permutation of <code>v</code>. If <code>B = A[v]</code>, then <code>A == B[invperm(v)]</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; v = [2; 4; 3; 1];

julia&gt; invperm(v)
4-element Array{Int64,1}:
 4
 1
 3
 2

julia&gt; A = ['a','b','c','d'];

julia&gt; B = A[v]
4-element Array{Char,1}:
 'b'
 'd'
 'c'
 'a'

julia&gt; B[invperm(v)]
4-element Array{Char,1}:
 'a'
 'b'
 'c'
 'd'</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/combinatorics.jl#L195-L228">source</a><h3 id="Base.isperm">
<code>Base.isperm</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">isperm(v) -&gt; Bool</pre>
<p>Return <code>true</code> if <code>v</code> is a valid permutation.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; isperm([1; 2])
true

julia&gt; isperm([1; 3])
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/combinatorics.jl#L39-L52">source</a><h3 id="Base.permute!-Tuple{Any,AbstractArray{T,1} where T}">
<code>Base.permute!</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">permute!(v, p)</pre>
<p>Permute vector <code>v</code> in-place, according to permutation <code>p</code>. No checking is done to verify that <code>p</code> is a permutation.</p>
<p>To return a new permutation, use <code>v[p]</code>. Note that this is generally faster than <code>permute!(v,p)</code> for large vectors.</p>
<p>See also <a href="#Base.invpermute!"><code>invpermute!</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1, 1, 3, 4];

julia&gt; perm = [2, 4, 3, 1];

julia&gt; permute!(A, perm);

julia&gt; A
4-element Array{Int64,1}:
 1
 4
 3
 1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/combinatorics.jl#L119-L145">source</a><h3 id="Base.invpermute!">
<code>Base.invpermute!</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">invpermute!(v, p)</pre>
<p>Like <a href="#Base.permute!-Tuple%7BAny,AbstractArray%7BT,1%7D%20where%20T%7D"><code>permute!</code></a>, but the inverse of the given permutation is applied.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = [1, 1, 3, 4];

julia&gt; perm = [2, 4, 3, 1];

julia&gt; invpermute!(A, perm);

julia&gt; A
4-element Array{Int64,1}:
 4
 1
 3
 1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/combinatorics.jl#L172-L192">source</a><h3 id="Base.reverse-Tuple{AbstractArray{T,1} where T}">
<code>Base.reverse</code><span class="docstring-category">Method</span>
</h3>
<pre data-language="julia">reverse(v [, start=1 [, stop=length(v) ]] )</pre>
<p>Return a copy of <code>v</code> reversed from start to stop. See also <a href="../iterators/index#Base.Iterators.reverse"><code>Iterators.reverse</code></a> for reverse-order iteration without making a copy.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = Vector(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; reverse(A)
5-element Array{Int64,1}:
 5
 4
 3
 2
 1

julia&gt; reverse(A, 1, 4)
5-element Array{Int64,1}:
 4
 3
 2
 1
 5

julia&gt; reverse(A, 3, 5)
5-element Array{Int64,1}:
 1
 2
 5
 4
 3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L1409-L1449">source</a><pre data-language="julia">reverse(A; dims::Integer)</pre>
<p>Reverse <code>A</code> in dimension <code>dims</code>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; b = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; reverse(b, dims=2)
2×2 Array{Int64,2}:
 2  1
 4  3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/abstractarraymath.jl#L130-L147">source</a><h3 id="Base.reverseind">
<code>Base.reverseind</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">reverseind(v, i)</pre>
<p>Given an index <code>i</code> in <a href="#"><code>reverse(v)</code></a>, return the corresponding index in <code>v</code> so that <code>v[reverseind(v,i)] == reverse(v)[i]</code>. (This can be nontrivial in cases where <code>v</code> contains non-ASCII characters.)</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; r = reverse("Julia")
"ailuJ"

julia&gt; for i in 1:length(r)
           print(r[reverseind("Julia", i)])
       end
Julia</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/strings/basic.jl#L626-L643">source</a><h3 id="Base.reverse!">
<code>Base.reverse!</code><span class="docstring-category">Function</span>
</h3>
<pre data-language="julia">reverse!(v [, start=1 [, stop=length(v) ]]) -&gt; v</pre>
<p>In-place version of <a href="#"><code>reverse</code></a>.</p>
<p><strong>Examples</strong></p>
<pre data-language="julia">julia&gt; A = Vector(1:5)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; reverse!(A);

julia&gt; A
5-element Array{Int64,1}:
 5
 4
 3
 2
 1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/array.jl#L1472-L1497">source</a><div class="_attribution">
  <p class="_attribution-p">
    © 2009–2019 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.julialang.org/en/v1.2.0/base/arrays/" class="_attribution-link">https://docs.julialang.org/en/v1.2.0/base/arrays/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
