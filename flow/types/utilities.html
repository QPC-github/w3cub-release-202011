
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Utility Types - Flow - W3cubDocs</title>
  
  <meta name="description" content=" Flow provides a set of utility types to operate on other types, and can be useful for different scenarios. ">
  <meta name="keywords" content="utility, types, flow">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/flow/types/utilities.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-60a6449bb52e9968d95c133a29f066ffcb8dbe4f077d4022e51c991ce30bf256c8e19c508207a4193c414ffd0414826564317669b0f27f9f85c1cb21b84e097e.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/flow.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/flow/" class="_nav-link" title="" style="margin-left:0;">Flow</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1>Utility Types</h1> <p>Flow provides a set of utility types to operate on other types, and can be useful for different scenarios.</p> <p>Table of contents:</p> <ul> <li><a href="#toc-keys"><code>$Keys&lt;T&gt;</code></a></li> <li><a href="#toc-values"><code>$Values&lt;T&gt;</code></a></li> <li><a href="#toc-readonly"><code>$ReadOnly&lt;T&gt;</code></a></li> <li><a href="#toc-exact"><code>$Exact&lt;T&gt;</code></a></li> <li><a href="#toc-diff"><code>$Diff&lt;A, B&gt;</code></a></li> <li><a href="#toc-rest"><code>$Rest&lt;A, B&gt;</code></a></li> <li><a href="#toc-propertytype"><code>$PropertyType&lt;T, k&gt;</code></a></li> <li><a href="#toc-elementtype"><code>$ElementType&lt;T, K&gt;</code></a></li> <li><a href="#toc-nonmaybe"><code>$NonMaybeType&lt;T&gt;</code></a></li> <li><a href="#toc-objmap"><code>$ObjMap&lt;T, F&gt;</code></a></li> <li><a href="#toc-objmapi"><code>$ObjMapi&lt;T, F&gt;</code></a></li> <li><a href="#toc-tuplemap"><code>$TupleMap&lt;T, F&gt;</code></a></li> <li><a href="#toc-call"><code>$Call&lt;F, T...&gt;</code></a></li> <li><a href="#toc-class"><code>Class&lt;T&gt;</code></a></li> <li><a href="#toc-shape"><code>$Shape&lt;T&gt;</code></a></li> <li><a href="#toc-exports"><code>$Exports&lt;T&gt;</code></a></li> <li><a href="#toc-supertype"><code>$Supertype&lt;T&gt;</code></a></li> <li><a href="#toc-subtype"><code>$Subtype&lt;T&gt;</code></a></li> <li><a href="#toc-existential-type"><code>Existential Type (*)</code></a></li> </ul> <h2 id="toc-keys">
<code>$Keys&lt;T&gt;</code> </h2> <p>In Flow you can <a href="../literals">use union types similar to enums</a>:</p> <pre data-language="javascript">// @flow
type Suit = "Diamonds" | "Clubs" | "Hearts" | "Spades";

const clubs: Suit = 'Clubs';
const wrong: Suit = 'wrong'; // 'wrong' is not a Suit
</pre> <p>This is very handy, but sometimes you need to access the enum definition at runtime (i.e. at a value level).</p> <p>Suppose for example that you want to associate a value to each suit of the previous example.</p> <p>You could do</p> <pre data-language="javascript">// @flow
type Suit = "Diamonds" | "Clubs" | "Hearts" | "Spades";

const suitNumbers = {
  Diamonds: 1,
  Clubs: 2,
  Hearts: 3,
  Spades: 4
};

function printSuitNumber(suit: Suit) {
  console.log(suitNumbers[suit]);
}

printSuitNumber('Diamonds'); // 1
printSuitNumber('foo'); // 'foo' is not a Suit
</pre> <p>but this doesn’t feel very DRY, as we had to explicitly define the suit names twice.</p> <p>In situations like this one, you can leverage the <code>$Keys&lt;T&gt;</code> operator. Let’s see another example, this time using <code>$Keys</code>:</p> <pre data-language="javascript">// @flow
const countries = {
  US: "United States",
  IT: "Italy",
  FR: "France"
};

type Country = $Keys&lt;typeof countries&gt;;

const italy: Country = 'IT';
const nope: Country = 'nope'; // 'nope' is not a Country
</pre> <p>In the example above, the type of <code>Country</code> is equivalent to <code>type Country = 'US' | 'IT' | 'FR'</code>, but Flow was able to extract it from the keys of <code>countries</code>.</p> <h2 id="toc-values">
<code>$Values&lt;T&gt;</code> </h2> <p><code>$Values&lt;T&gt;</code> represents the union type of all the value types (not the values, but their <em>types</em>!) of the enumerable properties in an <a href="../objects">Object Type</a> <code>T</code>.</p> <p>For example:</p> <pre data-language="javascript">// @flow
type Props = {
  name: string,
  age: number,
};

// The following two types are equivalent:
type PropValues = string | number;
type Prop$Values = $Values&lt;Props&gt;;

const name: Prop$Values = 'Jon';  // OK
const age: Prop$Values = 42;  // OK
const fn: Prop$Values = () =&gt; {};  // Error! function is not part of the union type
</pre> <h2 id="toc-readonly">
<code>$ReadOnly&lt;T&gt;</code> </h2> <p><code>$ReadOnly&lt;T&gt;</code> is a type that represents the read-only version of a given <a href="../objects">object type</a> <code>T</code>. A read-only object type is an object type whose keys are all <a href="../interfaces#toc-interface-property-variance-read-only-and-write-only">read-only</a>.</p> <p>This means that the following 2 types are equivalent:</p> <pre data-language="javascript">type ReadOnlyObj = {
  +key: any,  // read-only field, marked by the `+` annotation
};
</pre> <pre data-language="javascript">type ReadOnlyObj = $ReadOnly&lt;{
  key: any,
}&gt;;
</pre> <p>This is useful when you need to use a read-only version of an object type you’ve already defined, without manually having to re-define and annotate each key as read-only. For example:</p> <pre data-language="javascript">// @flow
type Props = {
  name: string,
  age: number,
  // ...
};

type ReadOnlyProps = $ReadOnly&lt;Props&gt;;

function render(props: ReadOnlyProps) {
  const {name, age} = props;  // OK to read
  props.age = 42;             // Error when writing
  // ...
}
</pre> <p>Additionally, other utility types, such as <a href="#toc-objmap"><code>$ObjMap&lt;T&gt;</code></a>, may strip any read/write annotations, so <code>$ReadOnly&lt;T&gt;</code> is a handy way to quickly make the object read-only again after operating on it:</p> <pre data-language="javascript">type Obj = {
  +key: any,
};

type MappedObj = $ReadOnly&lt;$ObjMap&lt;Obj, TypeFn&gt;&gt; // Still read-only
</pre> <blockquote> <p>Note: <code>$ReadOnly</code> is only for making read-only <em>object</em> types. See the Array docs for how to <a href="../arrays#toc-readonlyarray">type read-only arrays with <code>$ReadOnlyArray</code></a>.</p> </blockquote> <h2 id="toc-exact">
<code>$Exact&lt;T&gt;</code> </h2> <p><code>$Exact&lt;{name: string}&gt;</code> is a synonym for <code>{| name: string |}</code> as in the <a href="../objects#toc-exact-object-types">Object documentation</a>.</p> <pre data-language="javascript">// @flow
type ExactUser = $Exact&lt;{name: string}&gt;;
type ExactUserShorthand = {| name: string |};

const user2 = {name: 'John Wilkes Booth'};
// These will both be satisfied because they are equivalent
(user2: ExactUser);
(user2: ExactUserShorthand);
</pre> <h2 id="toc-diff">
<code>$Diff&lt;A, B&gt;</code> </h2> <p>As the name hints, <code>$Diff&lt;A, B&gt;</code> is the type representing the set difference of <code>A</code> and <code>B</code>, i.e. <code>A \ B</code>, where <code>A</code> and <code>B</code> are both <a href="../objects">object types</a>. Here’s an example:</p> <pre data-language="javascript">// @flow
type Props = { name: string, age: number };
type DefaultProps = { age: number };
type RequiredProps = $Diff&lt;Props, DefaultProps&gt;;

function setProps(props: RequiredProps) {
  // ...
}

setProps({ name: 'foo' });
setProps({ name: 'foo', age: 42, baz: false }); // you can pass extra props too
setProps({ age: 42 }); // error, name is required
</pre> <p>As you may have noticed, the example is not a random one. <code>$Diff</code> is exactly what the React definition file uses to define the type of the props accepted by a React Component.</p> <p>Note that <code>$Diff&lt;A, B&gt;</code> will error if the object you are removing properties from does not have the property being removed, i.e. if <code>B</code> has a key that doesn’t exist in <code>A</code>:</p> <pre data-language="javascript">// @flow
type Props = { name: string, age: number };
type DefaultProps = { age: number, other: string }; // Will error due to this `other` property not being in Props.
type RequiredProps = $Diff&lt;Props, DefaultProps&gt;;

function setProps(props: RequiredProps) {
  props.name;
  // ...
}
</pre> <p>As a workaround, you can specify the property not present in <code>A</code> as optional. For example:</p> <pre data-language="javascript">type A = $Diff&lt;{}, {nope: number}&gt;; // Error
type B = $Diff&lt;{}, {nope: number | void}&gt;; // OK
</pre> <h2 id="toc-rest">
<code>$Rest&lt;A, B&gt;</code> </h2> <p><code>$Rest&lt;A, B&gt;</code> is the type that represents the runtime object rest operation, e.g.: <code>const {foo, ...rest} = obj</code>, where <code>A</code> and <code>B</code> are both <a href="../objects">object types</a>. The resulting type from this operation will be an object type containing <code>A</code>’s <em>own</em> properties that are not <em>own</em> properties in <code>B</code>. In flow, we treat all properties on <a href="../objects#toc-exact-object-types">exact object types</a> as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">own</a>. In in-exact objects, a property may or may not be own.</p> <p>For example:</p> <pre data-language="javascript">// @flow
type Props = { name: string, age: number };

const props: Props = {name: 'Jon', age: 42};
const {age, ...otherProps} = props;
(otherProps: $Rest&lt;Props, {|age: number|}&gt;);
otherProps.age;  // Error
</pre> <p>The main difference with <a href="#toc-diff"><code>$Diff&lt;A, B&gt;</code></a>, is that <code>$Rest&lt;A, B&gt;</code> aims to represent the true runtime rest operation, which implies that exact object types are treated differently in <code>$Rest&lt;A, B&gt;</code>. For example, <code>$Rest&lt;{|n: number|}, {}&gt;</code> will result in <code>{|n?: number|}</code> because an in-exact empty object may have an <code>n</code> property, while <code>$Diff&lt;{|n: number|}, {}&gt;</code> will result in <code>{|n: number|}</code>.</p> <h2 id="toc-propertytype">
<code>$PropertyType&lt;T, k&gt;</code> </h2> <p><strong>WARNING:</strong> <code>$PropertyType</code> is deprecated as of Flow version 0.155, and will be removed in a future version of Flow. Use <a href="../indexed-access">Indexed Access Types</a> instead. <code>$PropertyType&lt;T, 'k'&gt;</code> is now <code>T['k']</code>.</p> <p>A <code>$PropertyType&lt;T, k&gt;</code> is the type at a given key <code>k</code>. As of Flow v0.36.0, <code>k</code> must be a literal string.</p> <pre data-language="javascript">// @flow
type Person = {
  name: string,
  age: number,
  parent: Person
};

const newName: $PropertyType&lt;Person, 'name'&gt; = 'Toni Braxton';
const newAge: $PropertyType&lt;Person, 'age'&gt; = 51;
const newParent: $PropertyType&lt;Person, 'parent'&gt; = 'Evelyn Braxton';
</pre> <p>This can be especially useful for referring to the type of React props, or, even the entire <code>props</code> type itself.</p> <pre data-language="javascript">// @flow
import React from 'react';

type Props = {
  text: string,
  onMouseOver: ({x: number, y: number}) =&gt; void
}

class Tooltip extends React.Component&lt;Props&gt; {
  props: Props;
}

const someProps: $PropertyType&lt;Tooltip, 'props'&gt; = {
  text: 'foo',
  onMouseOver: (data: {x: number, y: number}) =&gt; undefined
};

const otherProps: $PropertyType&lt;Tooltip, 'props'&gt; = {
  text: 'foo'
  // Missing the `onMouseOver` definition
};
</pre> <p>You can even nest lookups:</p> <pre data-language="javascript">// @flow
type PositionHandler = $PropertyType&lt;$PropertyType&lt;Tooltip, 'props'&gt;, 'onMouseOver'&gt;;
const handler: PositionHandler = (data: {x: number, y: number}) =&gt; undefined;
const handler2: PositionHandler = (data: string) =&gt; undefined; // wrong parameter types
</pre> <p>You can use this in combination with <code>Class&lt;T&gt;</code> to get static props:</p> <pre data-language="javascript">// @flow
class BackboneModel {
  static idAttribute: string | false;
}

type ID = $PropertyType&lt;Class&lt;BackboneModel&gt;, 'idAttribute'&gt;;
const someID: ID = '1234';
const someBadID: ID = true;
</pre> <h2 id="toc-elementtype">
<code>$ElementType&lt;T, K&gt;</code> </h2> <p><strong>WARNING:</strong> <code>$ElementType</code> is deprecated as of Flow version 0.155, and will be removed in a future version of Flow. Use <a href="../indexed-access">Indexed Access Types</a> instead. <code>$ElementType&lt;T, K&gt;</code> is now <code>T[K]</code>.</p> <p><code>$ElementType&lt;T, K&gt;</code> is the type that represents the type of every element inside an <a href="../arrays">array</a>, <a href="../tuples">tuple</a> or <a href="../objects">object</a> type <code>T</code>, that matches the given <em>key</em> type <code>K</code>.</p> <p>For example:</p> <pre data-language="javascript">// @flow

// Using objects:
type Obj = {
  name: string,
  age: number,
}
('Jon': $ElementType&lt;Obj, 'name'&gt;);
(42: $ElementType&lt;Obj, 'age'&gt;);
(true: $ElementType&lt;Obj, 'name'&gt;); // Nope, `name` is not a boolean
(true: $ElementType&lt;Obj, 'other'&gt;); // Nope, property `other` is not in Obj

// Using tuples:
type Tuple = [boolean, string];
(true: $ElementType&lt;Tuple, 0&gt;);
('foo': $ElementType&lt;Tuple, 1&gt;);
('bar': $ElementType&lt;Tuple, 2&gt;); // Nope, can't access position 2
</pre> <p>In the above case, we’re using literal values as <code>K</code>, similarly to <a href="#toc-propertytype"><code>$PropertyType&lt;T, k&gt;</code></a>. However, when using <code>$ElementType&lt;T, K&gt;</code>, <code>K</code> is allowed to be any type, as long as that type exists on the keys of <code>T</code>. For example:</p> <pre data-language="javascript">// @flow

// Using objects
type Obj = { [key: string]: number };
(42: $ElementType&lt;Obj, string&gt;);
(42: $ElementType&lt;Obj, boolean&gt;); // Nope, object keys aren't booleans
(true: $ElementType&lt;Obj, string&gt;); // Nope, elements are numbers


// Using arrays, we don't statically know the size of the array, so you can just use the `number` type as the key:
type Arr = Array&lt;boolean&gt;;
(true: $ElementType&lt;Arr, number&gt;);
(true: $ElementType&lt;Arr, boolean&gt;); // Nope, array indices aren't booleans
('foo': $ElementType&lt;Arr, number&gt;); // Nope, elements are booleans
</pre> <p>You can also nest calls to <code>$ElementType&lt;T, K&gt;</code>, which is useful when you need to access the types inside nested structures:</p> <pre data-language="javascript">// @flow
type NumberObj = {
  nums: Array&lt;number&gt;,
};

(42: $ElementType&lt;$ElementType&lt;NumberObj, 'nums'&gt;, number&gt;);
</pre> <p>Additionally, one of the things that also makes <code>$ElementType&lt;T, K&gt;</code> more powerful than <a href="#toc-propertytype"><code>$PropertyType&lt;T, k&gt;</code></a> is that you can use it with generics. For example:</p> <pre data-language="javascript">// @flow
function getProp&lt;O: {+[string]: mixed}, P: $Keys&lt;O&gt;&gt;(o: O, p: P): $ElementType&lt;O, P&gt; {
  return o[p];
}

(getProp({a: 42}, 'a'): number); // OK
(getProp({a: 42}, 'a'): string); // Error: number is not a string
getProp({a: 42}, 'b'); // Error: `b` does not exist
</pre> <h2 id="toc-nonmaybe">
<code>$NonMaybeType&lt;T&gt;</code> </h2> <p><code>$NonMaybeType&lt;T&gt;</code> converts a type <code>T</code> to a non-maybe type. In other words, the values of <code>$NonMaybeType&lt;T&gt;</code> are the values of <code>T</code> except for <code>null</code> and <code>undefined</code>.</p> <pre data-language="javascript">// @flow
type MaybeName = ?string;
type Name = $NonMaybeType&lt;MaybeName&gt;;

('Gabriel': MaybeName); // Ok
(null: MaybeName); // Ok
('Gabriel': Name); // Ok
(null: Name); // Error! null can't be annotated as Name because Name is not a maybe type
</pre> <h2 id="toc-objmap">
<code>$ObjMap&lt;T, F&gt;</code> </h2> <p><code>ObjMap&lt;T, F&gt;</code> takes an <a href="../objects">object type</a> <code>T</code>, and a <a href="../functions">function type</a> <code>F</code>, and returns the object type obtained by mapping the type of each value in the object with the provided function type <code>F</code>. In other words, <code>$ObjMap</code> will <a href="#toc-call">call</a> (at the type level) the given function type <code>F</code> for every property value type in <code>T</code>, and return the resulting object type from those calls.</p> <p>Let’s see an example. Suppose you have a function called <code>run</code> that takes an object of thunks (functions in the form <code>() =&gt; A</code>) as input:</p> <pre data-language="javascript">// @flow
function run&lt;O: {[key: string]: Function}&gt;(o: O) {
  return Object.keys(o).reduce((acc, k) =&gt; Object.assign(acc, { [k]: o[k]() }), {});
}
</pre> <p>The function’s purpose is to run all the thunks and return an object made of values. What’s the return type of this function?</p> <p>The keys are the same, but the values have a different type, namely the return type of each function. At a value level (the implementation of the function) we’re essentially mapping over the object to produce new values for the keys. How to express this at a type level?</p> <p>This is where <code>ObjMap&lt;T, F&gt;</code> comes in handy.</p> <pre data-language="javascript">// @flow

// let's write a function type that takes a `() =&gt; V` and returns a `V` (its return type)
type ExtractReturnType = &lt;V&gt;(() =&gt; V) =&gt; V;

declare function run&lt;O: {[key: string]: Function}&gt;(o: O): $ObjMap&lt;O, ExtractReturnType&gt;;

const o = {
  a: () =&gt; true,
  b: () =&gt; 'foo'
};

(run(o).a: boolean); // Ok
(run(o).b: string);  // Ok
// $ExpectError
(run(o).b: boolean); // Nope, b is a string
// $ExpectError
run(o).c;            // Nope, c was not in the original object
</pre> <p>This is extremely useful for expressing the return type of functions that manipulate objects values. You could use a similar approach (for instance) to provide the return type of bluebird’s <a href="http://bluebirdjs.com/docs/api/promise.props.html"><code>Promise.props</code></a> function, which is like <code>Promise.all</code> but takes an object as input.</p> <p>Here’s a possible declaration of this function, which is very similar to our first example:</p> <pre data-language="javascript">// @flow
declare function props&lt;A, O: { [key: string]: A }&gt;(promises: O): Promise&lt;$ObjMap&lt;O, typeof $await&gt;&gt;;
</pre> <p>And use:</p> <pre data-language="javascript">// @flow
const promises = { a: Promise.resolve(42) };
props(promises).then(o =&gt; {
  (o.a: 42); // Ok
  // $ExpectError
  (o.a: 43); // Error, flow knows it's 42
});
</pre> <h2 id="toc-objmapi">
<code>$ObjMapi&lt;T, F&gt;</code> </h2> <p><code>ObjMapi&lt;T, F&gt;</code> is similar to <a href="#toc-objmap"><code>ObjMap&lt;T, F&gt;</code></a>. The difference is that function type <code>F</code> will be <a href="#toc-call">called</a> with both the key and value types of the elements of the object type <code>T</code>, instead of just the value types. For example:</p> <pre data-language="javascript">// @flow
const o = {
  a: () =&gt; true,
  b: () =&gt; 'foo'
};

type ExtractReturnObjectType = &lt;K, V&gt;(K, () =&gt; V) =&gt; { k: K, v: V };

declare function run&lt;O: Object&gt;(o: O): $ObjMapi&lt;O, ExtractReturnObjectType&gt;;

(run(o).a: { k: 'a', v: boolean }); // Ok
(run(o).b: { k: 'b', v: string });  // Ok
// $ExpectError
(run(o).a: { k: 'b', v: boolean }); // Nope, a.k is "a"
// $ExpectError
(run(o).b: { k: 'b', v: number });  // Nope, b.v is a string
// $ExpectError
run(o).c;                           // Nope, c was not in the original object
</pre> <h2 id="toc-tuplemap">
<code>$TupleMap&lt;T, F&gt;</code> </h2> <p><code>$TupleMap&lt;T, F&gt;</code> takes an iterable type <code>T</code> (e.g.: <a href="../tuples"><code>Tuple</code></a> or <a href="../arrays"><code>Array</code></a>), and a <a href="../functions">function type</a> <code>F</code>, and returns the iterable type obtained by mapping the type of each value in the iterable with the provided function type <code>F</code>. This is analogous to the Javascript function <code>map</code>.</p> <p>Following our example from <a href="#toc-objmap"><code>$ObjMap&lt;T&gt;</code></a>, let’s assume that <code>run</code> takes an array of functions, instead of an object, and maps over them returning an array of the function call results. We could annotate its return type like this:</p> <pre data-language="javascript">// @flow

// Function type that takes a `() =&gt; V` and returns a `V` (its return type)
type ExtractReturnType = &lt;V&gt;(() =&gt; V) =&gt; V

function run&lt;A, I: Array&lt;() =&gt; A&gt;&gt;(iter: I): $TupleMap&lt;I, ExtractReturnType&gt; {
  return iter.map(fn =&gt; fn());
}

const arr = [() =&gt; 'foo', () =&gt; 'bar'];
(run(arr)[0]: string); // OK
(run(arr)[1]: string); // OK
(run(arr)[1]: boolean); // Error
</pre> <h2 id="toc-call">
<code>$Call&lt;F, T...&gt;</code> </h2> <p><code>$Call&lt;F, T...&gt;</code> is a type that represents the result of calling the given <a href="../functions">function type</a> <code>F</code> with 0 or more arguments <code>T...</code>. This is analogous to calling a function at runtime (or more specifically, it’s analogous to calling <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>Function.prototype.call</code></a>), but at the type level; this means that function type calls happens statically, i.e. not at runtime.</p> <p>Let’s see a couple of examples:</p> <pre data-language="javascript">// @flow

// Takes an object type, returns the type of its `prop` key
type ExtractPropType = &lt;T&gt;({prop: T}) =&gt; T;
type Obj = {prop: number};
type PropType = $Call&lt;ExtractPropType, Obj&gt;;  // Call `ExtractPropType` with `Obj` as an argument
type Nope = $Call&lt;ExtractPropType, {nope: number}&gt;;  // Error: argument doesn't match `Obj`.

(5: PropType); // OK
(true: PropType);  // Error: PropType is a number
(5: Nope);  // Error
</pre> <pre data-language="javascript">// @flow

// Takes a function type, and returns its return type
// This is useful if you want to get the return type of some function without actually calling it at runtime.
type ExtractReturnType = &lt;R&gt;(() =&gt; R) =&gt; R;
type Fn = () =&gt; number;
type ReturnType = $Call&lt;ExtractReturnType, Fn&gt; // Call `ExtractReturnType` with `Fn` as an argument

(5: ReturnType);  // OK
(true: ReturnType);  // Error: ReturnType is a number
</pre> <p><code>$Call</code> can be very powerful because it allows you to make calls in type-land that you would otherwise have to do at runtime. The type-land calls happen statically and will be erased at runtime.</p> <p>Let’s look at a couple of more advanced examples:</p> <pre data-language="javascript">// @flow

// Extracting deeply nested types:
type NestedObj = {|
  +status: ?number,
  +data: ?$ReadOnlyArray&lt;{|
    +foo: ?{|
       +bar: number,
    |},
  |}&gt;,
|};

// If you wanted to extract the type for `bar`, you could use $Call:
type BarType = $Call&lt;
  &lt;T&gt;({
    +data: ?$ReadOnlyArray&lt;{
      +foo: ?{
        +bar: ?T
      },
    }&gt;,
  }) =&gt; T,
  NestedObj,
&gt;;

(5: BarType);
(true: BarType);  // Error: `bar` is not a boolean
</pre> <pre data-language="javascript">// @flow

// Getting return types:
function getFirstValue&lt;V&gt;(map: Map&lt;string, V&gt;): ?V {
  for (const [key, value] of map.entries()) {
    return value;
  }
  return null;
}

// Using $Call, we can get the actual return type of the function above, without calling it at runtime:
type Value = $Call&lt;typeof getFirstValue, Map&lt;string, number&gt;&gt;;

(5: Value);
(true: Value);  // Error: Value is a `number`


// We could generalize it further:
type GetMapValue&lt;M&gt; =
  $Call&lt;typeof getFirstValue, M&gt;;

(5: GetMapValue&lt;Map&lt;string, number&gt;&gt;);
(true: GetMapValue&lt;Map&lt;string, boolean&gt;&gt;);
(true: GetMapValue&lt;Map&lt;string, number&gt;&gt;);  // Error: value is a `number`
</pre> <h2 id="toc-class">
<code>Class&lt;T&gt;</code> </h2> <p>Given a type <code>T</code> representing instances of a class <code>C</code>, the type <code>Class&lt;T&gt;</code> is the type of the class <code>C</code>. For example:</p> <pre data-language="javascript">// @flow
class Store {}
class ExtendedStore extends Store {}
class Model {}

function makeStore(storeClass: Class&lt;Store&gt;) {
  return new storeClass();
}

(makeStore(Store): Store);
(makeStore(ExtendedStore): Store);
(makeStore(Model): Model); // error
(makeStore(ExtendedStore): Model); // Flow infers the return type
</pre> <p>For classes that take type parameters, you must also provide the parameter. For example:</p> <pre data-language="javascript">// @flow
class ParamStore&lt;T&gt; {
  constructor(data: T) {}
}

function makeParamStore&lt;T&gt;(storeClass: Class&lt;ParamStore&lt;T&gt;&gt;, data: T): ParamStore&lt;T&gt; {
  return new storeClass(data);
}
(makeParamStore(ParamStore, 1): ParamStore&lt;number&gt;);
(makeParamStore(ParamStore, 1): ParamStore&lt;boolean&gt;); // failed because of the second parameter
</pre> <h2 id="toc-shape">
<code>$Shape&lt;T&gt;</code> </h2> <p>A variable of type <code>$Shape&lt;T&gt;</code>, where <code>T</code> is some object type, can be assigned objects <code>o</code> that contain a subset of the properties included in <code>T</code>. For each property <code>p: S</code> of <code>T</code>, the type of a potential binding of <code>p</code> in <code>o</code> must be compatible with <code>S</code>.</p> <p>For example</p> <pre data-language="javascript">// @flow
type Person = {
  age: number,
  name: string,
}
type PersonDetails = $Shape&lt;Person&gt;;

const person1: Person = {age: 28};  // Error: missing `name`
const person2: Person = {name: 'a'};  // Error: missing `age`
const person3: PersonDetails = {age: 28};  // OK
const person4: PersonDetails = {name: 'a'};  // OK
const person5: PersonDetails = {age: 28, name: 'a'};  // OK
const person6: PersonDetails = {age: '28'};  // Error: string is incompatible with number
</pre> <blockquote> <p>Note: <code>$Shape&lt;T&gt;</code> is <strong>not</strong> equivalent to <code>T</code> with all its fields marked as optional. In particular, Flow unsoundly allows <code>$Shape&lt;T&gt;</code> to be used as a <code>T</code> in several contexts. For example in</p> <pre data-language="plaintext">const personShape: PersonDetails = {age: 28};
(personShape: Person);</pre> <p>Flow will unsoundly allow this last cast to succeed. If this behavior is not wanted, then this utility type should be avoided.</p> </blockquote> <h2 id="toc-exports">
<code>$Exports&lt;T&gt;</code> </h2> <p>The following are functionally equivalent</p> <pre data-language="javascript">import typeof * as T from 'my-module';
</pre> <pre data-language="javascript">type T = $Exports&lt;'my-module'&gt;;
</pre> <p>The advantage of the <code>$Exports</code> syntax is that you can <code>export</code> the type on the same line</p> <pre data-language="javascript">export type T = $Exports&lt;'my-module'&gt;;
</pre> <p>where as you would otherwise need to export an alias in the <code>import typeof</code> case</p> <pre data-language="javascript">import typeof * as T from 'my-module';
export type MyModuleType = T;
</pre> <h2 id="toc-supertype">
<code>$Supertype&lt;T&gt;</code> </h2> <p>This utility has been deprecated and should be avoided. See <a href="https://flow.org/en/linting/rule-reference/#toc-deprecated-utility">here</a> for details.</p> <h2 id="toc-subtype">
<code>$Subtype&lt;T&gt;</code> </h2> <p>This utility has been deprecated and should be avoided. See <a href="https://flow.org/en/linting/rule-reference/#toc-deprecated-utility">here</a> for details.</p> <h2 id="toc-existential-type">Existential Type (<code>*</code>) </h2> <p>This utility has been deprecated and should be avoided. See <a href="https://flow.org/en/linting/rule-reference/#toc-deprecated-type">here</a> for details.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2013–present Facebook Inc.<br>Licensed under the MIT License.<br>
    <a href="https://flow.org/en/docs/types/utilities" class="_attribution-link">https://flow.org/en/docs/types/utilities</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
