
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>List - OCaml - W3cubDocs</title>
  
  <meta name="description" content=" List operations. ">
  <meta name="keywords" content="module, list, ocaml">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ocaml/libref/list.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c2f2e7d1236e299f399a2d9bf4342fa70a8839fbe6eb79130546d6bf383b99636ffdf29c557090085d7c4ac34eeb5426851b42d2f4ec63cf218916cbd19aa876.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/ocaml.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ocaml/" class="_nav-link" title="" style="margin-left:0;">OCaml</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _ocaml">
				
				
<h1>Module List</h1> <pre id="MODULEList" data-type="module List [Module List]" data-language="ocaml">module List: sig .. end</pre>
<div class="info module top"> <div class="info-desc"> <p>List operations.</p> <p>Some functions are flagged as not tail-recursive. A tail-recursive function uses constant stack space, while a non-tail-recursive function uses stack space proportional to the length of its list argument, which can be a problem with very long lists. When the function takes several list arguments, an approximate formula giving stack usage (in some unspecified constant unit) is shown in parentheses.</p> <p>The above considerations can usually be ignored if your lists are not longer than about 10000 elements.</p> </div> </div> <hr width="100%"> <pre id="TYPEt" data-type="type 'a t [Module List]" data-language="ocaml">type 'a t = 'a list = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTt.[]"><span class="constructor">[]</span></span></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTt.::"><span class="constructor">::</span></span> <span class="keyword">of</span> <code class="type">'a * 'a list</code></code>
</td> </tr>
</table> <div class="info "> <div class="info-desc"> <p>An alias for the type of lists.</p> </div> </div> <pre id="VALlength" data-type="val length [Module List]" data-language="ocaml">val length : 'a list -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Return the length (number of elements) of the given list.</p> </div> </div> <pre id="VALcompare_lengths" data-type="val compare_lengths [Module List]" data-language="ocaml">val compare_lengths : 'a list -&gt; 'b list -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Compare the lengths of two lists. <code class="code">compare_lengths l1 l2</code> is equivalent to <code class="code">compare (length l1) (length l2)</code>, except that the computation stops after itering on the shortest list.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05.0</li> </ul> </div> <pre id="VALcompare_length_with" data-type="val compare_length_with [Module List]" data-language="ocaml">val compare_length_with : 'a list -&gt; int -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Compare the length of a list to an integer. <code class="code">compare_length_with l n</code> is equivalent to <code class="code">compare (length l) n</code>, except that the computation stops after at most <code class="code">n</code> iterations on the list.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05.0</li> </ul> </div> <pre id="VALcons" data-type="val cons [Module List]" data-language="ocaml">val cons : 'a -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">cons x xs</code> is <code class="code">x :: xs</code></p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03.0</li> </ul> </div> <pre id="VALhd" data-type="val hd [Module List]" data-language="ocaml">val hd : 'a list -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p>Return the first element of the given list.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Failure</code> if the list is empty.</li> </ul> </div> <pre id="VALtl" data-type="val tl [Module List]" data-language="ocaml">val tl : 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Return the given list without its first element.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Failure</code> if the list is empty.</li> </ul> </div> <pre id="VALnth" data-type="val nth [Module List]" data-language="ocaml">val nth : 'a list -&gt; int -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p>Return the <code class="code">n</code>-th element of the given list. The first element (head of the list) is at position 0.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b><ul>
<li>
<code>Failure</code> if the list is too short.</li> <li>
<code>Invalid_argument</code> if <code class="code">n</code> is negative.</li> </ul>
</li> </ul> </div> <pre id="VALnth_opt" data-type="val nth_opt [Module List]" data-language="ocaml">val nth_opt : 'a list -&gt; int -&gt; 'a option</pre>
<div class="info "> <div class="info-desc"> <p>Return the <code class="code">n</code>-th element of the given list. The first element (head of the list) is at position 0. Return <code class="code"><span class="constructor">None</span></code> if the list is too short.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n</code> is negative.</li> </ul> </div> <pre id="VALrev" data-type="val rev [Module List]" data-language="ocaml">val rev : 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>List reversal.</p> </div> </div> <pre id="VALinit" data-type="val init [Module List]" data-language="ocaml">val init : int -&gt; (int -&gt; 'a) -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">List</span>.init len f</code> is <code class="code">[f 0; f 1; ...; f (len-1)]</code>, evaluated left to right.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.06.0</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if len &lt; 0.</li> </ul> </div> <pre id="VALappend" data-type="val append [Module List]" data-language="ocaml">val append : 'a list -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Concatenate two lists. Same as the infix operator <code class="code">@</code>. Not tail-recursive (length of the first argument).</p> </div> </div> <pre id="VALrev_append" data-type="val rev_append [Module List]" data-language="ocaml">val rev_append : 'a list -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">List</span>.rev_append l1 l2</code> reverses <code class="code">l1</code> and concatenates it to <code class="code">l2</code>. This is equivalent to <a href="list#VALrev"><code class="code"><span class="constructor">List</span>.rev</code></a><code class="code"> l1 @ l2</code>, but <code class="code">rev_append</code> is tail-recursive and more efficient.</p> </div> </div> <pre id="VALconcat" data-type="val concat [Module List]" data-language="ocaml">val concat : 'a list list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).</p> </div> </div> <pre id="VALflatten" data-type="val flatten [Module List]" data-language="ocaml">val flatten : 'a list list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>An alias for <code class="code">concat</code>.</p> </div> </div> <h2 id="1_Iterators">Iterators</h2> <pre id="VALiter" data-type="val iter [Module List]" data-language="ocaml">val iter : ('a -&gt; unit) -&gt; 'a list -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">List</span>.iter f [a1; ...; an]</code> applies function <code class="code">f</code> in turn to <code class="code">a1; ...; an</code>. It is equivalent to <code class="code"><span class="keyword">begin</span> f a1; f a2; ...; f an; () <span class="keyword">end</span></code>.</p> </div> </div> <pre id="VALiteri" data-type="val iteri [Module List]" data-language="ocaml">val iteri : (int -&gt; 'a -&gt; unit) -&gt; 'a list -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALiter"><code class="code"><span class="constructor">List</span>.iter</code></a>, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.00.0</li> </ul> </div> <pre id="VALmap" data-type="val map [Module List]" data-language="ocaml">val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">List</span>.map f [a1; ...; an]</code> applies function <code class="code">f</code> to <code class="code">a1, ..., an</code>, and builds the list <code class="code">[f a1; ...; f an]</code> with the results returned by <code class="code">f</code>. Not tail-recursive.</p> </div> </div> <pre id="VALmapi" data-type="val mapi [Module List]" data-language="ocaml">val mapi : (int -&gt; 'a -&gt; 'b) -&gt; 'a list -&gt; 'b list</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALmap"><code class="code"><span class="constructor">List</span>.map</code></a>, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument. Not tail-recursive.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.00.0</li> </ul> </div> <pre id="VALrev_map" data-type="val rev_map [Module List]" data-language="ocaml">val rev_map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">List</span>.rev_map f l</code> gives the same result as <a href="list#VALrev"><code class="code"><span class="constructor">List</span>.rev</code></a><code class="code"> (</code><a href="list#VALmap"><code class="code"><span class="constructor">List</span>.map</code></a><code class="code"> f l)</code>, but is tail-recursive and more efficient.</p> </div> </div> <pre id="VALfilter_map" data-type="val filter_map [Module List]" data-language="ocaml">val filter_map : ('a -&gt; 'b option) -&gt; 'a list -&gt; 'b list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">filter_map f l</code> applies <code class="code">f</code> to every element of <code class="code">l</code>, filters out the <code class="code"><span class="constructor">None</span></code> elements and returns the list of the arguments of the <code class="code"><span class="constructor">Some</span></code> elements.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08.0</li> </ul> </div> <pre id="VALconcat_map" data-type="val concat_map [Module List]" data-language="ocaml">val concat_map : ('a -&gt; 'b list) -&gt; 'a list -&gt; 'b list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">List</span>.concat_map f l</code> gives the same result as <a href="list#VALconcat"><code class="code"><span class="constructor">List</span>.concat</code></a><code class="code"> (</code><a href="list#VALmap"><code class="code"><span class="constructor">List</span>.map</code></a><code class="code"> f l)</code>. Tail-recursive.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.10.0</li> </ul> </div> <pre id="VALfold_left_map" data-type="val fold_left_map [Module List]" data-language="ocaml">val fold_left_map : ('a -&gt; 'b -&gt; 'a * 'c) -&gt; 'a -&gt; 'b list -&gt; 'a * 'c list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_left_map</code> is a combination of <code class="code">fold_left</code> and <code class="code">map</code> that threads an accumulator through calls to <code class="code">f</code></p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.11.0</li> </ul> </div> <pre id="VALfold_left" data-type="val fold_left [Module List]" data-language="ocaml">val fold_left : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">List</span>.fold_left f a [b1; ...; bn]</code> is <code class="code">f (... (f (f a b1) b2) ...) bn</code>.</p> </div> </div> <pre id="VALfold_right" data-type="val fold_right [Module List]" data-language="ocaml">val fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'a list -&gt; 'b -&gt; 'b</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">List</span>.fold_right f [a1; ...; an] b</code> is <code class="code">f a1 (f a2 (... (f an b) ...))</code>. Not tail-recursive.</p> </div> </div> <h2 id="1_Iteratorsontwolists">Iterators on two lists</h2> <pre id="VALiter2" data-type="val iter2 [Module List]" data-language="ocaml">val iter2 : ('a -&gt; 'b -&gt; unit) -&gt; 'a list -&gt; 'b list -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">List</span>.iter2 f [a1; ...; an] [b1; ...; bn]</code> calls in turn <code class="code">f a1 b1; ...; f an bn</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists are determined to have different lengths.</li> </ul> </div> <pre id="VALmap2" data-type="val map2 [Module List]" data-language="ocaml">val map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">List</span>.map2 f [a1; ...; an] [b1; ...; bn]</code> is <code class="code">[f a1 b1; ...; f an bn]</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists are determined to have different lengths. Not tail-recursive.</li> </ul> </div> <pre id="VALrev_map2" data-type="val rev_map2 [Module List]" data-language="ocaml">val rev_map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">List</span>.rev_map2 f l1 l2</code> gives the same result as <a href="list#VALrev"><code class="code"><span class="constructor">List</span>.rev</code></a><code class="code"> (</code><a href="list#VALmap2"><code class="code"><span class="constructor">List</span>.map2</code></a><code class="code"> f l1 l2)</code>, but is tail-recursive and more efficient.</p> </div> </div> <pre id="VALfold_left2" data-type="val fold_left2 [Module List]" data-language="ocaml">val fold_left2 : ('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'c list -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">List</span>.fold_left2 f a [b1; ...; bn] [c1; ...; cn]</code> is <code class="code">f (... (f (f a b1 c1) b2 c2) ...) bn cn</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists are determined to have different lengths.</li> </ul> </div> <pre id="VALfold_right2" data-type="val fold_right2 [Module List]" data-language="ocaml">val fold_right2 : ('a -&gt; 'b -&gt; 'c -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c -&gt; 'c</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">List</span>.fold_right2 f [a1; ...; an] [b1; ...; bn] c</code> is <code class="code">f a1 b1 (f a2 b2 (... (f an bn c) ...))</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists are determined to have different lengths. Not tail-recursive.</li> </ul> </div> <h2 id="1_Listscanning">List scanning</h2> <pre id="VALfor_all" data-type="val for_all [Module List]" data-language="ocaml">val for_all : ('a -&gt; bool) -&gt; 'a list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">for_all p [a1; ...; an]</code> checks if all elements of the list satisfy the predicate <code class="code">p</code>. That is, it returns <code class="code">(p a1) <span class="keywordsign">&amp;&amp;</span> (p a2) <span class="keywordsign">&amp;&amp;</span> ... <span class="keywordsign">&amp;&amp;</span> (p an)</code> for a non-empty list and <code class="code"><span class="keyword">true</span></code> if the list is empty.</p> </div> </div> <pre id="VALexists" data-type="val exists [Module List]" data-language="ocaml">val exists : ('a -&gt; bool) -&gt; 'a list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">exists p [a1; ...; an]</code> checks if at least one element of the list satisfies the predicate <code class="code">p</code>. That is, it returns <code class="code">(p a1) <span class="keywordsign">||</span> (p a2) <span class="keywordsign">||</span> ... <span class="keywordsign">||</span> (p an)</code> for a non-empty list and <code class="code"><span class="keyword">false</span></code> if the list is empty.</p> </div> </div> <pre id="VALfor_all2" data-type="val for_all2 [Module List]" data-language="ocaml">val for_all2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALfor_all"><code class="code"><span class="constructor">List</span>.for_all</code></a>, but for a two-argument predicate.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists are determined to have different lengths.</li> </ul> </div> <pre id="VALexists2" data-type="val exists2 [Module List]" data-language="ocaml">val exists2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALexists"><code class="code"><span class="constructor">List</span>.exists</code></a>, but for a two-argument predicate.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists are determined to have different lengths.</li> </ul> </div> <pre id="VALmem" data-type="val mem [Module List]" data-language="ocaml">val mem : 'a -&gt; 'a list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">mem a l</code> is true if and only if <code class="code">a</code> is equal to an element of <code class="code">l</code>.</p> </div> </div> <pre id="VALmemq" data-type="val memq [Module List]" data-language="ocaml">val memq : 'a -&gt; 'a list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALmem"><code class="code"><span class="constructor">List</span>.mem</code></a>, but uses physical equality instead of structural equality to compare list elements.</p> </div> </div> <h2 id="1_Listsearching">List searching</h2> <pre id="VALfind" data-type="val find [Module List]" data-language="ocaml">val find : ('a -&gt; bool) -&gt; 'a list -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find p l</code> returns the first element of the list <code class="code">l</code> that satisfies the predicate <code class="code">p</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Not_found</code> if there is no value that satisfies <code class="code">p</code> in the list <code class="code">l</code>.</li> </ul> </div> <pre id="VALfind_opt" data-type="val find_opt [Module List]" data-language="ocaml">val find_opt : ('a -&gt; bool) -&gt; 'a list -&gt; 'a option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_opt p l</code> returns the first element of the list <code class="code">l</code> that satisfies the predicate <code class="code">p</code>, or <code class="code"><span class="constructor">None</span></code> if there is no value that satisfies <code class="code">p</code> in the list <code class="code">l</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <pre id="VALfind_map" data-type="val find_map [Module List]" data-language="ocaml">val find_map : ('a -&gt; 'b option) -&gt; 'a list -&gt; 'b option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_map f l</code> applies <code class="code">f</code> to the elements of <code class="code">l</code> in order, and returns the first result of the form <code class="code"><span class="constructor">Some</span> v</code>, or <code class="code"><span class="constructor">None</span></code> if none exist.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.10.0</li> </ul> </div> <pre id="VALfilter" data-type="val filter [Module List]" data-language="ocaml">val filter : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">filter p l</code> returns all the elements of the list <code class="code">l</code> that satisfy the predicate <code class="code">p</code>. The order of the elements in the input list is preserved.</p> </div> </div> <pre id="VALfind_all" data-type="val find_all [Module List]" data-language="ocaml">val find_all : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_all</code> is another name for <a href="list#VALfilter"><code class="code"><span class="constructor">List</span>.filter</code></a>.</p> </div> </div> <pre id="VALfilteri" data-type="val filteri [Module List]" data-language="ocaml">val filteri : (int -&gt; 'a -&gt; bool) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALfilter"><code class="code"><span class="constructor">List</span>.filter</code></a>, but the predicate is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.11.0</li> </ul> </div> <pre id="VALpartition" data-type="val partition [Module List]" data-language="ocaml">val partition : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">partition p l</code> returns a pair of lists <code class="code">(l1, l2)</code>, where <code class="code">l1</code> is the list of all the elements of <code class="code">l</code> that satisfy the predicate <code class="code">p</code>, and <code class="code">l2</code> is the list of all the elements of <code class="code">l</code> that do not satisfy <code class="code">p</code>. The order of the elements in the input list is preserved.</p> </div> </div> <h2 id="1_Associationlists">Association lists</h2> <pre id="VALassoc" data-type="val assoc [Module List]" data-language="ocaml">val assoc : 'a -&gt; ('a * 'b) list -&gt; 'b</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">assoc a l</code> returns the value associated with key <code class="code">a</code> in the list of pairs <code class="code">l</code>. That is, <code class="code">assoc a [ ...; (a,b); ...] = b</code> if <code class="code">(a,b)</code> is the leftmost binding of <code class="code">a</code> in list <code class="code">l</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Not_found</code> if there is no value associated with <code class="code">a</code> in the list <code class="code">l</code>.</li> </ul> </div> <pre id="VALassoc_opt" data-type="val assoc_opt [Module List]" data-language="ocaml">val assoc_opt : 'a -&gt; ('a * 'b) list -&gt; 'b option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">assoc_opt a l</code> returns the value associated with key <code class="code">a</code> in the list of pairs <code class="code">l</code>. That is, <code class="code">assoc_opt a [ ...; (a,b); ...] = b</code> if <code class="code">(a,b)</code> is the leftmost binding of <code class="code">a</code> in list <code class="code">l</code>. Returns <code class="code"><span class="constructor">None</span></code> if there is no value associated with <code class="code">a</code> in the list <code class="code">l</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <pre id="VALassq" data-type="val assq [Module List]" data-language="ocaml">val assq : 'a -&gt; ('a * 'b) list -&gt; 'b</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALassoc"><code class="code"><span class="constructor">List</span>.assoc</code></a>, but uses physical equality instead of structural equality to compare keys.</p> </div> </div> <pre id="VALassq_opt" data-type="val assq_opt [Module List]" data-language="ocaml">val assq_opt : 'a -&gt; ('a * 'b) list -&gt; 'b option</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALassoc_opt"><code class="code"><span class="constructor">List</span>.assoc_opt</code></a>, but uses physical equality instead of structural equality to compare keys.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <pre id="VALmem_assoc" data-type="val mem_assoc [Module List]" data-language="ocaml">val mem_assoc : 'a -&gt; ('a * 'b) list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALassoc"><code class="code"><span class="constructor">List</span>.assoc</code></a>, but simply return true if a binding exists, and false if no bindings exist for the given key.</p> </div> </div> <pre id="VALmem_assq" data-type="val mem_assq [Module List]" data-language="ocaml">val mem_assq : 'a -&gt; ('a * 'b) list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALmem_assoc"><code class="code"><span class="constructor">List</span>.mem_assoc</code></a>, but uses physical equality instead of structural equality to compare keys.</p> </div> </div> <pre id="VALremove_assoc" data-type="val remove_assoc [Module List]" data-language="ocaml">val remove_assoc : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">remove_assoc a l</code> returns the list of pairs <code class="code">l</code> without the first pair with key <code class="code">a</code>, if any. Not tail-recursive.</p> </div> </div> <pre id="VALremove_assq" data-type="val remove_assq [Module List]" data-language="ocaml">val remove_assq : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALremove_assoc"><code class="code"><span class="constructor">List</span>.remove_assoc</code></a>, but uses physical equality instead of structural equality to compare keys. Not tail-recursive.</p> </div> </div> <h2 id="1_Listsofpairs">Lists of pairs</h2> <pre id="VALsplit" data-type="val split [Module List]" data-language="ocaml">val split : ('a * 'b) list -&gt; 'a list * 'b list</pre>
<div class="info "> <div class="info-desc"> <p>Transform a list of pairs into a pair of lists: <code class="code">split [(a1,b1); ...; (an,bn)]</code> is <code class="code">([a1; ...; an], [b1; ...; bn])</code>. Not tail-recursive.</p> </div> </div> <pre id="VALcombine" data-type="val combine [Module List]" data-language="ocaml">val combine : 'a list -&gt; 'b list -&gt; ('a * 'b) list</pre>
<div class="info "> <div class="info-desc"> <p>Transform a pair of lists into a list of pairs: <code class="code">combine [a1; ...; an] [b1; ...; bn]</code> is <code class="code">[(a1,b1); ...; (an,bn)]</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</li> </ul> </div> <h2 id="1_Sorting">Sorting</h2> <pre id="VALsort" data-type="val sort [Module List]" data-language="ocaml">val sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, <a href="stdlib#VALcompare"><code class="code">compare</code></a> is a suitable comparison function. The resulting list is sorted in increasing order. <code class="code"><span class="constructor">List</span>.sort</code> is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</p> <p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p> </div> </div> <pre id="VALstable_sort" data-type="val stable_sort [Module List]" data-language="ocaml">val stable_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALsort"><code class="code"><span class="constructor">List</span>.sort</code></a>, but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order) .</p> <p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p> </div> </div> <pre id="VALfast_sort" data-type="val fast_sort [Module List]" data-language="ocaml">val fast_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALsort"><code class="code"><span class="constructor">List</span>.sort</code></a> or <a href="list#VALstable_sort"><code class="code"><span class="constructor">List</span>.stable_sort</code></a>, whichever is faster on typical input.</p> </div> </div> <pre id="VALsort_uniq" data-type="val sort_uniq [Module List]" data-language="ocaml">val sort_uniq : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="list#VALsort"><code class="code"><span class="constructor">List</span>.sort</code></a>, but also remove duplicates.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.02.0</li> </ul> </div> <pre id="VALmerge" data-type="val merge [Module List]" data-language="ocaml">val merge : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Merge two lists: Assuming that <code class="code">l1</code> and <code class="code">l2</code> are sorted according to the comparison function <code class="code">cmp</code>, <code class="code">merge cmp l1 l2</code> will return a sorted list containing all the elements of <code class="code">l1</code> and <code class="code">l2</code>. If several elements compare equal, the elements of <code class="code">l1</code> will be before the elements of <code class="code">l2</code>. Not tail-recursive (sum of the lengths of the arguments).</p> </div> </div> <h2 id="1_Iterators">Iterators</h2> <pre id="VALto_seq" data-type="val to_seq [Module List]" data-language="ocaml">val to_seq : 'a list -&gt; 'a Seq.t</pre>
<div class="info "> <div class="info-desc"> <p>Iterate on the list</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div> <pre id="VALof_seq" data-type="val of_seq [Module List]" data-language="ocaml">val of_seq : 'a Seq.t -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Create a list from the iterator</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © INRIA 1995-2020.<br>
    <a href="https://www.ocaml.org/releases/4.11/htmlman/libref/List.html" class="_attribution-link">https://www.ocaml.org/releases/4.11/htmlman/libref/List.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
