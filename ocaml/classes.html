
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>07.09. Classes - OCaml - W3cubDocs</title>
  
  <meta name="description" content=" Classes are defined using a small language, similar to the module language. ">
  <meta name="keywords" content="classes, ocaml">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ocaml/classes.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/ocaml.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ocaml/" class="_nav-link" title="" style="margin-left:0;">OCaml</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _ocaml">
				
				
<a href="typedecl"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjQgMjQiIGhlaWdodD0iMjQiIHdpZHRoPSIyNCIgPgogIDxwYXRoIGQ9Ik00IDEybDggOGwxLjQxNCAtMS40MTRMNy44MjggMTNIMjB2LTJINy44MjhMMTMuNDE0IDUuNDE0TDEyIDR6Ii8+Cjwvc3ZnPgo=" alt="Previous"></a> <a href="language"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDI0IDI0IiBoZWlnaHQ9IjI0IiB3aWR0aD0iMjQiPgogIDxwYXRoIGQ9Ik0xMiA0bDggOGwtMS40MTQgMS40MTRMMTMgNy44MjhWMjBoLTJWNy44MjhMNS40MTQgMTMuNDE0TDQgMTJ6Ii8+Cjwvc3ZnPgo=" alt="Up"></a> <a href="modtypes"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjQgMjQiIGhlaWdodD0iMjQiIHdpZHRoPSIyNCIgPgogIDxwYXRoIGQ9Ik0yMCAxMmwtOCA4bC0xLjQxNCAtMS40MTRMMTYuMTcyIDEzSDR2LTJIMTYuMTcyTDEwLjU4NiA1LjQxNEwxMiA0IHoiLz4KPC9zdmc+Cg==" alt="Next"></a> <hr> <h2 class="section" id="s:classes">
<a class="section-anchor" href="#s:classes" aria-hidden="true">﻿</a>7.9 Classes</h2> <ul> <li>
<a href="classes#ss%3Aclasses%3Aclass-types">7.9.1 Class types</a> </li>
<li>
<a href="classes#ss%3Aclass-expr">7.9.2 Class expressions</a> </li>
<li>
<a href="classes#ss%3Aclass-def">7.9.3 Class definitions</a> </li>
<li>
<a href="classes#ss%3Aclass-spec">7.9.4 Class specifications</a> </li>
<li>
<a href="classes#ss%3Aclasstype">7.9.5 Class type definitions</a> </li>
</ul> <p> Classes are defined using a small language, similar to the module language.</p> <h3 class="subsection" id="ss:classes:class-types">
<a class="section-anchor" href="#ss:classes:class-types" aria-hidden="true">﻿</a>7.9.1 Class types</h3> <p>Class types are the class-level equivalent of type expressions: they specify the general shape and type properties of classes.</p>

<div class="syntax"><table class="display dcenter">
<tr class="c019"><td class="dcell"><table class="c001 cellpading0">
<tr>
<td class="c018"> <a class="syntax" id="class-type"><span class="c010">class-type</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> [[<span class="c004">?</span>]<a class="syntax" href="lex#label-name"><span class="c010">label-name</span></a><span class="c004">:</span>] <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> <span class="c004">-&gt;</span> <a class="syntax" href="#class-type"><span class="c010">class-type</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <a class="syntax" href="#class-body-type"><span class="c010">class-body-type</span></a> </td>
</tr> <tr><td class="c018"> </td></tr> <tr>
<td class="c018"> <a class="syntax" id="class-body-type"><span class="c010">class-body-type</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> <span class="c004">object</span> [<span class="c004">(</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> <span class="c004">)</span>] {<a class="syntax" href="#class-field-spec"><span class="c010">class-field-spec</span></a>} <span class="c004">end</span> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> [<span class="c004">[</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> {<span class="c004">,</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a>} <span class="c004">]</span>] <a class="syntax" href="names#classtype-path"><span class="c010">classtype-path</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">let</span> <span class="c004">open</span> <a class="syntax" href="names#module-path"><span class="c010">module-path</span></a> <span class="c004">in</span> <a class="syntax" href="#class-body-type"><span class="c010">class-body-type</span></a> </td>
</tr> <tr><td class="c018"> </td></tr> <tr>
<td class="c018"> <a class="syntax" id="class-field-spec"><span class="c010">class-field-spec</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> <span class="c004">inherit</span> <a class="syntax" href="#class-body-type"><span class="c010">class-body-type</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">val</span> [<span class="c004">mutable</span>] [<span class="c004">virtual</span>] <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">val</span> <span class="c004">virtual</span> <span class="c004">mutable</span> <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">method</span> [<span class="c004">private</span>] [<span class="c004">virtual</span>] <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#poly-typexpr"><span class="c010">poly-typexpr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">method</span> <span class="c004">virtual</span> <span class="c004">private</span> <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#poly-typexpr"><span class="c010">poly-typexpr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">constraint</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> <span class="c004">=</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> </td>
</tr> </table></td></tr> </table></div>
<p> See also the following language extensions: <a href="attributes#s%3Aattributes">attributes</a> and <a href="extensionnodes#s%3Aextension-nodes">extension nodes</a>.</p>
<h4 class="subsubsection" id="sss:clty:simple">
<a class="section-anchor" href="#sss:clty:simple" aria-hidden="true">﻿</a>Simple class expressions</h4> <p>The expression <a class="syntax" href="names#classtype-path"><span class="c010">classtype-path</span></a> is equivalent to the class type bound to the name <a class="syntax" href="names#classtype-path"><span class="c010">classtype-path</span></a>. Similarly, the expression <span class="c004">[</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a><sub>1</sub> <span class="c004">,</span> … <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a><sub><span class="c009">n</span></sub> <span class="c004">]</span> <a class="syntax" href="names#classtype-path"><span class="c010">classtype-path</span></a> is equivalent to the parametric class type bound to the name <a class="syntax" href="names#classtype-path"><span class="c010">classtype-path</span></a>, in which type parameters have been instantiated to respectively <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a><sub>1</sub>, …<a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a><sub><span class="c009">n</span></sub>.</p>
<h4 class="subsubsection" id="sss:clty-fun">
<a class="section-anchor" href="#sss:clty-fun" aria-hidden="true">﻿</a>Class function type</h4> <p>The class type expression <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> <span class="c004">-&gt;</span> <a class="syntax" href="#class-type"><span class="c010">class-type</span></a> is the type of class functions (functions from values to classes) that take as argument a value of type <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> and return as result a class of type <a class="syntax" href="#class-type"><span class="c010">class-type</span></a>.</p>
<h4 class="subsubsection" id="sss:clty:body">
<a class="section-anchor" href="#sss:clty:body" aria-hidden="true">﻿</a>Class body type</h4> <p>The class type expression <span class="c004">object</span> [<span class="c004">(</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> <span class="c004">)</span>] {<a class="syntax" href="#class-field-spec"><span class="c010">class-field-spec</span></a>} <span class="c004">end</span> is the type of a class body. It specifies its instance variables and methods. In this type, <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> is matched against the self type, therefore providing a name for the self type.</p>
<p>A class body will match a class body type if it provides definitions for all the components specified in the class body type, and these definitions meet the type requirements given in the class body type. Furthermore, all methods either virtual or public present in the class body must also be present in the class body type (on the other hand, some instance variables and concrete private methods may be omitted). A virtual method will match a concrete method, which makes it possible to forget its implementation. An immutable instance variable will match a mutable instance variable.</p>
<h4 class="subsubsection" id="sss:clty-open">
<a class="section-anchor" href="#sss:clty-open" aria-hidden="true">﻿</a>Local opens</h4> <p>Local opens are supported in class types since OCaml 4.06.</p>
<h4 class="subsubsection" id="sss:clty-inheritance">
<a class="section-anchor" href="#sss:clty-inheritance" aria-hidden="true">﻿</a>Inheritance</h4> 
<p>The inheritance construct <span class="c004">inherit</span> <a class="syntax" href="#class-body-type"><span class="c010">class-body-type</span></a> provides for inclusion of methods and instance variables from other class types. The instance variable and method types from <a class="syntax" href="#class-body-type"><span class="c010">class-body-type</span></a> are added into the current class type.</p>
<h4 class="subsubsection" id="sss:clty-variable">
<a class="section-anchor" href="#sss:clty-variable" aria-hidden="true">﻿</a>Instance variable specification</h4> 
<p>A specification of an instance variable is written <span class="c004">val</span> [<span class="c004">mutable</span>] [<span class="c004">virtual</span>] <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a>, where <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> is the name of the instance variable and <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> its expected type. The flag <span class="c004">mutable</span> indicates whether this instance variable can be physically modified. The flag <span class="c004">virtual</span> indicates that this instance variable is not initialized. It can be initialized later through inheritance.</p>
<p>An instance variable specification will hide any previous specification of an instance variable of the same name.</p>
<h4 class="subsubsection" id="sss:clty-meth">
<a class="section-anchor" href="#sss:clty-meth" aria-hidden="true">﻿</a>Method specification</h4> 
<p>The specification of a method is written <span class="c004">method</span> [<span class="c004">private</span>] <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#poly-typexpr"><span class="c010">poly-typexpr</span></a>, where <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> is the name of the method and <a class="syntax" href="types#poly-typexpr"><span class="c010">poly-typexpr</span></a> its expected type, possibly polymorphic. The flag <span class="c004">private</span> indicates that the method cannot be accessed from outside the object.</p>
<p>The polymorphism may be left implicit in public method specifications: any type variable which is not bound to a class parameter and does not appear elsewhere inside the class specification will be assumed to be universal, and made polymorphic in the resulting method type. Writing an explicit polymorphic type will disable this behaviour.</p>
<p>If several specifications are present for the same method, they must have compatible types. Any non-private specification of a method forces it to be public.</p>
<h4 class="subsubsection" id="sss:class-virtual-meth-spec">
<a class="section-anchor" href="#sss:class-virtual-meth-spec" aria-hidden="true">﻿</a>Virtual method specification</h4> 
<p>A virtual method specification is written <span class="c004">method</span> [<span class="c004">private</span>] <span class="c004">virtual</span> <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#poly-typexpr"><span class="c010">poly-typexpr</span></a>, where <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> is the name of the method and <a class="syntax" href="types#poly-typexpr"><span class="c010">poly-typexpr</span></a> its expected type.</p>
<h4 class="subsubsection" id="sss:class-constraints">
<a class="section-anchor" href="#sss:class-constraints" aria-hidden="true">﻿</a>Constraints on type parameters</h4> 
<p>The construct <span class="c004">constraint</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a><sub>1</sub> <span class="c004">=</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a><sub>2</sub> forces the two type expressions to be equal. This is typically used to specify type parameters: in this way, they can be bound to specific type expressions.</p> <h3 class="subsection" id="ss:class-expr">
<a class="section-anchor" href="#ss:class-expr" aria-hidden="true">﻿</a>7.9.2 Class expressions</h3> <p>Class expressions are the class-level equivalent of value expressions: they evaluate to classes, thus providing implementations for the specifications expressed in class types.</p>

<div class="syntax"><table class="display dcenter">
<tr class="c019"><td class="dcell"><table class="c001 cellpading0">
<tr>
<td class="c018"> <a class="syntax" id="class-expr"><span class="c010">class-expr</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> <a class="syntax" href="names#class-path"><span class="c010">class-path</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">[</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> {<span class="c004">,</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a>} <span class="c004">]</span> <a class="syntax" href="names#class-path"><span class="c010">class-path</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">(</span> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> <span class="c004">)</span> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">(</span> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> <span class="c004">:</span> <a class="syntax" href="#class-type"><span class="c010">class-type</span></a> <span class="c004">)</span> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> {<a class="syntax" href="expr#argument"><span class="c010">argument</span></a>}<sup>+</sup> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">fun</span> {<a class="syntax" href="expr#parameter"><span class="c010">parameter</span></a>}<sup>+</sup> <span class="c004">-&gt;</span> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">let</span> [<span class="c004">rec</span>] <a class="syntax" href="expr#let-binding"><span class="c010">let-binding</span></a> {<span class="c004">and</span> <a class="syntax" href="expr#let-binding"><span class="c010">let-binding</span></a>} <span class="c004">in</span> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">object</span> <a class="syntax" href="#class-body"><span class="c010">class-body</span></a> <span class="c004">end</span> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">let</span> <span class="c004">open</span> <a class="syntax" href="names#module-path"><span class="c010">module-path</span></a> <span class="c004">in</span> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> </td>
</tr> <tr><td class="c018"> </td></tr> </table></td></tr> </table></div>
<div class="syntax"><table class="display dcenter">
<tr class="c019"><td class="dcell"><table class="c001 cellpading0">
<tr>
<td class="c018"> <a class="syntax" id="class-field"><span class="c010">class-field</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> <span class="c004">inherit</span> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> [<span class="c004">as</span> <a class="syntax" href="lex#lowercase-ident"><span class="c010">lowercase-ident</span></a>] </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">inherit!</span> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> [<span class="c004">as</span> <a class="syntax" href="lex#lowercase-ident"><span class="c010">lowercase-ident</span></a>] </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">val</span> [<span class="c004">mutable</span>] <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> [<span class="c004">:</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a>] <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">val!</span> [<span class="c004">mutable</span>] <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> [<span class="c004">:</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a>] <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">val</span> [<span class="c004">mutable</span>] <span class="c004">virtual</span> <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">val</span> <span class="c004">virtual</span> <span class="c004">mutable</span> <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">method</span> [<span class="c004">private</span>] <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> {<a class="syntax" href="expr#parameter"><span class="c010">parameter</span></a>} [<span class="c004">:</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a>] <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">method!</span> [<span class="c004">private</span>] <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> {<a class="syntax" href="expr#parameter"><span class="c010">parameter</span></a>} [<span class="c004">:</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a>] <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">method</span> [<span class="c004">private</span>] <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#poly-typexpr"><span class="c010">poly-typexpr</span></a> <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">method!</span> [<span class="c004">private</span>] <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#poly-typexpr"><span class="c010">poly-typexpr</span></a> <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">method</span> [<span class="c004">private</span>] <span class="c004">virtual</span> <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#poly-typexpr"><span class="c010">poly-typexpr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">method</span> <span class="c004">virtual</span> <span class="c004">private</span> <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#poly-typexpr"><span class="c010">poly-typexpr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">constraint</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> <span class="c004">=</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">initializer</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> </td>
</tr> </table></td></tr> </table></div>
<p> See also the following language extensions: <a href="locallyabstract#s%3Alocally-abstract">locally abstract types</a>, <a href="attributes#s%3Aattributes">attributes</a> and <a href="extensionnodes#s%3Aextension-nodes">extension nodes</a>.</p>
<h4 class="subsubsection" id="sss:class-simple">
<a class="section-anchor" href="#sss:class-simple" aria-hidden="true">﻿</a>Simple class expressions</h4> <p>The expression <a class="syntax" href="names#class-path"><span class="c010">class-path</span></a> evaluates to the class bound to the name <a class="syntax" href="names#class-path"><span class="c010">class-path</span></a>. Similarly, the expression <span class="c004">[</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a><sub>1</sub> <span class="c004">,</span> … <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a><sub><span class="c009">n</span></sub> <span class="c004">]</span> <a class="syntax" href="names#class-path"><span class="c010">class-path</span></a> evaluates to the parametric class bound to the name <a class="syntax" href="names#class-path"><span class="c010">class-path</span></a>, in which type parameters have been instantiated respectively to <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a><sub>1</sub>, …<a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a><sub><span class="c009">n</span></sub>.</p>
<p>The expression <span class="c004">(</span> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> <span class="c004">)</span> evaluates to the same module as <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a>.</p>
<p>The expression <span class="c004">(</span> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> <span class="c004">:</span> <a class="syntax" href="#class-type"><span class="c010">class-type</span></a> <span class="c004">)</span> checks that <a class="syntax" href="#class-type"><span class="c010">class-type</span></a> matches the type of <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> (that is, that the implementation <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> meets the type specification <a class="syntax" href="#class-type"><span class="c010">class-type</span></a>). The whole expression evaluates to the same class as <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a>, except that all components not specified in <a class="syntax" href="#class-type"><span class="c010">class-type</span></a> are hidden and can no longer be accessed.</p>
<h4 class="subsubsection" id="sss:class-app">
<a class="section-anchor" href="#sss:class-app" aria-hidden="true">﻿</a>Class application</h4> <p>Class application is denoted by juxtaposition of (possibly labeled) expressions. It denotes the class whose constructor is the first expression applied to the given arguments. The arguments are evaluated as for expression application, but the constructor itself will only be evaluated when objects are created. In particular, side-effects caused by the application of the constructor will only occur at object creation time.</p>
<h4 class="subsubsection" id="sss:class-fun">
<a class="section-anchor" href="#sss:class-fun" aria-hidden="true">﻿</a>Class function</h4> <p>The expression <span class="c004">fun</span> [[<span class="c004">?</span>]<a class="syntax" href="lex#label-name"><span class="c010">label-name</span></a><span class="c004">:</span>] <a class="syntax" href="patterns#pattern"><span class="c010">pattern</span></a> <span class="c004">-&gt;</span> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> evaluates to a function from values to classes. When this function is applied to a value <span class="c009">v</span>, this value is matched against the pattern <a class="syntax" href="patterns#pattern"><span class="c010">pattern</span></a> and the result is the result of the evaluation of <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> in the extended environment.</p>
<p>Conversion from functions with default values to functions with patterns only works identically for class functions as for normal functions.</p>
<p>The expression </p>
<div class="center"> <span class="c004">fun</span> <a class="syntax" href="expr#parameter"><span class="c010">parameter</span></a><sub>1</sub> … <a class="syntax" href="expr#parameter"><span class="c010">parameter</span></a><sub><span class="c009">n</span></sub> <span class="c004">-&gt;</span> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> </div>
<p> is a short form for </p>
<div class="center"> <span class="c004">fun</span> <a class="syntax" href="expr#parameter"><span class="c010">parameter</span></a><sub>1</sub> <span class="c004">-&gt;</span> … <span class="c004">fun</span> <a class="syntax" href="expr#parameter"><span class="c010">parameter</span></a><sub><span class="c009">n</span></sub> <span class="c004">-&gt;</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> </div>
<h4 class="subsubsection" id="sss:class-localdefs">
<a class="section-anchor" href="#sss:class-localdefs" aria-hidden="true">﻿</a>Local definitions</h4> <p>The <span class="c003">let</span> and <span class="c003">let rec</span> constructs bind value names locally, as for the core language expressions.</p>
<p>If a local definition occurs at the very beginning of a class definition, it will be evaluated when the class is created (just as if the definition was outside of the class). Otherwise, it will be evaluated when the object constructor is called.</p>
<h4 class="subsubsection" id="sss:class-opens">
<a class="section-anchor" href="#sss:class-opens" aria-hidden="true">﻿</a>Local opens</h4> <p>Local opens are supported in class expressions since OCaml 4.06.</p>
<h4 class="subsubsection" id="sss:class-body">
<a class="section-anchor" href="#sss:class-body" aria-hidden="true">﻿</a>Class body</h4> <div class="syntax"><table class="display dcenter">
<tr class="c019"><td class="dcell"><table class="c001 cellpading0">
<tr>
<td class="c018"> <a class="syntax" id="class-body"><span class="c010">class-body</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> [<span class="c004">(</span> <a class="syntax" href="patterns#pattern"><span class="c010">pattern</span></a> [<span class="c004">:</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a>] <span class="c004">)</span>] { <a class="syntax" href="#class-field"><span class="c010">class-field</span></a> } </td>
</tr> </table></td></tr> </table></div>
<p> The expression <span class="c004">object</span> <a class="syntax" href="#class-body"><span class="c010">class-body</span></a> <span class="c004">end</span> denotes a class body. This is the prototype for an object : it lists the instance variables and methods of an object of this class.</p>
<p>A class body is a class value: it is not evaluated at once. Rather, its components are evaluated each time an object is created.</p>
<p>In a class body, the pattern <span class="c004">(</span> <a class="syntax" href="patterns#pattern"><span class="c010">pattern</span></a> [<span class="c004">:</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a>] <span class="c004">)</span> is matched against self, therefore providing a binding for self and self type. Self can only be used in method and initializers.</p>
<p>Self type cannot be a closed object type, so that the class remains extensible.</p>
<p>Since OCaml 4.01, it is an error if the same method or instance variable name is defined several times in the same class body.</p>
<h4 class="subsubsection" id="sss:class-inheritance">
<a class="section-anchor" href="#sss:class-inheritance" aria-hidden="true">﻿</a>Inheritance</h4> 
<p>The inheritance construct <span class="c004">inherit</span> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> allows reusing methods and instance variables from other classes. The class expression <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> must evaluate to a class body. The instance variables, methods and initializers from this class body are added into the current class. The addition of a method will override any previously defined method of the same name.</p>
<p> An ancestor can be bound by appending <span class="c004">as</span> <a class="syntax" href="lex#lowercase-ident"><span class="c010">lowercase-ident</span></a> to the inheritance construct. <a class="syntax" href="lex#lowercase-ident"><span class="c010">lowercase-ident</span></a> is not a true variable and can only be used to select a method, i.e. in an expression <a class="syntax" href="lex#lowercase-ident"><span class="c010">lowercase-ident</span></a> <span class="c004">#</span> <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a>. This gives access to the method <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> as it was defined in the parent class even if it is redefined in the current class. The scope of this ancestor binding is limited to the current class. The ancestor method may be called from a subclass but only indirectly.</p>
<h4 class="subsubsection" id="sss:class-variables">
<a class="section-anchor" href="#sss:class-variables" aria-hidden="true">﻿</a>Instance variable definition</h4> 
<p>The definition <span class="c004">val</span> [<span class="c004">mutable</span>] <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> adds an instance variable <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> whose initial value is the value of expression <a class="syntax" href="expr#expr"><span class="c010">expr</span></a>. The flag <span class="c004">mutable</span> allows physical modification of this variable by methods.</p>
<p>An instance variable can only be used in the methods and initializers that follow its definition.</p>
<p>Since version 3.10, redefinitions of a visible instance variable with the same name do not create a new variable, but are merged, using the last value for initialization. They must have identical types and mutability. However, if an instance variable is hidden by omitting it from an interface, it will be kept distinct from other instance variables with the same name.</p>
<h4 class="subsubsection" id="sss:class-virtual-variable">
<a class="section-anchor" href="#sss:class-virtual-variable" aria-hidden="true">﻿</a>Virtual instance variable definition</h4> 
<p>A variable specification is written <span class="c004">val</span> [<span class="c004">mutable</span>] <span class="c004">virtual</span> <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a>. It specifies whether the variable is modifiable, and gives its type.</p>
<p>Virtual instance variables were added in version 3.10.</p>
<h4 class="subsubsection" id="sss:class-method">
<a class="section-anchor" href="#sss:class-method" aria-hidden="true">﻿</a>Method definition</h4> 
<p>A method definition is written <span class="c004">method</span> <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a>. The definition of a method overrides any previous definition of this method. The method will be public (that is, not private) if any of the definition states so.</p>
<p>A private method, <span class="c002"><span class="c003">method</span> <span class="c003">private</span></span> <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a>, is a method that can only be invoked on self (from other methods of the same object, defined in this class or one of its subclasses). This invocation is performed using the expression <a class="syntax" href="names#value-name"><span class="c010">value-name</span></a> <span class="c004">#</span> <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a>, where <a class="syntax" href="names#value-name"><span class="c010">value-name</span></a> is directly bound to self at the beginning of the class definition. Private methods do not appear in object types. A method may have both public and private definitions, but as soon as there is a public one, all subsequent definitions will be made public.</p>
<p>Methods may have an explicitly polymorphic type, allowing them to be used polymorphically in programs (even for the same object). The explicit declaration may be done in one of three ways: (1) by giving an explicit polymorphic type in the method definition, immediately after the method name, <em>i.e.</em> <span class="c004">method</span> [<span class="c004">private</span>] <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> <span class="c004">:</span> {<span class="c004">'</span> <a class="syntax" href="lex#ident"><span class="c010">ident</span></a>}<sup>+</sup> <span class="c004">.</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a> <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a>; (2) by a forward declaration of the explicit polymorphic type through a virtual method definition; (3) by importing such a declaration through inheritance and/or constraining the type of <em>self</em>.</p>
<p>Some special expressions are available in method bodies for manipulating instance variables and duplicating self: </p>
<div class="syntax"><table class="display dcenter">
<tr class="c019"><td class="dcell"><table class="c001 cellpading0">
<tr>
<td class="c018"> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> … </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> <span class="c004">&lt;-</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> </td>
</tr> <tr>
<td class="c018"> </td>
<td class="c015">∣</td>
<td class="c017"> <span class="c004">{&lt;</span> [ <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> { <span class="c004">;</span> <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> } [<span class="c004">;</span>] ] <span class="c004">&gt;}</span> </td>
</tr> </table></td></tr> </table></div>
<p>The expression <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> <span class="c004">&lt;-</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> modifies in-place the current object by replacing the value associated to <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> by the value of <a class="syntax" href="expr#expr"><span class="c010">expr</span></a>. Of course, this instance variable must have been declared mutable.</p>
<p>The expression <span class="c004">{&lt;</span> <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a><sub>1</sub> <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a><sub>1</sub> <span class="c004">;</span> … <span class="c004">;</span> <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a><sub><span class="c009">n</span></sub> <span class="c004">=</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a><sub><span class="c009">n</span></sub> <span class="c004">&gt;}</span> evaluates to a copy of the current object in which the values of instance variables <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a><sub>1</sub>, …, <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a><sub><span class="c009">n</span></sub> have been replaced by the values of the corresponding expressions <a class="syntax" href="expr#expr"><span class="c010">expr</span></a><sub>1</sub>, …, <a class="syntax" href="expr#expr"><span class="c010">expr</span></a><sub><span class="c009">n</span></sub>.</p>
<h4 class="subsubsection" id="sss:class-virtual-meth">
<a class="section-anchor" href="#sss:class-virtual-meth" aria-hidden="true">﻿</a>Virtual method definition</h4> 
<p>A method specification is written <span class="c004">method</span> [<span class="c004">private</span>] <span class="c004">virtual</span> <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> <span class="c004">:</span> <a class="syntax" href="types#poly-typexpr"><span class="c010">poly-typexpr</span></a>. It specifies whether the method is public or private, and gives its type. If the method is intended to be polymorphic, the type must be explicitly polymorphic.</p>
<h4 class="subsubsection" id="sss:class-explicit-overriding">
<a class="section-anchor" href="#sss:class-explicit-overriding" aria-hidden="true">﻿</a>Explicit overriding</h4> <p>Since Ocaml 3.12, the keywords <span class="c004">inherit!</span>, <span class="c004">val!</span> and <span class="c004">method!</span> have the same semantics as <span class="c004">inherit</span>, <span class="c004">val</span> and <span class="c004">method</span>, but they additionally require the definition they introduce to be overriding. Namely, <span class="c004">method!</span> requires <a class="syntax" href="names#method-name"><span class="c010">method-name</span></a> to be already defined in this class, <span class="c004">val!</span> requires <a class="syntax" href="names#inst-var-name"><span class="c010">inst-var-name</span></a> to be already defined in this class, and <span class="c004">inherit!</span> requires <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> to override some definitions. If no such overriding occurs, an error is signaled.</p>
<p>As a side-effect, these 3 keywords avoid the warnings 7 (method override) and 13 (instance variable override). Note that warning 7 is disabled by default.</p>
<h4 class="subsubsection" id="sss:class-type-constraints">
<a class="section-anchor" href="#sss:class-type-constraints" aria-hidden="true">﻿</a>Constraints on type parameters</h4> <p> The construct <span class="c004">constraint</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a><sub>1</sub> <span class="c004">=</span> <a class="syntax" href="types#typexpr"><span class="c010">typexpr</span></a><sub>2</sub> forces the two type expressions to be equals. This is typically used to specify type parameters: in that way they can be bound to specific type expressions.</p>
<h4 class="subsubsection" id="sss:class-initializers">
<a class="section-anchor" href="#sss:class-initializers" aria-hidden="true">﻿</a>Initializers</h4> 
<p>A class initializer <span class="c004">initializer</span> <a class="syntax" href="expr#expr"><span class="c010">expr</span></a> specifies an expression that will be evaluated whenever an object is created from the class, once all its instance variables have been initialized.</p> <h3 class="subsection" id="ss:class-def">
<a class="section-anchor" href="#ss:class-def" aria-hidden="true">﻿</a>7.9.3 Class definitions</h3> 

<div class="syntax"><table class="display dcenter">
<tr class="c019"><td class="dcell"><table class="c001 cellpading0">
<tr>
<td class="c018"> <a class="syntax" id="class-definition"><span class="c010">class-definition</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> <span class="c004">class</span> <a class="syntax" href="#class-binding"><span class="c010">class-binding</span></a> { <span class="c004">and</span> <a class="syntax" href="#class-binding"><span class="c010">class-binding</span></a> } </td>
</tr> <tr><td class="c018"> </td></tr> <tr>
<td class="c018"> <a class="syntax" id="class-binding"><span class="c010">class-binding</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> [<span class="c004">virtual</span>] [<span class="c004">[</span> <a class="syntax" href="#type-parameters"><span class="c010">type-parameters</span></a> <span class="c004">]</span>] <a class="syntax" href="names#class-name"><span class="c010">class-name</span></a> {<a class="syntax" href="expr#parameter"><span class="c010">parameter</span></a>} [<span class="c004">:</span> <a class="syntax" href="#class-type"><span class="c010">class-type</span></a>] <span class="c004">=</span> <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a> </td>
</tr> <tr><td class="c018"> </td></tr> <tr>
<td class="c018"> <a class="syntax" id="type-parameters"><span class="c010">type-parameters</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> <span class="c004">'</span> <a class="syntax" href="lex#ident"><span class="c010">ident</span></a> { <span class="c004">,</span> <span class="c004">'</span> <a class="syntax" href="lex#ident"><span class="c010">ident</span></a> } </td>
</tr> </table></td></tr> </table></div>
<p>A class definition <span class="c004">class</span> <a class="syntax" href="#class-binding"><span class="c010">class-binding</span></a> { <span class="c004">and</span> <a class="syntax" href="#class-binding"><span class="c010">class-binding</span></a> } is recursive. Each <a class="syntax" href="#class-binding"><span class="c010">class-binding</span></a> defines a <a class="syntax" href="names#class-name"><span class="c010">class-name</span></a> that can be used in the whole expression except for inheritance. It can also be used for inheritance, but only in the definitions that follow its own.</p>
<p>A class binding binds the class name <a class="syntax" href="names#class-name"><span class="c010">class-name</span></a> to the value of expression <a class="syntax" href="#class-expr"><span class="c010">class-expr</span></a>. It also binds the class type <a class="syntax" href="names#class-name"><span class="c010">class-name</span></a> to the type of the class, and defines two type abbreviations : <a class="syntax" href="names#class-name"><span class="c010">class-name</span></a> and <span class="c004">#</span> <a class="syntax" href="names#class-name"><span class="c010">class-name</span></a>. The first one is the type of objects of this class, while the second is more general as it unifies with the type of any object belonging to a subclass (see section <a href="types#sss%3Atypexpr-sharp-types">7.4</a>).</p>
<h4 class="subsubsection" id="sss:class-virtual">
<a class="section-anchor" href="#sss:class-virtual" aria-hidden="true">﻿</a>Virtual class</h4> <p>A class must be flagged virtual if one of its methods is virtual (that is, appears in the class type, but is not actually defined). Objects cannot be created from a virtual class.</p>
<h4 class="subsubsection" id="sss:class-type-params">
<a class="section-anchor" href="#sss:class-type-params" aria-hidden="true">﻿</a>Type parameters</h4> <p>The class type parameters correspond to the ones of the class type and of the two type abbreviations defined by the class binding. They must be bound to actual types in the class definition using type constraints. So that the abbreviations are well-formed, type variables of the inferred type of the class must either be type parameters or be bound in the constraint clause.</p> <h3 class="subsection" id="ss:class-spec">
<a class="section-anchor" href="#ss:class-spec" aria-hidden="true">﻿</a>7.9.4 Class specifications</h3> 
<div class="syntax"><table class="display dcenter">
<tr class="c019"><td class="dcell"><table class="c001 cellpading0">
<tr>
<td class="c018"> <a class="syntax" id="class-specification"><span class="c010">class-specification</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> <span class="c004">class</span> <a class="syntax" href="#class-spec"><span class="c010">class-spec</span></a> { <span class="c004">and</span> <a class="syntax" href="#class-spec"><span class="c010">class-spec</span></a> } </td>
</tr> <tr><td class="c018"> </td></tr> <tr>
<td class="c018"> <a class="syntax" id="class-spec"><span class="c010">class-spec</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> [<span class="c004">virtual</span>] [<span class="c004">[</span> <a class="syntax" href="#type-parameters"><span class="c010">type-parameters</span></a> <span class="c004">]</span>] <a class="syntax" href="names#class-name"><span class="c010">class-name</span></a> <span class="c004">:</span> <a class="syntax" href="#class-type"><span class="c010">class-type</span></a> </td>
</tr> </table></td></tr> </table></div>
<p>This is the counterpart in signatures of class definitions. A class specification matches a class definition if they have the same type parameters and their types match.</p> <h3 class="subsection" id="ss:classtype">
<a class="section-anchor" href="#ss:classtype" aria-hidden="true">﻿</a>7.9.5 Class type definitions</h3> 
<div class="syntax"><table class="display dcenter">
<tr class="c019"><td class="dcell"><table class="c001 cellpading0">
<tr>
<td class="c018"> <a class="syntax" id="classtype-definition"><span class="c010">classtype-definition</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> <span class="c004">class</span> <span class="c004">type</span> <a class="syntax" href="#classtype-def"><span class="c010">classtype-def</span></a> { <span class="c004">and</span> <a class="syntax" href="#classtype-def"><span class="c010">classtype-def</span></a> } </td>
</tr> <tr><td class="c018"> </td></tr> <tr>
<td class="c018"> <a class="syntax" id="classtype-def"><span class="c010">classtype-def</span></a>
</td>
<td class="c015">::=</td>
<td class="c017"> [<span class="c004">virtual</span>] [<span class="c004">[</span> <a class="syntax" href="#type-parameters"><span class="c010">type-parameters</span></a> <span class="c004">]</span>] <a class="syntax" href="names#class-name"><span class="c010">class-name</span></a> <span class="c004">=</span> <a class="syntax" href="#class-body-type"><span class="c010">class-body-type</span></a> </td>
</tr> </table></td></tr> </table></div>
<p>A class type definition <span class="c004">class</span> <a class="syntax" href="names#class-name"><span class="c010">class-name</span></a> <span class="c004">=</span> <a class="syntax" href="#class-body-type"><span class="c010">class-body-type</span></a> defines an abbreviation <a class="syntax" href="names#class-name"><span class="c010">class-name</span></a> for the class body type <a class="syntax" href="#class-body-type"><span class="c010">class-body-type</span></a>. As for class definitions, two type abbreviations <a class="syntax" href="names#class-name"><span class="c010">class-name</span></a> and <span class="c004">#</span> <a class="syntax" href="names#class-name"><span class="c010">class-name</span></a> are also defined. The definition can be parameterized by some type parameters. If any method in the class type body is virtual, the definition must be flagged <span class="c004">virtual</span>.</p>
<p>Two class type definitions match if they have the same type parameters and they expand to matching types. </p> <hr> <a href="typedecl"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjQgMjQiIGhlaWdodD0iMjQiIHdpZHRoPSIyNCIgPgogIDxwYXRoIGQ9Ik00IDEybDggOGwxLjQxNCAtMS40MTRMNy44MjggMTNIMjB2LTJINy44MjhMMTMuNDE0IDUuNDE0TDEyIDR6Ii8+Cjwvc3ZnPgo=" alt="Previous"></a> <a href="language"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDI0IDI0IiBoZWlnaHQ9IjI0IiB3aWR0aD0iMjQiPgogIDxwYXRoIGQ9Ik0xMiA0bDggOGwtMS40MTQgMS40MTRMMTMgNy44MjhWMjBoLTJWNy44MjhMNS40MTQgMTMuNDE0TDQgMTJ6Ii8+Cjwvc3ZnPgo=" alt="Up"></a> <a href="modtypes"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjQgMjQiIGhlaWdodD0iMjQiIHdpZHRoPSIyNCIgPgogIDxwYXRoIGQ9Ik0yMCAxMmwtOCA4bC0xLjQxNCAtMS40MTRMMTYuMTcyIDEzSDR2LTJIMTYuMTcyTDEwLjU4NiA1LjQxNEwxMiA0IHoiLz4KPC9zdmc+Cg==" alt="Next"></a><div class="_attribution">
  <p class="_attribution-p">
    © INRIA 1995-2020.<br>
    <a href="https://www.ocaml.org/releases/4.11/htmlman/classes.html" class="_attribution-link">https://www.ocaml.org/releases/4.11/htmlman/classes.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
