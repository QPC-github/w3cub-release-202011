
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>24. Runtime Tracing With the Instrumented Runtime - OCaml - W3cubDocs</title>
  
  <meta name="description" content=" This chapter describes the OCaml instrumented runtime, a runtime variant allowing the collection of events and metrics. ">
  <meta name="keywords" content="chapter, runtime, tracing, with, instrumented, ocaml">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ocaml/instrumented-runtime.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c2f2e7d1236e299f399a2d9bf4342fa70a8839fbe6eb79130546d6bf383b99636ffdf29c557090085d7c4ac34eeb5426851b42d2f4ec63cf218916cbd19aa876.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/ocaml.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ocaml/" class="_nav-link" title="" style="margin-left:0;">OCaml</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _ocaml">
				
				
<a href="afl-fuzz"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjQgMjQiIGhlaWdodD0iMjQiIHdpZHRoPSIyNCIgPgogIDxwYXRoIGQ9Ik00IDEybDggOGwxLjQxNCAtMS40MTRMNy44MjggMTNIMjB2LTJINy44MjhMMTMuNDE0IDUuNDE0TDEyIDR6Ii8+Cjwvc3ZnPgo=" alt="Previous"></a> <a href="index"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDI0IDI0IiBoZWlnaHQ9IjI0IiB3aWR0aD0iMjQiPgogIDxwYXRoIGQ9Ik0xMiA0bDggOGwtMS40MTQgMS40MTRMMTMgNy44MjhWMjBoLTJWNy44MjhMNS40MTQgMTMuNDE0TDQgMTJ6Ii8+Cjwvc3ZnPgo=" alt="Up"></a> <a href="core"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjQgMjQiIGhlaWdodD0iMjQiIHdpZHRoPSIyNCIgPgogIDxwYXRoIGQ9Ik0yMCAxMmwtOCA4bC0xLjQxNCAtMS40MTRMMTYuMTcyIDEzSDR2LTJIMTYuMTcyTDEwLjU4NiA1LjQxNEwxMiA0IHoiLz4KPC9zdmc+Cg==" alt="Next"></a> <hr> <h1 class="chapter" id="sec560">Chapter 24 Runtime tracing with the instrumented runtime</h1> <ul> <li>
<a href="instrumented-runtime#s%3Ainstr-runtime-overview">24.1 Overview</a> </li>
<li>
<a href="instrumented-runtime#s%3Ainstr-runtime-enabling">24.2 Enabling runtime instrumentation</a> </li>
<li>
<a href="instrumented-runtime#s%3Ainstr-runtime-read">24.3 Reading traces</a> </li>
<li>
<a href="instrumented-runtime#s%3Ainstr-runtime-more">24.4 Controlling instrumentation and limitations</a> </li>
</ul> <p>This chapter describes the OCaml instrumented runtime, a runtime variant allowing the collection of events and metrics.</p>
<p>Collected metrics include time spent executing the <em>garbage collector</em>. The overall execution time of individual pauses are measured down to the time spent in specific parts of the garbage collection. Insight is also given on memory allocation and motion by recording the size of allocated memory blocks, as well as value promotions from the <em>minor heap</em> to the <em>major heap</em>.</p> <h2 class="section" id="s:instr-runtime-overview">
<a class="section-anchor" href="#s:instr-runtime-overview" aria-hidden="true">﻿</a>24.1 Overview</h2> <p>Once compiled and linked with the instrumented runtime, any OCaml program can generate <em>trace files</em> that can then be read and analyzed by users in order to understand specific runtime behaviors.</p>
<p>The generated trace files are stored using the <em>Common Trace Format</em>, which is a general purpose binary tracing format. A complete trace consists of: </p>
<ul class="itemize">
<li class="li-itemize"> a <em>metadata file</em>, part of the OCaml distribution </li>
<li class="li-itemize">and a <em>trace file</em>, generated by the runtime in the program being traced. </li>
</ul>
<p>For more information on the <em>Common Trace Format</em>, see <a href="https://diamon.org/ctf/">https://diamon.org/ctf/</a>.</p> <h2 class="section" id="s:instr-runtime-enabling">
<a class="section-anchor" href="#s:instr-runtime-enabling" aria-hidden="true">﻿</a>24.2 Enabling runtime instrumentation</h2> <p>For the following examples, we will use the following example program:</p>
<pre class="caml-example verbatim" data-language="ocaml">   module SMap = Map.Make(String) let s i = String.make 512 (Char.chr (i mod 256)) let clear map = SMap.fold (fun k _ m -&gt; SMap.remove k m) map map let rec seq i = if i = 0 then Seq.empty else fun () -&gt; (Seq.Cons (i, seq (i - 1))) let () = seq 1_000_000 |&gt; Seq.fold_left (fun m i -&gt; SMap.add (s i) i m) SMap.empty |&gt; clear |&gt; ignore </pre>
<p>The next step is to compile and link the program with the instrumented runtime. This can be done by using the <span class="c003">-runtime-variant</span> flag:</p>
<pre data-language="ocaml">       ocamlopt -runtime-variant i program.ml -o program
</pre>
<p> Note that the instrumented runtime is an alternative runtime for OCaml programs. It is only referenced during the linking stage of the final executable. This means that the compilation stage does not need to be altered to enable instrumentation.</p>
<p>The resulting program can then be traced by running it with the environment variable <span class="c003">OCAML_EVENTLOG_ENABLED</span>:</p>
<pre data-language="ocaml">        OCAML_EVENTLOG_ENABLED=1 ./program
</pre>
<p> During execution, a trace file will be generated in the program’s current working directory.</p>
<h4 class="subsubsection" id="sss:instr-runtime-build-more">
<a class="section-anchor" href="#sss:instr-runtime-build-more" aria-hidden="true">﻿</a>More build examples</h4> <p>When using the <em>dune</em> build system, this compiler invocation can be replicated using the <span class="c003">flags</span> <span class="c003">stanza</span> when building an executable.</p>
<pre data-language="ocaml">       (executable
         (name program)
         (flags "-runtime-variant=i"))
</pre>
<p> The instrumented runtime can also be used with the OCaml bytecode interpreter. This can be done by either using the <span class="c003">-runtime-variant=i</span> flag when linking the program with <span class="c003">ocamlc</span>, or by running the generated bytecode through <span class="c003">ocamlruni</span>:</p>
<pre data-language="ocaml">       ocamlc program.ml -o program.byte
       OCAML_EVENTLOG_ENABLED=1 ocamlruni program.byte
</pre>
<p> See chapter <a href="comp#c%3Acamlc">9</a> and chapter <a href="runtime#c%3Aruntime">11</a> for more information about <span class="c003">ocamlc</span> and <span class="c003">ocamlrun</span>.</p> <h2 class="section" id="s:instr-runtime-read">
<a class="section-anchor" href="#s:instr-runtime-read" aria-hidden="true">﻿</a>24.3 Reading traces</h2> <p>Traces generated by the instrumented runtime can be analyzed with tooling available outside of the OCaml distribution.</p>
<p>A complete trace consists of a <em>metadata file</em> and a <em>trace file</em>. Two simple ways to work with the traces are the <em>eventlog-tools</em> and <em>babeltrace</em> libraries.</p> <h3 class="subsection" id="ss:instr-runtime-tools">
<a class="section-anchor" href="#ss:instr-runtime-tools" aria-hidden="true">﻿</a>24.3.1 eventlog-tools</h3> <p> <em>eventlog-tools</em> is a library implementing a parser, as well as a a set of tools that allows to perform basic format conversions and analysis.</p>
<p>For more information about <em>eventlog-tools</em>, refer to the project’s main page: <a href="https://github.com/ocaml-multicore/eventlog-tools">https://github.com/ocaml-multicore/eventlog-tools</a></p> <h3 class="subsection" id="ss:instr-runtime-babeltrace">
<a class="section-anchor" href="#ss:instr-runtime-babeltrace" aria-hidden="true">﻿</a>24.3.2 babeltrace</h3> <p><em>babeltrace</em> is a C library, as well as a Python binding and set of tools that serve as the reference implementation for the <em>Common Trace Format</em>. The <em>babeltrace</em> command line utility allows for a basic rendering of a trace’s content, while the high level Python API can be used to decode the trace and process them programmatically with libraries such as <em>numpy</em> or <em>Jupyter</em>.</p>
<p>Unlike <em>eventlog-tools</em>, which possesses a specific knowledge of OCaml’s <em>Common Trace Format</em> schema, it is required to provide the OCaml <em>metadata</em> file to <em>babeltrace</em>.</p>
<p>The metadata file is available in the OCaml installation. Its location can be obtained using the following command:</p>
<pre data-language="ocaml">        ocamlc -where
</pre>
<p> The <em>eventlog_metadata</em> file can be found at this path and copied in the same directory as the generated trace file. However, <em>babeltrace</em> expects the file to be named <span class="c003">metadata</span> in order to process the trace. Thus, it will need to be renamed when copied to the trace’s directory.</p>
<p>Here is a naive decoder example, using <em>babeltrace</em>’s Python library, and <em>Python 3.8</em>:</p>
<pre data-language="ocaml">
import subprocess
import shutil
import sys
import babeltrace as bt

def print_event(ev):
    print(ev['timestamp'])
    print(ev['pid'])
    if ev.name == "entry":
        print('entry_event')
        print(ev['phase'])
    if ev.name == "exit":
        print('exit_event')
        print(ev['phase'])
    if ev.name == "alloc":
        print(ev['count'])
        print(ev['bucket'])
    if ev.name == "counter":
        print(ev['count'])
        print(ev['kind'])
    if ev.name == "flush":
        print("flush")

def get_ocaml_dir():
    # Fetching OCaml's installation directory to extract the CTF metadata
    ocamlc_where = subprocess.run(['ocamlc', '-where'], stdout=subprocess.PIPE)
    ocaml_dir = ocamlc_where.stdout.decode('utf-8').rstrip('\n')
    return(ocaml_dir)

def main():
    trace_dir = sys.argv[1]
    ocaml_dir = get_ocaml_dir()
    metadata_path = ocaml_dir + "/eventlog_metadata"
    # copying the metadata to the trace's directory,
    # and renaming it to 'metadata'.
    shutil.copyfile(metadata_path, trace_dir + "/metadata")
    tr = bt.TraceCollection()
    tr.add_trace(trace_dir, 'ctf')
    for event in tr.events:
        print_event(event)

if __name__ == '__main__':
    main()

</pre>
<p> This script expect to receive as an argument the directory containing the trace file. It will then copy the <em>CTF</em> metadata file to the trace’s directory, and then decode the trace, printing each event in the process.</p>
<p>For more information on <em>babeltrace</em>, see the website at: <a href="https://babeltrace.org/">https://babeltrace.org/</a></p> <h2 class="section" id="s:instr-runtime-more">
<a class="section-anchor" href="#s:instr-runtime-more" aria-hidden="true">﻿</a>24.4 Controlling instrumentation and limitations</h2> <h3 class="subsection" id="ss:instr-runtime-prefix">
<a class="section-anchor" href="#ss:instr-runtime-prefix" aria-hidden="true">﻿</a>24.4.1 Trace filename</h3> <p>The default trace filename is <span class="c003">caml-{PID}.eventlog</span>, where <span class="c003">{PID}</span> is the process identifier of the traced program.</p>
<p>This filename can also be specified using the <span class="c003">OCAML_EVENTLOG_PREFIX</span> environment variable. The given path will be suffixed with <span class="c003">{.PID}.eventlog</span>.</p>
<pre data-language="ocaml">        OCAML_EVENTLOG_PREFIX=/tmp/a_prefix OCAML_EVENTLOG_ENABLED=1 ./program
</pre>
<p> In this example, the trace will be available at path <span class="c003">/tmp/a_prefix.{PID}.eventlog</span>.</p>
<p>Note that this will only affect the prefix of the trace file, there is no option to specify the full effective file name. This restriction is in place to make room for future improvements to the instrumented runtime, where the single trace file per session design may be replaced.</p>
<p>For scripting purpose, matching against ‘{PID}‘, as well as the <span class="c003">.eventlog</span> file extension should provide enough control over the generated files.</p>
<p>Note as well that parent directories in the given path will not be created when opening the trace. The runtime assumes the path is accessible for creating and writing the trace. The program will fail to start if this requirement isn’t met.</p> <h3 class="subsection" id="ss:instr-runtime-pause">
<a class="section-anchor" href="#ss:instr-runtime-pause" aria-hidden="true">﻿</a>24.4.2 Pausing and resuming tracing</h3> <p> Mechanisms are available to control event collection at runtime.</p>
<p><span class="c003">OCAML_EVENTLOG_ENABLED</span> can be set to the <span class="c003">p</span> flag in order to start the program with event collection paused.</p>
<pre data-language="ocaml">        OCAML_EVENTLOG_ENABLED=p ./program
</pre>
<p> The program will have to start event collection explicitly. Starting and stopping event collection programmatically can be done by calling <span class="c003">Gc.eventlog_resume</span> and <span class="c003">Gc.eventlog_pause</span>) from within the program. Refer to the <a href="libref/gc"><span class="c003">Gc</span></a> module documentation for more information.</p>
<p>Running the program provided earlier with <span class="c003">OCAML_EVENTLOG_ENABLED=p</span> will for example yield the following result.</p>
<pre data-language="ocaml">$ OCAML_EVENTLOG_ENABLED=p ./program
$ ocaml-eventlog-report caml-{PID}.eventlog
==== eventlog/flush
median flush time: 58ns
total flush time: 58ns
flush count: 1
</pre>
<p> The resulting trace contains only one event payload, namely a <em>flush</em> event, indicating how much time was spent flushing the trace file to disk.</p>
<p>However, if the program is changed to include a call to <span class="c003">Gc.eventlog_resume</span>, events payloads can be seen again in the trace file.</p>
<pre class="caml-example verbatim" data-language="ocaml">   let () = Gc.eventlog_resume(); seq 1_000_000 |&gt; Seq.fold_left (fun m i -&gt; SMap.add (s i) i m) SMap.empty |&gt; clear |&gt; ignore </pre>
<p>The resulting trace will contain all events encountered during the program’s execution:</p>
<pre data-language="ocaml">        $ ocaml-eventlog-report caml-{PID}.eventlog
        [..omitted..]
        ==== force_minor/alloc_small
        100.0K..200.0K: 174
        20.0K..30.0K: 1
        0..100: 1

        ==== eventlog/flush
        median flush time: 207.8us
        total flush time: 938.1us
        flush count: 5
</pre> <h3 class="subsection" id="ss:instr-runtime-limitations">
<a class="section-anchor" href="#ss:instr-runtime-limitations" aria-hidden="true">﻿</a>24.4.3 Limitations</h3> <p>The instrumented runtime does not support the <span class="c003">fork</span> system call. A child process forked from an instrumented program will not be traced.</p>
<p>The instrumented runtime aims to provide insight into the runtime’s execution while maintaining a low overhead. However, this overhead may become more noticeable depending on how a program executes. The instrumented runtime currently puts a strong emphasis on tracing <em>garbage collection</em> events. This means that programs with heavy garbage collection activity may be more susceptible to tracing induced performance penalties.</p>
<p>While providing an accurate estimate of potential performance loss is difficult, test on various OCaml programs showed a total running time increase ranging from 1% to 8%.</p>
<p>For a program with an extended running time where the collection of only a small sample of events is required, using the <em>eventlog_resume</em> and <em>eventlog_pause</em> primitives may help relieve some of the tracing induced performance impact. </p> <hr> <a href="afl-fuzz"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjQgMjQiIGhlaWdodD0iMjQiIHdpZHRoPSIyNCIgPgogIDxwYXRoIGQ9Ik00IDEybDggOGwxLjQxNCAtMS40MTRMNy44MjggMTNIMjB2LTJINy44MjhMMTMuNDE0IDUuNDE0TDEyIDR6Ii8+Cjwvc3ZnPgo=" alt="Previous"></a> <a href="index"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDI0IDI0IiBoZWlnaHQ9IjI0IiB3aWR0aD0iMjQiPgogIDxwYXRoIGQ9Ik0xMiA0bDggOGwtMS40MTQgMS40MTRMMTMgNy44MjhWMjBoLTJWNy44MjhMNS40MTQgMTMuNDE0TDQgMTJ6Ii8+Cjwvc3ZnPgo=" alt="Up"></a> <a href="core"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjQgMjQiIGhlaWdodD0iMjQiIHdpZHRoPSIyNCIgPgogIDxwYXRoIGQ9Ik0yMCAxMmwtOCA4bC0xLjQxNCAtMS40MTRMMTYuMTcyIDEzSDR2LTJIMTYuMTcyTDEwLjU4NiA1LjQxNEwxMiA0IHoiLz4KPC9zdmc+Cg==" alt="Next"></a><div class="_attribution">
  <p class="_attribution-p">
    © INRIA 1995-2020.<br>
    <a href="https://www.ocaml.org/releases/4.11/htmlman/instrumented-runtime.html" class="_attribution-link">https://www.ocaml.org/releases/4.11/htmlman/instrumented-runtime.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
