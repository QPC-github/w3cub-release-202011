
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>02. The Module System - OCaml - W3cubDocs</title>
  
  <meta name="description" content=" This chapter introduces the module system of OCaml. ">
  <meta name="keywords" content="chapter, module, system, ocaml">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ocaml/moduleexamples.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/ocaml.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ocaml/" class="_nav-link" title="" style="margin-left:0;">OCaml</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _ocaml">
				
				
<a href="coreexamples"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjQgMjQiIGhlaWdodD0iMjQiIHdpZHRoPSIyNCIgPgogIDxwYXRoIGQ9Ik00IDEybDggOGwxLjQxNCAtMS40MTRMNy44MjggMTNIMjB2LTJINy44MjhMMTMuNDE0IDUuNDE0TDEyIDR6Ii8+Cjwvc3ZnPgo=" alt="Previous"></a> <a href="index"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDI0IDI0IiBoZWlnaHQ9IjI0IiB3aWR0aD0iMjQiPgogIDxwYXRoIGQ9Ik0xMiA0bDggOGwtMS40MTQgMS40MTRMMTMgNy44MjhWMjBoLTJWNy44MjhMNS40MTQgMTMuNDE0TDQgMTJ6Ii8+Cjwvc3ZnPgo=" alt="Up"></a> <a href="objectexamples"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjQgMjQiIGhlaWdodD0iMjQiIHdpZHRoPSIyNCIgPgogIDxwYXRoIGQ9Ik0yMCAxMmwtOCA4bC0xLjQxNCAtMS40MTRMMTYuMTcyIDEzSDR2LTJIMTYuMTcyTDEwLjU4NiA1LjQxNEwxMiA0IHoiLz4KPC9zdmc+Cg==" alt="Next"></a> <hr> <h1 class="chapter" id="sec20">Chapter 2 The module system</h1> <ul> <li>
<a href="moduleexamples#s%3Amodule%3Astructures">2.1 Structures</a> </li>
<li>
<a href="moduleexamples#s%3Asignature">2.2 Signatures</a> </li>
<li>
<a href="moduleexamples#s%3Afunctors">2.3 Functors</a> </li>
<li>
<a href="moduleexamples#s%3Afunctors-and-abstraction">2.4 Functors and type abstraction</a> </li>
<li>
<a href="moduleexamples#s%3Aseparate-compilation">2.5 Modules and separate compilation</a> </li>
</ul> 
<p>This chapter introduces the module system of OCaml.</p> <h2 class="section" id="s:module:structures">
<a class="section-anchor" href="#s:module:structures" aria-hidden="true">﻿</a>2.1 Structures</h2> <p>A primary motivation for modules is to package together related definitions (such as the definitions of a data type and associated operations over that type) and enforce a consistent naming scheme for these definitions. This avoids running out of names or accidentally confusing names. Such a package is called a <em>structure</em> and is introduced by the <span class="c003">struct</span>…<span class="c003">end</span> construct, which contains an arbitrary sequence of definitions. The structure is usually given a name with the <span class="c003">module</span> binding. Here is for instance a structure packaging together a type of priority queues and their operations: </p>
<pre class="caml-example toplevel" data-language="ocaml">   module PrioQueue = struct type priority = int type 'a queue = Empty | Node of priority * 'a * 'a queue * 'a queue let empty = Empty let rec insert queue prio elt = match queue with Empty -&gt; Node(prio, elt, Empty, Empty) | Node(p, e, left, right) -&gt; if prio &lt;= p then Node(prio, elt, insert right p e, left) else Node(p, e, insert right prio elt, left) exception Queue_is_empty let rec remove_top = function Empty -&gt; raise Queue_is_empty | Node(prio, elt, left, Empty) -&gt; left | Node(prio, elt, Empty, right) -&gt; right | Node(prio, elt, (Node(lprio, lelt, _, _) as left), (Node(rprio, relt, _, _) as right)) -&gt; if lprio &lt;= rprio then Node(lprio, lelt, remove_top left, right) else Node(rprio, relt, left, remove_top right) let extract = function Empty -&gt; raise Queue_is_empty | Node(prio, elt, _, _) as queue -&gt; (prio, elt, remove_top queue) end;; module PrioQueue : sig type priority = int type 'a queue = Empty | Node of priority * 'a * 'a queue * 'a queue val empty : 'a queue val insert : 'a queue -&gt; priority -&gt; 'a -&gt; 'a queue exception Queue_is_empty val remove_top : 'a queue -&gt; 'a queue val extract : 'a queue -&gt; priority * 'a * 'a queue end </pre>
<p> Outside the structure, its components can be referred to using the “dot notation”, that is, identifiers qualified by a structure name. For instance, <span class="c003">PrioQueue.insert</span> is the function <span class="c003">insert</span> defined inside the structure <span class="c003">PrioQueue</span> and <span class="c003">PrioQueue.queue</span> is the type <span class="c003">queue</span> defined in <span class="c003">PrioQueue</span>. </p>
<pre class="caml-example toplevel" data-language="ocaml">   PrioQueue.insert PrioQueue.empty 1 "hello";; - : string PrioQueue.queue = PrioQueue.Node (1, "hello", PrioQueue.Empty, PrioQueue.Empty) </pre>
<p>Another possibility is to open the module, which brings all identifiers defined inside the module in the scope of the current structure.</p>
<pre class="caml-example toplevel" data-language="ocaml">   open PrioQueue;;   insert empty 1 "hello";; - : string PrioQueue.queue = Node (1, "hello", Empty, Empty) </pre>
<p>Opening a module enables lighter access to its components, at the cost of making it harder to identify in which module a identifier has been defined. In particular, opened modules can shadow identifiers present in the current scope, potentially leading to confusing errors:</p>
<pre class="caml-example toplevel" data-language="ocaml">   let empty = [] open PrioQueue;; val empty : 'a list = []   let x = 1 :: empty ;; Error: This expression has type 'a PrioQueue.queue but an expression was expected of type int list </pre>
<p>A partial solution to this conundrum is to open modules locally, making the components of the module available only in the concerned expression. This can also make the code easier to read – the open statement is closer to where it is used– and to refactor – the code fragment is more self-contained. Two constructions are available for this purpose: </p>
<pre class="caml-example toplevel" data-language="ocaml">   let open PrioQueue in insert empty 1 "hello";; - : string PrioQueue.queue = Node (1, "hello", Empty, Empty) </pre>
<p> and </p>
<pre class="caml-example toplevel" data-language="ocaml">   PrioQueue.(insert empty 1 "hello");; - : string PrioQueue.queue = Node (1, "hello", Empty, Empty) </pre>
<p> In the second form, when the body of a local open is itself delimited by parentheses, braces or bracket, the parentheses of the local open can be omitted. For instance, </p>
<pre class="caml-example toplevel" data-language="ocaml">   PrioQueue.[empty] = PrioQueue.([empty]);; - : bool = true   PrioQueue.[|empty|] = PrioQueue.([|empty|]);; - : bool = true   PrioQueue.{ contents = empty } = PrioQueue.({ contents = empty });; - : bool = true </pre>
<p> becomes </p>
<pre class="caml-example toplevel" data-language="ocaml">   PrioQueue.[insert empty 1 "hello"];; - : string PrioQueue.queue list = [Node (1, "hello", Empty, Empty)] </pre>
<p> This second form also works for patterns: </p>
<pre class="caml-example toplevel" data-language="ocaml">   let at_most_one_element x = match x with | PrioQueue.( Empty| Node (_,_, Empty,Empty) ) -&gt; true | _ -&gt; false ;; val at_most_one_element : 'a PrioQueue.queue -&gt; bool = &lt;fun&gt; </pre>
<p>It is also possible to copy the components of a module inside another module by using an <span class="c003">include</span> statement. This can be particularly useful to extend existing modules. As an illustration, we could add functions that returns an optional value rather than an exception when the priority queue is empty. </p>
<pre class="caml-example toplevel" data-language="ocaml">   module PrioQueueOpt = struct include PrioQueue let remove_top_opt x = try Some(remove_top x) with Queue_is_empty -&gt; None let extract_opt x = try Some(extract x) with Queue_is_empty -&gt; None end;; module PrioQueueOpt : sig type priority = int type 'a queue = 'a PrioQueue.queue = Empty | Node of priority * 'a * 'a queue * 'a queue val empty : 'a queue val insert : 'a queue -&gt; priority -&gt; 'a -&gt; 'a queue exception Queue_is_empty val remove_top : 'a queue -&gt; 'a queue val extract : 'a queue -&gt; priority * 'a * 'a queue val remove_top_opt : 'a queue -&gt; 'a queue option val extract_opt : 'a queue -&gt; (priority * 'a * 'a queue) option end </pre> <h2 class="section" id="s:signature">
<a class="section-anchor" href="#s:signature" aria-hidden="true">﻿</a>2.2 Signatures</h2> <p>Signatures are interfaces for structures. A signature specifies which components of a structure are accessible from the outside, and with which type. It can be used to hide some components of a structure (e.g. local function definitions) or export some components with a restricted type. For instance, the signature below specifies the three priority queue operations <span class="c003">empty</span>, <span class="c003">insert</span> and <span class="c003">extract</span>, but not the auxiliary function <span class="c003">remove_top</span>. Similarly, it makes the <span class="c003">queue</span> type abstract (by not providing its actual representation as a concrete type). </p>
<pre class="caml-example toplevel" data-language="ocaml">   module type PRIOQUEUE = sig type priority = int (* still concrete *) type 'a queue (* now abstract *) val empty : 'a queue val insert : 'a queue -&gt; int -&gt; 'a -&gt; 'a queue val extract : 'a queue -&gt; int * 'a * 'a queue exception Queue_is_empty end;; module type PRIOQUEUE = sig type priority = int type 'a queue val empty : 'a queue val insert : 'a queue -&gt; int -&gt; 'a -&gt; 'a queue val extract : 'a queue -&gt; int * 'a * 'a queue exception Queue_is_empty end </pre>
<p> Restricting the <span class="c003">PrioQueue</span> structure by this signature results in another view of the <span class="c003">PrioQueue</span> structure where the <span class="c003">remove_top</span> function is not accessible and the actual representation of priority queues is hidden: </p>
<pre class="caml-example toplevel" data-language="ocaml">   module AbstractPrioQueue = (PrioQueue : PRIOQUEUE);; module AbstractPrioQueue : PRIOQUEUE   AbstractPrioQueue.remove_top ;; Error: Unbound value AbstractPrioQueue.remove_top   AbstractPrioQueue.insert AbstractPrioQueue.empty 1 "hello";; - : string AbstractPrioQueue.queue = &lt;abstr&gt; </pre>
<p> The restriction can also be performed during the definition of the structure, as in </p>
<pre data-language="ocaml">module PrioQueue = (struct ... end : PRIOQUEUE);;
</pre>
<p>An alternate syntax is provided for the above: </p>
<pre data-language="ocaml">module PrioQueue : PRIOQUEUE = struct ... end;;
</pre>
<p> Like for modules, it is possible to include a signature to copy its components inside the current signature. For instance, we can extend the PRIOQUEUE signature with the <span class="c003">extract_opt</span> function:</p>
<pre class="caml-example toplevel" data-language="ocaml">   module type PRIOQUEUE_WITH_OPT = sig include PRIOQUEUE val extract_opt : 'a queue -&gt; (int * 'a * 'a queue) option end;; module type PRIOQUEUE_WITH_OPT = sig type priority = int type 'a queue val empty : 'a queue val insert : 'a queue -&gt; int -&gt; 'a -&gt; 'a queue val extract : 'a queue -&gt; int * 'a * 'a queue exception Queue_is_empty val extract_opt : 'a queue -&gt; (int * 'a * 'a queue) option end </pre> <h2 class="section" id="s:functors">
<a class="section-anchor" href="#s:functors" aria-hidden="true">﻿</a>2.3 Functors</h2> <p>Functors are “functions” from modules to modules. Functors let you create parameterized modules and then provide other modules as parameter(s) to get a specific implementation. For instance, a <span class="c003">Set</span> module implementing sets as sorted lists could be parameterized to work with any module that provides an element type and a comparison function <span class="c003">compare</span> (such as <span class="c003">OrderedString</span>):</p>
<pre class="caml-example toplevel" data-language="ocaml">   type comparison = Less | Equal | Greater;; type comparison = Less | Equal | Greater   module type ORDERED_TYPE = sig type t val compare: t -&gt; t -&gt; comparison end;; module type ORDERED_TYPE = sig type t val compare : t -&gt; t -&gt; comparison end   module Set = functor (Elt: ORDERED_TYPE) -&gt; struct type element = Elt.t type set = element list let empty = [] let rec add x s = match s with [] -&gt; [x] | hd::tl -&gt; match Elt.compare x hd with Equal -&gt; s (* x is already in s *) | Less -&gt; x :: s (* x is smaller than all elements of s *) | Greater -&gt; hd :: add x tl let rec member x s = match s with [] -&gt; false | hd::tl -&gt; match Elt.compare x hd with Equal -&gt; true (* x belongs to s *) | Less -&gt; false (* x is smaller than all elements of s *) | Greater -&gt; member x tl end;; module Set : functor (Elt : ORDERED_TYPE) -&gt; sig type element = Elt.t type set = element list val empty : 'a list val add : Elt.t -&gt; Elt.t list -&gt; Elt.t list val member : Elt.t -&gt; Elt.t list -&gt; bool end </pre>
<p> By applying the <span class="c003">Set</span> functor to a structure implementing an ordered type, we obtain set operations for this type: </p>
<pre class="caml-example toplevel" data-language="ocaml">   module OrderedString = struct type t = string let compare x y = if x = y then Equal else if x &lt; y then Less else Greater end;; module OrderedString : sig type t = string val compare : 'a -&gt; 'a -&gt; comparison end   module StringSet = Set(OrderedString);; module StringSet : sig type element = OrderedString.t type set = element list val empty : 'a list val add : OrderedString.t -&gt; OrderedString.t list -&gt; OrderedString.t list val member : OrderedString.t -&gt; OrderedString.t list -&gt; bool end   StringSet.member "bar" (StringSet.add "foo" StringSet.empty);; - : bool = false </pre> <h2 class="section" id="s:functors-and-abstraction">
<a class="section-anchor" href="#s:functors-and-abstraction" aria-hidden="true">﻿</a>2.4 Functors and type abstraction</h2> <p>As in the <span class="c003">PrioQueue</span> example, it would be good style to hide the actual implementation of the type <span class="c003">set</span>, so that users of the structure will not rely on sets being lists, and we can switch later to another, more efficient representation of sets without breaking their code. This can be achieved by restricting <span class="c003">Set</span> by a suitable functor signature: </p>
<pre class="caml-example toplevel" data-language="ocaml">   module type SETFUNCTOR = functor (Elt: ORDERED_TYPE) -&gt; sig type element = Elt.t (* concrete *) type set (* abstract *) val empty : set val add : element -&gt; set -&gt; set val member : element -&gt; set -&gt; bool end;; module type SETFUNCTOR = functor (Elt : ORDERED_TYPE) -&gt; sig type element = Elt.t type set val empty : set val add : element -&gt; set -&gt; set val member : element -&gt; set -&gt; bool end   module AbstractSet = (Set : SETFUNCTOR);; module AbstractSet : SETFUNCTOR   module AbstractStringSet = AbstractSet(OrderedString);; module AbstractStringSet : sig type element = OrderedString.t type set = AbstractSet(OrderedString).set val empty : set val add : element -&gt; set -&gt; set val member : element -&gt; set -&gt; bool end   AbstractStringSet.add "gee" AbstractStringSet.empty;; - : AbstractStringSet.set = &lt;abstr&gt; </pre>
<p>In an attempt to write the type constraint above more elegantly, one may wish to name the signature of the structure returned by the functor, then use that signature in the constraint: </p>
<pre class="caml-example toplevel" data-language="ocaml">   module type SET = sig type element type set val empty : set val add : element -&gt; set -&gt; set val member : element -&gt; set -&gt; bool end;; module type SET = sig type element type set val empty : set val add : element -&gt; set -&gt; set val member : element -&gt; set -&gt; bool end   module WrongSet = (Set : functor(Elt: ORDERED_TYPE) -&gt; SET);; module WrongSet : functor (Elt : ORDERED_TYPE) -&gt; SET   module WrongStringSet = WrongSet(OrderedString);; module WrongStringSet : sig type element = WrongSet(OrderedString).element type set = WrongSet(OrderedString).set val empty : set val add : element -&gt; set -&gt; set val member : element -&gt; set -&gt; bool end   WrongStringSet.add "gee" WrongStringSet.empty ;; Error: This expression has type string but an expression was expected of type WrongStringSet.element = WrongSet(OrderedString).element </pre>
<p> The problem here is that <span class="c003">SET</span> specifies the type <span class="c003">element</span> abstractly, so that the type equality between <span class="c003">element</span> in the result of the functor and <span class="c003">t</span> in its argument is forgotten. Consequently, <span class="c003">WrongStringSet.element</span> is not the same type as <span class="c003">string</span>, and the operations of <span class="c003">WrongStringSet</span> cannot be applied to strings. As demonstrated above, it is important that the type <span class="c003">element</span> in the signature <span class="c003">SET</span> be declared equal to <span class="c003">Elt.t</span>; unfortunately, this is impossible above since <span class="c003">SET</span> is defined in a context where <span class="c003">Elt</span> does not exist. To overcome this difficulty, OCaml provides a <span class="c003">with type</span> construct over signatures that allows enriching a signature with extra type equalities: </p>
<pre class="caml-example toplevel" data-language="ocaml">   module AbstractSet2 = (Set : functor(Elt: ORDERED_TYPE) -&gt; (SET with type element = Elt.t));; module AbstractSet2 : functor (Elt : ORDERED_TYPE) -&gt; sig type element = Elt.t type set val empty : set val add : element -&gt; set -&gt; set val member : element -&gt; set -&gt; bool end </pre>
<p>As in the case of simple structures, an alternate syntax is provided for defining functors and restricting their result: </p>
<pre data-language="ocaml">module AbstractSet2(Elt: ORDERED_TYPE) : (SET with type element = Elt.t) =
  struct ... end;;
</pre>
<p> Abstracting a type component in a functor result is a powerful technique that provides a high degree of type safety, as we now illustrate. Consider an ordering over character strings that is different from the standard ordering implemented in the <span class="c003">OrderedString</span> structure. For instance, we compare strings without distinguishing upper and lower case. </p>
<pre class="caml-example toplevel" data-language="ocaml">   module NoCaseString = struct type t = string let compare s1 s2 = OrderedString.compare (String.lowercase_ascii s1) (String.lowercase_ascii s2) end;; module NoCaseString : sig type t = string val compare : string -&gt; string -&gt; comparison end   module NoCaseStringSet = AbstractSet(NoCaseString);; module NoCaseStringSet : sig type element = NoCaseString.t type set = AbstractSet(NoCaseString).set val empty : set val add : element -&gt; set -&gt; set val member : element -&gt; set -&gt; bool end   NoCaseStringSet.add "FOO" AbstractStringSet.empty ;; Error: This expression has type AbstractStringSet.set = AbstractSet(OrderedString).set but an expression was expected of type NoCaseStringSet.set = AbstractSet(NoCaseString).set </pre>
<p> Note that the two types <span class="c003">AbstractStringSet.set</span> and <span class="c003">NoCaseStringSet.set</span> are not compatible, and values of these two types do not match. This is the correct behavior: even though both set types contain elements of the same type (strings), they are built upon different orderings of that type, and different invariants need to be maintained by the operations (being strictly increasing for the standard ordering and for the case-insensitive ordering). Applying operations from <span class="c003">AbstractStringSet</span> to values of type <span class="c003">NoCaseStringSet.set</span> could give incorrect results, or build lists that violate the invariants of <span class="c003">NoCaseStringSet</span>.</p> <h2 class="section" id="s:separate-compilation">
<a class="section-anchor" href="#s:separate-compilation" aria-hidden="true">﻿</a>2.5 Modules and separate compilation</h2> <p>All examples of modules so far have been given in the context of the interactive system. However, modules are most useful for large, batch-compiled programs. For these programs, it is a practical necessity to split the source into several files, called compilation units, that can be compiled separately, thus minimizing recompilation after changes.</p>
<p>In OCaml, compilation units are special cases of structures and signatures, and the relationship between the units can be explained easily in terms of the module system. A compilation unit <span class="c009">A</span> comprises two files: </p>
<ul class="itemize">
<li class="li-itemize"> the implementation file <span class="c009">A</span><span class="c003">.ml</span>, which contains a sequence of definitions, analogous to the inside of a <span class="c003">struct</span>…<span class="c003">end</span> construct; </li>
<li class="li-itemize">the interface file <span class="c009">A</span><span class="c003">.mli</span>, which contains a sequence of specifications, analogous to the inside of a <span class="c003">sig</span>…<span class="c003">end</span> construct. </li>
</ul>
<p> These two files together define a structure named <span class="c009">A</span> as if the following definition was entered at top-level: </p>
<pre data-language="ocaml">
module A: sig (* contents of file A.mli *) end
        = struct (* contents of file A.ml *) end;;
</pre>
<p> The files that define the compilation units can be compiled separately using the <span class="c003">ocamlc -c</span> command (the <span class="c003">-c</span> option means “compile only, do not try to link”); this produces compiled interface files (with extension <span class="c003">.cmi</span>) and compiled object code files (with extension <span class="c003">.cmo</span>). When all units have been compiled, their <span class="c003">.cmo</span> files are linked together using the <span class="c003">ocamlc</span> command. For instance, the following commands compile and link a program composed of two compilation units <span class="c003">Aux</span> and <span class="c003">Main</span>: </p>
<pre data-language="ocaml">$ ocamlc -c Aux.mli                     # produces aux.cmi
$ ocamlc -c Aux.ml                      # produces aux.cmo
$ ocamlc -c Main.mli                    # produces main.cmi
$ ocamlc -c Main.ml                     # produces main.cmo
$ ocamlc -o theprogram Aux.cmo Main.cmo
</pre>
<p>The program behaves exactly as if the following phrases were entered at top-level: </p>
<pre data-language="ocaml">
module Aux: sig (* contents of Aux.mli *) end
          = struct (* contents of Aux.ml *) end;;
module Main: sig (* contents of Main.mli *) end
           = struct (* contents of Main.ml *) end;;
</pre>
<p> In particular, <span class="c003">Main</span> can refer to <span class="c003">Aux</span>: the definitions and declarations contained in <span class="c003">Main.ml</span> and <span class="c003">Main.mli</span> can refer to definition in <span class="c003">Aux.ml</span>, using the <span class="c003">Aux.</span><span class="c009">ident</span> notation, provided these definitions are exported in <span class="c003">Aux.mli</span>.</p>
<p>The order in which the <span class="c003">.cmo</span> files are given to <span class="c003">ocamlc</span> during the linking phase determines the order in which the module definitions occur. Hence, in the example above, <span class="c003">Aux</span> appears first and <span class="c003">Main</span> can refer to it, but <span class="c003">Aux</span> cannot refer to <span class="c003">Main</span>.</p>
<p>Note that only top-level structures can be mapped to separately-compiled files, but neither functors nor module types. However, all module-class objects can appear as components of a structure, so the solution is to put the functor or module type inside a structure, which can then be mapped to a file. </p> <hr> <a href="coreexamples"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjQgMjQiIGhlaWdodD0iMjQiIHdpZHRoPSIyNCIgPgogIDxwYXRoIGQ9Ik00IDEybDggOGwxLjQxNCAtMS40MTRMNy44MjggMTNIMjB2LTJINy44MjhMMTMuNDE0IDUuNDE0TDEyIDR6Ii8+Cjwvc3ZnPgo=" alt="Previous"></a> <a href="index"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDI0IDI0IiBoZWlnaHQ9IjI0IiB3aWR0aD0iMjQiPgogIDxwYXRoIGQ9Ik0xMiA0bDggOGwtMS40MTQgMS40MTRMMTMgNy44MjhWMjBoLTJWNy44MjhMNS40MTQgMTMuNDE0TDQgMTJ6Ii8+Cjwvc3ZnPgo=" alt="Up"></a> <a href="objectexamples"><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMjQgMjQiIGhlaWdodD0iMjQiIHdpZHRoPSIyNCIgPgogIDxwYXRoIGQ9Ik0yMCAxMmwtOCA4bC0xLjQxNCAtMS40MTRMMTYuMTcyIDEzSDR2LTJIMTYuMTcyTDEwLjU4NiA1LjQxNEwxMiA0IHoiLz4KPC9zdmc+Cg==" alt="Next"></a><div class="_attribution">
  <p class="_attribution-p">
    © INRIA 1995-2020.<br>
    <a href="https://www.ocaml.org/releases/4.11/htmlman/moduleexamples.html" class="_attribution-link">https://www.ocaml.org/releases/4.11/htmlman/moduleexamples.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
