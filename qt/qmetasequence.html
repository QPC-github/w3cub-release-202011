
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>QMetaSequence (Class) - Qt - W3cubDocs</title>
  
  <meta name="description" content=" The QMetaSequence class allows type erased access to sequential containers. More... ">
  <meta name="keywords" content="qmetasequence, class, qt">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/qt/qmetasequence.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/qt.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/qt/" class="_nav-link" title="" style="margin-left:0;">Qt</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _qt">
				
				
<h1 class="title">QMetaSequence Class</h1>  <p>The QMetaSequence class allows type erased access to sequential containers. <a href="#details">More...</a></p>  <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> Header:</td>
<td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QMetaSequence&gt;</span> </td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> CMake:</td>
<td class="memItemRight bottomAlign"> find_package(Qt6 COMPONENTS Core REQUIRED)  target_link_libraries(mytarget PRIVATE Qt6::Core)</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> qmake:</td>
<td class="memItemRight bottomAlign"> QT += core</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Since:</td>
<td class="memItemRight bottomAlign"> Qt 6.0</td>
</tr>
<tr>
<td class="memItemLeft rightAlign topAlign"> Inherits:</td>
<td class="memItemRight bottomAlign"> QMetaContainer</td>
</tr>
</table> <ul> <li><a href="https://doc.qt.io/qt-6.2/qmetasequence-members.html">List of all members, including inherited members</a></li> </ul> <h2 id="public-functions">Public Functions
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#addValue">addValue</a></b>(void *<i>container</i>, const void *<i>value</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#addValueAtBegin">addValueAtBegin</a></b>(void *<i>container</i>, const void *<i>value</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#addValueAtEnd">addValueAtEnd</a></b>(void *<i>container</i>, const void *<i>value</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canAddValue">canAddValue</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canAddValueAtBegin">canAddValueAtBegin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canAddValueAtEnd">canAddValueAtEnd</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canEraseRangeAtIterator">canEraseRangeAtIterator</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canEraseValueAtIterator">canEraseValueAtIterator</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canGetValueAtConstIterator">canGetValueAtConstIterator</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canGetValueAtIndex">canGetValueAtIndex</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canGetValueAtIterator">canGetValueAtIterator</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canInsertValueAtIterator">canInsertValueAtIterator</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canRemoveValue">canRemoveValue</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canRemoveValueAtBegin">canRemoveValueAtBegin</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canRemoveValueAtEnd">canRemoveValueAtEnd</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canSetValueAtIndex">canSetValueAtIndex</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#canSetValueAtIterator">canSetValueAtIterator</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#eraseRangeAtIterator">eraseRangeAtIterator</a></b>(void *<i>container</i>, const void *<i>iterator1</i>, const void *<i>iterator2</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#eraseValueAtIterator">eraseValueAtIterator</a></b>(void *<i>container</i>, const void *<i>iterator</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#insertValueAtIterator">insertValueAtIterator</a></b>(void *<i>container</i>, const void *<i>iterator</i>, const void *<i>value</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> bool </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#isSortable">isSortable</a></b>() const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#removeValue">removeValue</a></b>(void *<i>container</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#removeValueAtBegin">removeValueAtBegin</a></b>(void *<i>container</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#removeValueAtEnd">removeValueAtEnd</a></b>(void *<i>container</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#setValueAtIndex">setValueAtIndex</a></b>(void *<i>container</i>, qsizetype <i>index</i>, const void *<i>value</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#setValueAtIterator">setValueAtIterator</a></b>(const void *<i>iterator</i>, const void *<i>value</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#valueAtConstIterator">valueAtConstIterator</a></b>(const void *<i>iterator</i>, void *<i>result</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#valueAtIndex">valueAtIndex</a></b>(const void *<i>container</i>, qsizetype <i>index</i>, void *<i>result</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> void </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#valueAtIterator">valueAtIterator</a></b>(const void *<i>iterator</i>, void *<i>result</i>) const</td>
</tr> <tr>
<td class="memItemLeft rightAlign topAlign"> QMetaType </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#valueMetaType">valueMetaType</a></b>() const</td>
</tr> </table> <h2 id="static-public-members">Static Public Members
</h2> <table class="alignedsummary"> <tr>
<td class="memItemLeft rightAlign topAlign"> QMetaSequence </td>
<td class="memItemRight bottomAlign">
<b><a href="qmetasequence#fromContainer">fromContainer</a></b>()</td>
</tr> </table>   <h2 id="details">Detailed Description
</h2> <p>The class provides a number of primitive container operations, using void* as operands. This way, you can manipulate a generic container retrieved from a Variant without knowing its type.</p> <p>The void* arguments to the various methods are typically created by using a <a href="qvariant">QVariant</a> of the respective container or value type, and calling its <a href="qvariant#data">QVariant::data</a>() or <a href="qvariant#constData">QVariant::constData</a>() methods. However, you can also pass plain pointers to objects of the container or value type.</p> <p>Iterator invalidation follows the rules given by the underlying containers and is not expressed in the API. Therefore, for a truly generic container, any iterators should be considered invalid after any write operation.</p>    <h2>Member Function Documentation</h2>  <h3 class="fn" id="addValue">
<span class="type">void</span> QMetaSequence::<span class="name">addValue</span>(<span class="type">void</span> *<i>container</i>, const <span class="type">void</span> *<i>value</i>) const
</h3> <p>Adds <i>value</i> to the <i>container</i> if possible. If <a href="qmetasequence#canAddValue">canAddValue</a>() returns <code>false</code>, the <i>value</i> is not added. Else, if <a href="qmetasequence#canAddValueAtEnd">canAddValueAtEnd</a>() returns <code>true</code>, the <i>value</i> is added to the end of the <i>container</i>. Else, if <a href="qmetasequence#canAddValueAtBegin">canAddValueAtBegin</a>() returns <code>true</code>, the <i>value</i> is added to the beginning of the container. Else, the value is added in an unspecified place or not at all. The latter is the case for adding values to an unordered container, for example <a href="qset">QSet</a>.</p> <p><b>See also </b><a href="qmetasequence#canAddValue">canAddValue</a>(), <a href="qmetasequence#canAddValueAtBegin">canAddValueAtBegin</a>(), <a href="qmetasequence#canAddValueAtEnd">canAddValueAtEnd</a>(), <a href="qmetasequence#isSortable">isSortable</a>(), and <a href="qmetasequence#removeValue">removeValue</a>().</p>   <h3 class="fn" id="addValueAtBegin">
<span class="type">void</span> QMetaSequence::<span class="name">addValueAtBegin</span>(<span class="type">void</span> *<i>container</i>, const <span class="type">void</span> *<i>value</i>) const
</h3> <p>Adds <i>value</i> to the beginning of <i>container</i> if possible. If <a href="qmetasequence#canAddValueAtBegin">canAddValueAtBegin</a>() returns <code>false</code>, the <i>value</i> is not added.</p> <p><b>See also </b><a href="qmetasequence#canAddValueAtBegin">canAddValueAtBegin</a>(), <a href="qmetasequence#isSortable">isSortable</a>(), and <a href="qmetasequence#removeValueAtBegin">removeValueAtBegin</a>().</p>   <h3 class="fn" id="addValueAtEnd">
<span class="type">void</span> QMetaSequence::<span class="name">addValueAtEnd</span>(<span class="type">void</span> *<i>container</i>, const <span class="type">void</span> *<i>value</i>) const
</h3> <p>Adds <i>value</i> to the end of <i>container</i> if possible. If <a href="qmetasequence#canAddValueAtEnd">canAddValueAtEnd</a>() returns <code>false</code>, the <i>value</i> is not added.</p> <p><b>See also </b><a href="qmetasequence#canAddValueAtEnd">canAddValueAtEnd</a>(), <a href="qmetasequence#isSortable">isSortable</a>(), and <a href="qmetasequence#removeValueAtEnd">removeValueAtEnd</a>().</p>   <h3 class="fn" id="canAddValue">
<span class="type">bool</span> QMetaSequence::<span class="name">canAddValue</span>() const
</h3> <p>Returns <code>true</code> if values can be added to the container, <code>false</code> otherwise.</p> <p><b>See also </b><a href="qmetasequence#addValue">addValue</a>() and <a href="qmetasequence#isSortable">isSortable</a>().</p>   <h3 class="fn" id="canAddValueAtBegin">
<span class="type">bool</span> QMetaSequence::<span class="name">canAddValueAtBegin</span>() const
</h3> <p>Returns <code>true</code> if values added using <a href="qmetasequence#addValue">addValue</a>() can be placed at the beginning of the container, otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qmetasequence#addValueAtBegin">addValueAtBegin</a>() and <a href="qmetasequence#canAddValueAtEnd">canAddValueAtEnd</a>().</p>   <h3 class="fn" id="canAddValueAtEnd">
<span class="type">bool</span> QMetaSequence::<span class="name">canAddValueAtEnd</span>() const
</h3> <p>Returns <code>true</code> if values added using <a href="qmetasequence#addValue">addValue</a>() can be placed at the end of the container, otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qmetasequence#addValueAtEnd">addValueAtEnd</a>() and <a href="qmetasequence#canAddValueAtBegin">canAddValueAtBegin</a>().</p>   <h3 class="fn" id="canEraseRangeAtIterator">
<span class="type">bool</span> QMetaSequence::<span class="name">canEraseRangeAtIterator</span>() const
</h3> <p>Returns <code>true</code> if a range between two iterators can be erased from the container, <code>false</code> otherwise.</p>   <h3 class="fn" id="canEraseValueAtIterator">
<span class="type">bool</span> QMetaSequence::<span class="name">canEraseValueAtIterator</span>() const
</h3> <p>Returns <code>true</code> if the value pointed to by a non-const iterator can be erased, <code>false</code> otherwise.</p> <p><b>See also </b><a href="qmetacontainer#hasIterator">hasIterator</a>() and <a href="qmetasequence#eraseValueAtIterator">eraseValueAtIterator</a>().</p>   <h3 class="fn" id="canGetValueAtConstIterator">
<span class="type">bool</span> QMetaSequence::<span class="name">canGetValueAtConstIterator</span>() const
</h3> <p>Returns <code>true</code> if the underlying container can retrieve the value pointed to by a const iterator, <code>false</code> otherwise.</p> <p><b>See also </b><a href="qmetacontainer#hasConstIterator">hasConstIterator</a>() and <a href="qmetasequence#valueAtConstIterator">valueAtConstIterator</a>().</p>   <h3 class="fn" id="canGetValueAtIndex">
<span class="type">bool</span> QMetaSequence::<span class="name">canGetValueAtIndex</span>() const
</h3> <p>Returns <code>true</code> if values can be retrieved from the container by index, otherwise <code>false</code>.</p> <p><b>See also </b><a href="qmetasequence#valueAtIndex">valueAtIndex</a>().</p>   <h3 class="fn" id="canGetValueAtIterator">
<span class="type">bool</span> QMetaSequence::<span class="name">canGetValueAtIterator</span>() const
</h3> <p>Returns <code>true</code> if the underlying container can retrieve the value pointed to by a non-const iterator, <code>false</code> otherwise.</p> <p><b>See also </b><a href="qmetacontainer#hasIterator">hasIterator</a>() and <a href="qmetasequence#valueAtIterator">valueAtIterator</a>().</p>   <h3 class="fn" id="canInsertValueAtIterator">
<span class="type">bool</span> QMetaSequence::<span class="name">canInsertValueAtIterator</span>() const
</h3> <p>Returns <code>true</code> if the underlying container can insert a new value, taking the location pointed to by a non-const iterator into account.</p> <p><b>See also </b><a href="qmetacontainer#hasIterator">hasIterator</a>() and <a href="qmetasequence#insertValueAtIterator">insertValueAtIterator</a>().</p>   <h3 class="fn" id="canRemoveValue">
<span class="type">bool</span> QMetaSequence::<span class="name">canRemoveValue</span>() const
</h3> <p>Returns <code>true</code> if values can be removed from the container, <code>false</code> otherwise.</p> <p><b>See also </b><a href="qmetasequence#removeValue">removeValue</a>() and <a href="qmetasequence#isSortable">isSortable</a>().</p>   <h3 class="fn" id="canRemoveValueAtBegin">
<span class="type">bool</span> QMetaSequence::<span class="name">canRemoveValueAtBegin</span>() const
</h3> <p>Returns <code>true</code> if values can be removed from the beginning of the container using <a href="qmetasequence#removeValue">removeValue</a>() can be placed at the, otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qmetasequence#removeValueAtBegin">removeValueAtBegin</a>() and <a href="qmetasequence#canRemoveValueAtEnd">canRemoveValueAtEnd</a>().</p>   <h3 class="fn" id="canRemoveValueAtEnd">
<span class="type">bool</span> QMetaSequence::<span class="name">canRemoveValueAtEnd</span>() const
</h3> <p>Returns <code>true</code> if values can be removed from the end of the container using <a href="qmetasequence#removeValue">removeValue</a>() can be placed at the, otherwise returns <code>false</code>.</p> <p><b>See also </b><a href="qmetasequence#removeValueAtEnd">removeValueAtEnd</a>() and <a href="qmetasequence#canRemoveValueAtBegin">canRemoveValueAtBegin</a>().</p>   <h3 class="fn" id="canSetValueAtIndex">
<span class="type">bool</span> QMetaSequence::<span class="name">canSetValueAtIndex</span>() const
</h3> <p>Returns <code>true</code> if an value can be written to the container by index, otherwise <code>false</code>.</p> <p><b>See also </b><a href="qmetasequence#setValueAtIndex">setValueAtIndex</a>().</p>   <h3 class="fn" id="canSetValueAtIterator">
<span class="type">bool</span> QMetaSequence::<span class="name">canSetValueAtIterator</span>() const
</h3> <p>Returns <code>true</code> if the underlying container can write to the value pointed to by a non-const iterator, <code>false</code> otherwise.</p> <p><b>See also </b><a href="qmetacontainer#hasIterator">hasIterator</a>() and <a href="qmetasequence#setValueAtIterator">setValueAtIterator</a>().</p>   <h3 class="fn" id="eraseRangeAtIterator">
<span class="type">void</span> QMetaSequence::<span class="name">eraseRangeAtIterator</span>(<span class="type">void</span> *<i>container</i>, const <span class="type">void</span> *<i>iterator1</i>, const <span class="type">void</span> *<i>iterator2</i>) const
</h3> <p>Erases the range of values between the iterators <i>iterator1</i> and <i>iterator2</i> from the <i>container</i>, if possible.</p> <p><b>See also </b><a href="qmetasequence#canEraseValueAtIterator">canEraseValueAtIterator</a>(), <a href="qmetacontainer#begin">begin</a>(), and <a href="qmetacontainer#end">end</a>().</p>   <h3 class="fn" id="eraseValueAtIterator">
<span class="type">void</span> QMetaSequence::<span class="name">eraseValueAtIterator</span>(<span class="type">void</span> *<i>container</i>, const <span class="type">void</span> *<i>iterator</i>) const
</h3> <p>Erases the value pointed to by the non-const <i>iterator</i> from the <i>container</i>, if possible.</p> <p><b>See also </b><a href="qmetasequence#canEraseValueAtIterator">canEraseValueAtIterator</a>(), <a href="qmetacontainer#begin">begin</a>(), and <a href="qmetacontainer#end">end</a>().</p>   <h3 class="fn" id="fromContainer">
<code>[static, since 6.0] </code>template &lt;typename T&gt; <span class="type">QMetaSequence</span> QMetaSequence::<span class="name">fromContainer</span>()
</h3> <p>Returns the <a href="qmetasequence">QMetaSequence</a> corresponding to the type given as template parameter.</p> <p>This function was introduced in Qt 6.0.</p>   <h3 class="fn" id="insertValueAtIterator">
<span class="type">void</span> QMetaSequence::<span class="name">insertValueAtIterator</span>(<span class="type">void</span> *<i>container</i>, const <span class="type">void</span> *<i>iterator</i>, const <span class="type">void</span> *<i>value</i>) const
</h3> <p>Inserts <i>value</i> into the <i>container</i>, if possible, taking the non-const <i>iterator</i> into account. If <a href="qmetasequence#canInsertValueAtIterator">canInsertValueAtIterator</a>() returns <code>false</code>, the <i>value</i> is not inserted. Else if <a href="qmetasequence#isSortable">isSortable</a>() returns <code>true</code>, the value is inserted before the value pointed to by <i>iterator</i>. Else, the <i>value</i> is inserted at an unspecified place or not at all. In the latter case, the <i>iterator</i> is taken as a hint. If it points to the correct place for the <i>value</i>, the operation may be faster than a <a href="qmetasequence#addValue">addValue</a>() without iterator.</p> <p><b>See also </b><a href="qmetasequence#canInsertValueAtIterator">canInsertValueAtIterator</a>(), <a href="qmetasequence#isSortable">isSortable</a>(), <a href="qmetacontainer#begin">begin</a>(), and <a href="qmetacontainer#end">end</a>().</p>   <h3 class="fn" id="isSortable">
<span class="type">bool</span> QMetaSequence::<span class="name">isSortable</span>() const
</h3> <p>Returns <code>true</code> if the underlying container is sortable, otherwise returns <code>false</code>. A container is considered sortable if values added to it are placed in a defined location. Inserting into or adding to a sortable container will always succeed. Inserting into or adding to an unsortable container may not succeed, for example if the container is a <a href="qset">QSet</a> that already contains the value being inserted.</p> <p><b>See also </b><a href="qmetasequence#addValue">addValue</a>(), <a href="qmetasequence#insertValueAtIterator">insertValueAtIterator</a>(), <a href="qmetasequence#canAddValueAtBegin">canAddValueAtBegin</a>(), <a href="qmetasequence#canAddValueAtEnd">canAddValueAtEnd</a>(), <a href="qmetasequence#canRemoveValueAtBegin">canRemoveValueAtBegin</a>(), and <a href="qmetasequence#canRemoveValueAtEnd">canRemoveValueAtEnd</a>().</p>   <h3 class="fn" id="removeValue">
<span class="type">void</span> QMetaSequence::<span class="name">removeValue</span>(<span class="type">void</span> *<i>container</i>) const
</h3> <p>Removes an value from the <i>container</i> if possible. If <a href="qmetasequence#canRemoveValue">canRemoveValue</a>() returns <code>false</code>, no value is removed. Else, if <a href="qmetasequence#canRemoveValueAtEnd">canRemoveValueAtEnd</a>() returns <code>true</code>, the last value in the <i>container</i> is removed. Else, if <a href="qmetasequence#canRemoveValueAtBegin">canRemoveValueAtBegin</a>() returns <code>true</code>, the first value in the <i>container</i> is removed. Else, an unspecified value or nothing is removed.</p> <p><b>See also </b><a href="qmetasequence#canRemoveValue">canRemoveValue</a>(), <a href="qmetasequence#canRemoveValueAtBegin">canRemoveValueAtBegin</a>(), <a href="qmetasequence#canRemoveValueAtEnd">canRemoveValueAtEnd</a>(), <a href="qmetasequence#isSortable">isSortable</a>(), and <a href="qmetasequence#addValue">addValue</a>().</p>   <h3 class="fn" id="removeValueAtBegin">
<span class="type">void</span> QMetaSequence::<span class="name">removeValueAtBegin</span>(<span class="type">void</span> *<i>container</i>) const
</h3> <p>Removes a value from the beginning of <i>container</i> if possible. If <a href="qmetasequence#canRemoveValueAtBegin">canRemoveValueAtBegin</a>() returns <code>false</code>, the value is not removed.</p> <p><b>See also </b><a href="qmetasequence#canRemoveValueAtBegin">canRemoveValueAtBegin</a>(), <a href="qmetasequence#isSortable">isSortable</a>(), and <a href="qmetasequence#addValueAtBegin">addValueAtBegin</a>().</p>   <h3 class="fn" id="removeValueAtEnd">
<span class="type">void</span> QMetaSequence::<span class="name">removeValueAtEnd</span>(<span class="type">void</span> *<i>container</i>) const
</h3> <p>Removes a value from the end of <i>container</i> if possible. If <a href="qmetasequence#canRemoveValueAtEnd">canRemoveValueAtEnd</a>() returns <code>false</code>, the value is not removed.</p> <p><b>See also </b><a href="qmetasequence#canRemoveValueAtEnd">canRemoveValueAtEnd</a>(), <a href="qmetasequence#isSortable">isSortable</a>(), and <a href="qmetasequence#addValueAtEnd">addValueAtEnd</a>().</p>   <h3 class="fn" id="setValueAtIndex">
<span class="type">void</span> QMetaSequence::<span class="name">setValueAtIndex</span>(<span class="type">void</span> *<i>container</i>, <span class="type">qsizetype</span> <i>index</i>, const <span class="type">void</span> *<i>value</i>) const
</h3> <p>Overwrites the value at <i>index</i> in the <i>container</i> using the <i>value</i> passed as parameter if that is possible.</p> <p><b>See also </b><a href="qmetasequence#valueAtIndex">valueAtIndex</a>() and <a href="qmetasequence#canSetValueAtIndex">canSetValueAtIndex</a>().</p>   <h3 class="fn" id="setValueAtIterator">
<span class="type">void</span> QMetaSequence::<span class="name">setValueAtIterator</span>(const <span class="type">void</span> *<i>iterator</i>, const <span class="type">void</span> *<i>value</i>) const
</h3> <p>Writes <i>value</i> to the value pointed to by the non-const <i>iterator</i>, if possible.</p> <p><b>See also </b><a href="qmetasequence#valueAtIterator">valueAtIterator</a>(), <a href="qmetasequence#canSetValueAtIterator">canSetValueAtIterator</a>(), <a href="qmetacontainer#begin">begin</a>(), and <a href="qmetacontainer#end">end</a>().</p>   <h3 class="fn" id="valueAtConstIterator">
<span class="type">void</span> QMetaSequence::<span class="name">valueAtConstIterator</span>(const <span class="type">void</span> *<i>iterator</i>, <span class="type">void</span> *<i>result</i>) const
</h3> <p>Retrieves the value pointed to by the const <i>iterator</i> and stores it in the memory location pointed to by <i>result</i>, if possible.</p> <p><b>See also </b><a href="qmetasequence#canGetValueAtConstIterator">canGetValueAtConstIterator</a>(), <a href="qmetacontainer#constBegin">constBegin</a>(), and <a href="qmetacontainer#constEnd">constEnd</a>().</p>   <h3 class="fn" id="valueAtIndex">
<span class="type">void</span> QMetaSequence::<span class="name">valueAtIndex</span>(const <span class="type">void</span> *<i>container</i>, <span class="type">qsizetype</span> <i>index</i>, <span class="type">void</span> *<i>result</i>) const
</h3> <p>Retrieves the value at <i>index</i> in the <i>container</i> and places it in the memory location pointed to by <i>result</i>, if that is possible.</p> <p><b>See also </b><a href="qmetasequence#setValueAtIndex">setValueAtIndex</a>() and <a href="qmetasequence#canGetValueAtIndex">canGetValueAtIndex</a>().</p>   <h3 class="fn" id="valueAtIterator">
<span class="type">void</span> QMetaSequence::<span class="name">valueAtIterator</span>(const <span class="type">void</span> *<i>iterator</i>, <span class="type">void</span> *<i>result</i>) const
</h3> <p>Retrieves the value pointed to by the non-const <i>iterator</i> and stores it in the memory location pointed to by <i>result</i>, if possible.</p> <p><b>See also </b><a href="qmetasequence#setValueAtIterator">setValueAtIterator</a>(), <a href="qmetasequence#canGetValueAtIterator">canGetValueAtIterator</a>(), <a href="qmetacontainer#begin">begin</a>(), and <a href="qmetacontainer#end">end</a>().</p>   <h3 class="fn" id="valueMetaType">
<span class="type"><a href="qmetatype">QMetaType</a></span> QMetaSequence::<span class="name">valueMetaType</span>() const
</h3> <p>Returns the meta type for values stored in the container.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © The Qt Company Ltd<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://doc.qt.io/qt-6.2/qmetasequence.html" class="_attribution-link">https://doc.qt.io/qt-6.2/qmetasequence.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
