
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>dmd.func - D - W3cubDocs</title>
  
  <meta name="description" content=" Compiler implementation of the D programming language. ">
  <meta name="keywords" content="dmd, func, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/dmd_func.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/d.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>dmd.func</h1>  <p>Compiler implementation of the <a href="http://www.dlang.org">D programming language</a>. </p>
<dl>
<dt>Authors:</dt>
<dd>
<a href="http://www.digitalmars.com">Walter Bright</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/dmd/blob/master/src/dmd/func.d">func.d</a> </dd>
</dl> <dl>
<dt>Documentation</dt>
<dd> <a href="dmd_func">https://dlang.org/phobos/dmd_func.html</a> </dd>
</dl> <dl>
<dt>Coverage</dt>
<dd> <a href="https://codecov.io/gh/dlang/dmd/src/master/src/dmd/func.d">https://codecov.io/gh/dlang/dmd/src/master/src/dmd/func.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="ILS">enum <strong id="ILS">ILS</strong>: int; </dt> <dd>
<p>Inline Status</p> <dl>
<dt class="d_decl" id="ILS.uninitialized"><strong id="uninitialized">uninitialized</strong></dt> <dd>
<p>not computed yet</p> </dd> <dt class="d_decl" id="ILS.no"><strong id="no">no</strong></dt> <dd>
<p>cannot inline</p> </dd> <dt class="d_decl" id="ILS.yes"><strong id="yes">yes</strong></dt> <dd>
<p>can inline</p> </dd> </dl> </dd> <dt class="d_decl" id="Ensure">struct <strong id="Ensure">Ensure</strong>; </dt> <dd>
<p>Tuple of result identifier (possibly null) and statement. This is used to store out contracts: out(id){ ensure }</p> <dl>
<dt class="d_decl" id="Ensure.arraySyntaxCopy">static Ensures* <strong id="arraySyntaxCopy">arraySyntaxCopy</strong>(Ensures* a); </dt> <dd>
<p>Do syntax copy of an array of Ensure's.</p> </dd> </dl> </dd> <dt class="d_decl" id="FuncDeclaration">class <strong id="FuncDeclaration">FuncDeclaration</strong>: dmd.declaration.Declaration; </dt> <dd> <dl>
<dt class="d_decl" id="FuncDeclaration.HiddenParameters">struct <strong id="HiddenParameters">HiddenParameters</strong>; </dt> <dd>
<p>All hidden parameters bundled.</p> <dl>
<dt class="d_decl" id="FuncDeclaration.HiddenParameters.vthis">VarDeclaration <strong id="vthis">vthis</strong>; </dt> <dd>
<p>The <code>this</code> parameter for methods or nested functions. </p>
<p>For methods, it would be the class object or struct value the method is called on. For nested functions it would be the enclosing function's stack frame.</p> </dd> <dt class="d_decl" id="FuncDeclaration.HiddenParameters.isThis2">bool <strong id="isThis2">isThis2</strong>; </dt> <dd>
<p>Is 'this' a pointer to a static array holding two contexts.</p> </dd> <dt class="d_decl" id="FuncDeclaration.HiddenParameters.selectorParameter">VarDeclaration <strong id="selectorParameter">selectorParameter</strong>; </dt> <dd>
<p>The selector parameter for Objective-C methods.</p> </dd> </dl> </dd> <dt class="d_decl" id="FuncDeclaration.frequires">Statements* <strong id="frequires">frequires</strong>; </dt> <dd>
<p>in contracts</p> </dd> <dt class="d_decl" id="FuncDeclaration.fensures">Ensures* <strong id="fensures">fensures</strong>; </dt> <dd>
<p>out contracts</p> </dd> <dt class="d_decl" id="FuncDeclaration.frequire">Statement <strong id="frequire">frequire</strong>; </dt> <dd>
<p>lowered in contract</p> </dd> <dt class="d_decl" id="FuncDeclaration.fensure">Statement <strong id="fensure">fensure</strong>; </dt> <dd>
<p>lowered out contract</p> </dd> <dt class="d_decl" id="FuncDeclaration.fbody">Statement <strong id="fbody">fbody</strong>; </dt> <dd>
<p>function body</p> </dd> <dt class="d_decl" id="FuncDeclaration.foverrides">FuncDeclarations <strong id="foverrides">foverrides</strong>; </dt> <dd>
<p>functions this function overrides</p> </dd> <dt class="d_decl" id="FuncDeclaration.fdrequire">FuncDeclaration <strong id="fdrequire">fdrequire</strong>; </dt> <dd>
<p>function that does the in contract</p> </dd> <dt class="d_decl" id="FuncDeclaration.fdensure">FuncDeclaration <strong id="fdensure">fdensure</strong>; </dt> <dd>
<p>function that does the out contract</p> </dd> <dt class="d_decl" id="FuncDeclaration.fdrequireParams">Expressions* <strong id="fdrequireParams">fdrequireParams</strong>; </dt> <dd>
<p>argument list for __require</p> </dd> <dt class="d_decl" id="FuncDeclaration.fdensureParams">Expressions* <strong id="fdensureParams">fdensureParams</strong>; </dt> <dd>
<p>argument list for __ensure</p> </dd> <dt class="d_decl" id="FuncDeclaration.mangleString">const(char)* <strong id="mangleString">mangleString</strong>; </dt> <dd>
<p>mangled symbol created from mangleExact()</p> </dd> <dt class="d_decl" id="FuncDeclaration.vresult">VarDeclaration <strong id="vresult">vresult</strong>; </dt> <dd>
<p>result variable for out contracts</p> </dd> <dt class="d_decl" id="FuncDeclaration.returnLabel">LabelDsymbol <strong id="returnLabel">returnLabel</strong>; </dt> <dd>
<p>where the return goes</p> </dd> <dt class="d_decl" id="FuncDeclaration.vthis">VarDeclaration <strong id="vthis">vthis</strong>; </dt> <dd>
<p>'this' parameter (member and nested)</p> </dd> <dt class="d_decl" id="FuncDeclaration.isThis2">bool <strong id="isThis2">isThis2</strong>; </dt> <dd>
<p>has a dual-context 'this' parameter</p> </dd> <dt class="d_decl" id="FuncDeclaration.v_arguments">VarDeclaration <strong id="v_arguments">v_arguments</strong>; </dt> <dd>
<p>'arguments' parameter</p> </dd> <dt class="d_decl" id="FuncDeclaration.selector">ObjcSelector* <strong id="selector">selector</strong>; </dt> <dd>
<p>Objective-C method selector (member function only)</p> </dd> <dt class="d_decl" id="FuncDeclaration.selectorParameter">VarDeclaration <strong id="selectorParameter">selectorParameter</strong>; </dt> <dd>
<p>Objective-C implicit selector parameter</p> </dd> <dt class="d_decl" id="FuncDeclaration.v_argptr">VarDeclaration <strong id="v_argptr">v_argptr</strong>; </dt> <dd>
<p>'argptr' variable</p> </dd> <dt class="d_decl" id="FuncDeclaration.parameters">VarDeclarations* <strong id="parameters">parameters</strong>; </dt> <dd>
<p>Array of VarDeclaration's for parameters</p> </dd> <dt class="d_decl" id="FuncDeclaration.labtab">DsymbolTable <strong id="labtab">labtab</strong>; </dt> <dd>
<p>statement label symbol table</p> </dd> <dt class="d_decl" id="FuncDeclaration.overnext">Dsymbol <strong id="overnext">overnext</strong>; </dt> <dd>
<p>next in overload list</p> </dd> <dt class="d_decl" id="FuncDeclaration.overnext0">FuncDeclaration <strong id="overnext0">overnext0</strong>; </dt> <dd>
<p>next in overload list (only used during IFTI)</p> </dd> <dt class="d_decl" id="FuncDeclaration.endloc">Loc <strong id="endloc">endloc</strong>; </dt> <dd>
<p>location of closing curly bracket</p> </dd> <dt class="d_decl" id="FuncDeclaration.vtblIndex">int <strong id="vtblIndex">vtblIndex</strong>; </dt> <dd>
<p>for member functions, index into vtbl[]</p> </dd> <dt class="d_decl" id="FuncDeclaration.naked">bool <strong id="naked">naked</strong>; </dt> <dd>
<p>true if naked</p> </dd> <dt class="d_decl" id="FuncDeclaration.generated">bool <strong id="generated">generated</strong>; </dt> <dd>
<p>true if function was generated by the compiler rather than</p> </dd> <dt class="d_decl" id="FuncDeclaration.isCrtCtorDtor">ubyte <strong id="isCrtCtorDtor">isCrtCtorDtor</strong>; </dt> <dd>
<p>supplied by the user </p>
<p>has attribute pragma(crt_constructor(1)/crt_destructor(2))</p> </dd> <dt class="d_decl" id="FuncDeclaration.inlineStatusStmt">ILS <strong id="inlineStatusStmt">inlineStatusStmt</strong>; </dt> <dd>
<p>not set before the glue layer</p> </dd> <dt class="d_decl" id="FuncDeclaration.ctfeCode">CompiledCtfeFunctionPimpl <strong id="ctfeCode">ctfeCode</strong>; </dt> <dd>
<p>Local data (i.e. CompileCtfeFunction*) for module dinterpret</p> </dd> <dt class="d_decl" id="FuncDeclaration.inlineNest">int <strong id="inlineNest">inlineNest</strong>; </dt> <dd>
<p>!=0 if nested inline</p> </dd> <dt class="d_decl" id="FuncDeclaration.isArrayOp">bool <strong id="isArrayOp">isArrayOp</strong>; </dt> <dd>
<p>true if array operation</p> </dd> <dt class="d_decl" id="FuncDeclaration.eh_none">bool <strong id="eh_none">eh_none</strong>; </dt> <dd>
<p>true if no exception unwinding is needed</p> </dd> <dt class="d_decl" id="FuncDeclaration.semantic3Errors">bool <strong id="semantic3Errors">semantic3Errors</strong>; </dt> <dd>
<p>true if errors in semantic3 this function's frame ptr</p> </dd> <dt class="d_decl" id="FuncDeclaration.fes">ForeachStatement <strong id="fes">fes</strong>; </dt> <dd>
<p>if foreach body, this is the foreach</p> </dd> <dt class="d_decl" id="FuncDeclaration.interfaceVirtual">BaseClass* <strong id="interfaceVirtual">interfaceVirtual</strong>; </dt> <dd>
<p>if virtual, but only appears in base interface vtbl[]</p> </dd> <dt class="d_decl" id="FuncDeclaration.introducing">bool <strong id="introducing">introducing</strong>; </dt> <dd>
<p>true if 'introducing' function</p> </dd> <dt class="d_decl" id="FuncDeclaration.tintro">Type <strong id="tintro">tintro</strong>; </dt> <dd>
<p>if !=NULL, then this is the type of the 'introducing' function this one is overriding</p> </dd> <dt class="d_decl" id="FuncDeclaration.inferRetType">bool <strong id="inferRetType">inferRetType</strong>; </dt> <dd>
<p>true if return type is to be inferred</p> </dd> <dt class="d_decl" id="FuncDeclaration.storage_class2">StorageClass <strong id="storage_class2">storage_class2</strong>; </dt> <dd>
<p>storage class for template onemember's</p> </dd> <dt class="d_decl" id="FuncDeclaration.hasReturnExp">int <strong id="hasReturnExp">hasReturnExp</strong>; </dt> <dd>
<p>1 if there's a return exp; statement 2 if there's a throw statement 4 if there's an assert(0) 8 if there's inline asm 16 if there are multiple return statements</p> </dd> <dt class="d_decl" id="FuncDeclaration.nrvo_can">bool <strong id="nrvo_can">nrvo_can</strong>; </dt> <dd>
<p>true means we can do NRVO</p> </dd> <dt class="d_decl" id="FuncDeclaration.nrvo_var">VarDeclaration <strong id="nrvo_var">nrvo_var</strong>; </dt> <dd>
<p>variable to replace with shidden</p> </dd> <dt class="d_decl" id="FuncDeclaration.shidden">Symbol* <strong id="shidden">shidden</strong>; </dt> <dd>
<p>hidden pointer passed to function</p> </dd> <dt class="d_decl" id="FuncDeclaration.gotos">GotoStatements* <strong id="gotos">gotos</strong>; </dt> <dd>
<p>Gotos with forward references</p> </dd> <dt class="d_decl" id="FuncDeclaration.builtin">BUILTIN <strong id="builtin">builtin</strong>; </dt> <dd>
<p>set if this is a known, builtin function we can evaluate at compile time</p> </dd> <dt class="d_decl" id="FuncDeclaration.tookAddressOf">int <strong id="tookAddressOf">tookAddressOf</strong>; </dt> <dd>
<p>set if someone took the address of this function</p> </dd> <dt class="d_decl" id="FuncDeclaration.closureVars">VarDeclarations <strong id="closureVars">closureVars</strong>; </dt> <dd>
<p>local variables in this function which are referenced by nested functions</p> </dd> <dt class="d_decl" id="FuncDeclaration.siblingCallers">FuncDeclarations <strong id="siblingCallers">siblingCallers</strong>; </dt> <dd>
<p>Sibling nested functions which called this one</p> </dd> <dt class="d_decl" id="FuncDeclaration.flags">uint <strong id="flags">flags</strong>; </dt> <dd>
<p>FUNCFLAG.xxxxx</p> </dd> <dt class="d_decl" id="FuncDeclaration.functionSemantic">final bool <strong id="functionSemantic">functionSemantic</strong>(); </dt> <dd>
<p>Resolve forward reference of function signature - parameter types, return type, and attributes. Returns false if any errors exist in the signature.</p> </dd> <dt class="d_decl" id="FuncDeclaration.functionSemantic3">final bool <strong id="functionSemantic3">functionSemantic3</strong>(); </dt> <dd>
<p>Resolve forward reference of function body. Returns false if any errors exist in the body.</p> </dd> <dt class="d_decl" id="FuncDeclaration.checkForwardRef">final bool <strong id="checkForwardRef">checkForwardRef</strong>(ref const Loc loc); </dt> <dd>
<p>Check that this function type is properly resolved. If not, report "forward reference error" and return true.</p> </dd> <dt class="d_decl" id="FuncDeclaration.declareThis">final HiddenParameters <strong id="declareThis">declareThis</strong>(Scope* sc, AggregateDeclaration ad); </dt> <dd>
<p>Creates and returns the hidden parameters for this function declaration. </p>
<p>Hidden parameters include the <code>this</code> parameter of a class, struct or nested function and the selector parameter for Objective-C methods.</p> </dd> <dt class="d_decl" id="FuncDeclaration.overrides">final int <strong id="overrides">overrides</strong>(FuncDeclaration fd); </dt> <dd>
<p>Determine if 'this' overrides fd. Return !=0 if it does.</p> </dd> <dt class="d_decl" id="FuncDeclaration.findVtblIndex">final int <strong id="findVtblIndex">findVtblIndex</strong>(Dsymbols* vtbl, int dim, bool fix17349 = true); </dt> <dd>
<p>Find index of function in vtbl[0..dim] that this function overrides. Prefer an exact match to a covariant one. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Dsymbols* <code>vtbl</code>
</td> <td>vtable to use</td>
</tr> <tr>
<td>int <code>dim</code>
</td> <td>maximal vtable dimension</td>
</tr> <tr>
<td>bool <code>fix17349</code>
</td> <td>enable fix <a href="https://issues.dlang.org/show_bug.cgi?id=17349">https://issues.dlang.org/show_bug.cgi?id=17349</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>-1 didn't find one -2 can't determine because of forward references</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.overrideInterface">final BaseClass* <strong id="overrideInterface">overrideInterface</strong>(); </dt> <dd>
<p>If function a function in a base class, return that base class. </p>
<dl>
<dt>Returns:</dt>
<dd>base class if overriding, null if not</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.overloadInsert">bool <strong id="overloadInsert">overloadInsert</strong>(Dsymbol s); </dt> <dd>
<p>Overload this FuncDeclaration with the new one f. Return true if successful; i.e. no conflict.</p> </dd> <dt class="d_decl" id="FuncDeclaration.overloadExactMatch">final FuncDeclaration <strong id="overloadExactMatch">overloadExactMatch</strong>(Type t); </dt> <dd>
<p>Find function in overload list that exactly matches t.</p> </dd> <dt class="d_decl" id="FuncDeclaration.overloadModMatch">final FuncDeclaration <strong id="overloadModMatch">overloadModMatch</strong>(ref const Loc loc, Type tthis, ref bool hasOverloads); </dt> <dd>
<p>Find function in overload list that matches to the 'this' modifier. There's four result types. </p>
<p> 1. If the 'tthis' matches only one candidate, it's an "exact match". Returns the function and 'hasOverloads' is set to false. eg. If 'tthis" is mutable and there's only one mutable method. 2. If there's two or more match candidates, but a candidate function will be a "better match". Returns the better match function but 'hasOverloads' is set to true. eg. If 'tthis' is mutable, and there's both mutable and const methods, the mutable method will be a better match. 3. If there's two or more match candidates, but there's no better match, Returns null and 'hasOverloads' is set to true to represent "ambiguous match". eg. If 'tthis' is mutable, and there's two or more mutable methods. 4. If there's no candidates, it's "no match" and returns null with error report. e.g. If 'tthis' is const but there's no const methods.</p> </dd> <dt class="d_decl" id="FuncDeclaration.findTemplateDeclRoot">final TemplateDeclaration <strong id="findTemplateDeclRoot">findTemplateDeclRoot</strong>(); </dt> <dd>
<p>find function template root in overload list</p> </dd> <dt class="d_decl" id="FuncDeclaration.inUnittest">final bool <strong id="inUnittest">inUnittest</strong>(); </dt> <dd>
<p>Returns true if function was declared directly or indirectly in a unittest block</p> </dd> <dt class="d_decl" id="FuncDeclaration.leastAsSpecialized">final MATCH <strong id="leastAsSpecialized">leastAsSpecialized</strong>(FuncDeclaration g); </dt> <dd>
<p>Determine partial specialization order of 'this' vs g. This is very similar to TemplateDeclaration::leastAsSpecialized(). </p>
<dl>
<dt>Returns:</dt>
<dd>match 'this' is at least as specialized as g 0 g is more specialized than 'this'</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.searchLabel">final LabelDsymbol <strong id="searchLabel">searchLabel</strong>(Identifier ident); </dt> <dd>
<p>Labels are in a separate scope, one per function.</p> </dd> <dt class="d_decl" id="FuncDeclaration.getLevel">final int <strong id="getLevel">getLevel</strong>(FuncDeclaration fd, int intypeof); </dt> <dd>
<p>Determine lexical level difference from <code>this</code> to nested function <code>fd</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>FuncDeclaration <code>fd</code>
</td> <td>target of call</td>
</tr> <tr>
<td>int <code>intypeof</code>
</td> <td>!=0 if inside typeof</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>0 same level &gt;0 decrease nesting by number -1 increase nesting by 1 (<code>fd</code> is nested within <code>this</code>) LevelError error, <code>this</code> cannot call <code>fd</code>
</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.getLevelAndCheck">final int <strong id="getLevelAndCheck">getLevelAndCheck</strong>(ref const Loc loc, Scope* sc, FuncDeclaration fd); </dt> <dd>
<p>Determine lexical level difference from <code>this</code> to nested function <code>fd</code>. Issue error if <code>this</code> cannot call <code>fd</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Loc <code>loc</code>
</td> <td>location for error messages</td>
</tr> <tr>
<td>Scope* <code>sc</code>
</td> <td>context</td>
</tr> <tr>
<td>FuncDeclaration <code>fd</code>
</td> <td>target of call</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>0 same level &gt;0 decrease nesting by number -1 increase nesting by 1 (<code>fd</code> is nested within 'this') LevelError error</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.toFullSignature">final const(char)* <strong id="toFullSignature">toFullSignature</strong>(); </dt> <dd>
<p>for diagnostics, e.g. 'int foo(int x, int y) pure'</p> </dd> <dt class="d_decl" id="FuncDeclaration.isAbstract">final bool <strong id="isAbstract">isAbstract</strong>(); </dt> <dd>
<p>Override so it can work even if semantic() hasn't yet been run.</p> </dd> <dt class="d_decl" id="FuncDeclaration.canInferAttributes">final bool <strong id="canInferAttributes">canInferAttributes</strong>(Scope* sc); </dt> <dd>
<p>Decide if attributes for this function can be inferred from examining the function body. </p>
<dl>
<dt>Returns:</dt>
<dd>true if can</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.initInferAttributes">final void <strong id="initInferAttributes">initInferAttributes</strong>(); </dt> <dd>
<p>Initialize for inferring the attributes of this function.</p> </dd> <dt class="d_decl" id="FuncDeclaration.setImpure">final bool <strong id="setImpure">setImpure</strong>(); </dt> <dd>
<p>The function is doing something impure, so mark it as impure. If there's a purity error, return true.</p> </dd> <dt class="d_decl" id="FuncDeclaration.setUnsafe">final bool <strong id="setUnsafe">setUnsafe</strong>(); </dt> <dd>
<p>The function is doing something unsafe, so mark it as unsafe. If there's a safe error, return true.</p> </dd> <dt class="d_decl" id="FuncDeclaration.setGC">final bool <strong id="setGC">setGC</strong>(); </dt> <dd>
<p>The function is doing something that may allocate with the GC, so mark it as not nogc (not no-how). </p>
<dl>
<dt>Returns:</dt>
<dd>true if function is marked as @nogc, meaning a user error occurred</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.isReturnIsolated">final bool <strong id="isReturnIsolated">isReturnIsolated</strong>(); </dt> <dd>
<p>See if pointers from function parameters, mutable globals, or uplevel functions could leak into return value. </p>
<dl>
<dt>Returns:</dt>
<dd>true if the function return value is isolated from any inputs to the function</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.isTypeIsolated">final bool <strong id="isTypeIsolated">isTypeIsolated</strong>(Type t); </dt> <dd>
<p>See if pointers from function parameters, mutable globals, or uplevel functions could leak into type <code>t</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>t</code>
</td> <td>type to check if it is isolated</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if <code>t</code> is isolated from any inputs to the function</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.isNested">const bool <strong id="isNested">isNested</strong>(); </dt> <dd>
<p>Determine if function needs a static frame pointer. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if function is really nested within other function. </dd>
</dl> <dl>
<dt>Contracts</dt>
<dd> If isNested() returns true, isThis() should return false, unless the function needs a dual-context pointer.</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.isThis">inout inout(AggregateDeclaration) <strong id="isThis">isThis</strong>(); </dt> <dd>
<p>Determine if function is a non-static member function that has an implicit 'this' expression. </p>
<dl>
<dt>Returns:</dt>
<dd>The aggregate it is a member of, or null. </dd>
</dl> <dl>
<dt>Contracts</dt>
<dd> Both isThis() and isNested() should return true if function needs a dual-context pointer, otherwise if isThis() returns true, isNested() should return false.</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.isUnique">final bool <strong id="isUnique">isUnique</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>true if there are no overloads of this function</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.checkNestedReference">final bool <strong id="checkNestedReference">checkNestedReference</strong>(Scope* sc, ref const Loc loc); </dt> <dd>
<p>In the current function, we are calling 'this' function. 1. Check to see if the current function can call 'this' function, issue error if not. 2. If the current function is not the parent of 'this' function, then add the current function to the list of siblings of 'this' function. 3. If the current function is a literal, and it's accessing an uplevel scope, then mark it as a delegate. Returns true if error occurs.</p> </dd> <dt class="d_decl" id="FuncDeclaration.needsClosure">final bool <strong id="needsClosure">needsClosure</strong>(); </dt> <dd>
<p>Look at all the variables in this function that are referenced by nested functions, and determine if a closure needs to be created for them.</p> </dd> <dt class="d_decl" id="FuncDeclaration.checkClosure">final bool <strong id="checkClosure">checkClosure</strong>(); </dt> <dd>
<p>Check that the function contains any closure. If it's @nogc, report suitable errors. This is mostly consistent with FuncDeclaration::needsClosure(). </p>
<dl>
<dt>Returns:</dt>
<dd>true if any errors occur.</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.hasNestedFrameRefs">final bool <strong id="hasNestedFrameRefs">hasNestedFrameRefs</strong>(); </dt> <dd>
<p>Determine if function's variables are referenced by a function nested within it.</p> </dd> <dt class="d_decl" id="FuncDeclaration.buildResultVar">final void <strong id="buildResultVar">buildResultVar</strong>(Scope* sc, Type tret); </dt> <dd>
<p>Declare result variable lazily.</p> </dd> <dt class="d_decl" id="FuncDeclaration.mergeFrequire">final Statement <strong id="mergeFrequire">mergeFrequire</strong>(Statement sf, Expressions* params); </dt> <dd>
<p>Merge into this function the 'in' contracts of all it overrides. 'in's are OR'd together, i.e. only one of them needs to pass.</p> </dd> <dt class="d_decl" id="FuncDeclaration.needsFensure">static bool <strong id="needsFensure">needsFensure</strong>(FuncDeclaration fd); </dt> <dd>
<p>Determine whether an 'out' contract is declared inside the given function or any of its overrides. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>FuncDeclaration <code>fd</code>
</td> <td>the function to search</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true found an 'out' contract</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.buildEnsureRequire">final void <strong id="buildEnsureRequire">buildEnsureRequire</strong>(); </dt> <dd>
<p>Rewrite contracts as statements.</p> </dd> <dt class="d_decl" id="FuncDeclaration.mergeFensure">final Statement <strong id="mergeFensure">mergeFensure</strong>(Statement sf, Identifier oid, Expressions* params); </dt> <dd>
<p>Merge into this function the 'out' contracts of all it overrides. 'out's are AND'd together, i.e. all of them need to pass.</p> </dd> <dt class="d_decl" id="FuncDeclaration.getParameterList">final ParameterList <strong id="getParameterList">getParameterList</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>the function's parameter list, and whether it is variadic or not.</dd>
</dl> </dd> <dt class="d_decl" id="FuncDeclaration.genCfunc">static FuncDeclaration <strong id="genCfunc">genCfunc</strong>(Parameters* fparams, Type treturn, const(char)* name, StorageClass stc = 0); </dt> <dd>
<p>Generate a FuncDeclaration for a runtime library function.</p> </dd> <dt class="d_decl" id="FuncDeclaration.checkDmain">final void <strong id="checkDmain">checkDmain</strong>(); </dt> <dd>
<p>Check parameters and return type of D main() function. Issue error messages.</p> </dd> </dl> </dd> <dt class="d_decl" id="addInvariant">Expression <strong id="addInvariant">addInvariant</strong>(ref const Loc loc, Scope* sc, AggregateDeclaration ad, VarDeclaration vthis); </dt> <dd>
<p>Generate Expression to call the invariant. </p>
<dl>
<dt>Input</dt>
<dd> ad aggregate with the invariant vthis variable with 'this' </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>void expression that calls the invariant</dd>
</dl> </dd> <dt class="d_decl" id="overloadApply">int <strong id="overloadApply">overloadApply</strong>(Dsymbol fstart, scope int delegate(Dsymbol) dg, Scope* sc = null); </dt> <dd>
<p>Visit each overloaded function/template in turn, and call dg(s) on it. Exit when no more, or dg(s) returns nonzero. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Dsymbol <code>fstart</code>
</td> <td>symbol to start from</td>
</tr> <tr>
<td>int delegate(Dsymbol) <code>dg</code>
</td> <td>the delegate to be called on the overload</td>
</tr> <tr>
<td>Scope* <code>sc</code>
</td> <td>context used to check if symbol is accessible (and therefore visible), can be null</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>==0 continue !=0 done (and the return value from the last dg() call)</dd>
</dl> </dd> <dt class="d_decl" id="MODMatchToBuffer">auto <strong id="MODMatchToBuffer">MODMatchToBuffer</strong>(OutBuffer* buf, ubyte lhsMod, ubyte rhsMod); </dt> <dd>
<p>Checks for mismatching modifiers between <code>lhsMod</code> and <code>rhsMod</code> and prints the mismatching modifiers to <code>buf</code>. </p>
<p>The modifiers of the <code>lhsMod</code> mismatching the ones with the <code>rhsMod</code> are printed, i.e. lhs(shared) vs. rhs() prints "<code>shared</code>", wheras lhs() vs rhs(shared) prints "non-shared". </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>OutBuffer* <code>buf</code>
</td> <td>output buffer to write to</td>
</tr> <tr>
<td>ubyte <code>lhsMod</code>
</td> <td>modifier on the left-hand side</td>
</tr> <tr>
<td>ubyte <code>lhsMod</code>
</td> <td>modifier on the right-hand side</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A tuple with <code>isMutable</code> and <code>isNotShared</code> set if the <code>lhsMod</code> is missing those modifiers (compared to rhs).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">OutBuffer buf;
auto mismatches = MODMatchToBuffer(&amp;buf, MODFlags.shared_, 0);
assert(buf.peekSlice == "`shared` ");
assert(!mismatches.isNotShared);

buf.reset;
mismatches = MODMatchToBuffer(&amp;buf, 0, MODFlags.shared_);
assert(buf.peekSlice == "non-shared ");
assert(mismatches.isNotShared);

buf.reset;
mismatches = MODMatchToBuffer(&amp;buf, MODFlags.const_, 0);
assert(buf.peekSlice == "`const` ");
assert(!mismatches.isMutable);

buf.reset;
mismatches = MODMatchToBuffer(&amp;buf, 0, MODFlags.const_);
assert(buf.peekSlice == "mutable ");
assert(mismatches.isMutable);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="FuncResolveFlag">enum <strong id="FuncResolveFlag">FuncResolveFlag</strong>: ubyte; </dt> <dd>
<p>Flag used by <a href="#resolveFuncCall"><code>resolveFuncCall</code></a>.</p> <dl>
<dt class="d_decl" id="FuncResolveFlag.standard"><strong id="standard">standard</strong></dt> <dd>
<p>issue error messages, solve the call.</p> </dd> <dt class="d_decl" id="FuncResolveFlag.quiet"><strong id="quiet">quiet</strong></dt> <dd>
<p>do not issue error message on no match, just return <code>null</code>.</p> </dd> <dt class="d_decl" id="FuncResolveFlag.overloadOnly"><strong id="overloadOnly">overloadOnly</strong></dt> <dd>
<p>only resolve overloads.</p> </dd> </dl> </dd> <dt class="d_decl" id="resolveFuncCall">FuncDeclaration <strong id="resolveFuncCall">resolveFuncCall</strong>(ref const Loc loc, Scope* sc, Dsymbol s, Objects* tiargs, Type tthis, Expressions* fargs, FuncResolveFlag flags); </dt> <dd>
<p>Given a symbol that could be either a FuncDeclaration or a function template, resolve it to a function symbol. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Loc <code>loc</code>
</td> <td>instantiation location</td>
</tr> <tr>
<td>Scope* <code>sc</code>
</td> <td>instantiation scope</td>
</tr> <tr>
<td>Dsymbol <code>s</code>
</td> <td>instantiation symbol</td>
</tr> <tr>
<td>Objects* <code>tiargs</code>
</td> <td>initial list of template arguments</td>
</tr> <tr>
<td>Type <code>tthis</code>
</td> <td>if !NULL, the <code>this</code> argument type</td>
</tr> <tr>
<td>Expressions* <code>fargs</code>
</td> <td>arguments to function</td>
</tr> <tr>
<td>FuncResolveFlag <code>flags</code>
</td> <td>see <a href="#FuncResolveFlag"><code>FuncResolveFlag</code></a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>if match is found, then function symbol, else null</dd>
</dl> </dd> <dt class="d_decl" id="getIndirection">Type <strong id="getIndirection">getIndirection</strong>(Type t); </dt> <dd>
<p>Returns an indirect type one step from t.</p> </dd> <dt class="d_decl" id="followInstantiationContext">bool <strong id="followInstantiationContext">followInstantiationContext</strong>(D...)(Dsymbol s, D p); </dt> <dd>
<p>Returns true if any of the symbols <code>p</code> resides in the enclosing instantiation scope of <code>s</code>.</p> </dd> <dt class="d_decl" id="FuncAliasDeclaration">class <strong id="FuncAliasDeclaration">FuncAliasDeclaration</strong>: dmd.func.FuncDeclaration; </dt> <dd>
<p>Used as a way to import a set of functions from another scope into this one.</p> </dd> <dt class="d_decl" id="FuncLiteralDeclaration">class <strong id="FuncLiteralDeclaration">FuncLiteralDeclaration</strong>: dmd.func.FuncDeclaration; </dt> <dd> <dl>
<dt class="d_decl" id="FuncLiteralDeclaration.modifyReturns">void <strong id="modifyReturns">modifyReturns</strong>(Scope* sc, Type tret); </dt> <dd>
<p>Modify all expression type of return statements to tret. </p>
<p>On function literals, return type may be modified based on the context type after its semantic3 is done, in FuncExp::implicitCastTo. <br><br> A function() dg = (){ return new B(); } // OK if is(B : A) == true <br><br> If B to A conversion is convariant that requires offseet adjusting, all return statements should be adjusted to return expressions typed A.</p> </dd> </dl> </dd> <dt class="d_decl" id="CtorDeclaration">class <strong id="CtorDeclaration">CtorDeclaration</strong>: dmd.func.FuncDeclaration; </dt>  <dt class="d_decl" id="PostBlitDeclaration">class <strong id="PostBlitDeclaration">PostBlitDeclaration</strong>: dmd.func.FuncDeclaration; </dt>  <dt class="d_decl" id="DtorDeclaration">class <strong id="DtorDeclaration">DtorDeclaration</strong>: dmd.func.FuncDeclaration; </dt>  <dt class="d_decl" id="StaticCtorDeclaration">class <strong id="StaticCtorDeclaration">StaticCtorDeclaration</strong>: dmd.func.FuncDeclaration; </dt>  <dt class="d_decl" id="SharedStaticCtorDeclaration">class <strong id="SharedStaticCtorDeclaration">SharedStaticCtorDeclaration</strong>: dmd.func.StaticCtorDeclaration; </dt>  <dt class="d_decl" id="StaticDtorDeclaration">class <strong id="StaticDtorDeclaration">StaticDtorDeclaration</strong>: dmd.func.FuncDeclaration; </dt>  <dt class="d_decl" id="SharedStaticDtorDeclaration">class <strong id="SharedStaticDtorDeclaration">SharedStaticDtorDeclaration</strong>: dmd.func.StaticDtorDeclaration; </dt>  <dt class="d_decl" id="InvariantDeclaration">class <strong id="InvariantDeclaration">InvariantDeclaration</strong>: dmd.func.FuncDeclaration; </dt>  <dt class="d_decl" id="UnitTestDeclaration">class <strong id="UnitTestDeclaration">UnitTestDeclaration</strong>: dmd.func.FuncDeclaration; </dt>  <dt class="d_decl" id="NewDeclaration">class <strong id="NewDeclaration">NewDeclaration</strong>: dmd.func.FuncDeclaration; </dt>  <dt class="d_decl" id="DeleteDeclaration">class <strong id="DeleteDeclaration">DeleteDeclaration</strong>: dmd.func.FuncDeclaration; </dt>  </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/dmd_func.html" class="_attribution-link">https://dlang.org/phobos/dmd_func.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
