
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std.functional - D - W3cubDocs</title>
  
  <meta name="description" content=" Functions that manipulate other functions. ">
  <meta name="keywords" content="std, functional, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/std_functional.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>std.functional</h1>  <p>Functions that manipulate other functions. </p>
<p>This module provides functions for compile time function composition. These functions are helpful when constructing predicates for the algorithms in <a href="std_algorithm"><code>std.algorithm</code></a> or <a href="std_range"><code>std.range</code></a>. <br><br>  </p>
<table>

<tr>
<th scope="col">Function Name</th> <th scope="col">Description</th> </tr> <tr>
<td><a href="#adjoin"><code>adjoin</code></a></td> <td>Joins a couple of functions into one that executes the original functions independently and returns a tuple with all the results. </td>
</tr> <tr>
<td>
<a href="#compose"><code>compose</code></a>, <a href="#pipe"><code>pipe</code></a>
</td> <td>Join a couple of functions into one that executes the original functions one after the other, using one function's result for the next function's argument. </td>
</tr> <tr>
<td><a href="#forward"><code>forward</code></a></td> <td>Forwards function arguments while saving ref-ness. </td>
</tr> <tr>
<td>
<a href="#lessThan"><code>lessThan</code></a>, <a href="#greaterThan"><code>greaterThan</code></a>, <a href="#equalTo"><code>equalTo</code></a>
</td> <td>Ready-made predicate functions to compare two values. </td>
</tr> <tr>
<td><a href="#memoize"><code>memoize</code></a></td> <td>Creates a function that caches its result for fast re-evaluation. </td>
</tr> <tr>
<td><a href="#not"><code>not</code></a></td> <td>Creates a function that negates another. </td>
</tr> <tr>
<td><a href="#partial"><code>partial</code></a></td> <td>Creates a function that binds the first argument of a given function to a given value. </td>
</tr> <tr>
<td><a href="#reverseArgs"><code>reverseArgs</code></a></td> <td>Predicate that reverses the order of its arguments. </td>
</tr> <tr>
<td><a href="#toDelegate"><code>toDelegate</code></a></td> <td>Converts a callable to a delegate. </td>
</tr> <tr>
<td>
<a href="#unaryFun"><code>unaryFun</code></a>, <a href="#binaryFun"><code>binaryFun</code></a>
</td> <td>Create a unary or binary function from a string. Most often used when defining algorithms on ranges. </td>
</tr> </table>  <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.org">Andrei Alexandrescu</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/functional.d">std/functional.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="unaryFun">template <strong id="unaryFun">unaryFun</strong>(alias fun, string parmName = "a")</dt> <dd>
<p>Transforms a <code>string</code> representing an expression into a unary function. The <code>string</code> must either use symbol name <code>a</code> as the parameter or provide the symbol via the <code>parmName</code> argument. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>fun</td> <td>a <code>string</code> or a callable</td>
</tr> <tr>
<td>parmName</td> <td>the name of the parameter if <code>fun</code> is a string. Defaults to <code>"a"</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>If <code>fun</code> is a <code>string</code>, a new single parameter function  If <code>fun</code> is not a <code>string</code>, an alias to <code>fun</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Strings are compiled into functions:
alias isEven = unaryFun!("(a &amp; 1) == 0");
assert(isEven(2) &amp;&amp; !isEven(1));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="binaryFun">template <strong id="binaryFun">binaryFun</strong>(alias fun, string parm1Name = "a", string parm2Name = "b")</dt> <dd>
<p>Transforms a <code>string</code> representing an expression into a binary function. The <code>string</code> must either use symbol names <code>a</code> and <code>b</code> as the parameters or provide the symbols via the <code>parm1Name</code> and <code>parm2Name</code> arguments. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>fun</td> <td>a <code>string</code> or a callable</td>
</tr> <tr>
<td>parm1Name</td> <td>the name of the first parameter if <code>fun</code> is a string. Defaults to <code>"a"</code>.</td>
</tr> <tr>
<td>parm2Name</td> <td>the name of the second parameter if <code>fun</code> is a string. Defaults to <code>"b"</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>If <code>fun</code> is not a string, <code>binaryFun</code> aliases itself away to <code>fun</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias less = binaryFun!("a &lt; b");
assert(less(1, 2) &amp;&amp; !less(2, 1));
alias greater = binaryFun!("a &gt; b");
assert(!greater("1", "2") &amp;&amp; greater("2", "1"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="lessThan">alias <strong id="lessThan">lessThan</strong> = safeOp!"&lt;".safeOp(T0, T1)(auto ref T0 a, auto ref T1 b); </dt> <dd>
<p>Predicate that returns <span class="d_param">a &lt; b</span>. Correctly compares signed and unsigned integers, ie. -1 &lt; 2U.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(lessThan(2, 3));
assert(lessThan(2U, 3U));
assert(lessThan(2, 3.0));
assert(lessThan(-2, 3U));
assert(lessThan(2, 3U));
assert(!lessThan(3U, -2));
assert(!lessThan(3U, 2));
assert(!lessThan(0, 0));
assert(!lessThan(0U, 0));
assert(!lessThan(0, 0U));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="greaterThan">alias <strong id="greaterThan">greaterThan</strong> = safeOp!"&gt;".safeOp(T0, T1)(auto ref T0 a, auto ref T1 b); </dt> <dd>
<p>Predicate that returns <span class="d_param">a &gt; b</span>. Correctly compares signed and unsigned integers, ie. 2U &gt; -1.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(!greaterThan(2, 3));
assert(!greaterThan(2U, 3U));
assert(!greaterThan(2, 3.0));
assert(!greaterThan(-2, 3U));
assert(!greaterThan(2, 3U));
assert(greaterThan(3U, -2));
assert(greaterThan(3U, 2));
assert(!greaterThan(0, 0));
assert(!greaterThan(0U, 0));
assert(!greaterThan(0, 0U));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="equalTo">alias <strong id="equalTo">equalTo</strong> = safeOp!"==".safeOp(T0, T1)(auto ref T0 a, auto ref T1 b); </dt> <dd>
<p>Predicate that returns <span class="d_param">a == b</span>. Correctly compares signed and unsigned integers, ie. !(-1 == ~0U).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(equalTo(0U, 0));
assert(equalTo(0, 0U));
assert(!equalTo(-1, ~0U));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="reverseArgs">template <strong id="reverseArgs">reverseArgs</strong>(alias pred)</dt> <dd>
<p>N-ary predicate that reverses the order of arguments, e.g., given <code>pred(a, b, c)</code>, returns <code>pred(c, b, a)</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>A callable</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A function which calls <code>pred</code> after reversing the given parameters</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias gt = reverseArgs!(binaryFun!("a &lt; b"));
assert(gt(2, 1) &amp;&amp; !gt(1, 1));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int x = 42;
bool xyz(int a, int b) { return a * x &lt; b / x; }
auto foo = &amp;xyz;
foo(4, 5);
alias zyx = reverseArgs!(foo);
writeln(zyx(5, 4)); // foo(4, 5)
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias gt = reverseArgs!(binaryFun!("a &lt; b"));
assert(gt(2, 1) &amp;&amp; !gt(1, 1));
int x = 42;
bool xyz(int a, int b) { return a * x &lt; b / x; }
auto foo = &amp;xyz;
foo(4, 5);
alias zyx = reverseArgs!(foo);
writeln(zyx(5, 4)); // foo(4, 5)
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int abc(int a, int b, int c) { return a * b + c; }
alias cba = reverseArgs!abc;
writeln(abc(91, 17, 32)); // cba(32, 17, 91)
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int a(int a) { return a * 2; }
alias _a = reverseArgs!a;
writeln(a(2)); // _a(2)
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int b() { return 4; }
alias _b = reverseArgs!b;
writeln(b()); // _b()
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="binaryReverseArgs">template <strong id="binaryReverseArgs">binaryReverseArgs</strong>(alias pred)</dt> <dd>
<p>Binary predicate that reverses the order of arguments, e.g., given <code>pred(a, b)</code>, returns <code>pred(b, a)</code>. </p>
<p><span class="red">DEPRECATED: Use <a href="#reverseArgs"><code>reverseArgs</code></a></span> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>A callable</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A function which calls <code>pred</code> after reversing the given parameters</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias gt = binaryReverseArgs!(binaryFun!("a &lt; b"));
assert(gt(2, 1) &amp;&amp; !gt(1, 1));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int x = 42;
bool xyz(int a, int b) { return a * x &lt; b / x; }
auto foo = &amp;xyz;
foo(4, 5);
alias zyx = binaryReverseArgs!(foo);
writeln(zyx(5, 4)); // foo(4, 5)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="not">template <strong id="not">not</strong>(alias pred)</dt> <dd>
<p>Negates predicate <code>pred</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>A string or a callable</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A function which calls <code>pred</code> and returns the logical negation of its return value.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.searching : find;
import std.functional;
import std.uni : isWhite;
string a = "   Hello, world!";
writeln(find!(not!isWhite)(a)); // "Hello, world!"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="partial">template <strong id="partial">partial</strong>(alias fun, alias arg)</dt> <dd>
<p><a href="http://en.wikipedia.org/wiki/Partial_application">Partially applies</a> <span class="d_param">fun</span> by tying its first argument to <span class="d_param">arg</span>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>fun</td> <td>A callable</td>
</tr> <tr>
<td>arg</td> <td>The first argument to apply to <code>fun</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new function which calls <code>fun</code> with <code>arg</code> plus the passed parameters.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int fun(int a, int b) { return a + b; }
alias fun5 = partial!(fun, 5);
writeln(fun5(6)); // 11
// Note that in most cases you'd use an alias instead of a value
// assignment. Using an alias allows you to partially evaluate template
// functions without committing to a particular type of the function.
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="adjoin">template <strong id="adjoin">adjoin</strong>(F...) if (F.length == 1)<br><br>template <strong id="adjoin">adjoin</strong>(F...) if (F.length &gt; 1)</dt> <dd>
<p>Takes multiple functions and adjoins them together. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>F</td> <td>the call-able(s) to adjoin</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new function which returns a <a href="std_typecons#Tuple"><code>std.typecons.Tuple</code></a>. Each of the elements of the tuple will be the return values of <code>F</code>. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> In the special case where only a single function is provided (<code>F.length == 1</code>), adjoin simply aliases to the single passed function (<code>F[0]</code>).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.functional, std.typecons : Tuple;
static bool f1(int a) { return a != 0; }
static int f2(int a) { return a / 2; }
auto x = adjoin!(f1, f2)(5);
assert(is(typeof(x) == Tuple!(bool, int)));
assert(x[0] == true &amp;&amp; x[1] == 2);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="compose">template <strong id="compose">compose</strong>(fun...)</dt> <dd>
<p>Composes passed-in functions <code>fun[0], fun[1], ...</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>fun</td> <td>the call-able(s) or <code>string</code>(s) to compose into one function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new function <code>f(x)</code> that in turn returns <code>fun[0](fun[1](...(x)))...</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#pipe"><code>pipe</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : map;
import std.array : split;
import std.conv : to;

// First split a string in whitespace-separated tokens and then
// convert each token into an integer
assert(compose!(map!(to!(int)), split)("1 2 3").equal([1, 2, 3]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="pipe">template <strong id="pipe">pipe</strong>(fun...)</dt> <dd>
<p>Pipes functions in sequence. Offers the same functionality as <code> compose</code>, but with functions specified in reverse order. This may lead to more readable code in some situation because the order of execution is the same as lexical order. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>fun</td> <td>the call-able(s) or <code>string</code>(s) to compose into one function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new function <code>f(x)</code> that in turn returns <code>fun[$-1](...fun[1](fun[0](x)))...</code>. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Read an entire text file, split the resulting string in
// whitespace-separated tokens, and then convert each token into an
// integer
int[] a = pipe!(readText, split, map!(to!(int)))("file.txt");
</pre>  <dl>
<dt>See Also:</dt>
<dd><a href="#compose"><code>compose</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : to;
string foo(int a) { return to!(string)(a); }
int bar(string a) { return to!(int)(a) + 1; }
double baz(int a) { return a + 0.5; }
writeln(compose!(baz, bar, foo)(1)); // 2.5
writeln(pipe!(foo, bar, baz)(1)); // 2.5

writeln(compose!(baz, `to!(int)(a) + 1`, foo)(1)); // 2.5
writeln(compose!(baz, bar)("1"[])); // 2.5

writeln(compose!(baz, bar)("1")); // 2.5

writeln(compose!(`a + 0.5`, `to!(int)(a) + 1`, foo)(1)); // 2.5
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="memoize">ReturnType!fun <strong id="memoize">memoize</strong>(alias fun)(Parameters!fun args); <br><br>ReturnType!fun <strong id="memoize">memoize</strong>(alias fun, uint maxSize)(Parameters!fun args); </dt> <dd>
<p><a href="https://en.wikipedia.org/wiki/Memoization">Memoizes</a> a function so as to avoid repeated computation. The memoization structure is a hash table keyed by a tuple of the function's arguments. There is a speed gain if the function is repeatedly called with the same arguments and is more expensive than a hash table lookup. For more information on memoization, refer to <a href="http://docs.google.com/viewer?url=http%3A%2F%2Fhop.perl.plover.com%2Fbook%2Fpdf%2F03CachingAndMemoization.pdf">this book chapter</a>. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">double transmogrify(int a, string b)
{
   ... expensive computation ...
}
alias fastTransmogrify = memoize!transmogrify;
unittest
{
    auto slow = transmogrify(2, "hello");
    auto fast = fastTransmogrify(2, "hello");
    assert(slow == fast);
}
</pre>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>fun</td> <td>the call-able to memozie</td>
</tr> <tr>
<td>maxSize</td> <td>The maximum size of the GC buffer to hold the return values</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new function which calls <code>fun</code> and caches its return values. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> Technically the memoized function should be pure because <code>memoize</code> assumes it will always return the same result for a given tuple of arguments. However, <code>memoize</code> does not enforce that because sometimes it is useful to memoize an impure function, too.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>To memoize a recursive function, simply insert the memoized call in lieu of the plain recursive call. For example, to transform the exponential-time Fibonacci implementation into a linear-time computation: <pre data-language="d">ulong fib(ulong n) @safe
{
    return n &lt; 2 ? n : memoize!fib(n - 2) + memoize!fib(n - 1);
}
writeln(fib(10)); // 55
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>To improve the speed of the factorial function, <pre data-language="d">ulong fact(ulong n) @safe
{
    return n &lt; 2 ? 1 : n * memoize!fact(n - 1);
}
writeln(fact(10)); // 3628800
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>This memoizes all values of <code>fact</code> up to the largest argument. To only cache the final result, move <code>memoize</code> outside the function as shown below. <pre data-language="d">ulong factImpl(ulong n) @safe
{
    return n &lt; 2 ? 1 : n * factImpl(n - 1);
}
alias fact = memoize!factImpl;
writeln(fact(10)); // 3628800
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>When the <code>maxSize</code> parameter is specified, memoize will used a fixed size hash table to limit the number of cached entries. <pre data-language="d">ulong fact(ulong n)
{
    // Memoize no more than 8 values
    return n &lt; 2 ? 1 : n * memoize!(fact, 8)(n - 1);
}
writeln(fact(8)); // 40320
// using more entries than maxSize will overwrite existing entries
writeln(fact(10)); // 3628800
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toDelegate">auto <strong id="toDelegate">toDelegate</strong>(F)(auto ref F fp)<br><small>  Constraints: if (isCallable!F); </small>
</dt> <dd>
<p>Convert a callable to a delegate with the same parameter list and return type, avoiding heap allocations and use of auxiliary storage. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>F <code>fp</code>
</td> <td>a function pointer or an aggregate type with <code>opCall</code> defined.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A delegate with the context pointer pointing to nothing. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">void doStuff() {
    writeln("Hello, world.");
}

void runDelegate(void delegate() myDelegate) {
    myDelegate();
}

auto delegateToPass = toDelegate(&amp;doStuff);
runDelegate(delegateToPass);  // Calls doStuff, prints "Hello, world."
</pre>  <dl>
<dt>Bugs:</dt>
<dd><ul> <li>Does not work with <code>@safe</code> functions.</li> <li>Ignores C-style / D-style variadic arguments.</li> </ul></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static int inc(ref uint num) {
    num++;
    return 8675309;
}

uint myNum = 0;
auto incMyNumDel = toDelegate(&amp;inc);
auto returnVal = incMyNumDel(myNum);
writeln(myNum); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="forward">template <strong id="forward">forward</strong>(args...)</dt> <dd>
<p>Forwards function arguments while keeping <code>out</code>, <code>ref</code>, and <code>lazy</code> on the parameters. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>args</td> <td>a parameter list or an <a href="std_meta#AliasSeq"><code>std.meta.AliasSeq</code></a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An <code>AliasSeq</code> of <code>args</code> with <code>out</code>, <code>ref</code>, and <code>lazy</code> saved.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C
{
    static int foo(int n) { return 1; }
    static int foo(ref int n) { return 2; }
}

// with forward
int bar()(auto ref int x) { return C.foo(forward!x); }

// without forward
int baz()(auto ref int x) { return C.foo(x); }

int i;
writeln(bar(1)); // 1
writeln(bar(i)); // 2

writeln(baz(1)); // 2
writeln(baz(i)); // 2
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void foo(int n, ref string s) { s = null; foreach (i; 0 .. n) s ~= "Hello"; }

// forwards all arguments which are bound to parameter tuple
void bar(Args...)(auto ref Args args) { return foo(forward!args); }

// forwards all arguments with swapping order
void baz(Args...)(auto ref Args args) { return foo(forward!args[$/2..$], forward!args[0..$/2]); }

string s;
bar(1, s);
writeln(s); // "Hello"
baz(s, 2);
writeln(s); // "HelloHello"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct X {
    int i;
    this(this)
    {
        ++i;
    }
}

struct Y
{
    private X x_;
    this()(auto ref X x)
    {
        x_ = forward!x;
    }
}

struct Z
{
    private const X x_;
    this()(auto ref X x)
    {
        x_ = forward!x;
    }
    this()(auto const ref X x)
    {
        x_ = forward!x;
    }
}

X x;
const X cx;
auto constX = (){ const X x; return x; };
static assert(__traits(compiles, { Y y = x; }));
static assert(__traits(compiles, { Y y = X(); }));
static assert(!__traits(compiles, { Y y = cx; }));
static assert(!__traits(compiles, { Y y = constX(); }));
static assert(__traits(compiles, { Z z = x; }));
static assert(__traits(compiles, { Z z = X(); }));
static assert(__traits(compiles, { Z z = cx; }));
static assert(__traits(compiles, { Z z = constX(); }));


Y y1 = x;
// ref lvalue, copy
writeln(y1.x_.i); // 1
Y y2 = X();
// rvalue, move
writeln(y2.x_.i); // 0

Z z1 = x;
// ref lvalue, copy
writeln(z1.x_.i); // 1
Z z2 = X();
// rvalue, move
writeln(z2.x_.i); // 0
Z z3 = cx;
// ref const lvalue, copy
writeln(z3.x_.i); // 1
Z z4 = constX();
// const rvalue, copy
writeln(z4.x_.i); // 1
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_functional.html" class="_attribution-link">https://dlang.org/phobos/std_functional.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
