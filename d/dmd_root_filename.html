
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>dmd.root.filename - D - W3cubDocs</title>
  
  <meta name="description" content=" Compiler implementation of the D programming language http&#58;&#47;&#47;dlang.org ">
  <meta name="keywords" content="dmd, root, filename, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/dmd_root_filename.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>dmd.root.filename</h1>  <p>Compiler implementation of the D programming language <a href="http://dlang.org">http://dlang.org</a> </p>
<dl>
<dt>Authors:</dt>
<dd>Walter Bright, <a href="http://www.digitalmars.com">http://www.digitalmars.com</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/dmd/blob/master/src/dmd/root/filename.d">root/filename.d</a> </dd>
</dl> <dl>
<dt>Documentation</dt>
<dd> <a href="dmd_root_filename">https://dlang.org/phobos/dmd_root_filename.html</a> </dd>
</dl> <dl>
<dt>Coverage</dt>
<dd> <a href="https://codecov.io/gh/dlang/dmd/src/master/src/dmd/root/filename.d">https://codecov.io/gh/dlang/dmd/src/master/src/dmd/root/filename.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="FileName">struct <strong id="FileName">FileName</strong>; </dt> <dd>
<p>Encapsulate path and file names.</p> <dl>
<dt class="d_decl" id="FileName.this">pure nothrow this(const(char)[] str); </dt>  <dt class="d_decl" id="FileName.equals">static pure nothrow @nogc bool <strong id="equals">equals</strong>(const(char)* name1, const(char)* name2); <br><br>static pure nothrow @nogc bool <strong id="equals">equals</strong>(const(char)[] name1, const(char)[] name2); </dt> <dd>
<p>Compare two name according to the platform's rules (case sensitive or not)</p> </dd> <dt class="d_decl" id="FileName.absolute">static pure nothrow @nogc bool <strong id="absolute">absolute</strong>(const(char)* name); <br><br>static pure nothrow @nogc bool <strong id="absolute">absolute</strong>(const(char)[] name); </dt> <dd>
<p>Determine if path is absolute. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)* <code>name</code>
</td> <td>path</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if absolute path name.</dd>
</dl> </dd> <dt class="d_decl" id="FileName.toAbsolute">static nothrow const(char)* <strong id="toAbsolute">toAbsolute</strong>(const(char)* name, const(char)* base = null); </dt> <dd>
<p>Return the given name as an absolute path </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)* <code>name</code>
</td> <td>path</td>
</tr> <tr>
<td>const(char)* <code>base</code>
</td> <td>the absolute base to prefix name with if it is relative</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>name as an absolute path relative to base</dd>
</dl> </dd> <dt class="d_decl" id="FileName.ext">static pure nothrow @nogc const(char)* <strong id="ext">ext</strong>(const(char)* str); <br><br>static pure nothrow @nogc @safe const(char)[] <strong id="ext">ext</strong>(const(char)[] str); </dt> <dd>
<p>Determine file name extension as slice of input. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)* <code>str</code>
</td> <td>file name</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>filename extension (read-only). Points past '.' of extension. If there isn't one, return null.</dd>
</dl> </dd> <dt class="d_decl" id="FileName.removeExt">static nothrow const(char)* <strong id="removeExt">removeExt</strong>(const(char)* str); <br><br>static nothrow const(char)[] <strong id="removeExt">removeExt</strong>(const(char)[] str); </dt> <dd>
<p>Return file name without extension. </p>
<dl>
<dt>TODO</dt>
<dd> Once slice are used everywhere and <code>\0</code> is not assumed, this can be turned into a simple slicing. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)* <code>str</code>
</td> <td>file name</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>mem.xmalloc'd filename with extension removed.</dd>
</dl> </dd> <dt class="d_decl" id="FileName.name">static pure nothrow @nogc const(char)* <strong id="name">name</strong>(const(char)* str); <br><br>static pure nothrow @nogc const(char)[] <strong id="name">name</strong>(const(char)[] str); </dt> <dd>
<p>Return filename name excluding path (read-only).</p> </dd> <dt class="d_decl" id="FileName.path">static nothrow const(char)* <strong id="path">path</strong>(const(char)* str); <br><br>static nothrow const(char)[] <strong id="path">path</strong>(const(char)[] str); </dt> <dd>
<p>Return path portion of str. returned string is newly allocated Path does not include trailing path separator.</p> </dd> <dt class="d_decl" id="FileName.replaceName">static nothrow const(char)[] <strong id="replaceName">replaceName</strong>(const(char)[] path, const(char)[] name); </dt> <dd>
<p>Replace filename portion of path.</p> </dd> <dt class="d_decl" id="FileName.combine">static nothrow const(char)* <strong id="combine">combine</strong>(const(char)* path, const(char)* name); <br><br>static nothrow const(char)[] <strong id="combine">combine</strong>(const(char)[] path, const(char)[] name); </dt> <dd>
<p>Combine a <code>path</code> and a file <code>name</code> </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)* <code>path</code>
</td> <td>Path to append to</td>
</tr> <tr>
<td>const(char)* <code>name</code>
</td> <td>Name to append to path</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The <code>\0</code> terminated string which is the combination of <code>path</code> and <code>name</code> and a valid path.</dd>
</dl> </dd> <dt class="d_decl" id="FileName.splitPath">static nothrow void <strong id="splitPath">splitPath</strong>(int delegate(const(char)*) nothrow sink, const(char)* path); </dt> <dd>
<p>Split path (such as that returned by <code>getenv("PATH")</code>) into pieces, each piece is mem.xmalloc'd Handle double quotes and ~. Pass the pieces to sink() </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int delegate(const(char)*) nothrow <code>sink</code>
</td> <td>send the path pieces here, end when sink() returns !=0</td>
</tr> <tr>
<td>const(char)* <code>path</code>
</td> <td>the path to split up.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="FileName.addExt">static pure nothrow char[] <strong id="addExt">addExt</strong>(const(char)[] name, const(char)[] ext); </dt> <dd>
<p>Add the extension <code>ext</code> to <code>name</code>, regardless of the content of <code>name</code> </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>name</code>
</td> <td>Path to append the extension to</td>
</tr> <tr>
<td>const(char)[] <code>ext</code>
</td> <td>Extension to add (should not include '.')</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A newly allocated string (free with <code>FileName.free</code>)</dd>
</dl> </dd> <dt class="d_decl" id="FileName.defaultExt">static nothrow const(char)* <strong id="defaultExt">defaultExt</strong>(const(char)* name, const(char)* ext); <br><br>static nothrow const(char)[] <strong id="defaultExt">defaultExt</strong>(const(char)[] name, const(char)[] ext); </dt> <dd>
<p>Free returned value with FileName::free()</p> </dd> <dt class="d_decl" id="FileName.forceExt">static nothrow const(char)* <strong id="forceExt">forceExt</strong>(const(char)* name, const(char)* ext); <br><br>static nothrow const(char)[] <strong id="forceExt">forceExt</strong>(const(char)[] name, const(char)[] ext); </dt> <dd>
<p>Free returned value with FileName::free()</p> </dd> <dt class="d_decl" id="FileName.equalsExt">static pure nothrow @nogc bool <strong id="equalsExt">equalsExt</strong>(const(char)* name, const(char)* ext); <br><br>static pure nothrow @nogc bool <strong id="equalsExt">equalsExt</strong>(const(char)[] name, const(char)[] ext); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>name</code>'s extension is <code>ext</code>
</dd>
</dl> </dd> <dt class="d_decl" id="FileName.equalsExt.2">const pure nothrow @nogc bool <strong id="equalsExt">equalsExt</strong>(const(char)* ext); </dt> <dd>
<p>Return !=0 if extensions match.</p> </dd> <dt class="d_decl" id="FileName.searchPath">static nothrow const(char)* <strong id="searchPath">searchPath</strong>(Strings* path, const(char)* name, bool cwd); </dt> <dd>
<p>Search paths for file. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Strings* <code>path</code>
</td> <td>array of path strings</td>
</tr> <tr>
<td>const(char)* <code>name</code>
</td> <td>file to look for</td>
</tr> <tr>
<td>bool <code>cwd</code>
</td> <td>true means search current directory before searching path</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>if found, filename combined with path, otherwise null</dd>
</dl> </dd> <dt class="d_decl" id="FileName.safeSearchPath">static nothrow const(char)* <strong id="safeSearchPath">safeSearchPath</strong>(Strings* path, const(char)* name); </dt> <dd>
<p>Search Path for file in a safe manner. </p>
<p>Be wary of CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') attacks. <a href="http://cwe.mitre.org/data/definitions/22.html">http://cwe.mitre.org/data/definitions/22.html</a> More info: <a href="https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources">https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources</a> </p> <dl>
<dt>Returns:</dt>
<dd>NULL file not found !=NULL mem.xmalloc'd file name</dd>
</dl> </dd> <dt class="d_decl" id="FileName.exists">static nothrow int <strong id="exists">exists</strong>(const(char)* name); <br><br>static nothrow int <strong id="exists">exists</strong>(const(char)[] name); </dt> <dd>
<p>Check if the file the <code>path</code> points to exists </p>
<dl>
<dt>Returns:</dt>
<dd>0 if it does not exists 1 if it exists and is not a directory 2 if it exists and is a directory</dd>
</dl> </dd> <dt class="d_decl" id="FileName.ensurePathExists">static nothrow bool <strong id="ensurePathExists">ensurePathExists</strong>(const(char)[] path); <br><br>static nothrow bool <strong id="ensurePathExists">ensurePathExists</strong>(const(char)* path); </dt> <dd>
<p>Ensure that the provided path exists </p>
<p>Accepts a path to either a file or a directory. In the former case, the basepath (path to the containing directory) will be checked for existence, and created if it does not exists. In the later case, the directory pointed to will be checked for existence and created if needed. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>path</code>
</td> <td>a path to a file or a directory</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the directory exists or was successfully created</dd>
</dl> </dd> <dt class="d_decl" id="FileName.canonicalName">static nothrow const(char)* <strong id="canonicalName">canonicalName</strong>(const(char)* name); <br><br>static nothrow const(char)[] <strong id="canonicalName">canonicalName</strong>(const(char)[] name); </dt> <dd>
<p>Return canonical version of name in a malloc'd buffer. This code is high risk.</p> </dd> <dt class="d_decl" id="FileName.free">static pure nothrow void <strong id="free">free</strong>(const(char)* str); </dt> <dd>
<p>Free memory allocated by FileName routines</p> </dd> </dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/dmd_root_filename.html" class="_attribution-link">https://dlang.org/phobos/dmd_root_filename.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
