
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>25. Traits - D - W3cubDocs</title>
  
  <meta name="description" content="Traits are extensions to the language to enable programs, at compile time, to get at information internal to the compiler. This is also known as &hellip;">
  <meta name="keywords" content="traits, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/traits.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>Traits</h1>       <b>Contents</b>  <ol> <li><a href="#isArithmetic">isArithmetic</a></li> <li><a href="#isFloating">isFloating</a></li> <li><a href="#isIntegral">isIntegral</a></li> <li><a href="#isScalar">isScalar</a></li> <li><a href="#isUnsigned">isUnsigned</a></li> <li><a href="#isStaticArray">isStaticArray</a></li> <li><a href="#isAssociativeArray">isAssociativeArray</a></li> <li><a href="#isAbstractClass">isAbstractClass</a></li> <li><a href="#isFinalClass">isFinalClass</a></li> <li><a href="#isPOD">isPOD</a></li> <li><a href="#isNested">isNested</a></li> <li><a href="#isFuture">isFuture</a></li> <li><a href="#isDeprecated">isDeprecated</a></li> <li><a href="#isDisabled">isDisabled</a></li> <li><a href="#isVirtualFunction">isVirtualFunction</a></li> <li><a href="#isVirtualMethod">isVirtualMethod</a></li> <li><a href="#isAbstractFunction">isAbstractFunction</a></li> <li><a href="#isFinalFunction">isFinalFunction</a></li> <li><a href="#isOverrideFunction">isOverrideFunction</a></li> <li><a href="#isStaticFunction">isStaticFunction</a></li> <li><a href="#isRef">isRef</a></li> <li><a href="#isTemplate">isTemplate</a></li> <li><a href="#isZeroInit">isZeroInit</a></li> <li><a href="#isReturnOnStack">isReturnOnStack</a></li> <li><a href="#isModule">isModule</a></li> <li><a href="#isPackage">isPackage</a></li> <li><a href="#hasMember">hasMember</a></li> <li><a href="#identifier">identifier</a></li> <li><a href="#getAliasThis">getAliasThis</a></li> <li><a href="#getAttributes">getAttributes</a></li> <li><a href="#getFunctionVariadicStyle">getFunctionVariadicStyle</a></li> <li><a href="#getFunctionAttributes">getFunctionAttributes</a></li> <li><a href="#getLinkage">getLinkage</a></li> <li><a href="#getLocation">getLocation</a></li> <li><a href="#getMember">getMember</a></li> <li><a href="#getOverloads">getOverloads</a></li> <li><a href="#getParameterStorageClasses">getParameterStorageClasses</a></li> <li><a href="#getPointerBitmap">getPointerBitmap</a></li> <li><a href="#getProtection">getProtection</a></li> <li><a href="#getTargetInfo">getTargetInfo</a></li> <li><a href="#getVirtualFunctions">getVirtualFunctions</a></li> <li><a href="#getVirtualMethods">getVirtualMethods</a></li> <li><a href="#getUnitTests">getUnitTests</a></li> <li><a href="#parent">parent</a></li> <li><a href="#classInstanceSize">classInstanceSize</a></li> <li><a href="#getVirtualIndex">getVirtualIndex</a></li> <li><a href="#allMembers">allMembers</a></li> <li><a href="#derivedMembers">derivedMembers</a></li> <li><a href="#isSame">isSame</a></li> <li><a href="#compiles">compiles</a></li> </ol>   <p>Traits are extensions to the language to enable programs, at compile time, to get at information internal to the compiler. This is also known as compile time reflection. It is done as a special, easily extended syntax (similar to Pragmas) so that new capabilities can be added as required. </p>  <pre>TraitsExpression:
    __traits ( TraitsKeyword , TraitsArguments )

TraitsKeyword:
    isAbstractClass
    isArithmetic
    isAssociativeArray
    isFinalClass
    isPOD
    isNested
    isFuture
    isDeprecated
    isFloating
    isIntegral
    isScalar
    isStaticArray
    isUnsigned
    isDisabled
    isVirtualFunction
    isVirtualMethod
    isAbstractFunction
    isFinalFunction
    isStaticFunction
    isOverrideFunction
    isTemplate
    isRef
    isOut
    isLazy
    isReturnOnStack
    isZeroInit
    isModule
    isPackage
    hasMember
    identifier
    getAliasThis
    getAttributes
    getFunctionAttributes
    getFunctionVariadicStyle
    getLinkage
    getLocation
    getMember
    getOverloads
    getParameterStorageClasses
    getPointerBitmap
    getProtection
    getTargetInfo
    getVirtualFunctions
    getVirtualMethods
    getUnitTests
    parent
    classInstanceSize
    getVirtualIndex
    allMembers
    derivedMembers
    isSame
    compiles

TraitsArguments:
    TraitsArgument
    TraitsArgument , TraitsArguments

TraitsArgument:
    AssignExpression
    Type
</pre>  <h2><a id="isArithmetic"><span class="gname">isArithmetic</span></a></h2>  <p>If the arguments are all either types that are arithmetic types, or expressions that are typed as arithmetic types, then <code>true</code> is returned. Otherwise, <code>false</code> is returned. If there are no arguments, <code>false</code> is returned.</p>   <pre data-language="d">import std.stdio;

void main()
{
    int i;
    writeln(__traits(isArithmetic, int));
    writeln(__traits(isArithmetic, i, i+1, int));
    writeln(__traits(isArithmetic));
    writeln(__traits(isArithmetic, int*));
}
</pre>   Prints:  <pre>true
true
false
false
</pre>  <h2><a id="isFloating"><span class="gname">isFloating</span></a></h2>  <p>Works like <code>isArithmetic</code>, except it's for floating point types (including imaginary and complex types).</p>   <pre data-language="d">import core.simd : float4;

enum E : float { a, b }

static assert(__traits(isFloating, float));
static assert(__traits(isFloating, idouble));
static assert(__traits(isFloating, creal));
static assert(__traits(isFloating, E));
static assert(__traits(isFloating, float4));

static assert(!__traits(isFloating, float[4]));
</pre>   <h2><a id="isIntegral"><span class="gname">isIntegral</span></a></h2>  <p>Works like <code>isArithmetic</code>, except it's for integral types (including character types).</p>   <pre data-language="d">import core.simd : int4;

enum E { a, b }

static assert(__traits(isIntegral, bool));
static assert(__traits(isIntegral, char));
static assert(__traits(isIntegral, int));
static assert(__traits(isIntegral, E));
static assert(__traits(isIntegral, int4));

static assert(!__traits(isIntegral, float));
static assert(!__traits(isIntegral, int[4]));
static assert(!__traits(isIntegral, void*));
</pre>   <h2><a id="isScalar"><span class="gname">isScalar</span></a></h2>  <p>Works like <code>isArithmetic</code>, except it's for scalar types.</p>   <pre data-language="d">import core.simd : int4, void16;

enum E { a, b }

static assert(__traits(isScalar, bool));
static assert(__traits(isScalar, char));
static assert(__traits(isScalar, int));
static assert(__traits(isScalar, float));
static assert(__traits(isScalar, E));
static assert(__traits(isScalar, int4));
static assert(__traits(isScalar, void*)); // Includes pointers!

static assert(!__traits(isScalar, int[4]));
static assert(!__traits(isScalar, void16));
static assert(!__traits(isScalar, void));
static assert(!__traits(isScalar, typeof(null)));
static assert(!__traits(isScalar, Object));
</pre>   <h2><a id="isUnsigned"><span class="gname">isUnsigned</span></a></h2>  <p>Works like <code>isArithmetic</code>, except it's for unsigned types.</p>   <pre data-language="d">import core.simd : uint4;

enum SignedEnum { a, b }
enum UnsignedEnum : uint { a, b }

static assert(__traits(isUnsigned, bool));
static assert(__traits(isUnsigned, char));
static assert(__traits(isUnsigned, uint));
static assert(__traits(isUnsigned, UnsignedEnum));
static assert(__traits(isUnsigned, uint4));

static assert(!__traits(isUnsigned, int));
static assert(!__traits(isUnsigned, float));
static assert(!__traits(isUnsigned, SignedEnum));
static assert(!__traits(isUnsigned, uint[4]));
static assert(!__traits(isUnsigned, void*));
</pre>   <h2><a id="isStaticArray"><span class="gname">isStaticArray</span></a></h2>  <p>Works like <code>isArithmetic</code>, except it's for static array types.</p>   <pre data-language="d">import core.simd : int4;

enum E : int[4] { a = [1, 2, 3, 4] }

static array = [1, 2, 3]; // Not a static array: the type is inferred as int[] not int[3].

static assert(__traits(isStaticArray, void[0]));
static assert(__traits(isStaticArray, E));
static assert(!__traits(isStaticArray, int4));
static assert(!__traits(isStaticArray, array));
</pre>   <h2><a id="isAssociativeArray"><span class="gname">isAssociativeArray</span></a></h2>  <p>Works like <code>isArithmetic</code>, except it's for associative array types.</p>  <h2><a id="isAbstractClass"><span class="gname">isAbstractClass</span></a></h2>  <p>If the arguments are all either types that are abstract classes, or expressions that are typed as abstract classes, then <code>true</code> is returned. Otherwise, <code>false</code> is returned. If there are no arguments, <code>false</code> is returned.</p>   <pre data-language="d">import std.stdio;

abstract class C { int foo(); }

void main()
{
    C c;
    writeln(__traits(isAbstractClass, C));
    writeln(__traits(isAbstractClass, c, C));
    writeln(__traits(isAbstractClass));
    writeln(__traits(isAbstractClass, int*));
}
</pre>   Prints:  <pre>true
true
false
false
</pre>  <h2><a id="isFinalClass"><span class="gname">isFinalClass</span></a></h2>  <p>Works like <code>isAbstractClass</code>, except it's for final classes.</p>  <h2><a id="isPOD"><span class="gname">isPOD</span></a></h2>  <p>Takes one argument, which must be a type. It returns <code>true</code> if the type is a <a href="https://dlang.org/glossary.html#pod">POD</a> type, otherwise <code>false</code>.</p>  <h2><a id="isNested"><span class="gname">isNested</span></a></h2>  <p>Takes one argument. It returns <code>true</code> if the argument is a nested type which internally stores a context pointer, otherwise it returns <code>false</code>. Nested types can be <a href="class#nested">classes</a>, <a href="struct#nested">structs</a>, and <a href="function#variadicnested">functions</a>.</p>  <h2><a id="isFuture"><span class="gname">isFuture</span></a></h2>  <p>Takes one argument. It returns <code>true</code> if the argument is a symbol marked with the <code>@future</code> keyword, otherwise <code>false</code>. Currently, only functions and variable declarations have support for the <code>@future</code> keyword.</p>  <h2><a id="isDeprecated"><span class="gname">isDeprecated</span></a></h2>  <p>Takes one argument. It returns <code>true</code> if the argument is a symbol marked with the <code>deprecated</code> keyword, otherwise <code>false</code>.</p>  <h2><a id="isDisabled"><span class="gname">isDisabled</span></a></h2>  <p>Takes one argument and returns <code>true</code> if it's a function declaration marked with <code>@disable</code>.</p>   <pre data-language="d">struct Foo
{
    @disable void foo();
    void bar(){}
}

static assert(__traits(isDisabled, Foo.foo));
static assert(!__traits(isDisabled, Foo.bar));
</pre>   <p>For any other declaration even if <code>@disable</code> is a syntactically valid attribute <code>false</code> is returned because the annotation has no effect.</p>   <pre data-language="d">@disable struct Bar{}

static assert(!__traits(isDisabled, Bar));
</pre>   <h2><a id="isVirtualFunction"><span class="gname">isVirtualFunction</span></a></h2>  <p>The same as <a href="#isVirtualMethod"><i>isVirtualMethod</i></a>, except that final functions that don't override anything return true. </p>  <h2><a id="isVirtualMethod"><span class="gname">isVirtualMethod</span></a></h2>  <p>Takes one argument. If that argument is a virtual function, <code>true</code> is returned, otherwise <code>false</code>. Final functions that don't override anything return false. </p>   <pre data-language="d">import std.stdio;

struct S
{
    void bar() { }
}

class C
{
    void bar() { }
}

void main()
{
    writeln(__traits(isVirtualMethod, C.bar));  // true
    writeln(__traits(isVirtualMethod, S.bar));  // false
}
</pre>   <h2><a id="isAbstractFunction"><span class="gname">isAbstractFunction</span></a></h2>  <p>Takes one argument. If that argument is an abstract function, <code>true</code> is returned, otherwise <code>false</code>. </p>   <pre data-language="d">import std.stdio;

struct S
{
    void bar() { }
}

class C
{
    void bar() { }
}

class AC
{
    abstract void foo();
}

void main()
{
    writeln(__traits(isAbstractFunction, C.bar));   // false
    writeln(__traits(isAbstractFunction, S.bar));   // false
    writeln(__traits(isAbstractFunction, AC.foo));  // true
}
</pre>   <h2><a id="isFinalFunction"><span class="gname">isFinalFunction</span></a></h2>  <p>Takes one argument. If that argument is a final function, <code>true</code> is returned, otherwise <code>false</code>. </p>   <pre data-language="d">import std.stdio;

struct S
{
    void bar() { }
}

class C
{
    void bar() { }
    final void foo();
}

final class FC
{
    void foo();
}

void main()
{
    writeln(__traits(isFinalFunction, C.bar));  // false
    writeln(__traits(isFinalFunction, S.bar));  // false
    writeln(__traits(isFinalFunction, C.foo));  // true
    writeln(__traits(isFinalFunction, FC.foo)); // true
}
</pre>   <h2><a id="isOverrideFunction"><span class="gname">isOverrideFunction</span></a></h2>  <p>Takes one argument. If that argument is a function marked with <span class="d_keyword">override</span>, <code>true</code> is returned, otherwise <code>false</code>. </p>   <pre data-language="d">import std.stdio;

class Base
{
    void foo() { }
}

class Foo : Base
{
    override void foo() { }
    void bar() { }
}

void main()
{
    writeln(__traits(isOverrideFunction, Base.foo)); // false
    writeln(__traits(isOverrideFunction, Foo.foo));  // true
    writeln(__traits(isOverrideFunction, Foo.bar));  // false
}
</pre>   <h2><a id="isStaticFunction"><span class="gname">isStaticFunction</span></a></h2>  <p>Takes one argument. If that argument is a static function, meaning it has no context pointer, <code>true</code> is returned, otherwise <code>false</code>. </p>   <pre data-language="d">struct A
{
    int foo() { return 3; }
    static int boo(int a) { return a; }
}

void main()
{
    assert(__traits(isStaticFunction, A.boo));
    assert(!__traits(isStaticFunction, A.foo));
    assert(__traits(isStaticFunction, main));
}
</pre>   <h2>
<a id="isRef"><span class="gname">isRef</span></a>, <a id="isOut"><span class="gname">isOut</span></a>, <a id="isLazy"><span class="gname">isLazy</span></a>
</h2>  <p>Takes one argument. If that argument is a declaration, <code>true</code> is returned if it is <span class="d_keyword">ref</span>, <span class="d_keyword">out</span>, or <span class="d_keyword">lazy</span>, otherwise <code>false</code>. </p>   <pre data-language="d">void fooref(ref int x)
{
    static assert(__traits(isRef, x));
    static assert(!__traits(isOut, x));
    static assert(!__traits(isLazy, x));
}

void fooout(out int x)
{
    static assert(!__traits(isRef, x));
    static assert(__traits(isOut, x));
    static assert(!__traits(isLazy, x));
}

void foolazy(lazy int x)
{
    static assert(!__traits(isRef, x));
    static assert(!__traits(isOut, x));
    static assert(__traits(isLazy, x));
}
</pre>   <h2><a id="isTemplate"><span class="gname">isTemplate</span></a></h2>  <p>Takes one argument. If that argument is a template then <code>true</code> is returned, otherwise <code>false</code>. </p>   <pre data-language="d">void foo(T)(){}
static assert(__traits(isTemplate,foo));
static assert(!__traits(isTemplate,foo!int()));
static assert(!__traits(isTemplate,"string"));
</pre>   <h2><a id="isZeroInit"><span class="gname">isZeroInit</span></a></h2>  <p>Takes one argument which must be a type. If the type's <a href="property#init">default initializer</a> is all zero bits then <code>true</code> is returned, otherwise <code>false</code>.</p>   <pre data-language="d">struct S1 { int x; }
struct S2 { int x = -1; }

static assert(__traits(isZeroInit, S1));
static assert(!__traits(isZeroInit, S2));

void test()
{
    int x = 3;
    static assert(__traits(isZeroInit, typeof(x)));
}

// `isZeroInit` will always return true for a class C
// because `C.init` is null reference.

class C { int x = -1; }

static assert(__traits(isZeroInit, C));
</pre>   <h2><a id="isReturnOnStack"><span class="gname">isReturnOnStack</span></a></h2>  <p> Takes one argument which must either be a function symbol, function literal, a delegate, or a function pointer. It returns a <code>bool</code> which is <code>true</code> if the return value of the function is returned on the stack via a pointer to it passed as a hidden extra parameter to the function. </p>   <pre data-language="d">struct S { int[20] a; }
int test1();
S test2();

static assert(__traits(isReturnOnStack, test1) == false);
static assert(__traits(isReturnOnStack, test2) == true);
</pre>   <b>Implementation Defined</b>: This is determined by the function ABI calling convention in use, which is often complex.   <b>Best Practices:</b> This has applications in: <ol> <li>Returning values in registers is often faster, so this can be used as a check on a hot function to ensure it is using the fastest method.</li> <li>When using inline assembly to correctly call a function.</li> <li>Testing that the compiler does this correctly is normally hackish and awkward, this enables efficient, direct, and simple testing.</li> </ol>  <h2><a id="isModule"><span class="gname">isModule</span></a></h2>  <p>Takes one argument. If that argument is a symbol that refers to a <a href="module">spec/module, module</a> then <code>true</code> is returned, otherwise <code>false</code>. <a href="module#package-module">Package modules</a> are considered to be modules even if they have not been directly imported as modules. </p>  <pre data-language="d">import std.algorithm.sorting;

// A regular package (no package.d)
static assert(!__traits(isModule, std));
// A package module (has a package.d file)
// Note that we haven't imported std.algorithm directly.
// (In other words, we don't have an "import std.algorithm;" directive.)
static assert(__traits(isModule, std.algorithm));
// A regular module
static assert(__traits(isModule, std.algorithm.sorting));
</pre>  <h2><a id="isPackage"><span class="gname">isPackage</span></a></h2>  <p>Takes one argument. If that argument is a symbol that refers to a <a href="module">spec/module, package</a> then <code>true</code> is returned, otherwise <code>false</code>. </p>  <pre data-language="d">import std.algorithm.sorting;
static assert(__traits(isPackage, std));
static assert(__traits(isPackage, std.algorithm));
static assert(!__traits(isPackage, std.algorithm.sorting));
</pre>  <h2><a id="hasMember"><span class="gname">hasMember</span></a></h2>  <p>The first argument is a type that has members, or is an expression of a type that has members. The second argument is a string. If the string is a valid property of the type, <code>true</code> is returned, otherwise <code>false</code>. </p>   <pre data-language="d">import std.stdio;

struct S
{
    int m;

    import std.stdio; // imports write
}

void main()
{
    S s;

    writeln(__traits(hasMember, S, "m")); // true
    writeln(__traits(hasMember, s, "m")); // true
    writeln(__traits(hasMember, S, "y")); // false
    writeln(__traits(hasMember, S, "write")); // true
    writeln(__traits(hasMember, int, "sizeof")); // true
}
</pre>   <h2><a id="identifier"><span class="gname">identifier</span></a></h2>  <p>Takes one argument, a symbol. Returns the identifier for that symbol as a string literal. </p>  <pre data-language="d">import std.stdio;

int var = 123;
pragma(msg, typeof(var));                       // int
pragma(msg, typeof(__traits(identifier, var))); // string
writeln(var);                                   // 123
writeln(__traits(identifier, var));             // "var"
</pre>   <h2><a id="getAliasThis"><span class="gname">getAliasThis</span></a></h2>  <p>Takes one argument, a type. If the type has <code>alias this</code> declarations, returns a sequence of the names (as <code>string</code>s) of the members used in those declarations. Otherwise returns an empty sequence. </p>   <pre data-language="d">alias AliasSeq(T...) = T;

struct S1
{
    string var;
    alias var this;
}
static assert(__traits(getAliasThis, S1) == AliasSeq!("var"));
static assert(__traits(getAliasThis, int).length == 0);

pragma(msg, __traits(getAliasThis, S1));
pragma(msg, __traits(getAliasThis, int));
</pre>   Prints:  <pre>tuple("var")
tuple()
</pre>  <h2><a id="getAttributes"><span class="gname">getAttributes</span></a></h2> <p> Takes one argument, a symbol. Returns a tuple of all attached user-defined attributes. If no UDAs exist it will return an empty tuple. </p>  <p> For more information, see: <a href="attribute#uda">User-Defined Attributes</a> </p>   <pre data-language="d">@(3) int a;
@("string", 7) int b;

enum Foo;
@Foo int c;

pragma(msg, __traits(getAttributes, a));
pragma(msg, __traits(getAttributes, b));
pragma(msg, __traits(getAttributes, c));
</pre>   Prints:  <pre>tuple(3)
tuple("string", 7)
tuple((Foo))
</pre>  <h2><a id="getFunctionVariadicStyle"><span class="gname">getFunctionVariadicStyle</span></a></h2> <p> Takes one argument which must either be a function symbol, or a type that is a function, delegate or a function pointer. It returns a string identifying the kind of <a href="function#variadic">variadic arguments</a> that are supported. </p>  <table>
<caption>getFunctionVariadicStyle</caption> <tr>
<th class="donthyphenate"><b>result</b></th>
<th class="donthyphenate"><b>kind</b></th>
<th class="donthyphenate"><b>access</b></th>
<th class="donthyphenate"><b>example</b></th>
</tr> <tr>
<td><code>"none"</code></td>
<td>not a variadic function</td>
<td> </td>
<td><code>void foo();</code></td>
</tr> <tr>
<td><code>"argptr"</code></td>
<td>D style variadic function</td>
<td>
<code>_argptr</code> and <code>_arguments</code>
</td>
<td><code>void bar(...)</code></td>
</tr> <tr>
<td><code>"stdarg"</code></td>
<td>C style variadic function</td>
<td><a href="https://dlang.org/phobos/core_stdc_stdarg.html"><code>core.stdc.stdarg</code></a></td>
<td><code>extern (C) void abc(int, ...)</code></td>
</tr> <tr>
<td><code>"typesafe"</code></td>
<td>typesafe variadic function</td>
<td>array on stack</td>
<td><code>void def(int[] ...)</code></td>
</tr> </table>   <pre data-language="d">import core.stdc.stdarg;

void novar() {}
extern(C) void cstyle(int, ...) {}
extern(C++) void cppstyle(int, ...) {}
void dstyle(...) {}
void typesafe(int[]...) {}

static assert(__traits(getFunctionVariadicStyle, novar) == "none");
static assert(__traits(getFunctionVariadicStyle, cstyle) == "stdarg");
static assert(__traits(getFunctionVariadicStyle, cppstyle) == "stdarg");
static assert(__traits(getFunctionVariadicStyle, dstyle) == "argptr");
static assert(__traits(getFunctionVariadicStyle, typesafe) == "typesafe");

static assert(__traits(getFunctionVariadicStyle, (int[] a...) {}) == "typesafe");
static assert(__traits(getFunctionVariadicStyle, typeof(cstyle)) == "stdarg");
</pre>   <h2><a id="getFunctionAttributes"><span class="gname">getFunctionAttributes</span></a></h2> <p> Takes one argument which must either be a function symbol, function literal, or a function pointer. It returns a string tuple of all the attributes of that function <b>excluding</b> any user-defined attributes (UDAs can be retrieved with the <a href="#get-attributes">getAttributes</a> trait). If no attributes exist it will return an empty tuple. </p>   <b>Note:</b> The order of the attributes in the returned tuple is implementation-defined and should not be relied upon.  <p> A list of currently supported attributes are:</p> <ul><li>
<code>pure</code>, <code>nothrow</code>, <code>@nogc</code>, <code>@property</code>, <code>@system</code>, <code>@trusted</code>, <code>@safe</code>, and <code>ref</code>
</li></ul> <b>Note:</b> <code>ref</code> is a function attribute even though it applies to the return type.  <p> Additionally the following attributes are only valid for non-static member functions:</p> <ul><li>
<code>const</code>, <code>immutable</code>, <code>inout</code>, <code>shared</code>
</li></ul>  For example:   <pre data-language="d">int sum(int x, int y) pure nothrow { return x + y; }

pragma(msg, __traits(getFunctionAttributes, sum));

struct S
{
    void test() const @system { }
}

pragma(msg, __traits(getFunctionAttributes, S.test));

void main(){}
</pre>   Prints:  <pre>tuple("pure", "nothrow", "@system")
tuple("const", "@system")
</pre>  <p>Note that some attributes can be inferred. For example:</p>   <pre data-language="d">pragma(msg, __traits(getFunctionAttributes, (int x) @trusted { return x * 2; }));

void main(){}
</pre>   Prints:  <pre>tuple("pure", "nothrow", "@nogc", "@trusted")
</pre>  <h2><a id="getLinkage"><span class="gname">getLinkage</span></a></h2>  <p>Takes one argument, which is a declaration symbol, or the type of a function, delegate, pointer to function, struct, class, or interface. Returns a string representing the <a href="attribute#LinkageAttribute">LinkageAttribute</a> of the declaration. The string is one of: </p>  <ul> <li><code>"D"</code></li> <li><code>"C"</code></li> <li><code>"C++"</code></li> <li><code>"Windows"</code></li> <li><code>"Objective-C"</code></li> <li><code>"System"</code></li> </ul>   <pre data-language="d">extern (C) int fooc();
alias aliasc = fooc;

static assert(__traits(getLinkage, fooc) == "C");
static assert(__traits(getLinkage, aliasc) == "C");

extern (C++) struct FooCPPStruct {}
extern (C++) class FooCPPClass {}
extern (C++) interface FooCPPInterface {}

static assert(__traits(getLinkage, FooCPPStruct) == "C++");
static assert(__traits(getLinkage, FooCPPClass) == "C++");
static assert(__traits(getLinkage, FooCPPInterface) == "C++");
</pre>   <h2><a id="getLocation"><span class="gname">getLocation</span></a></h2> <p>Takes one argument which is a symbol. To disambiguate between overloads, pass the result of <a href="#getOverloads"><i>getOverloads</i></a> with the desired index, to <code>getLocation</code>. Returns a <code>tuple(string, int, int)</code> whose entries correspond to the filename, line number and column number where the argument was declared. </p>  <h2><a id="getMember"><span class="gname">getMember</span></a></h2>  <p>Takes two arguments, the second must be a string. The result is an expression formed from the first argument, followed by a ‘.’, followed by the second argument as an identifier. </p>   <pre data-language="d">import std.stdio;

struct S
{
    int mx;
    static int my;
}

void main()
{
    S s;

    __traits(getMember, s, "mx") = 1;  // same as s.mx=1;
    writeln(__traits(getMember, s, "m" ~ "x")); // 1

    // __traits(getMember, S, "mx") = 1;  // error, no this for S.mx
    __traits(getMember, S, "my") = 2;  // ok
}
</pre>   <h2><a id="getOverloads"><span class="gname">getOverloads</span></a></h2>  <p>The first argument is an aggregate (e.g. struct/class/module). The second argument is a <code>string</code> that matches the name of the member(s) to return. The third argument is a <code>bool</code>, and is optional. If <code>true</code>, the result will also include template overloads. The result is a tuple of all the overloads of the supplied name. </p>   <pre data-language="d">import std.stdio;

class D
{
    this() { }
    ~this() { }
    void foo() { }
    int foo(int) { return 2; }
    void bar(T)() { return T.init; }
    class bar(int n) {}
}

void main()
{
    D d = new D();

    foreach (t; __traits(getOverloads, D, "foo"))
        writeln(typeid(typeof(t)));

    alias b = typeof(__traits(getOverloads, D, "foo"));
    foreach (t; b)
        writeln(typeid(t));

    auto i = __traits(getOverloads, d, "foo")[1](1);
    writeln(i);

    foreach (t; __traits(getOverloads, D, "bar", true))
        writeln(t.stringof);
}
</pre>   Prints:  <pre>void()
int()
void()
int()
2
bar(T)()
bar(int n)
</pre>  <h2><a id="getParameterStorageClasses"><span class="gname">getParameterStorageClasses</span></a></h2>  <p> Takes two arguments. The first must either be a function symbol, or a type that is a function, delegate or a function pointer. The second is an integer identifying which parameter, where the first parameter is 0. It returns a tuple of strings representing the storage classes of that parameter. </p>   <pre data-language="d">ref int foo(return ref const int* p, scope int* a, out int b, lazy int c);

static assert(__traits(getParameterStorageClasses, foo, 0)[0] == "return");
static assert(__traits(getParameterStorageClasses, foo, 0)[1] == "ref");

static assert(__traits(getParameterStorageClasses, foo, 1)[0] == "scope");
static assert(__traits(getParameterStorageClasses, foo, 2)[0] == "out");
static assert(__traits(getParameterStorageClasses, typeof(&amp;foo), 3)[0] == "lazy");
</pre>   <h2><a id="getPointerBitmap"><span class="gname">getPointerBitmap</span></a></h2>  <p>The argument is a type. The result is an array of <code>size_t</code> describing the memory used by an instance of the given type. </p> <p>The first element of the array is the size of the type (for classes it is the <a href="#classInstanceSize"><i>classInstanceSize</i></a>).</p> <p>The following elements describe the locations of GC managed pointers within the memory occupied by an instance of the type. For type T, there are <code>T.sizeof / size_t.sizeof</code> possible pointers represented by the bits of the array values.</p> <p>This array can be used by a precise GC to avoid false pointers.</p>  <pre data-language="d">void main()
{
    static class C
    {
        // implicit virtual function table pointer not marked
        // implicit monitor field not marked, usually managed manually
        C next;
        size_t sz;
        void* p;
        void function () fn; // not a GC managed pointer
    }

    static struct S
    {
        size_t val1;
        void* p;
        C c;
        byte[] arr;          // { length, ptr }
        void delegate () dg; // { context, func }
    }

    static assert (__traits(getPointerBitmap, C) == [6*size_t.sizeof, 0b010100]);
    static assert (__traits(getPointerBitmap, S) == [7*size_t.sizeof, 0b0110110]);
}
</pre>    <h2><a id="getProtection"><span class="gname">getProtection</span></a></h2>  <p>The argument is a symbol. The result is a string giving its protection level: "public", "private", "protected", "export", or "package". </p>   <pre data-language="d">import std.stdio;

class D
{
    export void foo() { }
    public int bar;
}

void main()
{
    D d = new D();

    auto i = __traits(getProtection, d.foo);
    writeln(i);

    auto j = __traits(getProtection, d.bar);
    writeln(j);
}
</pre>   Prints:  <pre>export
public
</pre>  <h2><a id="getTargetInfo"><span class="gname">getTargetInfo</span></a></h2>  <p>Receives a string key as argument. The result is an expression describing the requested target information. </p>   <pre data-language="d">version (CppRuntime_Microsoft)
    static assert(__traits(getTargetInfo, "cppRuntimeLibrary") == "libcmt");
</pre>   <p>Keys are implementation defined, allowing relevant data for exotic targets. A reliable subset exists which are always available: </p>  <ul> <li>
<code>"cppRuntimeLibrary"</code> - The C++ runtime library affinity for this toolchain</li> <li>
<code>"floatAbi"</code> - Floating point ABI; may be <code>"hard"</code>, <code>"soft"</code>, or <code>"softfp"</code>
</li> <li>
<code>"objectFormat"</code> - Target object format</li> </ul>  <h2><a id="getVirtualFunctions"><span class="gname">getVirtualFunctions</span></a></h2>  <p>The same as <a href="#getVirtualMethods"><i>getVirtualMethods</i></a>, except that final functions that do not override anything are included. </p>  <h2><a id="getVirtualMethods"><span class="gname">getVirtualMethods</span></a></h2>  <p>The first argument is a class type or an expression of class type. The second argument is a string that matches the name of one of the functions of that class. The result is a tuple of the virtual overloads of that function. It does not include final functions that do not override anything. </p>   <pre data-language="d">import std.stdio;

class D
{
    this() { }
    ~this() { }
    void foo() { }
    int foo(int) { return 2; }
}

void main()
{
    D d = new D();

    foreach (t; __traits(getVirtualMethods, D, "foo"))
        writeln(typeid(typeof(t)));

    alias b = typeof(__traits(getVirtualMethods, D, "foo"));
    foreach (t; b)
        writeln(typeid(t));

    auto i = __traits(getVirtualMethods, d, "foo")[1](1);
    writeln(i);
}
</pre>   Prints:  <pre>void()
int()
void()
int()
2
</pre>  <h2><a id="getUnitTests"><span class="gname">getUnitTests</span></a></h2>  <p> Takes one argument, a symbol of an aggregate (e.g. struct/class/module). The result is a tuple of all the unit test functions of that aggregate. The functions returned are like normal nested static functions, <a href="https://dlang.org/glossary.html#ctfe">CTFE</a> will work and <a href="attribute#uda">UDAs</a> will be accessible. </p>  <h3>Note:</h3>  <p> The -unittest flag needs to be passed to the compiler. If the flag is not passed <code>__traits(getUnitTests)</code> will always return an empty tuple. </p>   <pre data-language="d">module foo;

import core.runtime;
import std.stdio;

struct name { string name; }

class Foo
{
    unittest
    {
        writeln("foo.Foo.unittest");
    }
}

@name("foo") unittest
{
    writeln("foo.unittest");
}

template Tuple (T...)
{
    alias Tuple = T;
}

shared static this()
{
  // Override the default unit test runner to do nothing. After that, "main" will
  // be called.
  Runtime.moduleUnitTester = { return true; };
}

void main()
{
    writeln("start main");

    alias tests = Tuple!(__traits(getUnitTests, foo));
    static assert(tests.length == 1);

    alias attributes = Tuple!(__traits(getAttributes, tests[0]));
    static assert(attributes.length == 1);

    foreach (test; tests)
        test();

    foreach (test; __traits(getUnitTests, Foo))
        test();
}
</pre>   <p>By default, the above will print:</p>  <pre>start main
foo.unittest
foo.Foo.unittest
</pre>  <h2><a id="parent"><span class="gname">parent</span></a></h2>  <p>Takes a single argument which must evaluate to a symbol. The result is the symbol that is the parent of it. </p>  <h2><a id="classInstanceSize"><span class="gname">classInstanceSize</span></a></h2>  <p>Takes a single argument, which must evaluate to either a class type or an expression of class type. The result is of type <code>size_t</code>, and the value is the number of bytes in the runtime instance of the class type. It is based on the static type of a class, not the polymorphic type. </p>  <h2><a id="getVirtualIndex"><span class="gname">getVirtualIndex</span></a></h2>  <p>Takes a single argument which must evaluate to a function. The result is a <code>ptrdiff_t</code> containing the index of that function within the vtable of the parent type. If the function passed in is final and does not override a virtual function, <code>-1</code> is returned instead. </p>  <h2><a id="allMembers"><span class="gname">allMembers</span></a></h2>  <p>Takes a single argument, which must evaluate to either a type or an expression of type. A tuple of string literals is returned, each of which is the name of a member of that type combined with all of the members of the base classes (if the type is a class). No name is repeated. Builtin properties are not included. </p>   <pre data-language="d">import std.stdio;

class D
{
    this() { }
    ~this() { }
    void foo() { }
    int foo(int) { return 0; }
}

void main()
{
    auto b = [ __traits(allMembers, D) ];
    writeln(b);
    // ["__ctor", "__dtor", "foo", "toString", "toHash", "opCmp", "opEquals",
    // "Monitor", "factory"]
}
</pre>   <p>The order in which the strings appear in the result is not defined.</p>  <h2><a id="derivedMembers"><span class="gname">derivedMembers</span></a></h2>  <p>Takes a single argument, which must evaluate to either a type or an expression of type. A tuple of string literals is returned, each of which is the name of a member of that type. No name is repeated. Base class member names are not included. Builtin properties are not included. </p>   <pre data-language="d">import std.stdio;

class D
{
    this() { }
    ~this() { }
    void foo() { }
    int foo(int) { return 0; }
}

void main()
{
    auto a = [__traits(derivedMembers, D)];
    writeln(a);    // ["__ctor", "__dtor", "foo"]
}
</pre>   <p>The order in which the strings appear in the result is not defined.</p>  <h2><a id="isSame"><span class="gname">isSame</span></a></h2>  <p>Takes two arguments and returns bool <code>true</code> if they are the same symbol, <code>false</code> if not.</p>   <pre data-language="d">import std.stdio;

struct S { }

int foo();
int bar();

void main()
{
    writeln(__traits(isSame, foo, foo)); // true
    writeln(__traits(isSame, foo, bar)); // false
    writeln(__traits(isSame, foo, S));   // false
    writeln(__traits(isSame, S, S));     // true
    writeln(__traits(isSame, std, S));   // false
    writeln(__traits(isSame, std, std)); // true
}
</pre>   <p>If the two arguments are expressions made up of literals or enums that evaluate to the same value, true is returned.</p>  <p>If the two arguments are both lambda functions (or aliases to lambda functions), then they are compared for equality. For the comparison to be computed correctly, the following conditions must be met for both lambda functions:</p>  <ol> <li>The lambda function arguments must not have a template instantiation as an explicit argument type. Any other argument types (basic, user-defined, template) are supported.</li> <li>The lambda function body must contain a single expression (no return statement) which contains only numeric values, manifest constants, enum values, function arguments and function calls. If the expression contains local variables or return statements, the function is considered incomparable.</li> </ol>  <p>If these constraints aren't fulfilled, the function is considered incomparable and <code>isSame</code> returns <code>false</code>.</p>   <pre data-language="d">int f() { return 2; }
void test(alias pred)()
{
    // f() from main is a different function from top-level f()
    static assert(!__traits(isSame, (int a) =&gt; a + f(), pred));
}

void main()
{
    static assert(__traits(isSame, (a, b) =&gt; a + b, (c, d) =&gt; c + d));
    static assert(__traits(isSame, a =&gt; ++a, b =&gt; ++b));
    static assert(!__traits(isSame, (int a, int b) =&gt; a + b, (a, b) =&gt; a + b));
    static assert(__traits(isSame, (a, b) =&gt; a + b + 10, (c, d) =&gt; c + d + 10));

    // lambdas accessing local variables are considered incomparable
    int b;
    static assert(!__traits(isSame, a =&gt; a + b, a =&gt; a + b));

    // lambdas calling other functions are comparable
    int f() { return 3;}
    static assert(__traits(isSame, a =&gt; a + f(), a =&gt; a + f()));
    test!((int a) =&gt; a + f())();

    class A
    {
        int a;
        this(int a)
        {
            this.a = a;
        }
    }

    class B
    {
        int a;
        this(int a)
        {
            this.a = a;
        }
    }

    static assert(__traits(isSame, (A a) =&gt; ++a.a, (A b) =&gt; ++b.a));
    // lambdas with different data types are considered incomparable,
    // even if the memory layout is the same
    static assert(!__traits(isSame, (A a) =&gt; ++a.a, (B a) =&gt; ++a.a));
}
</pre>   <h2><a id="compiles"><span class="gname">compiles</span></a></h2>  <p>Returns a bool <code>true</code> if all of the arguments compile (are semantically correct). The arguments can be symbols, types, or expressions that are syntactically correct. The arguments cannot be statements or declarations. </p>  <p>If there are no arguments, the result is <code>false</code>.</p>   <pre data-language="d">import std.stdio;

struct S
{
    static int s1;
    int s2;
}

int foo();
int bar();

void main()
{
    writeln(__traits(compiles));                      // false
    writeln(__traits(compiles, foo));                 // true
    writeln(__traits(compiles, foo + 1));             // true
    writeln(__traits(compiles, &amp;foo + 1));            // false
    writeln(__traits(compiles, typeof(1)));           // true
    writeln(__traits(compiles, S.s1));                // true
    writeln(__traits(compiles, S.s3));                // false
    writeln(__traits(compiles, 1,2,3,int,long,std));  // true
    writeln(__traits(compiles, 3[1]));                // false
    writeln(__traits(compiles, 1,2,3,int,long,3[1])); // false
}
</pre>   <p>This is useful for:</p>  <ul> <li>Giving better error messages inside generic code than the sometimes hard to follow compiler ones.</li> <li>Doing a finer grained specialization than template partial specialization allows for.</li> </ul>       <div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/spec/traits.html" class="_attribution-link">https://dlang.org/spec/traits.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
