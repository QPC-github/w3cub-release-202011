
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>dmd.expression - D - W3cubDocs</title>
  
  <meta name="description" content=" Compiler implementation of the D programming language. ">
  <meta name="keywords" content="dmd, expression, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/dmd_expression.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>dmd.expression</h1>  <p>Compiler implementation of the <a href="http://www.dlang.org">D programming language</a>. </p>
<dl>
<dt>Authors:</dt>
<dd>
<a href="http://www.digitalmars.com">Walter Bright</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/dmd/blob/master/src/dmd/expression.d">expression.d</a> </dd>
</dl> <dl>
<dt>Documentation</dt>
<dd> <a href="dmd_expression">https://dlang.org/phobos/dmd_expression.html</a> </dd>
</dl> <dl>
<dt>Coverage</dt>
<dd> <a href="https://codecov.io/gh/dlang/dmd/src/master/src/dmd/expression.d">https://codecov.io/gh/dlang/dmd/src/master/src/dmd/expression.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="firstComma">inout(Expression) <strong id="firstComma">firstComma</strong>(inout Expression e); </dt> <dd>
<p>Find the first non-comma expression. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Expression <code>e</code>
</td> <td>Expressions connected by commas</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>left-most non-comma expression</dd>
</dl> </dd> <dt class="d_decl" id="lastComma">inout(Expression) <strong id="lastComma">lastComma</strong>(inout Expression e); </dt> <dd>
<p>Find the last non-comma expression. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Expression <code>e</code>
</td> <td>Expressions connected by commas</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>right-most non-comma expression</dd>
</dl> </dd> <dt class="d_decl" id="hasThis">FuncDeclaration <strong id="hasThis">hasThis</strong>(Scope* sc); </dt> <dd>
<p>Determine if <code>this</code> is available by walking up the enclosing scopes until a function is found. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Scope* <code>sc</code>
</td> <td>where to start looking for the enclosing function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Found function if it satisfies <code>isThis()</code>, otherwise <code>null</code>
</dd>
</dl> </dd> <dt class="d_decl" id="isNeedThisScope">bool <strong id="isNeedThisScope">isNeedThisScope</strong>(Scope* sc, Declaration d); </dt> <dd>
<p>Determine if a <code>this</code> is needed to access <code>d</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Scope* <code>sc</code>
</td> <td>context</td>
</tr> <tr>
<td>Declaration <code>d</code>
</td> <td>declaration to check</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true means a <code>this</code> is needed</dd>
</dl> </dd> <dt class="d_decl" id="isDotOpDispatch">bool <strong id="isDotOpDispatch">isDotOpDispatch</strong>(Expression e); </dt> <dd>
<p>check e is exp.opDispatch!(tiargs) or not It's used to switch to UFCS the semantic analysis path</p> </dd> <dt class="d_decl" id="expandTuples">void <strong id="expandTuples">expandTuples</strong>(Expressions* exps); </dt> <dd>
<p>Expand tuples. </p>
<dl>
<dt>Input</dt>
<dd> exps aray of Expressions </dd>
</dl> <dl>
<dt>Output</dt>
<dd> exps rewritten in place</dd>
</dl> </dd> <dt class="d_decl" id="isAliasThisTuple">TupleDeclaration <strong id="isAliasThisTuple">isAliasThisTuple</strong>(Expression e); </dt> <dd>
<p>Expand alias this tuples.</p> </dd> <dt class="d_decl" id="getFuncTemplateDecl">TemplateDeclaration <strong id="getFuncTemplateDecl">getFuncTemplateDecl</strong>(Dsymbol s); </dt> <dd>
<p>If <code>s</code> is a function template, i.e. the only member of a template and that member is a function, return that template. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Dsymbol <code>s</code>
</td> <td>symbol that might be a function template</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>template for that function, otherwise null</dd>
</dl> </dd> <dt class="d_decl" id="valueNoDtor">Expression <strong id="valueNoDtor">valueNoDtor</strong>(Expression e); </dt> <dd>
<p>If we want the value of this expression, but do not want to call the destructor on it.</p> </dd> <dt class="d_decl" id="doCopyOrMove">Expression <strong id="doCopyOrMove">doCopyOrMove</strong>(Scope* sc, Expression e, Type t = null); </dt> <dd>
<p>Handle the postblit call on lvalue, or the move of rvalue. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Scope* <code>sc</code>
</td> <td>the scope where the expression is encountered</td>
</tr> <tr>
<td>Expression <code>e</code>
</td> <td>the expression the needs to be moved or copied (source)</td>
</tr> <tr>
<td>Type <code>t</code>
</td> <td>if the struct defines a copy constructor, the type of the destination</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The expression that copy constructs or moves the value.</dd>
</dl> </dd> <dt class="d_decl" id="UnionExp">struct <strong id="UnionExp">UnionExp</strong>; </dt>  <dt class="d_decl" id="RealIdentical">int <strong id="RealIdentical">RealIdentical</strong>(real_t x1, real_t x2); </dt> <dd>
<p>Test to see if two reals are the same. Regard NaN's as equivalent. Regard +0 and -0 as different. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>real_t <code>x1</code>
</td> <td>first operand</td>
</tr> <tr>
<td>real_t <code>x2</code>
</td> <td>second operand</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>1 if x1 is x2 else 0</dd>
</dl> </dd> <dt class="d_decl" id="typeDotIdExp">DotIdExp <strong id="typeDotIdExp">typeDotIdExp</strong>(ref const Loc loc, Type type, Identifier ident); </dt> <dd>
<p>TypeDotIdExp</p> </dd> <dt class="d_decl" id="expToVariable">VarDeclaration <strong id="expToVariable">expToVariable</strong>(Expression e); </dt> <dd>
<p>Given an Expression, find the variable it really is. </p>
<p>For example, <code>a[index]</code> is really <code>a</code>, and <code>s.f</code> is really <code>s</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Expression <code>e</code>
</td> <td>Expression to look at</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>variable if there is one, null if not</dd>
</dl> </dd> <dt class="d_decl" id="Expression">abstract class <strong id="Expression">Expression</strong>: dmd.ast_node.ASTNode; </dt> <dd>
<p><a href="http://dlang.org/spec/expression.html#expression">http://dlang.org/spec/expression.html#expression</a></p> <dl>
<dt class="d_decl" id="Expression.deinitialize">static void <strong id="deinitialize">deinitialize</strong>(); </dt> <dd>
<p>Deinitializes the global state of the compiler. </p>
<p>This can be used to restore the state set by <code>_init</code> to its original state.</p> </dd> <dt class="d_decl" id="Expression.copy">final Expression <strong id="copy">copy</strong>(); </dt> <dd>
<p>Does *not* do a deep copy.</p> </dd> <dt class="d_decl" id="Expression.combine">static Expression <strong id="combine">combine</strong>(Expression e1, Expression e2); </dt> <dd>
<p>Combine e1 and e2 by CommaExp if both are not NULL.</p> </dd> <dt class="d_decl" id="Expression.extractLast">static Expression <strong id="extractLast">extractLast</strong>(Expression e, out Expression e0); </dt> <dd>
<p>If 'e' is a tree of commas, returns the rightmost expression by stripping off it from the tree. The remained part of the tree is returned via e0. Otherwise 'e' is directly returned and e0 is set to NULL.</p> </dd> <dt class="d_decl" id="Expression.isLvalue">bool <strong id="isLvalue">isLvalue</strong>(); </dt> <dd>
<p>Return !=0 if expression is an lvalue.</p> </dd> <dt class="d_decl" id="Expression.toLvalue">Expression <strong id="toLvalue">toLvalue</strong>(Scope* sc, Expression e); </dt> <dd>
<p>Give error if we're not an lvalue. If we can, convert expression to be an lvalue.</p> </dd> <dt class="d_decl" id="Expression.resolveLoc">Expression <strong id="resolveLoc">resolveLoc</strong>(ref const Loc loc, Scope* sc); </dt> <dd>
<p>Resolve __FILE__, __LINE__, __MODULE__, __FUNCTION__, __PRETTY_FUNCTION__, _FILE_FULL_PATH__ to loc.</p> </dd> <dt class="d_decl" id="Expression.checkType">bool <strong id="checkType">checkType</strong>(); </dt> <dd>
<p>Check that the expression has a valid type. If not, generates an error "... has no type". </p>
<dl>
<dt>Returns:</dt>
<dd>true if the expression is not valid. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> When this function returns true, <code>checkValue()</code> should also return true.</dd>
</dl> </dd> <dt class="d_decl" id="Expression.checkValue">bool <strong id="checkValue">checkValue</strong>(); </dt> <dd>
<p>Check that the expression has a valid value. If not, generates an error "... has no value". </p>
<dl>
<dt>Returns:</dt>
<dd>true if the expression is not valid or has void type.</dd>
</dl> </dd> <dt class="d_decl" id="Expression.checkPurity">final bool <strong id="checkPurity">checkPurity</strong>(Scope* sc, FuncDeclaration f); </dt> <dd>
<p>Calling function f. Check the purity, i.e. if we're in a pure function we can only call other pure functions. Returns true if error occurs.</p> </dd> <dt class="d_decl" id="Expression.checkPurity.2">final bool <strong id="checkPurity">checkPurity</strong>(Scope* sc, VarDeclaration v); </dt> <dd>
<p>Accessing variable v. Check for purity and safety violations. Returns true if error occurs.</p> </dd> <dt class="d_decl" id="Expression.checkSafety">final bool <strong id="checkSafety">checkSafety</strong>(Scope* sc, FuncDeclaration f); </dt> <dd>
<p>Calling function f. Check the safety, i.e. if we're in a @safe function we can only call @safe or @trusted functions. Returns true if error occurs.</p> </dd> <dt class="d_decl" id="Expression.checkNogc">final bool <strong id="checkNogc">checkNogc</strong>(Scope* sc, FuncDeclaration f); </dt> <dd>
<p>Calling function f. Check the @nogc-ness, i.e. if we're in a @nogc function we can only call other @nogc functions. Returns true if error occurs.</p> </dd> <dt class="d_decl" id="Expression.checkPostblit">final bool <strong id="checkPostblit">checkPostblit</strong>(Scope* sc, Type t); </dt> <dd>
<p>Check that the postblit is callable if t is an array of structs. Returns true if error happens.</p> </dd> <dt class="d_decl" id="Expression.checkReadModifyWrite">final bool <strong id="checkReadModifyWrite">checkReadModifyWrite</strong>(TOK rmwOp, Expression ex = null); </dt> <dd>
<p>Check whether the expression allows RMW operations, error with rmw operator diagnostic if not. ex is the RHS expression, or NULL if ++/-- is used (for diagnostics) Returns true if error occurs.</p> </dd> <dt class="d_decl" id="Expression.checkModifiable">Modifiable <strong id="checkModifiable">checkModifiable</strong>(Scope* sc, int flag = 0); </dt> <dd>
<dl>
<dt>Parameters</dt>
<dd> sc: scope flag: 1: do not issue error message for invalid modification </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether the type is modifiable</dd>
</dl> </dd> <dt class="d_decl" id="Expression.toBoolean">Expression <strong id="toBoolean">toBoolean</strong>(Scope* sc); </dt> <dd>
<p>If expression can be tested for true or false, returns the modified expression. Otherwise returns ErrorExp.</p> </dd> <dt class="d_decl" id="Expression.addDtorHook">Expression <strong id="addDtorHook">addDtorHook</strong>(Scope* sc); </dt> <dd>
<p>Destructors are attached to VarDeclarations. Hence, if expression returns a temp that needs a destructor, make sure and create a VarDeclaration for that temp.</p> </dd> <dt class="d_decl" id="Expression.addressOf">final Expression <strong id="addressOf">addressOf</strong>(); </dt> <dd>
<p>Take address of expression.</p> </dd> <dt class="d_decl" id="Expression.deref">final Expression <strong id="deref">deref</strong>(); </dt> <dd>
<p>If this is a reference, dereference it.</p> </dd> <dt class="d_decl" id="Expression.isBool">bool <strong id="isBool">isBool</strong>(bool result); </dt> <dd>
<p>Does this expression statically evaluate to a boolean 'result' (true or false)?</p> </dd> </dl> </dd> <dt class="d_decl" id="IntegerExp">class <strong id="IntegerExp">IntegerExp</strong>: dmd.expression.Expression; </dt> <dd> <dl>
<dt class="d_decl" id="IntegerExp.literal">IntegerExp <strong id="literal">literal</strong>(int v)(); </dt> <dd>
<p>Use this instead of creating new instances for commonly used literals such as 0 or 1. </p>
<dl>
<dt>Parameters</dt>
<dd> v = The value of the expression </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A static instance of the expression, typed as <code>Tint32</code>.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="ErrorExp">class <strong id="ErrorExp">ErrorExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>Use this expression for error recovery. It should behave as a 'sink' to prevent further cascaded error messages.</p> </dd> <dt class="d_decl" id="VoidInitExp">class <strong id="VoidInitExp">VoidInitExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>An uninitialized value, generated from void initializers.</p> <dl>
<dt class="d_decl" id="VoidInitExp.var">VarDeclaration <strong id="var">var</strong>; </dt> <dd>
<p>the variable from where the void value came from, null if not known</p> </dd> <dt class="d_decl" id="VoidInitExp.this">this(VarDeclaration var); </dt> <dd>
<p>Useful for error messages</p> </dd> </dl> </dd> <dt class="d_decl" id="RealExp">class <strong id="RealExp">RealExp</strong>: dmd.expression.Expression; </dt>  <dt class="d_decl" id="ComplexExp">class <strong id="ComplexExp">ComplexExp</strong>: dmd.expression.Expression; </dt>  <dt class="d_decl" id="IdentifierExp">class <strong id="IdentifierExp">IdentifierExp</strong>: dmd.expression.Expression; </dt>  <dt class="d_decl" id="DollarExp">class <strong id="DollarExp">DollarExp</strong>: dmd.expression.IdentifierExp; </dt>  <dt class="d_decl" id="DsymbolExp">class <strong id="DsymbolExp">DsymbolExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>Won't be generated by parser.</p> </dd> <dt class="d_decl" id="ThisExp">class <strong id="ThisExp">ThisExp</strong>: dmd.expression.Expression; </dt> <dd>
<p><a href="http://dlang.org/spec/expression.html#this">http://dlang.org/spec/expression.html#this</a></p> </dd> <dt class="d_decl" id="SuperExp">class <strong id="SuperExp">SuperExp</strong>: dmd.expression.ThisExp; </dt> <dd>
<p><a href="http://dlang.org/spec/expression.html#super">http://dlang.org/spec/expression.html#super</a></p> </dd> <dt class="d_decl" id="NullExp">class <strong id="NullExp">NullExp</strong>: dmd.expression.Expression; </dt> <dd>
<p><a href="http://dlang.org/spec/expression.html#null">http://dlang.org/spec/expression.html#null</a></p> </dd> <dt class="d_decl" id="StringExp">class <strong id="StringExp">StringExp</strong>: dmd.expression.Expression; </dt> <dd>
<p><a href="http://dlang.org/spec/expression.html#string_literals">http://dlang.org/spec/expression.html#string_literals</a></p> <dl>
<dt class="d_decl" id="StringExp.numberOfCodeUnits">const size_t <strong id="numberOfCodeUnits">numberOfCodeUnits</strong>(int tynto = 0); </dt> <dd>
<p>Return the number of code units the string would be if it were re-encoded as tynto. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>tynto</code>
</td> <td>code unit type of the target encoding</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>number of code units</dd>
</dl> </dd> <dt class="d_decl" id="StringExp.writeTo">const void <strong id="writeTo">writeTo</strong>(void* dest, bool zero, int tyto = 0); </dt> <dd>
<p>Write the contents of the string to dest. Use numberOfCodeUnits() to determine size of result. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>dest</code>
</td> <td>destination</td>
</tr> <tr>
<td>int <code>tyto</code>
</td> <td>encoding type of the result</td>
</tr> <tr>
<td>bool <code>zero</code>
</td> <td>add terminating 0</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="StringExp.getCodeUnit">const pure dchar <strong id="getCodeUnit">getCodeUnit</strong>(size_t i); </dt> <dd>
<p>Get the code unit at index i </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>size_t <code>i</code>
</td> <td>index</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>code unit at index i</dd>
</dl> </dd> <dt class="d_decl" id="StringExp.setCodeUnit">void <strong id="setCodeUnit">setCodeUnit</strong>(size_t i, dchar c); </dt> <dd>
<p>Set the code unit at index i to c </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>size_t <code>i</code>
</td> <td>index</td>
</tr> <tr>
<td>dchar <code>c</code>
</td> <td>code unit to set it to</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="StringExp.toPtr">char* <strong id="toPtr">toPtr</strong>(); </dt> <dd>
<p>If the string data is UTF-8 and can be accessed directly, return a pointer to it. Do not assume a terminating 0. </p>
<dl>
<dt>Returns:</dt>
<dd>pointer to string data if possible, null if not</dd>
</dl> </dd> <dt class="d_decl" id="StringExp.toUTF8">StringExp <strong id="toUTF8">toUTF8</strong>(Scope* sc); </dt> <dd>
<p>Convert string to char[].</p> </dd> <dt class="d_decl" id="StringExp.toStringz">const const(char)[] <strong id="toStringz">toStringz</strong>(); </dt> <dd>
<p>Convert string contents to a 0 terminated string, allocated by mem.xmalloc().</p> </dd> </dl> </dd> <dt class="d_decl" id="TupleExp">class <strong id="TupleExp">TupleExp</strong>: dmd.expression.Expression; </dt>  <dt class="d_decl" id="ArrayLiteralExp">class <strong id="ArrayLiteralExp">ArrayLiteralExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>[ e1, e2, e3, ... ] </p>
<p><a href="http://dlang.org/spec/expression.html#array_literals">http://dlang.org/spec/expression.html#array_literals</a></p> <dl>
<dt class="d_decl" id="ArrayLiteralExp.basis">Expression <strong id="basis">basis</strong>; </dt> <dd>
<p>If !is null, elements[] can be sparse and basis is used for the "default" element value. In other words, non-null elements[i] overrides this 'basis' value.</p> </dd> </dl> </dd> <dt class="d_decl" id="AssocArrayLiteralExp">class <strong id="AssocArrayLiteralExp">AssocArrayLiteralExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>[ key0 : value0, key1 : value1, ... ] </p>
<p><a href="http://dlang.org/spec/expression.html#associative_array_literals">http://dlang.org/spec/expression.html#associative_array_literals</a></p> </dd> <dt class="d_decl" id="stageScrub">enum int <strong id="stageScrub">stageScrub</strong>; </dt> <dd>
<p>scrubReturnValue is running</p> </dd> <dt class="d_decl" id="stageSearchPointers">enum int <strong id="stageSearchPointers">stageSearchPointers</strong>; </dt> <dd>
<p>hasNonConstPointers is running</p> </dd> <dt class="d_decl" id="stageOptimize">enum int <strong id="stageOptimize">stageOptimize</strong>; </dt> <dd>
<p>optimize is running</p> </dd> <dt class="d_decl" id="stageApply">enum int <strong id="stageApply">stageApply</strong>; </dt> <dd>
<p>apply is running</p> </dd> <dt class="d_decl" id="stageInlineScan">enum int <strong id="stageInlineScan">stageInlineScan</strong>; </dt> <dd>
<p>inlineScan is running</p> </dd> <dt class="d_decl" id="stageToCBuffer">enum int <strong id="stageToCBuffer">stageToCBuffer</strong>; </dt> <dd>
<p>toCBuffer is running</p> </dd> <dt class="d_decl" id="StructLiteralExp">class <strong id="StructLiteralExp">StructLiteralExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>sd( e1, e2, e3, ... )</p> <dl>
<dt class="d_decl" id="StructLiteralExp.sd">StructDeclaration <strong id="sd">sd</strong>; </dt> <dd>
<p>which aggregate this is for</p> </dd> <dt class="d_decl" id="StructLiteralExp.elements">Expressions* <strong id="elements">elements</strong>; </dt> <dd>
<p>parallels sd.fields[] with null entries for fields to skip</p> </dd> <dt class="d_decl" id="StructLiteralExp.stype">Type <strong id="stype">stype</strong>; </dt> <dd>
<p>final type of result (can be different from sd's type)</p> </dd> <dt class="d_decl" id="StructLiteralExp.sym">Symbol* <strong id="sym">sym</strong>; </dt> <dd>
<p>back end symbol to initialize with literal</p> </dd> <dt class="d_decl" id="StructLiteralExp.origin">StructLiteralExp <strong id="origin">origin</strong>; </dt> <dd>
<p>pointer to the origin instance of the expression. once a new expression is created, origin is set to 'this'. anytime when an expression copy is created, 'origin' pointer is set to 'origin' pointer value of the original expression.</p> </dd> <dt class="d_decl" id="StructLiteralExp.inlinecopy">StructLiteralExp <strong id="inlinecopy">inlinecopy</strong>; </dt> <dd>
<p>those fields need to prevent a infinite recursion when one field of struct initialized with 'this' pointer.</p> </dd> <dt class="d_decl" id="StructLiteralExp.stageflags">int <strong id="stageflags">stageflags</strong>; </dt> <dd>
<p>anytime when recursive function is calling, 'stageflags' marks with bit flag of current stage and unmarks before return from this function. 'inlinecopy' uses similar 'stageflags' and from multiple evaluation 'doInline' (with infinite recursion) of this expression.</p> </dd> <dt class="d_decl" id="StructLiteralExp.useStaticInit">bool <strong id="useStaticInit">useStaticInit</strong>; </dt> <dd>
<p>if this is true, use the StructDeclaration's init symbol</p> </dd> <dt class="d_decl" id="StructLiteralExp.getField">Expression <strong id="getField">getField</strong>(Type type, uint offset); </dt> <dd>
<p>Gets expression at offset of type. Returns NULL if not found.</p> </dd> <dt class="d_decl" id="StructLiteralExp.getFieldIndex">int <strong id="getFieldIndex">getFieldIndex</strong>(Type type, uint offset); </dt> <dd>
<p>Get index of field. Returns -1 if not found.</p> </dd> </dl> </dd> <dt class="d_decl" id="TypeExp">class <strong id="TypeExp">TypeExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>Mainly just a placeholder</p> </dd> <dt class="d_decl" id="ScopeExp">class <strong id="ScopeExp">ScopeExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>Mainly just a placeholder of Package, Module, Nspace, and TemplateInstance (including TemplateMixin) </p>
<p>A template instance that requires IFTI: foo!tiargs(fargs) // foo!tiargs is left until CallExp::semantic() or resolveProperties()</p> </dd> <dt class="d_decl" id="TemplateExp">class <strong id="TemplateExp">TemplateExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>Mainly just a placeholder</p> </dd> <dt class="d_decl" id="NewExp">class <strong id="NewExp">NewExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>thisexp.new(newargs) newtype(arguments)</p> </dd> <dt class="d_decl" id="NewAnonClassExp">class <strong id="NewAnonClassExp">NewAnonClassExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>thisexp.new(newargs) class baseclasses { } (arguments)</p> </dd> <dt class="d_decl" id="SymbolExp">class <strong id="SymbolExp">SymbolExp</strong>: dmd.expression.Expression; </dt>  <dt class="d_decl" id="SymOffExp">class <strong id="SymOffExp">SymOffExp</strong>: dmd.expression.SymbolExp; </dt> <dd>
<p>Offset from symbol</p> </dd> <dt class="d_decl" id="VarExp">class <strong id="VarExp">VarExp</strong>: dmd.expression.SymbolExp; </dt> <dd>
<p>Variable</p> </dd> <dt class="d_decl" id="OverExp">class <strong id="OverExp">OverExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>Overload Set</p> </dd> <dt class="d_decl" id="FuncExp">class <strong id="FuncExp">FuncExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>Function/Delegate literal</p> </dd> <dt class="d_decl" id="DeclarationExp">class <strong id="DeclarationExp">DeclarationExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>Declaration of a symbol </p>
<p>D grammar allows declarations only as statements. However in AST representation it can be part of any expression. This is used, for example, during internal syntax re-writes to inject hidden symbols.</p> </dd> <dt class="d_decl" id="TypeidExp">class <strong id="TypeidExp">TypeidExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>typeid(int)</p> </dd> <dt class="d_decl" id="TraitsExp">class <strong id="TraitsExp">TraitsExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>_traits(identifier, args...)</p> </dd> <dt class="d_decl" id="HaltExp">class <strong id="HaltExp">HaltExp</strong>: dmd.expression.Expression; </dt>  <dt class="d_decl" id="IsExp">class <strong id="IsExp">IsExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>is(targ id tok tspec) is(targ id == tok2)</p> </dd> <dt class="d_decl" id="UnaExp">abstract class <strong id="UnaExp">UnaExp</strong>: dmd.expression.Expression; </dt> <dd> <dl>
<dt class="d_decl" id="UnaExp.incompatibleTypes">final Expression <strong id="incompatibleTypes">incompatibleTypes</strong>(); </dt> <dd>
<p>The type for a unary expression is incompatible. Print error message. </p>
<dl>
<dt>Returns:</dt>
<dd>ErrorExp</dd>
</dl> </dd> <dt class="d_decl" id="UnaExp.setNoderefOperand">final void <strong id="setNoderefOperand">setNoderefOperand</strong>(); </dt> <dd>
<p>Mark the operand as will never be dereferenced, which is useful info for @safe checks. Do before semantic() on operands rewrites them.</p> </dd> </dl> </dd> <dt class="d_decl" id="BinExp">abstract class <strong id="BinExp">BinExp</strong>: dmd.expression.Expression; </dt> <dd> <dl>
<dt class="d_decl" id="BinExp.incompatibleTypes">final Expression <strong id="incompatibleTypes">incompatibleTypes</strong>(); </dt> <dd>
<p>The types for a binary expression are incompatible. Print error message. </p>
<dl>
<dt>Returns:</dt>
<dd>ErrorExp</dd>
</dl> </dd> <dt class="d_decl" id="BinExp.setNoderefOperands">final void <strong id="setNoderefOperands">setNoderefOperands</strong>(); </dt> <dd>
<p>Mark the operands as will never be dereferenced, which is useful info for @safe checks. Do before semantic() on operands rewrites them.</p> </dd> </dl> </dd> <dt class="d_decl" id="BinAssignExp">class <strong id="BinAssignExp">BinAssignExp</strong>: dmd.expression.BinExp; </dt>  <dt class="d_decl" id="CompileExp">class <strong id="CompileExp">CompileExp</strong>: dmd.expression.Expression; </dt> <dd>
<p><a href="https://dlang.org/spec/expression.html#mixin_expressions">https://dlang.org/spec/expression.html#mixin_expressions</a></p> </dd> <dt class="d_decl" id="ImportExp">class <strong id="ImportExp">ImportExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="AssertExp">class <strong id="AssertExp">AssertExp</strong>: dmd.expression.UnaExp; </dt> <dd>
<p><a href="https://dlang.org/spec/expression.html#assert_expressions">https://dlang.org/spec/expression.html#assert_expressions</a></p> </dd> <dt class="d_decl" id="DotIdExp">class <strong id="DotIdExp">DotIdExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="DotTemplateExp">class <strong id="DotTemplateExp">DotTemplateExp</strong>: dmd.expression.UnaExp; </dt> <dd>
<p>Mainly just a placeholder</p> </dd> <dt class="d_decl" id="DotVarExp">class <strong id="DotVarExp">DotVarExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="DotTemplateInstanceExp">class <strong id="DotTemplateInstanceExp">DotTemplateInstanceExp</strong>: dmd.expression.UnaExp; </dt> <dd>
<p>foo.bar!(args)</p> </dd> <dt class="d_decl" id="DelegateExp">class <strong id="DelegateExp">DelegateExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="DotTypeExp">class <strong id="DotTypeExp">DotTypeExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="CallExp">class <strong id="CallExp">CallExp</strong>: dmd.expression.UnaExp; </dt> <dd> <dl>
<dt class="d_decl" id="CallExp.this">this(ref const Loc loc, FuncDeclaration fd, Expression earg1); </dt> <dd>
<p>Instatiates a new function call expression </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Loc <code>loc</code>
</td> <td>location</td>
</tr> <tr>
<td>FuncDeclaration <code>fd</code>
</td> <td>the declaration of the function to call</td>
</tr> <tr>
<td>Expression <code>earg1</code>
</td> <td>the function argument</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="CallExp.create">static CallExp <strong id="create">create</strong>(Loc loc, FuncDeclaration fd, Expression earg1); </dt> <dd>
<p>Creates a new function call expression </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Loc <code>loc</code>
</td> <td>location</td>
</tr> <tr>
<td>FuncDeclaration <code>fd</code>
</td> <td>the declaration of the function to call</td>
</tr> <tr>
<td>Expression <code>earg1</code>
</td> <td>the function argument</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="AddrExp">class <strong id="AddrExp">AddrExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="PtrExp">class <strong id="PtrExp">PtrExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="NegExp">class <strong id="NegExp">NegExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="UAddExp">class <strong id="UAddExp">UAddExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="ComExp">class <strong id="ComExp">ComExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="NotExp">class <strong id="NotExp">NotExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="DeleteExp">class <strong id="DeleteExp">DeleteExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="CastExp">class <strong id="CastExp">CastExp</strong>: dmd.expression.UnaExp; </dt> <dd>
<p>Possible to cast to one type while painting to another type</p> </dd> <dt class="d_decl" id="VectorExp">class <strong id="VectorExp">VectorExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="VectorArrayExp">class <strong id="VectorArrayExp">VectorArrayExp</strong>: dmd.expression.UnaExp; </dt> <dd>
<p>e1.array property for vectors. </p>
<p><a href="https://dlang.org/spec/simd.html#properties">https://dlang.org/spec/simd.html#properties</a></p> </dd> <dt class="d_decl" id="SliceExp">class <strong id="SliceExp">SliceExp</strong>: dmd.expression.UnaExp; </dt> <dd>
<p>e1 [lwr .. upr] </p>
<p><a href="http://dlang.org/spec/expression.html#slice_expressions">http://dlang.org/spec/expression.html#slice_expressions</a></p> <dl>
<dt class="d_decl" id="SliceExp.this">this(ref const Loc loc, Expression e1, IntervalExp ie); </dt>  </dl> </dd> <dt class="d_decl" id="ArrayLengthExp">class <strong id="ArrayLengthExp">ArrayLengthExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="ArrayExp">class <strong id="ArrayExp">ArrayExp</strong>: dmd.expression.UnaExp; </dt> <dd>
<p>e1 [ a0, a1, a2, a3 ,... ] </p>
<p><a href="http://dlang.org/spec/expression.html#index_expressions">http://dlang.org/spec/expression.html#index_expressions</a></p> </dd> <dt class="d_decl" id="DotExp">class <strong id="DotExp">DotExp</strong>: dmd.expression.BinExp; </dt>  <dt class="d_decl" id="CommaExp">class <strong id="CommaExp">CommaExp</strong>: dmd.expression.BinExp; </dt> <dd> <dl>
<dt class="d_decl" id="CommaExp.isGenerated">const bool <strong id="isGenerated">isGenerated</strong>; </dt> <dd>
<p>This is needed because AssignExp rewrites CommaExp, hence it needs to trigger the deprecation.</p> </dd> <dt class="d_decl" id="CommaExp.allowCommaExp">bool <strong id="allowCommaExp">allowCommaExp</strong>; </dt> <dd>
<p>Temporary variable to enable / disable deprecation of comma expression depending on the context. Since most constructor calls are rewritting, the only place where false will be passed will be from the parser.</p> </dd> <dt class="d_decl" id="CommaExp.allow">static void <strong id="allow">allow</strong>(Expression exp); </dt> <dd>
<p>If the argument is a CommaExp, set a flag to prevent deprecation messages </p>
<p>It's impossible to know from CommaExp.semantic if the result will be used, hence when there is a result (type != void), a deprecation message is always emitted. However, some construct can produce a result but won't use it (ExpStatement and for loop increment). Those should call this function to prevent unwanted deprecations to be emitted. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Expression <code>exp</code>
</td> <td>An expression that discards its result. If the argument is null or not a CommaExp, nothing happens.</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="IntervalExp">class <strong id="IntervalExp">IntervalExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>Mainly just a placeholder</p> </dd> <dt class="d_decl" id="DelegateFuncptrExp">class <strong id="DelegateFuncptrExp">DelegateFuncptrExp</strong>: dmd.expression.UnaExp; </dt>  <dt class="d_decl" id="IndexExp">class <strong id="IndexExp">IndexExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p>e1 [ e2 ]</p> </dd> <dt class="d_decl" id="PostExp">class <strong id="PostExp">PostExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p>For both i++ and i--</p> </dd> <dt class="d_decl" id="PreExp">class <strong id="PreExp">PreExp</strong>: dmd.expression.UnaExp; </dt> <dd>
<p>For both ++i and --i</p> </dd> <dt class="d_decl" id="AssignExp">class <strong id="AssignExp">AssignExp</strong>: dmd.expression.BinExp; </dt> <dd> <dl>
<dt class="d_decl" id="AssignExp.this">this(ref const Loc loc, Expression e1, Expression e2); </dt>  </dl> </dd> <dt class="d_decl" id="ConstructExp">class <strong id="ConstructExp">ConstructExp</strong>: dmd.expression.AssignExp; </dt>  <dt class="d_decl" id="BlitExp">class <strong id="BlitExp">BlitExp</strong>: dmd.expression.AssignExp; </dt>  <dt class="d_decl" id="AddAssignExp">class <strong id="AddAssignExp">AddAssignExp</strong>: dmd.expression.BinAssignExp; </dt>  <dt class="d_decl" id="MinAssignExp">class <strong id="MinAssignExp">MinAssignExp</strong>: dmd.expression.BinAssignExp; </dt>  <dt class="d_decl" id="MulAssignExp">class <strong id="MulAssignExp">MulAssignExp</strong>: dmd.expression.BinAssignExp; </dt>  <dt class="d_decl" id="DivAssignExp">class <strong id="DivAssignExp">DivAssignExp</strong>: dmd.expression.BinAssignExp; </dt>  <dt class="d_decl" id="ModAssignExp">class <strong id="ModAssignExp">ModAssignExp</strong>: dmd.expression.BinAssignExp; </dt>  <dt class="d_decl" id="AndAssignExp">class <strong id="AndAssignExp">AndAssignExp</strong>: dmd.expression.BinAssignExp; </dt>  <dt class="d_decl" id="OrAssignExp">class <strong id="OrAssignExp">OrAssignExp</strong>: dmd.expression.BinAssignExp; </dt>  <dt class="d_decl" id="XorAssignExp">class <strong id="XorAssignExp">XorAssignExp</strong>: dmd.expression.BinAssignExp; </dt>  <dt class="d_decl" id="PowAssignExp">class <strong id="PowAssignExp">PowAssignExp</strong>: dmd.expression.BinAssignExp; </dt>  <dt class="d_decl" id="ShlAssignExp">class <strong id="ShlAssignExp">ShlAssignExp</strong>: dmd.expression.BinAssignExp; </dt>  <dt class="d_decl" id="ShrAssignExp">class <strong id="ShrAssignExp">ShrAssignExp</strong>: dmd.expression.BinAssignExp; </dt>  <dt class="d_decl" id="UshrAssignExp">class <strong id="UshrAssignExp">UshrAssignExp</strong>: dmd.expression.BinAssignExp; </dt>  <dt class="d_decl" id="CatAssignExp">class <strong id="CatAssignExp">CatAssignExp</strong>: dmd.expression.BinAssignExp; </dt> <dd>
<p>The ~= operator. It can have one of the following operators: </p>
<p>TOK.concatenateAssign - appending T[] to T[] TOK.concatenateElemAssign - appending T to T[] TOK.concatenateDcharAssign - appending dchar to T[] <br><br> The parser initially sets it to TOK.concatenateAssign, and semantic() later decides which of the three it will be set to.</p> </dd> <dt class="d_decl" id="CatElemAssignExp">class <strong id="CatElemAssignExp">CatElemAssignExp</strong>: dmd.expression.CatAssignExp; </dt>  <dt class="d_decl" id="CatDcharAssignExp">class <strong id="CatDcharAssignExp">CatDcharAssignExp</strong>: dmd.expression.CatAssignExp; </dt>  <dt class="d_decl" id="AddExp">class <strong id="AddExp">AddExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p><a href="http://dlang.org/spec/expression.html#add_expressions">http://dlang.org/spec/expression.html#add_expressions</a></p> </dd> <dt class="d_decl" id="MinExp">class <strong id="MinExp">MinExp</strong>: dmd.expression.BinExp; </dt>  <dt class="d_decl" id="CatExp">class <strong id="CatExp">CatExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p><a href="http://dlang.org/spec/expression.html#cat_expressions">http://dlang.org/spec/expression.html#cat_expressions</a></p> </dd> <dt class="d_decl" id="MulExp">class <strong id="MulExp">MulExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p><a href="http://dlang.org/spec/expression.html#mul_expressions">http://dlang.org/spec/expression.html#mul_expressions</a></p> </dd> <dt class="d_decl" id="DivExp">class <strong id="DivExp">DivExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p><a href="http://dlang.org/spec/expression.html#mul_expressions">http://dlang.org/spec/expression.html#mul_expressions</a></p> </dd> <dt class="d_decl" id="ModExp">class <strong id="ModExp">ModExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p><a href="http://dlang.org/spec/expression.html#mul_expressions">http://dlang.org/spec/expression.html#mul_expressions</a></p> </dd> <dt class="d_decl" id="PowExp">class <strong id="PowExp">PowExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p><a href="http://dlang.org/spec/expression.html#pow_expressions">http://dlang.org/spec/expression.html#pow_expressions</a></p> </dd> <dt class="d_decl" id="ShlExp">class <strong id="ShlExp">ShlExp</strong>: dmd.expression.BinExp; </dt>  <dt class="d_decl" id="ShrExp">class <strong id="ShrExp">ShrExp</strong>: dmd.expression.BinExp; </dt>  <dt class="d_decl" id="UshrExp">class <strong id="UshrExp">UshrExp</strong>: dmd.expression.BinExp; </dt>  <dt class="d_decl" id="AndExp">class <strong id="AndExp">AndExp</strong>: dmd.expression.BinExp; </dt>  <dt class="d_decl" id="OrExp">class <strong id="OrExp">OrExp</strong>: dmd.expression.BinExp; </dt>  <dt class="d_decl" id="XorExp">class <strong id="XorExp">XorExp</strong>: dmd.expression.BinExp; </dt>  <dt class="d_decl" id="LogicalExp">class <strong id="LogicalExp">LogicalExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p><a href="http://dlang.org/spec/expression.html#andand_expressions">http://dlang.org/spec/expression.html#andand_expressions</a> <a href="http://dlang.org/spec/expression.html#oror_expressions">http://dlang.org/spec/expression.html#oror_expressions</a></p> </dd> <dt class="d_decl" id="CmpExp">class <strong id="CmpExp">CmpExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p><code>op</code> is one of: TOK.lessThan, TOK.lessOrEqual, TOK.greaterThan, TOK.greaterOrEqual </p>
<p><a href="http://dlang.org/spec/expression.html#relation_expressions">http://dlang.org/spec/expression.html#relation_expressions</a></p> </dd> <dt class="d_decl" id="InExp">class <strong id="InExp">InExp</strong>: dmd.expression.BinExp; </dt>  <dt class="d_decl" id="RemoveExp">class <strong id="RemoveExp">RemoveExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p>This deletes the key e1 from the associative array e2</p> </dd> <dt class="d_decl" id="EqualExp">class <strong id="EqualExp">EqualExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p><code>==</code> and <code>!=</code> </p>
<p>TOK.equal and TOK.notEqual <br><br> <a href="http://dlang.org/spec/expression.html#equality_expressions">http://dlang.org/spec/expression.html#equality_expressions</a></p> </dd> <dt class="d_decl" id="IdentityExp">class <strong id="IdentityExp">IdentityExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p><code>is</code> and <code>!is</code> </p>
<p>TOK.identity and TOK.notIdentity <br><br> <a href="http://dlang.org/spec/expression.html#identity_expressions">http://dlang.org/spec/expression.html#identity_expressions</a></p> </dd> <dt class="d_decl" id="CondExp">class <strong id="CondExp">CondExp</strong>: dmd.expression.BinExp; </dt> <dd>
<p><code>econd ? e1 : e2</code> </p>
<p><a href="http://dlang.org/spec/expression.html#conditional_expressions">http://dlang.org/spec/expression.html#conditional_expressions</a></p> </dd> <dt class="d_decl" id="DefaultInitExp">class <strong id="DefaultInitExp">DefaultInitExp</strong>: dmd.expression.Expression; </dt>  <dt class="d_decl" id="FileInitExp">class <strong id="FileInitExp">FileInitExp</strong>: dmd.expression.DefaultInitExp; </dt>  <dt class="d_decl" id="LineInitExp">class <strong id="LineInitExp">LineInitExp</strong>: dmd.expression.DefaultInitExp; </dt>  <dt class="d_decl" id="ModuleInitExp">class <strong id="ModuleInitExp">ModuleInitExp</strong>: dmd.expression.DefaultInitExp; </dt>  <dt class="d_decl" id="FuncInitExp">class <strong id="FuncInitExp">FuncInitExp</strong>: dmd.expression.DefaultInitExp; </dt>  <dt class="d_decl" id="PrettyFuncInitExp">class <strong id="PrettyFuncInitExp">PrettyFuncInitExp</strong>: dmd.expression.DefaultInitExp; </dt>  <dt class="d_decl" id="ObjcClassReferenceExp">class <strong id="ObjcClassReferenceExp">ObjcClassReferenceExp</strong>: dmd.expression.Expression; </dt> <dd>
<p>Objective-C class reference expression. </p>
<p>Used to get the metaclass of an Objective-C class, <code>NSObject.Class</code>.</p> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/dmd_expression.html" class="_attribution-link">https://dlang.org/phobos/dmd_expression.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
