
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>dmd.mtype - D - W3cubDocs</title>
  
  <meta name="description" content=" Compiler implementation of the D programming language. ">
  <meta name="keywords" content="dmd, mtype, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/dmd_mtype.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/d.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>dmd.mtype</h1>  <p>Compiler implementation of the <a href="http://www.dlang.org">D programming language</a>. </p>
<dl>
<dt>Authors:</dt>
<dd>
<a href="http://www.digitalmars.com">Walter Bright</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/dmd/blob/master/src/dmd/mtype.d">mtype.d</a> </dd>
</dl> <dl>
<dt>Documentation</dt>
<dd> <a href="dmd_mtype">https://dlang.org/phobos/dmd_mtype.html</a> </dd>
</dl> <dl>
<dt>Coverage</dt>
<dd> <a href="https://codecov.io/gh/dlang/dmd/src/master/src/dmd/mtype.d">https://codecov.io/gh/dlang/dmd/src/master/src/dmd/mtype.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="MODimplicitConv">pure nothrow @nogc @safe bool <strong id="MODimplicitConv">MODimplicitConv</strong>(MOD modfrom, MOD modto); </dt> <dd>
<p>Return !=0 if modfrom can be implicitly converted to modto</p> </dd> <dt class="d_decl" id="MODmethodConv">pure nothrow @nogc @safe MATCH <strong id="MODmethodConv">MODmethodConv</strong>(MOD modfrom, MOD modto); </dt> <dd>
<p>Return MATCH.exact or MATCH.constant if a method of type '() modfrom' can call a method of type '() modto'.</p> </dd> <dt class="d_decl" id="MODmerge">pure nothrow @nogc @safe MOD <strong id="MODmerge">MODmerge</strong>(MOD mod1, MOD mod2); </dt> <dd>
<p>Merge mod bits to form common mod.</p> </dd> <dt class="d_decl" id="MODtoBuffer">nothrow void <strong id="MODtoBuffer">MODtoBuffer</strong>(OutBuffer* buf, MOD mod); </dt> <dd>
<p>Store modifier name into buf.</p> </dd> <dt class="d_decl" id="MODtoChars">pure nothrow const(char)* <strong id="MODtoChars">MODtoChars</strong>(MOD mod); <br><br>pure nothrow string <strong id="MODtoString">MODtoString</strong>(MOD mod); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>a human readable representation of <code>mod</code>, which is the token <code>mod</code> corresponds to</dd>
</dl> </dd> <dt class="d_decl" id="ModToStc">pure nothrow @nogc @safe StorageClass <strong id="ModToStc">ModToStc</strong>(uint mod); </dt> <dd>
<p>Convert MODxxxx to STCxxx</p> </dd> <dt class="d_decl" id="DotExpFlag">enum <strong id="DotExpFlag">DotExpFlag</strong>: int; </dt> <dd>
<p>dotExp() bit flags</p> </dd> <dt class="d_decl" id="VarArg">enum <strong id="VarArg">VarArg</strong>: int; </dt> <dd>
<p>Variadic argument lists <a href="https://dlang.org/spec/function.html#variadic">https://dlang.org/spec/function.html#variadic</a></p> <dl>
<dt class="d_decl" id="VarArg.none"><strong id="none">none</strong></dt> <dd>
<p>fixed number of arguments</p> </dd> <dt class="d_decl" id="VarArg.variadic"><strong id="variadic">variadic</strong></dt> <dd>
<p>(T t, ...) can be C-style (core.stdc.stdarg) or D-style (core.vararg)</p> </dd> <dt class="d_decl" id="VarArg.typesafe"><strong id="typesafe">typesafe</strong></dt> <dd>
<p>(T t ...) typesafe <a href="https://dlang.org/spec/function.html#typesafe_variadic_functions">https://dlang.org/spec/function.html#typesafe_variadic_functions</a></p> </dd> </dl> </dd> <dt class="d_decl" id="Type">abstract class <strong id="Type">Type</strong>: dmd.ast_node.ASTNode; </dt> <dd> <dl>
<dt class="d_decl" id="Type.covariant">final int <strong id="covariant">covariant</strong>(Type t, StorageClass* pstc = null, bool fix17349 = true); </dt> <dd>
<p>Covariant means that 'this' can substitute for 't', i.e. a pure function is a match for an impure type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>t</code>
</td> <td>type 'this' is covariant with</td>
</tr> <tr>
<td>StorageClass* <code>pstc</code>
</td> <td>if not null, store STCxxxx which would make it covariant</td>
</tr> <tr>
<td>bool <code>fix17349</code>
</td> <td>enable fix <a href="https://issues.dlang.org/show_bug.cgi?id=17349">https://issues.dlang.org/show_bug.cgi?id=17349</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>0 types are distinct 1 this is covariant with t 2 arguments match as far as overloading goes, but types are not covariant 3 cannot determine covariance because of forward references *pstc STCxxxx which would make it covariant</dd>
</dl> </dd> <dt class="d_decl" id="Type.toChars">final const(char)* <strong id="toChars">toChars</strong>(); <br><br>final char* <strong id="toPrettyChars">toPrettyChars</strong>(bool QualifyTypes = false); </dt> <dd>
<p>For pretty-printing a type.</p> </dd> <dt class="d_decl" id="Type.deinitialize">static void <strong id="deinitialize">deinitialize</strong>(); </dt> <dd>
<p>Deinitializes the global state of the compiler. </p>
<p>This can be used to restore the state set by <code>_init</code> to its original state.</p> </dd> <dt class="d_decl" id="Type.merge2">final Type <strong id="merge2">merge2</strong>(); </dt> <dd>
<p>This version does a merge even if the deco is already computed. Necessary for types that have a deco, but are not merged.</p> </dd> <dt class="d_decl" id="Type.modToBuffer">final const nothrow void <strong id="modToBuffer">modToBuffer</strong>(OutBuffer* buf); </dt> <dd>
<p>Store this type's modifier name into buf.</p> </dd> <dt class="d_decl" id="Type.modToChars">final const nothrow char* <strong id="modToChars">modToChars</strong>(); </dt> <dd>
<p>Return this type's modifier name.</p> </dd> <dt class="d_decl" id="Type.isAssignable">bool <strong id="isAssignable">isAssignable</strong>(); </dt> <dd>
<p>When T is mutable, </p>
<dl>
<dt>Given</dt>
<dd> T a, b; Can we bitwise assign: a = b; ?</dd>
</dl> </dd> <dt class="d_decl" id="Type.isBoolean">bool <strong id="isBoolean">isBoolean</strong>(); </dt> <dd>
<p>Returns true if T can be converted to boolean value.</p> </dd> <dt class="d_decl" id="Type.checkDeprecated">void <strong id="checkDeprecated">checkDeprecated</strong>(ref const Loc loc, Scope* sc); </dt> <dd>
<p>Check type to see if it is based on a deprecated symbol.</p> </dd> <dt class="d_decl" id="Type.nullAttributes">final const nothrow Type <strong id="nullAttributes">nullAttributes</strong>(); </dt> <dd>
<p>Return a copy of this type with all attributes null-initialized. Useful for creating a type with different modifiers.</p> </dd> <dt class="d_decl" id="Type.constOf">final Type <strong id="constOf">constOf</strong>(); </dt> <dd>
<p>Convert to 'const'.</p> </dd> <dt class="d_decl" id="Type.immutableOf">final Type <strong id="immutableOf">immutableOf</strong>(); </dt> <dd>
<p>Convert to 'immutable'.</p> </dd> <dt class="d_decl" id="Type.mutableOf">final Type <strong id="mutableOf">mutableOf</strong>(); </dt> <dd>
<p>Make type mutable.</p> </dd> <dt class="d_decl" id="Type.unSharedOf">final Type <strong id="unSharedOf">unSharedOf</strong>(); </dt> <dd>
<p>Make type unshared. 0 =&gt; 0 const =&gt; const immutable =&gt; immutable shared =&gt; 0 shared const =&gt; const wild =&gt; wild wild const =&gt; wild const shared wild =&gt; wild shared wild const =&gt; wild const</p> </dd> <dt class="d_decl" id="Type.wildOf">final Type <strong id="wildOf">wildOf</strong>(); </dt> <dd>
<p>Convert to 'wild'.</p> </dd> <dt class="d_decl" id="Type.fixTo">final void <strong id="fixTo">fixTo</strong>(Type t); </dt> <dd>
<p>For our new type 'this', which is type-constructed from t, fill in the cto, ito, sto, scto, wto shortcuts.</p> </dd> <dt class="d_decl" id="Type.check">final void <strong id="check">check</strong>(); </dt> <dd>
<p>Look for bugs in constructing types.</p> </dd> <dt class="d_decl" id="Type.addSTC">final Type <strong id="addSTC">addSTC</strong>(StorageClass stc); </dt> <dd>
<p>Apply STCxxxx bits to existing type. Use *before* semantic analysis is run.</p> </dd> <dt class="d_decl" id="Type.castMod">final Type <strong id="castMod">castMod</strong>(MOD mod); </dt> <dd>
<p>Apply MODxxxx bits to existing type.</p> </dd> <dt class="d_decl" id="Type.addMod">final Type <strong id="addMod">addMod</strong>(MOD mod); </dt> <dd>
<p>Add MODxxxx bits to existing type. We're adding, not replacing, so adding const to a shared type =&gt; "shared const"</p> </dd> <dt class="d_decl" id="Type.addStorageClass">Type <strong id="addStorageClass">addStorageClass</strong>(StorageClass stc); </dt> <dd>
<p>Add storage class modifiers to type.</p> </dd> <dt class="d_decl" id="Type.toBasetype">Type <strong id="toBasetype">toBasetype</strong>(); </dt> <dd>
<p>If this is a shell around another type, get that other type.</p> </dd> <dt class="d_decl" id="Type.implicitConvTo">MATCH <strong id="implicitConvTo">implicitConvTo</strong>(Type to); </dt> <dd>
<p>Determine if 'this' can be implicitly converted to type 'to'. </p>
<dl>
<dt>Returns:</dt>
<dd>MATCH.nomatch, MATCH.convert, MATCH.constant, MATCH.exact</dd>
</dl> </dd> <dt class="d_decl" id="Type.constConv">MATCH <strong id="constConv">constConv</strong>(Type to); </dt> <dd>
<p>Determine if converting 'this' to 'to' is an identity operation, a conversion to const operation, or the types aren't the same. </p>
<dl>
<dt>Returns:</dt>
<dd>MATCH.exact 'this' == 'to' MATCH.constant 'to' is const MATCH.nomatch conversion to mutable or invariant</dd>
</dl> </dd> <dt class="d_decl" id="Type.deduceWild">MOD <strong id="deduceWild">deduceWild</strong>(Type t, bool isRef); </dt> <dd>
<p>Compute MOD bits matching <code>this</code> argument type to wild parameter type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>t</code>
</td> <td>corresponding parameter type</td>
</tr> <tr>
<td>bool <code>isRef</code>
</td> <td>parameter is <code>ref</code> or <code>out</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>MOD bits</dd>
</dl> </dd> <dt class="d_decl" id="Type.toHeadMutable">Type <strong id="toHeadMutable">toHeadMutable</strong>(); </dt> <dd>
<p>Return type with the top level of it being mutable.</p> </dd> <dt class="d_decl" id="Type.alignment">structalign_t <strong id="alignment">alignment</strong>(); </dt> <dd>
<p>Return alignment to use for this type.</p> </dd> <dt class="d_decl" id="Type.defaultInitLiteral">Expression <strong id="defaultInitLiteral">defaultInitLiteral</strong>(ref const Loc loc); </dt> <dd>
<p>Use when we prefer the default initializer to be a literal, rather than a global immutable variable.</p> </dd> <dt class="d_decl" id="Type.hasWild">const int <strong id="hasWild">hasWild</strong>(); </dt> <dd>
<p>Return !=0 if the type or any of its subtypes is wild.</p> </dd> <dt class="d_decl" id="Type.hasPointers">bool <strong id="hasPointers">hasPointers</strong>(); </dt> <dd>
<p>Return !=0 if type has pointers that need to be scanned by the GC during a collection cycle.</p> </dd> <dt class="d_decl" id="Type.hasVoidInitPointers">bool <strong id="hasVoidInitPointers">hasVoidInitPointers</strong>(); </dt> <dd>
<p>Detect if type has pointer fields that are initialized to void. Local stack variables with such void fields can remain uninitialized, leading to pointer bugs. </p>
<dl>
<dt>Returns:</dt>
<dd>true if so</dd>
</dl> </dd> <dt class="d_decl" id="Type.nextOf">Type <strong id="nextOf">nextOf</strong>(); </dt> <dd>
<p>If this is a type of something, return that something.</p> </dd> <dt class="d_decl" id="Type.baseElemOf">final Type <strong id="baseElemOf">baseElemOf</strong>(); </dt> <dd>
<p>If this is a type of static array, return its base element type.</p> </dd> <dt class="d_decl" id="Type.numberOfElems">final uint <strong id="numberOfElems">numberOfElems</strong>(ref const Loc loc); </dt> <dd>
<p>Compute number of elements for a (possibly multidimensional) static array, or 1 for other types. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Loc <code>loc</code>
</td> <td>for error message</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>number of elements, uint.max on overflow</dd>
</dl> </dd> <dt class="d_decl" id="Type.sizemask">final uinteger_t <strong id="sizemask">sizemask</strong>(); </dt> <dd>
<p>Return the mask that an integral type will fit into.</p> </dd> <dt class="d_decl" id="Type.needsDestruction">bool <strong id="needsDestruction">needsDestruction</strong>(); </dt> <dd>
<p>true if when type goes out of scope, it needs a destructor applied. Only applies to value types, not ref types.</p> </dd> <dt class="d_decl" id="Type.needsNested">bool <strong id="needsNested">needsNested</strong>(); </dt>  <dt class="d_decl" id="Type.checkComplexTransition">final bool <strong id="checkComplexTransition">checkComplexTransition</strong>(ref const Loc loc, Scope* sc); </dt> <dd>
<p><a href="https://issues.dlang.org/show_bug.cgi?id=14488">https://issues.dlang.org/show_bug.cgi?id=14488</a> Check if the inner most base type is complex or imaginary. Should only give alerts when set to emit transitional messages. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Loc <code>loc</code>
</td> <td>The source location.</td>
</tr> <tr>
<td>Scope* <code>sc</code>
</td> <td>scope of the type</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="TypeError">class <strong id="TypeError">TypeError</strong>: dmd.mtype.Type; </dt>  <dt class="d_decl" id="TypeNext">abstract class <strong id="TypeNext">TypeNext</strong>: dmd.mtype.Type; </dt> <dd> <dl>
<dt class="d_decl" id="TypeNext.nextOf">final Type <strong id="nextOf">nextOf</strong>(); </dt> <dd>
<p>For TypeFunction, nextOf() can return NULL if the function return type is meant to be inferred, and semantic() hasn't yet ben run on the function. After semantic(), it must no longer be NULL.</p> </dd> </dl> </dd> <dt class="d_decl" id="TypeBasic">class <strong id="TypeBasic">TypeBasic</strong>: dmd.mtype.Type; </dt>  <dt class="d_decl" id="TypeVector">class <strong id="TypeVector">TypeVector</strong>: dmd.mtype.Type; </dt> <dd>
<p>The basetype must be one of: byte[16],ubyte[16],short[8],ushort[8],int[4],uint[4],long[2],ulong[2],float[4],double[2] For AVX: byte[32],ubyte[32],short[16],ushort[16],int[8],uint[8],long[4],ulong[4],float[8],double[4]</p> </dd> <dt class="d_decl" id="TypeArray">abstract class <strong id="TypeArray">TypeArray</strong>: dmd.mtype.TypeNext; </dt>  <dt class="d_decl" id="TypeSArray">class <strong id="TypeSArray">TypeSArray</strong>: dmd.mtype.TypeArray; </dt> <dd>
<p>Static array, one with a fixed dimension</p> <dl>
<dt class="d_decl" id="TypeSArray.needsNested">bool <strong id="needsNested">needsNested</strong>(); </dt>  </dl> </dd> <dt class="d_decl" id="TypeDArray">class <strong id="TypeDArray">TypeDArray</strong>: dmd.mtype.TypeArray; </dt> <dd>
<p>Dynamic array, no dimension</p> </dd> <dt class="d_decl" id="TypeAArray">class <strong id="TypeAArray">TypeAArray</strong>: dmd.mtype.TypeArray; </dt>  <dt class="d_decl" id="TypePointer">class <strong id="TypePointer">TypePointer</strong>: dmd.mtype.TypeNext; </dt>  <dt class="d_decl" id="TypeReference">class <strong id="TypeReference">TypeReference</strong>: dmd.mtype.TypeNext; </dt>  <dt class="d_decl" id="TypeFunction">class <strong id="TypeFunction">TypeFunction</strong>: dmd.mtype.TypeNext; </dt> <dd> <dl>
<dt class="d_decl" id="TypeFunction.purityLevel">void <strong id="purityLevel">purityLevel</strong>(); </dt> <dd>
<p>Set 'purity' field of 'this'. Do this lazily, as the parameter types might be forward referenced.</p> </dd> <dt class="d_decl" id="TypeFunction.hasLazyParameters">bool <strong id="hasLazyParameters">hasLazyParameters</strong>(); </dt> <dd>
<p>Return true if there are lazy parameters.</p> </dd> <dt class="d_decl" id="TypeFunction.parameterEscapes">bool <strong id="parameterEscapes">parameterEscapes</strong>(Type tthis, Parameter p); </dt> <dd>
<p>Examine function signature for parameter p and see if the value of p can 'escape' the scope of the function. This is useful to minimize the needed annotations for the parameters. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>tthis</code>
</td> <td>type of <code>this</code> parameter, null if none</td>
</tr> <tr>
<td>Parameter <code>p</code>
</td> <td>parameter to this function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if escapes via assignment to global or through a parameter</dd>
</dl> </dd> <dt class="d_decl" id="TypeFunction.parameterStorageClass">StorageClass <strong id="parameterStorageClass">parameterStorageClass</strong>(Type tthis, Parameter p); </dt> <dd>
<p>Take the specified storage class for p, and use the function signature to infer whether STC.scope_ and STC.return_ should be OR'd in. (This will not affect the name mangling.) </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>tthis</code>
</td> <td>type of <code>this</code> parameter, null if none</td>
</tr> <tr>
<td>Parameter <code>p</code>
</td> <td>parameter to this function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>storage class with STC.scope_ or STC.return_ OR'd in</dd>
</dl> </dd> <dt class="d_decl" id="TypeFunction.callMatch">MATCH <strong id="callMatch">callMatch</strong>(Type tthis, Expression[] args, int flag = 0, const(char)** pMessage = null, Scope* sc = null); </dt> <dd>
<p>'args' are being matched to function 'this' Determine match level. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>tthis</code>
</td> <td>type of <code>this</code> pointer, null if not member function</td>
</tr> <tr>
<td>Expression[] <code>args</code>
</td> <td>array of function arguments</td>
</tr> <tr>
<td>int <code>flag</code>
</td> <td>1: performing a partial ordering match</td>
</tr> <tr>
<td>const(char)** <code>pMessage</code>
</td> <td>address to store error message, or null</td>
</tr> <tr>
<td>Scope* <code>sc</code>
</td> <td>context</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>MATCHxxxx</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="TypeDelegate">class <strong id="TypeDelegate">TypeDelegate</strong>: dmd.mtype.TypeNext; </dt>  <dt class="d_decl" id="TypeTraits">class <strong id="TypeTraits">TypeTraits</strong>: dmd.mtype.Type; </dt> <dd>
<p>This is a shell containing a TraitsExp that can be either resolved to a type or to a symbol. </p>
<p>The point is to allow AliasDeclarationY to use <code>__traits()</code>, see issue 7804.</p> <dl>
<dt class="d_decl" id="TypeTraits.exp">TraitsExp <strong id="exp">exp</strong>; </dt> <dd>
<p>The expression to resolve as type or symbol.</p> </dd> <dt class="d_decl" id="TypeTraits.sym">Dsymbol <strong id="sym">sym</strong>; </dt> <dd>
<p>After <code>typeSemantic</code> the symbol when <code>exp</code> doesn't represent a type.</p> </dd> </dl> </dd> <dt class="d_decl" id="TypeMixin">class <strong id="TypeMixin">TypeMixin</strong>: dmd.mtype.Type; </dt> <dd>
<p>Implements mixin types. </p>
<p>Semantic analysis will convert it to a real type.</p> </dd> <dt class="d_decl" id="TypeQualified">abstract class <strong id="TypeQualified">TypeQualified</strong>: dmd.mtype.Type; </dt>  <dt class="d_decl" id="TypeIdentifier">class <strong id="TypeIdentifier">TypeIdentifier</strong>: dmd.mtype.TypeQualified; </dt> <dd> <dl>
<dt class="d_decl" id="TypeIdentifier.toDsymbol">Dsymbol <strong id="toDsymbol">toDsymbol</strong>(Scope* sc); </dt> <dd>
<p>See if type resolves to a symbol, if so, return that symbol.</p> </dd> </dl> </dd> <dt class="d_decl" id="TypeInstance">class <strong id="TypeInstance">TypeInstance</strong>: dmd.mtype.TypeQualified; </dt> <dd>
<p>Similar to TypeIdentifier, but with a TemplateInstance as the root</p> </dd> <dt class="d_decl" id="TypeTypeof">class <strong id="TypeTypeof">TypeTypeof</strong>: dmd.mtype.TypeQualified; </dt>  <dt class="d_decl" id="TypeReturn">class <strong id="TypeReturn">TypeReturn</strong>: dmd.mtype.TypeQualified; </dt>  <dt class="d_decl" id="TypeStruct">class <strong id="TypeStruct">TypeStruct</strong>: dmd.mtype.Type; </dt> <dd> <dl>
<dt class="d_decl" id="TypeStruct.defaultInitLiteral">Expression <strong id="defaultInitLiteral">defaultInitLiteral</strong>(ref const Loc loc); </dt> <dd>
<p>Use when we prefer the default initializer to be a literal, rather than a global immutable variable.</p> </dd> </dl> </dd> <dt class="d_decl" id="TypeEnum">class <strong id="TypeEnum">TypeEnum</strong>: dmd.mtype.Type; </dt>  <dt class="d_decl" id="TypeClass">class <strong id="TypeClass">TypeClass</strong>: dmd.mtype.Type; </dt>  <dt class="d_decl" id="TypeTuple">class <strong id="TypeTuple">TypeTuple</strong>: dmd.mtype.Type; </dt> <dd> <dl>
<dt class="d_decl" id="TypeTuple.this">this(Expressions* exps); </dt> <dd>
<p>Form TypeTuple from the types of the expressions. Assume exps[] is already tuple expanded.</p> </dd> <dt class="d_decl" id="TypeTuple.this.2">this(); </dt> <dd>
<p>Type tuple with 0, 1 or 2 types in it.</p> </dd> </dl> </dd> <dt class="d_decl" id="TypeSlice">class <strong id="TypeSlice">TypeSlice</strong>: dmd.mtype.TypeNext; </dt> <dd>
<p>This is so we can slice a TypeTuple</p> </dd> <dt class="d_decl" id="TypeNull">class <strong id="TypeNull">TypeNull</strong>: dmd.mtype.Type; </dt>  <dt class="d_decl" id="ParameterList">struct <strong id="ParameterList">ParameterList</strong>; </dt> <dd>
<p>Encapsulate Parameters* so .length and [i] can be used on it. <a href="https://dlang.org/spec/function.html#ParameterList">https://dlang.org/spec/function.html#ParameterList</a></p> </dd> <dt class="d_decl" id="Parameter">class <strong id="Parameter">Parameter</strong>: dmd.ast_node.ASTNode; </dt> <dd> <dl>
<dt class="d_decl" id="Parameter.isLazyArray">Type <strong id="isLazyArray">isLazyArray</strong>(); </dt> <dd>
<p>Determine if parameter is a lazy array of delegates. If so, return the return type of those delegates. If not, return NULL. </p>
<p>Returns T if the type is one of the following forms: T delegate()[] T delegate()[dim]</p> </dd> <dt class="d_decl" id="Parameter.dim">static size_t <strong id="dim">dim</strong>(Parameters* parameters); </dt> <dd>
<p>Determine number of arguments, folding in tuples.</p> </dd> <dt class="d_decl" id="Parameter.getNth">static Parameter <strong id="getNth">getNth</strong>(Parameters* parameters, size_t nth, size_t* pn = null); </dt> <dd>
<p>Get nth Parameter, folding in tuples. </p>
<dl>
<dt>Returns:</dt>
<dd>Parameter* nth Parameter NULL not found, *pn gets incremented by the number of Parameters</dd>
</dl> </dd> <dt class="d_decl" id="Parameter._foreach">static int <strong id="_foreach">_foreach</strong>(Parameters* parameters, scope ForeachDg dg, size_t* pn = null); </dt> <dd>
<p>Expands tuples in args in depth first order. Calls dg(void *ctx, size_t argidx, Parameter *arg) for each Parameter. If dg returns !=0, stops and returns that value else returns 0. Use this function to avoid the O(N + N^2/2) complexity of calculating dim and calling N times getNth.</p> </dd> <dt class="d_decl" id="Parameter.isCovariant">const pure nothrow @nogc @safe bool <strong id="isCovariant">isCovariant</strong>(bool returnByRef, const Parameter p); </dt> <dd>
<p>Compute covariance of parameters <code>this</code> and <code>p</code> as determined by the storage classes of both. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>bool <code>returnByRef</code>
</td> <td>true if the function returns by ref</td>
</tr> <tr>
<td>Parameter <code>p</code>
</td> <td>Parameter to compare with</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true = <code>this</code> can be used in place of <code>p</code> false = nope</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="toAutoQualChars">const(char*)[2] <strong id="toAutoQualChars">toAutoQualChars</strong>(Type t1, Type t2); </dt> <dd>
<p>For printing two types with qualification when necessary. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>t1</code>
</td> <td>The first type to receive the type name for</td>
</tr> <tr>
<td>Type <code>t2</code>
</td> <td>The second type to receive the type name for</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The fully-qualified names of both types if the two type names are not the same, or the unqualified names of both types if the two type names are the same.</dd>
</dl> </dd> <dt class="d_decl" id="modifiersApply">void <strong id="modifiersApply">modifiersApply</strong>(const TypeFunction tf, void delegate(string) dg); </dt> <dd>
<p>For each active modifier (MODFlags.const_, MODFlags.immutable_, etc) call <code>fp</code> with a void* for the work param and a string representation of the attribute.</p> </dd> <dt class="d_decl" id="attributesApply">void <strong id="attributesApply">attributesApply</strong>(const TypeFunction tf, void delegate(string) dg, TRUSTformat trustFormat = TRUSTformatDefault); </dt> <dd>
<p>For each active attribute (ref/const/nogc/etc) call <code>fp</code> with a void* for the work param and a string representation of the attribute.</p> </dd> <dt class="d_decl" id="isAggregate">AggregateDeclaration <strong id="isAggregate">isAggregate</strong>(Type t); </dt> <dd>
<p>If the type is a class or struct, returns the symbol for it, else null.</p> </dd> <dt class="d_decl" id="isIndexableNonAggregate">bool <strong id="isIndexableNonAggregate">isIndexableNonAggregate</strong>(Type t); </dt> <dd>
<p>Determine if type t can be indexed or sliced given that it is not an aggregate with operator overloads. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>t</code>
</td> <td>type to check</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if an expression of type t can be e1 in an array expression</dd>
</dl> </dd> <dt class="d_decl" id="isCopyable">pure nothrow @nogc bool <strong id="isCopyable">isCopyable</strong>(const Type t); </dt> <dd>
<p>Determine if type t is copyable. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>t</code>
</td> <td>type to check</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if we can copy it</dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/dmd_mtype.html" class="_attribution-link">https://dlang.org/phobos/dmd_mtype.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
