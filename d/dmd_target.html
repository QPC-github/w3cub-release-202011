
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>dmd.target - D - W3cubDocs</title>
  
  <meta name="description" content=" Compiler implementation of the D programming language. ">
  <meta name="keywords" content="dmd, target, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/dmd_target.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/d.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>dmd.target</h1>  <p>Compiler implementation of the <a href="http://www.dlang.org">D programming language</a>. </p>
<dl>
<dt>Authors:</dt>
<dd>
<a href="http://www.digitalmars.com">Walter Bright</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/dmd/blob/master/src/dmd/target.d">target.d</a> </dd>
</dl> <dl>
<dt>Documentation</dt>
<dd> <a href="dmd_target">https://dlang.org/phobos/dmd_target.html</a> </dd>
</dl> <dl>
<dt>Coverage</dt>
<dd> <a href="https://codecov.io/gh/dlang/dmd/src/master/src/dmd/target.d">https://codecov.io/gh/dlang/dmd/src/master/src/dmd/target.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="Target">struct <strong id="Target">Target</strong>; </dt> <dd>
<p>Describes a back-end target. At present it is incomplete, but in the future it should grow to contain most or all target machine and target O/S specific information. </p>
<p>In many cases, calls to sizeof() can't be used directly for getting data type sizes since cross compiling is supported and would end up using the host sizes rather than the target sizes.</p> <dl>
<dt class="d_decl" id="Target.ptrsize">uint <strong id="ptrsize">ptrsize</strong>; </dt> <dd>
<p>size of a pointer in bytes</p> </dd> <dt class="d_decl" id="Target.realsize">uint <strong id="realsize">realsize</strong>; </dt> <dd>
<p>size a real consumes in memory</p> </dd> <dt class="d_decl" id="Target.realpad">uint <strong id="realpad">realpad</strong>; </dt> <dd>
<p>padding added to the CPU real size to bring it up to realsize</p> </dd> <dt class="d_decl" id="Target.realalignsize">uint <strong id="realalignsize">realalignsize</strong>; </dt> <dd>
<p>alignment for reals</p> </dd> <dt class="d_decl" id="Target.classinfosize">uint <strong id="classinfosize">classinfosize</strong>; </dt> <dd>
<p>size of <code>ClassInfo</code></p> </dd> <dt class="d_decl" id="Target.maxStaticDataSize">ulong <strong id="maxStaticDataSize">maxStaticDataSize</strong>; </dt> <dd>
<p>maximum size of static data</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties">struct <strong id="FPTypeProperties">FPTypeProperties</strong>(T); </dt> <dd>
<p>Values representing all properties for floating point types</p> <dl>
<dt class="d_decl" id="Target.FPTypeProperties.max">real_t <strong id="max">max</strong>; </dt> <dd>
<p>largest representable value that's not infinity</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.min_normal">real_t <strong id="min_normal">min_normal</strong>; </dt> <dd>
<p>smallest representable normalized value that's not 0</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.nan">real_t <strong id="nan">nan</strong>; </dt> <dd>
<p>NaN value</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.infinity">real_t <strong id="infinity">infinity</strong>; </dt> <dd>
<p>infinity value</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.epsilon">real_t <strong id="epsilon">epsilon</strong>; </dt> <dd>
<p>smallest increment to the value 1</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.dig">d_int64 <strong id="dig">dig</strong>; </dt> <dd>
<p>number of decimal digits of precision</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.mant_dig">d_int64 <strong id="mant_dig">mant_dig</strong>; </dt> <dd>
<p>number of bits in mantissa</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.max_exp">d_int64 <strong id="max_exp">max_exp</strong>; </dt> <dd>
<p>maximum int value such that 2<sup><code>max_exp-1</code></sup> is representable</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.min_exp">d_int64 <strong id="min_exp">min_exp</strong>; </dt> <dd>
<p>minimum int value such that 2<sup><code>min_exp-1</code></sup> is representable as a normalized value</p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.max_10_exp">d_int64 <strong id="max_10_exp">max_10_exp</strong>; </dt> <dd>
<p>maximum int value such that 10<sup><code>max_10_exp</code> is representable</sup></p> </dd> <dt class="d_decl" id="Target.FPTypeProperties.min_10_exp">d_int64 <strong id="min_10_exp">min_10_exp</strong>; </dt> <dd>
<p>minimum int value such that 10<sup><code>min_10_exp</code></sup> is representable as a normalized value</p> </dd> </dl> </dd> <dt class="d_decl" id="Target.FloatProperties">FPTypeProperties!float <strong id="FloatProperties">FloatProperties</strong>; </dt>  <dt class="d_decl" id="Target.DoubleProperties">FPTypeProperties!double <strong id="DoubleProperties">DoubleProperties</strong>; </dt>  <dt class="d_decl" id="Target.RealProperties">FPTypeProperties!real_t <strong id="RealProperties">RealProperties</strong>; </dt>  <dt class="d_decl" id="Target._init">void <strong id="_init">_init</strong>(ref const Param params); </dt> <dd>
<p>Initialize the Target</p> </dd> <dt class="d_decl" id="Target.deinitialize">void <strong id="deinitialize">deinitialize</strong>(); </dt> <dd>
<p>Deinitializes the global state of the compiler. </p>
<p>This can be used to restore the state set by <code>_init</code> to its original state.</p> </dd> <dt class="d_decl" id="Target.alignsize">uint <strong id="alignsize">alignsize</strong>(Type type); </dt> <dd>
<p>Requested target memory alignment size of the given type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>type</code>
</td> <td>type to inspect</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>alignment in bytes</dd>
</dl> </dd> <dt class="d_decl" id="Target.fieldalign">uint <strong id="fieldalign">fieldalign</strong>(Type type); </dt> <dd>
<p>Requested target field alignment size of the given type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>type</code>
</td> <td>type to inspect</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>alignment in bytes</dd>
</dl> </dd> <dt class="d_decl" id="Target.critsecsize">uint <strong id="critsecsize">critsecsize</strong>(); </dt> <dd>
<p>Size of the target OS critical section. </p>
<dl>
<dt>Returns:</dt>
<dd>size in bytes</dd>
</dl> </dd> <dt class="d_decl" id="Target.va_listType">Type <strong id="va_listType">va_listType</strong>(); </dt> <dd>
<p>Type for the <code>va_list</code> type for the target. </p>
<dl>
<dt>NOTE</dt>
<dd> For Posix/x86_64 this returns the type which will really be used for passing an argument of type va_list. </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>Type</code> that represents <code>va_list</code>.</dd>
</dl> </dd> <dt class="d_decl" id="Target.isVectorTypeSupported">int <strong id="isVectorTypeSupported">isVectorTypeSupported</strong>(int sz, Type type); </dt> <dd>
<p>Checks whether the target supports a vector type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>sz</code>
</td> <td>vector type size in bytes</td>
</tr> <tr>
<td>Type <code>type</code>
</td> <td>vector element type</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>0 vector type is supported, 1 vector type is not supported on the target at all 2 vector element type is not supported 3 vector size is not supported</dd>
</dl> </dd> <dt class="d_decl" id="Target.isVectorOpSupported">bool <strong id="isVectorOpSupported">isVectorOpSupported</strong>(Type type, ubyte op, Type t2 = null); </dt> <dd>
<p>Checks whether the target supports the given operation for vectors. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>type</code>
</td> <td>target type of operation</td>
</tr> <tr>
<td>ubyte <code>op</code>
</td> <td>the unary or binary op being done on the <code>type</code>
</td>
</tr> <tr>
<td>Type <code>t2</code>
</td> <td>type of second operand if <code>op</code> is a binary operation</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if the operation is supported or type is not a vector</dd>
</dl> </dd> <dt class="d_decl" id="Target.systemLinkage">LINK <strong id="systemLinkage">systemLinkage</strong>(); </dt> <dd>
<p>Default system linkage for the target. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>LINK</code> to use for <code>extern(System)</code>
</dd>
</dl> </dd> <dt class="d_decl" id="Target.toArgTypes">TypeTuple <strong id="toArgTypes">toArgTypes</strong>(Type t); </dt> <dd>
<p>Describes how an argument type is passed to a function on target. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>t</code>
</td> <td>type to break down</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>tuple of types if type is passed in one or more registers empty tuple if type is always passed on the stack null if the type is a <code>void</code> or argtypes aren't supported by the target</dd>
</dl> </dd> <dt class="d_decl" id="Target.isReturnOnStack">bool <strong id="isReturnOnStack">isReturnOnStack</strong>(TypeFunction tf, bool needsThis); </dt> <dd>
<p>Determine return style of function - whether in registers or through a hidden pointer to the caller's stack. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TypeFunction <code>tf</code>
</td> <td>function type to check</td>
</tr> <tr>
<td>bool <code>needsThis</code>
</td> <td>true if the function type is for a non-static member function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if return value from function is on the stack</dd>
</dl> </dd> <dt class="d_decl" id="Target.parameterSize">ulong <strong id="parameterSize">parameterSize</strong>(ref const Loc loc, Type t); </dt> <dd>
<p>Determine the size a value of type <code>t</code> will be when it is passed on the function parameter stack. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Loc <code>loc</code>
</td> <td>location to use for error messages</td>
</tr> <tr>
<td>Type <code>t</code>
</td> <td>type of parameter</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>size used on parameter stack</dd>
</dl> </dd> <dt class="d_decl" id="Target.getTargetInfo">Expression <strong id="getTargetInfo">getTargetInfo</strong>(const(char)* name, ref const Loc loc); </dt> <dd>
<p>Get targetInfo by key </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)* <code>name</code>
</td> <td>name of targetInfo to get</td>
</tr> <tr>
<td>Loc <code>loc</code>
</td> <td>location to use for error messages</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Expression for the requested targetInfo</dd>
</dl> </dd> <dt class="d_decl" id="Target.isXmmSupported">bool <strong id="isXmmSupported">isXmmSupported</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>true if xmm usage is supported</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="TargetC">struct <strong id="TargetC">TargetC</strong>; </dt> <dd>
<p>Functions and variables specific to interfacing with extern(C) ABI.</p> <dl>
<dt class="d_decl" id="TargetC.longsize">uint <strong id="longsize">longsize</strong>; </dt> <dd>
<p>size of a C <code>long</code> or <code>unsigned long</code> type</p> </dd> <dt class="d_decl" id="TargetC.long_doublesize">uint <strong id="long_doublesize">long_doublesize</strong>; </dt> <dd>
<p>size of a C <code>long double</code></p> </dd> <dt class="d_decl" id="TargetC.criticalSectionSize">uint <strong id="criticalSectionSize">criticalSectionSize</strong>; </dt> <dd>
<p>size of os critical section</p> </dd> </dl> </dd> <dt class="d_decl" id="TargetCPP">struct <strong id="TargetCPP">TargetCPP</strong>; </dt> <dd>
<p>Functions and variables specific to interface with extern(C++) ABI.</p> <dl>
<dt class="d_decl" id="TargetCPP.reverseOverloads">bool <strong id="reverseOverloads">reverseOverloads</strong>; </dt> <dd>
<p>set if overloaded functions are grouped and in reverse order (such as in dmc and cl)</p> </dd> <dt class="d_decl" id="TargetCPP.exceptions">bool <strong id="exceptions">exceptions</strong>; </dt> <dd>
<p>set if catching C++ exceptions is supported</p> </dd> <dt class="d_decl" id="TargetCPP.twoDtorInVtable">bool <strong id="twoDtorInVtable">twoDtorInVtable</strong>; </dt> <dd>
<p>target C++ ABI puts deleting and non-deleting destructor into vtable</p> </dd> <dt class="d_decl" id="TargetCPP.toMangle">const(char)* <strong id="toMangle">toMangle</strong>(Dsymbol s); </dt> <dd>
<p>Mangle the given symbol for C++ ABI. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Dsymbol <code>s</code>
</td> <td>declaration with C++ linkage</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>string mangling of symbol</dd>
</dl> </dd> <dt class="d_decl" id="TargetCPP.typeInfoMangle">const(char)* <strong id="typeInfoMangle">typeInfoMangle</strong>(ClassDeclaration cd); </dt> <dd>
<p>Get RTTI mangling of the given class declaration for C++ ABI. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ClassDeclaration <code>cd</code>
</td> <td>class with C++ linkage</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>string mangling of C++ typeinfo</dd>
</dl> </dd> <dt class="d_decl" id="TargetCPP.typeMangle">const(char)* <strong id="typeMangle">typeMangle</strong>(Type t); </dt> <dd>
<p>Gets vendor-specific type mangling for C++ ABI. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>t</code>
</td> <td>type to inspect</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>string if type is mangled specially on target null if unhandled</dd>
</dl> </dd> <dt class="d_decl" id="TargetCPP.parameterType">Type <strong id="parameterType">parameterType</strong>(Parameter p); </dt> <dd>
<p>Get the type that will really be used for passing the given argument to an <code>extern(C++)</code> function. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Parameter <code>p</code>
</td> <td>parameter to be passed.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>Type</code> to use for parameter <code>p</code>.</dd>
</dl> </dd> <dt class="d_decl" id="TargetCPP.fundamentalType">bool <strong id="fundamentalType">fundamentalType</strong>(const Type t, ref bool isFundamental); </dt> <dd>
<p>Checks whether type is a vendor-specific fundamental type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>t</code>
</td> <td>type to inspect</td>
</tr> <tr>
<td>bool <code>isFundamental</code>
</td> <td>where to store result</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if isFundamental was set by function</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="target">Target <strong id="target">target</strong>; </dt>  </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/dmd_target.html" class="_attribution-link">https://dlang.org/phobos/dmd_target.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
