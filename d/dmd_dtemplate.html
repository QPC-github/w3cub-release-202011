
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>dmd.dtemplate - D - W3cubDocs</title>
  
  <meta name="description" content=" Compiler implementation of the D programming language. ">
  <meta name="keywords" content="dmd, dtemplate, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/dmd_dtemplate.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>dmd.dtemplate</h1>  <p>Compiler implementation of the <a href="http://www.dlang.org">D programming language</a>. </p>
<p>Template implementation. </p> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://www.digitalmars.com">Walter Bright</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/dmd/blob/master/src/dmd/dtemplate.d">dtemplate.d</a> </dd>
</dl> <dl>
<dt>Documentation</dt>
<dd> <a href="dmd_dtemplate">https://dlang.org/phobos/dmd_dtemplate.html</a> </dd>
</dl> <dl>
<dt>Coverage</dt>
<dd> <a href="https://codecov.io/gh/dlang/dmd/src/master/src/dmd/dtemplate.d">https://codecov.io/gh/dlang/dmd/src/master/src/dmd/dtemplate.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="isExpression">pure nothrow @nogc inout(Expression) <strong id="isExpression">isExpression</strong>(inout RootObject o); </dt> <dd>
<p>These functions substitute for dynamic_cast. dynamic_cast does not work on earlier versions of gcc.</p> </dd> <dt class="d_decl" id="isError">pure nothrow @nogc bool <strong id="isError">isError</strong>(const RootObject o); </dt> <dd>
<p>Is this Object an error?</p> </dd> <dt class="d_decl" id="arrayObjectIsError">pure nothrow @nogc bool <strong id="arrayObjectIsError">arrayObjectIsError</strong>(const Objects* args); </dt> <dd>
<p>Are any of the Objects an error?</p> </dd> <dt class="d_decl" id="getType">pure nothrow @nogc inout(Type) <strong id="getType">getType</strong>(inout RootObject o); </dt> <dd>
<p>Try to get arg as a type.</p> </dd> <dt class="d_decl" id="TemplateDeclaration">class <strong id="TemplateDeclaration">TemplateDeclaration</strong>: dmd.dsymbol.ScopeDsymbol; </dt> <dd>
<p>[mixin] template Identifier (parameters) [Constraint] <a href="https://dlang.org/spec/template.html">https://dlang.org/spec/template.html</a> <a href="https://dlang.org/spec/template-mixin.html">https://dlang.org/spec/template-mixin.html</a></p> <dl>
<dt class="d_decl" id="TemplateDeclaration.inuse">int <strong id="inuse">inuse</strong>; </dt> <dd>
<p>for recursive expansion detection</p> </dd> <dt class="d_decl" id="TemplateDeclaration.overloadInsert">bool <strong id="overloadInsert">overloadInsert</strong>(Dsymbol s); </dt> <dd>
<p>Overload existing TemplateDeclaration 'this' with the new one 's'. Return true if successful; i.e. no conflict.</p> </dd> <dt class="d_decl" id="TemplateDeclaration.toCharsNoConstraints">const(char)* <strong id="toCharsNoConstraints">toCharsNoConstraints</strong>(); </dt> <dd>
<p>Similar to <code>toChars</code>, but does not print the template constraints</p> </dd> <dt class="d_decl" id="TemplateDeclaration.evaluateConstraint">bool <strong id="evaluateConstraint">evaluateConstraint</strong>(TemplateInstance ti, Scope* sc, Scope* paramscope, Objects* dedargs, FuncDeclaration fd); </dt> <dd>
<p>Check to see if constraint is satisfied.</p> </dd> <dt class="d_decl" id="TemplateDeclaration.getConstraintEvalError">const(char)* <strong id="getConstraintEvalError">getConstraintEvalError</strong>(ref const(char)* tip); </dt> <dd>
<p>Destructively get the error message from the last constraint evaluation </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)* <code>tip</code>
</td> <td>tip to show after printing all overloads</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="TemplateDeclaration.scopeForTemplateParameters">Scope* <strong id="scopeForTemplateParameters">scopeForTemplateParameters</strong>(TemplateInstance ti, Scope* sc); </dt> <dd>
<p>Create a scope for the parameters of the TemplateInstance <code>ti</code> in the parent scope sc from the ScopeDsymbol paramsym. </p>
<p>If paramsym is null a new ScopeDsymbol is used in place of paramsym. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TemplateInstance <code>ti</code>
</td> <td>the TemplateInstance whose parameters to generate the scope for.</td>
</tr> <tr>
<td>Scope* <code>sc</code>
</td> <td>the parent scope of ti</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a scope for the parameters of ti</dd>
</dl> </dd> <dt class="d_decl" id="TemplateDeclaration.matchWithInstance">MATCH <strong id="matchWithInstance">matchWithInstance</strong>(Scope* sc, TemplateInstance ti, Objects* dedtypes, Expressions* fargs, int flag); </dt> <dd>
<p>Given that ti is an instance of this TemplateDeclaration, deduce the types of the parameters to this, and store those deduced types in dedtypes[]. </p>
<dl>
<dt>Input</dt>
<dd> flag 1: don't do semantic() because of dummy types 2: don't change types in matchArg() </dd>
</dl> <dl>
<dt>Output</dt>
<dd> dedtypes deduced arguments Return match level.</dd>
</dl> </dd> <dt class="d_decl" id="TemplateDeclaration.leastAsSpecialized">MATCH <strong id="leastAsSpecialized">leastAsSpecialized</strong>(Scope* sc, TemplateDeclaration td2, Expressions* fargs); </dt> <dd>
<p>Determine partial specialization order of 'this' vs td2. </p>
<dl>
<dt>Returns:</dt>
<dd>match this is at least as specialized as td2 0 td2 is more specialized than this</dd>
</dl> </dd> <dt class="d_decl" id="TemplateDeclaration.deduceFunctionTemplateMatch">MATCH <strong id="deduceFunctionTemplateMatch">deduceFunctionTemplateMatch</strong>(TemplateInstance ti, Scope* sc, ref FuncDeclaration fd, Type tthis, Expressions* fargs); </dt> <dd>
<p>Match function arguments against a specific template function. </p>
<dl>
<dt>Input</dt>
<dd> ti sc instantiation scope fd tthis 'this' argument if !NULL fargs arguments to function </dd>
</dl> <dl>
<dt>Output</dt>
<dd> fd Partially instantiated function declaration ti.tdtypes Expression/Type deduced template arguments </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>match level bit 0-3 Match template parameters by inferred template arguments bit 4-7 Match template parameters by initial template arguments</dd>
</dl> </dd> <dt class="d_decl" id="TemplateDeclaration.declareParameter">RootObject <strong id="declareParameter">declareParameter</strong>(Scope* sc, TemplateParameter tp, RootObject o); </dt> <dd>
<p>Declare template parameter tp with value o, and install it in the scope sc.</p> </dd> <dt class="d_decl" id="TemplateDeclaration.doHeaderInstantiation">FuncDeclaration <strong id="doHeaderInstantiation">doHeaderInstantiation</strong>(TemplateInstance ti, Scope* sc2, FuncDeclaration fd, Type tthis, Expressions* fargs); </dt> <dd>
<p>Limited function template instantiation for using fd.leastAsSpecialized()</p> </dd> <dt class="d_decl" id="TemplateDeclaration.findExistingInstance">TemplateInstance <strong id="findExistingInstance">findExistingInstance</strong>(TemplateInstance tithis, Expressions* fargs); </dt> <dd>
<p>Given a new instance tithis of this TemplateDeclaration, see if there already exists an instance. If so, return that existing instance.</p> </dd> <dt class="d_decl" id="TemplateDeclaration.addInstance">TemplateInstance <strong id="addInstance">addInstance</strong>(TemplateInstance ti); </dt> <dd>
<p>Add instance ti to TemplateDeclaration's table of instances. Return a handle we can use to later remove it if it fails instantiation.</p> </dd> <dt class="d_decl" id="TemplateDeclaration.removeInstance">void <strong id="removeInstance">removeInstance</strong>(TemplateInstance ti); </dt> <dd>
<p>Remove TemplateInstance from table of instances. </p>
<dl>
<dt>Input</dt>
<dd> handle returned by addInstance()</dd>
</dl> </dd> <dt class="d_decl" id="TemplateDeclaration.isVariadic">TemplateTupleParameter <strong id="isVariadic">isVariadic</strong>(); </dt> <dd>
<p>Check if the last template parameter is a tuple one, and returns it if so, else returns <code>null</code>. </p>
<dl>
<dt>Returns:</dt>
<dd>The last template parameter if it's a <code>TemplateTupleParameter</code>
</dd>
</dl> </dd> <dt class="d_decl" id="TemplateDeclaration.isOverloadable">const bool <strong id="isOverloadable">isOverloadable</strong>(); </dt> <dd>
<p>We can overload templates.</p> </dd> </dl> </dd> <dt class="d_decl" id="functionResolve">void <strong id="functionResolve">functionResolve</strong>(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc, Objects* tiargs, Type tthis, Expressions* fargs, const(char)** pMessage = null); </dt> <dd>
<p>Given function arguments, figure out which template function to expand, and return matching result. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>MatchAccumulator <code>m</code>
</td> <td>matching result</td>
</tr> <tr>
<td>Dsymbol <code>dstart</code>
</td> <td>the root of overloaded function templates</td>
</tr> <tr>
<td>Loc <code>loc</code>
</td> <td>instantiation location</td>
</tr> <tr>
<td>Scope* <code>sc</code>
</td> <td>instantiation scope</td>
</tr> <tr>
<td>Objects* <code>tiargs</code>
</td> <td>initial list of template arguments</td>
</tr> <tr>
<td>Type <code>tthis</code>
</td> <td>if !NULL, the 'this' pointer argument</td>
</tr> <tr>
<td>Expressions* <code>fargs</code>
</td> <td>arguments to function</td>
</tr> <tr>
<td>const(char)** <code>pMessage</code>
</td> <td>address to store error message, or null</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="reliesOnTident">bool <strong id="reliesOnTident">reliesOnTident</strong>(Type t, TemplateParameters* tparams, size_t iStart = 0); </dt> <dd>
<p>Check whether the type t representation relies on one or more the template parameters. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>t</code>
</td> <td>Tested type, if null, returns false.</td>
</tr> <tr>
<td>TemplateParameters* <code>tparams</code>
</td> <td>Template parameters.</td>
</tr> <tr>
<td>size_t <code>iStart</code>
</td> <td>Start index of tparams to limit the tested parameters. If it's nonzero, tparams[0..iStart] will be excluded from the test target.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="TemplateParameter">abstract class <strong id="TemplateParameter">TemplateParameter</strong>: dmd.ast_node.ASTNode; </dt> <dd>
<p><a href="https://dlang.org/spec/template.html#TemplateParameter">https://dlang.org/spec/template.html#TemplateParameter</a></p> </dd> <dt class="d_decl" id="TemplateTypeParameter">class <strong id="TemplateTypeParameter">TemplateTypeParameter</strong>: dmd.dtemplate.TemplateParameter; </dt> <dd>
<p><a href="https://dlang.org/spec/template.html#TemplateTypeParameter">https://dlang.org/spec/template.html#TemplateTypeParameter</a> </p>
<dl>
<dt>Syntax</dt>
<dd> ident : specType = defaultType</dd>
</dl> </dd> <dt class="d_decl" id="TemplateThisParameter">class <strong id="TemplateThisParameter">TemplateThisParameter</strong>: dmd.dtemplate.TemplateTypeParameter; </dt> <dd>
<p><a href="https://dlang.org/spec/template.html#TemplateThisParameter">https://dlang.org/spec/template.html#TemplateThisParameter</a> </p>
<dl>
<dt>Syntax</dt>
<dd> this ident : specType = defaultType</dd>
</dl> </dd> <dt class="d_decl" id="TemplateValueParameter">class <strong id="TemplateValueParameter">TemplateValueParameter</strong>: dmd.dtemplate.TemplateParameter; </dt> <dd>
<p><a href="https://dlang.org/spec/template.html#TemplateValueParameter">https://dlang.org/spec/template.html#TemplateValueParameter</a> </p>
<dl>
<dt>Syntax</dt>
<dd> valType ident : specValue = defaultValue</dd>
</dl> </dd> <dt class="d_decl" id="TemplateAliasParameter">class <strong id="TemplateAliasParameter">TemplateAliasParameter</strong>: dmd.dtemplate.TemplateParameter; </dt> <dd>
<p><a href="https://dlang.org/spec/template.html#TemplateAliasParameter">https://dlang.org/spec/template.html#TemplateAliasParameter</a> </p>
<dl>
<dt>Syntax</dt>
<dd> specType ident : specAlias = defaultAlias</dd>
</dl> </dd> <dt class="d_decl" id="TemplateTupleParameter">class <strong id="TemplateTupleParameter">TemplateTupleParameter</strong>: dmd.dtemplate.TemplateParameter; </dt> <dd>
<p><a href="https://dlang.org/spec/template.html#TemplateSequenceParameter">https://dlang.org/spec/template.html#TemplateSequenceParameter</a> </p>
<dl>
<dt>Syntax</dt>
<dd> ident ...</dd>
</dl> </dd> <dt class="d_decl" id="TemplateInstance">class <strong id="TemplateInstance">TemplateInstance</strong>: dmd.dsymbol.ScopeDsymbol; </dt> <dd>
<p><a href="https://dlang.org/spec/template.html#explicit_tmp_instantiation">https://dlang.org/spec/template.html#explicit_tmp_instantiation</a> </p>
<dl>
<dt>Given</dt>
<dd> foo!(args) =&gt; name = foo tiargs = args</dd>
</dl> <dl>
<dt class="d_decl" id="TemplateInstance.this">this(ref const Loc loc, TemplateDeclaration td, Objects* tiargs); </dt> <dd>
<p>This constructor is only called when we figured out which function template to instantiate.</p> </dd> <dt class="d_decl" id="TemplateInstance.printInstantiationTrace">final void <strong id="printInstantiationTrace">printInstantiationTrace</strong>(); </dt> <dd>
<p>Given an error instantiating the TemplateInstance, give the nested TemplateInstance instantiations that got us here. Those are a list threaded into the nested scopes.</p> </dd> <dt class="d_decl" id="TemplateInstance.getIdent">final Identifier <strong id="getIdent">getIdent</strong>(); </dt> <dd>
<p>Lazily generate identifier for template instance. This is because 75% of the ident's are never needed.</p> </dd> <dt class="d_decl" id="TemplateInstance.equalsx">final bool <strong id="equalsx">equalsx</strong>(TemplateInstance ti); </dt> <dd>
<p>Compare proposed template instantiation with existing template instantiation. Note that this is not commutative because of the auto ref check. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TemplateInstance <code>ti</code>
</td> <td>existing template instantiation</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true for match</dd>
</dl> </dd> <dt class="d_decl" id="TemplateInstance.needsCodegen">final bool <strong id="needsCodegen">needsCodegen</strong>(); </dt> <dd>
<p>Returns true if this is not instantiated in non-root module, and is a part of non-speculative instantiatiation. </p>
<dl>
<dt>Note</dt>
<dd> minst does not stabilize until semantic analysis is completed, so don't call this function during semantic analysis to return precise result.</dd>
</dl> </dd> <dt class="d_decl" id="TemplateInstance.findTempDecl">final bool <strong id="findTempDecl">findTempDecl</strong>(Scope* sc, WithScopeSymbol* pwithsym); </dt> <dd>
<p>Find template declaration corresponding to template instance. </p>
<dl>
<dt>Returns:</dt>
<dd>false if finding fails. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> This function is reentrant against error occurrence. If returns false, any members of this object won't be modified, and repetition call will reproduce same error.</dd>
</dl> </dd> <dt class="d_decl" id="TemplateInstance.updateTempDecl">final bool <strong id="updateTempDecl">updateTempDecl</strong>(Scope* sc, Dsymbol s); </dt> <dd>
<p>Confirm s is a valid template, then store it. </p>
<dl>
<dt>Input</dt>
<dd> sc s candidate symbol of template. It may be: TemplateDeclaration FuncDeclaration with findTemplateDeclRoot() != NULL OverloadSet which contains candidates </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if updating succeeds.</dd>
</dl> </dd> <dt class="d_decl" id="TemplateInstance.semanticTiargs">static bool <strong id="semanticTiargs">semanticTiargs</strong>(ref const Loc loc, Scope* sc, Objects* tiargs, int flags); </dt> <dd>
<p>Run semantic of tiargs as arguments of template. </p>
<dl>
<dt>Input</dt>
<dd> loc sc tiargs array of template arguments flags 1: replace const variables with their initializers 2: don't devolve Parameter to Type </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>false if one or more arguments have errors.</dd>
</dl> </dd> <dt class="d_decl" id="TemplateInstance.semanticTiargs.2">final bool <strong id="semanticTiargs">semanticTiargs</strong>(Scope* sc); </dt> <dd>
<p>Run semantic on the elements of tiargs. </p>
<dl>
<dt>Input</dt>
<dd> sc </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>false if one or more arguments have errors. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> This function is reentrant against error occurrence. If returns false, all elements of tiargs won't be modified.</dd>
</dl> </dd> <dt class="d_decl" id="TemplateInstance.needsTypeInference">final bool <strong id="needsTypeInference">needsTypeInference</strong>(Scope* sc, int flag = 0); </dt> <dd>
<p>Determine if template instance is really a template function, and that template function needs to infer types from the function arguments. </p>
<p>Like findBestMatch, iterate possible template candidates, but just looks only the necessity of type inference.</p> </dd> <dt class="d_decl" id="TemplateInstance.hasNestedArgs">final bool <strong id="hasNestedArgs">hasNestedArgs</strong>(Objects* args, bool isstatic); </dt> <dd>
<p>Determines if a TemplateInstance will need a nested generation of the TemplateDeclaration. Sets enclosing property if so, and returns != 0;</p> </dd> <dt class="d_decl" id="TemplateInstance.appendToModuleMember">final Dsymbols* <strong id="appendToModuleMember">appendToModuleMember</strong>(); </dt> <dd>
<p>Append 'this' to the specific module members[]</p> </dd> <dt class="d_decl" id="TemplateInstance.declareParameters">final void <strong id="declareParameters">declareParameters</strong>(Scope* sc); </dt> <dd>
<p>Declare parameters of template instance, initialize them with the template instance arguments.</p> </dd> <dt class="d_decl" id="TemplateInstance.genIdent">final Identifier <strong id="genIdent">genIdent</strong>(Objects* args); </dt> <dd>
<p>This instance needs an identifier for name mangling purposes. Create one by taking the template declaration name and adding the type signature for it.</p> </dd> </dl> </dd> <dt class="d_decl" id="unSpeculative">void <strong id="unSpeculative">unSpeculative</strong>(Scope* sc, RootObject o); </dt> <dd>
<p>IsExpression can evaluate the specified type speculatively, and even if it instantiates any symbols, they are normally unnecessary for the final executable. However, if those symbols leak to the actual code, compiler should remark them as non-speculative to generate their code and link to the final executable.</p> </dd> <dt class="d_decl" id="definitelyValueParameter">bool <strong id="definitelyValueParameter">definitelyValueParameter</strong>(Expression e); </dt> <dd>
<p>Return true if e could be valid only as a template value parameter. Return false if it might be an alias or tuple. (Note that even in this case, it could still turn out to be a value).</p> </dd> <dt class="d_decl" id="TemplateMixin">class <strong id="TemplateMixin">TemplateMixin</strong>: dmd.dtemplate.TemplateInstance; </dt> <dd>
<p><a href="https://dlang.org/spec/template-mixin.html">https://dlang.org/spec/template-mixin.html</a> </p>
<dl>
<dt>Syntax</dt>
<dd> mixin MixinTemplateName [TemplateArguments] [Identifier];</dd>
</dl> </dd> <dt class="d_decl" id="TemplateInstanceBox">struct <strong id="TemplateInstanceBox">TemplateInstanceBox</strong>; </dt> <dd>
<p>This struct is needed for TemplateInstance to be the key in an associative array. Fixing <a href="https://issues.dlang.org/show_bug.cgi?id=15812">https://issues.dlang.org/show_bug.cgi?id=15812</a> and <a href="https://issues.dlang.org/show_bug.cgi?id=15813">https://issues.dlang.org/show_bug.cgi?id=15813</a> would make it unnecessary.</p> </dd> <dt class="d_decl" id="matchArg">MATCH <strong id="matchArg">matchArg</strong>(TemplateParameter tp, Loc instLoc, Scope* sc, Objects* tiargs, size_t i, TemplateParameters* parameters, Objects* dedtypes, Declaration* psparam); </dt> <dd>
<p>Match to a particular TemplateParameter. </p>
<dl>
<dt>Input</dt>
<dd> instLoc location that the template is instantiated. tiargs[] actual arguments to template instance i i'th argument parameters[] template parameters dedtypes[] deduced arguments to template instance *psparam set to symbol declared and initialized to dedtypes[i]</dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/dmd_dtemplate.html" class="_attribution-link">https://dlang.org/phobos/dmd_dtemplate.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
