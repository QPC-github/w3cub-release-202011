
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>5. Declarations - D - W3cubDocs</title>
  
  <meta name="description" content=" Declaration syntax generally reads right to left&#58; ">
  <meta name="keywords" content="declarations, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/d/declaration.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _d">
				
				
<h1>Declarations</h1>       <b>Contents</b>  <ol> <li><a href="#declaration_syntax">Declaration Syntax</a></li> <li><a href="#auto-declaration">Implicit Type Inference</a></li> <li><a href="#alias">Alias Declarations</a></li> <li><a href="#extern">Extern Declarations</a></li> <li><a href="#typeof"><code>typeof</code></a></li> <li><a href="#void_init">Void Initializations</a></li> <li><a href="#global_static_init">Global and Static Initializers</a></li> <li><a href="#typequal_vs_storageclass">Type Qualifiers vs. Storage Classes</a></li> </ol>   <pre>Declaration:
    FuncDeclaration
    VarDeclarations
    AliasDeclaration
    AggregateDeclaration
    EnumDeclaration
    ImportDeclaration
    ConditionalDeclaration
    StaticForeachDeclaration
    StaticAssert
</pre>  <pre>VarDeclarations:
    StorageClassesopt BasicType Declarators ;
    AutoDeclaration

Declarators:
    DeclaratorInitializer
    DeclaratorInitializer , DeclaratorIdentifierList

DeclaratorInitializer:
    VarDeclarator
    VarDeclarator TemplateParametersopt = Initializer
    AltDeclarator
    AltDeclarator = Initializer

DeclaratorIdentifierList:
    DeclaratorIdentifier
    DeclaratorIdentifier , DeclaratorIdentifierList

DeclaratorIdentifier:
    VarDeclaratorIdentifier
    AltDeclaratorIdentifier

VarDeclaratorIdentifier:
    Identifier
    Identifier TemplateParametersopt = Initializer

AltDeclaratorIdentifier:
    BasicType2 Identifier AltDeclaratorSuffixesopt
    BasicType2 Identifier AltDeclaratorSuffixesopt = Initializer
    BasicType2opt Identifier AltDeclaratorSuffixes
    BasicType2opt Identifier AltDeclaratorSuffixes = Initializer

Declarator:
    VarDeclarator
    AltDeclarator

VarDeclarator:
    BasicType2opt Identifier

AltDeclarator:
    BasicType2opt Identifier AltDeclaratorSuffixes
    BasicType2opt ( AltDeclaratorX )
    BasicType2opt ( AltDeclaratorX ) AltFuncDeclaratorSuffix
    BasicType2opt ( AltDeclaratorX ) AltDeclaratorSuffixes

AltDeclaratorX:
    BasicType2opt Identifier
    BasicType2opt Identifier AltFuncDeclaratorSuffix
    AltDeclarator

AltDeclaratorSuffixes:
    AltDeclaratorSuffix
    AltDeclaratorSuffix AltDeclaratorSuffixes

AltDeclaratorSuffix:
    [ ]
    [ AssignExpression ]
    [ Type ]

AltFuncDeclaratorSuffix:
    Parameters MemberFunctionAttributesopt
</pre>  <pre>Type:
    TypeCtorsopt BasicType BasicType2opt

TypeCtors:
    TypeCtor
    TypeCtor TypeCtors

TypeCtor:
    const
    immutable
    inout
    shared

BasicType:
    BasicTypeX
    . IdentifierList
    IdentifierList
    Typeof
    Typeof . IdentifierList
    TypeCtor ( Type )
    Vector
    Traits
    MixinType

Vector:
    __vector ( VectorBaseType )

VectorBaseType:
    Type

BasicTypeX:
    bool
    byte
    ubyte
    short
    ushort
    int
    uint
    long
    ulong
    cent
    ucent
    char
    wchar
    dchar
    float
    double
    real
    ifloat
    idouble
    ireal
    cfloat
    cdouble
    creal
    void

BasicType2:
    BasicType2X BasicType2opt

BasicType2X:
    *
    [ ]
    [ AssignExpression ]
    [ AssignExpression .. AssignExpression ]
    [ Type ]
    delegate Parameters MemberFunctionAttributesopt
    function Parameters FunctionAttributesopt

IdentifierList:
    Identifier
    Identifier . IdentifierList
    TemplateInstance
    TemplateInstance . IdentifierList
    Identifier [ AssignExpression ]
    Identifier [ AssignExpression ]. IdentifierList
</pre>  <pre>StorageClasses:
    StorageClass
    StorageClass StorageClasses

StorageClass:
    LinkageAttribute
    AlignAttribute
    deprecated
    enum
    static
    extern
    abstract
    final
    override
    synchronized
    auto
    scope
    const
    immutable
    inout
    shared
    __gshared
    Property
    nothrow
    pure
    ref
</pre>  <pre>Initializer:
    VoidInitializer
    NonVoidInitializer

NonVoidInitializer:
    ExpInitializer
    ArrayInitializer
    StructInitializer

ExpInitializer:
    AssignExpression

ArrayInitializer:
    [ ArrayMemberInitializationsopt ]

ArrayMemberInitializations:
    ArrayMemberInitialization
    ArrayMemberInitialization ,
    ArrayMemberInitialization , ArrayMemberInitializations

ArrayMemberInitialization:
    NonVoidInitializer
    AssignExpression : NonVoidInitializer

StructInitializer:
    { StructMemberInitializersopt }

StructMemberInitializers:
    StructMemberInitializer
    StructMemberInitializer ,
    StructMemberInitializer , StructMemberInitializers

StructMemberInitializer:
    NonVoidInitializer
    Identifier : NonVoidInitializer
</pre>  <h2 id="declaration_syntax">Declaration Syntax</h2>  <p>Declaration syntax generally reads right to left:</p>  <pre data-language="d">int x;    // x is an int
int* x;   // x is a pointer to int
int** x;  // x is a pointer to a pointer to int
int[] x;  // x is an array of ints
int*[] x; // x is an array of pointers to ints
int[]* x; // x is a pointer to an array of ints
</pre>  <p>Arrays read right to left as well:</p>  <pre data-language="d">int[3] x;     // x is an array of 3 ints
int[3][5] x;  // x is an array of 5 arrays of 3 ints
int[3]*[5] x; // x is an array of 5 pointers to arrays of 3 ints
</pre>  <p>Pointers to functions are declared using the <code>function</code> keyword: </p>  <pre data-language="d">int function(char) x; // x is a pointer to
                     // a function taking a char argument
                     // and returning an int
int function(char)[] x; // x is an array of
                     // pointers to functions
                     // taking a char argument
                     // and returning an int
</pre>  <p>C-style array, function pointer and pointer to array declarations are deprecated: </p>  <pre data-language="d">int x[3];          // x is an array of 3 ints
int x[3][5];       // x is an array of 3 arrays of 5 ints
int (*x[5])[3];    // x is an array of 5 pointers to arrays of 3 ints
int (*x)(char);    // x is a pointer to a function taking a char argument
                   // and returning an int
int (*[] x)(char); // x is an array of pointers to functions
                   // taking a char argument and returning an int
</pre>  <p>In a declaration declaring multiple symbols, all the declarations must be of the same type: </p>  <pre data-language="d">int x,y;   // x and y are ints
int* x,y;  // x and y are pointers to ints
int x,*y;  // error, multiple types
int[] x,y; // x and y are arrays of ints
int x[],y; // error, multiple types
</pre>  <h2><span id="AutoDeclaration">Implicit Type Inference</span></h2>  <pre>AutoDeclaration:
    StorageClasses AutoDeclarationX ;

AutoDeclarationX:
    AutoDeclarationY
    AutoDeclarationX , AutoDeclarationY

AutoDeclarationY:
    Identifier TemplateParametersopt = Initializer
</pre>  <p>If a declaration starts with a <i>StorageClass</i> and has a <i>NonVoidInitializer</i> from which the type can be inferred, the type on the declaration can be omitted. </p>  <pre data-language="d">static x = 3;      // x is type int
auto y = 4u;       // y is type uint

auto s = "Apollo"; // s is type immutable(char)[]

class C { ... }

auto c = new C();  // c is a handle to an instance of class C
</pre>  <p>The <i>NonVoidInitializer</i> cannot contain forward references (this restriction may be removed in the future). The implicitly inferred type is statically bound to the declaration at compile time, not run time. </p>  <p>An <a href="expression#ArrayLiteral"><i>ArrayLiteral</i></a> is inferred to be a dynamic array type rather than a static array:</p>  <pre data-language="d">auto v = ["resistance", "is", "useless"]; // type is string[], not string[3]
</pre>   <h2 id="alias">Alias Declarations</h2>  <pre>AliasDeclaration:
    alias StorageClassesopt BasicType Declarators ;
    alias StorageClassesopt BasicType FuncDeclarator ;
    alias AliasDeclarationX ;

AliasDeclarationX:
    AliasDeclarationY
    AliasDeclarationX , AliasDeclarationY

AliasDeclarationY:
    Identifier TemplateParametersopt = StorageClassesopt Type
    Identifier TemplateParametersopt = FunctionLiteral
    Identifier TemplateParametersopt = StorageClassesopt BasicType Parameters MemberFunctionAttributesopt
</pre>  <p><i>AliasDeclaration</i>s create a symbol that is an alias for another type, and can be used anywhere that other type may appear. </p>  <pre data-language="d">alias myint = abc.Foo.bar;
</pre>  <p> Aliased types are semantically identical to the types they are aliased to. The debugger cannot distinguish between them, and there is no difference as far as function overloading is concerned. For example: </p>  <pre data-language="d">alias myint = int;

void foo(int x) { ... }
void foo(myint m) { ... } // error, multiply defined function foo
</pre>  <p>A symbol can be declared as an <i>alias</i> of another symbol. For example: </p>  <pre data-language="d">import planets;

alias myAlbedo = planets.albedo;
...
int len = myAlbedo("Saturn"); // actually calls planets.albedo()
</pre>  <p> The following alias declarations are valid: </p>  <pre data-language="d">template Foo2(T) { alias t = T; }
alias t1 = Foo2!(int);
alias t2 = Foo2!(int).t;
alias t3 = t1.t;
alias t4 = t2;

t1.t v1;  // v1 is type int
t2 v2;    // v2 is type int
t3 v3;    // v3 is type int
t4 v4;    // v4 is type int

alias Fun = int(string p);
int fun(string){return 0;}
static assert(is(typeof(fun) == Fun));

alias MemberFun1 = int() const;
alias MemberFun2 = const int();
// leading attributes apply to the func, not the return type
static assert(is(MemberFun1 == MemberFun2));
</pre>  <p> Aliased symbols are useful as a shorthand for a long qualified symbol name, or as a way to redirect references from one symbol to another: </p>  <pre data-language="d">version (Win32)
{
    alias myfoo = win32.foo;
}
version (linux)
{
    alias myfoo = linux.bar;
}
</pre>  <p> Aliasing can be used to <code>import</code> a symbol from an import into the current scope: </p>  <pre data-language="d">alias strlen = string.strlen;
</pre>  <p> Aliases can also <code>import</code> a set of overloaded functions, that can be overloaded with functions in the current scope: </p>  <pre data-language="d">class A
{
    int foo(int a) { return 1; }
}

class B : A
{
    int foo( int a, uint b ) { return 2; }
}

class C : B
{
    int foo( int a ) { return 3; }
    alias foo = B.foo;
}

class D : C
{
}

void test()
{
    D b = new D();
    int i;

    i = b.foo(1, 2u);   // calls B.foo
    i = b.foo(1);       // calls C.foo
}
</pre>  <p> <b>Note:</b> Type aliases can sometimes look indistinguishable from alias declarations: </p>  <pre data-language="d">alias abc = foo.bar; // is it a type or a symbol?
</pre>  <p> The distinction is made in the semantic analysis pass. </p>  <p>Aliases cannot be used for expressions:</p>  <pre data-language="d">struct S
{
    static int i;
    static int j;
}

alias a = S.i; // OK, `S.i` is a symbol
alias b = S.j; // OK. `S.j` is also a symbol
alias c = a + b; // illegal, `a + b` is an expression
a = 2;         // sets `S.i` to `2`
b = 4;         // sets `S.j` to `4`
</pre>  <h2 id="extern">Extern Declarations</h2>  <p>Variable declarations with the storage class <code>extern</code> are not allocated storage within the module. They must be defined in some other object file with a matching name which is then linked in.</p>  <p>An <code>extern</code> declaration can optionally be followed by an <code>extern</code> <a href="attribute#linkage">linkage attribute</a>. If there is no linkage attribute it defaults to <code>extern(D)</code>:</p>  <pre data-language="d">// variable allocated and initialized in this module with C linkage
extern(C) int foo;
// variable allocated outside this module with C linkage
// (e.g. in a statically linked C library or another module)
extern extern(C) int bar;
</pre>  <b>Best Practices:</b> <ol> <li>The primary usefulness of <i>Extern Declarations</i> is to connect with global variables declarations and functions in C or C++ files.</li> </ol>  <h2 id="typeof"><code>typeof</code></h2>  <pre>Typeof:
    typeof ( Expression )
    typeof ( return )
</pre>  <p> <i>Typeof</i> is a way to specify a type based on the type of an expression. For example: </p>  <pre data-language="d">void func(int i)
{
    typeof(i) j;       // j is of type int
    typeof(3 + 6.0) x; // x is of type double
    typeof(1)* p;      // p is of type pointer to int
    int[typeof(p)] a;  // a is of type int[int*]

    writefln("%d", typeof('c').sizeof); // prints 1
    double c = cast(typeof(1.0))j; // cast j to double
}
</pre>  <p> <i>Expression</i> is not evaluated, just the type of it is generated: </p>  <pre data-language="d">void func()
{
    int i = 1;
    typeof(++i) j; // j is declared to be an int, i is not incremented
    writefln("%d", i);  // prints 1
}
</pre>  <p>Special cases: </p> <ol> <li>
<code>typeof(this)</code> will generate the type of what <code>this</code> would be in a non-static member function, even if not in a member function. </li> <li>Analogously, <code>typeof(super)</code> will generate the type of what <code>super</code> would be in a non-static member function. </li> <li>
<code>typeof(return)</code> will, when inside a function scope, give the return type of that function. </li> </ol>  <pre data-language="d">class A { }

class B : A
{
    typeof(this) x;  // x is declared to be a B
    typeof(super) y; // y is declared to be an A
}

struct C
{
    static typeof(this) z;  // z is declared to be a C

    typeof(super) q; // error, no super struct for C
}

typeof(this) r;   // error, no enclosing struct or class
</pre>  <p>If the expression is a <a href="function#property-functions"> Property Function</a>, <code>typeof</code> gives its return type. </p>  <pre data-language="d">struct S
{
    @property int foo() { return 1; }
}
typeof(S.foo) n;  // n is declared to be an int
</pre>  <b>Best Practices:</b> <ol> <li>
<i>Typeof</i> is most useful in writing generic template code.</li> </ol>   <h2 id="void_init">Void Initializations</h2>  <pre>VoidInitializer:
    void
</pre>  <p>Normally, variables are initialized either with an explicit <a href="#Initializer"><i>Initializer</i></a> or are set to the default value for the type of the variable. If the <i>Initializer</i> is <code>void</code>, however, the variable is not initialized. If its value is used before it is set, undefined program behavior will result. </p>  <b>Undefined Behavior</b>: If a void initialized variable's value is used before it is set, the behavior is undefined.  <pre data-language="d">void foo()
{
    int x = void;
    writeln(x);  // will print garbage
}
</pre>   <b>Best Practices:</b> <ol> <li>Void initializers are useful when a static array is on the stack, but may only be partially used, such as as a temporary buffer. Void initializers will speed up the code, but of course one must be careful that array elements are actually set before read.</li> <li>The same is true for structs.</li> <li>Use of void initializers is rarely useful for individual local variables, as a modern optimizer will remove the dead store of its initialization if it is initialized later.</li> <li>For hot code paths, it is worthwhile to check to see if the void initializer actually improves results before using it.</li> </ol>   <h2 id="global_static_init">Global and Static Initializers</h2>  <p>The <a href="#Initializer"><i>Initializer</i></a> for a global or static variable must be evaluatable at compile time. Runtime initialization is done with static constructors. </p>  <b>Implementation Defined</b>: <ol> <li>Whether some pointers can be initialized with the addresses of other functions or data.</li> </ol>  <h2 id="typequal_vs_storageclass">Type Qualifiers vs. Storage Classes</h2>  <p>Type qualifer and storage classes are distinct.</p>  <p>A <i>type qualifier</i> creates a derived type from an existing base type, and the resulting type may be used to create multiple instances of that type.</p>  <p>For example, the <code>immutable</code> type qualifier can be used to create variables of immutable type, such as:</p>  <pre data-language="d">immutable(int)   x; // typeof(x) == immutable(int)
immutable(int)[] y; // typeof(y) == immutable(int)[]
                    // typeof(y[0]) == immutable(int)

// Type constructors create new types that can be aliased:
alias ImmutableInt = immutable(int);
ImmutableInt z;     // typeof(z) == immutable(int)
</pre>  <p>A <i>storage class</i>, on the other hand, does not create a new type, but describes only the kind of storage used by the variable or function being declared. For example, a member function can be declared with the <code>const</code> storage class to indicate that it does not modify its implicit <code>this</code> argument:</p>  <pre data-language="d">struct S
{
    int x;
    int method() const
    {
        //x++;    // Error: this method is const and cannot modify this.x
        return x; // OK: we can still read this.x
    }
}
</pre>  <p>Although some keywords can be used both as a type qualifier and a storage class, there are some storage classes that cannot be used to construct new types, such as <code>ref</code>:</p>  <pre data-language="d">// ref declares the parameter x to be passed by reference
void func(ref int x)
{
    x++; // so modifications to x will be visible in the caller
}

void main()
{
    auto x = 1;
    func(x);
    assert(x == 2);

    // However, ref is not a type qualifier, so the following is illegal:
    ref(int) y; // Error: ref is not a type qualifier.
}
</pre>  <p>Functions can also be declared as <code>ref</code>, meaning their return value is passed by reference:</p> <pre data-language="d">ref int func2()
{
    static int y = 0;
    return y;
}

void main()
{
    func2() = 2; // The return value of func2() can be modified.
    assert(func2() == 2);

    // However, the reference returned by func2() does not propagate to
    // variables, because the 'ref' only applies to the return value itself,
    // not to any subsequent variable created from it:
    auto x = func2();
    static assert(is(typeof(x) == int)); // N.B.: *not* ref(int);
                                     // there is no such type as ref(int).
    x++;
    assert(x == 3);
    assert(func2() == 2); // x is not a reference to what func2() returned; it
                          // does not inherit the ref storage class from func2().
}
</pre>  <p>Some keywords, such as <code>const</code>, can be used both as a type qualifier and a storage class. The distinction is determined by the syntax where it appears.</p>  <pre data-language="d">struct S
{
    /* Is const here a type qualifier or a storage class?
     * Is the return value const(int), or is this a const function that returns
     * (mutable) int?
     */
    const int* func() // a const function
    {
        ++p;          // error, this.p is const
        return p;     // error, cannot convert const(int)* to int*
    }

    const(int)* func() // a function returning a pointer to a const int
    {
        ++p;          // ok, this.p is mutable
        return p;     // ok, int* can be implicitly converted to const(int)*
    }

    int* p;
}
</pre>  <b>Best Practices:</b> To avoid confusion, the type qualifier syntax with parentheses should be used for return types, and function storage classes should be written on the right-hand side of the declaration instead of the left-hand side where it may be visually confused with the return type:  <pre data-language="d">struct S
{
    // Now it is clear that the 'const' here applies to the return type:
    const(int) func1() { return 1; }

    // And it is clear that the 'const' here applies to the function:
    int func2() const { return 1; }
}
</pre>      <div class="_attribution">
  <p class="_attribution-p">
    © 1999–2019 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/spec/declaration.html" class="_attribution-link">https://dlang.org/spec/declaration.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
