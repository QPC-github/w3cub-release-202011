
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Obtaining SQL Values - SQLite - W3cubDocs</title>
  
  <meta name="description" content=" Summary&#58; ">
  <meta name="keywords" content="obtaining, sql, values, sqlite">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/sqlite/c3ref/value_blob.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/sqlite.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/sqlite/" class="_nav-link" title="" style="margin-left:0;">SQLite</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sqlite">
				
				
<h1>Obtaining SQL Values</h1>  <pre data-language="sql">
const void *sqlite3_value_blob(sqlite3_value*);
double sqlite3_value_double(sqlite3_value*);
int sqlite3_value_int(sqlite3_value*);
sqlite3_int64 sqlite3_value_int64(sqlite3_value*);
void *sqlite3_value_pointer(sqlite3_value*, const char*);
const unsigned char *sqlite3_value_text(sqlite3_value*);
const void *sqlite3_value_text16(sqlite3_value*);
const void *sqlite3_value_text16le(sqlite3_value*);
const void *sqlite3_value_text16be(sqlite3_value*);
int sqlite3_value_bytes(sqlite3_value*);
int sqlite3_value_bytes16(sqlite3_value*);
int sqlite3_value_type(sqlite3_value*);
int sqlite3_value_numeric_type(sqlite3_value*);
int sqlite3_value_nochange(sqlite3_value*);
int sqlite3_value_frombind(sqlite3_value*);
</pre> <p> <b>Summary:</b> </p>
<pre data-language="sql"> 
sqlite3_value_blob
→
BLOB value 


sqlite3_value_double
→
REAL value 


sqlite3_value_int
→
32-bit INTEGER value 


sqlite3_value_int64
→
64-bit INTEGER value 


sqlite3_value_pointer
→
Pointer value 


sqlite3_value_text
→
UTF-8 TEXT value 


sqlite3_value_text16
→
UTF-16 TEXT value in the native byteorder 


sqlite3_value_text16be
→
UTF-16be TEXT value 


sqlite3_value_text16le
→
UTF-16le TEXT value 


 
 
 


sqlite3_value_bytes
→
Size of a BLOB or a UTF-8 TEXT in bytes 



sqlite3_value_bytes16  
→ 
Size of UTF-16 TEXT in bytes 


sqlite3_value_type
→
Default datatype of the value 



sqlite3_value_numeric_type  
→ 
Best numeric datatype of the value 



sqlite3_value_nochange  
→ 
True if the column is unchanged in an UPDATE against a virtual table. 



sqlite3_value_frombind  
→ 
True if value originated from a bound parameter 

</pre> <p><b>Details:</b></p> <p>These routines extract type, size, and content information from <a href="value">protected sqlite3_value</a> objects. Protected sqlite3_value objects are used to pass parameter information into the functions that implement <a href="../appfunc">application-defined SQL functions</a> and <a href="../vtab">virtual tables</a>.</p> <p>These routines work only with <a href="value">protected sqlite3_value</a> objects. Any attempt to use these routines on an <a href="value">unprotected sqlite3_value</a> is not threadsafe.</p> <p>These routines work just like the corresponding <a href="column_blob">column access functions</a> except that these routines take a single <a href="value">protected sqlite3_value</a> object pointer instead of a <a href="stmt">sqlite3_stmt*</a> pointer and an integer column number.</p> <p>The sqlite3_value_text16() interface extracts a UTF-16 string in the native byte-order of the host machine. The sqlite3_value_text16be() and sqlite3_value_text16le() interfaces extract UTF-16 strings as big-endian and little-endian respectively.</p> <p>If <a href="value">sqlite3_value</a> object V was initialized using <a href="bind_blob">sqlite3_bind_pointer(S,I,P,X,D)</a> or <a href="result_blob">sqlite3_result_pointer(C,P,X,D)</a> and if X and Y are strings that compare equal according to strcmp(X,Y), then sqlite3_value_pointer(V,Y) will return the pointer P. Otherwise, sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() routine is part of the <a href="../bindptr">pointer passing interface</a> added for SQLite 3.20.0.</p> <p>The sqlite3_value_type(V) interface returns the <a href="c_blob">datatype code</a> for the initial datatype of the <a href="value">sqlite3_value</a> object V. The returned value is one of <a href="c_blob">SQLITE_INTEGER</a>, <a href="c_blob">SQLITE_FLOAT</a>, <a href="c_blob">SQLITE_TEXT</a>, <a href="c_blob">SQLITE_BLOB</a>, or <a href="c_blob">SQLITE_NULL</a>. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</p> <p>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The <a href="c_blob">datatype</a> after conversion is returned.</p> <p>Within the <a href="../vtab#xupdate">xUpdate</a> method of a <a href="../vtab">virtual table</a>, the sqlite3_value_nochange(X) interface returns true if and only if the column corresponding to X is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior <a href="../vtab#xcolumn">xColumn</a> method call that was invoked to extracted the value for that column returned without setting a result (probably because it queried <a href="vtab_nochange">sqlite3_vtab_nochange()</a> and found that the column was unchanging). Within an <a href="../vtab#xupdate">xUpdate</a> method, any value for which sqlite3_value_nochange(X) is true will in all other respects appear to be a NULL value. If sqlite3_value_nochange(X) is invoked anywhere other than within an <a href="../vtab#xupdate">xUpdate</a> method call for an UPDATE statement, then the return value is arbitrary and meaningless.</p> <p>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the <a href="bind_blob">sqlite3_bind()</a> interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</p> <p>Please pay particular attention to the fact that the pointer returned from <a href="value_blob">sqlite3_value_blob()</a>, <a href="value_blob">sqlite3_value_text()</a>, or <a href="value_blob">sqlite3_value_text16()</a> can be invalidated by a subsequent call to <a href="value_blob">sqlite3_value_bytes()</a>, <a href="value_blob">sqlite3_value_bytes16()</a>, <a href="value_blob">sqlite3_value_text()</a>, or <a href="value_blob">sqlite3_value_text16()</a>.</p> <p>These routines must be called from the same thread as the SQL function that supplied the <a href="value">sqlite3_value*</a> parameters.</p> <p>As long as the input parameter is correct, these routines can only fail if an out-of-memory error occurs during a format conversion. Only the following subset of interfaces are subject to out-of-memory errors:</p> 
<ul> <li> sqlite3_value_blob() </li>
<li> sqlite3_value_text() </li>
<li> sqlite3_value_text16() </li>
<li> sqlite3_value_text16le() </li>
<li> sqlite3_value_text16be() </li>
<li> sqlite3_value_bytes() </li>
<li> sqlite3_value_bytes16() </li>
</ul> <p>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the <a href="errcode">sqlite3_errcode()</a> immediately after the suspect return value is obtained and before any other SQLite interface is called on the same <a href="sqlite3">database connection</a>. </p>
<p>See also lists of <a href="objlist">Objects</a>, <a href="constlist">Constants</a>, and <a href="funclist">Functions</a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    SQLite is in the Public Domain.<br>
    <a href="https://sqlite.org/c3ref/value_blob.html" class="_attribution-link">https://sqlite.org/c3ref/value_blob.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
