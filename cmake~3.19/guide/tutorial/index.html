
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Tutorial - CMake 3.19 - W3cubDocs</title>
  
  <meta name="description" content=" A Basic Starting Point (Step 1) ">
  <meta name="keywords" content="cmake, tutorial, cmake~3.19">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/cmake~3.19/guide/tutorial/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/cmake~3.19.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cmake~3.19/" class="_nav-link" title="" style="margin-left:0;">CMake 3.19</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx_simple">
				
				
<h1 id="guide:CMake Tutorial">CMake Tutorial</h1>   <ul id="cmake-tutorial"> <li><a class="reference internal" href="#introduction" id="id2">Introduction</a></li> <li>
<p><a class="reference internal" href="#a-basic-starting-point-step-1" id="id3">A Basic Starting Point (Step 1)</a></p> <ul> <li><a class="reference internal" href="#adding-a-version-number-and-configured-header-file" id="id4">Adding a Version Number and Configured Header File</a></li> <li><a class="reference internal" href="#specify-the-c-standard" id="id5">Specify the C++ Standard</a></li> <li><a class="reference internal" href="#build-and-test" id="id6">Build and Test</a></li> </ul> </li> <li><a class="reference internal" href="#adding-a-library-step-2" id="id7">Adding a Library (Step 2)</a></li> <li><a class="reference internal" href="#adding-usage-requirements-for-library-step-3" id="id8">Adding Usage Requirements for Library (Step 3)</a></li> <li>
<p><a class="reference internal" href="#installing-and-testing-step-4" id="id9">Installing and Testing (Step 4)</a></p> <ul> <li><a class="reference internal" href="#install-rules" id="id10">Install Rules</a></li> <li><a class="reference internal" href="#testing-support" id="id11">Testing Support</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#adding-system-introspection-step-5" id="id12">Adding System Introspection (Step 5)</a></p> <ul> <li><a class="reference internal" href="#specify-compile-definition" id="id13">Specify Compile Definition</a></li> </ul> </li> <li><a class="reference internal" href="#adding-a-custom-command-and-generated-file-step-6" id="id14">Adding a Custom Command and Generated File (Step 6)</a></li> <li><a class="reference internal" href="#building-an-installer-step-7" id="id15">Building an Installer (Step 7)</a></li> <li><a class="reference internal" href="#adding-support-for-a-dashboard-step-8" id="id16">Adding Support for a Dashboard (Step 8)</a></li> <li><a class="reference internal" href="#mixing-static-and-shared-step-9" id="id17">Mixing Static and Shared (Step 9)</a></li> <li><a class="reference internal" href="#adding-generator-expressions-step-10" id="id18">Adding Generator Expressions (Step 10)</a></li> <li><a class="reference internal" href="#adding-export-configuration-step-11" id="id19">Adding Export Configuration (Step 11)</a></li> <li><a class="reference internal" href="#packaging-debug-and-release-step-12" id="id20">Packaging Debug and Release (Step 12)</a></li> </ul>
   <h2 id="introduction">Introduction</h2> <p>The CMake tutorial provides a step-by-step guide that covers common build system issues that CMake helps address. Seeing how various topics all work together in an example project can be very helpful. The tutorial documentation and source code for examples can be found in the <code>Help/guide/tutorial</code> directory of the CMake source code tree. Each step has its own subdirectory containing code that may be used as a starting point. The tutorial examples are progressive so that each step provides the complete solution for the previous step.</p>   <h2 id="a-basic-starting-point-step-1">A Basic Starting Point (Step 1)</h2> <p>The most basic project is an executable built from source code files. For simple projects, a three line <code>CMakeLists.txt</code> file is all that is required. This will be the starting point for our tutorial. Create a <code>CMakeLists.txt</code> file in the <code>Step1</code> directory that looks like:</p> <pre data-language="cmake">cmake_minimum_required(VERSION 3.10)

# set the project name
project(Tutorial)

# add the executable
add_executable(Tutorial tutorial.cxx)
</pre> <p>Note that this example uses lower case commands in the <code>CMakeLists.txt</code> file. Upper, lower, and mixed case commands are supported by CMake. The source code for <code>tutorial.cxx</code> is provided in the <code>Step1</code> directory and can be used to compute the square root of a number.</p>  <h3 id="adding-a-version-number-and-configured-header-file">Adding a Version Number and Configured Header File</h3> <p>The first feature we will add is to provide our executable and project with a version number. While we could do this exclusively in the source code, using <code>CMakeLists.txt</code> provides more flexibility.</p> <p>First, modify the <code>CMakeLists.txt</code> file to use the <a class="reference internal" href="../../command/project#command:project" title="project" id="index-0-command:project"><code>project()</code></a> command to set the project name and version number.</p> <pre data-language="cmake">cmake_minimum_required(VERSION 3.10)

# set the project name and version
project(Tutorial VERSION 1.0)
</pre> <p>Then, configure a header file to pass the version number to the source code:</p> <pre data-language="cmake">configure_file(TutorialConfig.h.in TutorialConfig.h)
</pre> <p>Since the configured file will be written into the binary tree, we must add that directory to the list of paths to search for include files. Add the following lines to the end of the <code>CMakeLists.txt</code> file:</p> <pre data-language="cmake">target_include_directories(Tutorial PUBLIC
                           "${PROJECT_BINARY_DIR}"
                           )
</pre> <p>Using your favorite editor, create <code>TutorialConfig.h.in</code> in the source directory with the following contents:</p> <pre data-language="cmake">// the configured options and settings for Tutorial
#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@
#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@
</pre> <p>When CMake configures this header file the values for <code>@Tutorial_VERSION_MAJOR@</code> and <code>@Tutorial_VERSION_MINOR@</code> will be replaced.</p> <p>Next modify <code>tutorial.cxx</code> to include the configured header file, <code>TutorialConfig.h</code>.</p> <p>Finally, let’s print out the executable name and version number by updating <code>tutorial.cxx</code> as follows:</p> <pre data-language="c">  if (argc &lt; 2) {
    // report version
    std::cout &lt;&lt; argv[0] &lt;&lt; " Version " &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; "."
              &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl;
    std::cout &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " number" &lt;&lt; std::endl;
    return 1;
  }
</pre>   <h3 id="specify-the-c-standard">Specify the C++ Standard</h3> <p>Next let’s add some C++11 features to our project by replacing <code>atof</code> with <code>std::stod</code> in <code>tutorial.cxx</code>. At the same time, remove <code>#include &lt;cstdlib&gt;</code>.</p> <pre data-language="c">  const double inputValue = std::stod(argv[1]);
</pre> <p>We will need to explicitly state in the CMake code that it should use the correct flags. The easiest way to enable support for a specific C++ standard in CMake is by using the <a class="reference internal" href="../../variable/cmake_cxx_standard#variable:CMAKE_CXX_STANDARD" title="CMAKE_CXX_STANDARD" id="index-0-variable:CMAKE_CXX_STANDARD"><code>CMAKE_CXX_STANDARD</code></a> variable. For this tutorial, set the <a class="reference internal" href="../../variable/cmake_cxx_standard#variable:CMAKE_CXX_STANDARD" title="CMAKE_CXX_STANDARD" id="index-1-variable:CMAKE_CXX_STANDARD"><code>CMAKE_CXX_STANDARD</code></a> variable in the <code>CMakeLists.txt</code> file to 11 and <a class="reference internal" href="../../variable/cmake_cxx_standard_required#variable:CMAKE_CXX_STANDARD_REQUIRED" title="CMAKE_CXX_STANDARD_REQUIRED" id="index-0-variable:CMAKE_CXX_STANDARD_REQUIRED"><code>CMAKE_CXX_STANDARD_REQUIRED</code></a> to True. Make sure to add the <code>CMAKE_CXX_STANDARD</code> declarations above the call to <code>add_executable</code>.</p> <pre data-language="cmake">cmake_minimum_required(VERSION 3.10)

# set the project name and version
project(Tutorial VERSION 1.0)

# specify the C++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)
</pre>   <h3 id="build-and-test">Build and Test</h3> <p>Run the <a class="reference internal" href="../../manual/cmake.1#manual:cmake(1)" title="cmake(1)" id="index-0-manual:cmake(1)"><code>cmake</code></a> executable or the <a class="reference internal" href="../../manual/cmake-gui.1#manual:cmake-gui(1)" title="cmake-gui(1)" id="index-0-manual:cmake-gui(1)"><code>cmake-gui</code></a> to configure the project and then build it with your chosen build tool.</p> <p>For example, from the command line we could navigate to the <code>Help/guide/tutorial</code> directory of the CMake source code tree and create a build directory:</p> <pre data-language="console">mkdir Step1_build
</pre> <p>Next, navigate to the build directory and run CMake to configure the project and generate a native build system:</p> <pre data-language="console">cd Step1_build
cmake ../Step1
</pre> <p>Then call that build system to actually compile/link the project:</p> <pre data-language="console">cmake --build .
</pre> <p>Finally, try to use the newly built <code>Tutorial</code> with these commands:</p> <pre data-language="console">Tutorial 4294967296
Tutorial 10
Tutorial
</pre>    <h2 id="adding-a-library-step-2">Adding a Library (Step 2)</h2> <p>Now we will add a library to our project. This library will contain our own implementation for computing the square root of a number. The executable can then use this library instead of the standard square root function provided by the compiler.</p> <p>For this tutorial we will put the library into a subdirectory called <code>MathFunctions</code>. This directory already contains a header file, <code>MathFunctions.h</code>, and a source file <code>mysqrt.cxx</code>. The source file has one function called <code>mysqrt</code> that provides similar functionality to the compiler’s <code>sqrt</code> function.</p> <p>Add the following one line <code>CMakeLists.txt</code> file to the <code>MathFunctions</code> directory:</p> <pre data-language="cmake">add_library(MathFunctions mysqrt.cxx)
</pre> <p>To make use of the new library we will add an <a class="reference internal" href="../../command/add_subdirectory#command:add_subdirectory" title="add_subdirectory" id="index-0-command:add_subdirectory"><code>add_subdirectory()</code></a> call in the top-level <code>CMakeLists.txt</code> file so that the library will get built. We add the new library to the executable, and add <code>MathFunctions</code> as an include directory so that the <code>mqsqrt.h</code> header file can be found. The last few lines of the top-level <code>CMakeLists.txt</code> file should now look like:</p> <pre data-language="cmake"># add the MathFunctions library
add_subdirectory(MathFunctions)

# add the executable
add_executable(Tutorial tutorial.cxx)

target_link_libraries(Tutorial PUBLIC MathFunctions)

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
target_include_directories(Tutorial PUBLIC
                          "${PROJECT_BINARY_DIR}"
                          "${PROJECT_SOURCE_DIR}/MathFunctions"
                          )
</pre> <p>Now let us make the MathFunctions library optional. While for the tutorial there really isn’t any need to do so, for larger projects this is a common occurrence. The first step is to add an option to the top-level <code>CMakeLists.txt</code> file.</p> <pre data-language="cmake">option(USE_MYMATH "Use tutorial provided math implementation" ON)

# configure a header file to pass some of the CMake settings
# to the source code
configure_file(TutorialConfig.h.in TutorialConfig.h)
</pre> <p>This option will be displayed in the <a class="reference internal" href="../../manual/cmake-gui.1#manual:cmake-gui(1)" title="cmake-gui(1)" id="index-1-manual:cmake-gui(1)"><code>cmake-gui</code></a> and <a class="reference internal" href="../../manual/ccmake.1#manual:ccmake(1)" title="ccmake(1)" id="index-0-manual:ccmake(1)"><code>ccmake</code></a> with a default value of ON that can be changed by the user. This setting will be stored in the cache so that the user does not need to set the value each time they run CMake on a build directory.</p> <p>The next change is to make building and linking the MathFunctions library conditional. To do this we change the end of the top-level <code>CMakeLists.txt</code> file to look like the following:</p> <pre data-language="cmake">if(USE_MYMATH)
  add_subdirectory(MathFunctions)
  list(APPEND EXTRA_LIBS MathFunctions)
  list(APPEND EXTRA_INCLUDES "${PROJECT_SOURCE_DIR}/MathFunctions")
endif()

# add the executable
add_executable(Tutorial tutorial.cxx)

target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
target_include_directories(Tutorial PUBLIC
                           "${PROJECT_BINARY_DIR}"
                           ${EXTRA_INCLUDES}
                           )
</pre> <p>Note the use of the variable <code>EXTRA_LIBS</code> to collect up any optional libraries to later be linked into the executable. The variable <code>EXTRA_INCLUDES</code> is used similarly for optional header files. This is a classic approach when dealing with many optional components, we will cover the modern approach in the next step.</p> <p>The corresponding changes to the source code are fairly straightforward. First, in <code>tutorial.cxx</code>, include the <code>MathFunctions.h</code> header if we need it:</p> <pre data-language="c">#ifdef USE_MYMATH
#  include "MathFunctions.h"
#endif
</pre> <p>Then, in the same file, make <code>USE_MYMATH</code> control which square root function is used:</p> <pre data-language="c">#ifdef USE_MYMATH
  const double outputValue = mysqrt(inputValue);
#else
  const double outputValue = sqrt(inputValue);
#endif
</pre> <p>Since the source code now requires <code>USE_MYMATH</code> we can add it to <code>TutorialConfig.h.in</code> with the following line:</p> <pre data-language="c">#cmakedefine USE_MYMATH
</pre> <p><strong>Exercise</strong>: Why is it important that we configure <code>TutorialConfig.h.in</code> after the option for <code>USE_MYMATH</code>? What would happen if we inverted the two?</p> <p>Run the <a class="reference internal" href="../../manual/cmake.1#manual:cmake(1)" title="cmake(1)" id="index-1-manual:cmake(1)"><code>cmake</code></a> executable or the <a class="reference internal" href="../../manual/cmake-gui.1#manual:cmake-gui(1)" title="cmake-gui(1)" id="index-2-manual:cmake-gui(1)"><code>cmake-gui</code></a> to configure the project and then build it with your chosen build tool. Then run the built Tutorial executable.</p> <p>Now let’s update the value of <code>USE_MYMATH</code>. The easiest way is to use the <a class="reference internal" href="../../manual/cmake-gui.1#manual:cmake-gui(1)" title="cmake-gui(1)" id="index-3-manual:cmake-gui(1)"><code>cmake-gui</code></a> or <a class="reference internal" href="../../manual/ccmake.1#manual:ccmake(1)" title="ccmake(1)" id="index-1-manual:ccmake(1)"><code>ccmake</code></a> if you’re in the terminal. Or, alternatively, if you want to change the option from the command-line, try:</p> <pre data-language="console">cmake ../Step2 -DUSE_MYMATH=OFF
</pre> <p>Rebuild and run the tutorial again.</p> <p>Which function gives better results, sqrt or mysqrt?</p>   <h2 id="adding-usage-requirements-for-library-step-3">Adding Usage Requirements for Library (Step 3)</h2> <p>Usage requirements allow for far better control over a library or executable’s link and include line while also giving more control over the transitive property of targets inside CMake. The primary commands that leverage usage requirements are:</p>  <ul class="simple"> <li><a class="reference internal" href="../../command/target_compile_definitions#command:target_compile_definitions" title="target_compile_definitions" id="index-0-command:target_compile_definitions"><code>target_compile_definitions()</code></a></li> <li><a class="reference internal" href="../../command/target_compile_options#command:target_compile_options" title="target_compile_options" id="index-0-command:target_compile_options"><code>target_compile_options()</code></a></li> <li><a class="reference internal" href="../../command/target_include_directories#command:target_include_directories" title="target_include_directories" id="index-0-command:target_include_directories"><code>target_include_directories()</code></a></li> <li><a class="reference internal" href="../../command/target_link_libraries#command:target_link_libraries" title="target_link_libraries" id="index-0-command:target_link_libraries"><code>target_link_libraries()</code></a></li> </ul>  <p>Let’s refactor our code from <a class="reference internal" href="#adding-a-library-step-2">Adding a Library (Step 2)</a> to use the modern CMake approach of usage requirements. We first state that anybody linking to MathFunctions needs to include the current source directory, while MathFunctions itself doesn’t. So this can become an <code>INTERFACE</code> usage requirement.</p> <p>Remember <code>INTERFACE</code> means things that consumers require but the producer doesn’t. Add the following lines to the end of <code>MathFunctions/CMakeLists.txt</code>:</p> <pre data-language="cmake">target_include_directories(MathFunctions
          INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
          )
</pre> <p>Now that we’ve specified usage requirements for MathFunctions we can safely remove our uses of the <code>EXTRA_INCLUDES</code> variable from the top-level <code>CMakeLists.txt</code>, here:</p> <pre data-language="cmake">if(USE_MYMATH)
  add_subdirectory(MathFunctions)
  list(APPEND EXTRA_LIBS MathFunctions)
endif()
</pre> <p>And here:</p> <pre data-language="cmake">target_include_directories(Tutorial PUBLIC
                           "${PROJECT_BINARY_DIR}"
                           )
</pre> <p>Once this is done, run the <a class="reference internal" href="../../manual/cmake.1#manual:cmake(1)" title="cmake(1)" id="index-2-manual:cmake(1)"><code>cmake</code></a> executable or the <a class="reference internal" href="../../manual/cmake-gui.1#manual:cmake-gui(1)" title="cmake-gui(1)" id="index-4-manual:cmake-gui(1)"><code>cmake-gui</code></a> to configure the project and then build it with your chosen build tool or by using <code>cmake --build .</code> from the build directory.</p>   <h2 id="installing-and-testing-step-4">Installing and Testing (Step 4)</h2> <p>Now we can start adding install rules and testing support to our project.</p>  <h3 id="install-rules">Install Rules</h3> <p>The install rules are fairly simple: for MathFunctions we want to install the library and header file and for the application we want to install the executable and configured header.</p> <p>So to the end of <code>MathFunctions/CMakeLists.txt</code> we add:</p> <pre data-language="cmake">install(TARGETS MathFunctions DESTINATION lib)
install(FILES MathFunctions.h DESTINATION include)
</pre> <p>And to the end of the top-level <code>CMakeLists.txt</code> we add:</p> <pre data-language="cmake">install(TARGETS Tutorial DESTINATION bin)
install(FILES "${PROJECT_BINARY_DIR}/TutorialConfig.h"
  DESTINATION include
  )
</pre> <p>That is all that is needed to create a basic local install of the tutorial.</p> <p>Now run the <a class="reference internal" href="../../manual/cmake.1#manual:cmake(1)" title="cmake(1)" id="index-3-manual:cmake(1)"><code>cmake</code></a> executable or the <a class="reference internal" href="../../manual/cmake-gui.1#manual:cmake-gui(1)" title="cmake-gui(1)" id="index-5-manual:cmake-gui(1)"><code>cmake-gui</code></a> to configure the project and then build it with your chosen build tool.</p> <p>Then run the install step by using the <code>install</code> option of the <a class="reference internal" href="../../manual/cmake.1#manual:cmake(1)" title="cmake(1)" id="index-4-manual:cmake(1)"><code>cmake</code></a> command (introduced in 3.15, older versions of CMake must use <code>make install</code>) from the command line. For multi-configuration tools, don’t forget to use the <code>--config</code> argument to specify the configuration. If using an IDE, simply build the <code>INSTALL</code> target. This step will install the appropriate header files, libraries, and executables. For example:</p> <pre data-language="console">cmake --install .
</pre> <p>The CMake variable <a class="reference internal" href="../../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX" title="CMAKE_INSTALL_PREFIX" id="index-0-variable:CMAKE_INSTALL_PREFIX"><code>CMAKE_INSTALL_PREFIX</code></a> is used to determine the root of where the files will be installed. If using the <code>cmake --install</code> command, the installation prefix can be overridden via the <code>--prefix</code> argument. For example:</p> <pre data-language="console">cmake --install . --prefix "/home/myuser/installdir"
</pre> <p>Navigate to the install directory and verify that the installed Tutorial runs.</p>   <h3 id="testing-support">Testing Support</h3> <p>Next let’s test our application. At the end of the top-level <code>CMakeLists.txt</code> file we can enable testing and then add a number of basic tests to verify that the application is working correctly.</p> <pre data-language="cmake">enable_testing()

# does the application run
add_test(NAME Runs COMMAND Tutorial 25)

# does the usage message work?
add_test(NAME Usage COMMAND Tutorial)
set_tests_properties(Usage
  PROPERTIES PASS_REGULAR_EXPRESSION "Usage:.*number"
  )

# define a function to simplify adding tests
function(do_test target arg result)
  add_test(NAME Comp${arg} COMMAND ${target} ${arg})
  set_tests_properties(Comp${arg}
    PROPERTIES PASS_REGULAR_EXPRESSION ${result}
    )
endfunction(do_test)

# do a bunch of result based tests
do_test(Tutorial 4 "4 is 2")
do_test(Tutorial 9 "9 is 3")
do_test(Tutorial 5 "5 is 2.236")
do_test(Tutorial 7 "7 is 2.645")
do_test(Tutorial 25 "25 is 5")
do_test(Tutorial -25 "-25 is [-nan|nan|0]")
do_test(Tutorial 0.0001 "0.0001 is 0.01")
</pre> <p>The first test simply verifies that the application runs, does not segfault or otherwise crash, and has a zero return value. This is the basic form of a CTest test.</p> <p>The next test makes use of the <a class="reference internal" href="../../prop_test/pass_regular_expression#prop_test:PASS_REGULAR_EXPRESSION" title="PASS_REGULAR_EXPRESSION" id="index-0-prop_test:PASS_REGULAR_EXPRESSION"><code>PASS_REGULAR_EXPRESSION</code></a> test property to verify that the output of the test contains certain strings. In this case, verifying that the usage message is printed when an incorrect number of arguments are provided.</p> <p>Lastly, we have a function called <code>do_test</code> that runs the application and verifies that the computed square root is correct for given input. For each invocation of <code>do_test</code>, another test is added to the project with a name, input, and expected results based on the passed arguments.</p> <p>Rebuild the application and then cd to the binary directory and run the <a class="reference internal" href="../../manual/ctest.1#manual:ctest(1)" title="ctest(1)" id="index-0-manual:ctest(1)"><code>ctest</code></a> executable: <code>ctest -N</code> and <code>ctest -VV</code>. For multi-config generators (e.g. Visual Studio), the configuration type must be specified. To run tests in Debug mode, for example, use <code>ctest -C Debug -VV</code> from the build directory (not the Debug subdirectory!). Alternatively, build the <code>RUN_TESTS</code> target from the IDE.</p>    <h2 id="adding-system-introspection-step-5">Adding System Introspection (Step 5)</h2> <p>Let us consider adding some code to our project that depends on features the target platform may not have. For this example, we will add some code that depends on whether or not the target platform has the <code>log</code> and <code>exp</code> functions. Of course almost every platform has these functions but for this tutorial assume that they are not common.</p> <p>If the platform has <code>log</code> and <code>exp</code> then we will use them to compute the square root in the <code>mysqrt</code> function. We first test for the availability of these functions using the <a class="reference internal" href="../../module/checksymbolexists#module:CheckSymbolExists" title="CheckSymbolExists" id="index-0-module:CheckSymbolExists"><code>CheckSymbolExists</code></a> module in the top-level <code>CMakeLists.txt</code>. On some platforms, we will need to link to the m library. If <code>log</code> and <code>exp</code> are not initially found, require the m library and try again.</p> <p>We’re going to use the new defines in <code>TutorialConfig.h.in</code>, so be sure to set them before that file is configured.</p> <pre data-language="cmake">include(CheckSymbolExists)
check_symbol_exists(log "math.h" HAVE_LOG)
check_symbol_exists(exp "math.h" HAVE_EXP)
if(NOT (HAVE_LOG AND HAVE_EXP))
  unset(HAVE_LOG CACHE)
  unset(HAVE_EXP CACHE)
  set(CMAKE_REQUIRED_LIBRARIES "m")
  check_symbol_exists(log "math.h" HAVE_LOG)
  check_symbol_exists(exp "math.h" HAVE_EXP)
  if(HAVE_LOG AND HAVE_EXP)
    target_link_libraries(MathFunctions PRIVATE m)
  endif()
endif()
</pre> <p>Now let’s add these defines to <code>TutorialConfig.h.in</code> so that we can use them from <code>mysqrt.cxx</code>:</p> <pre data-language="console">// does the platform provide exp and log functions?
#cmakedefine HAVE_LOG
#cmakedefine HAVE_EXP
</pre> <p>If <code>log</code> and <code>exp</code> are available on the system, then we will use them to compute the square root in the <code>mysqrt</code> function. Add the following code to the <code>mysqrt</code> function in <code>MathFunctions/mysqrt.cxx</code> (don’t forget the <code>#endif</code> before returning the result!):</p> <pre data-language="c">#if defined(HAVE_LOG) &amp;&amp; defined(HAVE_EXP)
  double result = exp(log(x) * 0.5);
  std::cout &lt;&lt; "Computing sqrt of " &lt;&lt; x &lt;&lt; " to be " &lt;&lt; result
            &lt;&lt; " using log and exp" &lt;&lt; std::endl;
#else
  double result = x;
</pre> <p>We will also need to modify <code>mysqrt.cxx</code> to include <code>cmath</code>.</p> <pre data-language="c">#include &lt;cmath&gt;
</pre> <p>Run the <a class="reference internal" href="../../manual/cmake.1#manual:cmake(1)" title="cmake(1)" id="index-5-manual:cmake(1)"><code>cmake</code></a> executable or the <a class="reference internal" href="../../manual/cmake-gui.1#manual:cmake-gui(1)" title="cmake-gui(1)" id="index-6-manual:cmake-gui(1)"><code>cmake-gui</code></a> to configure the project and then build it with your chosen build tool and run the Tutorial executable.</p> <p>You will notice that we’re not using <code>log</code> and <code>exp</code>, even if we think they should be available. We should realize quickly that we have forgotten to include <code>TutorialConfig.h</code> in <code>mysqrt.cxx</code>.</p> <p>We will also need to update <code>MathFunctions/CMakeLists.txt</code> so <code>mysqrt.cxx</code> knows where this file is located:</p> <pre data-language="cmake">target_include_directories(MathFunctions
          INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
          PRIVATE ${CMAKE_BINARY_DIR}
          )
</pre> <p>After making this update, go ahead and build the project again and run the built Tutorial executable. If <code>log</code> and <code>exp</code> are still not being used, open the generated <code>TutorialConfig.h</code> file from the build directory. Maybe they aren’t available on the current system?</p> <p>Which function gives better results now, sqrt or mysqrt?</p>  <h3 id="specify-compile-definition">Specify Compile Definition</h3> <p>Is there a better place for us to save the <code>HAVE_LOG</code> and <code>HAVE_EXP</code> values other than in <code>TutorialConfig.h</code>? Let’s try to use <a class="reference internal" href="../../command/target_compile_definitions#command:target_compile_definitions" title="target_compile_definitions" id="index-1-command:target_compile_definitions"><code>target_compile_definitions()</code></a>.</p> <p>First, remove the defines from <code>TutorialConfig.h.in</code>. We no longer need to include <code>TutorialConfig.h</code> from <code>mysqrt.cxx</code> or the extra include in <code>MathFunctions/CMakeLists.txt</code>.</p> <p>Next, we can move the check for <code>HAVE_LOG</code> and <code>HAVE_EXP</code> to <code>MathFunctions/CMakeLists.txt</code> and then specify those values as <code>PRIVATE</code> compile definitions.</p> <pre data-language="cmake">include(CheckSymbolExists)
check_symbol_exists(log "math.h" HAVE_LOG)
check_symbol_exists(exp "math.h" HAVE_EXP)
if(NOT (HAVE_LOG AND HAVE_EXP))
  unset(HAVE_LOG CACHE)
  unset(HAVE_EXP CACHE)
  set(CMAKE_REQUIRED_LIBRARIES "m")
  check_symbol_exists(log "math.h" HAVE_LOG)
  check_symbol_exists(exp "math.h" HAVE_EXP)
  if(HAVE_LOG AND HAVE_EXP)
    target_link_libraries(MathFunctions PRIVATE m)
  endif()
endif()

# add compile definitions
if(HAVE_LOG AND HAVE_EXP)
  target_compile_definitions(MathFunctions
                             PRIVATE "HAVE_LOG" "HAVE_EXP")
endif()
</pre> <p>After making these updates, go ahead and build the project again. Run the built Tutorial executable and verify that the results are same as earlier in this step.</p>    <h2 id="adding-a-custom-command-and-generated-file-step-6">Adding a Custom Command and Generated File (Step 6)</h2> <p>Suppose, for the purpose of this tutorial, we decide that we never want to use the platform <code>log</code> and <code>exp</code> functions and instead would like to generate a table of precomputed values to use in the <code>mysqrt</code> function. In this section, we will create the table as part of the build process, and then compile that table into our application.</p> <p>First, let’s remove the check for the <code>log</code> and <code>exp</code> functions in <code>MathFunctions/CMakeLists.txt</code>. Then remove the check for <code>HAVE_LOG</code> and <code>HAVE_EXP</code> from <code>mysqrt.cxx</code>. At the same time, we can remove <code>#include &lt;cmath&gt;</code>.</p> <p>In the <code>MathFunctions</code> subdirectory, a new source file named <code>MakeTable.cxx</code> has been provided to generate the table.</p> <p>After reviewing the file, we can see that the table is produced as valid C++ code and that the output filename is passed in as an argument.</p> <p>The next step is to add the appropriate commands to the <code>MathFunctions/CMakeLists.txt</code> file to build the MakeTable executable and then run it as part of the build process. A few commands are needed to accomplish this.</p> <p>First, at the top of <code>MathFunctions/CMakeLists.txt</code>, the executable for <code>MakeTable</code> is added as any other executable would be added.</p> <pre data-language="cmake">add_executable(MakeTable MakeTable.cxx)
</pre> <p>Then we add a custom command that specifies how to produce <code>Table.h</code> by running MakeTable.</p> <pre data-language="cmake">add_custom_command(
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  DEPENDS MakeTable
  )
</pre> <p>Next we have to let CMake know that <code>mysqrt.cxx</code> depends on the generated file <code>Table.h</code>. This is done by adding the generated <code>Table.h</code> to the list of sources for the library MathFunctions.</p> <pre data-language="cmake">add_library(MathFunctions
            mysqrt.cxx
            ${CMAKE_CURRENT_BINARY_DIR}/Table.h
            )
</pre> <p>We also have to add the current binary directory to the list of include directories so that <code>Table.h</code> can be found and included by <code>mysqrt.cxx</code>.</p> <pre data-language="cmake">target_include_directories(MathFunctions
          INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
          PRIVATE ${CMAKE_CURRENT_BINARY_DIR}
          )
</pre> <p>Now let’s use the generated table. First, modify <code>mysqrt.cxx</code> to include <code>Table.h</code>. Next, we can rewrite the mysqrt function to use the table:</p> <pre data-language="c">double mysqrt(double x)
{
  if (x &lt;= 0) {
    return 0;
  }

  // use the table to help find an initial value
  double result = x;
  if (x &gt;= 1 &amp;&amp; x &lt; 10) {
    std::cout &lt;&lt; "Use the table to help find an initial value " &lt;&lt; std::endl;
    result = sqrtTable[static_cast&lt;int&gt;(x)];
  }

  // do ten iterations
  for (int i = 0; i &lt; 10; ++i) {
    if (result &lt;= 0) {
      result = 0.1;
    }
    double delta = x - (result * result);
    result = result + 0.5 * delta / result;
    std::cout &lt;&lt; "Computing sqrt of " &lt;&lt; x &lt;&lt; " to be " &lt;&lt; result &lt;&lt; std::endl;
  }

  return result;
}
</pre> <p>Run the <a class="reference internal" href="../../manual/cmake.1#manual:cmake(1)" title="cmake(1)" id="index-6-manual:cmake(1)"><code>cmake</code></a> executable or the <a class="reference internal" href="../../manual/cmake-gui.1#manual:cmake-gui(1)" title="cmake-gui(1)" id="index-7-manual:cmake-gui(1)"><code>cmake-gui</code></a> to configure the project and then build it with your chosen build tool.</p> <p>When this project is built it will first build the <code>MakeTable</code> executable. It will then run <code>MakeTable</code> to produce <code>Table.h</code>. Finally, it will compile <code>mysqrt.cxx</code> which includes <code>Table.h</code> to produce the MathFunctions library.</p> <p>Run the Tutorial executable and verify that it is using the table.</p>   <h2 id="building-an-installer-step-7">Building an Installer (Step 7)</h2> <p>Next suppose that we want to distribute our project to other people so that they can use it. We want to provide both binary and source distributions on a variety of platforms. This is a little different from the install we did previously in <a class="reference internal" href="#installing-and-testing-step-4">Installing and Testing (Step 4)</a> , where we were installing the binaries that we had built from the source code. In this example we will be building installation packages that support binary installations and package management features. To accomplish this we will use CPack to create platform specific installers. Specifically we need to add a few lines to the bottom of our top-level <code>CMakeLists.txt</code> file.</p> <pre data-language="cmake">include(InstallRequiredSystemLibraries)
set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/License.txt")
set(CPACK_PACKAGE_VERSION_MAJOR "${Tutorial_VERSION_MAJOR}")
set(CPACK_PACKAGE_VERSION_MINOR "${Tutorial_VERSION_MINOR}")
include(CPack)
</pre> <p>That is all there is to it. We start by including <a class="reference internal" href="../../module/installrequiredsystemlibraries#module:InstallRequiredSystemLibraries" title="InstallRequiredSystemLibraries" id="index-0-module:InstallRequiredSystemLibraries"><code>InstallRequiredSystemLibraries</code></a>. This module will include any runtime libraries that are needed by the project for the current platform. Next we set some CPack variables to where we have stored the license and version information for this project. The version information was set earlier in this tutorial and the <code>license.txt</code> has been included in the top-level source directory for this step.</p> <p>Finally we include the <a class="reference internal" href="../../module/cpack#module:CPack" title="CPack" id="index-0-module:CPack"><code>CPack module</code></a> which will use these variables and some other properties of the current system to setup an installer.</p> <p>The next step is to build the project in the usual manner and then run the <a class="reference internal" href="../../manual/cpack.1#manual:cpack(1)" title="cpack(1)" id="index-0-manual:cpack(1)"><code>cpack</code></a> executable. To build a binary distribution, from the binary directory run:</p> <pre data-language="console">cpack
</pre> <p>To specify the generator, use the <code>-G</code> option. For multi-config builds, use <code>-C</code> to specify the configuration. For example:</p> <pre data-language="console">cpack -G ZIP -C Debug
</pre> <p>To create a source distribution you would type:</p> <pre data-language="console">cpack --config CPackSourceConfig.cmake
</pre> <p>Alternatively, run <code>make package</code> or right click the <code>Package</code> target and <code>Build Project</code> from an IDE.</p> <p>Run the installer found in the binary directory. Then run the installed executable and verify that it works.</p>   <h2 id="adding-support-for-a-dashboard-step-8">Adding Support for a Dashboard (Step 8)</h2> <p>Adding support for submitting our test results to a dashboard is simple. We already defined a number of tests for our project in <a class="reference internal" href="#testing-support">Testing Support</a>. Now we just have to run those tests and submit them to a dashboard. To include support for dashboards we include the <a class="reference internal" href="../../module/ctest#module:CTest" title="CTest" id="index-0-module:CTest"><code>CTest</code></a> module in our top-level <code>CMakeLists.txt</code>.</p> <p>Replace:</p> <pre data-language="cmake"># enable testing
enable_testing()
</pre> <p>With:</p> <pre data-language="cmake"># enable dashboard scripting
include(CTest)
</pre> <p>The <a class="reference internal" href="../../module/ctest#module:CTest" title="CTest" id="index-1-module:CTest"><code>CTest</code></a> module will automatically call <code>enable_testing()</code>, so we can remove it from our CMake files.</p> <p>We will also need to create a <code>CTestConfig.cmake</code> file in the top-level directory where we can specify the name of the project and where to submit the dashboard.</p> <pre data-language="cmake">set(CTEST_PROJECT_NAME "CMakeTutorial")
set(CTEST_NIGHTLY_START_TIME "00:00:00 EST")

set(CTEST_DROP_METHOD "http")
set(CTEST_DROP_SITE "my.cdash.org")
set(CTEST_DROP_LOCATION "/submit.php?project=CMakeTutorial")
set(CTEST_DROP_SITE_CDASH TRUE)
</pre> <p>The <a class="reference internal" href="../../manual/ctest.1#manual:ctest(1)" title="ctest(1)" id="index-1-manual:ctest(1)"><code>ctest</code></a> executable will read in this file when it runs. To create a simple dashboard you can run the <a class="reference internal" href="../../manual/cmake.1#manual:cmake(1)" title="cmake(1)" id="index-7-manual:cmake(1)"><code>cmake</code></a> executable or the <a class="reference internal" href="../../manual/cmake-gui.1#manual:cmake-gui(1)" title="cmake-gui(1)" id="index-8-manual:cmake-gui(1)"><code>cmake-gui</code></a> to configure the project, but do not build it yet. Instead, change directory to the binary tree, and then run:</p>  <p>ctest [-VV] -D Experimental</p>  <p>Remember, for multi-config generators (e.g. Visual Studio), the configuration type must be specified:</p> <pre data-language="none">ctest [-VV] -C Debug -D Experimental
</pre> <p>Or, from an IDE, build the <code>Experimental</code> target.</p> <p>The <a class="reference internal" href="../../manual/ctest.1#manual:ctest(1)" title="ctest(1)" id="index-2-manual:ctest(1)"><code>ctest</code></a> executable will build and test the project and submit the results to Kitware’s public dashboard: <a class="reference external" href="https://my.cdash.org/index.php?project=CMakeTutorial">https://my.cdash.org/index.php?project=CMakeTutorial</a>.</p>   <h2 id="mixing-static-and-shared-step-9">Mixing Static and Shared (Step 9)</h2> <p>In this section we will show how the <a class="reference internal" href="../../variable/build_shared_libs#variable:BUILD_SHARED_LIBS" title="BUILD_SHARED_LIBS" id="index-0-variable:BUILD_SHARED_LIBS"><code>BUILD_SHARED_LIBS</code></a> variable can be used to control the default behavior of <a class="reference internal" href="../../command/add_library#command:add_library" title="add_library" id="index-0-command:add_library"><code>add_library()</code></a>, and allow control over how libraries without an explicit type (<code>STATIC</code>, <code>SHARED</code>, <code>MODULE</code> or <code>OBJECT</code>) are built.</p> <p>To accomplish this we need to add <a class="reference internal" href="../../variable/build_shared_libs#variable:BUILD_SHARED_LIBS" title="BUILD_SHARED_LIBS" id="index-1-variable:BUILD_SHARED_LIBS"><code>BUILD_SHARED_LIBS</code></a> to the top-level <code>CMakeLists.txt</code>. We use the <a class="reference internal" href="../../command/option#command:option" title="option" id="index-0-command:option"><code>option()</code></a> command as it allows users to optionally select if the value should be ON or OFF.</p> <p>Next we are going to refactor MathFunctions to become a real library that encapsulates using <code>mysqrt</code> or <code>sqrt</code>, instead of requiring the calling code to do this logic. This will also mean that <code>USE_MYMATH</code> will not control building MathFunctions, but instead will control the behavior of this library.</p> <p>The first step is to update the starting section of the top-level <code>CMakeLists.txt</code> to look like:</p> <pre data-language="cmake">cmake_minimum_required(VERSION 3.10)

# set the project name and version
project(Tutorial VERSION 1.0)

# specify the C++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# control where the static and shared libraries are built so that on windows
# we don't need to tinker with the path to run the executable
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}")
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}")
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}")

option(BUILD_SHARED_LIBS "Build using shared libraries" ON)

# configure a header file to pass the version number only
configure_file(TutorialConfig.h.in TutorialConfig.h)

# add the MathFunctions library
add_subdirectory(MathFunctions)

# add the executable
add_executable(Tutorial tutorial.cxx)
target_link_libraries(Tutorial PUBLIC MathFunctions)
</pre> <p>Now that we have made MathFunctions always be used, we will need to update the logic of that library. So, in <code>MathFunctions/CMakeLists.txt</code> we need to create a SqrtLibrary that will conditionally be built and installed when <code>USE_MYMATH</code> is enabled. Now, since this is a tutorial, we are going to explicitly require that SqrtLibrary is built statically.</p> <p>The end result is that <code>MathFunctions/CMakeLists.txt</code> should look like:</p> <pre data-language="cmake"># add the library that runs
add_library(MathFunctions MathFunctions.cxx)

# state that anybody linking to us needs to include the current source dir
# to find MathFunctions.h, while we don't.
target_include_directories(MathFunctions
                           INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
                           )

# should we use our own math functions
option(USE_MYMATH "Use tutorial provided math implementation" ON)
if(USE_MYMATH)

  target_compile_definitions(MathFunctions PRIVATE "USE_MYMATH")

  # first we add the executable that generates the table
  add_executable(MakeTable MakeTable.cxx)

  # add the command to generate the source code
  add_custom_command(
    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h
    COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h
    DEPENDS MakeTable
    )

  # library that just does sqrt
  add_library(SqrtLibrary STATIC
              mysqrt.cxx
              ${CMAKE_CURRENT_BINARY_DIR}/Table.h
              )

  # state that we depend on our binary dir to find Table.h
  target_include_directories(SqrtLibrary PRIVATE
                             ${CMAKE_CURRENT_BINARY_DIR}
                             )

  target_link_libraries(MathFunctions PRIVATE SqrtLibrary)
endif()

# define the symbol stating we are using the declspec(dllexport) when
# building on windows
target_compile_definitions(MathFunctions PRIVATE "EXPORTING_MYMATH")

# install rules
set(installable_libs MathFunctions)
if(TARGET SqrtLibrary)
  list(APPEND installable_libs SqrtLibrary)
endif()
install(TARGETS ${installable_libs} DESTINATION lib)
install(FILES MathFunctions.h DESTINATION include)
</pre> <p>Next, update <code>MathFunctions/mysqrt.cxx</code> to use the <code>mathfunctions</code> and <code>detail</code> namespaces:</p> <pre data-language="c">#include &lt;iostream&gt;

#include "MathFunctions.h"

// include the generated table
#include "Table.h"

namespace mathfunctions {
namespace detail {
// a hack square root calculation using simple operations
double mysqrt(double x)
{
  if (x &lt;= 0) {
    return 0;
  }

  // use the table to help find an initial value
  double result = x;
  if (x &gt;= 1 &amp;&amp; x &lt; 10) {
    std::cout &lt;&lt; "Use the table to help find an initial value " &lt;&lt; std::endl;
    result = sqrtTable[static_cast&lt;int&gt;(x)];
  }

  // do ten iterations
  for (int i = 0; i &lt; 10; ++i) {
    if (result &lt;= 0) {
      result = 0.1;
    }
    double delta = x - (result * result);
    result = result + 0.5 * delta / result;
    std::cout &lt;&lt; "Computing sqrt of " &lt;&lt; x &lt;&lt; " to be " &lt;&lt; result &lt;&lt; std::endl;
  }

  return result;
}
}
}
</pre> <p>We also need to make some changes in <code>tutorial.cxx</code>, so that it no longer uses <code>USE_MYMATH</code>:</p> <ol class="arabic simple"> <li>Always include <code>MathFunctions.h</code>
</li> <li>Always use <code>mathfunctions::sqrt</code>
</li> <li>Don’t include cmath</li> </ol> <p>Finally, update <code>MathFunctions/MathFunctions.h</code> to use dll export defines:</p> <pre data-language="c">#if defined(_WIN32)
#  if defined(EXPORTING_MYMATH)
#    define DECLSPEC __declspec(dllexport)
#  else
#    define DECLSPEC __declspec(dllimport)
#  endif
#else // non windows
#  define DECLSPEC
#endif

namespace mathfunctions {
double DECLSPEC sqrt(double x);
}
</pre> <p>At this point, if you build everything, you may notice that linking fails as we are combining a static library without position independent code with a library that has position independent code. The solution to this is to explicitly set the <a class="reference internal" href="../../prop_tgt/position_independent_code#prop_tgt:POSITION_INDEPENDENT_CODE" title="POSITION_INDEPENDENT_CODE" id="index-0-prop_tgt:POSITION_INDEPENDENT_CODE"><code>POSITION_INDEPENDENT_CODE</code></a> target property of SqrtLibrary to be True no matter the build type.</p> <pre data-language="cmake">  # state that SqrtLibrary need PIC when the default is shared libraries
  set_target_properties(SqrtLibrary PROPERTIES
                        POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS}
                        )

  target_link_libraries(MathFunctions PRIVATE SqrtLibrary)
</pre> <p><strong>Exercise</strong>: We modified <code>MathFunctions.h</code> to use dll export defines. Using CMake documentation can you find a helper module to simplify this?</p>   <h2 id="adding-generator-expressions-step-10">Adding Generator Expressions (Step 10)</h2> <p><a class="reference internal" href="../../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)" title="cmake-generator-expressions(7)" id="index-0-manual:cmake-generator-expressions(7)"><code>Generator expressions</code></a> are evaluated during build system generation to produce information specific to each build configuration.</p> <p><a class="reference internal" href="../../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)" title="cmake-generator-expressions(7)" id="index-1-manual:cmake-generator-expressions(7)"><code>Generator expressions</code></a> are allowed in the context of many target properties, such as <a class="reference internal" href="../../prop_tgt/link_libraries#prop_tgt:LINK_LIBRARIES" title="LINK_LIBRARIES" id="index-0-prop_tgt:LINK_LIBRARIES"><code>LINK_LIBRARIES</code></a>, <a class="reference internal" href="../../prop_tgt/include_directories#prop_tgt:INCLUDE_DIRECTORIES" title="INCLUDE_DIRECTORIES" id="index-0-prop_tgt:INCLUDE_DIRECTORIES"><code>INCLUDE_DIRECTORIES</code></a>, <a class="reference internal" href="../../prop_tgt/compile_definitions#prop_tgt:COMPILE_DEFINITIONS" title="COMPILE_DEFINITIONS" id="index-0-prop_tgt:COMPILE_DEFINITIONS"><code>COMPILE_DEFINITIONS</code></a> and others. They may also be used when using commands to populate those properties, such as <a class="reference internal" href="../../command/target_link_libraries#command:target_link_libraries" title="target_link_libraries" id="index-1-command:target_link_libraries"><code>target_link_libraries()</code></a>, <a class="reference internal" href="../../command/target_include_directories#command:target_include_directories" title="target_include_directories" id="index-1-command:target_include_directories"><code>target_include_directories()</code></a>, <a class="reference internal" href="../../command/target_compile_definitions#command:target_compile_definitions" title="target_compile_definitions" id="index-2-command:target_compile_definitions"><code>target_compile_definitions()</code></a> and others.</p> <p><a class="reference internal" href="../../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)" title="cmake-generator-expressions(7)" id="index-2-manual:cmake-generator-expressions(7)"><code>Generator expressions</code></a> may be used to enable conditional linking, conditional definitions used when compiling, conditional include directories and more. The conditions may be based on the build configuration, target properties, platform information or any other queryable information.</p> <p>There are different types of <a class="reference internal" href="../../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)" title="cmake-generator-expressions(7)" id="index-3-manual:cmake-generator-expressions(7)"><code>generator expressions</code></a> including Logical, Informational, and Output expressions.</p> <p>Logical expressions are used to create conditional output. The basic expressions are the 0 and 1 expressions. A <code>$&lt;0:...&gt;</code> results in the empty string, and <code>&lt;1:...&gt;</code> results in the content of “…”. They can also be nested.</p> <p>A common usage of <a class="reference internal" href="../../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)" title="cmake-generator-expressions(7)" id="index-4-manual:cmake-generator-expressions(7)"><code>generator expressions</code></a> is to conditionally add compiler flags, such as those for language levels or warnings. A nice pattern is to associate this information to an <code>INTERFACE</code> target allowing this information to propagate. Let’s start by constructing an <code>INTERFACE</code> target and specifying the required C++ standard level of <code>11</code> instead of using <a class="reference internal" href="../../variable/cmake_cxx_standard#variable:CMAKE_CXX_STANDARD" title="CMAKE_CXX_STANDARD" id="index-2-variable:CMAKE_CXX_STANDARD"><code>CMAKE_CXX_STANDARD</code></a>.</p> <p>So the following code:</p> <pre data-language="cmake"># specify the C++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)
</pre> <p>Would be replaced with:</p> <pre data-language="cmake">add_library(tutorial_compiler_flags INTERFACE)
target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)
</pre> <p>Next we add the desired compiler warning flags that we want for our project. As warning flags vary based on the compiler we use the <code>COMPILE_LANG_AND_ID</code> generator expression to control which flags to apply given a language and a set of compiler ids as seen below:</p> <pre data-language="cmake">set(gcc_like_cxx "$&lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU&gt;")
set(msvc_cxx "$&lt;COMPILE_LANG_AND_ID:CXX,MSVC&gt;")
target_compile_options(tutorial_compiler_flags INTERFACE
  "$&lt;${gcc_like_cxx}:$&lt;BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused&gt;&gt;"
  "$&lt;${msvc_cxx}:$&lt;BUILD_INTERFACE:-W3&gt;&gt;"
)
</pre> <p>Looking at this we see that the warning flags are encapsulated inside a <code>BUILD_INTERFACE</code> condition. This is done so that consumers of our installed project will not inherit our warning flags.</p> <p><strong>Exercise</strong>: Modify <code>MathFunctions/CMakeLists.txt</code> so that all targets have a <a class="reference internal" href="../../command/target_link_libraries#command:target_link_libraries" title="target_link_libraries" id="index-2-command:target_link_libraries"><code>target_link_libraries()</code></a> call to <code>tutorial_compiler_flags</code>.</p>   <h2 id="adding-export-configuration-step-11">Adding Export Configuration (Step 11)</h2> <p>During <a class="reference internal" href="#installing-and-testing-step-4">Installing and Testing (Step 4)</a> of the tutorial we added the ability for CMake to install the library and headers of the project. During <a class="reference internal" href="#building-an-installer-step-7">Building an Installer (Step 7)</a> we added the ability to package up this information so it could be distributed to other people.</p> <p>The next step is to add the necessary information so that other CMake projects can use our project, be it from a build directory, a local install or when packaged.</p> <p>The first step is to update our <a class="reference internal" href="../../command/install#command:install" title="install" id="index-0-command:install"><code>install(TARGETS)</code></a> commands to not only specify a <code>DESTINATION</code> but also an <code>EXPORT</code>. The <code>EXPORT</code> keyword generates and installs a CMake file containing code to import all targets listed in the install command from the installation tree. So let’s go ahead and explicitly <code>EXPORT</code> the MathFunctions library by updating the <code>install</code> command in <code>MathFunctions/CMakeLists.txt</code> to look like:</p> <pre data-language="cmake">set(installable_libs MathFunctions tutorial_compiler_flags)
if(TARGET SqrtLibrary)
  list(APPEND installable_libs SqrtLibrary)
endif()
install(TARGETS ${installable_libs}
        DESTINATION lib
        EXPORT MathFunctionsTargets)
install(FILES MathFunctions.h DESTINATION include)
</pre> <p>Now that we have MathFunctions being exported, we also need to explicitly install the generated <code>MathFunctionsTargets.cmake</code> file. This is done by adding the following to the bottom of the top-level <code>CMakeLists.txt</code>:</p> <pre data-language="cmake">install(EXPORT MathFunctionsTargets
  FILE MathFunctionsTargets.cmake
  DESTINATION lib/cmake/MathFunctions
)
</pre> <p>At this point you should try and run CMake. If everything is setup properly you will see that CMake will generate an error that looks like:</p> <pre data-language="console">Target "MathFunctions" INTERFACE_INCLUDE_DIRECTORIES property contains
path:

  "/Users/robert/Documents/CMakeClass/Tutorial/Step11/MathFunctions"

which is prefixed in the source directory.
</pre> <p>What CMake is trying to say is that during generating the export information it will export a path that is intrinsically tied to the current machine and will not be valid on other machines. The solution to this is to update the MathFunctions <a class="reference internal" href="../../command/target_include_directories#command:target_include_directories" title="target_include_directories" id="index-2-command:target_include_directories"><code>target_include_directories()</code></a> to understand that it needs different <code>INTERFACE</code> locations when being used from within the build directory and from an install / package. This means converting the <a class="reference internal" href="../../command/target_include_directories#command:target_include_directories" title="target_include_directories" id="index-3-command:target_include_directories"><code>target_include_directories()</code></a> call for MathFunctions to look like:</p> <pre data-language="cmake">target_include_directories(MathFunctions
                           INTERFACE
                            $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}&gt;
                            $&lt;INSTALL_INTERFACE:include&gt;
                           )
</pre> <p>Once this has been updated, we can re-run CMake and verify that it doesn’t warn anymore.</p> <p>At this point, we have CMake properly packaging the target information that is required but we will still need to generate a <code>MathFunctionsConfig.cmake</code> so that the CMake <a class="reference internal" href="../../command/find_package#command:find_package" title="find_package" id="index-0-command:find_package"><code>find_package()</code></a> command can find our project. So let’s go ahead and add a new file to the top-level of the project called <code>Config.cmake.in</code> with the following contents:</p> <pre data-language="none">
@PACKAGE_INIT@

include ( "${CMAKE_CURRENT_LIST_DIR}/MathFunctionsTargets.cmake" )
</pre> <p>Then, to properly configure and install that file, add the following to the bottom of the top-level <code>CMakeLists.txt</code>:</p> <pre data-language="cmake">install(EXPORT MathFunctionsTargets
  FILE MathFunctionsTargets.cmake
  DESTINATION lib/cmake/MathFunctions
)

include(CMakePackageConfigHelpers)
# generate the config file that is includes the exports
configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in
  "${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake"
  INSTALL_DESTINATION "lib/cmake/example"
  NO_SET_AND_CHECK_MACRO
  NO_CHECK_REQUIRED_COMPONENTS_MACRO
  )
# generate the version file for the config file
write_basic_package_version_file(
  "${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfigVersion.cmake"
  VERSION "${Tutorial_VERSION_MAJOR}.${Tutorial_VERSION_MINOR}"
  COMPATIBILITY AnyNewerVersion
)

# install the configuration file
install(FILES
  ${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsConfig.cmake
  DESTINATION lib/cmake/MathFunctions
  )
</pre> <p>At this point, we have generated a relocatable CMake Configuration for our project that can be used after the project has been installed or packaged. If we want our project to also be used from a build directory we only have to add the following to the bottom of the top level <code>CMakeLists.txt</code>:</p> <pre data-language="cmake">export(EXPORT MathFunctionsTargets
  FILE "${CMAKE_CURRENT_BINARY_DIR}/MathFunctionsTargets.cmake"
)
</pre> <p>With this export call we now generate a <code>Targets.cmake</code>, allowing the configured <code>MathFunctionsConfig.cmake</code> in the build directory to be used by other projects, without needing it to be installed.</p>   <h2 id="packaging-debug-and-release-step-12">Packaging Debug and Release (Step 12)</h2> <p><strong>Note:</strong> This example is valid for single-configuration generators and will not work for multi-configuration generators (e.g. Visual Studio).</p> <p>By default, CMake’s model is that a build directory only contains a single configuration, be it Debug, Release, MinSizeRel, or RelWithDebInfo. It is possible, however, to setup CPack to bundle multiple build directories and construct a package that contains multiple configurations of the same project.</p> <p>First, we want to ensure that the debug and release builds use different names for the executables and libraries that will be installed. Let’s use <code>d</code> as the postfix for the debug executable and libraries.</p> <p>Set <a class="reference internal" href="../../variable/cmake_debug_postfix#variable:CMAKE_DEBUG_POSTFIX" title="CMAKE_DEBUG_POSTFIX" id="index-0-variable:CMAKE_DEBUG_POSTFIX"><code>CMAKE_DEBUG_POSTFIX</code></a> near the beginning of the top-level <code>CMakeLists.txt</code> file:</p> <pre data-language="cmake">set(CMAKE_DEBUG_POSTFIX d)

add_library(tutorial_compiler_flags INTERFACE)
</pre> <p>And the <a class="reference internal" href="../../prop_tgt/debug_postfix#prop_tgt:DEBUG_POSTFIX" title="DEBUG_POSTFIX" id="index-0-prop_tgt:DEBUG_POSTFIX"><code>DEBUG_POSTFIX</code></a> property on the tutorial executable:</p> <pre data-language="cmake">add_executable(Tutorial tutorial.cxx)
set_target_properties(Tutorial PROPERTIES DEBUG_POSTFIX ${CMAKE_DEBUG_POSTFIX})

target_link_libraries(Tutorial PUBLIC MathFunctions)
</pre> <p>Let’s also add version numbering to the MathFunctions library. In <code>MathFunctions/CMakeLists.txt</code>, set the <a class="reference internal" href="../../prop_tgt/version#prop_tgt:VERSION" title="VERSION" id="index-0-prop_tgt:VERSION"><code>VERSION</code></a> and <a class="reference internal" href="../../prop_tgt/soversion#prop_tgt:SOVERSION" title="SOVERSION" id="index-0-prop_tgt:SOVERSION"><code>SOVERSION</code></a> properties:</p> <pre data-language="cmake">set_property(TARGET MathFunctions PROPERTY VERSION "1.0.0")
set_property(TARGET MathFunctions PROPERTY SOVERSION "1")
</pre> <p>From the <code>Step12</code> directory, create <code>debug</code> and <code>release</code> subbdirectories. The layout will look like:</p> <pre data-language="none">- Step12
   - debug
   - release
</pre> <p>Now we need to setup debug and release builds. We can use <a class="reference internal" href="../../variable/cmake_build_type#variable:CMAKE_BUILD_TYPE" title="CMAKE_BUILD_TYPE" id="index-0-variable:CMAKE_BUILD_TYPE"><code>CMAKE_BUILD_TYPE</code></a> to set the configuration type:</p> <pre data-language="console">cd debug
cmake -DCMAKE_BUILD_TYPE=Debug ..
cmake --build .
cd ../release
cmake -DCMAKE_BUILD_TYPE=Release ..
cmake --build .
</pre> <p>Now that both the debug and release builds are complete, we can use a custom configuration file to package both builds into a single release. In the <code>Step12</code> directory, create a file called <code>MultiCPackConfig.cmake</code>. In this file, first include the default configuration file that was created by the <a class="reference internal" href="../../manual/cmake.1#manual:cmake(1)" title="cmake(1)" id="index-8-manual:cmake(1)"><code>cmake</code></a> executable.</p> <p>Next, use the <code>CPACK_INSTALL_CMAKE_PROJECTS</code> variable to specify which projects to install. In this case, we want to install both debug and release.</p> <pre data-language="cmake">include("release/CPackConfig.cmake")

set(CPACK_INSTALL_CMAKE_PROJECTS
    "debug;Tutorial;ALL;/"
    "release;Tutorial;ALL;/"
    )
</pre> <p>From the <code>Step12</code> directory, run <a class="reference internal" href="../../manual/cpack.1#manual:cpack(1)" title="cpack(1)" id="index-1-manual:cpack(1)"><code>cpack</code></a> specifying our custom configuration file with the <code>config</code> option:</p> <pre data-language="console">cpack --config MultiCPackConfig.cmake
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2000–2020 Kitware, Inc. and Contributors<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://cmake.org/cmake/help/v3.19/guide/tutorial/index.html" class="_attribution-link">https://cmake.org/cmake/help/v3.19/guide/tutorial/index.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
