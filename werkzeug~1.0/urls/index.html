
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>URL Helpers - Werkzeug 1.0 - W3cubDocs</title>
  
  <meta name="description" content="werkzeug.urls used to provide several wrapper functions for Python 2 urlparse, whose main purpose were to work around the behavior of the Py2 stdlib &hellip;">
  <meta name="keywords" content="url, helpers, werkzeug, werkzeug~1.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/werkzeug~1.0/urls/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/werkzeug~1.0.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/werkzeug~1.0/" class="_nav-link" title="" style="margin-left:0;">Werkzeug 1.0</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="url-helpers">URL Helpers</h1>  <h2 id="werkzeug-urls">werkzeug.urls</h2> <p><code>werkzeug.urls</code> used to provide several wrapper functions for Python 2 urlparse, whose main purpose were to work around the behavior of the Py2 stdlib and its lack of unicode support. While this was already a somewhat inconvenient situation, it got even more complicated because Python 3’s <code>urllib.parse</code> actually does handle unicode properly. In other words, this module would wrap two libraries with completely different behavior. So now this module contains a 2-and-3-compatible backport of Python 3’s <code>urllib.parse</code>, which is mostly API-compatible.</p> <dl class="class"> <dt id="werkzeug.urls.BaseURL">
<code>class werkzeug.urls.BaseURL</code> </dt> <dd>
<p>Superclass of <a class="reference internal" href="#werkzeug.urls.URL" title="werkzeug.urls.URL"><code>URL</code></a> and <a class="reference internal" href="#werkzeug.urls.BytesURL" title="werkzeug.urls.BytesURL"><code>BytesURL</code></a>.</p> <dl class="attribute"> <dt id="werkzeug.urls.BaseURL.ascii_host">
<code>ascii_host</code> </dt> <dd>
<p>Works exactly like <a class="reference internal" href="#werkzeug.urls.BaseURL.host" title="werkzeug.urls.BaseURL.host"><code>host</code></a> but will return a result that is restricted to ASCII. If it finds a netloc that is not ASCII it will attempt to idna decode it. This is useful for socket operations when the URL might include internationalized characters.</p> </dd>
</dl> <dl class="attribute"> <dt id="werkzeug.urls.BaseURL.auth">
<code>auth</code> </dt> <dd>
<p>The authentication part in the URL if available, <code>None</code> otherwise.</p> </dd>
</dl> <dl class="method"> <dt id="werkzeug.urls.BaseURL.decode_netloc">
<code>decode_netloc()</code> </dt> <dd>
<p>Decodes the netloc part into a string.</p> </dd>
</dl> <dl class="method"> <dt id="werkzeug.urls.BaseURL.decode_query">
<code>decode_query(*args, **kwargs)</code> </dt> <dd>
<p>Decodes the query part of the URL. Ths is a shortcut for calling <a class="reference internal" href="#werkzeug.urls.url_decode" title="werkzeug.urls.url_decode"><code>url_decode()</code></a> on the query argument. The arguments and keyword arguments are forwarded to <a class="reference internal" href="#werkzeug.urls.url_decode" title="werkzeug.urls.url_decode"><code>url_decode()</code></a> unchanged.</p> </dd>
</dl> <dl class="method"> <dt id="werkzeug.urls.BaseURL.get_file_location">
<code>get_file_location(pathformat=None)</code> </dt> <dd>
<p>Returns a tuple with the location of the file in the form <code>(server, location)</code>. If the netloc is empty in the URL or points to localhost, it’s represented as <code>None</code>.</p> <p>The <code>pathformat</code> by default is autodetection but needs to be set when working with URLs of a specific system. The supported values are <code>'windows'</code> when working with Windows or DOS paths and <code>'posix'</code> when working with posix paths.</p> <p>If the URL does not point to a local file, the server and location are both represented as <code>None</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>pathformat</strong> – The expected format of the path component. Currently <code>'windows'</code> and <code>'posix'</code> are supported. Defaults to <code>None</code> which is autodetect.</td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="werkzeug.urls.BaseURL.host">
<code>host</code> </dt> <dd>
<p>The host part of the URL if available, otherwise <code>None</code>. The host is either the hostname or the IP address mentioned in the URL. It will not contain the port.</p> </dd>
</dl> <dl class="method"> <dt id="werkzeug.urls.BaseURL.join">
<code>join(*args, **kwargs)</code> </dt> <dd>
<p>Joins this URL with another one. This is just a convenience function for calling into <a class="reference internal" href="#werkzeug.urls.url_join" title="werkzeug.urls.url_join"><code>url_join()</code></a> and then parsing the return value again.</p> </dd>
</dl> <dl class="attribute"> <dt id="werkzeug.urls.BaseURL.password">
<code>password</code> </dt> <dd>
<p>The password if it was part of the URL, <code>None</code> otherwise. This undergoes URL decoding and will always be a unicode string.</p> </dd>
</dl> <dl class="attribute"> <dt id="werkzeug.urls.BaseURL.port">
<code>port</code> </dt> <dd>
<p>The port in the URL as an integer if it was present, <code>None</code> otherwise. This does not fill in default ports.</p> </dd>
</dl> <dl class="attribute"> <dt id="werkzeug.urls.BaseURL.raw_password">
<code>raw_password</code> </dt> <dd>
<p>The password if it was part of the URL, <code>None</code> otherwise. Unlike <a class="reference internal" href="#werkzeug.urls.BaseURL.password" title="werkzeug.urls.BaseURL.password"><code>password</code></a> this one is not being decoded.</p> </dd>
</dl> <dl class="attribute"> <dt id="werkzeug.urls.BaseURL.raw_username">
<code>raw_username</code> </dt> <dd>
<p>The username if it was part of the URL, <code>None</code> otherwise. Unlike <a class="reference internal" href="#werkzeug.urls.BaseURL.username" title="werkzeug.urls.BaseURL.username"><code>username</code></a> this one is not being decoded.</p> </dd>
</dl> <dl class="method"> <dt id="werkzeug.urls.BaseURL.replace">
<code>replace(**kwargs)</code> </dt> <dd>
<p>Return an URL with the same values, except for those parameters given new values by whichever keyword arguments are specified.</p> </dd>
</dl> <dl class="method"> <dt id="werkzeug.urls.BaseURL.to_iri_tuple">
<code>to_iri_tuple()</code> </dt> <dd>
<p>Returns a <a class="reference internal" href="#werkzeug.urls.URL" title="werkzeug.urls.URL"><code>URL</code></a> tuple that holds a IRI. This will try to decode as much information as possible in the URL without losing information similar to how a web browser does it for the URL bar.</p> <p>It’s usually more interesting to directly call <a class="reference internal" href="#werkzeug.urls.uri_to_iri" title="werkzeug.urls.uri_to_iri"><code>uri_to_iri()</code></a> which will return a string.</p> </dd>
</dl> <dl class="method"> <dt id="werkzeug.urls.BaseURL.to_uri_tuple">
<code>to_uri_tuple()</code> </dt> <dd>
<p>Returns a <a class="reference internal" href="#werkzeug.urls.BytesURL" title="werkzeug.urls.BytesURL"><code>BytesURL</code></a> tuple that holds a URI. This will encode all the information in the URL properly to ASCII using the rules a web browser would follow.</p> <p>It’s usually more interesting to directly call <a class="reference internal" href="#werkzeug.urls.iri_to_uri" title="werkzeug.urls.iri_to_uri"><code>iri_to_uri()</code></a> which will return a string.</p> </dd>
</dl> <dl class="method"> <dt id="werkzeug.urls.BaseURL.to_url">
<code>to_url()</code> </dt> <dd>
<p>Returns a URL string or bytes depending on the type of the information stored. This is just a convenience function for calling <a class="reference internal" href="#werkzeug.urls.url_unparse" title="werkzeug.urls.url_unparse"><code>url_unparse()</code></a> for this URL.</p> </dd>
</dl> <dl class="attribute"> <dt id="werkzeug.urls.BaseURL.username">
<code>username</code> </dt> <dd>
<p>The username if it was part of the URL, <code>None</code> otherwise. This undergoes URL decoding and will always be a unicode string.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="werkzeug.urls.BytesURL">
<code>class werkzeug.urls.BytesURL</code> </dt> <dd>
<p>Represents a parsed URL in bytes.</p> <dl class="method"> <dt id="werkzeug.urls.BytesURL.decode">
<code>decode(charset='utf-8', errors='replace')</code> </dt> <dd>
<p>Decodes the URL to a tuple made out of strings. The charset is only being used for the path, query and fragment.</p> </dd>
</dl> <dl class="method"> <dt id="werkzeug.urls.BytesURL.encode_netloc">
<code>encode_netloc()</code> </dt> <dd>
<p>Returns the netloc unchanged as bytes.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="werkzeug.urls.Href">
<code>class werkzeug.urls.Href(base='./', charset='utf-8', sort=False, key=None)</code> </dt> <dd>
<p>Implements a callable that constructs URLs with the given base. The function can be called with any number of positional and keyword arguments which than are used to assemble the URL. Works with URLs and posix paths.</p> <p>Positional arguments are appended as individual segments to the path of the URL:</p> <pre data-language="python">&gt;&gt;&gt; href = Href('/foo')
&gt;&gt;&gt; href('bar', 23)
'/foo/bar/23'
&gt;&gt;&gt; href('foo', bar=23)
'/foo/foo?bar=23'
</pre> <p>If any of the arguments (positional or keyword) evaluates to <code>None</code> it will be skipped. If no keyword arguments are given the last argument can be a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><code>dict</code></a> or <code>MultiDict</code> (or any other dict subclass), otherwise the keyword arguments are used for the query parameters, cutting off the first trailing underscore of the parameter name:</p> <pre data-language="python">&gt;&gt;&gt; href(is_=42)
'/foo?is=42'
&gt;&gt;&gt; href({'foo': 'bar'})
'/foo?foo=bar'
</pre> <p>Combining of both methods is not allowed:</p> <pre data-language="python">&gt;&gt;&gt; href({'foo': 'bar'}, bar=42)
Traceback (most recent call last):
  ...
TypeError: keyword arguments and query-dicts can't be combined
</pre> <p>Accessing attributes on the href object creates a new href object with the attribute name as prefix:</p> <pre data-language="python">&gt;&gt;&gt; bar_href = href.bar
&gt;&gt;&gt; bar_href("blub")
'/foo/bar/blub'
</pre> <p>If <code>sort</code> is set to <code>True</code> the items are sorted by <code>key</code> or the default sorting algorithm:</p> <pre data-language="python">&gt;&gt;&gt; href = Href("/", sort=True)
&gt;&gt;&gt; href(a=1, b=2, c=3)
'/?a=1&amp;b=2&amp;c=3'
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.5: </span><code>sort</code> and <code>key</code> were added.</p> </div> </details>
</dd>
</dl> <dl class="class"> <dt id="werkzeug.urls.URL">
<code>class werkzeug.urls.URL</code> </dt> <dd>
<p>Represents a parsed URL. This behaves like a regular tuple but also has some extra attributes that give further insight into the URL.</p> <dl class="method"> <dt id="werkzeug.urls.URL.encode">
<code>encode(charset='utf-8', errors='replace')</code> </dt> <dd>
<p>Encodes the URL to a tuple made out of bytes. The charset is only being used for the path, query and fragment.</p> </dd>
</dl> <dl class="method"> <dt id="werkzeug.urls.URL.encode_netloc">
<code>encode_netloc()</code> </dt> <dd>
<p>Encodes the netloc part to an ASCII safe URL as bytes.</p> </dd>
</dl> </dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.iri_to_uri">
<code>werkzeug.urls.iri_to_uri(iri, charset='utf-8', errors='strict', safe_conversion=False)</code> </dt> <dd>
<p>Convert an IRI to a URI. All non-ASCII and unsafe characters are quoted. If the URL has a domain, it is encoded to Punycode.</p> <pre data-language="python">&gt;&gt;&gt; iri_to_uri('http://\u2603.net/p\xe5th?q=\xe8ry%DF')
'http://xn--n3h.net/p%C3%A5th?q=%C3%A8ry%DF'
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>iri</strong> – The IRI to convert.</li> <li>
<strong>charset</strong> – The encoding of the IRI.</li> <li>
<strong>errors</strong> – Error handler to use during <code>bytes.encode</code>.</li> <li>
<strong>safe_conversion</strong> – Return the URL unchanged if it only contains ASCII characters and no whitespace. See the explanation below.</li> </ul> </td> </tr>  </table> <p>There is a general problem with IRI conversion with some protocols that are in violation of the URI specification. Consider the following two IRIs:</p> <pre data-language="python">magnet:?xt=uri:whatever
itms-services://?action=download-manifest
</pre> <p>After parsing, we don’t know if the scheme requires the <code>//</code>, which is dropped if empty, but conveys different meanings in the final URL if it’s present or not. In this case, you can use <code>safe_conversion</code>, which will return the URL unchanged if it only contains ASCII characters and no whitespace. This can result in a URI with unquoted characters if it was not already quoted correctly, but preserves the URL’s semantics. Werkzeug uses this for the <code>Location</code> header for redirects.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified">Changed in version 0.15: </span>All reserved characters remain unquoted. Previously, only some reserved characters were left unquoted.</p> </div> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 0.9.6: </span>The <code>safe_conversion</code> parameter was added.</p> </div> <div class="versionadded"> <p><span class="versionmodified">New in version 0.6.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.uri_to_iri">
<code>werkzeug.urls.uri_to_iri(uri, charset='utf-8', errors='werkzeug.url_quote')</code> </dt> <dd>
<p>Convert a URI to an IRI. All valid UTF-8 characters are unquoted, leaving all reserved and invalid characters quoted. If the URL has a domain, it is decoded from Punycode.</p> <pre data-language="python">&gt;&gt;&gt; uri_to_iri("http://xn--n3h.net/p%C3%A5th?q=%C3%A8ry%DF")
'http://\u2603.net/p\xe5th?q=\xe8ry%DF'
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>uri</strong> – The URI to convert.</li> <li>
<strong>charset</strong> – The encoding to encode unquoted bytes with.</li> <li>
<strong>errors</strong> – Error handler to use during <code>bytes.encode</code>. By default, invalid bytes are left quoted.</li> </ul> </td> </tr>  </table> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified">Changed in version 0.15: </span>All reserved and invalid characters remain quoted. Previously, only some reserved characters were preserved, and invalid bytes were replaced instead of left quoted.</p> </div> <div class="versionadded"> <p><span class="versionmodified">New in version 0.6.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.url_decode">
<code>werkzeug.urls.url_decode(s, charset='utf-8', decode_keys=False, include_empty=True, errors='replace', separator='&amp;', cls=None)</code> </dt> <dd>
<p>Parse a querystring and return it as <code>MultiDict</code>. There is a difference in key decoding on different Python versions. On Python 3 keys will always be fully decoded whereas on Python 2, keys will remain bytestrings if they fit into ASCII. On 2.x keys can be forced to be unicode by setting <code>decode_keys</code> to <code>True</code>.</p> <p>If the charset is set to <code>None</code> no unicode decoding will happen and raw bytes will be returned.</p> <p>Per default a missing value for a key will default to an empty key. If you don’t want that behavior you can set <code>include_empty</code> to <code>False</code>.</p> <p>Per default encoding errors are ignored. If you want a different behavior you can set <code>errors</code> to <code>'replace'</code> or <code>'strict'</code>. In strict mode a <code>HTTPUnicodeError</code> is raised.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified">Changed in version 0.5: </span>In previous versions “;” and “&amp;” could be used for url decoding. This changed in 0.5 where only “&amp;” is supported. If you want to use “;” instead a different <code>separator</code> can be provided.</p> <p>The <code>cls</code> parameter was added.</p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>s</strong> – a string with the query string to decode.</li> <li>
<strong>charset</strong> – the charset of the query string. If set to <code>None</code> no unicode decoding will take place.</li> <li>
<strong>decode_keys</strong> – Used on Python 2.x to control whether keys should be forced to be unicode objects. If set to <code>True</code> then keys will be unicode in all cases. Otherwise, they remain <code>str</code> if they fit into ASCII.</li> <li>
<strong>include_empty</strong> – Set to <code>False</code> if you don’t want empty values to appear in the dict.</li> <li>
<strong>errors</strong> – the decoding error behavior.</li> <li>
<strong>separator</strong> – the pair separator to be used, defaults to <code>&amp;</code>
</li> <li>
<strong>cls</strong> – an optional dict class to use. If this is not specified or <code>None</code> the default <code>MultiDict</code> is used.</li> </ul> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.url_decode_stream">
<code>werkzeug.urls.url_decode_stream(stream, charset='utf-8', decode_keys=False, include_empty=True, errors='replace', separator='&amp;', cls=None, limit=None, return_iterator=False)</code> </dt> <dd>
<p>Works like <a class="reference internal" href="#werkzeug.urls.url_decode" title="werkzeug.urls.url_decode"><code>url_decode()</code></a> but decodes a stream. The behavior of stream and limit follows functions like <a class="reference internal" href="../wsgi/index#werkzeug.wsgi.make_line_iter" title="werkzeug.wsgi.make_line_iter"><code>make_line_iter()</code></a>. The generator of pairs is directly fed to the <code>cls</code> so you can consume the data while it’s parsed.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.8.</span></p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>stream</strong> – a stream with the encoded querystring</li> <li>
<strong>charset</strong> – the charset of the query string. If set to <code>None</code> no unicode decoding will take place.</li> <li>
<strong>decode_keys</strong> – Used on Python 2.x to control whether keys should be forced to be unicode objects. If set to <code>True</code>, keys will be unicode in all cases. Otherwise, they remain <code>str</code> if they fit into ASCII.</li> <li>
<strong>include_empty</strong> – Set to <code>False</code> if you don’t want empty values to appear in the dict.</li> <li>
<strong>errors</strong> – the decoding error behavior.</li> <li>
<strong>separator</strong> – the pair separator to be used, defaults to <code>&amp;</code>
</li> <li>
<strong>cls</strong> – an optional dict class to use. If this is not specified or <code>None</code> the default <code>MultiDict</code> is used.</li> <li>
<strong>limit</strong> – the content length of the URL data. Not necessary if a limited stream is provided.</li> <li>
<strong>return_iterator</strong> – if set to <code>True</code> the <code>cls</code> argument is ignored and an iterator over all decoded pairs is returned</li> </ul> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.url_encode">
<code>werkzeug.urls.url_encode(obj, charset='utf-8', encode_keys=False, sort=False, key=None, separator=b'&amp;')</code> </dt> <dd>
<p>URL encode a dict/<code>MultiDict</code>. If a value is <code>None</code> it will not appear in the result string. Per default only values are encoded into the target charset strings. If <code>encode_keys</code> is set to <code>True</code> unicode keys are supported too.</p> <p>If <code>sort</code> is set to <code>True</code> the items are sorted by <code>key</code> or the default sorting algorithm.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.5: </span><code>sort</code>, <code>key</code>, and <code>separator</code> were added.</p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>obj</strong> – the object to encode into a query string.</li> <li>
<strong>charset</strong> – the charset of the query string.</li> <li>
<strong>encode_keys</strong> – set to <code>True</code> if you have unicode keys. (Ignored on Python 3.x)</li> <li>
<strong>sort</strong> – set to <code>True</code> if you want parameters to be sorted by <code>key</code>.</li> <li>
<strong>separator</strong> – the separator to be used for the pairs.</li> <li>
<strong>key</strong> – an optional function to be used for sorting. For more details check out the <a class="reference external" href="https://docs.python.org/3/library/functions.html#sorted" title="(in Python v3.8)"><code>sorted()</code></a> documentation.</li> </ul> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.url_encode_stream">
<code>werkzeug.urls.url_encode_stream(obj, stream=None, charset='utf-8', encode_keys=False, sort=False, key=None, separator=b'&amp;')</code> </dt> <dd>
<p>Like <a class="reference internal" href="#werkzeug.urls.url_encode" title="werkzeug.urls.url_encode"><code>url_encode()</code></a> but writes the results to a stream object. If the stream is <code>None</code> a generator over all encoded pairs is returned.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.8.</span></p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>obj</strong> – the object to encode into a query string.</li> <li>
<strong>stream</strong> – a stream to write the encoded object into or <code>None</code> if an iterator over the encoded pairs should be returned. In that case the separator argument is ignored.</li> <li>
<strong>charset</strong> – the charset of the query string.</li> <li>
<strong>encode_keys</strong> – set to <code>True</code> if you have unicode keys. (Ignored on Python 3.x)</li> <li>
<strong>sort</strong> – set to <code>True</code> if you want parameters to be sorted by <code>key</code>.</li> <li>
<strong>separator</strong> – the separator to be used for the pairs.</li> <li>
<strong>key</strong> – an optional function to be used for sorting. For more details check out the <a class="reference external" href="https://docs.python.org/3/library/functions.html#sorted" title="(in Python v3.8)"><code>sorted()</code></a> documentation.</li> </ul> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.url_fix">
<code>werkzeug.urls.url_fix(s, charset='utf-8')</code> </dt> <dd>
<p>Sometimes you get an URL by a user that just isn’t a real URL because it contains unsafe characters like ‘ ‘ and so on. This function can fix some of the problems in a similar way browsers handle data entered by the user:</p> <pre data-language="python">&gt;&gt;&gt; url_fix(u'http://de.wikipedia.org/wiki/Elf (Begriffskl\xe4rung)')
'http://de.wikipedia.org/wiki/Elf%20(Begriffskl%C3%A4rung)'
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>s</strong> – the string with the URL to fix.</li> <li>
<strong>charset</strong> – The target charset for the URL if the url was given as unicode string.</li> </ul> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.url_join">
<code>werkzeug.urls.url_join(base, url, allow_fragments=True)</code> </dt> <dd>
<p>Join a base URL and a possibly relative URL to form an absolute interpretation of the latter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>base</strong> – the base URL for the join operation.</li> <li>
<strong>url</strong> – the URL to join.</li> <li>
<strong>allow_fragments</strong> – indicates whether fragments should be allowed.</li> </ul> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.url_parse">
<code>werkzeug.urls.url_parse(url, scheme=None, allow_fragments=True)</code> </dt> <dd>
<p>Parses a URL from a string into a <a class="reference internal" href="#werkzeug.urls.URL" title="werkzeug.urls.URL"><code>URL</code></a> tuple. If the URL is lacking a scheme it can be provided as second argument. Otherwise, it is ignored. Optionally fragments can be stripped from the URL by setting <code>allow_fragments</code> to <code>False</code>.</p> <p>The inverse of this function is <a class="reference internal" href="#werkzeug.urls.url_unparse" title="werkzeug.urls.url_unparse"><code>url_unparse()</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>url</strong> – the URL to parse.</li> <li>
<strong>scheme</strong> – the default schema to use if the URL is schemaless.</li> <li>
<strong>allow_fragments</strong> – if set to <code>False</code> a fragment will be removed from the URL.</li> </ul> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.url_quote">
<code>werkzeug.urls.url_quote(string, charset='utf-8', errors='strict', safe='/:', unsafe='')</code> </dt> <dd>
<p>URL encode a single string with a given encoding.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>s</strong> – the string to quote.</li> <li>
<strong>charset</strong> – the charset to be used.</li> <li>
<strong>safe</strong> – an optional sequence of safe characters.</li> <li>
<strong>unsafe</strong> – an optional sequence of unsafe characters.</li> </ul> </td> </tr>  </table> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.9.2: </span>The <code>unsafe</code> parameter was added.</p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.url_quote_plus">
<code>werkzeug.urls.url_quote_plus(string, charset='utf-8', errors='strict', safe='')</code> </dt> <dd>
<p>URL encode a single string with the given encoding and convert whitespace to “+”.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>s</strong> – The string to quote.</li> <li>
<strong>charset</strong> – The charset to be used.</li> <li>
<strong>safe</strong> – An optional sequence of safe characters.</li> </ul> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.url_unparse">
<code>werkzeug.urls.url_unparse(components)</code> </dt> <dd>
<p>The reverse operation to <a class="reference internal" href="#werkzeug.urls.url_parse" title="werkzeug.urls.url_parse"><code>url_parse()</code></a>. This accepts arbitrary as well as <a class="reference internal" href="#werkzeug.urls.URL" title="werkzeug.urls.URL"><code>URL</code></a> tuples and returns a URL as a string.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>components</strong> – the parsed URL as tuple which should be converted into a URL string.</td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.url_unquote">
<code>werkzeug.urls.url_unquote(string, charset='utf-8', errors='replace', unsafe='')</code> </dt> <dd>
<p>URL decode a single string with a given encoding. If the charset is set to <code>None</code> no unicode decoding is performed and raw bytes are returned.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>s</strong> – the string to unquote.</li> <li>
<strong>charset</strong> – the charset of the query string. If set to <code>None</code> no unicode decoding will take place.</li> <li>
<strong>errors</strong> – the error handling for the charset decoding.</li> </ul> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.urls.url_unquote_plus">
<code>werkzeug.urls.url_unquote_plus(s, charset='utf-8', errors='replace')</code> </dt> <dd>
<p>URL decode a single string with the given <code>charset</code> and decode “+” to whitespace.</p> <p>Per default encoding errors are ignored. If you want a different behavior you can set <code>errors</code> to <code>'replace'</code> or <code>'strict'</code>. In strict mode a <code>HTTPUnicodeError</code> is raised.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>s</strong> – The string to unquote.</li> <li>
<strong>charset</strong> – the charset of the query string. If set to <code>None</code> no unicode decoding will take place.</li> <li>
<strong>errors</strong> – The error handling for the <code>charset</code> decoding.</li> </ul> </td> </tr>  </table> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2020 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://werkzeug.palletsprojects.com/en/1.0.x/urls/" class="_attribution-link">https://werkzeug.palletsprojects.com/en/1.0.x/urls/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
