
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>HTTP Utilities - Werkzeug 1.0 - W3cubDocs</title>
  
  <meta name="description" content="Werkzeug provides a couple of functions to parse and generate HTTP headers that are useful when implementing WSGI middlewares or whenever you are &hellip;">
  <meta name="keywords" content="http, utilities, werkzeug, werkzeug~1.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/werkzeug~1.0/http/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/werkzeug~1.0.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/werkzeug~1.0/" class="_nav-link" title="" style="margin-left:0;">Werkzeug 1.0</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="http-utilities">HTTP Utilities</h1> <p>Werkzeug provides a couple of functions to parse and generate HTTP headers that are useful when implementing WSGI middlewares or whenever you are operating on a lower level layer. All this functionality is also exposed from request and response objects.</p>  <h2 id="date-functions">Date Functions</h2> <p>The following functions simplify working with times in an HTTP context. Werkzeug uses offset-naive <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.8)"><code>datetime</code></a> objects internally that store the time in UTC. If you’re working with timezones in your application make sure to replace the tzinfo attribute with a UTC timezone information before processing the values.</p> <dl class="function"> <dt id="werkzeug.http.cookie_date">
<code>werkzeug.http.cookie_date(expires=None)</code> </dt> <dd>
<p>Formats the time to ensure compatibility with Netscape’s cookie standard.</p> <p>Accepts a floating point number expressed in seconds since the epoch in, a datetime object or a timetuple. All times in UTC. The <a class="reference internal" href="#werkzeug.http.parse_date" title="werkzeug.http.parse_date"><code>parse_date()</code></a> function can be used to parse such a date.</p> <p>Outputs a string in the format <code>Wdy, DD-Mon-YYYY HH:MM:SS GMT</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>expires</strong> – If provided that date is used, otherwise the current.</td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.http_date">
<code>werkzeug.http.http_date(timestamp=None)</code> </dt> <dd>
<p>Formats the time to match the RFC1123 date format.</p> <p>Accepts a floating point number expressed in seconds since the epoch in, a datetime object or a timetuple. All times in UTC. The <a class="reference internal" href="#werkzeug.http.parse_date" title="werkzeug.http.parse_date"><code>parse_date()</code></a> function can be used to parse such a date.</p> <p>Outputs a string in the format <code>Wdy, DD Mon YYYY HH:MM:SS GMT</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>timestamp</strong> – If provided that date is used, otherwise the current.</td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.parse_date">
<code>werkzeug.http.parse_date(value)</code> </dt> <dd>
<p>Parse one of the following date formats into a datetime object:</p> <pre data-language="text">Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format
</pre> <p>If parsing fails the return value is <code>None</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>value</strong> – a string with a supported date format.</td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">a <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.8)"><code>datetime.datetime</code></a> object.</td> </tr>  </table> </dd>
</dl>   <h2 id="header-parsing">Header Parsing</h2> <p>The following functions can be used to parse incoming HTTP headers. Because Python does not provide data structures with the semantics required by <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html" id="index-0"><strong>RFC 2616</strong></a>, Werkzeug implements some custom data structures that are <a class="reference internal" href="../datastructures/index#http-datastructures"><span class="std std-ref">documented separately</span></a>.</p> <dl class="function"> <dt id="werkzeug.http.parse_options_header">
<code>werkzeug.http.parse_options_header(value, multiple=False)</code> </dt> <dd>
<p>Parse a <code>Content-Type</code> like header into a tuple with the content type and the options:</p> <pre data-language="python">&gt;&gt;&gt; parse_options_header('text/html; charset=utf8')
('text/html', {'charset': 'utf8'})
</pre> <p>This should not be used to parse <code>Cache-Control</code> like headers that use a slightly different format. For these headers use the <a class="reference internal" href="#werkzeug.http.parse_dict_header" title="werkzeug.http.parse_dict_header"><code>parse_dict_header()</code></a> function.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified">Changed in version 0.15: </span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2231.html" id="index-1"><strong>RFC 2231</strong></a> parameter continuations are handled.</p> </div> <div class="versionadded"> <p><span class="versionmodified">New in version 0.5.</span></p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>value</strong> – the header to parse.</li> <li>
<strong>multiple</strong> – Whether try to parse and return multiple MIME types</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last">(mimetype, options) or (mimetype, options, mimetype, options, …) if multiple=True</p> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.parse_set_header">
<code>werkzeug.http.parse_set_header(value, on_update=None)</code> </dt> <dd>
<p>Parse a set-like header and return a <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.HeaderSet" title="werkzeug.datastructures.HeaderSet"><code>HeaderSet</code></a> object:</p> <pre data-language="python">&gt;&gt;&gt; hs = parse_set_header('token, "quoted value"')
</pre> <p>The return value is an object that treats the items case-insensitively and keeps the order of the items:</p> <pre data-language="python">&gt;&gt;&gt; 'TOKEN' in hs
True
&gt;&gt;&gt; hs.index('quoted value')
1
&gt;&gt;&gt; hs
HeaderSet(['token', 'quoted value'])
</pre> <p>To create a header from the <code>HeaderSet</code> again, use the <a class="reference internal" href="#werkzeug.http.dump_header" title="werkzeug.http.dump_header"><code>dump_header()</code></a> function.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>value</strong> – a set header to be parsed.</li> <li>
<strong>on_update</strong> – an optional callable that is called every time a value on the <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.HeaderSet" title="werkzeug.datastructures.HeaderSet"><code>HeaderSet</code></a> object is changed.</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last">a <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.HeaderSet" title="werkzeug.datastructures.HeaderSet"><code>HeaderSet</code></a></p> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.parse_list_header">
<code>werkzeug.http.parse_list_header(value)</code> </dt> <dd>
<p>Parse lists as described by RFC 2068 Section 2.</p> <p>In particular, parse comma-separated lists where the elements of the list may include quoted-strings. A quoted-string could contain a comma. A non-quoted string could have quotes in the middle. Quotes are removed automatically after parsing.</p> <p>It basically works like <a class="reference internal" href="#werkzeug.http.parse_set_header" title="werkzeug.http.parse_set_header"><code>parse_set_header()</code></a> just that items may appear multiple times and case sensitivity is preserved.</p> <p>The return value is a standard <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><code>list</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; parse_list_header('token, "quoted value"')
['token', 'quoted value']
</pre> <p>To create a header from the <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><code>list</code></a> again, use the <a class="reference internal" href="#werkzeug.http.dump_header" title="werkzeug.http.dump_header"><code>dump_header()</code></a> function.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>value</strong> – a string with a list header.</td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.8)"><code>list</code></a></td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.parse_dict_header">
<code>werkzeug.http.parse_dict_header(value, cls=&lt;class 'dict'&gt;)</code> </dt> <dd>
<p>Parse lists of key, value pairs as described by RFC 2068 Section 2 and convert them into a python dict (or any other mapping object created from the type with a dict like interface provided by the <code>cls</code> argument):</p> <pre data-language="python">&gt;&gt;&gt; d = parse_dict_header('foo="is a fish", bar="as well"')
&gt;&gt;&gt; type(d) is dict
True
&gt;&gt;&gt; sorted(d.items())
[('bar', 'as well'), ('foo', 'is a fish')]
</pre> <p>If there is no value for a key it will be <code>None</code>:</p> <pre data-language="python">&gt;&gt;&gt; parse_dict_header('key_without_value')
{'key_without_value': None}
</pre> <p>To create a header from the <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.8)"><code>dict</code></a> again, use the <a class="reference internal" href="#werkzeug.http.dump_header" title="werkzeug.http.dump_header"><code>dump_header()</code></a> function.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified">Changed in version 0.9: </span>Added support for <code>cls</code> argument.</p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>value</strong> – a string with a dict header.</li> <li>
<strong>cls</strong> – callable to use for storage of parsed results.</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last">an instance of <code>cls</code></p> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.parse_accept_header">
<code>werkzeug.http.parse_accept_header(value[, class])</code> </dt> <dd>
<p>Parses an HTTP Accept-* header. This does not implement a complete valid algorithm but one that supports at least value and quality extraction.</p> <p>Returns a new <code>Accept</code> object (basically a list of <code>(value, quality)</code> tuples sorted by the quality with some additional accessor methods).</p> <p>The second parameter can be a subclass of <code>Accept</code> that is created with the parsed values and returned.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>value</strong> – the accept header string to be parsed.</li> <li>
<strong>cls</strong> – the wrapper class for the return value (can be <code>Accept</code> or a subclass thereof)</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last">an instance of <code>cls</code>.</p> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.parse_cache_control_header">
<code>werkzeug.http.parse_cache_control_header(value, on_update=None, cls=None)</code> </dt> <dd>
<p>Parse a cache control header. The RFC differs between response and request cache control, this method does not. It’s your responsibility to not use the wrong control statements.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.5: </span>The <code>cls</code> was added. If not specified an immutable <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.RequestCacheControl" title="werkzeug.datastructures.RequestCacheControl"><code>RequestCacheControl</code></a> is returned.</p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>value</strong> – a cache control header to be parsed.</li> <li>
<strong>on_update</strong> – an optional callable that is called every time a value on the <code>CacheControl</code> object is changed.</li> <li>
<strong>cls</strong> – the class for the returned object. By default <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.RequestCacheControl" title="werkzeug.datastructures.RequestCacheControl"><code>RequestCacheControl</code></a> is used.</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last">a <code>cls</code> object.</p> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.parse_authorization_header">
<code>werkzeug.http.parse_authorization_header(value)</code> </dt> <dd>
<p>Parse an HTTP basic/digest authorization header transmitted by the web browser. The return value is either <code>None</code> if the header was invalid or not given, otherwise an <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.Authorization" title="werkzeug.datastructures.Authorization"><code>Authorization</code></a> object.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>value</strong> – the authorization header to parse.</td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">a <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.Authorization" title="werkzeug.datastructures.Authorization"><code>Authorization</code></a> object or <code>None</code>.</td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.parse_www_authenticate_header">
<code>werkzeug.http.parse_www_authenticate_header(value, on_update=None)</code> </dt> <dd>
<p>Parse an HTTP WWW-Authenticate header into a <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.WWWAuthenticate" title="werkzeug.datastructures.WWWAuthenticate"><code>WWWAuthenticate</code></a> object.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>value</strong> – a WWW-Authenticate header to parse.</li> <li>
<strong>on_update</strong> – an optional callable that is called every time a value on the <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.WWWAuthenticate" title="werkzeug.datastructures.WWWAuthenticate"><code>WWWAuthenticate</code></a> object is changed.</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last">a <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.WWWAuthenticate" title="werkzeug.datastructures.WWWAuthenticate"><code>WWWAuthenticate</code></a> object.</p> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.parse_if_range_header">
<code>werkzeug.http.parse_if_range_header(value)</code> </dt> <dd>
<p>Parses an if-range header which can be an etag or a date. Returns a <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.IfRange" title="werkzeug.datastructures.IfRange"><code>IfRange</code></a> object.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="werkzeug.http.parse_range_header">
<code>werkzeug.http.parse_range_header(value, make_inclusive=True)</code> </dt> <dd>
<p>Parses a range header into a <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.Range" title="werkzeug.datastructures.Range"><code>Range</code></a> object. If the header is missing or malformed <code>None</code> is returned. <code>ranges</code> is a list of <code>(start, stop)</code> tuples where the ranges are non-inclusive.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="werkzeug.http.parse_content_range_header">
<code>werkzeug.http.parse_content_range_header(value, on_update=None)</code> </dt> <dd>
<p>Parses a range header into a <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.ContentRange" title="werkzeug.datastructures.ContentRange"><code>ContentRange</code></a> object or <code>None</code> if parsing is not possible.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.7.</span></p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>value</strong> – a content range header to be parsed.</li> <li>
<strong>on_update</strong> – an optional callable that is called every time a value on the <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.ContentRange" title="werkzeug.datastructures.ContentRange"><code>ContentRange</code></a> object is changed.</li> </ul> </td> </tr>  </table> </dd>
</dl>   <h2 id="header-utilities">Header Utilities</h2> <p>The following utilities operate on HTTP headers well but do not parse them. They are useful if you’re dealing with conditional responses or if you want to proxy arbitrary requests but want to remove WSGI-unsupported hop-by-hop headers. Also there is a function to create HTTP header strings from the parsed data.</p> <dl class="function"> <dt id="werkzeug.http.is_entity_header">
<code>werkzeug.http.is_entity_header(header)</code> </dt> <dd>
<p>Check if a header is an entity header.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.5.</span></p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>header</strong> – the header to test.</td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>True</code> if it’s an entity header, <code>False</code> otherwise.</td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.is_hop_by_hop_header">
<code>werkzeug.http.is_hop_by_hop_header(header)</code> </dt> <dd>
<p>Check if a header is an HTTP/1.1 “Hop-by-Hop” header.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.5.</span></p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>header</strong> – the header to test.</td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>True</code> if it’s an HTTP/1.1 “Hop-by-Hop” header, <code>False</code> otherwise.</td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.remove_entity_headers">
<code>werkzeug.http.remove_entity_headers(headers, allowed=('expires', 'content-location'))</code> </dt> <dd>
<p>Remove all entity headers from a list or <code>Headers</code> object. This operation works in-place. <code>Expires</code> and <code>Content-Location</code> headers are by default not removed. The reason for this is <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2616.html" id="index-2"><strong>RFC 2616</strong></a> section 10.3.5 which specifies some entity headers that should be sent.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified">Changed in version 0.5: </span>added <code>allowed</code> parameter.</p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>headers</strong> – a list or <code>Headers</code> object.</li> <li>
<strong>allowed</strong> – a list of headers that should still be allowed even though they are entity headers.</li> </ul> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.remove_hop_by_hop_headers">
<code>werkzeug.http.remove_hop_by_hop_headers(headers)</code> </dt> <dd>
<p>Remove all HTTP/1.1 “Hop-by-Hop” headers from a list or <code>Headers</code> object. This operation works in-place.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.5.</span></p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>headers</strong> – a list or <code>Headers</code> object.</td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.is_byte_range_valid">
<code>werkzeug.http.is_byte_range_valid(start, stop, length)</code> </dt> <dd>
<p>Checks if a given byte content range is valid for the given length.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="werkzeug.http.quote_header_value">
<code>werkzeug.http.quote_header_value(value, extra_chars='', allow_token=True)</code> </dt> <dd>
<p>Quote a header value if necessary.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.5.</span></p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>value</strong> – the value to quote.</li> <li>
<strong>extra_chars</strong> – a list of extra characters to skip quoting.</li> <li>
<strong>allow_token</strong> – if this is enabled token values are returned unchanged.</li> </ul> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.unquote_header_value">
<code>werkzeug.http.unquote_header_value(value, is_filename=False)</code> </dt> <dd>
<p>Unquotes a header value. (Reversal of <a class="reference internal" href="#werkzeug.http.quote_header_value" title="werkzeug.http.quote_header_value"><code>quote_header_value()</code></a>). This does not use the real unquoting but what browsers are actually using for quoting.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.5.</span></p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>value</strong> – the header value to unquote.</td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.dump_header">
<code>werkzeug.http.dump_header(iterable, allow_token=True)</code> </dt> <dd>
<p>Dump an HTTP header again. This is the reversal of <a class="reference internal" href="#werkzeug.http.parse_list_header" title="werkzeug.http.parse_list_header"><code>parse_list_header()</code></a>, <a class="reference internal" href="#werkzeug.http.parse_set_header" title="werkzeug.http.parse_set_header"><code>parse_set_header()</code></a> and <a class="reference internal" href="#werkzeug.http.parse_dict_header" title="werkzeug.http.parse_dict_header"><code>parse_dict_header()</code></a>. This also quotes strings that include an equals sign unless you pass it as dict of key, value pairs.</p> <pre data-language="python">&gt;&gt;&gt; dump_header({'foo': 'bar baz'})
'foo="bar baz"'
&gt;&gt;&gt; dump_header(('foo', 'bar baz'))
'foo, "bar baz"'
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>iterable</strong> – the iterable or dict of values to quote.</li> <li>
<strong>allow_token</strong> – if set to <code>False</code> tokens as values are disallowed. See <a class="reference internal" href="#werkzeug.http.quote_header_value" title="werkzeug.http.quote_header_value"><code>quote_header_value()</code></a> for more details.</li> </ul> </td> </tr>  </table> </dd>
</dl>   <h2 id="cookies">Cookies</h2> <dl class="function"> <dt id="werkzeug.http.parse_cookie">
<code>werkzeug.http.parse_cookie(header, charset='utf-8', errors='replace', cls=None)</code> </dt> <dd>
<p>Parse a cookie from a string or WSGI environ.</p> <p>The same key can be provided multiple times, the values are stored in-order. The default <code>MultiDict</code> will have the first value first, and all values can be retrieved with <code>MultiDict.getlist()</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>header</strong> – The cookie header as a string, or a WSGI environ dict with a <code>HTTP_COOKIE</code> key.</li> <li>
<strong>charset</strong> – The charset for the cookie values.</li> <li>
<strong>errors</strong> – The error behavior for the charset decoding.</li> <li>
<strong>cls</strong> – A dict-like class to store the parsed cookies in. Defaults to <code>MultiDict</code>.</li> </ul> </td> </tr>  </table> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 1.0.0: </span>Returns a <code>MultiDict</code> instead of a <code>TypeConversionDict</code>.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified">Changed in version 0.5: </span>Returns a <code>TypeConversionDict</code> instead of a regular dict. The <code>cls</code> parameter was added.</p> </div> </details>
</dd>
</dl> <dl class="function"> <dt id="werkzeug.http.dump_cookie">
<code>werkzeug.http.dump_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, charset='utf-8', sync_expires=True, max_size=4093, samesite=None)</code> </dt> <dd>
<p>Creates a new Set-Cookie header without the <code>Set-Cookie</code> prefix The parameters are the same as in the cookie Morsel object in the Python standard library but it accepts unicode data, too.</p> <p>On Python 3 the return value of this function will be a unicode string, on Python 2 it will be a native string. In both cases the return value is usually restricted to ascii as the vast majority of values are properly escaped, but that is no guarantee. If a unicode string is returned it’s tunneled through latin1 as required by PEP 3333.</p> <p>The return value is not ASCII safe if the key contains unicode characters. This is technically against the specification but happens in the wild. It’s strongly recommended to not use non-ASCII values for the keys.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>max_age</strong> – should be a number of seconds, or <code>None</code> (default) if the cookie should last only as long as the client’s browser session. Additionally <code>timedelta</code> objects are accepted, too.</li> <li>
<strong>expires</strong> – should be a <code>datetime</code> object or unix timestamp.</li> <li>
<strong>path</strong> – limits the cookie to a given path, per default it will span the whole domain.</li> <li>
<strong>domain</strong> – Use this if you want to set a cross-domain cookie. For example, <code>domain=".example.com"</code> will set a cookie that is readable by the domain <code>www.example.com</code>, <code>foo.example.com</code> etc. Otherwise, a cookie will only be readable by the domain that set it.</li> <li>
<strong>secure</strong> – The cookie will only be available via HTTPS</li> <li>
<strong>httponly</strong> – disallow JavaScript to access the cookie. This is an extension to the cookie standard and probably not supported by all browsers.</li> <li>
<strong>charset</strong> – the encoding for unicode values.</li> <li>
<strong>sync_expires</strong> – automatically set expires if max_age is defined but expires not.</li> <li>
<strong>max_size</strong> – Warn if the final header value exceeds this size. The default, 4093, should be safely <a class="reference external" href="http://browsercookielimits.squawky.net/">supported by most browsers</a>. Set to 0 to disable this check.</li> <li>
<strong>samesite</strong> – Limits the scope of the cookie such that it will only be attached to requests if those requests are same-site.</li> </ul> </td> </tr>  </table> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 1.0.0: </span>The string <code>'None'</code> is accepted for <code>samesite</code>.</p> </div> </dd>
</dl>   <h2 id="conditional-response-helpers">Conditional Response Helpers</h2> <p>For conditional responses the following functions might be useful:</p> <dl class="function"> <dt id="werkzeug.http.parse_etags">
<code>werkzeug.http.parse_etags(value)</code> </dt> <dd>
<p>Parse an etag header.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>value</strong> – the tag header to parse</td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">an <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.ETags" title="werkzeug.datastructures.ETags"><code>ETags</code></a> object.</td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.quote_etag">
<code>werkzeug.http.quote_etag(etag, weak=False)</code> </dt> <dd>
<p>Quote an etag.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>etag</strong> – the etag to quote.</li> <li>
<strong>weak</strong> – set to <code>True</code> to tag it “weak”.</li> </ul> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.unquote_etag">
<code>werkzeug.http.unquote_etag(etag)</code> </dt> <dd>
<p>Unquote a single etag:</p> <pre data-language="python">&gt;&gt;&gt; unquote_etag('W/"bar"')
('bar', True)
&gt;&gt;&gt; unquote_etag('"bar"')
('bar', False)
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>etag</strong> – the etag identifier to unquote.</td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">a <code>(etag, weak)</code> tuple.</td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.generate_etag">
<code>werkzeug.http.generate_etag(data)</code> </dt> <dd>
<p>Generate an etag for some data.</p> </dd>
</dl> <dl class="function"> <dt id="werkzeug.http.is_resource_modified">
<code>werkzeug.http.is_resource_modified(environ, etag=None, data=None, last_modified=None, ignore_if_range=True)</code> </dt> <dd>
<p>Convenience method for conditional requests.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>environ</strong> – the WSGI environment of the request to be checked.</li> <li>
<strong>etag</strong> – the etag for the response for comparison.</li> <li>
<strong>data</strong> – or alternatively the data of the response to automatically generate an etag using <a class="reference internal" href="#werkzeug.http.generate_etag" title="werkzeug.http.generate_etag"><code>generate_etag()</code></a>.</li> <li>
<strong>last_modified</strong> – an optional date of the last modification.</li> <li>
<strong>ignore_if_range</strong> – If <code>False</code>, <code>If-Range</code> header will be taken into account.</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last"><code>True</code> if the resource was modified, otherwise <code>False</code>.</p> </td> </tr>  </table> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 1.0.0: </span>The check is run for methods other than <code>GET</code> and <code>HEAD</code>.</p> </div> </dd>
</dl>   <h2 id="constants">Constants</h2> <dl class="data"> <dt id="werkzeug.http.HTTP_STATUS_CODES">
<code>werkzeug.http.HTTP_STATUS_CODES</code> </dt> <dd>
<p>A dict of status code -&gt; default status message pairs. This is used by the wrappers and other places where an integer status code is expanded to a string throughout Werkzeug.</p> </dd>
</dl>   <h2 id="form-data-parsing">Form Data Parsing</h2> <p id="module-werkzeug.formparser">Werkzeug provides the form parsing functions separately from the request object so that you can access form data from a plain WSGI environment.</p> <p>The following formats are currently supported by the form data parser:</p> <ul class="simple"> <li><code>application/x-www-form-urlencoded</code></li> <li><code>multipart/form-data</code></li> </ul> <p>Nested multipart is not currently supported (Werkzeug 0.9), but it isn’t used by any of the modern web browsers.</p> <p>Usage example:</p> <pre data-language="python">&gt;&gt;&gt; from cStringIO import StringIO
&gt;&gt;&gt; data = '--foo\r\nContent-Disposition: form-data; name="test"\r\n' \
... '\r\nHello World!\r\n--foo--'
&gt;&gt;&gt; environ = {'wsgi.input': StringIO(data), 'CONTENT_LENGTH': str(len(data)),
...            'CONTENT_TYPE': 'multipart/form-data; boundary=foo',
...            'REQUEST_METHOD': 'POST'}
&gt;&gt;&gt; stream, form, files = parse_form_data(environ)
&gt;&gt;&gt; stream.read()
''
&gt;&gt;&gt; form['test']
u'Hello World!'
&gt;&gt;&gt; not files
True
</pre> <p>Normally the WSGI environment is provided by the WSGI gateway with the incoming data as part of it. If you want to generate such fake-WSGI environments for unittesting you might want to use the <code>create_environ()</code> function or the <code>EnvironBuilder</code> instead.</p> <dl class="class"> <dt id="werkzeug.formparser.FormDataParser">
<code>class werkzeug.formparser.FormDataParser(stream_factory=None, charset='utf-8', errors='replace', max_form_memory_size=None, max_content_length=None, cls=None, silent=True)</code> </dt> <dd>
<p>This class implements parsing of form data for Werkzeug. By itself it can parse multipart and url encoded form data. It can be subclassed and extended but for most mimetypes it is a better idea to use the untouched stream and expose it as separate attributes on a request object.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.8.</span></p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>stream_factory</strong> – An optional callable that returns a new read and writeable file descriptor. This callable works the same as <code>_get_file_stream()</code>.</li> <li>
<strong>charset</strong> – The character set for URL and url encoded form data.</li> <li>
<strong>errors</strong> – The encoding error behavior.</li> <li>
<strong>max_form_memory_size</strong> – the maximum number of bytes to be accepted for in-memory stored form data. If the data exceeds the value specified an <code>RequestEntityTooLarge</code> exception is raised.</li> <li>
<strong>max_content_length</strong> – If this is provided and the transmitted data is longer than this value an <code>RequestEntityTooLarge</code> exception is raised.</li> <li>
<strong>cls</strong> – an optional dict class to use. If this is not specified or <code>None</code> the default <code>MultiDict</code> is used.</li> <li>
<strong>silent</strong> – If set to False parsing errors will not be caught.</li> </ul> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.formparser.parse_form_data">
<code>werkzeug.formparser.parse_form_data(environ, stream_factory=None, charset='utf-8', errors='replace', max_form_memory_size=None, max_content_length=None, cls=None, silent=True)</code> </dt> <dd>
<p>Parse the form data in the environ and return it as tuple in the form <code>(stream, form, files)</code>. You should only call this method if the transport method is <code>POST</code>, <code>PUT</code>, or <code>PATCH</code>.</p> <p>If the mimetype of the data transmitted is <code>multipart/form-data</code> the files multidict will be filled with <code>FileStorage</code> objects. If the mimetype is unknown the input stream is wrapped and returned as first argument, else the stream is empty.</p> <p>This is a shortcut for the common usage of <a class="reference internal" href="#werkzeug.formparser.FormDataParser" title="werkzeug.formparser.FormDataParser"><code>FormDataParser</code></a>.</p> <p>Have a look at <a class="reference internal" href="../request_data/index#dealing-with-request-data"><span class="std std-ref">Dealing with Request Data</span></a> for more details.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified">New in version 0.5.1: </span>The optional <code>silent</code> flag was added.</p> </div> <div class="versionadded"> <p><span class="versionmodified">New in version 0.5: </span>The <code>max_form_memory_size</code>, <code>max_content_length</code> and <code>cls</code> parameters were added.</p> </div> </details><table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>environ</strong> – the WSGI environment to be used for parsing.</li> <li>
<strong>stream_factory</strong> – An optional callable that returns a new read and writeable file descriptor. This callable works the same as <code>_get_file_stream()</code>.</li> <li>
<strong>charset</strong> – The character set for URL and url encoded form data.</li> <li>
<strong>errors</strong> – The encoding error behavior.</li> <li>
<strong>max_form_memory_size</strong> – the maximum number of bytes to be accepted for in-memory stored form data. If the data exceeds the value specified an <code>RequestEntityTooLarge</code> exception is raised.</li> <li>
<strong>max_content_length</strong> – If this is provided and the transmitted data is longer than this value an <code>RequestEntityTooLarge</code> exception is raised.</li> <li>
<strong>cls</strong> – an optional dict class to use. If this is not specified or <code>None</code> the default <code>MultiDict</code> is used.</li> <li>
<strong>silent</strong> – If set to False parsing errors will not be caught.</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last">A tuple in the form <code>(stream, form, files)</code>.</p> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="werkzeug.formparser.parse_multipart_headers">
<code>werkzeug.formparser.parse_multipart_headers(iterable)</code> </dt> <dd>
<p>Parses multipart headers from an iterable that yields lines (including the trailing newline symbol). The iterable has to be newline terminated.</p> <p>The iterable will stop at the line where the headers ended so it can be further consumed.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<strong>iterable</strong> – iterable of strings that are newline terminated</td> </tr>  </table> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2020 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://werkzeug.palletsprojects.com/en/1.0.x/http/" class="_attribution-link">https://werkzeug.palletsprojects.com/en/1.0.x/http/</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
