
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Tensor Module - Eigen3 - W3cubDocs</title>
  
  <meta name="description" content=" This module provides a Tensor class for storing arbitrarily indexed objects. ">
  <meta name="keywords" content="tensor, module, eigen, eigen3">
  <meta name="HandheldFriendly" content="True">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/eigen3/unsupported/group__cxx11__tensor__module.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-f16eecbe420d8b2925d31ffbb21d05646497ecbd9515f08ffe69e9bba7332f5657accc7003c7f6c72cb4a132171acf171b359ae3bae4ae5660ddfb1718f88c67.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/eigen3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/eigen3/" class="_nav-link" title="" style="margin-left:0;">Eigen3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _eigen3">
				
				
<h1>Tensor Module</h1>      <div>  <p>This module provides a Tensor class for storing arbitrarily indexed objects.</p> <pre data-language="cpp"><span>#include &lt;Eigen/CXX11/Tensor&gt;</span>
</pre>
<p>Much of the documentation can be found <a href="eigen_tensors">here</a>. </p> <table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensor">Eigen::Tensor&lt; Scalar_, NumIndices_, Options_, IndexType_ &gt;</a></td>
</tr> <tr>
<td> </td>
<td>The tensor class. <a href="classeigen_1_1tensor#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorassign">TensorAssign</a></td>
</tr> <tr>
<td> </td>
<td>The tensor assignment class. <a href="classtensorassign#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorasyncdevice">Eigen::TensorAsyncDevice&lt; ExpressionType, DeviceType, DoneCallback &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Pseudo expression providing an operator = that will evaluate its argument asynchronously on the specified device. Currently only ThreadPoolDevice implements proper asynchronous execution, while the default and GPU devices just run the expression synchronously and call m_done() on completion.. <a href="classeigen_1_1tensorasyncdevice#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorbase">Eigen::TensorBase&lt; Derived, AccessLevel &gt;</a></td>
</tr> <tr>
<td> </td>
<td>The tensor base class. <a href="classeigen_1_1tensorbase#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorbroadcasting">TensorBroadcasting</a></td>
</tr> <tr>
<td> </td>
<td>Tensor broadcasting class. <a href="classtensorbroadcasting#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorconcatenationop">Eigen::TensorConcatenationOp&lt; Axis, LhsXprType, RhsXprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> concatenation class. <a href="classeigen_1_1tensorconcatenationop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorcontraction">TensorContraction</a></td>
</tr> <tr>
<td> </td>
<td>Tensor contraction class. <a href="classtensorcontraction#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorconversionop">Eigen::TensorConversionOp&lt; TargetType, XprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> conversion class. This class makes it possible to vectorize type casting operations when the number of scalars per packet in the source and the destination type differ. <a href="classeigen_1_1tensorconversionop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorconvolution">TensorConvolution</a></td>
</tr> <tr>
<td> </td>
<td>Tensor convolution class. <a href="classtensorconvolution#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorcustombinaryop">Eigen::TensorCustomBinaryOp&lt; CustomBinaryFunc, LhsXprType, RhsXprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> custom class. <a href="classeigen_1_1tensorcustombinaryop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorcustomunaryop">Eigen::TensorCustomUnaryOp&lt; CustomUnaryFunc, XprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> custom class. <a href="classeigen_1_1tensorcustomunaryop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensordevice">Eigen::TensorDevice&lt; ExpressionType, DeviceType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Pseudo expression providing an operator = that will evaluate its argument on the specified computing 'device' (GPU, thread pool, ...) <a href="classeigen_1_1tensordevice#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="structeigen_1_1tensorevaluator">Eigen::TensorEvaluator&lt; Derived, Device &gt;</a></td>
</tr> <tr>
<td> </td>
<td>A cost model used to limit the number of threads used for evaluating tensor expression. <a href="structeigen_1_1tensorevaluator#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorexecutor">TensorExecutor</a></td>
</tr> <tr>
<td> </td>
<td>The tensor executor class. <a href="classtensorexecutor#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorexpr">TensorExpr</a></td>
</tr> <tr>
<td> </td>
<td>Tensor expression classes. <a href="classtensorexpr#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorfft">TensorFFT</a></td>
</tr> <tr>
<td> </td>
<td>Tensor FFT class. <a href="classtensorfft#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorfixedsize">Eigen::TensorFixedSize&lt; Scalar_, Dimensions_, Options_, IndexType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>The fixed sized version of the tensor class. <a href="classeigen_1_1tensorfixedsize#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorforcedeval">TensorForcedEval</a></td>
</tr> <tr>
<td> </td>
<td>Tensor reshaping class. <a href="classtensorforcedeval#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorgeneratorop">Eigen::TensorGeneratorOp&lt; Generator, XprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> generator class. <a href="classeigen_1_1tensorgeneratorop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorimagepatch">TensorImagePatch</a></td>
</tr> <tr>
<td> </td>
<td>Patch extraction specialized for image processing. This assumes that the input has a least 3 dimensions ordered as follow: 1st dimension: channels (of size d) 2nd dimension: rows (of size r) 3rd dimension: columns (of size c) There can be additional dimensions such as time (for video) or batch (for bulk processing after the first 3. Calling the image patch code with patch_rows and patch_cols is equivalent to calling the regular patch extraction code with parameters d, patch_rows, patch_cols, and 1 for all the additional dimensions. <a href="classtensorimagepatch#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorindextuple">TensorIndexTuple</a></td>
</tr> <tr>
<td> </td>
<td>Tensor + Index Tuple class. <a href="classtensorindextuple#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorinflation">TensorInflation</a></td>
</tr> <tr>
<td> </td>
<td>Tensor inflation class. <a href="classtensorinflation#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorkchippingreshaping">TensorKChippingReshaping</a></td>
</tr> <tr>
<td> </td>
<td>A chip is a thin slice, corresponding to a column or a row in a 2-d tensor. <a href="classtensorkchippingreshaping#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorlayoutswap">TensorLayoutSwap</a></td>
</tr> <tr>
<td> </td>
<td>Swap the layout from col-major to row-major, or row-major to col-major, and invert the order of the dimensions. <a href="classtensorlayoutswap#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensormap">Eigen::TensorMap&lt; PlainObjectType, Options_, MakePointer_ &gt;</a></td>
</tr> <tr>
<td> </td>
<td>A tensor expression mapping an existing array of data. <a href="classeigen_1_1tensormap#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorpadding">TensorPadding</a></td>
</tr> <tr>
<td> </td>
<td>Tensor padding class. At the moment only padding with a constant value is supported. <a href="classtensorpadding#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorpatch">TensorPatch</a></td>
</tr> <tr>
<td> </td>
<td>Tensor patch class. <a href="classtensorpatch#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorreduction">TensorReduction</a></td>
</tr> <tr>
<td> </td>
<td>Tensor reduction class. <a href="classtensorreduction#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorref">Eigen::TensorRef&lt; PlainObjectType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>A reference to a tensor expression The expression will be evaluated lazily (as much as possible). <a href="classeigen_1_1tensorref#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorreshaping">TensorReshaping</a></td>
</tr> <tr>
<td> </td>
<td>Tensor reshaping class. <a href="classtensorreshaping#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorreverse">TensorReverse</a></td>
</tr> <tr>
<td> </td>
<td>Tensor reverse elements class. <a href="classtensorreverse#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorscan">TensorScan</a></td>
</tr> <tr>
<td> </td>
<td>Tensor scan class. <a href="classtensorscan#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorshuffling">TensorShuffling</a></td>
</tr> <tr>
<td> </td>
<td>Tensor shuffling class. <a href="classtensorshuffling#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorslicing">TensorSlicing</a></td>
</tr> <tr>
<td> </td>
<td>Tensor slicing class. <a href="classtensorslicing#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorstriding">TensorStriding</a></td>
</tr> <tr>
<td> </td>
<td>Tensor striding class. <a href="classtensorstriding#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensortrace">TensorTrace</a></td>
</tr> <tr>
<td> </td>
<td>Tensor Trace class. <a href="classtensortrace#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensortupleindex">TensorTupleIndex</a></td>
</tr> <tr>
<td> </td>
<td>Converts to Tensor&lt;Tuple&lt;Index, Scalar&gt; &gt; and reduces to Tensor&lt;Index&gt;. <a href="classtensortupleindex#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorvolumepatch">TensorVolumePatch</a></td>
</tr> <tr>
<td> </td>
<td>Patch extraction specialized for processing of volumetric data. This assumes that the input has a least 4 dimensions ordered as follows: <a href="classtensorvolumepatch#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table> </div> <div class="_attribution">
  <p class="_attribution-p">
    © Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/unsupported/group__CXX11__Tensor__Module.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/unsupported/group__CXX11__Tensor__Module.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
