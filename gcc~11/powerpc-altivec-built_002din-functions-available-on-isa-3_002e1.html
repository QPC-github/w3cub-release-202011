
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>6.60.23.5. PowerPC AltiVec Built-in Functions Available on ISA 3.1 - GCC 11 - W3cubDocs</title>
  
  <meta name="description" content=" The following additional built-in functions are also available for the PowerPC family of processors, starting with ISA 3.1 (-mcpu&#61;power10)&#58; ">
  <meta name="keywords" content="powerpc, altivec, built-in, functions, available, on, isa, gcc, gcc~11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/gcc~11/powerpc-altivec-built_002din-functions-available-on-isa-3_002e1.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-9352e6910fe51dd10a2c4166dc5a7847892ebc84c0bb52d7e40dcdccbf262592790483d09e6dbfd62c689609a706227727ca9acb967a718e944c111f43ca96a0.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/gcc~11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/gcc~11/" class="_nav-link" title="" style="margin-left:0;">GCC 11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1 class="subsubsection" id="PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e1-1">6.60.23.5 PowerPC AltiVec Built-in Functions Available on ISA 3.1</h1> <p>The following additional built-in functions are also available for the PowerPC family of processors, starting with ISA 3.1 (<samp>-mcpu=power10</samp>): </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_cfuge (vector unsigned long long int, vector unsigned long long int)</pre>
</div> <p id="index-vec_005fcfuge">Perform a vector centrifuge operation, as if implemented by the <code>vcfuged</code> instruction.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_cntlzm (vector unsigned long long int, vector unsigned long long int)</pre>
</div> <p id="index-vec_005fcntlzm">Perform a vector count leading zeros under bit mask operation, as if implemented by the <code>vclzdm</code> instruction.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_cnttzm (vector unsigned long long int, vector unsigned long long int)</pre>
</div> <p id="index-vec_005fcnttzm">Perform a vector count trailing zeros under bit mask operation, as if implemented by the <code>vctzdm</code> instruction.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed char</pre>
<pre class="smallexample" data-language="cpp">vec_clrl (vector signed char a, unsigned int n)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char</pre>
<pre class="smallexample" data-language="cpp">vec_clrl (vector unsigned char a, unsigned int n)</pre>
</div> <p id="index-vec_005fclrl">Clear the left-most <code>(16 - n)</code> bytes of vector argument <code>a</code>, as if implemented by the <code>vclrlb</code> instruction on a big-endian target and by the <code>vclrrb</code> instruction on a little-endian target. A value of <code>n</code> that is greater than 16 is treated as if it equaled 16.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed char</pre>
<pre class="smallexample" data-language="cpp">vec_clrr (vector signed char a, unsigned int n)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char</pre>
<pre class="smallexample" data-language="cpp">vec_clrr (vector unsigned char a, unsigned int n)</pre>
</div> <p id="index-vec_005fclrr">Clear the right-most <code>(16 - n)</code> bytes of vector argument <code>a</code>, as if implemented by the <code>vclrrb</code> instruction on a big-endian target and by the <code>vclrlb</code> instruction on a little-endian target. A value of <code>n</code> that is greater than 16 is treated as if it equaled 16.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_gnb (vector unsigned __int128, const unsigned char)</pre>
</div> <p id="index-vec_005fgnb">Perform a 128-bit vector gather operation, as if implemented by the <code>vgnb</code> instruction. The second argument must be a literal integer value between 2 and 7 inclusive.  </p> <p>Vector Extract </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_extractl (vector unsigned char, vector unsigned char, unsigned int)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_extractl (vector unsigned short, vector unsigned short, unsigned int)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_extractl (vector unsigned int, vector unsigned int, unsigned int)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_extractl (vector unsigned long long, vector unsigned long long, unsigned int)</pre>
</div> <p id="index-vec_005fextractl">Extract an element from two concatenated vectors starting at the given byte index in natural-endian order, and place it zero-extended in doubleword 1 of the result according to natural element order. If the byte index is out of range for the data type, the intrinsic will be rejected. For little-endian, this output will match the placement by the hardware instruction, i.e., dword[0] in RTL notation. For big-endian, an additional instruction is needed to move it from the "left" doubleword to the "right" one. For little-endian, semantics matching the <code>vextdubvrx</code>, <code>vextduhvrx</code>, <code>vextduwvrx</code> instruction will be generated, while for big-endian, semantics matching the <code>vextdubvlx</code>, <code>vextduhvlx</code>, <code>vextduwvlx</code> instructions will be generated. Note that some fairly anomalous results can be generated if the byte index is not aligned on an element boundary for the element being extracted. This is a limitation of the bi-endian vector programming model is consistent with the limitation on <code>vec_perm</code>.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_extracth (vector unsigned char, vector unsigned char, unsigned int)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_extracth (vector unsigned short, vector unsigned short,</pre>
<pre class="smallexample" data-language="cpp">unsigned int)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_extracth (vector unsigned int, vector unsigned int, unsigned int)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_extracth (vector unsigned long long, vector unsigned long long,</pre>
<pre class="smallexample" data-language="cpp">unsigned int)</pre>
</div> <p id="index-vec_005fextracth">Extract an element from two concatenated vectors starting at the given byte index. The index is based on big endian order for a little endian system. Similarly, the index is based on little endian order for a big endian system. The extraced elements are zero-extended and put in doubleword 1 according to natural element order. If the byte index is out of range for the data type, the intrinsic will be rejected. For little-endian, this output will match the placement by the hardware instruction (vextdubvrx, vextduhvrx, vextduwvrx, vextddvrx) i.e., dword[0] in RTL notation. For big-endian, an additional instruction is needed to move it from the "left" doubleword to the "right" one. For little-endian, semantics matching the <code>vextdubvlx</code>, <code>vextduhvlx</code>, <code>vextduwvlx</code> instructions will be generated, while for big-endian, semantics matching the <code>vextdubvrx</code>, <code>vextduhvrx</code>, <code>vextduwvrx</code> instructions will be generated. Note that some fairly anomalous results can be generated if the byte index is not aligned on the element boundary for the element being extracted. This is a limitation of the bi-endian vector programming model consistent with the limitation on <code>vec_perm</code>.  </p>
<div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_pdep (vector unsigned long long int, vector unsigned long long int)</pre>
</div> <p id="index-vec_005fpdep">Perform a vector parallel bits deposit operation, as if implemented by the <code>vpdepd</code> instruction.  </p> <p>Vector Insert </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned char</pre>
<pre class="smallexample" data-language="cpp">vec_insertl (unsigned char, vector unsigned char, unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short</pre>
<pre class="smallexample" data-language="cpp">vec_insertl (unsigned short, vector unsigned short, unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int</pre>
<pre class="smallexample" data-language="cpp">vec_insertl (unsigned int, vector unsigned int, unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long</pre>
<pre class="smallexample" data-language="cpp">vec_insertl (unsigned long long, vector unsigned long long,</pre>
<pre class="smallexample" data-language="cpp">unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char</pre>
<pre class="smallexample" data-language="cpp">vec_insertl (vector unsigned char, vector unsigned char, unsigned int;</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short</pre>
<pre class="smallexample" data-language="cpp">vec_insertl (vector unsigned short, vector unsigned short,</pre>
<pre class="smallexample" data-language="cpp">unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int</pre>
<pre class="smallexample" data-language="cpp">vec_insertl (vector unsigned int, vector unsigned int, unsigned int);</pre>
</div> <p id="index-vec_005finsertl">Let src be the first argument, when the first argument is a scalar, or the rightmost element of the left doubleword of the first argument, when the first argument is a vector. Insert the source into the destination at the position given by the third argument, using natural element order in the second argument. The rest of the second argument is unchanged. If the byte index is greater than 14 for halfwords, greater than 12 for words, or greater than 8 for doublewords the result is undefined. For little-endian, the generated code will be semantically equivalent to <code>vins[bhwd]rx</code> instructions. Similarly for big-endian it will be semantically equivalent to <code>vins[bhwd]lx</code>. Note that some fairly anomalous results can be generated if the byte index is not aligned on an element boundary for the type of element being inserted.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned char</pre>
<pre class="smallexample" data-language="cpp">vec_inserth (unsigned char, vector unsigned char, unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short</pre>
<pre class="smallexample" data-language="cpp">vec_inserth (unsigned short, vector unsigned short, unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int</pre>
<pre class="smallexample" data-language="cpp">vec_inserth (unsigned int, vector unsigned int, unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long</pre>
<pre class="smallexample" data-language="cpp">vec_inserth (unsigned long long, vector unsigned long long,</pre>
<pre class="smallexample" data-language="cpp">unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char</pre>
<pre class="smallexample" data-language="cpp">vec_inserth (vector unsigned char, vector unsigned char, unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short</pre>
<pre class="smallexample" data-language="cpp">vec_inserth (vector unsigned short, vector unsigned short,</pre>
<pre class="smallexample" data-language="cpp">unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int</pre>
<pre class="smallexample" data-language="cpp">vec_inserth (vector unsigned int, vector unsigned int, unsigned int);</pre>
</div> <p id="index-vec_005finserth">Let src be the first argument, when the first argument is a scalar, or the rightmost element of the first argument, when the first argument is a vector. Insert src into the second argument at the position identified by the third argument, using opposite element order in the second argument, and leaving the rest of the second argument unchanged. If the byte index is greater than 14 for halfwords, 12 for words, or 8 for doublewords, the intrinsic will be rejected. Note that the underlying hardware instruction uses the same register for the second argument and the result. For little-endian, the code generation will be semantically equivalent to <code>vins[bhwd]lx</code>, while for big-endian it will be semantically equivalent to <code>vins[bhwd]rx</code>. Note that some fairly anomalous results can be generated if the byte index is not aligned on an element boundary for the sort of element being inserted.  </p> <p>Vector Replace Element </p>
<div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed int vec_replace_elt (vector signed int, signed int,</pre>
<pre class="smallexample" data-language="cpp">const int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int vec_replace_elt (vector unsigned int,</pre>
<pre class="smallexample" data-language="cpp">unsigned int, const int);</pre>
<pre class="smallexample" data-language="cpp">vector float vec_replace_elt (vector float, float, const int);</pre>
<pre class="smallexample" data-language="cpp">vector signed long long vec_replace_elt (vector signed long long,</pre>
<pre class="smallexample" data-language="cpp">signed long long, const int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long vec_replace_elt (vector unsigned long long,</pre>
<pre class="smallexample" data-language="cpp">unsigned long long, const int);</pre>
<pre class="smallexample" data-language="cpp">vector double rec_replace_elt (vector double, double, const int);</pre>
</div> <p>The third argument (constrained to [0,3]) identifies the natural-endian element number of the first argument that will be replaced by the second argument to produce the result. The other elements of the first argument will remain unchanged in the result. </p> <p>If it’s desirable to insert a word at an unaligned position, use vec_replace_unaligned instead. </p>  <p id="index-vec_005freplace_005felement">Vector Replace Unaligned </p>
<div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned char vec_replace_unaligned (vector unsigned char,</pre>
<pre class="smallexample" data-language="cpp">signed int, const int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char vec_replace_unaligned (vector unsigned char,</pre>
<pre class="smallexample" data-language="cpp">unsigned int, const int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char vec_replace_unaligned (vector unsigned char,</pre>
<pre class="smallexample" data-language="cpp">float, const int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char vec_replace_unaligned (vector unsigned char,</pre>
<pre class="smallexample" data-language="cpp">signed long long, const int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char vec_replace_unaligned (vector unsigned char,</pre>
<pre class="smallexample" data-language="cpp">unsigned long long, const int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char vec_replace_unaligned (vector unsigned char,</pre>
<pre class="smallexample" data-language="cpp">double, const int);</pre>
</div> <p>The second argument replaces a portion of the first argument to produce the result, with the rest of the first argument unchanged in the result. The third argument identifies the byte index (using left-to-right, or big-endian order) where the high-order byte of the second argument will be placed, with the remaining bytes of the second argument placed naturally "to the right" of the high-order byte. </p> <p id="index-vec_005freplace_005funaligned">The programmer is responsible for understanding the endianness issues involved with the first argument and the result.  </p> <p>Vector Shift Left Double Bit Immediate </p>
<div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed char vec_sldb (vector signed char, vector signed char,</pre>
<pre class="smallexample" data-language="cpp">const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char vec_sldb (vector unsigned char,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char, const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector signed short vec_sldb (vector signed short, vector signed short,</pre>
<pre class="smallexample" data-language="cpp">const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short vec_sldb (vector unsigned short,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short, const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector signed int vec_sldb (vector signed int, vector signed int,</pre>
<pre class="smallexample" data-language="cpp">const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int vec_sldb (vector unsigned int, vector unsigned int,</pre>
<pre class="smallexample" data-language="cpp">const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector signed long long vec_sldb (vector signed long long,</pre>
<pre class="smallexample" data-language="cpp">vector signed long long, const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long vec_sldb (vector unsigned long long,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long, const unsigned int);</pre>
</div> <p>Shift the combined input vectors left by the amount specified by the low-order three bits of the third argument, and return the leftmost remaining 128 bits. Code using this instruction must be endian-aware. </p>  <p id="index-vec_005fsldb">Vector Shift Right Double Bit Immediate </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed char vec_srdb (vector signed char, vector signed char,</pre>
<pre class="smallexample" data-language="cpp">const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char vec_srdb (vector unsigned char, vector unsigned char,</pre>
<pre class="smallexample" data-language="cpp">const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector signed short vec_srdb (vector signed short, vector signed short,</pre>
<pre class="smallexample" data-language="cpp">const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short vec_srdb (vector unsigned short, vector unsigned short,</pre>
<pre class="smallexample" data-language="cpp">const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector signed int vec_srdb (vector signed int, vector signed int,</pre>
<pre class="smallexample" data-language="cpp">const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int vec_srdb (vector unsigned int, vector unsigned int,</pre>
<pre class="smallexample" data-language="cpp">const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector signed long long vec_srdb (vector signed long long,</pre>
<pre class="smallexample" data-language="cpp">vector signed long long, const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long vec_srdb (vector unsigned long long,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long, const unsigned int);</pre>
</div> <p>Shift the combined input vectors right by the amount specified by the low-order three bits of the third argument, and return the remaining 128 bits. Code using this built-in must be endian-aware. </p>  <p id="index-vec_005fsrdb">Vector Splat </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed int vec_splati (const signed int);</pre>
<pre class="smallexample" data-language="cpp">vector float vec_splati (const float);</pre>
</div> <p>Splat a 32-bit immediate into a vector of words. </p>  <div class="smallexample" id="index-vec_005fsplati"> <pre class="smallexample" data-language="cpp">vector double vec_splatid (const float);</pre>
</div> <p>Convert a single precision floating-point value to double-precision and splat the result to a vector of double-precision floats. </p>  <div class="smallexample" id="index-vec_005fsplatid"> <pre class="smallexample" data-language="cpp">vector signed int vec_splati_ins (vector signed int,</pre>
<pre class="smallexample" data-language="cpp">const unsigned int, const signed int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int vec_splati_ins (vector unsigned int,</pre>
<pre class="smallexample" data-language="cpp">const unsigned int, const unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector float vec_splati_ins (vector float, const unsigned int,</pre>
<pre class="smallexample" data-language="cpp">const float);</pre>
</div> <p>Argument 2 must be either 0 or 1. Splat the value of argument 3 into the word identified by argument 2 of each doubleword of argument 1 and return the result. The other words of argument 1 are unchanged. </p>  <p id="index-vec_005fsplati_005fins">Vector Blend Variable </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed char vec_blendv (vector signed char, vector signed char,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char vec_blendv (vector unsigned char,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char, vector unsigned char);</pre>
<pre class="smallexample" data-language="cpp">vector signed short vec_blendv (vector signed short,</pre>
<pre class="smallexample" data-language="cpp">vector signed short, vector unsigned short);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short vec_blendv (vector unsigned short,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short, vector unsigned short);</pre>
<pre class="smallexample" data-language="cpp">vector signed int vec_blendv (vector signed int, vector signed int,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int vec_blendv (vector unsigned int,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int, vector unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector signed long long vec_blendv (vector signed long long,</pre>
<pre class="smallexample" data-language="cpp">vector signed long long, vector unsigned long long);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long vec_blendv (vector unsigned long long,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long, vector unsigned long long);</pre>
<pre class="smallexample" data-language="cpp">vector float vec_blendv (vector float, vector float,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int);</pre>
<pre class="smallexample" data-language="cpp">vector double vec_blendv (vector double, vector double,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long);</pre>
</div> <p>Blend the first and second argument vectors according to the sign bits of the corresponding elements of the third argument vector. This is similar to the <code>vsel</code> and <code>xxsel</code> instructions but for bigger elements. </p>  <p id="index-vec_005fblendv">Vector Permute Extended </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed char vec_permx (vector signed char, vector signed char,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char, const int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char vec_permx (vector unsigned char,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char, vector unsigned char, const int);</pre>
<pre class="smallexample" data-language="cpp">vector signed short vec_permx (vector signed short,</pre>
<pre class="smallexample" data-language="cpp">vector signed short, vector unsigned char, const int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short vec_permx (vector unsigned short,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short, vector unsigned char, const int);</pre>
<pre class="smallexample" data-language="cpp">vector signed int vec_permx (vector signed int, vector signed int,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char, const int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int vec_permx (vector unsigned int,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int, vector unsigned char, const int);</pre>
<pre class="smallexample" data-language="cpp">vector signed long long vec_permx (vector signed long long,</pre>
<pre class="smallexample" data-language="cpp">vector signed long long, vector unsigned char, const int);</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long vec_permx (vector unsigned long long,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long, vector unsigned char, const int);</pre>
<pre class="smallexample" data-language="cpp">vector float (vector float, vector float, vector unsigned char,</pre>
<pre class="smallexample" data-language="cpp">const int);</pre>
<pre class="smallexample" data-language="cpp">vector double (vector double, vector double, vector unsigned char,</pre>
<pre class="smallexample" data-language="cpp">const int);</pre>
</div> <p id="index-vec_005fpermx">Perform a partial permute of the first two arguments, which form a 32-byte section of an emulated vector up to 256 bytes wide, using the partial permute control vector in the third argument. The fourth argument (constrained to values of 0-7) identifies which 32-byte section of the emulated vector is contained in the first two arguments.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_pext (vector unsigned long long int, vector unsigned long long int)</pre>
</div> <p id="index-vec_005fpext">Perform a vector parallel bit extract operation, as if implemented by the <code>vpextd</code> instruction.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned char vec_stril (vector unsigned char)</pre>
<pre class="smallexample" data-language="cpp">vector signed char vec_stril (vector signed char)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short vec_stril (vector unsigned short)</pre>
<pre class="smallexample" data-language="cpp">vector signed short vec_stril (vector signed short)</pre>
</div> <p id="index-vec_005fstril">Isolate the left-most non-zero elements of the incoming vector argument, replacing all elements to the right of the left-most zero element found within the argument with zero. The typical implementation uses the <code>vstribl</code> or <code>vstrihl</code> instruction on big-endian targets and uses the <code>vstribr</code> or <code>vstrihr</code> instruction on little-endian targets.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">int vec_stril_p (vector unsigned char)</pre>
<pre class="smallexample" data-language="cpp">int vec_stril_p (vector signed char)</pre>
<pre class="smallexample" data-language="cpp">int short vec_stril_p (vector unsigned short)</pre>
<pre class="smallexample" data-language="cpp">int vec_stril_p (vector signed short)</pre>
</div> <p id="index-vec_005fstril_005fp">Return a non-zero value if and only if the argument contains a zero element. The typical implementation uses the <code>vstribl.</code> or <code>vstrihl.</code> instruction on big-endian targets and uses the <code>vstribr.</code> or <code>vstrihr.</code> instruction on little-endian targets. Choose this built-in to check for presence of zero element if the same argument is also passed to <code>vec_stril</code>.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned char vec_strir (vector unsigned char)</pre>
<pre class="smallexample" data-language="cpp">vector signed char vec_strir (vector signed char)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short vec_strir (vector unsigned short)</pre>
<pre class="smallexample" data-language="cpp">vector signed short vec_strir (vector signed short)</pre>
</div> <p id="index-vec_005fstrir">Isolate the right-most non-zero elements of the incoming vector argument, replacing all elements to the left of the right-most zero element found within the argument with zero. The typical implementation uses the <code>vstribr</code> or <code>vstrihr</code> instruction on big-endian targets and uses the <code>vstribl</code> or <code>vstrihl</code> instruction on little-endian targets.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">int vec_strir_p (vector unsigned char)</pre>
<pre class="smallexample" data-language="cpp">int vec_strir_p (vector signed char)</pre>
<pre class="smallexample" data-language="cpp">int short vec_strir_p (vector unsigned short)</pre>
<pre class="smallexample" data-language="cpp">int vec_strir_p (vector signed short)</pre>
</div> <p id="index-vec_005fstrir_005fp">Return a non-zero value if and only if the argument contains a zero element. The typical implementation uses the <code>vstribr.</code> or <code>vstrihr.</code> instruction on big-endian targets and uses the <code>vstribl.</code> or <code>vstrihl.</code> instruction on little-endian targets. Choose this built-in to check for presence of zero element if the same argument is also passed to <code>vec_strir</code>.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned char</pre>
<pre class="smallexample" data-language="cpp">vec_ternarylogic (vector unsigned char, vector unsigned char,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned char, const unsigned int)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short</pre>
<pre class="smallexample" data-language="cpp">vec_ternarylogic (vector unsigned short, vector unsigned short,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short, const unsigned int)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int</pre>
<pre class="smallexample" data-language="cpp">vec_ternarylogic (vector unsigned int, vector unsigned int,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int, const unsigned int)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long int</pre>
<pre class="smallexample" data-language="cpp">vec_ternarylogic (vector unsigned long long int, vector unsigned long long int,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long int, const unsigned int)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned __int128</pre>
<pre class="smallexample" data-language="cpp">vec_ternarylogic (vector unsigned __int128, vector unsigned __int128,</pre>
<pre class="smallexample" data-language="cpp">vector unsigned __int128, const unsigned int)</pre>
</div> <p id="index-vec_005fternarylogic">Perform a 128-bit vector evaluate operation, as if implemented by the <code>xxeval</code> instruction. The fourth argument must be a literal integer value between 0 and 255 inclusive.  </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned char vec_genpcvm (vector unsigned char, const int)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned short vec_genpcvm (vector unsigned short, const int)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int vec_genpcvm (vector unsigned int, const int)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int vec_genpcvm (vector unsigned long long int,</pre>
<pre class="smallexample" data-language="cpp">const int)</pre>
</div> <p>Vector Integer Multiply/Divide/Modulo </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed int</pre>
<pre class="smallexample" data-language="cpp">vec_mulh (vector signed int a, vector signed int b)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int</pre>
<pre class="smallexample" data-language="cpp">vec_mulh (vector unsigned int a, vector unsigned int b)</pre>
</div> <p>For each integer value <code>i</code> from 0 to 3, do the following. The integer value in word element <code>i</code> of a is multiplied by the integer value in word element <code>i</code> of b. The high-order 32 bits of the 64-bit product are placed into word element <code>i</code> of the vector returned. </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed long long</pre>
<pre class="smallexample" data-language="cpp">vec_mulh (vector signed long long a, vector signed long long b)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long</pre>
<pre class="smallexample" data-language="cpp">vec_mulh (vector unsigned long long a, vector unsigned long long b)</pre>
</div> <p>For each integer value <code>i</code> from 0 to 1, do the following. The integer value in doubleword element <code>i</code> of a is multiplied by the integer value in doubleword element <code>i</code> of b. The high-order 64 bits of the 128-bit product are placed into doubleword element <code>i</code> of the vector returned. </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector unsigned long long</pre>
<pre class="smallexample" data-language="cpp">vec_mul (vector unsigned long long a, vector unsigned long long b)</pre>
<pre class="smallexample" data-language="cpp">vector signed long long</pre>
<pre class="smallexample" data-language="cpp">vec_mul (vector signed long long a, vector signed long long b)</pre>
</div> <p>For each integer value <code>i</code> from 0 to 1, do the following. The integer value in doubleword element <code>i</code> of a is multiplied by the integer value in doubleword element <code>i</code> of b. The low-order 64 bits of the 128-bit product are placed into doubleword element <code>i</code> of the vector returned. </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed int</pre>
<pre class="smallexample" data-language="cpp">vec_div (vector signed int a, vector signed int b)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int</pre>
<pre class="smallexample" data-language="cpp">vec_div (vector unsigned int a, vector unsigned int b)</pre>
</div> <p>For each integer value <code>i</code> from 0 to 3, do the following. The integer in word element <code>i</code> of a is divided by the integer in word element <code>i</code> of b. The unique integer quotient is placed into the word element <code>i</code> of the vector returned. If an attempt is made to perform any of the divisions &lt;anything&gt; Ã· 0 then the quotient is undefined. </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed long long</pre>
<pre class="smallexample" data-language="cpp">vec_div (vector signed long long a, vector signed long long b)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long</pre>
<pre class="smallexample" data-language="cpp">vec_div (vector unsigned long long a, vector unsigned long long b)</pre>
</div> <p>For each integer value <code>i</code> from 0 to 1, do the following. The integer in doubleword element <code>i</code> of a is divided by the integer in doubleword element <code>i</code> of b. The unique integer quotient is placed into the doubleword element <code>i</code> of the vector returned. If an attempt is made to perform any of the divisions 0x8000_0000_0000_0000 Ã· -1 or &lt;anything&gt; Ã· 0 then the quotient is undefined. </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed int</pre>
<pre class="smallexample" data-language="cpp">vec_dive (vector signed int a, vector signed int b)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int</pre>
<pre class="smallexample" data-language="cpp">vec_dive (vector unsigned int a, vector unsigned int b)</pre>
</div> <p>For each integer value <code>i</code> from 0 to 3, do the following. The integer in word element <code>i</code> of a is shifted left by 32 bits, then divided by the integer in word element <code>i</code> of b. The unique integer quotient is placed into the word element <code>i</code> of the vector returned. If the quotient cannot be represented in 32 bits, or if an attempt is made to perform any of the divisions &lt;anything&gt; Ã· 0 then the quotient is undefined. </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed long long</pre>
<pre class="smallexample" data-language="cpp">vec_dive (vector signed long long a, vector signed long long b)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long</pre>
<pre class="smallexample" data-language="cpp">vec_dive (vector unsigned long long a, vector unsigned long long b)</pre>
</div> <p>For each integer value <code>i</code> from 0 to 1, do the following. The integer in doubleword element <code>i</code> of a is shifted left by 64 bits, then divided by the integer in doubleword element <code>i</code> of b. The unique integer quotient is placed into the doubleword element <code>i</code> of the vector returned. If the quotient cannot be represented in 64 bits, or if an attempt is made to perform &lt;anything&gt; Ã· 0 then the quotient is undefined. </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed int</pre>
<pre class="smallexample" data-language="cpp">vec_mod (vector signed int a, vector signed int b)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned int</pre>
<pre class="smallexample" data-language="cpp">vec_mod (vector unsigned int a, vector unsigned int b)</pre>
</div> <p>For each integer value <code>i</code> from 0 to 3, do the following. The integer in word element <code>i</code> of a is divided by the integer in word element <code>i</code> of b. The unique integer remainder is placed into the word element <code>i</code> of the vector returned. If an attempt is made to perform any of the divisions 0x8000_0000 Ã· -1 or &lt;anything&gt; Ã· 0 then the remainder is undefined. </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">vector signed long long</pre>
<pre class="smallexample" data-language="cpp">vec_mod (vector signed long long a, vector signed long long b)</pre>
<pre class="smallexample" data-language="cpp">vector unsigned long long</pre>
<pre class="smallexample" data-language="cpp">vec_mod (vector unsigned long long a, vector unsigned long long b)</pre>
</div> <p>For each integer value <code>i</code> from 0 to 1, do the following. The integer in doubleword element <code>i</code> of a is divided by the integer in doubleword element <code>i</code> of b. The unique integer remainder is placed into the doubleword element <code>i</code> of the vector returned. If an attempt is made to perform &lt;anything&gt; Ã· 0 then the remainder is undefined. </p> <p id="index-vec_005fgenpcvm">Generate PCV from specified Mask size, as if implemented by the <code>xxgenpcvbm</code>, <code>xxgenpcvhm</code>, <code>xxgenpcvwm</code> instructions, where immediate value is either 0, 1, 2 or 3.  </p>  <p class="header"> </p>
<p> Previous: <a href="powerpc-altivec-built_002din-functions-available-on-isa-3_002e0#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e0" accesskey="p" rel="prev">PowerPC AltiVec Built-in Functions Available on ISA 3.0</a>, Up: <a href="powerpc-altivec_002fvsx-built_002din-functions#PowerPC-AltiVec_002fVSX-Built_002din-Functions" accesskey="u" rel="up">PowerPC AltiVec/VSX Built-in Functions</a> [<a href="index#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gcc/Option-Index.html#Option-Index" title="Index" rel="index">Index</a>]</p> <div class="_attribution">
  <p class="_attribution-p">
    © Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gcc/PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e1.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gcc/PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e1.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
