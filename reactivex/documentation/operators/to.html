
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>To - ReactiveX - W3cubDocs</title>
  
  <meta name="description" content="The various language-specific implementations of ReactiveX have a variety of operators that you can use to convert an Observable, or a sequence of &hellip;">
  <meta name="keywords" content="reactivex">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/reactivex/documentation/operators/to.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/reactivex.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/reactivex/" class="_nav-link" title="" style="margin-left:0;">ReactiveX</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _reactivex">
				
				
<h1>To</h1> <blockquote>convert an Observable into another object or data structure</blockquote> <figure> <img src="http://reactivex.io/documentation/operators/images/to.c.png" style="width:100%;" alt="To"> <figcaption><p> The various language-specific implementations of ReactiveX have a variety of operators that you can use to convert an Observable, or a sequence of items emitted by an Observable, into another variety of object or data structure. Some of these block until the Observable terminates and then produce an equivalent object or data structure; others return an Observable that emits such an object or data structure. </p></figcaption> </figure> <p> In some implementations of ReactiveX, there is also an operator that converts an Observable into a “Blocking” Observable. A Blocking Observable extends the ordinary Observable by providing a set of methods, operating on the items emitted by the Observable, that block. Some of the <span class="operator">To</span> operators are in this Blocking Observable set of extended operations. </p> <h4>See Also</h4> <ul> <li><a href="http://www.introtorx.com/Content/v1.0.10621.0/10_LeavingTheMonad.html#LeavingTheMonad"><cite>Introduction to Rx</cite>: Leaving the monad</a></li> </ul> <h2>Language-Specific Information</h2> <div id="accordion" role="tablist" aria-multiselectable="true">   <div> <div role="tab" id="headingRxGroovy"> <h3 class="panel-title">  RxGroovy <code>BlockingObservable.from BlockingObservable.getIterator nest toBlocking BlockingObservable.toFuture BlockingObservable.toIterable toList toMap toMultiMap toSortedList</code>  </h3> </div> <div id="collapseRxGroovy" role="tabpanel" aria-labelledby="headingRxGroovy"> <div> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/B.getIterator.png" style="width:100%;" alt="getIterator"> <figcaption><p> The <code>getIterator</code> operator applies to the <code>BlockingObservable</code> subclass, so in order to use it, you must first convert your source Observable into a <code>BlockingObservable</code> by means of either the <code>BlockingObservable.from</code> method or the <code>Observable.toBlocking</code> operator. </p>
<p> This operator converts an Observable into an <code>Iterator</code> with which you can iterate over the set of items emitted by the source Observable. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#getIterator()"><code>BlockingObservable.getIterator()</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/B.toFuture.png" style="width:100%;" alt="toFuture"> <figcaption><p> The <code>toFuture</code> operator applies to the <code>BlockingObservable</code> subclass, so in order to use it, you must first convert your source Observable into a <code>BlockingObservable</code> by means of either the <code>BlockingObservable.from</code> method or the <code>Observable.toBlocking</code> operator. </p>
<p> This operator converts an Observable into an <code>Future</code> that will return the single item emitted by the source Observable. If the source Observable emits more than one item, the <code>Future</code> will receive an <code>IllegalArgumentException</code>; if it completes after emitting no items, the <code>Future</code> will receive a <code>NoSuchElementException</code>. </p>
<p> If you want to convert an Observable that may emit multiple items into a <code>Future</code>, try something like this: <code>myObservable.toList().toBlocking().toFuture()</code>. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#toFuture()"><code>BlockingObservable.toFuture()</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/B.toIterable.png" style="width:100%;" alt="toIterable"> <figcaption><p> The <code>toIterable</code> operator applies to the <code>BlockingObservable</code> subclass, so in order to use it, you must first convert your source Observable into a <code>BlockingObservable</code> by means of either the <code>BlockingObservable.from</code> method or the <code>Observable.toBlocking</code> operator. </p>
<p> This operator converts an Observable into an <code>Iterable</code> with which you can iterate over the set of items emitted by the source Observable. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#toIterable()"><code>BlockingObservable.toIterable()</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/toList.png" style="width:100%;" alt="toList"> <figcaption><p> Normally, an Observable that emits multiple items will do so by invoking its observer’s <code>onNext</code> method for each such item. You can change this behavior, instructing the Observable to compose a list of these multiple items and then to invoke the observer’s <code>onNext</code> method only once, passing it the entire list, by applying the <code>toList</code> operator to the Observable. </p>
<p> For example, the following rather pointless code takes a list of integers, converts it into an Observable, then converts that Observable into one that emits the original list as a single item: </p> <h4>Sample Code</h4> <pre data-language="groovy">numbers = Observable.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);

numbers.toList().subscribe(
  { println(it); },                          // onNext
  { println("Error: " + it.getMessage()); }, // onError
  { println("Sequence complete"); }          // onCompleted
);</pre> <div><pre data-language="javascript">[1, 2, 3, 4, 5, 6, 7, 8, 9]
Sequence complete</pre></div> <p> If the source Observable invokes <code>onCompleted</code> before emitting any items, the Observable returned by <code>toList</code> will emit an empty list before invoking <code>onCompleted</code>. If the source Observable invokes <code>onError</code>, the Observable returned by <code>toList</code> will immediately invoke the <code>onError</code> methods of its observers. </p>
<p> <code>toList</code> does not by default operate on any particular <a href="../scheduler">Scheduler</a>. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toList()"><code>toList()</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/toMap.png" style="width:100%;" alt="toMap"> <figcaption><p> The <code>toMap</code> operator collects the items emitted by the source Observable into a map (by default, a <code>HashMap</code>, but you can optionally supply a factory function that generates another <code>Map</code> variety) and then emits that map. You supply a function that generates the key for each emitted item. You may also optionally supply a function that converts an emitted item into the value to be stored in the map (by default, the item itself is this value). </p>
<p> <code>toMap</code> does not by default operate on any particular <a href="../scheduler">Scheduler</a>. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1)"><code>toMap(Func1)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1,%20rx.functions.Func1)"><code>toMap(Func1,Func1)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0)"><code>toMap(Func1,Func1,Func0)</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/toMultiMap.png" style="width:100%;" alt="toMultiMap"> <figcaption><p> The <code>toMultiMap</code> operator is similar to <code>toMap</code> except that the map it generates is also an <code>ArrayList</code> (by default; or you can pass an optional factory method as a fourth parameter by which you generate the variety of collection you prefer). </p>
<p> <code>toMultiMap</code> does not by default operate on any particular <a href="../scheduler">Scheduler</a>. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1)"><code>toMultiMap(Func1)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1)"><code>toMultiMap(Func1,Func1)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0)"><code>toMultiMap(Func1,Func1,Func0)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0,%20rx.functions.Func1)"><code>toMultiMap(Func1,Func1,Func0,Func1)</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/toSortedList.png" style="width:100%;" alt="toSortedList"> <figcaption><p> The <code>toSortedList</code> operator behaves much like <code>toList</code> except that it sorts the resulting list. By default it sorts the list naturally in ascending order by means of the <code>Comparable</code> interface. If any of the items emitted by the Observable does not support <code>Comparable</code> with respect to the type of every other item emitted by the Observable, <code>toSortedList</code> will throw an exception. However, you can change this default behavior by also passing in to <code>toSortedList</code> a function that takes as its parameters two items and returns a number; <code>toSortedList</code> will then use that function instead of <code>Comparable</code> to sort the items. </p>
<p> For example, the following code takes a list of unsorted integers, converts it into an Observable, then converts that Observable into one that emits the original list in sorted form as a single item: </p> <h4>Sample Code</h4> <pre data-language="groovy">numbers = Observable.from([8, 6, 4, 2, 1, 3, 5, 7, 9]);

numbers.toSortedList().subscribe(
  { println(it); },                          // onNext
  { println("Error: " + it.getMessage()); }, // onError
  { println("Sequence complete"); }          // onCompleted
);</pre> <div><pre data-language="javascript">[1, 2, 3, 4, 5, 6, 7, 8, 9]
Sequence complete</pre></div> <p> Here is an example that provides its own sorting function: in this case, one that sorts numbers according to how close they are to the number 5. </p> <pre data-language="groovy">numbers = Observable.from([8, 6, 4, 2, 1, 3, 5, 7, 9]);

numbers.toSortedList({ n, m -&gt; Math.abs(5-n) - Math.abs(5-m) }).subscribe(
  { println(it); },                          // onNext
  { println("Error: " + it.getMessage()); }, // onError
  { println("Sequence complete"); }          // onCompleted
);</pre> <div><pre data-language="javascript">[5, 6, 4, 3, 7, 8, 2, 1, 9]
Sequence complete</pre></div> <p> <code>toSortedList</code> does not by default operate on any particular <a href="../scheduler">Scheduler</a>. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toSortedList()"><code>toSortedList()</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toSortedList(rx.functions.Func2)"><code>toSortedList(Func2)</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/nest.png" style="width:100%;" alt="nest"> <figcaption><p> RxGroovy also has a <code>nest</code> operator that has one particular purpose: it converts a source Observable into an Observable that emits that source Observable as its sole item. </p></figcaption> </figure> </div> </div> </div> <div> <div role="tab" id="headingRxJava 1․x"> <h3 class="panel-title">  RxJava 1․x <code>BlockingObservable.from BlockingObservable.getIterator nest toBlocking BlockingObservable.toFuture BlockingObservable.toIterable toList toMap toMultiMap toSortedList</code>  </h3> </div> <div id="collapseRxJava 1․x" role="tabpanel" aria-labelledby="headingRxJava 1․x"> <div> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/B.getIterator.png" style="width:100%;" alt="getIterator"> <figcaption><p> The <code>getIterator</code> operator applies to the <code>BlockingObservable</code> subclass, so in order to use it, you must first convert your source Observable into a <code>BlockingObservable</code> by means of either the <code>BlockingObservable.from</code> method or the <code>Observable.toBlocking</code> operator. </p>
<p> This operator converts an Observable into an <code>Iterator</code> with which you can iterate over the set of items emitted by the source Observable. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#getIterator()"><code>BlockingObservable.getIterator()</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/B.toFuture.png" style="width:100%;" alt="toFuture"> <figcaption><p> The <code>toFuture</code> operator applies to the <code>BlockingObservable</code> subclass, so in order to use it, you must first convert your source Observable into a <code>BlockingObservable</code> by means of either the <code>BlockingObservable.from</code> method or the <code>Observable.toBlocking</code> operator. </p>
<p> This operator converts an Observable into an <code>Future</code> that will return the single item emitted by the source Observable. If the source Observable emits more than one item, the <code>Future</code> will receive an <code>IllegalArgumentException</code>; if it completes after emitting no items, the <code>Future</code> will receive a <code>NoSuchElementException</code>. </p>
<p> If you want to convert an Observable that may emit multiple items into a <code>Future</code>, try something like this: <code>myObservable.toList().toBlocking().toFuture()</code>. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#toFuture()"><code>BlockingObservable.toFuture()</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/B.toIterable.png" style="width:100%;" alt="toIterable"> <figcaption><p> The <code>toIterable</code> operator applies to the <code>BlockingObservable</code> subclass, so in order to use it, you must first convert your source Observable into a <code>BlockingObservable</code> by means of either the <code>BlockingObservable.from</code> method or the <code>Observable.toBlocking</code> operator. </p>
<p> This operator converts an Observable into an <code>Iterable</code> with which you can iterate over the set of items emitted by the source Observable. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/observables/BlockingObservable.html#toIterable()"><code>BlockingObservable.toIterable()</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/toList.png" style="width:100%;" alt="toList"> <figcaption><p> Normally, an Observable that emits multiple items will do so by invoking its observer’s <code>onNext</code> method for each such item. You can change this behavior, instructing the Observable to compose a list of these multiple items and then to invoke the observer’s <code>onNext</code> method only once, passing it the entire list, by applying the <code>toList</code> operator to the Observable. </p>
<p> If the source Observable invokes <code>onCompleted</code> before emitting any items, the Observable returned by <code>toList</code> will emit an empty list before invoking <code>onCompleted</code>. If the source Observable invokes <code>onError</code>, the Observable returned by <code>toList</code> will immediately invoke the <code>onError</code> methods of its observers. </p>
<p> <code>toList</code> does not by default operate on any particular <a href="../scheduler">Scheduler</a>. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toList()"><code>toList()</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/toMap.png" style="width:100%;" alt="toMap"> <figcaption><p> The <code>toMap</code> operator collects the items emitted by the source Observable into a map (by default, a <code>HashMap</code>, but you can optionally supply a factory function that generates another <code>Map</code> variety) and then emits that map. You supply a function that generates the key for each emitted item. You may also optionally supply a function that converts an emitted item into the value to be stored in the map (by default, the item itself is this value). </p>
<p> <code>toMap</code> does not by default operate on any particular <a href="../scheduler">Scheduler</a>. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1)"><code>toMap(Func1)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1,%20rx.functions.Func1)"><code>toMap(Func1,Func1)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0)"><code>toMap(Func1,Func1,Func0)</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/toMultiMap.png" style="width:100%;" alt="toMultiMap"> <figcaption><p> The <code>toMultiMap</code> operator is similar to <code>toMap</code> except that the map it generates is also an <code>ArrayList</code> (by default; or you can pass an optional factory method as a fourth parameter by which you generate the variety of collection you prefer). </p>
<p> <code>toMultiMap</code> does not by default operate on any particular <a href="../scheduler">Scheduler</a>. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1)"><code>toMultiMap(Func1)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1)"><code>toMultiMap(Func1,Func1)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0)"><code>toMultiMap(Func1,Func1,Func0)</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toMultimap(rx.functions.Func1,%20rx.functions.Func1,%20rx.functions.Func0,%20rx.functions.Func1)"><code>toMultiMap(Func1,Func1,Func0,Func1)</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/toSortedList.png" style="width:100%;" alt="toSortedList"> <figcaption><p> The <code>toSortedList</code> operator behaves much like <code>toList</code> except that it sorts the resulting list. By default it sorts the list naturally in ascending order by means of the <code>Comparable</code> interface. If any of the items emitted by the Observable does not support <code>Comparable</code> with respect to the type of every other item emitted by the Observable, <code>toSortedList</code> will throw an exception. However, you can change this default behavior by also passing in to <code>toSortedList</code> a function that takes as its parameters two items and returns a number; <code>toSortedList</code> will then use that function instead of <code>Comparable</code> to sort the items. </p>
<p> <code>toSortedList</code> does not by default operate on any particular <a href="../scheduler">Scheduler</a>. </p> <ul> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toSortedList()"><code>toSortedList()</code></a>
</li> <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toSortedList(rx.functions.Func2)"><code>toSortedList(Func2)</code></a>
</li> </ul></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/nest.png" style="width:100%;" alt="nest"> <figcaption><p> RxJava also has a <code>nest</code> operator that has one particular purpose: it converts a source Observable into an Observable that emits that source Observable as its sole item. </p></figcaption> </figure> </div> </div> </div>  <div> <div role="tab" id="headingRxJS"> <h3 class="panel-title">  RxJS <code>toArray toMap toSet</code>  </h3> </div> <div id="collapseRxJS" role="tabpanel" aria-labelledby="headingRxJS"> <div> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/toArray.png" style="width:100%;" alt="toArray"> <figcaption><p> Normally, an Observable that emits multiple items will do so by invoking its observer’s <code>onNext</code> method for each such item. You can change this behavior, instructing the Observable to compose an array of these multiple items and then to invoke the observer’s <code>onNext</code> method only once, passing it the entire array, by applying the <code>toArray</code> operator to the Observable. </p> <h4>Sample Code</h4> <pre data-language="javascript">var source = Rx.Observable.timer(0, 1000)
    .take(5)
    .toArray();

var subscription = source.subscribe(
    function (x) { console.log('Next: ' + x); },
    function (err) { console.log('Error: ' + err); },
    function () { console.log('Completed'); });</pre> <div><pre data-language="javascript">Next: [0,1,2,3,4]
Completed</pre></div> <p><code>toArray</code> is found in each of the following distributions:</p> <ul> <li><code>rx.js</code></li> <li><code>rx.all.js</code></li> <li><code>rx.all.compat.js</code></li> <li><code>rx.compat.js</code></li> <li><code>rx.lite.js</code></li> <li><code>rx.lite.compat.js</code></li> </ul> </figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/toMap.png" style="width:100%;" alt="toMap"> <figcaption><p> The <code>toMap</code> operator collects the items emitted by the source Observable into a <code>Map</code> and then emits that map. You supply a function that generates the key for each emitted item. You may also optionally supply a function that converts an emitted item into the value to be stored in the map (by default, the item itself is this value). </p> <h4>Sample Code</h4> <pre data-language="javascript">var source = Rx.Observable.timer(0, 1000)
    .take(5)
    .toMap(function (x) { return x * 2; }, function (x) { return x * 4; });

var subscription = source.subscribe(
    function (x) {
        var arr = [];
        x.forEach(function (value, key) { arr.push(value, key); })
        console.log('Next: ' + arr);
    },
    function (err) { console.log('Error: ' + err); },
    function () { console.log('Completed'); });</pre> <div><pre data-language="javascript">Next: [0,0,2,4,4,8,6,12,8,16]
Completed</pre></div> <p><code>toMap</code> is found in each of the following distributions:</p> <ul> <li><code>rx.all.js</code></li> <li><code>rx.all.compat.js</code></li> <li><code>rx.aggregates.js</code></li> </ul> </figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/toSet.png" style="width:100%;" alt="toSet"> <figcaption><p> Normally, an Observable that emits multiple items will do so by invoking its observer’s <code>onNext</code> method for each such item. You can change this behavior, instructing the Observable to compose a <code>Set</code> of these multiple items and then to invoke the observer’s <code>onNext</code> method only once, passing it the entire <code>Set</code>, by applying the <code>toSet</code> operator to the Observable. </p>
<p> Note that this only works in an ES6 environment or polyfilled. </p> <pre data-language="javascript">var source = Rx.Observable.timer(0, 1000)
    .take(5)
    .toSet();

var subscription = source.subscribe(
    function (x) {
        var arr = [];
        x.forEach(function (i) { arr.push(i); })
        console.log('Next: ' + arr);
    },
    function (err) { console.log('Error: ' + err); },
    function () { console.log('Completed'); });</pre> <div><pre data-language="javascript">Next: [0,1,2,3,4]
Completed</pre></div> <p><code>toSet</code> is found in each of the following distributions:</p> <ul> <li><code>rx.all.js</code></li> <li><code>rx.all.compat.js</code></li> <li><code>rx.aggregates.js</code></li> </ul> </figcaption> </figure> </div> </div> </div>   <div> <div role="tab" id="headingRxPHP"> <h3 class="panel-title">  RxPHP <code>toArray</code>  </h3> </div> <div id="collapseRxPHP" role="tabpanel" aria-labelledby="headingRxPHP"> <div> <figure class="variant"> <figcaption> <p> RxPHP implements this operator as <code>toArray</code>. </p> <p> Creates an observable sequence containing a single element which is an array containing all the elements of the source sequence. </p> <h4>Sample Code</h4> <pre data-language="php">//from https://github.com/ReactiveX/RxPHP/blob/master/demo/toArray/toArray.php

$source = \Rx\Observable::fromArray([1, 2, 3, 4]);

$observer = $createStdoutObserver();

$subscription = $source-&gt;toArray()
    -&gt;subscribe(new CallbackObserver(
        function ($array) use ($observer) {
            $observer-&gt;onNext(json_encode($array));
        },
        [$observer, "onError"],
        [$observer, "onCompleted"]
    ));</pre> <div> <pre data-language="javascript">Next value: [1,2,3,4]
Complete!</pre> </div> </figcaption> </figure> </div> </div> </div>     </div>
<div class="_attribution">
  <p class="_attribution-p">
    © ReactiveX contributors<br>Licensed under the Apache License 2.0.<br>
    <a href="http://reactivex.io/documentation/operators/to.html" class="_attribution-link">http://reactivex.io/documentation/operators/to.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
