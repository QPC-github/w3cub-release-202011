
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Start - ReactiveX - W3cubDocs</title>
  
  <meta name="description" content="There are a number of ways that programming languages have for obtaining values as the result of calculations, with names like functions, futures, &hellip;">
  <meta name="keywords" content="start, reactivex">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/reactivex/documentation/operators/start.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/reactivex.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/reactivex/" class="_nav-link" title="" style="margin-left:0;">ReactiveX</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _reactivex">
				
				
<h1>Start</h1> <blockquote>create an Observable that emits the return value of a function-like directive</blockquote> <figure> <img src="http://reactivex.io/documentation/operators/images/start.c.png" style="width:100%;" alt="Start"> <figcaption><p> There are a number of ways that programming languages have for obtaining values as the result of calculations, with names like functions, futures, actions, callables, runnables, and so forth. The operators grouped here under the <span class="operator">Start</span> operator category make these things behave like Observables so that they can be chained with other Observables in an Observable cascade </p></figcaption> </figure> <h2>See Also</h2> <ul> <li><a href="from"><span class="operator">From</span></a></li> <li><a href="just"><span class="operator">Just</span></a></li> <li><a href="http://rxwiki.wikidot.com/101samples#toc1"><cite>101 Rx Samples</cite>: Start — Run Code Asynchronously</a></li> </ul> <h2>Language-Specific Information</h2> <div id="accordion" role="tablist" aria-multiselectable="true">   <div> <div role="tab" id="headingRxGroovy"> <h3 class="panel-title">  RxGroovy <code>asyncAction asyncFunc deferFuture forEachFuture fromAction fromCallable fromFunc0 fromRunnable start startFuture toAsync</code>  </h3> </div> <div id="collapseRxGroovy" role="tabpanel" aria-labelledby="headingRxGroovy"> <div> <p> The various RxGroovy implementations of <span class="operator">Start</span> are found in the optional <code>rxjava-async</code> module. </p> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/start.png" style="width:100%;" alt="start"> <figcaption><p> The <code>rxjava-async</code> module includes the <code>start</code> operator, which accepts a function as its parameter, calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer. </p>
<p> Note that the function will only be executed once, even if more than one observer subscribes to the resulting Observable. </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/toAsync.png" style="width:100%;" alt="toAsync"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>toAsync</code>, <code>asyncAction</code>, and <code>asyncFunc</code> operators. These accept a function or an Action as their parameter. In the case of a function, this variant of the operator calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer (just as the <code>start</code> operator does). </p>
<p> In the case of Action, the process is similar, but there is no return value. In this case, the Observable created by this operator will emit a <code>null</code> before terminating. </p>
<p> Note that the function or Action will only be executed once, even if more than one observer subscribes to the resulting Observable. </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/startFuture.png" style="width:100%;" alt="startFuture"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>startFuture</code> operator. You pass it a function that returns a <code>Future</code>. <code>startFuture</code> calls this function immediately to obtain the <code>Future</code>, and calls the <code>Future</code>’s <code>get</code> method to try to obtain its value. It returns an Observable to which it will emit this value to any subsequent observers. </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/deferFuture.png" style="width:100%;" alt="deferFuture"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>deferFuture</code> operator. You pass it a function that returns a <code>Future</code> that returns an Observable. <code>deferFuture</code> returns an Observable, but does not call the function you provide until such time as an observer subscribes to the Observable it returns. When it does so, it immediately calls <code>get</code> on the resulting <code>Future</code>, and then mirrors the emissions from the Observable returned by the <code>Future</code> as its own emissions. </p>
<p> In this way you can include a <code>Future</code> that returns an Observable in a cascade of Observables as a peer to other Observables. </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/fromAction.png" style="width:100%;" alt="fromAction"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>fromAction</code> operator. It accepts an <code>Action</code> as its parameter, and returns an Observable that emits the item you pass to <code>fromAction</code> upon termination of the <code>Action</code> </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/fromCallable.png" style="width:100%;" alt="fromCallable"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>fromCallable</code> operator. It accepts a <code>Callable</code> as its parameter, and returns an Observable that emits the result of this callable as its sole emission. </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/fromRunnable.png" style="width:100%;" alt="fromRunnable"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>fromRunnable</code> operator. It accepts a <code>Runnable</code> as its parameter, and returns an Observable that emits the item you pass to <code>fromRunnable</code> upon termination of the <code>Runnable</code> </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/forEachFuture.png" style="width:100%;" alt="forEachFuture"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>forEachFuture</code> operator. It is not really a variant of the <span class="operator">Start</span> operator, but something all its own. You pass <code>forEachFuture</code> some subset of the typical observer methods (<code>onNext</code>, <code>onError</code>, and <code>onCompleted</code>) and the Observable will call these methods in the usual way. But <code>forEachFuture</code> itself returns a <code>Future</code> that blocks on <code>get</code> until the source Observable completes, then returns either the completion or error, depending on how the Observable completed. </p>
<p> You can use this if you need a function that blocks until the completion of an Observable. </p></figcaption> </figure> <p> The <code>rxjava-async</code> module also includes the <code>runAsync</code> operator. It is peculiar in that it creates a specialization of an Observable called a <code>StoppableObservable</code>. </p>
<p> Pass <code>runAsync</code> an <code>Action</code> and a <a href="../scheduler"><code>Scheduler</code></a>, and it will return a <code>StoppableObservable</code> that uses the specified <code>Action</code> to generate items that it emits. The <code>Action</code> accepts an <code>Observer</code> and a <code>Subscription</code>. It uses the <code>Subscription</code> to check for the <code>unsubscribed</code> condition, upon which it will stop emitting items. You can also manually stop a <code>StoppableObservable</code> at any time by calling its <code>unsubscribe</code> method (which will also unsubscribe the <code>Subscription</code> you have associated with the <code>StoppableObservable</code>). </p>
<p> Because <code>runAsync</code> immediately invokes the <code>Action</code> and begins emitting the items (that is, it produces a <em>hot</em> Observable), it is possible that some items may be lost in the interval between when you establish the <code>StoppableObservable</code> with this operator and when your <code>Observer</code> is ready to receive items. If this is a problem, you can use the variant of <code>runAsync</code> that also accepts a <code>Subject</code> and pass a <code>ReplaySubject</code> with which you can retrieve the otherwise-missing items. </p>
<p> In RxGroovy there is also a version of the <a href="from"><span class="operator">From</span></a> operator that converts a <code>Future</code> into an Observable, and in this way resembles the <span class="operator">Start</span> operator. </p> </div> </div> </div> <div> <div role="tab" id="headingRxJava 1․x"> <h3 class="panel-title">  RxJava 1․x <code>asyncAction asyncFunc deferFuture forEachFuture fromAction fromCallable fromFunc0 fromRunnable start startFuture toAsync</code>  </h3> </div> <div id="collapseRxJava 1․x" role="tabpanel" aria-labelledby="headingRxJava 1․x"> <div> <p> The various RxJava implementations of <span class="operator">Start</span> are found in the optional <code>rxjava-async</code> module. </p> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/start.png" style="width:100%;" alt="start"> <figcaption><p> The <code>rxjava-async</code> module includes the <code>start</code> operator, which accepts a function as its parameter, calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer. </p>
<p> Note that the function will only be executed once, even if more than one observer subscribes to the resulting Observable. </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/toAsync.png" style="width:100%;" alt="toAsync"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>toAsync</code>, <code>asyncAction</code>, and <code>asyncFunc</code> operators. These accept a function or an Action as their parameter. In the case of a function, this variant of the operator calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer (just as the <code>start</code> operator does). </p>
<p> In the case of Action, the process is similar, but there is no return value. In this case, the Observable created by this operator will emit a <code>null</code> before terminating. </p>
<p> Note that the function or Action will only be executed once, even if more than one observer subscribes to the resulting Observable. </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/startFuture.png" style="width:100%;" alt="startFuture"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>startFuture</code> operator. You pass it a function that returns a <code>Future</code>. <code>startFuture</code> calls this function immediately to obtain the <code>Future</code>, and calls the <code>Future</code>’s <code>get</code> method to try to obtain its value. It returns an Observable to which it will emit this value to any subsequent observers. </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/deferFuture.png" style="width:100%;" alt="deferFuture"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>deferFuture</code> operator. You pass it a function that returns a <code>Future</code> that returns an Observable. <code>deferFuture</code> returns an Observable, but does not call the function you provide until such time as an observer subscribes to the Observable it returns. When it does so, it immediately calls <code>get</code> on the resulting <code>Future</code>, and then mirrors the emissions from the Observable returned by the <code>Future</code> as its own emissions. </p>
<p> In this way you can include a <code>Future</code> that returns an Observable in a cascade of Observables as a peer to other Observables. </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/fromAction.png" style="width:100%;" alt="fromAction"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>fromAction</code> operator. It accepts an <code>Action</code> as its parameter, and returns an Observable that emits the item you pass to <code>fromAction</code> upon termination of the <code>Action</code> </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/fromCallable.png" style="width:100%;" alt="fromCallable"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>fromCallable</code> operator. It accepts a <code>Callable</code> as its parameter, and returns an Observable that emits the result of this callable as its sole emission. </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/fromRunnable.png" style="width:100%;" alt="fromRunnable"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>fromRunnable</code> operator. It accepts a <code>Runnable</code> as its parameter, and returns an Observable that emits the item you pass to <code>fromRunnable</code> upon termination of the <code>Runnable</code> </p></figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/forEachFuture.png" style="width:100%;" alt="forEachFuture"> <figcaption><p> The <code>rxjava-async</code> module also includes the <code>forEachFuture</code> operator. It is not really a variant of the <span class="operator">Start</span> operator, but something all its own. You pass <code>forEachFuture</code> some subset of the typical observer methods (<code>onNext</code>, <code>onError</code>, and <code>onCompleted</code>) and the Observable will call these methods in the usual way. But <code>forEachFuture</code> itself returns a <code>Future</code> that blocks on <code>get</code> until the source Observable completes, then returns either the completion or error, depending on how the Observable completed. </p>
<p> You can use this if you need a function that blocks until the completion of an Observable. </p></figcaption> </figure> <p> The <code>rxjava-async</code> module also includes the <code>runAsync</code> operator. It is peculiar in that it creates a specialization of an Observable called a <code>StoppableObservable</code>. </p>
<p> Pass <code>runAsync</code> an <code>Action</code> and a <a href="../scheduler"><code>Scheduler</code></a>, and it will return a <code>StoppableObservable</code> that uses the specified <code>Action</code> to generate items that it emits. The <code>Action</code> accepts an <code>Observer</code> and a <code>Subscription</code>. It uses the <code>Subscription</code> to check for the <code>unsubscribed</code> condition, upon which it will stop emitting items. You can also manually stop a <code>StoppableObservable</code> at any time by calling its <code>unsubscribe</code> method (which will also unsubscribe the <code>Subscription</code> you have associated with the <code>StoppableObservable</code>). </p>
<p> Because <code>runAsync</code> immediately invokes the <code>Action</code> and begins emitting the items (that is, it produces a <em>hot</em> Observable), it is possible that some items may be lost in the interval between when you establish the <code>StoppableObservable</code> with this operator and when your <code>Observer</code> is ready to receive items. If this is a problem, you can use the variant of <code>runAsync</code> that also accepts a <code>Subject</code> and pass a <code>ReplaySubject</code> with which you can retrieve the otherwise-missing items. </p>
<p> In RxJava there is also a version of the <a href="from"><span class="operator">From</span></a> operator that converts a <code>Future</code> into an Observable, and in this way resembles the <span class="operator">Start</span> operator. </p> </div> </div> </div>  <div> <div role="tab" id="headingRxJS"> <h3 class="panel-title">  RxJS <code>start startAsync toAsync</code>  </h3> </div> <div id="collapseRxJS" role="tabpanel" aria-labelledby="headingRxJS"> <div> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/start.png" style="width:100%;" alt="start"> <figcaption><p> RxJS implements the <code>start</code> operator. It takes as its parameters a function whose return value will be the emission from the resulting Observable, and, optionally, any additional parameter to that function and a <a href="../scheduler">Scheduler</a> on which to run the function. </p> <h4>Sample Code</h4> <pre data-language="javascript">var context = { value: 42 };

var source = Rx.Observable.start(
    function () {
        return this.value;
    },
    context,
    Rx.Scheduler.timeout
);

var subscription = source.subscribe(
    function (x) {
        console.log('Next: ' + x);
    },
    function (err) {
        console.log('Error: ' + err);
    },
    function () {
        console.log('Completed');
    });</pre> <div><pre data-language="javascript">Next: 42
Completed</pre></div> <p> <code>start</code> is found in the following distributions: </p> <ul> <li>
<code>rx.async.js</code> (requires <code>rx.binding.js</code> and either <code>rx.js</code> or <code>rx.compat.js</code>)</li> <li>
<code>rx.async.compat.js</code> (requires <code>rx.binding.js</code> and either <code>rx.js</code> or <code>rx.compat.js</code>)</li> <li><code>rx.lite.js</code></li> <li><code>rx.lite.compat.js</code></li> </ul> </figcaption> </figure> <figure class="variant"> <img src="http://reactivex.io/documentation/operators/images/startAsync.png" style="width:100%;" alt="start"> <figcaption><p> RxJS also implements the <code>startAsync</code> operator. It takes as its parameters an asynchronous function whose return value will be the emission from the resulting Observable. </p>
<p> You can convert a function into an asynchronous function with the <code>toAsync</code> method. It takes a function, function parameter, and <a href="../scheduler">Scheduler</a> as parameters, and returns an asynchronous function that will be invoked on the specified Scheduler. The last two parameters are optional; if you do not specify a Scheduler, the <code>timeout</code> Scheduler will be used by default. </p> <h4>Sample Code</h4> <pre data-language="javascript">var source = Rx.Observable.startAsync(function () {
    return RSVP.Promise.resolve(42);
});

var subscription = source.subscribe(
    function (x) {
        console.log('Next: ' + x);
    },
    function (err) {
        console.log('Error: ' + err);
    },
    function () {
        console.log('Completed');
    });</pre> <div><pre data-language="javascript">Next: 42
Completed</pre></div> <p> <code>startAsync</code> is found in the following distributions: </p> <ul> <li>
<code>rx.async.js</code> (requires <code>rx.binding.js</code> and either <code>rx.js</code> or <code>rx.compat.js</code>)</li> <li>
<code>rx.async.compat.js</code> (requires <code>rx.binding.js</code> and either <code>rx.js</code> or <code>rx.compat.js</code>)</li> <li><code>rx.lite.js</code></li> <li><code>rx.lite.compat.js</code></li> </ul> <p> <code>toAsync</code> is found in the following distributions: </p> <ul> <li>
<code>rx.async.js</code> (requires <code>rx.binding.js</code> and either <code>rx.js</code> or <code>rx.compat.js</code>)</li> <li>
<code>rx.async.compat.js</code> (requires <code>rx.binding.js</code> and either <code>rx.js</code> or <code>rx.compat.js</code>)</li> </ul> </figcaption> </figure> </div> </div> </div>   <div> <div role="tab" id="headingRxPHP"> <h3 class="panel-title">  RxPHP <code>start</code>  </h3> </div> <div id="collapseRxPHP" role="tabpanel" aria-labelledby="headingRxPHP"> <div> <figure class="variant"> <figcaption> <p> RxPHP implements this operator as <code>start</code>. </p> <p> Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence. </p> <h4>Sample Code</h4> <pre data-language="php">//from https://github.com/ReactiveX/RxPHP/blob/master/demo/start/start.php

$source = Rx\Observable::start(function () {
    return 42;
});

$source-&gt;subscribe($stdoutObserver);</pre> <div> <pre data-language="javascript">Next value: 42
Complete!</pre> </div> </figcaption> </figure> </div> </div> </div>    </div>
<div class="_attribution">
  <p class="_attribution-p">
    © ReactiveX contributors<br>Licensed under the Apache License 2.0.<br>
    <a href="http://reactivex.io/documentation/operators/start.html" class="_attribution-link">http://reactivex.io/documentation/operators/start.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
