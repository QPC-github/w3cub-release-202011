
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>ActiveRecord&#58;&#58;ConnectionAdapters&#58;&#58;SchemaStatements - Ruby on Rails 6.0 - W3cubDocs</title>
  
  <meta name="description" content=" Add a new type column named column_name to table_name. ">
  <meta name="keywords" content="module, activerecord, connectionadapters, schemastatements, ruby, on, rails, rails~6.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rails~6.0/activerecord/connectionadapters/schemastatements.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/rails~6.0.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rails~6.0/" class="_nav-link" title="" style="margin-left:0;">Ruby on Rails 6.0</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="module-ActiveRecord::ConnectionAdapters::SchemaStatements" class="module"> module ActiveRecord::ConnectionAdapters::SchemaStatements </h1>  <section id="5Buntitled-5D" class="documentation-section"> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-add_belongs_to"> <span class="method-name">add_belongs_to</span><span class="method-args">(table_name, ref_name, **options)</span> </div>  <div class="aliases"> Alias for: <a href="schemastatements#method-i-add_reference">add_reference</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_column"> <span class="method-name">add_column</span><span class="method-args">(table_name, column_name, type, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_column-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 588
def add_column(table_name, column_name, type, **options)
  at = create_alter_table table_name
  at.add_column(column_name, type, options)
  execute schema_creation.accept at
end</pre> </div> <p>Add a new <code>type</code> column named <code>column_name</code> to <code>table_name</code>.</p> <p>The <code>type</code> parameter is normally one of the migrations native types, which is one of the following: <code>:primary_key</code>, <code>:string</code>, <code>:text</code>, <code>:integer</code>, <code>:bigint</code>, <code>:float</code>, <code>:decimal</code>, <code>:numeric</code>, <code>:datetime</code>, <code>:time</code>, <code>:date</code>, <code>:binary</code>, <code>:boolean</code>.</p> <p>You may use a type not in this list as long as it is supported by your database (for example, “polygon” in <span>MySQL</span>), but this will not be database agnostic and should usually be avoided.</p> <p>Available options are (none of these exists by default):</p> <ul>
<li> <p><code>:limit</code> - Requests a maximum column length. This is the number of characters for a <code>:string</code> column and number of bytes for <code>:text</code>, <code>:binary</code>, and <code>:integer</code> columns. This option is ignored by some backends.</p> </li>
<li> <p><code>:default</code> - The column's default value. Use <code>nil</code> for <code>NULL</code>.</p> </li>
<li> <p><code>:null</code> - Allows or disallows <code>NULL</code> values in the column.</p> </li>
<li> <p><code>:precision</code> - Specifies the precision for the <code>:decimal</code>, <code>:numeric</code>, <code>:datetime</code>, and <code>:time</code> columns.</p> </li>
<li> <p><code>:scale</code> - Specifies the scale for the <code>:decimal</code> and <code>:numeric</code> columns.</p> </li>
<li> <p><code>:collation</code> - Specifies the collation for a <code>:string</code> or <code>:text</code> column. If not specified, the column will have the same collation as the table.</p> </li>
<li> <p><code>:comment</code> - Specifies the comment for the column. This option is ignored by some backends.</p> </li>
</ul> <p>Note: The precision is the total number of significant digits, and the scale is the number of digits that can be stored following the decimal point. For example, the number 123.45 has a precision of 5 and a scale of 2. A decimal with a precision of 5 and a scale of 2 can range from -999.99 to 999.99.</p> <p>Please be aware of different RDBMS implementations behavior with <code>:decimal</code> columns:</p> <ul>
<li> <p>The SQL standard says the default scale should be 0, <code>:scale</code> &lt;= <code>:precision</code>, and makes no comments about the requirements of <code>:precision</code>.</p> </li>
<li> <p>MySQL: <code>:precision</code> [1..63], <code>:scale</code> [0..30]. Default is (10,0).</p> </li>
<li> <p>PostgreSQL: <code>:precision</code> [1..infinity], <code>:scale</code> [0..infinity]. No default.</p> </li>
<li> <p>SQLite3: No restrictions on <code>:precision</code> and <code>:scale</code>, but the maximum supported <code>:precision</code> is 16. No default.</p> </li>
<li> <p>Oracle: <code>:precision</code> [1..38], <code>:scale</code> [-84..127]. Default is (38,0).</p> </li>
<li> <p>DB2: <code>:precision</code> [1..63], <code>:scale</code> [0..62]. Default unknown.</p> </li>
<li> <p>SqlServer: <code>:precision</code> [1..38], <code>:scale</code> [0..38]. Default (38,0).</p> </li>
</ul> <h2 id="method-i-add_column-label-Examples">Examples</h2> <pre class="ruby" data-language="ruby">add_column(:users, :picture, :binary, limit: 2.megabytes)
# ALTER TABLE "users" ADD "picture" blob(2097152)

add_column(:articles, :status, :string, limit: 20, default: 'draft', null: false)
# ALTER TABLE "articles" ADD "status" varchar(20) DEFAULT 'draft' NOT NULL

add_column(:answers, :bill_gates_money, :decimal, precision: 15, scale: 2)
# ALTER TABLE "answers" ADD "bill_gates_money" decimal(15,2)

add_column(:measurements, :sensor_reading, :decimal, precision: 30, scale: 20)
# ALTER TABLE "measurements" ADD "sensor_reading" decimal(30,20)

# While :scale defaults to zero on most databases, it
# probably wouldn't hurt to include it.
add_column(:measurements, :huge_integer, :decimal, precision: 30)
# ALTER TABLE "measurements" ADD "huge_integer" decimal(30)

# Defines a column that stores an array of a type.
add_column(:users, :skills, :text, array: true)
# ALTER TABLE "users" ADD "skills" text[]

# Defines a column with a database-specific type.
add_column(:shapes, :triangle, 'polygon')
# ALTER TABLE "shapes" ADD "triangle" polygon
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_foreign_key"> <span class="method-name">add_foreign_key</span><span class="method-args">(from_table, to_table, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_foreign_key-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 991
def add_foreign_key(from_table, to_table, options = {})
  return unless supports_foreign_keys?

  options = foreign_key_options(from_table, to_table, options)
  at = create_alter_table from_table
  at.add_foreign_key to_table, options

  execute schema_creation.accept(at)
end</pre> </div> <p>Adds a new foreign key. <code>from_table</code> is the table with the key column, <code>to_table</code> contains the referenced primary key.</p> <p>The foreign key will be named after the following pattern: <code>fk_rails_&lt;identifier&gt;</code>. <code>identifier</code> is a 10 character long string which is deterministically generated from the <code>from_table</code> and <code>column</code>. A custom name can be specified with the <code>:name</code> option.</p> <h6 id="method-i-add_foreign_key-label-Creating+a+simple+foreign+key">Creating a simple foreign key</h6> <pre class="ruby" data-language="ruby">add_foreign_key :articles, :authors
</pre> <p>generates:</p> <pre>ALTER TABLE "articles" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY ("author_id") REFERENCES "authors" ("id")</pre> <h6 id="method-i-add_foreign_key-label-Creating+a+foreign+key+on+a+specific+column">Creating a foreign key on a specific column</h6> <pre class="ruby" data-language="ruby">add_foreign_key :articles, :users, column: :author_id, primary_key: "lng_id"
</pre> <p>generates:</p> <pre>ALTER TABLE "articles" ADD CONSTRAINT fk_rails_58ca3d3a82 FOREIGN KEY ("author_id") REFERENCES "users" ("lng_id")</pre> <h6 id="method-i-add_foreign_key-label-Creating+a+cascading+foreign+key">Creating a cascading foreign key</h6> <pre class="ruby" data-language="ruby">add_foreign_key :articles, :authors, on_delete: :cascade
</pre> <p>generates:</p> <pre>ALTER TABLE "articles" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY ("author_id") REFERENCES "authors" ("id") ON DELETE CASCADE</pre> <p>The <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:column</code> </dt>
<dd> <p>The foreign key column name on <code>from_table</code>. Defaults to <code>to_table.singularize + "_id"</code></p> </dd>
<dt>
<code>:primary_key</code> </dt>
<dd> <p>The primary key column name on <code>to_table</code>. Defaults to <code>id</code>.</p> </dd>
<dt>
<code>:name</code> </dt>
<dd> <p>The constraint name. Defaults to <code>fk_rails_&lt;identifier&gt;</code>.</p> </dd>
<dt>
<code>:on_delete</code> </dt>
<dd> <p>Action that happens <code>ON DELETE</code>. Valid values are <code>:nullify</code>, <code>:cascade</code> and <code>:restrict</code></p> </dd>
<dt>
<code>:on_update</code> </dt>
<dd> <p>Action that happens <code>ON UPDATE</code>. Valid values are <code>:nullify</code>, <code>:cascade</code> and <code>:restrict</code></p> </dd>
<dt>
<code>:validate</code> </dt>
<dd> <p>(PostgreSQL only) Specify whether or not the constraint should be validated. Defaults to <code>true</code>.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_index"> <span class="method-name">add_index</span><span class="method-args">(table_name, column_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_index-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 785
def add_index(table_name, column_name, options = {})
  index_name, index_type, index_columns, index_options = add_index_options(table_name, column_name, options)
  execute "CREATE #{index_type} INDEX #{quote_column_name(index_name)} ON #{quote_table_name(table_name)} (#{index_columns})#{index_options}"
end</pre> </div> <p>Adds a new index to the table. <code>column_name</code> can be a single <span>Symbol</span>, or an <a href="../../array">Array</a> of Symbols.</p> <p>The index will be named after the table and the column name(s), unless you pass <code>:name</code> as an option.</p> <h6 id="method-i-add_index-label-Creating+a+simple+index">Creating a simple index</h6> <pre class="ruby" data-language="ruby">add_index(:suppliers, :name)
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE INDEX suppliers_name_index ON suppliers(name)
</pre> <h6 id="method-i-add_index-label-Creating+a+unique+index">Creating a unique index</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:branch_id, :party_id], unique: true)
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE UNIQUE INDEX accounts_branch_id_party_id_index ON accounts(branch_id, party_id)
</pre> <h6 id="method-i-add_index-label-Creating+a+named+index">Creating a named index</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:branch_id, :party_id], unique: true, name: 'by_branch_party')
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE UNIQUE INDEX by_branch_party ON accounts(branch_id, party_id)
</pre> <h6 id="method-i-add_index-label-Creating+an+index+with+specific+key+length">Creating an index with specific key length</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, :name, name: 'by_name', length: 10)
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE INDEX by_name ON accounts(name(10))
</pre> <h6 id="method-i-add_index-label-Creating+an+index+with+specific+key+lengths+for+multiple+keys">Creating an index with specific key lengths for multiple keys</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:name, :surname], name: 'by_name_surname', length: {name: 10, surname: 15})
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE INDEX by_name_surname ON accounts(name(10), surname(15))
</pre> <p>Note: SQLite doesn't support index length.</p> <h6 id="method-i-add_index-label-Creating+an+index+with+a+sort+order+-28desc+or+asc-2C+asc+is+the+default-29">Creating an index with a sort order (desc or asc, asc is the default)</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:branch_id, :party_id, :surname], order: {branch_id: :desc, party_id: :asc})
</pre> <p>generates:</p> <pre>CREATE INDEX by_branch_desc_party ON accounts(branch_id DESC, party_id ASC, surname)</pre> <p>Note: <span>MySQL</span> only supports index order from 8.0.1 onwards (earlier versions accepted the syntax but ignored it).</p> <h6 id="method-i-add_index-label-Creating+a+partial+index">Creating a partial index</h6> <pre class="ruby" data-language="ruby">add_index(:accounts, [:branch_id, :party_id], unique: true, where: "active")
</pre> <p>generates:</p> <pre>CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id) WHERE active</pre> <p>Note: Partial indexes are only supported for PostgreSQL and SQLite 3.8.0+.</p> <h6 id="method-i-add_index-label-Creating+an+index+with+a+specific+method">Creating an index with a specific method</h6> <pre class="ruby" data-language="ruby">add_index(:developers, :name, using: 'btree')
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE INDEX index_developers_on_name ON developers USING btree (name) -- PostgreSQL
CREATE INDEX index_developers_on_name USING btree ON developers (name) -- MySQL
</pre> <p>Note: only supported by PostgreSQL and <span>MySQL</span></p> <h6 id="method-i-add_index-label-Creating+an+index+with+a+specific+operator+class">Creating an index with a specific operator class</h6> <pre class="ruby" data-language="ruby">add_index(:developers, :name, using: 'gist', opclass: :gist_trgm_ops)
# CREATE INDEX developers_on_name ON developers USING gist (name gist_trgm_ops) -- PostgreSQL

add_index(:developers, [:name, :city], using: 'gist', opclass: { city: :gist_trgm_ops })
# CREATE INDEX developers_on_name_and_city ON developers USING gist (name, city gist_trgm_ops) -- PostgreSQL

add_index(:developers, [:name, :city], using: 'gist', opclass: :gist_trgm_ops)
# CREATE INDEX developers_on_name_and_city ON developers USING gist (name gist_trgm_ops, city gist_trgm_ops) -- PostgreSQL
</pre> <p>Note: only supported by PostgreSQL</p> <h6 id="method-i-add_index-label-Creating+an+index+with+a+specific+type">Creating an index with a specific type</h6> <pre class="ruby" data-language="ruby">add_index(:developers, :name, type: :fulltext)
</pre> <p>generates:</p> <pre class="ruby" data-language="ruby">CREATE FULLTEXT INDEX index_developers_on_name ON developers (name) -- MySQL
</pre> <p>Note: only supported by <span>MySQL</span>.</p> <h6 id="method-i-add_index-label-Creating+an+index+with+a+specific+algorithm">Creating an index with a specific algorithm</h6> <pre class="ruby" data-language="ruby">add_index(:developers, :name, algorithm: :concurrently)
# CREATE INDEX CONCURRENTLY developers_on_name on developers (name)
</pre> <p>Note: only supported by PostgreSQL.</p> <p>Concurrently adding an index is not supported in a transaction.</p> <p>For more information see the <a href="../migration">“Transactional Migrations” section</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_reference"> <span class="method-name">add_reference</span><span class="method-args">(table_name, ref_name, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_reference-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 904
def add_reference(table_name, ref_name, **options)
  ReferenceDefinition.new(ref_name, options).add_to(update_table_definition(table_name, self))
end</pre> </div> <p>Adds a reference. The reference column is a bigint by default, the <code>:type</code> option can be used to specify a different type. Optionally adds a <code>_type</code> column, if <code>:polymorphic</code> option is provided. <a href="schemastatements#method-i-add_reference">add_reference</a> and <a href="schemastatements#method-i-add_belongs_to">add_belongs_to</a> are acceptable.</p> <p>The <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:type</code> </dt>
<dd> <p>The reference column type. Defaults to <code>:bigint</code>.</p> </dd>
<dt>
<code>:index</code> </dt>
<dd> <p>Add an appropriate index. Defaults to true. See <a href="schemastatements#method-i-add_index">add_index</a> for usage of this option.</p> </dd>
<dt>
<code>:foreign_key</code> </dt>
<dd> <p>Add an appropriate foreign key constraint. Defaults to false.</p> </dd>
<dt>
<code>:polymorphic</code> </dt>
<dd> <p>Whether an additional <code>_type</code> column should be added. Defaults to false.</p> </dd>
<dt>
<code>:null</code> </dt>
<dd> <p>Whether the column allows nulls. Defaults to true.</p> </dd>
</dl> <h6 id="method-i-add_reference-label-Create+a+user_id+bigint+column+without+an+index">Create a user_id bigint column without an index</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :user, index: false)
</pre> <h6 id="method-i-add_reference-label-Create+a+user_id+string+column">Create a user_id string column</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :user, type: :string)
</pre> <h6 id="method-i-add_reference-label-Create+supplier_id-2C+supplier_type+columns">Create supplier_id, supplier_type columns</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :supplier, polymorphic: true)
</pre> <h6 id="method-i-add_reference-label-Create+a+supplier_id+column+with+a+unique+index">Create a supplier_id column with a unique index</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :supplier, index: { unique: true })
</pre> <h6 id="method-i-add_reference-label-Create+a+supplier_id+column+with+a+named+index">Create a supplier_id column with a named index</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :supplier, index: { name: "my_supplier_index" })
</pre> <h6 id="method-i-add_reference-label-Create+a+supplier_id+column+and+appropriate+foreign+key">Create a supplier_id column and appropriate foreign key</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :supplier, foreign_key: true)
</pre> <h6 id="method-i-add_reference-label-Create+a+supplier_id+column+and+a+foreign+key+to+the+firms+table">Create a supplier_id column and a foreign key to the firms table</h6> <pre class="ruby" data-language="ruby">add_reference(:products, :supplier, foreign_key: {to_table: :firms})
</pre>  </div> <div class="aliases"> Also aliased as: <a href="schemastatements#method-i-add_belongs_to">add_belongs_to</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_timestamps"> <span class="method-name">add_timestamps</span><span class="method-args">(table_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="add_timestamps-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1148
def add_timestamps(table_name, options = {})
  options[:null] = false if options[:null].nil?

  if !options.key?(:precision) &amp;&amp; supports_datetime_with_precision?
    options[:precision] = 6
  end

  add_column table_name, :created_at, :datetime, options
  add_column table_name, :updated_at, :datetime, options
end</pre> </div> <p>Adds timestamps (<code>created_at</code> and <code>updated_at</code>) columns to <code>table_name</code>. Additional options (like <code>:null</code>) are forwarded to <a href="schemastatements#method-i-add_column">add_column</a>.</p> <pre class="ruby" data-language="ruby">add_timestamps(:suppliers, null: true)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-assume_migrated_upto_version"> <span class="method-name">assume_migrated_upto_version</span><span class="method-args">(version, migrations_paths = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="assume_migrated_upto_version-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1073
      def assume_migrated_upto_version(version, migrations_paths = nil)
        unless migrations_paths.nil?
          ActiveSupport::Deprecation.warn(&lt;&lt;~MSG.squish)
            Passing migrations_paths to #assume_migrated_upto_version is deprecated and will be removed in Rails 6.1.
          MSG
        end

        version = version.to_i
        sm_table = quote_table_name(schema_migration.table_name)

        migrated = migration_context.get_all_versions
        versions = migration_context.migrations.map(&amp;:version)

        unless migrated.include?(version)
          execute "INSERT INTO #{sm_table} (version) VALUES (#{quote(version)})"
        end

        inserting = (versions - migrated).select { |v| v &lt; version }
        if inserting.any?
          if (duplicate = inserting.detect { |v| inserting.count(v) &gt; 1 })
            raise "Duplicate migration #{duplicate}. Please renumber your migrations to resolve the conflict."
          end
          execute insert_versions_sql(inserting)
        end
      end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_column"> <span class="method-name">change_column</span><span class="method-args">(table_name, column_name, type, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="change_column-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 623
def change_column(table_name, column_name, type, options = {})
  raise NotImplementedError, "change_column is not implemented"
end</pre> </div> <p>Changes the column's definition according to the new options. See <a href="tabledefinition#method-i-column">ActiveRecord::ConnectionAdapters::TableDefinition#column</a> for details of the options you can use.</p> <pre class="ruby" data-language="ruby">change_column(:suppliers, :name, :string, limit: 80)
change_column(:accounts, :description, :text)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_column_comment"> <span class="method-name">change_column_comment</span><span class="method-args">(table_name, column_name, comment_or_changes)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="change_column_comment-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1224
def change_column_comment(table_name, column_name, comment_or_changes)
  raise NotImplementedError, "#{self.class} does not support changing column comments"
end</pre> </div> <p>Changes the comment for a column or removes it if <code>nil</code>.</p> <p>Passing a hash containing <code>:from</code> and <code>:to</code> will make this change reversible in migration:</p> <pre class="ruby" data-language="ruby">change_column_comment(:posts, :state, from: "old_comment", to: "new_comment")
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_column_default"> <span class="method-name">change_column_default</span><span class="method-args">(table_name, column_name, default_or_changes)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="change_column_default-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 641
def change_column_default(table_name, column_name, default_or_changes)
  raise NotImplementedError, "change_column_default is not implemented"
end</pre> </div> <p>Sets a new default value for a column:</p> <pre class="ruby" data-language="ruby">change_column_default(:suppliers, :qualification, 'new')
change_column_default(:accounts, :authorized, 1)
</pre> <p>Setting the default to <code>nil</code> effectively drops the default:</p> <pre class="ruby" data-language="ruby">change_column_default(:users, :email, nil)
</pre> <p>Passing a hash containing <code>:from</code> and <code>:to</code> will make this change reversible in migration:</p> <pre class="ruby" data-language="ruby">change_column_default(:posts, :state, from: nil, to: "draft")
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_column_null"> <span class="method-name">change_column_null</span><span class="method-args">(table_name, column_name, null, default = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="change_column_null-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 661
def change_column_null(table_name, column_name, null, default = nil)
  raise NotImplementedError, "change_column_null is not implemented"
end</pre> </div> <p>Sets or removes a <code>NOT NULL</code> constraint on a column. The <code>null</code> flag indicates whether the value can be <code>NULL</code>. For example</p> <pre class="ruby" data-language="ruby">change_column_null(:users, :nickname, false)
</pre> <p>says nicknames cannot be <code>NULL</code> (adds the constraint), whereas</p> <pre class="ruby" data-language="ruby">change_column_null(:users, :nickname, true)
</pre> <p>allows them to be <code>NULL</code> (drops the constraint).</p> <p>The method accepts an optional fourth argument to replace existing <code>NULL</code>s with some other value. Use that one when enabling the constraint if needed, since otherwise those rows would not be valid.</p> <p>Please note the fourth argument does not set a column's default.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_table"> <span class="method-name">change_table</span><span class="method-args">(table_name, options = {}) { |update_table_definition(table_name, recorder)| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="change_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 471
def change_table(table_name, options = {})
  if supports_bulk_alter? &amp;&amp; options[:bulk]
    recorder = ActiveRecord::Migration::CommandRecorder.new(self)
    yield update_table_definition(table_name, recorder)
    bulk_change_table(table_name, recorder.commands)
  else
    yield update_table_definition(table_name, self)
  end
end</pre> </div> <p>A block for changing columns in <code>table</code>.</p> <pre class="ruby" data-language="ruby"># change_table() yields a Table instance
change_table(:suppliers) do |t|
  t.column :name, :string, limit: 60
  # Other column alterations here
end
</pre> <p>The <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:bulk</code> </dt>
<dd> <p>Set this to true to make this a bulk alter query, such as</p> <pre>ALTER TABLE `users` ADD COLUMN age INT, ADD COLUMN birthdate DATETIME ...</pre> <p>Defaults to false.</p> <p>Only supported on the <span>MySQL</span> and PostgreSQL adapter, ignored elsewhere.</p> </dd>
</dl> <h6 id="method-i-change_table-label-Add+a+column">Add a column</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.column :name, :string, limit: 60
end
</pre> <h6 id="method-i-change_table-label-Add+2+integer+columns">Add 2 integer columns</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.integer :width, :height, null: false, default: 0
end
</pre> <h6 id="method-i-change_table-label-Add+created_at-2Fupdated_at+columns">Add created_at/updated_at columns</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.timestamps
end
</pre> <h6 id="method-i-change_table-label-Add+a+foreign+key+column">Add a foreign key column</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.references :company
end
</pre> <p>Creates a <code>company_id(bigint)</code> column.</p> <h6 id="method-i-change_table-label-Add+a+polymorphic+foreign+key+column">Add a polymorphic foreign key column</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.belongs_to :company, polymorphic: true
end
</pre> <p>Creates <code>company_type(varchar)</code> and <code>company_id(bigint)</code> columns.</p> <h6 id="method-i-change_table-label-Remove+a+column">Remove a column</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.remove :company
end
</pre> <h6 id="method-i-change_table-label-Remove+several+columns">Remove several columns</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.remove :company_id
  t.remove :width, :height
end
</pre> <h6 id="method-i-change_table-label-Remove+an+index">Remove an index</h6> <pre class="ruby" data-language="ruby">change_table(:suppliers) do |t|
  t.remove_index :company_id
end
</pre> <p>See also <a href="table">Table</a> for details on all of the various column transformations.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-change_table_comment"> <span class="method-name">change_table_comment</span><span class="method-args">(table_name, comment_or_changes)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="change_table_comment-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1214
def change_table_comment(table_name, comment_or_changes)
  raise NotImplementedError, "#{self.class} does not support changing table comments"
end</pre> </div> <p>Changes the comment for a table or removes it if <code>nil</code>.</p> <p>Passing a hash containing <code>:from</code> and <code>:to</code> will make this change reversible in migration:</p> <pre class="ruby" data-language="ruby">change_table_comment(:posts, from: "old_comment", to: "new_comment")
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-column_exists-3F"> <span class="method-name">column_exists?</span><span class="method-args">(table_name, column_name, type = nil, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="column_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 133
def column_exists?(table_name, column_name, type = nil, **options)
  column_name = column_name.to_s
  checks = []
  checks &lt;&lt; lambda { |c| c.name == column_name }
  checks &lt;&lt; lambda { |c| c.type == type.to_sym rescue nil } if type
  column_options_keys.each do |attr|
    checks &lt;&lt; lambda { |c| c.send(attr) == options[attr] } if options.key?(attr)
  end

  columns(table_name).any? { |c| checks.all? { |check| check[c] } }
end</pre> </div> <p>Checks to see if a column exists in a given table.</p> <pre class="ruby" data-language="ruby"># Check a column exists
column_exists?(:suppliers, :name)

# Check a column exists of a particular type
column_exists?(:suppliers, :name, :string)

# Check a column exists with a specific definition
column_exists?(:suppliers, :name, :string, limit: 100)
column_exists?(:suppliers, :name, :string, default: 'default')
column_exists?(:suppliers, :name, :string, null: false)
column_exists?(:suppliers, :tax, :decimal, precision: 8, scale: 2)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-columns"> <span class="method-name">columns</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="columns-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 112
def columns(table_name)
  table_name = table_name.to_s
  column_definitions(table_name).map do |field|
    new_column_from_field(table_name, field)
  end
end</pre> </div> <p>Returns an array of <code>Column</code> objects for the table specified by <code>table_name</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_join_table"> <span class="method-name">create_join_table</span><span class="method-args">(table_1, table_2, column_options: {}, **options) { |td| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="create_join_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 374
def create_join_table(table_1, table_2, column_options: {}, **options)
  join_table_name = find_join_table_name(table_1, table_2, options)

  column_options.reverse_merge!(null: false, index: false)

  t1_ref, t2_ref = [table_1, table_2].map { |t| t.to_s.singularize }

  create_table(join_table_name, options.merge!(id: false)) do |td|
    td.references t1_ref, column_options
    td.references t2_ref, column_options
    yield td if block_given?
  end
end</pre> </div> <p>Creates a new join table with the name created using the lexical order of the first two arguments. These arguments can be a <a href="../../string">String</a> or a <span>Symbol</span>.</p> <pre class="ruby" data-language="ruby"># Creates a table called 'assemblies_parts' with no id.
create_join_table(:assemblies, :parts)
</pre> <p>You can pass an <code>options</code> hash which can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:table_name</code> </dt>
<dd> <p>Sets the table name, overriding the default.</p> </dd>
<dt>
<code>:column_options</code> </dt>
<dd> <p>Any extra options you want appended to the columns definition.</p> </dd>
<dt>
<code>:options</code> </dt>
<dd> <p>Any extra options you want appended to the table definition.</p> </dd>
<dt>
<code>:temporary</code> </dt>
<dd> <p>Make a temporary table.</p> </dd>
<dt>
<code>:force</code> </dt>
<dd> <p>Set to true to drop the table before creating it. Defaults to false.</p> </dd>
</dl> <p>Note that <a href="schemastatements#method-i-create_join_table">create_join_table</a> does not create any indices by default; you can use its block form to do so yourself:</p> <pre class="ruby" data-language="ruby">create_join_table :products, :categories do |t|
  t.index :product_id
  t.index :category_id
end
</pre> <h6 id="method-i-create_join_table-label-Add+a+backend+specific+option+to+the+generated+SQL+-28MySQL-29">Add a backend specific option to the generated SQL (MySQL)</h6> <pre class="ruby" data-language="ruby">create_join_table(:assemblies, :parts, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8')
</pre> <p>generates:</p> <pre>CREATE TABLE assemblies_parts (
  assembly_id bigint NOT NULL,
  part_id bigint NOT NULL,
) ENGINE=InnoDB DEFAULT CHARSET=utf8</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_table"> <span class="method-name">create_table</span><span class="method-args">(table_name, **options) { |td| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="create_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 294
def create_table(table_name, **options)
  td = create_table_definition(table_name, options)

  if options[:id] != false &amp;&amp; !options[:as]
    pk = options.fetch(:primary_key) do
      Base.get_primary_key table_name.to_s.singularize
    end

    if pk.is_a?(Array)
      td.primary_keys pk
    else
      td.primary_key pk, options.fetch(:id, :primary_key), options.except(:comment)
    end
  end

  yield td if block_given?

  if options[:force]
    drop_table(table_name, options.merge(if_exists: true))
  end

  result = execute schema_creation.accept td

  unless supports_indexes_in_create?
    td.indexes.each do |column_name, index_options|
      add_index(table_name, column_name, index_options)
    end
  end

  if supports_comments? &amp;&amp; !supports_comments_in_create?
    if table_comment = options[:comment].presence
      change_table_comment(table_name, table_comment)
    end

    td.columns.each do |column|
      change_column_comment(table_name, column.name, column.comment) if column.comment.present?
    end
  end

  result
end</pre> </div> <p>Creates a new table with the name <code>table_name</code>. <code>table_name</code> may either be a <a href="../../string">String</a> or a <span>Symbol</span>.</p> <p>There are two ways to work with <a href="schemastatements#method-i-create_table">create_table</a>. You can use the block form or the regular form, like this:</p> <h3 id="method-i-create_table-label-Block+form">Block form</h3> <pre class="ruby" data-language="ruby"># create_table() passes a TableDefinition object to the block.
# This form will not only create the table, but also columns for the
# table.

create_table(:suppliers) do |t|
  t.column :name, :string, limit: 60
  # Other fields here
end
</pre> <h3 id="method-i-create_table-label-Block+form-2C+with+shorthand">Block form, with shorthand</h3> <pre class="ruby" data-language="ruby"># You can also use the column types as method calls, rather than calling the column method.
create_table(:suppliers) do |t|
  t.string :name, limit: 60
  # Other fields here
end
</pre> <h3 id="method-i-create_table-label-Regular+form">Regular form</h3> <pre class="ruby" data-language="ruby"># Creates a table called 'suppliers' with no columns.
create_table(:suppliers)
# Add a column to 'suppliers'.
add_column(:suppliers, :name, :string, {limit: 60})
</pre> <p>The <code>options</code> hash can include the following keys:</p> <dl class="rdoc-list label-list">
<dt>
<code>:id</code> </dt>
<dd> <p>Whether to automatically add a primary key column. Defaults to true. Join tables for <a href="../associations/classmethods#method-i-has_and_belongs_to_many">ActiveRecord::Base.has_and_belongs_to_many</a> should set it to false.</p> <p>A <span>Symbol</span> can be used to specify the type of the generated primary key column.</p> </dd>
<dt>
<code>:primary_key</code> </dt>
<dd> <p>The name of the primary key, if one is to be added automatically. Defaults to <code>id</code>. If <code>:id</code> is false, then this option is ignored.</p> <p>If an array is passed, a composite primary key will be created.</p> <p>Note that Active Record models will automatically detect their primary key. This can be avoided by using <a href="../attributemethods/primarykey/classmethods#method-i-primary_key-3D">self.primary_key=</a> on the model to define the key explicitly.</p> </dd>
<dt>
<code>:options</code> </dt>
<dd> <p>Any extra options you want appended to the table definition.</p> </dd>
<dt>
<code>:temporary</code> </dt>
<dd> <p>Make a temporary table.</p> </dd>
<dt>
<code>:force</code> </dt>
<dd> <p>Set to true to drop the table before creating it. Set to <code>:cascade</code> to drop dependent objects as well. Defaults to false.</p> </dd>
<dt>
<code>:if_not_exists</code> </dt>
<dd> <p>Set to true to avoid raising an error when the table already exists. Defaults to false.</p> </dd>
<dt>
<code>:as</code> </dt>
<dd> <p>SQL to use to generate the table. When this option is used, the block is ignored, as are the <code>:id</code> and <code>:primary_key</code> options.</p> </dd>
</dl> <h6 id="method-i-create_table-label-Add+a+backend+specific+option+to+the+generated+SQL+-28MySQL-29">Add a backend specific option to the generated SQL (MySQL)</h6> <pre class="ruby" data-language="ruby">create_table(:suppliers, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8mb4')
</pre> <p>generates:</p> <pre>CREATE TABLE suppliers (
  id bigint auto_increment PRIMARY KEY
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4</pre> <h6 id="method-i-create_table-label-Rename+the+primary+key+column">Rename the primary key column</h6> <pre class="ruby" data-language="ruby">create_table(:objects, primary_key: 'guid') do |t|
  t.column :name, :string, limit: 80
end
</pre> <p>generates:</p> <pre>CREATE TABLE objects (
  guid bigint auto_increment PRIMARY KEY,
  name varchar(80)
)</pre> <h6 id="method-i-create_table-label-Change+the+primary+key+column+type">Change the primary key column type</h6> <pre class="ruby" data-language="ruby">create_table(:tags, id: :string) do |t|
  t.column :label, :string
end
</pre> <p>generates:</p> <pre>CREATE TABLE tags (
  id varchar PRIMARY KEY,
  label varchar
)</pre> <h6 id="method-i-create_table-label-Create+a+composite+primary+key">Create a composite primary key</h6> <pre class="ruby" data-language="ruby">create_table(:orders, primary_key: [:product_id, :client_id]) do |t|
  t.belongs_to :product
  t.belongs_to :client
end
</pre> <p>generates:</p> <pre>CREATE TABLE order (
    product_id bigint NOT NULL,
    client_id bigint NOT NULL
);

ALTER TABLE ONLY "orders"
  ADD CONSTRAINT orders_pkey PRIMARY KEY (product_id, client_id);</pre> <h6 id="method-i-create_table-label-Do+not+add+a+primary+key+column">Do not add a primary key column</h6> <pre class="ruby" data-language="ruby">create_table(:categories_suppliers, id: false) do |t|
  t.column :category_id, :bigint
  t.column :supplier_id, :bigint
end
</pre> <p>generates:</p> <pre>CREATE TABLE categories_suppliers (
  category_id bigint,
  supplier_id bigint
)</pre> <h6 id="method-i-create_table-label-Create+a+temporary+table+based+on+a+query">Create a temporary table based on a query</h6> <pre class="ruby" data-language="ruby">create_table(:long_query, temporary: true,
  as: "SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id")
</pre> <p>generates:</p> <pre>CREATE TEMPORARY TABLE long_query AS
  SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id</pre> <p>See also <a href="tabledefinition#method-i-column">ActiveRecord::ConnectionAdapters::TableDefinition#column</a> for details on how to create columns.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-data_source_exists-3F"> <span class="method-name">data_source_exists?</span><span class="method-args">(name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="data_source_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 46
def data_source_exists?(name)
  query_values(data_source_sql(name), "SCHEMA").any? if name.present?
rescue NotImplementedError
  data_sources.include?(name.to_s)
end</pre> </div> <p>Checks to see if the data source <code>name</code> exists on the database.</p> <pre class="ruby" data-language="ruby">data_source_exists?(:ebooks)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-data_sources"> <span class="method-name">data_sources</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="data_sources-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 36
def data_sources
  query_values(data_source_sql, "SCHEMA")
rescue NotImplementedError
  tables | views
end</pre> </div> <p>Returns the relation names useable to back Active Record models. For most adapters this means all <a href="schemastatements#method-i-tables">tables</a> and <a href="schemastatements#method-i-views">views</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-drop_join_table"> <span class="method-name">drop_join_table</span><span class="method-args">(table_1, table_2, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="drop_join_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 394
def drop_join_table(table_1, table_2, options = {})
  join_table_name = find_join_table_name(table_1, table_2, options)
  drop_table(join_table_name)
end</pre> </div> <p>Drops the join table specified by the given arguments. See <a href="schemastatements#method-i-create_join_table">create_join_table</a> for details.</p> <p>Although this command ignores the block if one is given, it can be helpful to provide one in a migration's <code>change</code> method so it can be reverted. In that case, the block will be used by <a href="schemastatements#method-i-create_join_table">create_join_table</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-drop_table"> <span class="method-name">drop_table</span><span class="method-args">(table_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="drop_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 501
def drop_table(table_name, options = {})
  execute "DROP TABLE#{' IF EXISTS' if options[:if_exists]} #{quote_table_name(table_name)}"
end</pre> </div> <p>Drops a table from the database.</p> <dl class="rdoc-list label-list">
<dt>
<code>:force</code> </dt>
<dd> <p>Set to <code>:cascade</code> to drop dependent objects as well. Defaults to false.</p> </dd>
<dt>
<code>:if_exists</code> </dt>
<dd> <p>Set to <code>true</code> to only drop the table if it exists. Defaults to false.</p> </dd>
</dl> <p>Although this command ignores most <code>options</code> and the block if one is given, it can be helpful to provide these in a migration's <code>change</code> method so it can be reverted. In that case, <code>options</code> and the block will be used by <a href="schemastatements#method-i-create_table">create_table</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-foreign_key_exists-3F"> <span class="method-name">foreign_key_exists?</span><span class="method-args">(from_table, to_table = nil, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="foreign_key_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1048
def foreign_key_exists?(from_table, to_table = nil, **options)
  foreign_key_for(from_table, to_table: to_table, **options).present?
end</pre> </div> <p>Checks to see if a foreign key exists on a table for a given foreign key definition.</p> <pre class="ruby" data-language="ruby"># Checks to see if a foreign key exists.
foreign_key_exists?(:accounts, :branches)

# Checks to see if a foreign key on a specified column exists.
foreign_key_exists?(:accounts, column: :owner_id)

# Checks to see if a foreign key with a custom name exists.
foreign_key_exists?(:accounts, name: "special_fk_name")
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-foreign_keys"> <span class="method-name">foreign_keys</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="foreign_keys-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 943
def foreign_keys(table_name)
  raise NotImplementedError, "foreign_keys is not implemented"
end</pre> </div> <p>Returns an array of foreign keys for the given table. The foreign keys are represented as ForeignKeyDefinition objects.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-index_exists-3F"> <span class="method-name">index_exists?</span><span class="method-args">(table_name, column_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="index_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 101
def index_exists?(table_name, column_name, options = {})
  column_names = Array(column_name).map(&amp;:to_s)
  checks = []
  checks &lt;&lt; lambda { |i| Array(i.columns) == column_names }
  checks &lt;&lt; lambda { |i| i.unique } if options[:unique]
  checks &lt;&lt; lambda { |i| i.name == options[:name].to_s } if options[:name]

  indexes(table_name).any? { |i| checks.all? { |check| check[i] } }
end</pre> </div> <p>Checks to see if an index exists on a table for a given index definition.</p> <pre class="ruby" data-language="ruby"># Check an index exists
index_exists?(:suppliers, :company_id)

# Check an index on multiple columns exists
index_exists?(:suppliers, [:company_id, :company_type])

# Check a unique index exists
index_exists?(:suppliers, :company_id, unique: true)

# Check an index with a custom name exists
index_exists?(:suppliers, :company_id, name: "idx_company_id")
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-index_name_exists-3F"> <span class="method-name">index_name_exists?</span><span class="method-args">(table_name, index_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="index_name_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 853
def index_name_exists?(table_name, index_name)
  index_name = index_name.to_s
  indexes(table_name).detect { |i| i.name == index_name }
end</pre> </div> <p>Verifies the existence of an index with a given name.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-indexes"> <span class="method-name">indexes</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="indexes-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 83
def indexes(table_name)
  raise NotImplementedError, "#indexes is not implemented"
end</pre> </div> <p>Returns an array of indexes for the given table.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-native_database_types"> <span class="method-name">native_database_types</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="native_database_types-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 16
def native_database_types
  {}
end</pre> </div> <p>Returns a hash of mappings from the abstract data types to the native database types. See <a href="tabledefinition#method-i-column">ActiveRecord::ConnectionAdapters::TableDefinition#column</a> for details on the recognized abstract data types.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-options_include_default-3F"> <span class="method-name">options_include_default?</span><span class="method-args">(options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="options_include_default-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1204
def options_include_default?(options)
  options.include?(:default) &amp;&amp; !(options[:null] == false &amp;&amp; options[:default].nil?)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-primary_key"> <span class="method-name">primary_key</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="primary_key-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 146
def primary_key(table_name)
  pk = primary_keys(table_name)
  pk = pk.first unless pk.size &gt; 1
  pk
end</pre> </div> <p>Returns just a table's primary key</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-remove_belongs_to"> <span class="method-name">remove_belongs_to</span><span class="method-args">(table_name, ref_name, foreign_key: false, polymorphic: false, **options)</span> </div>  <div class="aliases"> Alias for: <a href="schemastatements#method-i-remove_reference">remove_reference</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_column"> <span class="method-name">remove_column</span><span class="method-args">(table_name, column_name, type = nil, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_column-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 613
def remove_column(table_name, column_name, type = nil, options = {})
  execute "ALTER TABLE #{quote_table_name(table_name)} #{remove_column_for_alter(table_name, column_name, type, options)}"
end</pre> </div> <p>Removes the column from the table definition.</p> <pre class="ruby" data-language="ruby">remove_column(:suppliers, :qualification)
</pre> <p>The <code>type</code> and <code>options</code> parameters will be ignored if present. It can be helpful to provide these in a migration's <code>change</code> method so it can be reverted. In that case, <code>type</code> and <code>options</code> will be used by <a href="schemastatements#method-i-add_column">add_column</a>. Indexes on the column are automatically removed.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_columns"> <span class="method-name">remove_columns</span><span class="method-args">(table_name, *column_names)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_columns-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 598
def remove_columns(table_name, *column_names)
  raise ArgumentError.new("You must specify at least one column name. Example: remove_columns(:people, :first_name)") if column_names.empty?
  column_names.each do |column_name|
    remove_column(table_name, column_name)
  end
end</pre> </div> <p>Removes the given columns from the table definition.</p> <pre class="ruby" data-language="ruby">remove_columns(:suppliers, :qualification, :experience)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_foreign_key"> <span class="method-name">remove_foreign_key</span><span class="method-args">(from_table, to_table = nil, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_foreign_key-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1026
def remove_foreign_key(from_table, to_table = nil, **options)
  return unless supports_foreign_keys?

  fk_name_to_delete = foreign_key_for!(from_table, to_table: to_table, **options).name

  at = create_alter_table from_table
  at.drop_foreign_key fk_name_to_delete

  execute schema_creation.accept(at)
end</pre> </div> <p>Removes the given foreign key from the table. Any option parameters provided will be used to re-add the foreign key in case of a migration rollback. It is recommended that you provide any options used when creating the foreign key so that the migration can be reverted properly.</p> <p>Removes the foreign key on <code>accounts.branch_id</code>.</p> <pre class="ruby" data-language="ruby">remove_foreign_key :accounts, :branches
</pre> <p>Removes the foreign key on <code>accounts.owner_id</code>.</p> <pre class="ruby" data-language="ruby">remove_foreign_key :accounts, column: :owner_id
</pre> <p>Removes the foreign key on <code>accounts.owner_id</code>.</p> <pre class="ruby" data-language="ruby">remove_foreign_key :accounts, to_table: :owners
</pre> <p>Removes the foreign key named <code>special_fk_name</code> on the <code>accounts</code> table.</p> <pre class="ruby" data-language="ruby">remove_foreign_key :accounts, name: :special_fk_name
</pre> <p>The <code>options</code> hash accepts the same keys as <a href="schemastatements#method-i-add_foreign_key">#add_foreign_key</a> with an addition of</p> <dl class="rdoc-list label-list">
<dt>
<code>:to_table</code> </dt>
<dd> <p>The name of the table that contains the referenced primary key.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_index"> <span class="method-name">remove_index</span><span class="method-args">(table_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_index-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 817
def remove_index(table_name, options = {})
  index_name = index_name_for_remove(table_name, options)
  execute "DROP INDEX #{quote_column_name(index_name)} ON #{quote_table_name(table_name)}"
end</pre> </div> <p>Removes the given index from the table.</p> <p>Removes the index on <code>branch_id</code> in the <code>accounts</code> table if exactly one such index exists.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, :branch_id
</pre> <p>Removes the index on <code>branch_id</code> in the <code>accounts</code> table if exactly one such index exists.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, column: :branch_id
</pre> <p>Removes the index on <code>branch_id</code> and <code>party_id</code> in the <code>accounts</code> table if exactly one such index exists.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, column: [:branch_id, :party_id]
</pre> <p>Removes the index named <code>by_branch_party</code> in the <code>accounts</code> table.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, name: :by_branch_party
</pre> <p>Removes the index named <code>by_branch_party</code> in the <code>accounts</code> table <code>concurrently</code>.</p> <pre class="ruby" data-language="ruby">remove_index :accounts, name: :by_branch_party, algorithm: :concurrently
</pre> <p>Note: only supported by PostgreSQL.</p> <p>Concurrently removing an index is not supported in a transaction.</p> <p>For more information see the <a href="../migration">“Transactional Migrations” section</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_reference"> <span class="method-name">remove_reference</span><span class="method-args">(table_name, ref_name, foreign_key: false, polymorphic: false, **options)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_reference-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 924
def remove_reference(table_name, ref_name, foreign_key: false, polymorphic: false, **options)
  if foreign_key
    reference_name = Base.pluralize_table_names ? ref_name.to_s.pluralize : ref_name
    if foreign_key.is_a?(Hash)
      foreign_key_options = foreign_key
    else
      foreign_key_options = { to_table: reference_name }
    end
    foreign_key_options[:column] ||= "#{ref_name}_id"
    remove_foreign_key(table_name, foreign_key_options)
  end

  remove_column(table_name, "#{ref_name}_id")
  remove_column(table_name, "#{ref_name}_type") if polymorphic
end</pre> </div> <p>Removes the reference(s). Also removes a <code>type</code> column if one exists. <a href="schemastatements#method-i-remove_reference">remove_reference</a> and <a href="schemastatements#method-i-remove_belongs_to">remove_belongs_to</a> are acceptable.</p> <h6 id="method-i-remove_reference-label-Remove+the+reference">Remove the reference</h6> <pre class="ruby" data-language="ruby">remove_reference(:products, :user, index: false)
</pre> <h6 id="method-i-remove_reference-label-Remove+polymorphic+reference">Remove polymorphic reference</h6> <pre class="ruby" data-language="ruby">remove_reference(:products, :supplier, polymorphic: true)
</pre> <h6 id="method-i-remove_reference-label-Remove+the+reference+with+a+foreign+key">Remove the reference with a foreign key</h6> <pre class="ruby" data-language="ruby">remove_reference(:products, :user, foreign_key: true)
</pre>  </div> <div class="aliases"> Also aliased as: <a href="schemastatements#method-i-remove_belongs_to">remove_belongs_to</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_timestamps"> <span class="method-name">remove_timestamps</span><span class="method-args">(table_name, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_timestamps-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 1163
def remove_timestamps(table_name, options = {})
  remove_column table_name, :updated_at
  remove_column table_name, :created_at
end</pre> </div> <p>Removes the timestamp columns (<code>created_at</code> and <code>updated_at</code>) from the table definition.</p> <pre class="ruby" data-language="ruby">remove_timestamps(:suppliers)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rename_column"> <span class="method-name">rename_column</span><span class="method-args">(table_name, column_name, new_column_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rename_column-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 669
def rename_column(table_name, column_name, new_column_name)
  raise NotImplementedError, "rename_column is not implemented"
end</pre> </div> <p>Renames a column.</p> <pre class="ruby" data-language="ruby">rename_column(:suppliers, :description, :name)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rename_index"> <span class="method-name">rename_index</span><span class="method-args">(table_name, old_name, new_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rename_index-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 828
def rename_index(table_name, old_name, new_name)
  validate_index_length!(table_name, new_name)

  # this is a naive implementation; some DBs may support this more efficiently (PostgreSQL, for instance)
  old_index_def = indexes(table_name).detect { |i| i.name == old_name }
  return unless old_index_def
  add_index(table_name, old_index_def.columns, name: new_name, unique: old_index_def.unique)
  remove_index(table_name, name: old_name)
end</pre> </div> <p>Renames an index.</p> <p>Rename the <code>index_people_on_last_name</code> index to <code>index_users_on_last_name</code>:</p> <pre class="ruby" data-language="ruby">rename_index :people, 'index_people_on_last_name', 'index_users_on_last_name'
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rename_table"> <span class="method-name">rename_table</span><span class="method-args">(table_name, new_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rename_table-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 485
def rename_table(table_name, new_name)
  raise NotImplementedError, "rename_table is not implemented"
end</pre> </div> <p>Renames a table.</p> <pre class="ruby" data-language="ruby">rename_table('octopuses', 'octopi')
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-table_alias_for"> <span class="method-name">table_alias_for</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="table_alias_for-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 30
def table_alias_for(table_name)
  table_name[0...table_alias_length].tr(".", "_")
end</pre> </div> <p>Truncates a table alias according to the limits of the current adapter.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-table_comment"> <span class="method-name">table_comment</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="table_comment-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 25
def table_comment(table_name)
  nil
end</pre> </div> <p>Returns the table comment that's stored in database metadata.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-table_exists-3F"> <span class="method-name">table_exists?</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="table_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 61
def table_exists?(table_name)
  query_values(data_source_sql(table_name, type: "BASE TABLE"), "SCHEMA").any? if table_name.present?
rescue NotImplementedError
  tables.include?(table_name.to_s)
end</pre> </div> <p>Checks to see if the table <code>table_name</code> exists on the database.</p> <pre class="ruby" data-language="ruby">table_exists?(:developers)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-table_options"> <span class="method-name">table_options</span><span class="method-args">(table_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="table_options-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 20
def table_options(table_name)
  nil
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-tables"> <span class="method-name">tables</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="tables-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 53
def tables
  query_values(data_source_sql(type: "BASE TABLE"), "SCHEMA")
end</pre> </div> <p>Returns an array of table names defined in the database.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-view_exists-3F"> <span class="method-name">view_exists?</span><span class="method-args">(view_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="view_exists-3F-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 76
def view_exists?(view_name)
  query_values(data_source_sql(view_name, type: "VIEW"), "SCHEMA").any? if view_name.present?
rescue NotImplementedError
  views.include?(view_name.to_s)
end</pre> </div> <p>Checks to see if the view <code>view_name</code> exists on the database.</p> <pre class="ruby" data-language="ruby">view_exists?(:ebooks)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-views"> <span class="method-name">views</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="views-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/connection_adapters/abstract/schema_statements.rb, line 68
def views
  query_values(data_source_sql(type: "VIEW"), "SCHEMA")
end</pre> </div> <p>Returns an array of view names defined in the database.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2004–2019 David Heinemeier Hansson<br>Licensed under the MIT License.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
