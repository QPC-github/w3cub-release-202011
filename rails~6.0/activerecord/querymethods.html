
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>ActiveRecord&#58;&#58;QueryMethods - Ruby on Rails 6.0 - W3cubDocs</title>
  
  <meta name="description" content=" Adds an SQL comment to queries generated from this relation. For example&#58; ">
  <meta name="keywords" content="module, activerecord, querymethods, ruby, on, rails, rails~6.0">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rails~6.0/activerecord/querymethods.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/rails~6.0.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rails~6.0/" class="_nav-link" title="" style="margin-left:0;">Ruby on Rails 6.0</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="module-ActiveRecord::QueryMethods" class="module"> module ActiveRecord::QueryMethods </h1>  <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="DEFAULT_VALUES">DEFAULT_VALUES </dt>

<dt id="FROZEN_EMPTY_ARRAY">FROZEN_EMPTY_ARRAY </dt>

<dt id="FROZEN_EMPTY_HASH">FROZEN_EMPTY_HASH </dt>

<dt id="STRUCTURAL_OR_METHODS">STRUCTURAL_OR_METHODS </dt>

<dt id="VALID_UNSCOPING_VALUES">VALID_UNSCOPING_VALUES </dt>

</dl> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-annotate"> <span class="method-name">annotate</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="annotate-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 992
def annotate(*args)
  check_if_method_has_arguments!(:annotate, args)
  spawn.annotate!(*args)
end</pre> </div> <p>Adds an SQL comment to queries generated from this relation. For example:</p> <pre class="ruby" data-language="ruby">User.annotate("selecting user names").select(:name)
# SELECT "users"."name" FROM "users"    selecting user names

User.annotate("selecting", "user", "names").select(:name)
# SELECT "users"."name" FROM "users"    selecting    /* user */ /* names */
</pre> <p>The SQL block comment delimiters, “/*” and “*/”, will be added automatically.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_with"> <span class="method-name">create_with</span><span class="method-args">(value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="create_with-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 825
def create_with(value)
  spawn.create_with!(value)
end</pre> </div> <p>Sets attributes to be used when creating new records from a relation object.</p> <pre class="ruby" data-language="ruby">users = User.where(name: 'Oscar')
users.new.name # =&gt; 'Oscar'

users = users.create_with(name: 'DHH')
users.new.name # =&gt; 'DHH'
</pre> <p>You can pass <code>nil</code> to <a href="querymethods#method-i-create_with">create_with</a> to reset attributes:</p> <pre class="ruby" data-language="ruby">users = users.create_with(nil)
users.new.name # =&gt; 'Oscar'
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-distinct"> <span class="method-name">distinct</span><span class="method-args">(value = true)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="distinct-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 872
def distinct(value = true)
  spawn.distinct!(value)
end</pre> </div> <p>Specifies whether the records should be unique or not. For example:</p> <pre class="ruby" data-language="ruby">User.select(:name)
# Might return two records with the same name

User.select(:name).distinct
# Returns 1 record per distinct name

User.select(:name).distinct.distinct(false)
# You can also remove the uniqueness
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-eager_load"> <span class="method-name">eager_load</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="eager_load-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 154
def eager_load(*args)
  check_if_method_has_arguments!(:eager_load, args)
  spawn.eager_load!(*args)
end</pre> </div> <p>Forces eager loading by performing a LEFT OUTER JOIN on <code>args</code>:</p> <pre class="ruby" data-language="ruby">User.eager_load(:posts)
# SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, ...
# FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" =
# "users"."id"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-extending"> <span class="method-name">extending</span><span class="method-args">(*modules, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="extending-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 918
def extending(*modules, &amp;block)
  if modules.any? || block
    spawn.extending!(*modules, &amp;block)
  else
    self
  end
end</pre> </div> <p>Used to extend a scope with additional methods, either through a module or through a block provided.</p> <p>The object returned is a relation, which can be further extended.</p> <h3 id="method-i-extending-label-Using+a+module">Using a module</h3> <pre class="ruby" data-language="ruby">module Pagination
  def page(number)
    # pagination code goes here
  end
end

scope = Model.all.extending(Pagination)
scope.page(params[:page])
</pre> <p>You can also pass a list of modules:</p> <pre class="ruby" data-language="ruby">scope = Model.all.extending(Pagination, SomethingElse)
</pre> <h3 id="method-i-extending-label-Using+a+block">Using a block</h3> <pre class="ruby" data-language="ruby">scope = Model.all.extending do
  def page(number)
    # pagination code goes here
  end
end
scope.page(params[:page])
</pre> <p>You can also use a block and a module list:</p> <pre class="ruby" data-language="ruby">scope = Model.all.extending(Pagination) do
  def per_page(number)
    # pagination code goes here
  end
end
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-extract_associated"> <span class="method-name">extract_associated</span><span class="method-args">(association)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="extract_associated-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 187
def extract_associated(association)
  preload(association).collect(&amp;association)
end</pre> </div> <p>Extracts a named <code>association</code> from the relation. The named association is first preloaded, then the individual association records are collected from the relation. Like so:</p> <pre class="ruby" data-language="ruby">account.memberships.extract_associated(:user)
# =&gt; Returns collection of User records
</pre> <p>This is short-hand for:</p> <pre class="ruby" data-language="ruby">account.memberships.preload(:user).collect(&amp;:user)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-from"> <span class="method-name">from</span><span class="method-args">(value, subquery_name = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="from-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 853
def from(value, subquery_name = nil)
  spawn.from!(value, subquery_name)
end</pre> </div> <p>Specifies table from which the records will be fetched. For example:</p> <pre class="ruby" data-language="ruby">Topic.select('title').from('posts')
# SELECT title FROM posts
</pre> <p>Can accept other relation objects. For example:</p> <pre class="ruby" data-language="ruby">Topic.select('title').from(Topic.approved)
# SELECT title FROM (SELECT * FROM topics WHERE approved = 't') subquery

Topic.select('a.title').from(Topic.approved, :a)
# SELECT a.title FROM (SELECT * FROM topics WHERE approved = 't') a
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-group"> <span class="method-name">group</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="group-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 315
def group(*args)
  check_if_method_has_arguments!(:group, args)
  spawn.group!(*args)
end</pre> </div> <p>Allows to specify a group attribute:</p> <pre class="ruby" data-language="ruby">User.group(:name)
# SELECT "users".* FROM "users" GROUP BY name
</pre> <p>Returns an array with distinct records based on the <code>group</code> attribute:</p> <pre class="ruby" data-language="ruby">User.select([:id, :name])
# =&gt; [#&lt;User id: 1, name: "Oscar"&gt;, #&lt;User id: 2, name: "Oscar"&gt;, #&lt;User id: 3, name: "Foo"&gt;]

User.group(:name)
# =&gt; [#&lt;User id: 3, name: "Foo", ...&gt;, #&lt;User id: 2, name: "Oscar", ...&gt;]

User.group('name AS grouped_name, age')
# =&gt; [#&lt;User id: 3, name: "Foo", age: 21, ...&gt;, #&lt;User id: 2, name: "Oscar", age: 21, ...&gt;, #&lt;User id: 5, name: "Foo", age: 23, ...&gt;]
</pre> <p>Passing in an array of attributes to group by is also supported.</p> <pre class="ruby" data-language="ruby">User.select([:id, :first_name]).group(:id, :first_name).first(3)
# =&gt; [#&lt;User id: 1, first_name: "Bill"&gt;, #&lt;User id: 2, first_name: "Earl"&gt;, #&lt;User id: 3, first_name: "Beto"&gt;]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-having"> <span class="method-name">having</span><span class="method-args">(opts, *rest)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="having-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 702
def having(opts, *rest)
  opts.blank? ? self : spawn.having!(opts, *rest)
end</pre> </div> <p>Allows to specify a HAVING clause. Note that you can't use HAVING without also specifying a GROUP clause.</p> <pre class="ruby" data-language="ruby">Order.having('SUM(price) &gt; 30').group('user_id')
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-includes"> <span class="method-name">includes</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="includes-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 135
def includes(*args)
  check_if_method_has_arguments!(:includes, args)
  spawn.includes!(*args)
end</pre> </div> <p>Specify relationships to be included in the result set. For example:</p> <pre class="ruby" data-language="ruby">users = User.includes(:address)
users.each do |user|
  user.address.city
end
</pre> <p>allows you to access the <code>address</code> attribute of the <code>User</code> model without firing an additional query. This will often result in a performance improvement over a simple join.</p> <p>You can also specify multiple relationships, like this:</p> <pre class="ruby" data-language="ruby">users = User.includes(:address, :friends)
</pre> <p>Loading nested relationships is possible using a Hash:</p> <pre class="ruby" data-language="ruby">users = User.includes(:address, friends: [:address, :followers])
</pre> <h3 id="method-i-includes-label-conditions">conditions</h3> <p>If you want to add string conditions to your included models, you'll have to explicitly reference them. For example:</p> <pre class="ruby" data-language="ruby">User.includes(:posts).where('posts.name = ?', 'example')
</pre> <p>Will throw an error, but this will work:</p> <pre class="ruby" data-language="ruby">User.includes(:posts).where('posts.name = ?', 'example').references(:posts)
</pre> <p>Note that <a href="querymethods#method-i-includes">includes</a> works with association names while <a href="querymethods#method-i-references">references</a> needs the actual table name.</p> <p>If you pass the conditions via hash, you don't need to call <a href="querymethods#method-i-references">references</a> explicitly, as <a href="querymethods#method-i-where">where</a> references the tables for you. For example, this will work correctly:</p> <pre class="ruby" data-language="ruby">User.includes(:posts).where(posts: { name: 'example' })
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-joins"> <span class="method-name">joins</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="joins-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 483
def joins(*args)
  check_if_method_has_arguments!(:joins, args)
  spawn.joins!(*args)
end</pre> </div> <p>Performs a joins on <code>args</code>. The given symbol(s) should match the name of the association(s).</p> <pre class="ruby" data-language="ruby">User.joins(:posts)
# SELECT "users".*
# FROM "users"
# INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
</pre> <p>Multiple joins:</p> <pre class="ruby" data-language="ruby">User.joins(:posts, :account)
# SELECT "users".*
# FROM "users"
# INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
# INNER JOIN "accounts" ON "accounts"."id" = "users"."account_id"
</pre> <p>Nested joins:</p> <pre class="ruby" data-language="ruby">User.joins(posts: [:comments])
# SELECT "users".*
# FROM "users"
# INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
# INNER JOIN "comments" "comments_posts"
#   ON "comments_posts"."post_id" = "posts"."id"
</pre> <p>You can use strings in order to customize your joins:</p> <pre class="ruby" data-language="ruby">User.joins("LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id")
# SELECT "users".* FROM "users" LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-left_joins"> <span class="method-name">left_joins</span><span class="method-args">(*args)</span> </div>  <div class="aliases"> Alias for: <a href="querymethods#method-i-left_outer_joins">left_outer_joins</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-left_outer_joins"> <span class="method-name">left_outer_joins</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="left_outer_joins-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 500
def left_outer_joins(*args)
  check_if_method_has_arguments!(__callee__, args)
  spawn.left_outer_joins!(*args)
end</pre> </div> <p>Performs a left outer joins on <code>args</code>:</p> <pre>User.left_outer_joins(:posts)
=&gt; SELECT "users".* FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"</pre>  </div> <div class="aliases"> Also aliased as: <a href="querymethods#method-i-left_joins">left_joins</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-limit"> <span class="method-name">limit</span><span class="method-args">(value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="limit-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 719
def limit(value)
  spawn.limit!(value)
end</pre> </div> <p>Specifies a limit for the number of records to retrieve.</p> <pre class="ruby" data-language="ruby">User.limit(10) # generated SQL has 'LIMIT 10'

User.limit(10).limit(20) # generated SQL has 'LIMIT 20'
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lock"> <span class="method-name">lock</span><span class="method-args">(locks = true)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="lock-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 746
def lock(locks = true)
  spawn.lock!(locks)
end</pre> </div> <p>Specifies locking settings (default to <code>true</code>). For more information on locking, please see <span>ActiveRecord::Locking</span>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-none"> <span class="method-name">none</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="none-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 789
def none
  spawn.none!
end</pre> </div> <p>Returns a chainable relation with zero records.</p> <p>The returned relation implements the Null <a href="../object">Object</a> pattern. It is an object with defined null behavior and always returns an empty array of records without querying the database.</p> <p>Any subsequent condition chained to the returned relation will continue generating an empty relation and will not fire any query to the database.</p> <p>Used in cases where a method or scope could return zero records but the result needs to be chainable.</p> <p>For example:</p> <pre class="ruby" data-language="ruby">@posts = current_user.visible_posts.where(name: params[:name])
# the visible_posts method is expected to return a chainable Relation

def visible_posts
  case role
  when 'Country Manager'
    Post.where(country: country)
  when 'Reviewer'
    Post.published
  when 'Bad User'
    Post.none # It can't be chained if [] is returned.
  end
end
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-offset"> <span class="method-name">offset</span><span class="method-args">(value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="offset-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 735
def offset(value)
  spawn.offset!(value)
end</pre> </div> <p>Specifies the number of rows to skip before returning rows.</p> <pre class="ruby" data-language="ruby">User.offset(10) # generated SQL has "OFFSET 10"
</pre> <p>Should be used with order.</p> <pre class="ruby" data-language="ruby">User.offset(10).order("name ASC")
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-optimizer_hints"> <span class="method-name">optimizer_hints</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="optimizer_hints-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 947
def optimizer_hints(*args)
  check_if_method_has_arguments!(:optimizer_hints, args)
  spawn.optimizer_hints!(*args)
end</pre> </div> <p>Specify optimizer hints to be used in the SELECT statement.</p> <p>Example (for MySQL):</p> <pre class="ruby" data-language="ruby">Topic.optimizer_hints("MAX_EXECUTION_TIME(50000)", "NO_INDEX_MERGE(topics)")
# SELECT   + MAX_EXECUTION_TIME(50000) NO_INDEX_MERGE(topics)    `topics`.* FROM `topics`
</pre> <p>Example (for PostgreSQL with pg_hint_plan):</p> <pre class="ruby" data-language="ruby">Topic.optimizer_hints("SeqScan(topics)", "Parallel(topics 8)")
# SELECT   + SeqScan(topics) Parallel(topics 8)    "topics".* FROM "topics"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-or"> <span class="method-name">or</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="or-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 676
def or(other)
  unless other.is_a? Relation
    raise ArgumentError, "You have passed #{other.class.name} object to #or. Pass an ActiveRecord::Relation object instead."
  end

  spawn.or!(other)
end</pre> </div> <p>Returns a new relation, which is the logical union of this relation and the one passed as an argument.</p> <p>The two relations must be structurally compatible: they must be scoping the same model, and they must differ only by <a href="querymethods#method-i-where">where</a> (if no <a href="querymethods#method-i-group">group</a> has been defined) or <a href="querymethods#method-i-having">having</a> (if a <a href="querymethods#method-i-group">group</a> is present). Neither relation may have a <a href="querymethods#method-i-limit">limit</a>, <a href="querymethods#method-i-offset">offset</a>, or <a href="querymethods#method-i-distinct">distinct</a> set.</p> <pre class="ruby" data-language="ruby">Post.where("id = 1").or(Post.where("author_id = 3"))
# SELECT `posts`.* FROM `posts` WHERE ((id = 1) OR (author_id = 3))
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-order"> <span class="method-name">order</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="order-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 346
def order(*args)
  check_if_method_has_arguments!(:order, args)
  spawn.order!(*args)
end</pre> </div> <p>Allows to specify an order attribute:</p> <pre class="ruby" data-language="ruby">User.order(:name)
# SELECT "users".* FROM "users" ORDER BY "users"."name" ASC

User.order(email: :desc)
# SELECT "users".* FROM "users" ORDER BY "users"."email" DESC

User.order(:name, email: :desc)
# SELECT "users".* FROM "users" ORDER BY "users"."name" ASC, "users"."email" DESC

User.order('name')
# SELECT "users".* FROM "users" ORDER BY name

User.order('name DESC')
# SELECT "users".* FROM "users" ORDER BY name DESC

User.order('name DESC, email')
# SELECT "users".* FROM "users" ORDER BY name DESC, email
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-preload"> <span class="method-name">preload</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="preload-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 168
def preload(*args)
  check_if_method_has_arguments!(:preload, args)
  spawn.preload!(*args)
end</pre> </div> <p>Allows preloading of <code>args</code>, in the same way that <a href="querymethods#method-i-includes">includes</a> does:</p> <pre class="ruby" data-language="ruby">User.preload(:posts)
# SELECT "posts".* FROM "posts" WHERE "posts"."user_id" IN (1, 2, 3)
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-readonly"> <span class="method-name">readonly</span><span class="method-args">(value = true)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="readonly-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 803
def readonly(value = true)
  spawn.readonly!(value)
end</pre> </div> <p>Sets readonly attributes for the returned relation. If value is true (default), attempting to update a record will result in an error.</p> <pre>users = User.readonly
users.first.save
=&gt; ActiveRecord::ReadOnlyRecord: User is marked as readonly</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-references"> <span class="method-name">references</span><span class="method-args">(*table_names)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="references-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 201
def references(*table_names)
  check_if_method_has_arguments!(:references, table_names)
  spawn.references!(*table_names)
end</pre> </div> <p>Use to indicate that the given <code>table_names</code> are referenced by an SQL string, and should therefore be JOINed in any query rather than loaded separately. This method only works in conjunction with <a href="querymethods#method-i-includes">includes</a>. See <a href="querymethods#method-i-includes">includes</a> for more details.</p> <pre class="ruby" data-language="ruby">User.includes(:posts).where("posts.name = 'foo'")
# Doesn't JOIN the posts table, resulting in an error.

User.includes(:posts).where("posts.name = 'foo'").references(:posts)
# Query now knows the string references posts, so adds a JOIN
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reorder"> <span class="method-name">reorder</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="reorder-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 368
def reorder(*args)
  check_if_method_has_arguments!(:reorder, args)
  spawn.reorder!(*args)
end</pre> </div> <p>Replaces any existing order defined on the relation with the specified order.</p> <pre class="ruby" data-language="ruby">User.order('email DESC').reorder('id ASC') # generated SQL has 'ORDER BY id ASC'
</pre> <p>Subsequent calls to order on the same relation will be appended. For example:</p> <pre class="ruby" data-language="ruby">User.order('email DESC').reorder('id ASC').order('name ASC')
</pre> <p>generates a query with 'ORDER BY id ASC, name ASC'.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reselect"> <span class="method-name">reselect</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="reselect-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 284
def reselect(*args)
  check_if_method_has_arguments!(:reselect, args)
  spawn.reselect!(*args)
end</pre> </div> <p>Allows you to change a previously set select statement.</p> <pre class="ruby" data-language="ruby">Post.select(:title, :body)
# SELECT `posts`.`title`, `posts`.`body` FROM `posts`

Post.select(:title, :body).reselect(:created_at)
# SELECT `posts`.`created_at` FROM `posts`
</pre> <p>This is short-hand for <code>unscope(:select).select(fields)</code>. Note that we're unscoping the entire select statement.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reverse_order"> <span class="method-name">reverse_order</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="reverse_order-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 962
def reverse_order
  spawn.reverse_order!
end</pre> </div> <p>Reverse the existing order clause on the relation.</p> <pre class="ruby" data-language="ruby">User.order('name ASC').reverse_order # generated SQL has 'ORDER BY name DESC'
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rewhere"> <span class="method-name">rewhere</span><span class="method-args">(conditions)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rewhere-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 662
def rewhere(conditions)
  unscope(where: conditions.keys).where(conditions)
end</pre> </div> <p>Allows you to change a previously set where condition for a given attribute, instead of appending to that condition.</p> <pre class="ruby" data-language="ruby">Post.where(trashed: true).where(trashed: false)
# WHERE `trashed` = 1 AND `trashed` = 0

Post.where(trashed: true).rewhere(trashed: false)
# WHERE `trashed` = 0

Post.where(active: true).where(trashed: true).rewhere(trashed: false)
# WHERE `active` = 1 AND `trashed` = 0
</pre> <p>This is short-hand for <code>unscope(where:
conditions.keys).where(conditions)</code>. Note that unlike reorder, we're only unscoping the named conditions – not the entire where statement.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-select"> <span class="method-name">select</span><span class="method-args">(*fields)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="select-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 254
def select(*fields)
  if block_given?
    if fields.any?
      raise ArgumentError, "`select' with block doesn't take arguments."
    end

    return super()
  end

  raise ArgumentError, "Call `select' with at least one field" if fields.empty?
  spawn._select!(*fields)
end</pre> </div> <p>Works in two unique ways.</p> <p>First: takes a block so it can be used just like <code>Array#select</code>.</p> <pre class="ruby" data-language="ruby">Model.all.select { |m| m.field == value }
</pre> <p>This will build an array of objects from the database for the scope, converting them into an array and iterating through them using <code>Array#select</code>.</p> <p>Second: Modifies the SELECT statement for the query so that only certain fields are retrieved:</p> <pre class="ruby" data-language="ruby">Model.select(:field)
# =&gt; [#&lt;Model id: nil, field: "value"&gt;]
</pre> <p>Although in the above example it looks as though this method returns an array, it actually returns a relation object and can have other query methods appended to it, such as the other methods in <a href="querymethods">ActiveRecord::QueryMethods</a>.</p> <p>The argument to the method can also be an array of fields.</p> <pre class="ruby" data-language="ruby">Model.select(:field, :other_field, :and_one_more)
# =&gt; [#&lt;Model id: nil, field: "value", other_field: "value", and_one_more: "value"&gt;]
</pre> <p>You can also use one or more strings, which will be used unchanged as SELECT fields.</p> <pre class="ruby" data-language="ruby">Model.select('field AS field_one', 'other_field AS field_two')
# =&gt; [#&lt;Model id: nil, field: "value", other_field: "value"&gt;]
</pre> <p>If an alias was specified, it will be accessible from the resulting objects:</p> <pre class="ruby" data-language="ruby">Model.select('field AS field_one').first.field_one
# =&gt; "value"
</pre> <p>Accessing attributes of an object that do not have fields retrieved by a select except <code>id</code> will throw ActiveModel::MissingAttributeError:</p> <pre class="ruby" data-language="ruby">Model.select(:field).first.other_field
# =&gt; ActiveModel::MissingAttributeError: missing attribute: other_field
</pre> <div class="method-calls-super"> Calls superclass method </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-unscope"> <span class="method-name">unscope</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="unscope-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 419
def unscope(*args)
  check_if_method_has_arguments!(:unscope, args)
  spawn.unscope!(*args)
end</pre> </div> <p>Removes an unwanted relation that is already defined on a chain of relations. This is useful when passing around chains of relations and would like to modify the relations without reconstructing the entire chain.</p> <pre class="ruby" data-language="ruby">User.order('email DESC').unscope(:order) == User.all
</pre> <p>The method arguments are symbols which correspond to the names of the methods which should be unscoped. The valid arguments are given in <a href="querymethods#VALID_UNSCOPING_VALUES">VALID_UNSCOPING_VALUES</a>. The method can also be called with multiple arguments. For example:</p> <pre class="ruby" data-language="ruby">User.order('email DESC').select('id').where(name: "John")
    .unscope(:order, :select, :where) == User.all
</pre> <p>One can additionally pass a hash as an argument to unscope specific <code>:where</code> values. This is done by passing a hash with a single key-value pair. The key should be <code>:where</code> and the value should be the where value to unscope. For example:</p> <pre>User.where(name: "John", active: true).unscope(where: :name)
    == User.where(active: true)</pre> <p>This method is similar to except, but unlike except, it persists across merges:</p> <pre>User.order('email').merge(User.except(:order))
    == User.order('email')

User.order('email').merge(User.unscope(:order))
    == User.all</pre> <p>This means it can be used in association definitions:</p> <pre class="ruby" data-language="ruby">has_many :comments, -&gt; { unscope(where: :trashed) }
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-where"> <span class="method-name">where</span><span class="method-args">(opts = :chain, *rest)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="where-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/query_methods.rb, line 632
def where(opts = :chain, *rest)
  if :chain == opts
    WhereChain.new(spawn)
  elsif opts.blank?
    self
  else
    spawn.where!(opts, *rest)
  end
end</pre> </div> <p>Returns a new relation, which is the result of filtering the current relation according to the conditions in the arguments.</p> <p><a href="querymethods#method-i-where">where</a> accepts conditions in one of several formats. In the examples below, the resulting SQL is given as an illustration; the actual query generated may be different depending on the database adapter.</p> <h3 id="method-i-where-label-string">string</h3> <p>A single string, without additional arguments, is passed to the query constructor as an SQL fragment, and used in the where clause of the query.</p> <pre class="ruby" data-language="ruby">Client.where("orders_count = '2'")
# SELECT * from clients where orders_count = '2';
</pre> <p>Note that building your own string from user input may expose your application to injection attacks if not done properly. As an alternative, it is recommended to use one of the following methods.</p> <h3 id="method-i-where-label-array">array</h3> <p>If an array is passed, then the first element of the array is treated as a template, and the remaining elements are inserted into the template to generate the condition. Active Record takes care of building the query to avoid injection attacks, and will convert from the ruby type to the database type where needed. Elements are inserted into the string in the order in which they appear.</p> <pre class="ruby" data-language="ruby">User.where(["name = ? and email = ?", "Joe", "joe@example.com"])
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
</pre> <p>Alternatively, you can use named placeholders in the template, and pass a hash as the second element of the array. The names in the template are replaced with the corresponding values from the hash.</p> <pre class="ruby" data-language="ruby">User.where(["name = :name and email = :email", { name: "Joe", email: "joe@example.com" }])
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
</pre> <p>This can make for more readable code in complex queries.</p> <p>Lastly, you can use sprintf-style % escapes in the template. This works slightly differently than the previous methods; you are responsible for ensuring that the values in the template are properly quoted. The values are passed to the connector for quoting, but the caller is responsible for ensuring they are enclosed in quotes in the resulting SQL. After quoting, the values are inserted using the same escapes as the Ruby core method <code>Kernel::sprintf</code>.</p> <pre class="ruby" data-language="ruby">User.where(["name = '%s' and email = '%s'", "Joe", "joe@example.com"])
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
</pre> <p>If <a href="querymethods#method-i-where">where</a> is called with multiple arguments, these are treated as if they were passed as the elements of a single array.</p> <pre class="ruby" data-language="ruby">User.where("name = :name and email = :email", { name: "Joe", email: "joe@example.com" })
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
</pre> <p>When using strings to specify conditions, you can use any operator available from the database. While this provides the most flexibility, you can also unintentionally introduce dependencies on the underlying database. If your code is intended for general consumption, test with multiple database backends.</p> <h3 id="method-i-where-label-hash">hash</h3> <p><a href="querymethods#method-i-where">where</a> will also accept a hash condition, in which the keys are fields and the values are values to be searched for.</p> <p>Fields can be symbols or strings. Values can be single values, arrays, or ranges.</p> <pre class="ruby" data-language="ruby">User.where({ name: "Joe", email: "joe@example.com" })
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com'

User.where({ name: ["Alice", "Bob"]})
# SELECT * FROM users WHERE name IN ('Alice', 'Bob')

User.where({ created_at: (Time.now.midnight - 1.day)..Time.now.midnight })
# SELECT * FROM users WHERE (created_at BETWEEN '2012-06-09 07:00:00.000000' AND '2012-06-10 07:00:00.000000')
</pre> <p>In the case of a belongs_to relationship, an association key can be used to specify the model if an <a href="../activerecord">ActiveRecord</a> object is used as the value.</p> <pre class="ruby" data-language="ruby">author = Author.find(1)

# The following queries will be equivalent:
Post.where(author: author)
Post.where(author_id: author)
</pre> <p>This also works with polymorphic belongs_to relationships:</p> <pre class="ruby" data-language="ruby">treasure = Treasure.create(name: 'gold coins')
treasure.price_estimates &lt;&lt; PriceEstimate.create(price: 125)

# The following queries will be equivalent:
PriceEstimate.where(estimate_of: treasure)
PriceEstimate.where(estimate_of_type: 'Treasure', estimate_of_id: treasure)
</pre> <h3 id="method-i-where-label-Joins">Joins</h3> <p>If the relation is the result of a join, you may create a condition which uses any of the tables in the join. For string and array conditions, use the table name in the condition.</p> <pre class="ruby" data-language="ruby">User.joins(:posts).where("posts.created_at &lt; ?", Time.now)
</pre> <p>For hash conditions, you can either use the table name in the key, or use a sub-hash.</p> <pre class="ruby" data-language="ruby">User.joins(:posts).where({ "posts.published" =&gt; true })
User.joins(:posts).where({ posts: { published: true } })
</pre> <h3 id="method-i-where-label-no+argument">no argument</h3> <p>If no argument is passed, <a href="querymethods#method-i-where">where</a> returns a new instance of <a href="querymethods/wherechain">WhereChain</a>, that can be chained with not to return a new relation that negates the where clause.</p> <pre class="ruby" data-language="ruby">User.where.not(name: "Jon")
# SELECT * FROM users WHERE name != 'Jon'
</pre> <p>See <a href="querymethods/wherechain">WhereChain</a> for more details on not.</p> <h3 id="method-i-where-label-blank+condition">blank condition</h3> <p>If the condition is any blank-ish object, then <a href="querymethods#method-i-where">where</a> is a no-op and returns the current relation.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2004–2019 David Heinemeier Hansson<br>Licensed under the MIT License.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
