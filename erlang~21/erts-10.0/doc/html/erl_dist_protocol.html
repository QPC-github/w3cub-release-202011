
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>13. Distribution Protocol - Erlang 21 - W3cubDocs</title>
  
  <meta name="description" content="This description is far from complete. It will be updated if the protocol is updated. However, the protocols, both from Erlang nodes to the Erlang &hellip;">
  <meta name="keywords" content="distribution, protocol, erlang, erlang~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/erlang~21/erts-10.0/doc/html/erl_dist_protocol.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/erlang~21.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~21/" class="_nav-link" title="" style="margin-left:0;">Erlang 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _erlang">
				
				
<h1>13 Distribution Protocol</h1> <p>This description is far from complete. It will be updated if the protocol is updated. However, the protocols, both from Erlang nodes to the Erlang Port Mapper Daemon (EPMD) and between Erlang nodes are stable since many years.</p> <p>The distribution protocol can be divided into four parts:</p> <ul> <li> <p>Low-level socket connection (1)</p> </li> <li> <p>Handshake, interchange node name, and authenticate (2)</p> </li> <li> <p>Authentication (done by <code><span class="code">net_kernel(3)</span></code>) (3)</p> </li> <li> <p>Connected (4)</p> </li> </ul> <p>A node fetches the port number of another node through the EPMD (at the other host) to initiate a connection request.</p> <p>For each host, where a distributed Erlang node is running, also an EPMD is to be running. The EPMD can be started explicitly or automatically as a result of the Erlang node startup.</p> <p>By default the EPMD listens on port 4369.</p> <p>(3) and (4) above are performed at the same level but the <code class="code">net_kernel</code> disconnects the other node if it communicates using an invalid cookie (after 1 second).</p> <p>The integers in all multibyte fields are in big-endian order.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p> The Erlang Distribution protocol is not by itself secure and does not aim to be so. In order to get secure distribution the distributed nodes should be configured to use distribution over tls. See the <code>Using SSL for Erlang Distribution</code> User's Guide for details on how to setup a secure distributed node. </p> </div> </div> <h2><span onmouseover="document.getElementById('ghlink-epmd-protocol-id109894').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-epmd-protocol-id109894').style.visibility = 'hidden';" id="epmd-protocol">13.1 EPMD Protocol</span></h2> <p>The requests served by the EPMD are summarized in the following figure.</p> <div class="doc-image-wrapper">  <p class="doc-image-caption">Figure 13.1: Summary of EPMD Requests</p> </div> <p>Each request <code class="code">*_REQ</code> is preceded by a 2 byte length field. Thus, the overall request format is as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>2</td> <td>n</td> </tr> <tr> <td><code class="code">Length</code></td> <td><code class="code">Request</code></td> </tr> </table> <p class="doc-table-caption">Table 13.1: Request Format</p> </div> <h4><span onmouseover="document.getElementById('ghlink-register-a-node-in-epmd-id109977').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-register-a-node-in-epmd-id109977').style.visibility = 'hidden';" id="register-a-node-in-epmd">Register a Node in EPMD</span></h4> <p>When a distributed node is started it registers itself in the EPMD. The message <code class="code">ALIVE2_REQ</code> described below is sent from the node to the EPMD. The response from the EPMD is <code class="code">ALIVE2_RESP</code>.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>2</td> <td>1</td> <td>1</td> <td>2</td> <td>2</td> <td>2</td> <td>Nlen</td> <td>2</td> <td>Elen</td> </tr> <tr> <td><code class="code">120</code></td> <td><code class="code">PortNo</code></td> <td><code class="code">NodeType</code></td> <td><code class="code">Protocol</code></td> <td><code class="code">HighestVersion</code></td> <td><code class="code">LowestVersion</code></td> <td><code class="code">Nlen</code></td> <td><code class="code">NodeName</code></td> <td><code class="code">Elen</code></td> <td><code class="code">Extra</code></td> </tr> </table> <p class="doc-table-caption">Table 13.2: ALIVE2_REQ (120)</p> </div> <dl> <dt><strong><code class="code">PortNo</code></strong></dt> <dd> <p>The port number on which the node accept connection requests.</p> </dd> <dt><strong><code class="code">NodeType</code></strong></dt> <dd> <p>77 = normal Erlang node, 72 = hidden node (C-node), ...</p> </dd> <dt><strong><code class="code">Protocol</code></strong></dt> <dd> <p>0 = TCP/IPv4, ...</p> </dd> <dt><strong><code class="code">HighestVersion</code></strong></dt> <dd> <p>The highest distribution version that this node can handle. The value in Erlang/OTP R6B and later is 5.</p> </dd> <dt><strong><code class="code">LowestVersion</code></strong></dt> <dd> <p>The lowest distribution version that this node can handle. The value in Erlang/OTP R6B and later is 5.</p> </dd> <dt><strong><code class="code">Nlen</code></strong></dt> <dd> <p>The length (in bytes) of field <code class="code">NodeName</code>.</p> </dd> <dt><strong><code class="code">NodeName</code></strong></dt> <dd> <p>The node name as an UTF-8 encoded string of <code class="code">Nlen</code> bytes.</p> </dd> <dt><strong><code class="code">Elen</code></strong></dt> <dd> <p>The length of field <code class="code">Extra</code>.</p> </dd> <dt><strong><code class="code">Extra</code></strong></dt> <dd> <p>Extra field of <code class="code">Elen</code> bytes.</p> </dd> </dl> <p>The connection created to the EPMD must be kept as long as the node is a distributed node. When the connection is closed, the node is automatically unregistered from the EPMD.</p> <p>The response message <code class="code">ALIVE2_RESP</code> is as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>2</td> </tr> <tr> <td><code class="code">121</code></td> <td><code class="code">Result</code></td> <td><code class="code">Creation</code></td> </tr> </table> <p class="doc-table-caption">Table 13.3: ALIVE2_RESP (121)</p> </div> <p>Result = 0 -&gt; ok, result &gt; 0 -&gt; error.</p> <h4><span onmouseover="document.getElementById('ghlink-unregister-a-node-from-epmd-id110411').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-unregister-a-node-from-epmd-id110411').style.visibility = 'hidden';" id="unregister-a-node-from-epmd">Unregister a Node from EPMD</span></h4> <p>A node unregisters itself from the EPMD by closing the TCP connection to EPMD established when the node was registered.</p> <h4><span onmouseover="document.getElementById('ghlink-get-the-distribution-port-of-another-node-id110426').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-get-the-distribution-port-of-another-node-id110426').style.visibility = 'hidden';" id="get-the-distribution-port-of-another-node">Get the Distribution Port of Another Node</span></h4> <p>When one node wants to connect to another node it starts with a <code class="code">PORT_PLEASE2_REQ</code> request to the EPMD on the host where the node resides to get the distribution port that the node listens to.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>N</td> </tr> <tr> <td><code class="code">122</code></td> <td><code class="code">NodeName</code></td> </tr> </table> <p class="doc-table-caption">Table 13.4: PORT_PLEASE2_REQ (122)</p> </div> <p>where N = <code class="code">Length</code> - 1.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> </tr> <tr> <td><code class="code">119</code></td> <td><code class="code">Result</code></td> </tr> </table> <p class="doc-table-caption">Table 13.5: PORT2_RESP (119) Response Indicating Error, Result &gt; 0 </p> </div> <p>or</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>1</td> <td>2</td> <td>1</td> <td>1</td> <td>2</td> <td>2</td> <td>2</td> <td>Nlen</td> <td>2</td> <td>Elen</td> </tr> <tr> <td><code class="code">119</code></td> <td><code class="code">Result</code></td> <td><code class="code">PortNo</code></td> <td><code class="code">NodeType</code></td> <td><code class="code">Protocol</code></td> <td><code class="code">HighestVersion</code></td> <td><code class="code">LowestVersion</code></td> <td><code class="code">Nlen</code></td> <td><code class="code">NodeName</code></td> <td><code class="code">Elen</code></td> <td>&gt;<code class="code">Extra</code> </td> </tr> </table> <p class="doc-table-caption">Table 13.6: PORT2_RESP, Result = 0</p> </div> <p>If <code class="code">Result</code> &gt; 0, the packet only consists of <code class="code">[119, Result]</code>.</p> <p>The EPMD closes the socket when it has sent the information.</p> <h4><span onmouseover="document.getElementById('ghlink-get-all-registered-names-from-epmd-id110789').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-get-all-registered-names-from-epmd-id110789').style.visibility = 'hidden';" id="get-all-registered-names-from-epmd">Get All Registered Names from EPMD</span></h4> <p>This request is used through the Erlang function <code><span class="code">net_adm:names/1,2</span></code>. A TCP connection is opened to the EPMD and this request is sent.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> </tr> <tr> <td><code class="code">110</code></td> </tr> </table> <p class="doc-table-caption">Table 13.7: NAMES_REQ (110)</p> </div> <p>The response for a <code class="code">NAMES_REQ</code> is as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>4</td> <td> </td> </tr> <tr> <td><code class="code">EPMDPortNo</code></td> <td><code class="code">NodeInfo*</code></td> </tr> </table> <p class="doc-table-caption">Table 13.8: NAMES_RESP</p> </div> <p><code class="code">NodeInfo</code> is a string written for each active node. When all <code class="code">NodeInfo</code> has been written the connection is closed by the EPMD.</p> <p><code class="code">NodeInfo</code> is, as expressed in Erlang:</p> <pre data-language="erlang">io:format("name ~ts at port ~p~n", [NodeName, Port]).</pre> <h4><span onmouseover="document.getElementById('ghlink-dump-all-data-from-epmd-id110931').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-dump-all-data-from-epmd-id110931').style.visibility = 'hidden';" id="dump-all-data-from-epmd">Dump All Data from EPMD</span></h4> <p>This request is not really used, it is to be regarded as a debug feature.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> </tr> <tr> <td><code class="code">100</code></td> </tr> </table> <p class="doc-table-caption">Table 13.9: DUMP_REQ</p> </div> <p>The response for a <code class="code">DUMP_REQ</code> is as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>4</td> <td> </td> </tr> <tr> <td><code class="code">EPMDPortNo</code></td> <td><code class="code">NodeInfo*</code></td> </tr> </table> <p class="doc-table-caption">Table 13.10: DUMP_RESP</p> </div> <p><code class="code">NodeInfo</code> is a string written for each node kept in the EPMD. When all <code class="code">NodeInfo</code> has been written the connection is closed by the EPMD.</p> <p><code class="code">NodeInfo</code> is, as expressed in Erlang:</p> <pre data-language="erlang">io:format("active name     ~ts at port ~p, fd = ~p~n",
          [NodeName, Port, Fd]).</pre> <p>or</p> <pre data-language="erlang">io:format("old/unused name ~ts at port ~p, fd = ~p ~n",
          [NodeName, Port, Fd]).</pre> <h4><span onmouseover="document.getElementById('ghlink-kill-epmd-id111074').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-kill-epmd-id111074').style.visibility = 'hidden';" id="kill-epmd">Kill EPMD</span></h4> <p>This request kills the running EPMD. It is almost never used.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> </tr> <tr> <td><code class="code">107</code></td> </tr> </table> <p class="doc-table-caption">Table 13.11: KILL_REQ</p> </div> <p>The response for a <code class="code">KILL_REQ</code> is as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>2</td> </tr> <tr> <td><code class="code">OKString</code></td> </tr> </table> <p class="doc-table-caption">Table 13.12: KILL_RESP</p> </div> <p>where <code class="code">OKString</code> is "OK".</p> <h4><span onmouseover="document.getElementById('ghlink-stop_req---not-used--id111172').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-stop_req---not-used--id111172').style.visibility = 'hidden';" id="stop_req---not-used-">STOP_REQ (Not Used)</span></h4> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>1</td> <td>n</td> </tr> <tr> <td><code class="code">115</code></td> <td><code class="code">NodeName</code></td> </tr> </table> <p class="doc-table-caption">Table 13.13: STOP_REQ</p> </div> <p>where n = <code class="code">Length</code> - 1.</p> <p>The current implementation of Erlang does not care if the connection to the EPMD is broken.</p> <p>The response for a <code class="code">STOP_REQ</code> is as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>7</td> </tr> <tr> <td><code class="code">OKString</code></td> </tr> </table> <p class="doc-table-caption">Table 13.14: STOP_RESP</p> </div> <p>where <code class="code">OKString</code> is "STOPPED".</p> <p>A negative response can look as follows:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>7</td> </tr> <tr> <td><code class="code">NOKString</code></td> </tr> </table> <p class="doc-table-caption">Table 13.15: STOP_NOTOK_RESP</p> </div> <p>where <code class="code">NOKString</code> is "NOEXIST".</p> <h2> <span onmouseover="document.getElementById('ghlink-distribution-handshake-id111367').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-distribution-handshake-id111367').style.visibility = 'hidden';" id="distribution_handshake">13.2 Distribution Handshake</span> </h2> <p>This section describes the distribution handshake protocol introduced in Erlang/OTP R6. This description was previously located in <code class="code">$ERL_TOP/lib/kernel/internal_doc/distribution_handshake.txt</code> and has more or less been copied and "formatted" here. It has been almost unchanged since 1999, but the handshake has not changed much since then either.</p> <h4><span onmouseover="document.getElementById('ghlink-general-id111390').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-general-id111390').style.visibility = 'hidden';" id="general">General</span></h4> <p>The TCP/IP distribution uses a handshake that expects a connection-based protocol, that is, the protocol does not include any authentication after the handshake procedure.</p> <p>This is not entirely safe, as it is vulnerable against takeover attacks, but it is a tradeoff between fair safety and performance.</p> <p>The cookies are never sent in cleartext and the handshake procedure expects the client (called <code class="code">A</code>) to be the first one to prove that it can generate a sufficient digest. The digest is generated with the MD5 message digest algorithm and the challenges are expected to be random numbers.</p> <h4><span onmouseover="document.getElementById('ghlink-definitions-id111420').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-definitions-id111420').style.visibility = 'hidden';" id="definitions">Definitions</span></h4> <p>A challenge is a 32-bit integer in big-endian order. Below the function <code class="code">gen_challenge()</code> returns a random 32-bit integer used as a challenge.</p> <p>A digest is a (16 bytes) MD5 hash of the challenge (as text) concatenated with the cookie (as text). Below, the function <code class="code">gen_digest(Challenge, Cookie)</code> generates a digest as described above.</p> <p>An <code class="code">out_cookie</code> is the cookie used in outgoing communication to a certain node, so that <code class="code">A</code>'s <code class="code">out_cookie</code> for <code class="code">B</code> is to correspond with <code class="code">B</code>'s <code class="code">in_cookie</code> for <code class="code">A</code> and conversely. <code class="code">A</code>'s <code class="code">out_cookie</code> for <code class="code">B</code> and <code class="code">A</code>'s <code class="code">in_cookie</code> for <code class="code">B</code> need <strong>not</strong> be the same. Below the function <code class="code">out_cookie(Node)</code> returns the current node's <code class="code">out_cookie</code> for <code class="code">Node</code>.</p> <p>An <code class="code">in_cookie</code> is the cookie expected to be used by another node when communicating with us, so that <code class="code">A</code>'s <code class="code">in_cookie</code> for <code class="code">B</code> corresponds with <code class="code">B</code>'s <code class="code">out_cookie</code> for <code class="code">A</code>. Below the function <code class="code">in_cookie(Node)</code> returns the current node's <code class="code">in_cookie</code> for <code class="code">Node</code>.</p> <p>The cookies are text strings that can be viewed as passwords.</p> <p>Every message in the handshake starts with a 16-bit big-endian integer, which contains the message length (not counting the two initial bytes). In Erlang this corresponds to option <code class="code">{packet, 2}</code> in <code><span class="code">gen_tcp(3)</span></code>. Notice that after the handshake, the distribution switches to 4 byte packet headers.</p> <h4><span onmouseover="document.getElementById('ghlink-the-handshake-in-detail-id111579').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-the-handshake-in-detail-id111579').style.visibility = 'hidden';" id="the-handshake-in-detail">The Handshake in Detail</span></h4> <p>Imagine two nodes, <code class="code">A</code> that initiates the handshake and <code class="code">B</code> that accepts the connection.</p> <dl> <dt><strong>1) connect/accept</strong></dt> <dd> <p><code class="code">A</code> connects to <code class="code">B</code> through TCP/IP and <code class="code">B</code> accepts the connection.</p> </dd> <dt><strong>2) <code class="code">send_name</code>/<code class="code">receive_name</code></strong></dt> <dd> <p><code class="code">A</code> sends an initial identification to <code class="code">B</code>, which receives the message. The message looks as follows (every "square" is one byte and the packet header is removed):</p> <pre data-language="erlang">
+---+--------+--------+-----+-----+-----+-----+-----+-----+-...-+-----+
|'n'|Version0|Version1|Flag0|Flag1|Flag2|Flag3|Name0|Name1| ... |NameN|
+---+--------+--------+-----+-----+-----+-----+-----+-----+-... +-----+</pre> <p>'n' is the message tag. 'Version0' and 'Version1' is the distribution version selected by <code class="code">A</code>, based on information from the EPMD. (16-bit big-endian) 'Flag0' ... 'Flag3' are capability flags, the capabilities are defined in <code class="code">$ERL_TOP/lib/kernel/include/dist.hrl</code>. (32-bit big-endian) 'Name0' ... 'NameN' is the full node name of <code class="code">A</code>, as a string of bytes (the packet length denotes how long it is).</p> </dd> <dt><strong>3) <code class="code">recv_status</code>/<code class="code">send_status</code></strong></dt> <dd> <p><code class="code">B</code> sends a status message to <code class="code">A</code>, which indicates if the connection is allowed. The following status codes are defined:</p> <dl> <dt><strong><code class="code">ok</code></strong></dt> <dd> <p>The handshake will continue.</p> </dd> <dt><strong><code class="code">ok_simultaneous</code></strong></dt> <dd> <p>The handshake will continue, but <code class="code">A</code> is informed that <code class="code">B</code> has another ongoing connection attempt that will be shut down (simultaneous connect where <code class="code">A</code>'s name is greater than <code class="code">B</code>'s name, compared literally).</p> </dd> <dt><strong><code class="code">nok</code></strong></dt> <dd> <p>The handshake will not continue, as <code class="code">B</code> already has an ongoing handshake, which it itself has initiated (simultaneous connect where <code class="code">B</code>'s name is greater than <code class="code">A</code>'s).</p> </dd> <dt><strong><code class="code">not_allowed</code></strong></dt> <dd> <p>The connection is disallowed for some (unspecified) security reason.</p> </dd> <dt><strong><code class="code">alive</code></strong></dt> <dd> <p>A connection to the node is already active, which either means that node <code class="code">A</code> is confused or that the TCP connection breakdown of a previous node with this name has not yet reached node <code class="code">B</code>. See step 3B below.</p> </dd> </dl> <p>The format of the status message is as follows:</p> <pre data-language="erlang">
+---+-------+-------+-...-+-------+
|'s'|Status0|Status1| ... |StatusN|
+---+-------+-------+-...-+-------+</pre> <p>'s' is the message tag. 'Status0' ... 'StatusN' is the status as a string (not terminated).</p> </dd> <dt><strong>3B) <code class="code">send_status</code>/<code class="code">recv_status</code></strong></dt> <dd> <p>If status was <code class="code">alive</code>, node <code class="code">A</code> answers with another status message containing either <code class="code">true</code>, which means that the connection is to continue (the old connection from this node is broken), or <code class="code">false</code>, which means that the connection is to be closed (the connection attempt was a mistake.</p> </dd> <dt><strong>4) <code class="code">recv_challenge</code>/<code class="code">send_challenge</code></strong></dt> <dd> <p>If the status was <code class="code">ok</code> or <code class="code">ok_simultaneous</code>, the handshake continues with <code class="code">B</code> sending <code class="code">A</code> another message, the challenge. The challenge contains the same type of information as the "name" message initially sent from <code class="code">A</code> to <code class="code">B</code>, plus a 32-bit challenge:</p> <pre data-language="erlang">
+---+--------+--------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-...-+-----+
|'n'|Version0|Version1|Flag0|Flag1|Flag2|Flag3|Chal0|Chal1|Chal2|Chal3|Name0|Name1| ... |NameN|
+---+--------+--------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-... +-----+</pre> <p>'Chal0' ... 'Chal3' is the challenge as a 32-bit big-endian integer and the other fields are <code class="code">B</code>'s version, flags, and full node name.</p> </dd> <dt><strong>5) <code class="code">send_challenge_reply</code>/<code class="code">recv_challenge_reply</code></strong></dt> <dd> <p>Now <code class="code">A</code> has generated a digest and its own challenge. Those are sent together in a package to <code class="code">B</code>:</p> <pre data-language="erlang">
+---+-----+-----+-----+-----+-----+-----+-----+-----+-...-+------+
|'r'|Chal0|Chal1|Chal2|Chal3|Dige0|Dige1|Dige2|Dige3| ... |Dige15|
+---+-----+-----+-----+-----+-----+-----+-----+-----+-...-+------+</pre> <p>'r' is the tag. 'Chal0' ... 'Chal3' is <code class="code">A</code>'s challenge for <code class="code">B</code> to handle. 'Dige0' ... 'Dige15' is the digest that <code class="code">A</code> constructed from the challenge <code class="code">B</code> sent in the previous step.</p> </dd> <dt><strong>6) <code class="code">recv_challenge_ack</code>/<code class="code">send_challenge_ack</code></strong></dt> <dd> <p><code class="code">B</code> checks that the digest received from <code class="code">A</code> is correct and generates a digest from the challenge received from <code class="code">A</code>. The digest is then sent to <code class="code">A</code>. The message is as follows:</p> <pre data-language="erlang">
+---+-----+-----+-----+-----+-...-+------+
|'a'|Dige0|Dige1|Dige2|Dige3| ... |Dige15|
+---+-----+-----+-----+-----+-...-+------+</pre> <p>'a' is the tag. 'Dige0' ... 'Dige15' is the digest calculated by <code class="code">B</code> for <code class="code">A</code>'s challenge.</p> </dd> <dt><strong>7) check</strong></dt> <dd> <p><code class="code">A</code> checks the digest from <code class="code">B</code> and the connection is up.</p> </dd> </dl> <h4><span onmouseover="document.getElementById('ghlink-semigraphic-view-id112021').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-semigraphic-view-id112021').style.visibility = 'hidden';" id="semigraphic-view">Semigraphic View</span></h4> <pre data-language="erlang">
A (initiator)                                      B (acceptor)

TCP connect ------------------------------------&gt;
                                                   TCP accept

send_name --------------------------------------&gt;
                                                   recv_name

  &lt;---------------------------------------------- send_status
recv_status
(if status was 'alive'
 send_status - - - - - - - - - - - - - - - - - -&gt;
                                                   recv_status)
                                                   ChB = gen_challenge()
                          (ChB)
  &lt;---------------------------------------------- send_challenge
recv_challenge
ChA = gen_challenge(),
OCA = out_cookie(B),
DiA = gen_digest(ChB, OCA)
                          (ChA, DiA)
send_challenge_reply ---------------------------&gt;
                                                   recv_challenge_reply
                                                   ICB = in_cookie(A),
                                                   check:
                                                   DiA == gen_digest (ChB, ICB)?
                                                   - if OK:
                                                    OCB = out_cookie(A),
                                                    DiB = gen_digest (ChA, OCB)
                          (DiB)
  &lt;----------------------------------------------- send_challenge_ack
recv_challenge_ack                                  DONE
ICA = in_cookie(B),                                - else:
check:                                              CLOSE
DiB == gen_digest(ChA, ICA)?
- if OK:
 DONE
- else:
 CLOSE</pre> <h4> <span onmouseover="document.getElementById('ghlink-distribution-flags-id112048').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-distribution-flags-id112048').style.visibility = 'hidden';" id="dflags">Distribution Flags</span> </h4> <p>The following capability flags are defined:</p> <dl> <dt><strong><code class="code">-define(DFLAG_PUBLISHED,16#1).</code></strong></dt> <dd> <p>The node is to be published and part of the global namespace.</p> </dd> <dt><strong><code class="code">-define(DFLAG_ATOM_CACHE,16#2).</code></strong></dt> <dd> <p>The node implements an atom cache (obsolete).</p> </dd> <dt><strong><code class="code">-define(DFLAG_EXTENDED_REFERENCES,16#4).</code></strong></dt> <dd> <p>The node implements extended (3 × 32 bits) references. This is required today. If not present, the connection is refused.</p> </dd> <dt><strong><code class="code">-define(DFLAG_DIST_MONITOR,16#8).</code></strong></dt> <dd> <p>The node implements distributed process monitoring.</p> </dd> <dt><strong><code class="code">-define(DFLAG_FUN_TAGS,16#10).</code></strong></dt> <dd> <p>The node uses separate tag for funs (lambdas) in the distribution protocol.</p> </dd> <dt><strong><code class="code">-define(DFLAG_DIST_MONITOR_NAME,16#20).</code></strong></dt> <dd> <p>The node implements distributed named process monitoring.</p> </dd> <dt><strong><code class="code">-define(DFLAG_HIDDEN_ATOM_CACHE,16#40).</code></strong></dt> <dd> <p>The (hidden) node implements atom cache (obsolete).</p> </dd> <dt><strong><code class="code">-define(DFLAG_NEW_FUN_TAGS,16#80).</code></strong></dt> <dd> <p>The node understand new fun tags.</p> </dd> <dt><strong><code class="code">-define(DFLAG_EXTENDED_PIDS_PORTS,16#100).</code></strong></dt> <dd> <p>The node can handle extended pids and ports. This is required today. If not present, the connection is refused.</p> </dd> <dt><strong><code class="code">-define(DFLAG_EXPORT_PTR_TAG,16#200).</code></strong></dt>  <dt><strong><code class="code">-define(DFLAG_BIT_BINARIES,16#400).</code></strong></dt>  <dt><strong><code class="code">-define(DFLAG_NEW_FLOATS,16#800).</code></strong></dt> <dd> <p>The node understands new float format.</p> </dd> <dt><strong><code class="code">-define(DFLAG_UNICODE_IO,16#1000).</code></strong></dt>  <dt><strong><code class="code">-define(DFLAG_DIST_HDR_ATOM_CACHE,16#2000).</code></strong></dt> <dd> <p>The node implements atom cache in distribution header.</p> </dd> <dt><strong><code class="code">-define(DFLAG_SMALL_ATOM_TAGS, 16#4000).</code></strong></dt> <dd> <p>The node understand the <code class="code">SMALL_ATOM_EXT</code> tag.</p> </dd> <dt><strong><code class="code">-define(DFLAG_UTF8_ATOMS, 16#10000).</code></strong></dt> <dd> <p>The node understand UTF-8 encoded atoms.</p> </dd> <dt><strong><code class="code">-define(DFLAG_MAP_TAG, 16#20000).</code></strong></dt> <dd> <p>The node understand the map tag.</p> </dd> <dt><strong><code class="code">-define(DFLAG_BIG_CREATION, 16#40000).</code></strong></dt> <dd> <p>The node understand big node creation.</p> </dd> <dt><strong><code class="code">-define(DFLAG_SEND_SENDER, 16#80000).</code></strong></dt> <dd> <p> Use the <code class="code">SEND_SENDER</code> <code><a href="#control_message">control message</a></code> instead of the <code class="code">SEND</code> control message and use the <code class="code">SEND_SENDER_TT</code> control message instead of the <code class="code">SEND_TT</code> control message. </p> </dd> </dl> <p> There is also function <code class="code">dist_util:strict_order_flags/0</code> returning all flags (bitwise or:ed together) corresponding to features that require strict ordering of data over distribution channels. </p> <h2> <span onmouseover="document.getElementById('ghlink-protocol-between-connected-nodes-id112336').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-protocol-between-connected-nodes-id112336').style.visibility = 'hidden';" id="connected_nodes">13.3 Protocol between Connected Nodes</span> </h2> <p>As from ERTS 5.7.2 the runtime system passes a distribution flag in the handshake stage that enables the use of a <code><a href="erl_ext_dist#distribution_header">distribution header</a></code> on all messages passed. Messages passed between nodes have in this case the following format:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>4</td> <td>d</td> <td>n</td> <td>m</td> </tr> <tr> <td><code class="code">Length</code></td> <td><code class="code">DistributionHeader</code></td> <td><code class="code">ControlMessage</code></td> <td><code class="code">Message</code></td> </tr> </table> <p class="doc-table-caption">Table 13.16: Format of Messages Passed between Nodes (as from ERTS 5.7.2) </p> </div> <dl> <dt><strong><code class="code">Length</code></strong></dt> <dd> <p>Equal to d + n + m.</p> </dd> <dt><strong><code class="code">ControlMessage</code></strong></dt> <dd> <p>A tuple passed using the external format of Erlang.</p> </dd> <dt><strong><code class="code">Message</code></strong></dt> <dd> <p>The message sent to another node using the '!' (in external format). Notice that <code class="code">Message</code> is only passed in combination with a <code class="code">ControlMessage</code> encoding a send ('!').</p> </dd> </dl> <p>Notice that <code><a href="erl_ext_dist#overall_format">the version number is omitted from the terms that follow a distribution header</a></code>.</p> <p>Nodes with an ERTS version earlier than 5.7.2 does not pass the distribution flag that enables the distribution header. Messages passed between nodes have in this case the following format:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td>4</td> <td>1</td> <td>n</td> <td>m</td> </tr> <tr> <td><code class="code">Length</code></td> <td><code class="code">Type</code></td> <td><code class="code">ControlMessage</code></td> <td><code class="code">Message</code></td> </tr> </table> <p class="doc-table-caption">Table 13.17: Format of Messages Passed between Nodes (before ERTS 5.7.2) </p> </div> <dl> <dt><strong><code class="code">Length</code></strong></dt> <dd> <p>Equal to 1 + n + m.</p> </dd> <dt><strong><code class="code">Type</code></strong></dt> <dd> <p>Equal to <code class="code">112</code> (pass through).</p> </dd> <dt><strong><code class="code">ControlMessage</code></strong></dt> <dd> <p>A tuple passed using the external format of Erlang.</p> </dd> <dt><strong><code class="code">Message</code></strong></dt> <dd> <p>The message sent to another node using the '!' (in external format). Notice that <code class="code">Message</code> is only passed in combination with a <code class="code">ControlMessage</code> encoding a send ('!').</p> </dd> </dl>  <p id="control_message">The <code class="code">ControlMessage</code> is a tuple, where the first element indicates which distributed operation it encodes:</p> <dl> <dt><strong><code class="code">LINK</code></strong></dt> <dd> <p><code class="code">{1, FromPid, ToPid}</code></p> </dd> <dt><strong><code class="code">SEND</code></strong></dt> <dd> <p><code class="code">{2, Unused, ToPid}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p><code class="code">Unused</code> is kept for backward compatibility.</p> </dd> <dt><strong><code class="code">EXIT</code></strong></dt> <dd> <p><code class="code">{3, FromPid, ToPid, Reason}</code></p> </dd> <dt><strong><code class="code">UNLINK</code></strong></dt> <dd> <p><code class="code">{4, FromPid, ToPid}</code></p> </dd> <dt><strong><code class="code">NODE_LINK</code></strong></dt> <dd> <p><code class="code">{5}</code></p> </dd> <dt><strong><code class="code">REG_SEND</code></strong></dt> <dd> <p><code class="code">{6, FromPid, Unused, ToName}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p><code class="code">Unused</code> is kept for backward compatibility.</p> </dd> <dt><strong><code class="code">GROUP_LEADER</code></strong></dt> <dd> <p><code class="code">{7, FromPid, ToPid}</code></p> </dd> <dt><strong><code class="code">EXIT2</code></strong></dt> <dd> <p><code class="code">{8, FromPid, ToPid, Reason}</code></p> </dd> </dl> <h2><span onmouseover="document.getElementById('ghlink-new-ctrlmessages-for-distrvsn-=-1--erlang-otp-r4--id112820').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-new-ctrlmessages-for-distrvsn-=-1--erlang-otp-r4--id112820').style.visibility = 'hidden';" id="new-ctrlmessages-for-distrvsn-=-1--erlang-otp-r4-">13.4 New Ctrlmessages for distrvsn = 1 (Erlang/OTP R4)</span></h2> <dl> <dt><strong><code class="code">SEND_TT</code></strong></dt> <dd> <p><code class="code">{12, Unused, ToPid, TraceToken}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p><code class="code">Unused</code> is kept for backward compatibility.</p> </dd> <dt><strong><code class="code">EXIT_TT</code></strong></dt> <dd> <p><code class="code">{13, FromPid, ToPid, TraceToken, Reason}</code></p> </dd> <dt><strong><code class="code">REG_SEND_TT</code></strong></dt> <dd> <p><code class="code">{16, FromPid, Unused, ToName, TraceToken}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p><code class="code">Unused</code> is kept for backward compatibility.</p> </dd> <dt><strong><code class="code">EXIT2_TT</code></strong></dt> <dd> <p><code class="code">{18, FromPid, ToPid, TraceToken, Reason}</code></p> </dd> </dl> <h2><span onmouseover="document.getElementById('ghlink-new-ctrlmessages-for-distrvsn-=-2-id112915').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-new-ctrlmessages-for-distrvsn-=-2-id112915').style.visibility = 'hidden';" id="new-ctrlmessages-for-distrvsn-=-2">13.5 New Ctrlmessages for distrvsn = 2</span></h2> <p><code class="code">distrvsn</code> 2 was never used.</p> <h2><span onmouseover="document.getElementById('ghlink-new-ctrlmessages-for-distrvsn-=-3--erlang-otp-r5c--id112932').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-new-ctrlmessages-for-distrvsn-=-3--erlang-otp-r5c--id112932').style.visibility = 'hidden';" id="new-ctrlmessages-for-distrvsn-=-3--erlang-otp-r5c-">13.6 New Ctrlmessages for distrvsn = 3 (Erlang/OTP R5C)</span></h2> <p>None, but the version number was increased anyway.</p> <h2><span onmouseover="document.getElementById('ghlink-new-ctrlmessages-for-distrvsn-=-4--erlang-otp-r6--id112946').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-new-ctrlmessages-for-distrvsn-=-4--erlang-otp-r6--id112946').style.visibility = 'hidden';" id="new-ctrlmessages-for-distrvsn-=-4--erlang-otp-r6-">13.7 New Ctrlmessages for distrvsn = 4 (Erlang/OTP R6)</span></h2> <p>These are only recognized by Erlang nodes, not by hidden nodes.</p> <dl> <dt><strong><code class="code">MONITOR_P</code></strong></dt> <dd> <p><code class="code">{19, FromPid, ToProc, Ref}</code>, where <code class="code">FromPid</code> = monitoring process and <code class="code">ToProc</code> = monitored process pid or name (atom)</p> </dd> <dt><strong><code class="code">DEMONITOR_P</code></strong></dt> <dd> <p><code class="code">{20, FromPid, ToProc, Ref}</code>, where <code class="code">FromPid</code> = monitoring process and <code class="code">ToProc</code> = monitored process pid or name (atom)</p> <p>We include <code class="code">FromPid</code> just in case we want to trace this.</p> </dd> <dt><strong><code class="code">MONITOR_P_EXIT</code></strong></dt> <dd> <p><code class="code">{21, FromProc, ToPid, Ref, Reason}</code>, where <code class="code">FromProc</code> = monitored process pid or name (atom), <code class="code">ToPid</code> = monitoring process, and <code class="code">Reason</code> = exit reason for the monitored process</p> </dd> </dl> <h2><span onmouseover="document.getElementById('ghlink-new-ctrlmessages-for-erlang-otp-21-id113043').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-new-ctrlmessages-for-erlang-otp-21-id113043').style.visibility = 'hidden';" id="new-ctrlmessages-for-erlang-otp-21">13.8 New Ctrlmessages for Erlang/OTP 21</span></h2> <dl> <dt><strong><code class="code">SEND_SENDER</code></strong></dt> <dd> <p><code class="code">{22, FromPid, ToPid}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p> This control messages replace the <code class="code">SEND</code> control message and will be sent when the distribution flag <code><a href="erl_dist_protocol#dflags"><span class="code">DFLAG_SEND_SENDER</span></a></code> has been negotiated in the connection setup handshake. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Messages encoded before the connection has been set up may still use the <code class="code">SEND</code> control message. However, once a <code class="code">SEND_SENDER</code> or <code class="code">SEND_SENDER_TT</code> control message has been sent, no more <code class="code">SEND</code> control messages will be sent in the same direction on the connection. </p>
</div> </div> </dd> <dt><strong><code class="code">SEND_SENDER_TT</code></strong></dt> <dd> <p><code class="code">{23, FromPid, ToPid, TraceToken}</code></p> <p>Followed by <code class="code">Message</code>.</p> <p> This control messages replace the <code class="code">SEND_TT</code> control message and will be sent when the distribution flag <code><a href="erl_dist_protocol#dflags"><span class="code">DFLAG_SEND_SENDER</span></a></code> has been negotiated in the connection setup handshake. </p> <div class="note"> <div class="label">Note</div> <div class="content">

<p> Messages encoded before the connection has been set up may still use the <code class="code">SEND_TT</code> control message. However, once a <code class="code">SEND_SENDER</code> or <code class="code">SEND_SENDER_TT</code> control message has been sent, no more <code class="code">SEND_TT</code> control messages will be sent in the same direction on the connection. </p>
</div> </div> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
