
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Igor - Erlang 21 - W3cubDocs</title>
  
  <meta name="description" content=" igor ">
  <meta name="keywords" content="igor, erlang, erlang~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/erlang~21/lib/syntax_tools-2.1.5/doc/html/igor.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/erlang~21.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~21/" class="_nav-link" title="" style="margin-left:0;">Erlang 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _erlang">
				
				
<h1>igor</h1> <h2><span onmouseover="document.getElementById('ghlink-module-id120510').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-id120510').style.visibility = 'hidden';" id="module">Module</span></h2> <p class="REFBODY module-body">igor</p> <h2><span onmouseover="document.getElementById('ghlink-module-summary-id120514').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-module-summary-id120514').style.visibility = 'hidden';" id="module-summary">Module Summary</span></h2> <p class="REFBODY module-summary-body">Igor: the Module Merger and Renamer.</p> <h2><span onmouseover="document.getElementById('ghlink-description-id120518').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-id120518').style.visibility = 'hidden';" id="description">Description</span></h2> 
<p>Igor: the Module Merger and Renamer.</p> <p>The program Igor merges the source code of one or more Erlang modules into a single module, which can then replace the original set of modules. Igor is also able to rename a set of (possibly interdependent) modules, without joining them into a single module.</p> <p>The main user interface consists of the functions <code><a href="#merge-3">merge/3</a></code> and <code><a href="#rename-3">rename/3</a></code>. See also the function <code><a href="#parse_transform-2">parse_transform/2</a></code>.</p> <p>A note of warning: Igor cannot do anything about the case when the name of a remote function is passed to the built-in functions <code class="code">apply</code> and <code class="code">spawn</code> <strong>unless</strong> the module and function names are explicitly stated in the call, as in e.g. <code class="code">apply(lists, reverse, [Xs])</code>. In all other cases, Igor leaves such calls unchanged, and warns the user that manual editing might be necessary.</p> <p>Also note that Erlang records will be renamed as necessary to avoid non-equivalent definitions using the same record name. This does not work if the source code accesses the name field of such record tuples by <code class="code">element/2</code> or similar methods. Always use the record syntax to handle record tuples, if possible.</p> <p>Disclaimer: the author of this program takes no responsibility for the correctness of the produced output, or for any effects of its execution. In particular, the author may not be held responsible should Igor include the code of a deceased madman in the result.</p> <p>For further information on Igors in general, see e.g. "Young Frankenstein", Mel Brooks, 1974, and "The Fifth Elephant", Terry Pratchett, 1999.</p> <h2>Data types</h2>   <dl id="types"> <dt><strong>filename() = <code id="type-filename">file:filename()</code></strong></dt>  <dt><strong id="type-stubDescriptor">stubDescriptor() = {ModuleName, Functions, [Attribute]}</strong></dt> <dd> <ul> <li><p>ModuleName = atom()</p></li> <li><p>Functions = [{FunctionName, {ModuleName, FunctionName}}]</p></li> <li><p>FunctionName = {atom(), integer()}</p></li> <li><p>Attribute = {atom(), term()}</p></li> </ul> <p>A stub module descriptor contains the module name, a list of exported functions, and a list of module attributes. Each function is described by its name (which includes its arity), and the corresponding module and function that it calls. (The arities should always match.) The attributes are simply described by key-value pairs. </p> </dd> <dt><strong>syntaxTree() = <code id="type-syntaxTree"><a href="erl_syntax#type-syntaxTree">erl_syntax:syntaxTree()</a></code></strong></dt> <dd>  <p>An abstract syntax tree. See the <code><a href="erl_syntax">erl_syntax</a></code> module for details. </p> </dd> </dl>  <h2><span onmouseover="document.getElementById('ghlink-exports-id120686').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-exports-id120686').style.visibility = 'hidden';" id="exports">Exports</span></h2> <div class="exports-body"> 
<div><span onmouseover="document.getElementById('ghlink-create_stubs-2-id120690').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-create_stubs-2-id120690').style.visibility = 'hidden';" id="create_stubs-2">create_stubs(Stubs::[stubDescriptor()], Options::[term()]) -&gt; [string()]</span></div> 
<p>Creates stub module source files corresponding to the given stub descriptors. The returned value is the list of names of the created files. See <code class="code">merge_sources/3</code> for more information about stub descriptors.</p> <p>Options: </p>
<dl> <dt><strong><code class="code">{backup_suffix, string()}</code></strong></dt>  <dt><strong><code class="code">{backups, boolean()}</code></strong></dt>  <dt><strong><code class="code">{printer, Function}</code></strong></dt>  <dt><strong><code class="code">{stub_dir, filename()}</code></strong></dt>  <dt><strong><code class="code">{suffix, string()}</code></strong></dt>  <dt><strong><code class="code">{verbose, boolean()}</code></strong></dt>  </dl> <p>See <code class="code">merge/3</code> for details on these options. </p> <p><strong>See also:</strong> <code><a href="#merge-3">merge/3</a></code>, <code><a href="#merge_sources-3">merge_sources/3</a></code>.</p>  
<div><span onmouseover="document.getElementById('ghlink-merge-2-id120790').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-merge-2-id120790').style.visibility = 'hidden';" id="merge-2">merge(Name::atom(), Files::[filename()]) -&gt; [filename()]</span></div> 
<p>Equivalent to <code><a href="#merge-3">merge(Name, Files, [])</a></code>.</p>  
<div><span onmouseover="document.getElementById('ghlink-merge-3-id120829').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-merge-3-id120829').style.visibility = 'hidden';" id="merge-3">merge(Name::atom(), Files::[filename()], Options::[term()]) -&gt; [filename()]</span></div> 
<p>Merges source code files to a single file. <code class="code">Name</code> specifies the name of the resulting module - not the name of the output file. <code class="code">Files</code> is a list of file names and/or module names of source modules to be read and merged (see <code class="code">merge_files/4</code> for details). All the input modules must be distinctly named.</p> <p>The resulting source code is written to a file named "<code class="code">&lt;em&gt;Name&lt;/em&gt;.erl</code>" in the current directory, unless otherwise specified by the options <code class="code">dir</code> and <code class="code">outfile</code> described below.</p> <p>Examples: </p>
<ul> <li><p>given a module <code class="code">m</code> in file "<code class="code">m.erl</code>" which uses the standard library module <code class="code">lists</code>, calling <code class="code">igor:merge(m, [m, lists])</code> will create a new file "<code class="code">m.erl</code> which contains the code from <code class="code">m</code> and exports the same functions, and which includes the referenced code from the <code class="code">lists</code> module. The original file will be renamed to "<code class="code">m.erl.bak</code>".</p></li> <li><p>given modules <code class="code">m1</code> and <code class="code">m2</code>, in corresponding files, calling <code class="code">igor:merge(m, [m1, m2])</code> will create a file "<code class="code">m.erl</code>" which contains the code from <code class="code">m1</code> and <code class="code">m2</code> and exports the functions of <code class="code">m1</code>.</p></li> </ul> <p>Stub module files are created for those modules that are to be exported by the target module (see options <code class="code">export</code>, <code class="code">stubs</code> and <code class="code">stub_dir</code>).</p> <p>The function returns the list of file names of all created modules, including any automatically created stub modules. The file name of the target module is always first in the list.</p> <p>Note: If you get a "syntax error" message when trying to merge files (and you know those files to be correct), then try the <code class="code">preprocess</code> option. It typically means that your code contains too strange macros to be handled without actually performing the preprocessor expansions.</p> <p>Options: </p>
<dl> <dt><strong><code class="code">{backup_suffix, string()}</code></strong></dt> <dd><p>Specifies the file name suffix to be used when a backup file is created; the default value is <code class="code">".bak"</code>.</p></dd> <dt><strong><code class="code">{backups, boolean()}</code></strong></dt> <dd><p>If the value is <code class="code">true</code>, existing files will be renamed before new files are opened for writing. The new names are formed by appending the string given by the <code class="code">backup_suffix</code> option to the original name. The default value is <code class="code">true</code>.</p></dd> <dt><strong><code class="code">{dir, filename()}</code></strong></dt> <dd><p>Specifies the name of the directory in which the output file is to be written. An empty string is interpreted as the current directory. By default, the current directory is used.</p></dd> <dt><strong><code class="code">{outfile, filename()}</code></strong></dt> <dd><p>Specifies the name of the file (without suffix) to which the resulting source code is to be written. By default, this is the same as the <code class="code">Name</code> argument.</p></dd> <dt><strong><code class="code">{preprocess, boolean()}</code></strong></dt> <dd><p>If the value is <code class="code">true</code>, preprocessing will be done when reading the source code. See <code class="code">merge_files/4</code> for details.</p></dd> <dt><strong><code class="code">{printer, Function}</code></strong></dt> <dd> <ul> <li><p><code class="code">Function = (syntaxTree()) -&gt; string()</code></p></li> </ul> <p> Specifies a function for prettyprinting Erlang syntax trees. This is used for outputting the resulting module definition, as well as for creating stub files. The function is assumed to return formatted text for the given syntax tree, and should raise an exception if an error occurs. The default formatting function calls <code class="code">erl_prettypr:format/2</code>.</p> </dd> <dt><strong><code class="code">{stub_dir, filename()}</code></strong></dt> <dd><p>Specifies the name of the directory to which any generated stub module files are written. The default value is <code class="code">"stubs"</code>.</p></dd> <dt><strong><code class="code">{stubs, boolean()}</code></strong></dt> <dd><p>If the value is <code class="code">true</code>, stub module files will be automatically generated for all exported modules that do not have the same name as the target module. The default value is <code class="code">true</code>.</p></dd> <dt><strong><code class="code">{suffix, string()}</code></strong></dt> <dd><p>Specifies the suffix to be used for the output file names; the default value is <code class="code">".erl"</code>.</p></dd> </dl> <p>See <code class="code">merge_files/4</code> for further options. </p> <p><strong>See also:</strong> <code><a href="#merge-2">merge/2</a></code>, <code><a href="#merge_files-4">merge_files/4</a></code>.</p>  
<div><span onmouseover="document.getElementById('ghlink-merge_files-3-id121182').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-merge_files-3-id121182').style.visibility = 'hidden';" id="merge_files-3">merge_files(Name::atom(), Files::[filename()], Options::[term()]) -&gt; {syntaxTree(), [stubDescriptor()]}</span></div> 
<p>Equivalent to <code><a href="#merge_files-4">merge_files(Name, [], Files, Options)</a></code>.</p>  
<div><span onmouseover="document.getElementById('ghlink-merge_files-4-id121228').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-merge_files-4-id121228').style.visibility = 'hidden';" id="merge_files-4">merge_files(Name::atom(), Sources::[Forms], Files::[filename()], Options::[term()]) -&gt; {syntaxTree(), [stubDescriptor()]}</span></div>  <h2 class="func-types-title">Types</h2>   
<p>Merges source code files and syntax trees to a single syntax tree. This is a file-reading front end to <code class="code">merge_sources/3</code>. <code class="code">Name</code> specifies the name of the resulting module - not the name of the output file. <code class="code">Sources</code> is a list of syntax trees and/or lists of "source code form" syntax trees, each entry representing a module definition. <code class="code">Files</code> is a list of file names and/or module names of source modules to be read and included. All the input modules must be distinctly named.</p> <p>If a name in <code class="code">Files</code> is not the name of an existing file, Igor assumes it represents a module name, and tries to locate and read the corresponding source file. The parsed files are appended to <code class="code">Sources</code> and passed on to <code class="code">merge_sources/3</code>, i.e., entries in <code class="code">Sources</code> are listed before entries read from files.</p> <p>If no exports are listed by an <code class="code">export</code> option (see <code class="code">merge_sources/3</code> for details), then if <code class="code">Name</code> is also the name of one of the input modules, that module will be exported; otherwise, the first listed module will be exported. Cf. the examples under <code class="code">merge/3</code>.</p> <p>The result is a pair <code class="code">{Tree, Stubs}</code>, where <code class="code">Tree</code> represents the source code that is the result of merging all the code in <code class="code">Sources</code> and <code class="code">Files</code>, and <code class="code">Stubs</code> is a list of stub module descriptors (see <code class="code">merge_sources/3</code> for details).</p> <p>Options: </p>
<dl> <dt><strong><code class="code">{comments, boolean()}</code></strong></dt> <dd><p>If the value is <code class="code">true</code>, source code comments in the original files will be preserved in the output. The default value is <code class="code">true</code>.</p></dd> <dt><strong><code class="code">{find_src_rules, [{string(), string()}]}</code></strong></dt> <dd><p>Specifies a list of rules for associating object files with source files, to be passed to the function <code class="code">filelib:find_source/2</code>. This can be used to change the way Igor looks for source files. If this option is not specified, the default system rules are used. The first occurrence of this option completely overrides any later in the option list.</p></dd> <dt><strong><code class="code">{includes, [filename()]}</code></strong></dt> <dd><p>Specifies a list of directory names for the Erlang preprocessor, if used, to search for include files (cf. the <code class="code">preprocess</code> option). The default value is the empty list. The directory of the source file and the current directory are automatically appended to the list.</p></dd> <dt><strong><code class="code">{macros, [{atom(), term()}]}</code></strong></dt> <dd><p>Specifies a list of "pre-defined" macro definitions for the Erlang preprocessor, if used (cf. the <code class="code">preprocess</code> option). The default value is the empty list.</p></dd> <dt><strong><code class="code">{preprocess, boolean()}</code></strong></dt> <dd> <p>If the value is <code class="code">false</code>, Igor will read source files without passing them through the Erlang preprocessor (<code class="code">epp</code>), in order to avoid expansion of preprocessor directives such as <code class="code">-include(...).</code>, <code class="code">-define(...).</code> and <code class="code">-ifdef(...)</code>, and macro calls such as <code class="code">?LINE</code> and <code class="code">?MY_MACRO(x, y)</code>. The default value is <code class="code">false</code>, i.e., preprocessing is not done. (See the module <code class="code">epp_dodger</code> for details.)</p> <p>Notes: If a file contains too exotic definitions or uses of macros, it will not be possible to read it without preprocessing. Furthermore, Igor does not currently try to sort out multiple inclusions of the same file, or redefinitions of the same macro name. Therefore, when preprocessing is turned off, it may become necessary to edit the resulting source code, removing such re-inclusions and redefinitions.</p> </dd> </dl> <p>See <code class="code">merge_sources/3</code> for further options. </p> <p><strong>See also:</strong> <code><a href="epp_dodger">epp_dodger</a></code>, <code>filelib:find_source/2</code>, <code><a href="#merge-3">merge/3</a></code>, <code><a href="#merge_files-3">merge_files/3</a></code>, <code><a href="#merge_sources-3">merge_sources/3</a></code>.</p>  
<div><span onmouseover="document.getElementById('ghlink-merge_sources-3-id121537').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-merge_sources-3-id121537').style.visibility = 'hidden';" id="merge_sources-3">merge_sources(Name::atom(), Sources::[Forms], Options::[term()]) -&gt; {syntaxTree(), [stubDescriptor()]}</span></div>  <h2 class="func-types-title">Types</h2>   
<p>Merges syntax trees to a single syntax tree. This is the main code merging "engine". <code class="code">Name</code> specifies the name of the resulting module. <code class="code">Sources</code> is a list of syntax trees of type <code class="code">form_list</code> and/or lists of "source code form" syntax trees, each entry representing a module definition. All the input modules must be distinctly named.</p> <p>Unless otherwise specified by the options, all modules are assumed to be at least "static", and all except the target module are assumed to be "safe". See the <code class="code">static</code> and <code class="code">safe</code> options for details.</p> <p>If <code class="code">Name</code> is also the name of one of the input modules, the code from that module will occur at the top of the resulting code, and no extra "header" comments will be added. In other words, the look of that module will be preserved.</p> <p>The result is a pair <code class="code">{Tree, Stubs}</code>, where <code class="code">Tree</code> represents the source code that is the result of merging all the code in <code class="code">Sources</code>, and <code class="code">Stubs</code> is a list of stub module descriptors (see below).</p> <p><code class="code">Stubs</code> contains one entry for each exported input module (cf. the <code class="code">export</code> option), each entry describing a stub module that redirects calls of functions in the original module to the corresponding (possibly renamed) functions in the new module. The stub descriptors can be used to automatically generate stub modules; see <code class="code">create_stubs/2</code>.</p> <p>Options: </p>
<dl> <dt><strong><code class="code">{export, [atom()]}</code></strong></dt> <dd><p>Specifies a list of names of input modules whose interfaces should be exported by the output module. A stub descriptor is generated for each specified module, unless its name is <code class="code">Name</code>. If no modules are specified, then if <code class="code">Name</code> is also the name of an input module, that module will be exported; otherwise the first listed module in <code class="code">Sources</code> will be exported. The default value is the empty list.</p></dd> <dt><strong><code class="code">{export_all, boolean()}</code></strong></dt> <dd><p>If the value is <code class="code">true</code>, this is equivalent to listing all of the input modules in the <code class="code">export</code> option. The default value is <code class="code">false</code>.</p></dd> <dt><strong><code class="code">{file_attributes, Preserve}</code></strong></dt> <dd> <ul> <li><p><code class="code">Preserve = yes | comment | no</code></p></li> </ul> <p> If the value is <code class="code">yes</code>, all file attributes <code class="code">-file(...)</code> in the input sources will be preserved in the resulting code. If the value is <code class="code">comment</code>, they will be turned into comments, but remain in their original positions in the code relative to the other source code forms. If the value is <code class="code">no</code>, all file attributes will be removed from the code, unless they have attached comments, in which case they will be handled as in the <code class="code">comment</code> case. The default value is <code class="code">no</code>.</p> </dd> <dt><strong><code class="code">{no_banner, boolean()}</code></strong></dt> <dd><p>If the value is <code class="code">true</code>, no banner comment will be added at the top of the resulting module, even if the target module does not have the same name as any of the input modules. Instead, Igor will try to preserve the look of the module whose code is at the top of the output. The default value is <code class="code">false</code>.</p></dd> <dt><strong><code class="code">{no_headers, boolean()}</code></strong></dt> <dd><p>If the value is <code class="code">true</code>, no header comments will be added to the resulting module at the beginning of each section of code that originates from a particular input module. The default value is <code class="code">false</code>, which means that section headers are normally added whenever more than two or more modules are merged.</p></dd> <dt><strong><code class="code">{no_imports, boolean()}</code></strong></dt> <dd><p>If the value is <code class="code">true</code>, all <code class="code">-import(...)</code> declarations in the original code will be expanded in the result; otherwise, as much as possible of the original import declarations will be preserved. The default value is <code class="code">false</code>.</p></dd> <dt><strong><code class="code">{notes, Notes}</code></strong></dt> <dd> <ul> <li><p><code class="code">Notes = always | yes | no</code></p></li> </ul> <p> If the value is <code class="code">yes</code>, comments will be inserted where important changes have been made in the code. If the value is <code class="code">always</code>, <strong>all</strong> changes to the code will be commented. If the value is <code class="code">no</code>, changes will be made without comments. The default value is <code class="code">yes</code>.</p> </dd> <dt><strong><code class="code">{redirect, [{atom(), atom()}]}</code></strong></dt> <dd><p>Specifies a list of pairs of module names, representing a mapping from old names to new. <strong>The set of old names may not include any of the names of the input modules.</strong> All calls to the listed old modules will be rewritten to refer to the corresponding new modules. <strong>The redirected calls will not be further processed, even if the new destination is in one of the input modules.</strong> This option mainly exists to support module renaming; cf. <code class="code">rename/3</code>. The default value is the empty list.</p></dd> <dt><strong><code class="code">{safe, [atom()]}</code></strong></dt> <dd><p>Specifies a list of names of input modules such that calls to these "safe" modules may be turned into direct local calls, that do not test for code replacement. Typically, this can be done for e.g. standard library modules. If a module is "safe", it is per definition also "static" (cf. below). The list may be empty. By default, all involved modules <strong>except the target module</strong> are considered "safe".</p></dd> <dt><strong><code class="code">{static, [atom()]}</code></strong></dt> <dd><p>Specifies a list of names of input modules which will be assumed never to be replaced (reloaded) unless the target module is also first replaced. The list may be empty. The target module itself (which may also be one of the input modules) is always regarded as "static", regardless of the value of this option. By default, all involved modules are assumed to be static.</p></dd> <dt><strong><code class="code">{tidy, boolean()}</code></strong></dt> <dd><p>If the value is <code class="code">true</code>, the resulting code will be processed using the <code class="code">erl_tidy</code> module, which removes unused functions and does general code cleanup. (See <code class="code">erl_tidy:module/2</code> for additional options.) The default value is <code class="code">true</code>.</p></dd> <dt><strong><code class="code">{verbose, boolean()}</code></strong></dt> <dd><p>If the value is <code class="code">true</code>, progress messages will be output while the program is running; the default value is <code class="code">false</code>.</p></dd> </dl> <p>Note: The distinction between "static" and "safe" modules is necessary in order not to break the semantics of dynamic code replacement. A "static" source module will not be replaced unless the target module also is. Now imagine a state machine implemented by placing the code for each state in a separate module, and suppose that we want to merge this into a single target module, marking all source modules as static. At each point in the original code where a call is made from one of the modules to another (i.e., the state transitions), code replacement is expected to be detected. Then, if we in the merged code do not check at these points if the <strong>target</strong> module (the result of the merge) has been replaced, we can not be sure in general that we will be able to do code replacement of the merged state machine - it could run forever without detecting the code change. Therefore, all such calls must remain remote-calls (detecting code changes), but may call the target module directly.</p> <p>If we are sure that this kind of situation cannot ensue, we may specify the involved modules as "safe", and all calls between them will become local. Note that if the target module itself is specified as safe, "remote" calls to itself will be turned into local calls. This would destroy the code replacement properties of e.g. a typical server loop. </p> <p><strong>See also:</strong> <code><a href="#create_stubs-2">create_stubs/2</a></code>, <code><a href="#rename-3">rename/3</a></code>, <code><a href="erl_tidy#module-2">erl_tidy:module/2</a></code>.</p>  
<div><span onmouseover="document.getElementById('ghlink-parse_transform-2-id122001').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-parse_transform-2-id122001').style.visibility = 'hidden';" id="parse_transform-2">parse_transform(Forms::[syntaxTree()], Options::[term()]) -&gt; [syntaxTree()]</span></div> 
<p>Allows Igor to work as a component of the Erlang compiler. Including the term <code class="code">{parse_transform, igor}</code> in the compile options when compiling an Erlang module (cf. <code class="code">compile:file/2</code>), will call upon Igor to process the source code, allowing automatic inclusion of other source files. No files are created or overwritten when this function is used.</p> <p>Igor will look for terms <code class="code">{igor, List}</code> in the compile options, where <code class="code">List</code> is a list of Igor-specific options, as follows: </p>
<dl> <dt><strong><code class="code">{files, [filename()]}</code></strong></dt> <dd><p>The value specifies a list of source files to be merged with the file being compiled; cf. <code class="code">merge_files/4</code>.</p></dd> </dl> <p>See <code class="code">merge_files/4</code> for further options. Note, however, that some options are preset by this function and cannot be overridden by the user; in particular, all cosmetic features are turned off, for efficiency. Preprocessing is turned on. </p> <p><strong>See also:</strong> <code>compile:file/2</code>, <code><a href="#merge_files-4">merge_files/4</a></code>.</p>  
<div><span onmouseover="document.getElementById('ghlink-rename-2-id122100').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-rename-2-id122100').style.visibility = 'hidden';" id="rename-2">rename(Files::[filename()], Renamings) -&gt; [string()]</span></div> 
<p>Equivalent to <code><a href="#rename-3">rename(Files, Renamings, [])</a></code>.</p>  
<div><span onmouseover="document.getElementById('ghlink-rename-3-id122133').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-rename-3-id122133').style.visibility = 'hidden';" id="rename-3">rename(Files::[filename()], Renamings, Options::[term()]) -&gt; [string()]</span></div>  <h2 class="func-types-title">Types</h2>   
<p>Renames a set of possibly interdependent source code modules. <code class="code">Files</code> is a list of file names of source modules to be processed. <code class="code">Renamings</code> is a list of pairs of <strong>module names</strong>, representing a mapping from old names to new. The returned value is the list of output file names.</p> <p>Each file in the list will be read and processed separately. For every file, each reference to some module M, such that there is an entry <code class="code">{&lt;em&gt;M&lt;/em&gt;, &lt;em&gt;M1&lt;/em&gt;}</code> in <code class="code">Renamings</code>, will be changed to the corresponding M1. Furthermore, if a file F defines module M, and there is an entry <code class="code">{&lt;em&gt;M&lt;/em&gt;, &lt;em&gt;M1&lt;/em&gt;}</code> in <code class="code">Renamings</code>, a new file named <code class="code">&lt;em&gt;M1&lt;/em&gt;.erl</code> will be created in the same directory as F, containing the source code for module M, renamed to M1. If M does not have an entry in <code class="code">Renamings</code>, the module is not renamed, only updated, and the resulting source code is written to <code class="code">&lt;em&gt;M&lt;/em&gt;.erl</code> (typically, this overwrites the original file). The <code class="code">suffix</code> option (see below) can be used to change the default "<code class="code">.erl</code>" suffix for the generated files.</p> <p>Stub modules will automatically be created (see the <code class="code">stubs</code> and <code class="code">stub_dir</code> options below) for each module that is renamed. These can be used to redirect any calls still using the old module names. The stub files are created in the same directory as the source file (typically overwriting the original file).</p> <p>Options: </p>
<dl> <dt><strong><code class="code">{backup_suffix, string()}</code></strong></dt>  <dt><strong><code class="code">{backups, boolean()}</code></strong></dt>  <dt><strong><code class="code">{printer, Function}</code></strong></dt>  <dt><strong><code class="code">{stubs, boolean()}</code></strong></dt>  <dt><strong><code class="code">{suffix, string()}</code></strong></dt>  </dl>
<p> See <code class="code">merge/3</code> for details on these options.</p> <dl> <dt><strong><code class="code">{comments, boolean()}</code></strong></dt>  <dt><strong><code class="code">{preprocess, boolean()}</code></strong></dt>  </dl>
<p> See <code class="code">merge_files/4</code> for details on these options.</p> <dl> <dt><strong><code class="code">{no_banner, boolean()}</code></strong></dt>  </dl>
<p> For the <code class="code">rename</code> function, this option is <code class="code">true</code> by default. See <code class="code">merge_sources/3</code> for details.</p> <dl> <dt><strong><code class="code">{tidy, boolean()}</code></strong></dt>  </dl>
<p> For the <code class="code">rename</code> function, this option is <code class="code">false</code> by default. See <code class="code">merge_sources/3</code> for details.</p> <dl> <dt><strong><code class="code">{no_headers, boolean()}</code></strong></dt>  <dt><strong><code class="code">{stub_dir, filename()}</code></strong></dt>  </dl>
<p> These options are preset by the <code class="code">rename</code> function and cannot be overridden by the user.</p> <p>See <code class="code">merge_sources/3</code> for further options. </p> <p><strong>See also:</strong> <code><a href="#merge-3">merge/3</a></code>, <code><a href="#merge_files-4">merge_files/4</a></code>, <code><a href="#merge_sources-3">merge_sources/3</a></code>.</p>  </div> Richard Carlsson carlsson.richard@gmail.com<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
