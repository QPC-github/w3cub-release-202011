
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>3. Running the Stack - Erlang 21 - W3cubDocs</title>
  
  <meta name="description" content="A user may have a number of &#34;virtual&#34; connections to other users. An MG is connected to at most one MGC, while an MGC may be connected to &hellip;">
  <meta name="keywords" content="running, stack, erlang, erlang~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/erlang~21/lib/megaco-3.18.3/doc/html/megaco_run.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/erlang~21.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~21/" class="_nav-link" title="" style="margin-left:0;">Erlang 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _erlang">
				
				
<h1>3 Running the stack</h1> <h2> <span onmouseover="document.getElementById('ghlink-starting-id65174').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-starting-id65174').style.visibility = 'hidden';" id="starting">3.1 Starting</span> </h2> <p>A user may have a number of "virtual" connections to other users. An MG is connected to at most one MGC, while an MGC may be connected to any number of MG's. For each connection the user selects a transport service, an encoding scheme and a user callback module.</p> <p>An MGC must initiate its transport service in order to listen to MG's trying to connect. How the actual transport is initiated is outside the scope of this application. However a send handle (typically a socket id or host and port) must be provided from the transport service in order to enable us to send the message to the correct destination. We do however not assume anything about this, from our point of view, opaque handle. Hopefully it is rather small since it will passed around the system between processes rather frequently.</p> <p>A user may either be statically configured in a .config file according to the application concept of Erlang/OTP or dynamically started with the configuration settings as arguments to megaco:start_user/2. These configuration settings may be updated later on with megaco:update_conn_info/2.</p> <p>The function megaco:connect/4 is used to tell the Megaco application about which control process it should supervise, which MID the remote user has, which callback module it should use to send messages etc. When this "virtual" connection is established the user may use megaco:call/3 and megaco:cast/3 in order to send messages to the other side. Then it is up to the MG to send its first Service Change Request message after applying some clever algorithm in order to fight the problem with startup avalanche (as discussed in the RFC).</p> <p>The originating user will wait for a reply or a timeout (defined by the request_timer). When it receives the reply this will optionally be acknowledged (regulated by auto_ack), and forwarded to the user. If an interim pending reply is received, the long_request_timer will be used instead of the usual request_timer, in order to enable avoidance of spurious re-sends of the request.</p> <p>On the destination side the transport service waits for messages. Each message is forwarded to the Megaco application via the megaco:receive_message/4 callback function. The transport service may or may not provide means for blocking and unblocking the reception of the incoming messages.</p>  <p>If a message is received before the "virtual" connection has been established, the connection will be setup automatically. An MGC may be real open minded and dynamically decide which encoding and transport service to use depending on how the transport layer contact is performed. For IP transports two ports are standardized, one for textual encoding and one for binary encoding. If for example an UDP packet was received on the text port it would be possible to decide encoding and transport on the fly.</p> <p>After decoding a message various user callback functions are invoked in order to allow the user to act properly. See the megaco_user module for more info about the callback arguments.</p> <p>When the user has processed a transaction request in its callback function, the Megaco application assembles a transaction reply, encodes it using the selected encoding module and sends the message back by invoking the callback function:</p> <ul> <li> <p>SendMod:send_message(SendHandle, ErlangBinary)</p> </li> </ul> <p>Re-send of messages, handling pending transactions, acknowledgements etc. is handled automatically by the Megaco application but the user is free to override the default behaviour by the various configuration possibilities. See megaco:update_user_info/2 and megaco:update_conn_info/2 about the possibilities.</p> <p>When connections gets broken (that is explicitly by megaco:disconnect/2 or when its controlling process dies) a user callback function is invoked in order to allow the user to re-establish the connection. The internal state of kept messages, re-send timers etc. is not affected by this. A few re-sends will of course fail while the connection is down, but the automatic re-send algorithm does not bother about this and eventually when the connection is up and running the messages will be delivered if the timeouts are set to be long enough. The user has the option of explicitly invoking megaco:cancel/2 to cancel all messages for a connection.</p> <h2> <span onmouseover="document.getElementById('ghlink-mgc-startup-call-flow-id65363').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-mgc-startup-call-flow-id65363').style.visibility = 'hidden';" id="mgc_startup_call_flow">3.2 MGC startup call flow</span> </h2> <p>In order to prepare the MGC for the reception of the initial message, hopefully a Service Change Request, the following needs to be done:</p> <ul> <li> <p>Start the Megaco application.</p> </li> <li> <p>Start the MGC user. This may either be done explicitly with megaco:start_user/2 or implicitly by providing the -megaco users configuration parameter.</p> </li> <li> <p>Initiate the transport service and provide it with a receive handle obtained from megaco:user_info/2.</p> </li> </ul> <p>When the initial message arrives the transport service forwards it to the protocol engine which automatically sets up the connection and invokes UserMod:handle_connect/2 before it invokes UserMod:handle_trans_request/3 with the Service Change Request like this:</p> <div class="doc-image-wrapper">  <p class="doc-image-caption">Figure 3.1: MGC Startup Call Flow</p> </div> <h2> <span onmouseover="document.getElementById('ghlink-mg-startup-call-flow-id59298').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-mg-startup-call-flow-id59298').style.visibility = 'hidden';" id="mg_startup_call_flow">3.3 MG startup call flow</span> </h2> <p>In order to prepare the MG for the sending of the initial message, hopefully a Service Change Request, the following needs to be done:</p> <ul> <li> <p>Start the Megaco application.</p> </li> <li> <p>Start the MG user. This may either be done explicitly with megaco:start_user/2 or implicitly by providing the -megaco users configuration parameter.</p> </li> <li> <p>Initiate the transport service and provide it with a receive handle obtained from megaco:user_info/2.</p> </li> <li> <p>Setup a connection to the MGC with megaco:connect/4 and provide it with a receive handle obtained from megaco:user_info/2.</p> </li> </ul> <p>If the MG has been provisioned with the MID of the MGC it can be given as the RemoteMid parameter to megaco:connect/4 and the call flow will look like this:</p> <div class="doc-image-wrapper">  <p class="doc-image-caption">Figure 3.2: MG Startup Call Flow</p> </div> <p>If the MG cannot be provisioned with the MID of the MGC, the MG can use the atom 'preliminary_mid' as the RemoteMid parameter to megaco:connect/4 and the call flow will look like this:</p> <div class="doc-image-wrapper">  <p class="doc-image-caption">Figure 3.3: MG Startup Call Flow (no MID)</p> </div> <h2> <span onmouseover="document.getElementById('ghlink-configuring-the-megaco-stack-id59387').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-configuring-the-megaco-stack-id59387').style.visibility = 'hidden';" id="config_megaco">3.4 Configuring the Megaco stack</span> </h2> <p>There are three kinds of configuration:</p> <ul> <li> <p>User info - Information related to megaco users. Read/Write. </p> <p>A User is an entity identified by a MID, e.g. a MGC or a MG. </p> <p>This information can be retrieved using <code><a href="megaco#user_info">megaco:user_info</a></code>. </p> </li> <li> <p>Connection info - Information regarding connections. Read/Write.</p> <p>This information can be retrieved using <code><a href="megaco#conn_info">megaco:conn_info</a></code>. </p> </li> <li> <p>System info - System wide information. Read only.</p> <p>This information can be retrieved using <code><a href="megaco#system_info">megaco:system_info</a></code>. </p> </li> </ul> <h2> <span onmouseover="document.getElementById('ghlink-initial-configuration-id59262').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-initial-configuration-id59262').style.visibility = 'hidden';" id="initial_config">3.5 Initial configuration</span> </h2> <p>The initial configuration of the Megaco should be defined in the Erlang system configuration file. The following configured parameters are defined for the Megaco application:</p> <ul> <li> <p><code class="code">users = [{Mid, [user_config()]}].</code></p> <p>Each user is represented by a tuple with the Mid of the user and a list of config parameters (each parameter is in turn a tuple: <code class="code">{Item, Value}</code>).</p> </li> <li> <p><code class="code">scanner = flex | {Module, Function, Arguments, Modules}</code></p> <ul> <li> <p><code class="code">flex</code> will result in the start of the flex scanner with default options.</p> </li> <li> <p>The MFA alternative makes it possible for Megaco to start and supervise a scanner written by the user (see <code class="code">supervisor:start_child</code> for an explanation of the parameters).</p> </li> </ul> </li> </ul> <p>See also <code><a href="megaco_encode#text_config">Configuration of text encoding module(s)</a></code> for more info. </p> <h2> <span onmouseover="document.getElementById('ghlink-changing-the-configuration-id67160').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-changing-the-configuration-id67160').style.visibility = 'hidden';" id="changing_config">3.6 Changing the configuration</span> </h2> <p>The configuration can be changed during runtime. This is done with the functions <code><a href="megaco#update_user_info">megaco:update_user_info</a></code> and <code><a href="megaco#update_conn_info">megaco:update_conn_info</a></code></p> <h2> <span onmouseover="document.getElementById('ghlink-the-transaction-sender-id67189').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-the-transaction-sender-id67189').style.visibility = 'hidden';" id="transaction_sender">3.7 The transaction sender</span> </h2> <p>The transaction sender is a process (one per connection), which handle all transaction sending, if so configured (see <code><a href="megaco#user_info">megaco:user_info</a></code> and <code><a href="megaco#conn_info">megaco:conn_info</a></code>).</p> <p>The purpose of the transaction sender is to accumulate transactions for a more efficient message sending. The transactions that are accumulated are transaction request and transaction ack. For transaction ack's the benefit is quite large, since the transactions are small and it is possible to have ranges (which means that transaction acks for transactions 1, 2, 3 and 4 can be sent as a range 1-4 in one transaction ack, instead of four separate transactions). </p> <p>There are a number of configuration parameter's that control the operation of the transaction sender. In principle, a message with everything stored (ack's and request's) is sent from the process when:</p> <ul> <li> <p>When <code class="code">trans_timer</code> expires.</p> </li> <li> <p>When <code class="code">trans_ack_maxcount</code> number of ack's has been received.</p> </li> <li> <p>When <code class="code">trans_req_maxcount</code> number of requests's has been received.</p> </li> <li> <p>When the size of all received requests exceeds <code class="code">trans_req_maxsize</code>.</p> </li> <li> <p>When a reply transaction is sent.</p> </li> <li> <p>When a pending transaction is sent.</p> </li> </ul> <p>When something is to be sent, everything is packed into one message, unless the trigger was a reply transaction and the added size of the reply and all the requests is greater then <code class="code">trans_req_maxsize</code>, in which case the stored transactions are sent first in a separate message and the reply in another message.</p> <p>When the transaction sender receives a request which is already "in storage" (indicated by the transaction id) it is assumed to be a resend and everything stored is sent. This could happen if the values of the <code class="code">trans_timer</code> and the <code class="code">request_timer</code> is not properly chosen.</p> <h2> <span onmouseover="document.getElementById('ghlink-segmentation-of-transaction-replies-id68142').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-segmentation-of-transaction-replies-id68142').style.visibility = 'hidden';" id="segment_reply">3.8 Segmentation of transaction replies</span> </h2> <p>In version 3 of the megaco standard the Segmentation package was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also <code><a href="megaco_encode#handling_versions">version3</a></code>.</p> <p>Although it would be both pointless and counterproductive to use segmentation on a transport that already does this (e.g. TCP), the megaco application does not check this. Instead, it is up to the user to configure this properly. </p> <ul> <li> <p>Receiving segmented messages: </p> <p>This is handled automatically by the megaco application. There is however one thing that need to be configured by the user, the <code><a href="megaco#user_info">segment_recv_timer</a></code> option. </p> <p>Note that the segments are delivered to the user differently depending on which function is used to issue the original request. When issuing the request using the <code><a href="megaco#cast">megaco:cast</a></code> function, the segments are delivered to the user via the <code><a href="megaco_user#trans_reply">handle_trans_reply</a></code> callback function one at a time, as they arrive. But this obviously doe not work for the <code><a href="megaco#call">megaco:call</a></code> function. In this case, the segments are accumulated and then delivered all at once as the function returns.</p> </li> <li> <p>Sending segmented messages: </p> <p>This is also handled automatically by the megaco application. First of all, segmentation is only attempted if so configured, see the <code><a href="megaco#user_info">segment_send</a></code> option. Secondly, megaco relies on the ability of the used codec to encode action replies, which is the smallest component the megaco application handles when segmenting. Thirdly, the reply will be segmented only if the sum of the size of the action replies (plus an arbitrary message header size) are greater then the specified max message size (see the <code><a href="megaco#user_info">max_pdu_size</a></code> option). Finally, if segmentation is decided, then each action reply will make up its own (segment) message.</p> </li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
