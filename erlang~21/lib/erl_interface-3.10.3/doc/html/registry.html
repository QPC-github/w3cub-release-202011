
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Registry - Erlang 21 - W3cubDocs</title>
  
  <meta name="description" content=" registry ">
  <meta name="keywords" content="registry, erlang, erlang~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/erlang~21/lib/erl_interface-3.10.3/doc/html/registry.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/erlang~21.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~21/" class="_nav-link" title="" style="margin-left:0;">Erlang 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _erlang">
				
				
<h1>registry</h1> <h2><span onmouseover="document.getElementById('ghlink-c-library-id84324').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-c-library-id84324').style.visibility = 'hidden';" id="c-library">C Library</span></h2> <p class="REFBODY c-library-body">registry</p> <h2><span onmouseover="document.getElementById('ghlink-library-summary-id84327').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-library-summary-id84327').style.visibility = 'hidden';" id="library-summary">Library Summary</span></h2> <p class="REFBODY library-summary-body">Store and back up key-value pairs.</p> <h2><span onmouseover="document.getElementById('ghlink-description-id84331').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-id84331').style.visibility = 'hidden';" id="description">Description</span></h2> 
<p>This module provides support for storing key-value pairs in a table known as a registry, backing up registries to <code>Mnesia</code> in an atomic manner, and later restoring the contents of a registry from <code class="code">Mnesia</code>.</p>  <h2><span onmouseover="document.getElementById('ghlink-exports-id84352').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-exports-id84352').style.visibility = 'hidden';" id="exports">Exports</span></h2> <div class="exports-body"> <h3><code>int ei_reg_close(reg)</code></h3>  <h2 class="func-types-title">Types</h2>   
<p>A registry that has previously been created with <code class="code">ei_reg_open()</code> is closed, and all the objects it contains are freed.</p> <p><code class="code">reg</code> is the registry to close.</p> <p>Returns <code class="code">0</code>.</p>  <h3><code>int ei_reg_delete(reg,key)</code></h3>  <h2 class="func-types-title">Types</h2>    
<p>Deletes an object from the registry. The object is not removed from the registry, it is only marked for later removal so that on later backups to <code class="code">Mnesia</code>, the corresponding object can be removed from the <code class="code">Mnesia</code> table as well. If another object is later created with the same key, the object will be reused. </p> <p>The object is removed from the registry after a call to <code class="code">ei_reg_dump()</code> or <code class="code">ei_reg_purge()</code>. </p> <ul> <li> <code class="code">reg</code> is the registry containing <code class="code">key</code>.</li> <li> <code class="code">key</code> is the object to remove.</li> </ul> <p>Returns <code class="code">0</code> on success, otherwise <code class="code">-1</code>.</p>  <h3><code>int ei_reg_dump(fd,reg,mntab,flags)</code></h3>  <h2 class="func-types-title">Types</h2>      
<p>Dumps the contents of a registry to a <code class="code">Mnesia</code> table in an atomic manner, that is, either all data or no data is updated. If any errors are encountered while backing up the data, the entire operation is aborted.</p> <ul> <li> <code class="code">fd</code> is an open connection to Erlang. <code class="code">Mnesia</code> 3.0 or later must be running on the Erlang node. </li> <li> <code class="code">reg</code> is the registry to back up.</li> <li> <code class="code">mntab</code> is the name of the <code class="code">Mnesia</code> table where the backed up data is to be placed. If the table does not exist, it is created automatically using configurable defaults. For information about configuring this behavior, see <code><span class="code">Mnesia</span></code>.</li> </ul> <p>If <code class="code">flags</code> is <code class="code">0</code>, the backup includes only those objects that have been created, modified, or deleted since the last backup or restore (that is, an incremental backup). After the backup, any objects that were marked dirty are now clean, and any objects that had been marked for deletion are deleted.</p> <p>Alternatively, setting flags to <code class="code">EI_FORCE</code> causes a full backup to be done, and <code class="code">EI_NOPURGE</code> causes the deleted objects to be left in the registry afterwards. These can be bitwise OR'ed together if both behaviors are desired. If <code class="code">EI_NOPURGE</code> was specified, <code class="code">ei_reg_purge()</code> can be used to explicitly remove the deleted items from the registry later.</p> <p>Returns <code class="code">0</code> on success, otherwise <code class="code">-1</code>.</p>  <h3><code>double ei_reg_getfval(reg,key)</code></h3>  <h2 class="func-types-title">Types</h2>    
<p>Gets the value associated with <code class="code">key</code> in the registry. The value must be a floating point type.</p> <ul> <li> <code class="code">reg</code> is the registry where the object will be looked up.</li> <li> <code class="code">key</code> is the name of the object to look up. </li> </ul> <p>On success, the function returns the value associated with <code class="code">key</code>. If the object is not found or if it is not a floating point object, <code class="code">-1.0</code> is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between <code class="code">-1.0</code> and a valid result), use the more general function <code class="code">ei_reg_getval()</code> instead.</p>  <h3><code>int ei_reg_getival(reg,key)</code></h3>  <h2 class="func-types-title">Types</h2>    
<p>Gets the value associated with <code class="code">key</code> in the registry. The value must be an integer.</p> <ul> <li> <code class="code">reg</code> is the registry where the object will be looked up.</li> <li> <code class="code">key</code> is the name of the object to look up. </li> </ul> <p>On success, the function returns the value associated with <code class="code">key</code>. If the object is not found or if it is not an integer object, <code class="code">-1</code> is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between <code class="code">-1</code> and a valid result), use the more general function <code class="code">ei_reg_getval()</code> instead.</p>  <h3><code>const void *ei_reg_getpval(reg,key,size)</code></h3>  <h2 class="func-types-title">Types</h2>     
<p>Gets the value associated with <code class="code">key</code> in the registry. The value must be a binary (pointer) type.</p> <ul> <li> <code class="code">reg</code> is the registry where the object will be looked up.</li> <li> <code class="code">key</code> is the name of the object to look up. </li> <li> <code class="code">size</code> is initialized to contain the length in bytes of the object, if it is found.</li> </ul> <p>On success, the function returns the value associated with <code class="code">key</code> and indicates its length in <code class="code">size</code>. If the object is not found or if it is not a binary object, <code class="code">NULL</code> is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between <code class="code">NULL</code> and a valid result), use the more general function <code class="code">ei_reg_getval()</code> instead.</p>  <h3><code>const char *ei_reg_getsval(reg,key)</code></h3>  <h2 class="func-types-title">Types</h2>    
<p>Gets the value associated with <code class="code">key</code> in the registry. The value must be a string.</p> <ul> <li> <code class="code">reg</code> is the registry where the object will be looked up.</li> <li> <code class="code">key</code> is the name of the object to look up. </li> </ul> <p>On success, the function returns the value associated with <code class="code">key</code>. If the object is not found or if it is not a string, <code class="code">NULL</code> is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between <code class="code">NULL</code> and a valid result), use the more general function <code class="code">ei_reg_getval()</code> instead.</p>  <h3><code>int ei_reg_getval(reg,key,flags,v,...)</code></h3>  <h2 class="func-types-title">Types</h2>      
<p>A general function for retrieving any kind of object from the registry.</p> <ul> <li> <p><code class="code">reg</code> is the registry where the object will be looked up.</p> </li> <li> <p><code class="code">key</code> is the name of the object to look up.</p> </li> <li> <p><code class="code">flags</code> indicates the type of object that you are looking for. If <code class="code">flags</code> is <code class="code">0</code>, any kind of object is returned. If <code class="code">flags</code> is <code class="code">EI_INT</code>, <code class="code">EI_FLT</code>, <code class="code">EI_STR</code>, or <code class="code">EI_BIN</code>, then only values of that kind are returned.</p> <p>The buffer pointed to by <code class="code">v</code> must be large enough to hold the return data, that is, it must be a pointer to one of <code class="code">int</code>, <code class="code">double</code>, <code class="code">char*</code>, or <code class="code">void*</code>, respectively.</p> <p>If <code class="code">flags</code> is <code class="code">EI_BIN</code>, a fifth argument <code class="code">int *size</code> is required, so that the size of the object can be returned.</p> </li> </ul> <p>On success, <code class="code">v</code> (and <code class="code">size</code> if the object is binary) is initialized with the value associated with <code class="code">key</code>, and the function returns <code class="code">EI_INT</code>, <code class="code">EI_FLT</code>, <code class="code">EI_STR</code>, or <code class="code">EI_BIN</code>, indicating the type of object. On failure, <code class="code">-1</code> is returned and the arguments are not updated.</p>  <h3><code>int ei_reg_markdirty(reg,key)</code></h3>  <h2 class="func-types-title">Types</h2>    
<p>Marks a registry object as dirty. This ensures that it is included in the next backup to <code class="code">Mnesia</code>. Normally this operation is not necessary, as all of the normal registry 'set' functions do this automatically. However, if you have retrieved the value of a string or binary object from the registry and modified the contents, then the change is invisible to the registry and the object is assumed to be unmodified. This function allows you to make such modifications and then let the registry know about them.</p> <ul> <li> <code class="code">reg</code> is the registry containing the object. </li> <li> <code class="code">key</code> is the name of the object to mark. </li> </ul> <p>Returns <code class="code">0</code> on success, otherwise <code class="code">-1</code>.</p>  <h3><code>ei_reg *ei_reg_open(size)</code></h3>  <h2 class="func-types-title">Types</h2>   
<p>Opens (creates) a registry, which initially is empty. To close the registry later, use <code class="code">ei_reg_close()</code>.</p> <p><code class="code">size</code> is the approximate number of objects you intend to store in the registry. As the registry uses a hash table with collision chaining, no absolute upper limit exists on the number of objects that can be stored in it. However, for reasons of efficiency, it is a good idea to choose a number that is appropriate for your needs. To change the size later, use <code class="code">ei_reg_resize()</code>. Notice that the number you provide is increased to the nearest larger prime number.</p> <p>Returns an empty registry on success, otherwise <code class="code">NULL</code>.</p>  <h3><code>int ei_reg_purge(reg)</code></h3>  <h2 class="func-types-title">Types</h2>   
<p>Removes all objects marked for deletion. When objects are deleted with <code class="code">ei_reg_delete()</code> they are not removed from the registry, only marked for later removal. On a later backup to <code class="code">Mnesia</code>, the objects can also be removed from the <code class="code">Mnesia</code> table. If you are not backing up to <code class="code">Mnesia</code>, you may wish to remove the objects manually with this function.</p> <p><code class="code">reg</code> is a registry containing objects marked for deletion.</p> <p>Returns <code class="code">0</code> on success, otherwise <code class="code">-1</code>.</p>  <h3><code>int ei_reg_resize(reg,newsize)</code></h3>  <h2 class="func-types-title">Types</h2>    
<p>Changes the size of a registry.</p> <p><code class="code">newsize</code> is the new size to make the registry. The number is increased to the nearest larger prime number.</p> <p>On success, the registry is resized, all contents rehashed, and <code class="code">0</code> is returned. On failure, the registry is left unchanged and <code class="code">-1</code> is returned.</p>  <h3><code>int ei_reg_restore(fd,reg,mntab)</code></h3>  <h2 class="func-types-title">Types</h2>     
<p>The contents of a <code class="code">Mnesia</code> table are read into the registry.</p> <ul> <li> <code class="code">fd</code> is an open connection to Erlang. <code class="code">Mnesia</code> 3.0 or later must be running on the Erlang node. </li> <li> <code class="code">reg</code> is the registry where the data is to be placed.</li> <li> <code class="code">mntab</code> is the name of the <code class="code">Mnesia</code> table to read data from.</li> </ul> <p>Notice that only tables of a certain format can be restored, that is, those that have been created and backed up to with <code class="code">ei_reg_dump()</code>. If the registry was not empty before the operation, the contents of the table are added to the contents of the registry. If the table contains objects with the same keys as those already in the registry, the registry objects are overwritten with the new values. If the registry contains objects that were not in the table, they are unchanged by this operation.</p> <p>After the restore operation, the entire contents of the registry is marked as unmodified. Notice that this includes any objects that were modified before the restore and not overwritten by the restore.</p> <p>Returns <code class="code">0</code> on success, otherwise <code class="code">-1</code>.</p>  <h3><code>int ei_reg_setfval(reg,key,f)</code></h3>  <h2 class="func-types-title">Types</h2>     
<p>Creates a key-value pair with the specified <code class="code">key</code> and floating point value <code class="code">f</code>. If an object already exists with the same <code class="code">key</code>, the new value replaces the old one. If the previous value was a binary or string, it is freed with <code class="code">free()</code>.</p> <ul> <li> <code class="code">reg</code> is the registry where the object is to be placed.</li> <li> <code class="code">key</code> is the object name.</li> <li> <code class="code">f</code> is the floating point value to assign. </li> </ul> <p>Returns <code class="code">0</code> on success, otherwise <code class="code">-1</code>.</p>  <h3><code>int ei_reg_setival(reg,key,i)</code></h3>  <h2 class="func-types-title">Types</h2>     
<p>Creates a key-value pair with the specified <code class="code">key</code> and integer value <code class="code">i</code>. If an object already exists with the same <code class="code">key</code>, the new value replaces the old one. If the previous value was a binary or string, it is freed with <code class="code">free()</code>.</p> <ul> <li> <code class="code">reg</code> is the registry where the object is to be placed.</li> <li> <code class="code">key</code> is the object name.</li> <li> <code class="code">i</code> is the integer value to assign.</li> </ul> <p>Returns <code class="code">0</code> on success, otherwise <code class="code">-1</code>.</p>  <h3><code>int ei_reg_setpval(reg,key,p,size)</code></h3>  <h2 class="func-types-title">Types</h2>      
<p>Creates a key-value pair with the specified <code class="code">key</code> whose "value" is the binary object pointed to by <code class="code">p</code>. If an object already exists with the same <code class="code">key</code>, the new value replaces the old one. If the previous value was a binary or string, it is freed with <code class="code">free()</code>.</p> <ul> <li> <code class="code">reg</code> is the registry where the object is to be placed.</li> <li> <code class="code">key</code> is the object name.</li> <li> <code class="code">p</code> is a pointer to the binary object. The object itself must have been created through a single call to <code class="code">malloc()</code> or a similar function, so that the registry can later delete it if necessary by calling <code class="code">free()</code>.</li> <li> <code class="code">size</code> is the length in bytes of the binary object.</li> </ul> <p>Returns <code class="code">0</code> on success, otherwise <code class="code">-1</code>.</p>  <h3><code>int ei_reg_setsval(reg,key,s)</code></h3>  <h2 class="func-types-title">Types</h2>     
<p>Creates a key-value pair with the specified <code class="code">key</code> whose "value" is the specified string <code class="code">s</code>. If an object already exists with the same <code class="code">key</code>, the new value replaces the old one. If the previous value was a binary or string, it is freed with <code class="code">free()</code>.</p> <ul> <li> <code class="code">reg</code> is the registry where the object is to be placed.</li> <li> <code class="code">key</code> is the object name.</li> <li> <code class="code">s</code> is the string to assign. The string itself must have been created through a single call to <code class="code">malloc()</code> or similar a function, so that the registry can later delete it if necessary by calling <code class="code">free()</code>.</li> </ul> <p>Returns <code class="code">0</code> on success, otherwise <code class="code">-1</code>.</p>  <h3><code>int ei_reg_setval(reg,key,flags,v,...)</code></h3>  <h2 class="func-types-title">Types</h2>      
<p>Creates a key-value pair with the specified <code class="code">key</code> whose value is specified by <code class="code">v</code>. If an object already exists with the same <code class="code">key</code>, the new value replaces the old one. If the previous value was a binary or string, it is freed with <code class="code">free()</code>.</p> <ul> <li> <p><code class="code">reg</code> is the registry where the object is to be placed.</p> </li> <li> <p><code class="code">key</code> is the object name.</p> </li> <li> <p><code class="code">flags</code> indicates the type of the object specified by <code class="code">v</code>. Flags must be one of <code class="code">EI_INT</code>, <code class="code">EI_FLT</code>, <code class="code">EI_STR</code>, and <code class="code">EI_BIN</code>, indicating whether <code class="code">v</code> is <code class="code">int</code>, <code class="code">double</code>, <code class="code">char*</code>, or <code class="code">void*</code>.</p> <p>If <code class="code">flags</code> is <code class="code">EI_BIN</code>, a fifth argument <code class="code">size</code> is required, indicating the size in bytes of the object pointed to by <code class="code">v</code>.</p> </li> </ul> <p>If you wish to store an arbitrary pointer in the registry, specify a <code class="code">size</code> of <code class="code">0</code>. In this case, the object itself is not transferred by an <code class="code">ei_reg_dump()</code> operation, only the pointer value.</p> <p>Returns <code class="code">0</code> on success, otherwise <code class="code">-1</code>.</p>  <h3><code>int ei_reg_stat(reg,key,obuf)</code></h3>  <h2 class="func-types-title">Types</h2>     
<p>Returns information about an object.</p> <ul> <li> <code class="code">reg</code> is the registry containing the object. </li> <li> <code class="code">key</code> is the object name.</li> <li> <code class="code">obuf</code> is a pointer to an <code class="code">ei_reg_stat</code> structure, defined as follows:</li> </ul> <pre data-language="erlang">struct ei_reg_stat {
  int attr;
  int size;
};</pre> <p>In <code class="code">attr</code> the attributes of the object are stored as the logical <strong>OR</strong> of its type (one of <code class="code">EI_INT</code>, <code class="code">EI_FLT</code>, <code class="code">EI_BIN</code>, and <code class="code">EI_STR</code>), whether it is marked for deletion (<code class="code">EI_DELET</code>), and whether it has been modified since the last backup to <code class="code">Mnesia</code> (<code class="code">EI_DIRTY</code>).</p> <p>Field <code class="code">size</code> indicates the size in bytes required to store <code class="code">EI_STR</code> (including the terminating <code class="code">0</code>) and <code class="code">EI_BIN</code> objects, or <code class="code">0</code> for <code class="code">EI_INT</code> and <code class="code">EI_FLT</code>.</p> <p>Returns <code class="code">0</code> and initializes <code class="code">obuf</code> on success, otherwise <code class="code">-1</code>.</p>  <h3><code>int ei_reg_tabstat(reg,obuf)</code></h3>  <h2 class="func-types-title">Types</h2>    
<p>Returns information about a registry. Using information returned by this function, you can see whether the size of the registry is suitable for the amount of data it contains.</p> <ul> <li> <code class="code">reg</code> is the registry to return information about.</li> <li> <code class="code">obuf</code> is a pointer to an <code class="code">ei_reg_tabstat</code> structure, defined as follows: </li> </ul> <pre data-language="erlang">struct ei_reg_tabstat {
  int size;  
  int nelem; 
  int npos;  
  int collisions; 
};</pre> <p>Field <code class="code">size</code> indicates the number of hash positions in the registry. This is the number you provided when you created or last resized the registry, rounded up to the nearest prime number.</p> <ul> <li> <code class="code">nelem</code> indicates the number of elements stored in the registry. It includes objects that are deleted but not purged.</li> <li> <code class="code">npos</code> indicates the number of unique positions that are occupied in the registry.</li> <li> <code class="code">collisions</code> indicates how many elements are sharing positions in the registry.</li> </ul> <p>On success, <code class="code">0</code> is returned and <code class="code">obuf</code> is initialized to contain table statistics, otherwise <code class="code">-1</code> is returned.</p>  </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
