
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Erl_connect - Erlang 21 - W3cubDocs</title>
  
  <meta name="description" content=" erl_connect ">
  <meta name="keywords" content="erl, connect, erlang, erlang~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/erlang~21/lib/erl_interface-3.10.3/doc/html/erl_connect.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/erlang~21.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~21/" class="_nav-link" title="" style="margin-left:0;">Erlang 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _erlang">
				
				
<h1>erl_connect</h1> <h2><span onmouseover="document.getElementById('ghlink-c-library-id86434').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-c-library-id86434').style.visibility = 'hidden';" id="c-library">C Library</span></h2> <p class="REFBODY c-library-body">erl_connect</p> <h2><span onmouseover="document.getElementById('ghlink-library-summary-id86438').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-library-summary-id86438').style.visibility = 'hidden';" id="library-summary">Library Summary</span></h2> <p class="REFBODY library-summary-body">Communicate with distributed Erlang.</p> <h2><span onmouseover="document.getElementById('ghlink-description-id86441').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-id86441').style.visibility = 'hidden';" id="description">Description</span></h2> 
<p>This module provides support for communication between distributed Erlang nodes and C-nodes, in a manner that is transparent to Erlang processes.</p> <p>A C-node appears to Erlang as a <strong>hidden node</strong>. That is, Erlang processes that know the name of the C-node can communicate with it in a normal manner, but the node name does not appear in the listing provided by <code><span class="code">erlang:nodes/0</span></code> in <code class="code">ERTS</code>.</p>  <h2><span onmouseover="document.getElementById('ghlink-exports-id86472').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-exports-id86472').style.visibility = 'hidden';" id="exports">Exports</span></h2> <div class="exports-body"> <h3><code>int erl_accept(listensock, conp)</code></h3>  <h2 class="func-types-title">Types</h2>    
<p>This function is used by a server process to accept a connection from a client process.</p> <ul> <li> <code class="code">listensock</code> is an open socket descriptor on which <code class="code">listen()</code> has previously been called.</li> <li> <code class="code">conp</code> is a pointer to an <code class="code">ErlConnect</code> struct, described as follows:</li> </ul> <pre data-language="erlang">typedef struct {
  char ipadr[4];
  char nodename[MAXNODELEN];
} ErlConnect;</pre> <p>On success, <code class="code">conp</code> is filled in with the address and node name of the connecting client and a file descriptor is returned. On failure, <code class="code">ERL_ERROR</code> is returned and <code class="code">erl_errno</code> is set to <code class="code">EIO</code>.</p>  <h3><code>int erl_close_connection(fd)</code></h3>  <h2 class="func-types-title">Types</h2>   
<p>Closes an open connection to an Erlang node.</p> <p><code class="code">Fd</code> is a file descriptor obtained from <code class="code">erl_connect()</code> or <code class="code">erl_xconnect()</code>.</p> <p>Returns <code class="code">0</code> on success. If the call fails, a non-zero value is returned, and the reason for the error can be obtained with the appropriate platform-dependent call.</p>  <h3>
<code>int erl_connect(node)</code><code>int erl_xconnect(addr, alive)</code>
</h3>  <h2 class="func-types-title">Types</h2>    
<p>Sets up a connection to an Erlang node.</p> <p><code class="code">erl_xconnect()</code> requires the IP address of the remote host and the alivename of the remote node to be specified. <code class="code">erl_connect()</code> provides an alternative interface, and determines the information from the node name provided.</p> <ul> <li> <code class="code">addr</code> is the 32-bit IP address of the remote host.</li> <li> <code class="code">alive</code> is the alivename of the remote node. </li> <li> <code class="code">node</code> is the name of the remote node.</li> </ul> <p>Returns an open file descriptor on success, otherwise a negative value. In the latter case <code class="code">erl_errno</code> is set to one of:</p> <dl> <dt><strong><code class="code">EHOSTUNREACH</code></strong></dt> <dd>The remote host <code class="code">node</code> is unreachable.</dd> <dt><strong><code class="code">ENOMEM</code></strong></dt> <dd>No more memory is available.</dd> <dt><strong><code class="code">EIO</code></strong></dt> <dd>I/O error.</dd> </dl> <p>Also, <code class="code">errno</code> values from <code class="code">socket</code><strong>(2)</strong> and <code class="code">connect</code><strong>(2)</strong> system calls can be propagated into <code class="code">erl_errno</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">#define NODE   "madonna@chivas.du.etx.ericsson.se"
#define ALIVE  "madonna"
#define IP_ADDR "150.236.14.75"

/*** Variant 1 ***/
erl_connect( NODE );

/*** Variant 2 ***/
struct in_addr addr;
addr = inet_addr(IP_ADDR);
erl_xconnect( &amp;addr , ALIVE );</pre>  <h3>
<code>int erl_connect_init(number, cookie, creation)</code><code>int erl_connect_xinit(host, alive, node, addr, cookie, creation)</code>
</h3>  <h2 class="func-types-title">Types</h2>       
<p>Initializes the <code class="code">erl_connect</code> module. In particular, these functions are used to identify the name of the C-node from which they are called. One of these functions must be called before any of the other functions in the <code class="code">erl_connect</code> module are used.</p> <p><code class="code">erl_connect_xinit()</code> stores for later use information about:</p> <ul> <li>Hostname of the node, <code class="code">host</code> </li> <li>Alivename, <code class="code">alive</code> </li> <li>Node name, <code class="code">node</code> </li> <li>IP address, <code class="code">addr</code> </li> <li>Cookie, <code class="code">cookie</code> </li> <li>Creation number, <code class="code">creation</code> </li> </ul> <p><code class="code">erl_connect_init()</code> provides an alternative interface that does not require as much information from the caller. Instead, <code class="code">erl_connect_init()</code> uses <code class="code">gethostbyname()</code> to obtain default values.</p> <p>If you use <code class="code">erl_connect_init()</code>, your node will have a short name, that is, it will not be fully qualified. If you need to use fully qualified (long) names, use <code class="code">erl_connect_xinit()</code> instead.</p> <ul> <li> <p><code class="code">host</code> is the name of the host on which the node is running.</p> </li> <li> <p><code class="code">alive</code> is the alivename of the node.</p> </li> <li> <p><code class="code">node</code> is the node name. It is to be of the form <strong>alivename@hostname</strong>.</p> </li> <li> <p><code class="code">addr</code> is the 32-bit IP address of <code class="code">host</code>.</p> </li> <li> <p><code class="code">cookie</code> is the authorization string required for access to the remote node. If <code class="code">NULL</code>, the user <code class="code">HOME</code> directory is searched for a cookie file <code class="code">.erlang.cookie</code>. The path to the home directory is retrieved from environment variable <code class="code">HOME</code> on Unix and from the <code class="code">HOMEDRIVE</code> and <code class="code">HOMEPATH</code> variables on Windows. For more details, see the <code><span class="code">auth</span></code> module in Kernel.</p> </li> <li> <p><code class="code">creation</code> helps identifying a particular instance of a C-node. In particular, it can help prevent us from receiving messages sent to an earlier process with the same registered name.</p> </li> </ul> <p>A C-node acting as a server is assigned a creation number when it calls <code class="code">erl_publish()</code>.</p> <p><code class="code">number</code> is used by <code class="code">erl_connect_init()</code> to construct the actual node name. In Example 2 below, <strong>"c17@a.DNS.name"</strong> is the resulting node name.</p> <p><strong>Example 1:</strong></p> <pre data-language="erlang">struct in_addr addr;
addr = inet_addr("150.236.14.75");
if (!erl_connect_xinit("chivas",
                       "madonna",
                       "madonna@chivas.du.etx.ericsson.se",
                       &amp;addr;
                       "samplecookiestring..."),
                       0)
  erl_err_quit("&lt;ERROR&gt; when initializing !");</pre> <p><strong>Example 2:</strong></p> <pre data-language="erlang">if (!erl_connect_init(17, "samplecookiestring...", 0))
  erl_err_quit("&lt;ERROR&gt; when initializing !");</pre>  <h3><code>int erl_publish(port)</code></h3>  <h2 class="func-types-title">Types</h2>   
<p>This function is used by a server process to register with the local name server EPMD, thereby allowing other processes to send messages by using the registered name. Before calling this function, the process should have called <code class="code">bind()</code> and <code class="code">listen()</code> on an open socket.</p> <p><code class="code">port</code> is the local name to register, and is to be the same as the port number that was previously bound to the socket.</p> <p>To unregister with EPMD, simply close the returned descriptor.</p> <p>On success, a descriptor connecting the calling process to EPMD is returned. On failure, <code class="code">-1</code> is returned and <code class="code">erl_errno</code> is set to:</p> <dl> <dt><strong><code class="code">EIO</code></strong></dt> <dd>I/O error.</dd> </dl> <p>Also, <code class="code">errno</code> values from <code class="code">socket</code><strong>(2)</strong> and <code class="code">connect</code><strong>(2)</strong> system calls can be propagated into <code class="code">erl_errno</code>.</p>  <h3><code>int erl_receive(fd, bufp, bufsize)</code></h3>  <h2 class="func-types-title">Types</h2>     
<p>Receives a message consisting of a sequence of bytes in the Erlang external format.</p> <ul> <li> <code class="code">fd</code> is an open descriptor to an Erlang connection.</li> <li> <code class="code">bufp</code> is a buffer large enough to hold the expected message.</li> <li> <code class="code">bufsize</code> indicates the size of <code class="code">bufp</code>.</li> </ul> <p>If a <strong>tick</strong> occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns <code class="code">ERL_TICK</code> and no message is placed in the buffer. Also, <code class="code">erl_errno</code> is set to <code class="code">EAGAIN</code>.</p> <p>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns a negative value and sets <code class="code">erl_errno</code> to one of:</p> <dl> <dt><strong><code class="code">EAGAIN</code></strong></dt> <dd>Temporary error: Try again.</dd> <dt><strong><code class="code">EMSGSIZE</code></strong></dt> <dd>Buffer is too small.</dd> <dt><strong><code class="code">EIO</code></strong></dt> <dd>I/O error.</dd> </dl>  <h3><code>int erl_receive_msg(fd, bufp, bufsize, emsg)</code></h3>  <h2 class="func-types-title">Types</h2>      
<p>Receives the message into the specified buffer and decodes into <code class="code">(ErlMessage *) emsg</code>.</p> <ul> <li> <code class="code">fd</code> is an open descriptor to an Erlang connection.</li> <li> <code class="code">bufp</code> is a buffer large enough to hold the expected message.</li> <li> <code class="code">bufsize</code> indicates the size of <code class="code">bufp</code>.</li> <li>&gt;<code class="code">emsg</code> is a pointer to an <code class="code">ErlMessage</code> structure into which the message will be decoded. <code class="code">ErlMessage</code> is defined as follows:</li> </ul> <pre data-language="erlang">typedef struct {
  int type;
  ETERM *msg;
  ETERM *to;
  ETERM *from;
  char to_name[MAXREGLEN];
} ErlMessage;</pre> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The definition of <code class="code">ErlMessage</code> has changed since earlier versions of <code class="code">Erl_Interface</code>.</p> </div> </div> <p><code class="code">type</code> identifies the type of message, one of the following:</p> <dl> <dt><strong><code class="code">ERL_SEND</code></strong></dt> <dd> <p>An ordinary send operation has occurred and <code class="code">emsg-&gt;to</code> contains the pid of the recipient. The message is in <code class="code">emsg-&gt;msg</code>.</p> </dd> <dt><strong><code class="code">ERL_REG_SEND</code></strong></dt> <dd> <p>A registered send operation has occurred and <code class="code">emsg-&gt;from</code> contains the pid of the sender. The message is in <code class="code">emsg-&gt;msg</code>.</p> </dd> <dt><strong><code class="code">ERL_LINK</code> or <code class="code">ERL_UNLINK</code> </strong></dt> <dd> <p><code class="code">emsg-&gt;to</code> and <code class="code">emsg-&gt;from</code> contain the pids of the sender and recipient of the link or unlink. <code class="code">emsg-&gt;msg</code> is not used.</p> </dd> <dt><strong><code class="code">ERL_EXIT</code></strong></dt> <dd> <p>A link is broken. <code class="code">emsg-&gt;to</code> and <code class="code">emsg-&gt;from</code> contain the pids of the linked processes, and <code class="code">emsg-&gt;msg</code> contains the reason for the exit.</p> </dd> </dl> <div class="note"> <div class="label">Note</div> <div class="content">

<p>It is the caller's responsibility to release the memory pointed to by <code class="code">emsg-&gt;msg</code>, <code class="code">emsg-&gt;to</code>, and <code class="code">emsg-&gt;from</code>.</p> </div> </div> <p>If a <strong>tick</strong> occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns <code class="code">ERL_TICK</code> indicating that the tick has been received and responded to, but no message is placed in the buffer. In this case you are to call <code class="code">erl_receive_msg()</code> again.</p> <p>On success, the function returns <code class="code">ERL_MSG</code> and the <code class="code">Emsg</code> struct is initialized as described above, or <code class="code">ERL_TICK</code>, in which case no message is returned. On failure, the function returns <code class="code">ERL_ERROR</code> and sets <code class="code">erl_errno</code> to one of:</p> <dl> <dt><strong><code class="code">EMSGSIZE</code></strong></dt> <dd>Buffer is too small.</dd> <dt><strong><code class="code">ENOMEM</code></strong></dt> <dd>No more memory is available.</dd> <dt><strong><code class="code">EIO</code></strong></dt> <dd>I/O error.</dd> </dl>  <h3><code>int erl_reg_send(fd, to, msg)</code></h3>  <h2 class="func-types-title">Types</h2>     
<p>Sends an Erlang term to a registered process.</p> <ul> <li> <code class="code">fd</code> is an open descriptor to an Erlang connection.</li> <li> <code class="code">to</code> is a string containing the registered name of the intended recipient of the message.</li> <li> <code class="code">msg</code> is the Erlang term to be sent.</li> </ul> <p>Returns <code class="code">1</code> on success, otherwise <code class="code">0</code>. In the latter case <code class="code">erl_errno</code> is set to one of:</p> <dl> <dt><strong><code class="code">ENOMEM</code></strong></dt> <dd>No more memory is available.</dd> <dt><strong><code class="code">EIO</code></strong></dt> <dd>I/O error.</dd> </dl>  <h3>
<code>ETERM *erl_rpc(fd, mod, fun, args)</code><code>int erl_rpc_from(fd, timeout, emsg)</code><code>int erl_rpc_to(fd, mod, fun, args)</code>
</h3>  <h2 class="func-types-title">Types</h2>      
<p>Supports calling Erlang functions on remote nodes. <code class="code">erl_rpc_to()</code> sends an RPC request to a remote node and <code class="code">erl_rpc_from()</code> receives the results of such a call. <code class="code">erl_rpc()</code> combines the functionality of these two functions by sending an RPC request and waiting for the results. See also <code><span class="code">rpc:call/4</span></code> in <code class="code">Kernel</code>.</p> <ul> <li> <code class="code">fd</code> is an open descriptor to an Erlang connection.</li> <li> <code class="code">timeout</code> is the maximum time (in milliseconds) to wait for results. To wait forever, specify <code class="code">ERL_NO_TIMEOUT</code>. When <code class="code">erl_rpc()</code> calls <code class="code">erl_rpc_from()</code>, the call will never timeout.</li> <li> <code class="code">mod</code> is the name of the module containing the function to be run on the remote node.</li> <li> <code class="code">fun</code> is the name of the function to run. </li> <li> <code class="code">args</code> is an Erlang list, containing the arguments to be passed to the function.</li> <li> <code class="code">emsg</code> is a message containing the result of the function call.</li> </ul> <p>The actual message returned by the RPC server is a 2-tuple <code class="code">{rex,Reply}</code>. If you use <code class="code">erl_rpc_from()</code> in your code, this is the message you will need to parse. If you use <code class="code">erl_rpc()</code>, the tuple itself is parsed for you, and the message returned to your program is the Erlang term containing <code class="code">Reply</code> only. Replies to RPC requests are always <code class="code">ERL_SEND</code> messages.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>It is the caller's responsibility to free the returned <code class="code">ETERM</code> structure and the memory pointed to by <code class="code">emsg-&gt;msg</code> and <code class="code">emsg-&gt;to</code>.</p> </div> </div> <p><code class="code">erl_rpc()</code> returns the remote function's return value on success, otherwise <code class="code">NULL</code>.</p> <p><code class="code">erl_rpc_to()</code> returns <code class="code">0</code> on success, otherwise a negative number.</p> <p><code class="code">erl_rcp_from()</code> returns <code class="code">ERL_MSG</code> on success (with <code class="code">Emsg</code> now containing the reply tuple), otherwise one of <code class="code">ERL_TICK</code>, <code class="code">ERL_TIMEOUT</code>, or <code class="code">ERL_ERROR</code>.</p> <p>When failing, all three functions set <code class="code">erl_errno</code> to one of:</p> <dl> <dt><strong><code class="code">ENOMEM</code></strong></dt> <dd>No more memory is available.</dd> <dt><strong><code class="code">EIO</code></strong></dt> <dd>I/O error.</dd> <dt><strong><code class="code">ETIMEDOUT</code></strong></dt> <dd>Timeout has expired.</dd> <dt><strong><code class="code">EAGAIN</code></strong></dt> <dd>Temporary error: Try again.</dd> </dl>  <h3><code>int erl_send(fd, to, msg)</code></h3>  <h2 class="func-types-title">Types</h2>    
<p>Sends an Erlang term to a process.</p> <ul> <li> <code class="code">fd</code> is an open descriptor to an Erlang connection.</li> <li> <code class="code">to</code> is an Erlang term containing the pid of the intended recipient of the message.</li> <li>&gt;<code class="code">msg</code> is the Erlang term to be sent.</li> </ul> <p>Returns <code class="code">1</code> on success, otherwise <code class="code">0</code>. In the latter case <code class="code">erl_errno</code> is set to one of:</p> <dl> <dt><strong><code class="code">EINVAL</code></strong></dt> <dd>Invalid argument: <code class="code">to</code> is not a valid Erlang pid.</dd> <dt><strong><code class="code">ENOMEM</code></strong></dt> <dd>No more memory is available.</dd> <dt><strong><code class="code">EIO</code></strong></dt> <dd>I/O error.</dd> </dl>  <h3>
<code>const char *erl_thisalivename()</code><code>const char *erl_thiscookie()</code><code>short erl_thiscreation()</code><code>const char *erl_thishostname()</code><code>const char *erl_thisnodename()</code>
</h3> 
<p>Retrieves information about the C-node. These values are initially set with <code class="code">erl_connect_init()</code> or <code class="code">erl_connect_xinit()</code>.</p>  <h3><code>int erl_unpublish(alive)</code></h3>  <h2 class="func-types-title">Types</h2>   
<p>This function can be called by a process to unregister a specified node from EPMD on the local host. This is, however, usually not allowed, unless EPMD was started with flag <code class="code">-relaxed_command_check</code>, which it normally is not.</p> <p>To unregister a node you have published, you should instead close the descriptor that was returned by <code class="code">ei_publish()</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is deprecated and will be removed in a future release.</p> </div> </div> <p><code class="code">alive</code> is the name of the node to unregister, that is, the first component of the node name, without <code class="code">@hostname</code>.</p> <p>If the node was successfully unregistered from EPMD, <code class="code">0</code> is returned, otherwise <code class="code">-1</code> is returned and <code class="code">erl_errno</code> is set to <code class="code">EIO</code>.</p>  <h3><code>int erl_xreceive_msg(fd, bufpp, bufsizep, emsg)</code></h3>  <h2 class="func-types-title">Types</h2>      
<p>Similar to <code class="code">erl_receive_msg</code>. The difference is that <code class="code">erl_xreceive_msg</code> expects the buffer to have been allocated by <code class="code">malloc</code>, and reallocates it if the received message does not fit into the original buffer. Therefore both buffer and buffer length are given as pointers; their values can change by the call.</p> <p>On success, the function returns <code class="code">ERL_MSG</code> and the <code class="code">Emsg</code> struct is initialized as described above, or <code class="code">ERL_TICK</code>, in which case no message is returned. On failure, the function returns <code class="code">ERL_ERROR</code> and sets <code class="code">erl_errno</code> to one of:</p> <dl> <dt><strong><code class="code">EMSGSIZE</code></strong></dt> <dd>Buffer is too small.</dd> <dt><strong><code class="code">ENOMEM</code></strong></dt> <dd>No more memory is available.</dd> <dt><strong><code class="code">EIO</code></strong></dt> <dd>I/O error.</dd> </dl>  <h3>
<code>struct hostent *erl_gethostbyaddr(addr, length, type)</code><code>struct hostent *erl_gethostbyaddr_r(addr, length, type, hostp, buffer, buflen, h_errnop)</code><code>struct hostent *erl_gethostbyname(name)</code><code>struct hostent *erl_gethostbyname_r(name, hostp, buffer, buflen, h_errnop)</code>
</h3>  <h2 class="func-types-title">Types</h2>          
<p>Convenience functions for some common name lookup functions.</p>  </div> <h2><span onmouseover="document.getElementById('ghlink-debug-information-id88439').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-debug-information-id88439').style.visibility = 'hidden';" id="debug-information">Debug Information</span></h2>  <p>If a connection attempt fails, the following can be checked:</p> <ul> <li><code class="code">erl_errno</code></li> <li>That the correct cookie was used</li> <li>That EPMD is running</li> <li>That the remote Erlang node on the other side is running the same version of Erlang as the <code class="code">erl_interface</code> library</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
