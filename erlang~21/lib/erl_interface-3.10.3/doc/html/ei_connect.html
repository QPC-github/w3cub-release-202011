
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Ei_connect - Erlang 21 - W3cubDocs</title>
  
  <meta name="description" content=" ei_connect ">
  <meta name="keywords" content="ei, connect, erlang, erlang~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/erlang~21/lib/erl_interface-3.10.3/doc/html/ei_connect.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/erlang~21.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~21/" class="_nav-link" title="" style="margin-left:0;">Erlang 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _erlang">
				
				
<h1>ei_connect</h1> <h2><span onmouseover="document.getElementById('ghlink-c-library-id81846').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-c-library-id81846').style.visibility = 'hidden';" id="c-library">C Library</span></h2> <p class="REFBODY c-library-body">ei_connect</p> <h2><span onmouseover="document.getElementById('ghlink-library-summary-id81850').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-library-summary-id81850').style.visibility = 'hidden';" id="library-summary">Library Summary</span></h2> <p class="REFBODY library-summary-body">Communicate with distributed Erlang.</p> <h2><span onmouseover="document.getElementById('ghlink-description-id81854').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-description-id81854').style.visibility = 'hidden';" id="description">Description</span></h2> 
<p>This module enables C-programs to communicate with Erlang nodes, using the Erlang distribution over TCP/IP.</p> <p>A C-node appears to Erlang as a <strong>hidden node</strong>. That is, Erlang processes that know the name of the C-node can communicate with it in a normal manner, but the node name is not shown in the listing provided by <code><span class="code">erlang:nodes/0</span></code> in <code class="code">ERTS</code>.</p> <p>The environment variable <code class="code">ERL_EPMD_PORT</code> can be used to indicate which logical cluster a C-node belongs to.</p>  <h2><span onmouseover="document.getElementById('ghlink-time-out-functions-id81893').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-time-out-functions-id81893').style.visibility = 'hidden';" id="time-out-functions">Time-Out Functions</span></h2>  <p>Most functions appear in a version with the suffix <code class="code">_tmo</code> appended to the function name. Those functions take an extra argument, a time-out in <strong>milliseconds</strong>. The semantics is this: for each communication primitive involved in the operation, if the primitive does not complete within the time specified, the function returns an error and <code class="code">erl_errno</code> is set to <code class="code">ETIMEDOUT</code>. With communication primitive is meant an operation on the socket, like <code class="code">connect</code>, <code class="code">accept</code>, <code class="code">recv</code>, or <code class="code">send</code>.</p> <p>Clearly the time-outs are for implementing fault tolerance, not to keep hard real-time promises. The <code class="code">_tmo</code> functions are for detecting non-responsive peers and to avoid blocking on socket operations.</p> <p>A time-out value of <code class="code">0</code> (zero) means that time-outs are disabled. Calling a <code class="code">_tmo</code> function with the last argument as <code class="code">0</code> is therefore the same thing as calling the function without the <code class="code">_tmo</code> suffix.</p> <p>As with all other functions starting with <code class="code">ei_</code>, you are <strong>not</strong> expected to put the socket in non-blocking mode yourself in the program. Every use of non-blocking mode is embedded inside the time-out functions. The socket will always be back in blocking mode after the operations are completed (regardless of the result). To avoid problems, leave the socket options alone. <code class="code">ei</code> handles any socket options that need modification.</p> <p>In all other senses, the <code class="code">_tmo</code> functions inherit all the return values and the semantics from the functions without the <code class="code">_tmo</code> suffix.</p>  <h2><span onmouseover="document.getElementById('ghlink-exports-id81999').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-exports-id81999').style.visibility = 'hidden';" id="exports">Exports</span></h2> <div class="exports-body"> <h3>
<code>struct hostent *ei_gethostbyaddr(const char *addr, int len, int type)</code><code>struct hostent *ei_gethostbyaddr_r(const char *addr, int length, int type, struct hostent *hostp, char *buffer, int buflen, int *h_errnop)</code><code>struct hostent *ei_gethostbyname(const char *name)</code><code>struct hostent *ei_gethostbyname_r(const char *name, struct hostent *hostp, char *buffer, int buflen, int *h_errnop)</code>
</h3> 
<p>Convenience functions for some common name lookup functions.</p>  <h3><code>int ei_accept(ei_cnode *ec, int listensock, ErlConnect *conp)</code></h3> 
<p>Used by a server process to accept a connection from a client process.</p> <ul> <li> <p><code class="code">ec</code> is the C-node structure.</p> </li> <li> <p><code class="code">listensock</code> is an open socket descriptor on which <code class="code">listen()</code> has previously been called.</p> </li> <li> <p><code class="code">conp</code> is a pointer to an <code class="code">ErlConnect</code> struct, described as follows:</p> <pre data-language="erlang">typedef struct {
  char ipadr[4];             
  char nodename[MAXNODELEN];
} ErlConnect;</pre> </li> </ul> <p>On success, <code class="code">conp</code> is filled in with the address and node name of the connecting client and a file descriptor is returned. On failure, <code class="code">ERL_ERROR</code> is returned and <code class="code">erl_errno</code> is set to <code class="code">EIO</code>.</p>  <h3><code>int ei_accept_tmo(ei_cnode *ec, int listensock, ErlConnect *conp, unsigned timeout_ms)</code></h3> 
<p>Equivalent to <code class="code">ei_accept</code> with an optional time-out argument, see the description at the beginning of this manual page.</p>  <h3>
<code>int ei_connect(ei_cnode* ec, char *nodename)</code><code>int ei_xconnect(ei_cnode* ec, Erl_IpAddr adr, char *alivename)</code>
</h3> 
<p>Sets up a connection to an Erlang node.</p> <p><code class="code">ei_xconnect()</code> requires the IP address of the remote host and the alive name of the remote node to be specified. <code class="code">ei_connect()</code> provides an alternative interface and determines the information from the node name provided.</p> <ul> <li> <code class="code">addr</code> is the 32-bit IP address of the remote host.</li> <li> <code class="code">alive</code> is the alivename of the remote node. </li> <li> <code class="code">node</code> is the name of the remote node.</li> </ul> <p>These functions return an open file descriptor on success, or a negative value indicating that an error occurred. In the latter case they set <code class="code">erl_errno</code> to one of the following:</p> <dl> <dt><strong><code class="code">EHOSTUNREACH</code></strong></dt> <dd>The remote host <code class="code">node</code> is unreachable.</dd> <dt><strong><code class="code">ENOMEM</code></strong></dt> <dd>No more memory is available.</dd> <dt><strong><code class="code">EIO</code></strong></dt> <dd>I/O error.</dd> </dl> <p>Also, <code class="code">errno</code> values from <code class="code">socket</code><strong>(2)</strong> and <code class="code">connect</code><strong>(2)</strong> system calls may be propagated into <code class="code">erl_errno</code>.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">#define NODE   "madonna@chivas.du.etx.ericsson.se"
#define ALIVE  "madonna"
#define IP_ADDR "150.236.14.75"

/*** Variant 1 ***/
int fd = ei_connect(&amp;ec, NODE);

/*** Variant 2 ***/
struct in_addr addr;
addr.s_addr = inet_addr(IP_ADDR);
fd = ei_xconnect(&amp;ec, &amp;addr, ALIVE);</pre>  <h3>
<code>int ei_connect_init(ei_cnode* ec, const char* this_node_name, const char *cookie, short creation)</code><code>int ei_connect_xinit(ei_cnode* ec, const char *thishostname, const char *thisalivename, const char *thisnodename, Erl_IpAddr thisipaddr, const char *cookie, short creation)</code>
</h3> 
<p>Initializes the <code class="code">ec</code> structure, to identify the node name and cookie of the server. One of them must be called before other functions that works on the <code class="code">ei_cnode</code> type or a file descriptor associated with a connection to another node is used.</p> <ul> <li> <p><code class="code">ec</code> is a structure containing information about the C-node. It is used in other <code class="code">ei</code> functions for connecting and receiving data.</p> </li> <li> <p><code class="code">this_node_name</code> is the registered name of the process (the name before '@').</p> </li> <li> <p><code class="code">cookie</code> is the cookie for the node.</p> </li> <li> <p><code class="code">creation</code> identifies a specific instance of a C-node. It can help prevent the node from receiving messages sent to an earlier process with the same registered name.</p> </li> <li> <p><code class="code">thishostname</code> is the name of the machine we are running on. If long names are to be used, they are to be fully qualified (that is, <code class="code">durin.erix.ericsson.se</code> instead of <code class="code">durin</code>).</p> </li> <li> <p><code class="code">thisalivename</code> is the registered name of the process.</p> </li> <li> <p><code class="code">thisnodename</code> is the full name of the node, that is, <code class="code">einode@durin</code>.</p> </li> <li> <p><code class="code">thispaddr</code> if the IP address of the host.</p> </li> </ul> <p>A C-node acting as a server is assigned a creation number when it calls <code class="code">ei_publish()</code>.</p> <p>A connection is closed by simply closing the socket. For information about how to close the socket gracefully (when there are outgoing packets before close), see the relevant system documentation.</p> <p>These functions return a negative value indicating that an error occurred.</p> <p><strong>Example 1:</strong></p> <pre data-language="erlang">int n = 0;
struct in_addr addr;
ei_cnode ec;
addr.s_addr = inet_addr("150.236.14.75");
if (ei_connect_xinit(&amp;ec,
                     "chivas",
                     "madonna",
                     "madonna@chivas.du.etx.ericsson.se",
                     &amp;addr;
                     "cookie...",
                     n++) &lt; 0) {
    fprintf(stderr,"ERROR when initializing: %d",erl_errno);
    exit(-1);
}</pre> <p><strong>Example 2:</strong></p> <pre data-language="erlang">if (ei_connect_init(&amp;ec, "madonna", "cookie...", n++) &lt; 0) {
    fprintf(stderr,"ERROR when initializing: %d",erl_errno);
    exit(-1);
}</pre>  <h3>
<code>int ei_connect_tmo(ei_cnode* ec, char *nodename, unsigned timeout_ms)</code><code>int ei_xconnect_tmo(ei_cnode* ec, Erl_IpAddr adr, char *alivename, unsigned timeout_ms)</code>
</h3> 
<p>Equivalent to <code class="code">ei_connect</code> and <code class="code">ei_xconnect</code> with an optional time-out argument, see the description at the beginning of this manual page.</p>  <h3>
<code>int ei_get_tracelevel(void)</code><code>void ei_set_tracelevel(int level)</code>
</h3> 
<p>Used to set tracing on the distribution. The levels are different verbosity levels. A higher level means more information. See also section <code><a href="#debug_information">Debug Information</a></code>.</p> <p>These functions are not thread safe.</p>  <h3><code>int ei_publish(ei_cnode *ec, int port)</code></h3> 
<p>Used by a server process to register with the local name server EPMD, thereby allowing other processes to send messages by using the registered name. Before calling either of these functions, the process should have called <code class="code">bind()</code> and <code class="code">listen()</code> on an open socket.</p> <ul> <li> <p><code class="code">ec</code> is the C-node structure.</p> </li> <li> <p><code class="code">port</code> is the local name to register, and is to be the same as the port number that was previously bound to the socket.</p> </li> <li> <p><code class="code">addr</code> is the 32-bit IP address of the local host.</p> </li> </ul> <p>To unregister with EPMD, simply close the returned descriptor. Do not use <code class="code">ei_unpublish()</code>, which is deprecated anyway.</p> <p>On success, the function returns a descriptor connecting the calling process to EPMD. On failure, <code class="code">-1</code> is returned and <code class="code">erl_errno</code> is set to <code class="code">EIO</code>.</p> <p>Also, <code class="code">errno</code> values from <code class="code">socket</code><strong>(2)</strong> and <code class="code">connect</code><strong>(2)</strong> system calls may be propagated into <code class="code">erl_errno</code>.</p>  <h3><code>int ei_publish_tmo(ei_cnode *ec, int port, unsigned timeout_ms)</code></h3> 
<p>Equivalent to <code class="code">ei_publish</code> with an optional time-out argument, see the description at the beginning of this manual page.</p>  <h3><code>int ei_receive(int fd, unsigned char* bufp, int bufsize)</code></h3> 
<p>Receives a message consisting of a sequence of bytes in the Erlang external format.</p> <ul> <li> <p><code class="code">fd</code> is an open descriptor to an Erlang connection. It is obtained from a previous <code class="code">ei_connect</code> or <code class="code">ei_accept</code>.</p> </li> <li> <p><code class="code">bufp</code> is a buffer large enough to hold the expected message.</p> </li> <li> <p><code class="code">bufsize</code> indicates the size of <code class="code">bufp</code>.</p> </li> </ul> <p>If a <strong>tick</strong> occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns <code class="code">ERL_TICK</code> and no message is placed in the buffer. Also, <code class="code">erl_errno</code> is set to <code class="code">EAGAIN</code>.</p> <p>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns <code class="code">ERL_ERROR</code> and sets <code class="code">erl_errno</code> to one of the following:</p> <dl> <dt><strong><code class="code">EAGAIN</code></strong></dt> <dd>Temporary error: Try again.</dd> <dt><strong><code class="code">EMSGSIZE</code></strong></dt> <dd>Buffer is too small.</dd> <dt><strong><code class="code">EIO</code></strong></dt> <dd>I/O error.</dd> </dl>  <h3><code>int ei_receive_encoded(int fd, char **mbufp, int *bufsz, erlang_msg *msg, int *msglen)</code></h3> 
<p>This function is retained for compatibility with code generated by the interface compiler and with code following examples in the same application.</p> <p>In essence, the function performs the same operation as <code class="code">ei_xreceive_msg</code>, but instead of using an <code class="code">ei_x_buff</code>, the function expects a pointer to a character pointer (<code class="code">mbufp</code>), where the character pointer is to point to a memory area allocated by <code class="code">malloc</code>. Argument <code class="code">bufsz</code> is to be a pointer to an integer containing the exact size (in bytes) of the memory area. The function may reallocate the memory area and will in such cases put the new size in <code class="code">*bufsz</code> and update <code class="code">*mbufp</code>.</p> <p>Returns either <code class="code">ERL_TICK</code> or the <code class="code">msgtype</code> field of the <code class="code">erlang_msg *msg</code>. The length of the message is put in <code class="code">*msglen</code>. On error a value <code class="code">&lt; 0</code> is returned.</p> <p>It is recommended to use <code class="code">ei_xreceive_msg</code> instead when possible, for the sake of readability. However, the function will be retained in the interface for compatibility and will <strong>not</strong> be removed in future releases without prior notice.</p>  <h3><code>int ei_receive_encoded_tmo(int fd, char **mbufp, int *bufsz, erlang_msg *msg, int *msglen, unsigned timeout_ms)</code></h3> 
<p>Equivalent to <code class="code">ei_receive_encoded</code> with an optional time-out argument, see the description at the beginning of this manual page.</p>  <h3>
<code>int ei_receive_msg(int fd, erlang_msg* msg, ei_x_buff* x)</code><code>int ei_xreceive_msg(int fd, erlang_msg* msg, ei_x_buff* x)</code>
</h3> 
<p>Receives a message to the buffer in <code class="code">x</code>. <code class="code">ei_xreceive_msg</code> allows the buffer in <code class="code">x</code> to grow, but <code class="code">ei_receive_msg</code> fails if the message is larger than the pre-allocated buffer in <code class="code">x</code>.</p> <ul> <li> <code class="code">fd</code> is an open descriptor to an Erlang connection.</li> <li> <code class="code">msg</code> is a pointer to an <code class="code">erlang_msg</code> structure and contains information on the message received.</li> <li> <code class="code">x</code> is buffer obtained from <code class="code">ei_x_new</code>.</li> </ul> <p>On success, the functions return <code class="code">ERL_MSG</code> and the <code class="code">msg</code> struct is initialized. <code class="code">erlang_msg</code> is defined as follows:</p> <pre data-language="erlang">typedef struct {
    long msgtype;
    erlang_pid from;
    erlang_pid to;
    char toname[MAXATOMLEN+1];
    char cookie[MAXATOMLEN+1];
    erlang_trace token;
} erlang_msg;</pre> <p><code class="code">msgtype</code> identifies the type of message, and is one of the following:</p> <dl> <dt><strong><code class="code">ERL_SEND</code></strong></dt> <dd> <p>Indicates that an ordinary send operation has occurred. <code class="code">msg-&gt;to</code> contains the pid of the recipient (the C-node).</p> </dd> <dt><strong><code class="code">ERL_REG_SEND</code></strong></dt> <dd> <p>A registered send operation occurred. <code class="code">msg-&gt;from</code> contains the pid of the sender.</p> </dd> <dt><strong><code class="code">ERL_LINK</code> or <code class="code">ERL_UNLINK</code></strong></dt> <dd> <p><code class="code">msg-&gt;to</code> and <code class="code">msg-&gt;from</code> contain the pids of the sender and recipient of the link or unlink.</p> </dd> <dt><strong><code class="code">ERL_EXIT</code></strong></dt> <dd> <p>Indicates a broken link. <code class="code">msg-&gt;to</code> and <code class="code">msg-&gt;from</code> contain the pids of the linked processes.</p> </dd> </dl> <p>The return value is the same as for <code><a href="#ei_receive"><span class="code">ei_receive</span></a></code>.</p>  <h3>
<code>int ei_receive_msg_tmo(int fd, erlang_msg* msg, ei_x_buff* x, unsigned imeout_ms)</code><code>int ei_xreceive_msg_tmo(int fd, erlang_msg* msg, ei_x_buff* x, unsigned timeout_ms)</code>
</h3> 
<p>Equivalent to <code class="code">ei_receive_msg</code> and <code class="code">ei_xreceive_msg</code> with an optional time-out argument, see the description at the beginning of this manual page.</p>  <h3><code>int ei_receive_tmo(int fd, unsigned char* bufp, int bufsize, unsigned timeout_ms)</code></h3> 
<p>Equivalent to <code class="code">ei_receive</code> with an optional time-out argument, see the description at the beginning of this manual page.</p>  <h3><code>int ei_reg_send(ei_cnode* ec, int fd, char* server_name, char* buf, int len)</code></h3> 
<p>Sends an Erlang term to a registered process.</p> <ul> <li> <p><code class="code">fd</code> is an open descriptor to an Erlang connection.</p> </li> <li> <code class="code">server_name</code> is the registered name of the intended recipient.</li> <li> <code class="code">buf</code> is the buffer containing the term in binary format.</li> <li> <code class="code">len</code> is the length of the message in bytes. </li> </ul> <p>Returns <code class="code">0</code> if successful, otherwise <code class="code">-1</code>. In the latter case it sets <code class="code">erl_errno</code> to <code class="code">EIO</code>.</p> <p><strong>Example:</strong></p> <p>Send the atom "ok" to the process "worker":</p> <pre data-language="erlang">ei_x_buff x;
ei_x_new_with_version(&amp;x);
ei_x_encode_atom(&amp;x, "ok");
if (ei_reg_send(&amp;ec, fd, x.buff, x.index) &lt; 0)
    handle_error();</pre>  <h3><code>int ei_reg_send_tmo(ei_cnode* ec, int fd, char* server_name, char* buf, int len, unsigned timeout_ms)</code></h3> 
<p>Equivalent to <code class="code">ei_reg_send</code> with an optional time-out argument, see the description at the beginning of this manual page.</p>  <h3>
<code>int ei_rpc(ei_cnode *ec, int fd, char *mod, char *fun, const char *argbuf, int argbuflen, ei_x_buff *x)</code><code>int ei_rpc_to(ei_cnode *ec, int fd, char *mod, char *fun, const char *argbuf, int argbuflen)</code><code>int ei_rpc_from(ei_cnode *ec, int fd, int timeout, erlang_msg *msg, ei_x_buff *x)</code>
</h3> 
<p>Supports calling Erlang functions on remote nodes. <code class="code">ei_rpc_to()</code> sends an RPC request to a remote node and <code class="code">ei_rpc_from()</code> receives the results of such a call. <code class="code">ei_rpc()</code> combines the functionality of these two functions by sending an RPC request and waiting for the results. See also <code><span class="code">rpc:call/4</span></code> in Kernel.</p> <ul> <li> <p><code class="code">ec</code> is the C-node structure previously initiated by a call to <code class="code">ei_connect_init()</code> or <code class="code">ei_connect_xinit()</code>.</p> </li> <li> <p><code class="code">fd</code> is an open descriptor to an Erlang connection.</p> </li> <li> <p><code class="code">timeout</code> is the maximum time (in milliseconds) to wait for results. Specify <code class="code">ERL_NO_TIMEOUT</code> to wait forever. <code class="code">ei_rpc()</code> waits infinitely for the answer, that is, the call will never time out.</p> </li> <li> <p><code class="code">mod</code> is the name of the module containing the function to be run on the remote node.</p> </li> <li> <p><code class="code">fun</code> is the name of the function to run.</p> </li> <li> <p><code class="code">argbuf</code> is a pointer to a buffer with an encoded Erlang list, without a version magic number, containing the arguments to be passed to the function.</p> </li> <li> <p><code class="code">argbuflen</code> is the length of the buffer containing the encoded Erlang list.</p> </li> <li> <p><code class="code">msg</code> is structure of type <code class="code">erlang_msg</code> and contains information on the message received. For a description of the <code class="code">erlang_msg</code> format, see <code><a href="#ei_receive_msg"><span class="code">ei_receive_msg</span></a></code>.</p> </li> <li> <p><code class="code">x</code> points to the dynamic buffer that receives the result. For <code class="code">ei_rpc()</code> this is the result without the version magic number. For <code class="code">ei_rpc_from()</code> the result returns a version magic number and a 2-tuple <code class="code">{rex,Reply}</code>.</p> </li> </ul> <p><code class="code">ei_rpc()</code> returns the number of bytes in the result on success and <code class="code">-1</code> on failure. <code class="code">ei_rpc_from()</code> returns the number of bytes, otherwise one of <code class="code">ERL_TICK</code>, <code class="code">ERL_TIMEOUT</code>, and <code class="code">ERL_ERROR</code>. When failing, all three functions set <code class="code">erl_errno</code> to one of the following:</p> <dl> <dt><strong><code class="code">EIO</code></strong></dt> <dd>I/O error.</dd> <dt><strong><code class="code">ETIMEDOUT</code></strong></dt> <dd>Time-out expired.</dd> <dt><strong><code class="code">EAGAIN</code></strong></dt> <dd>Temporary error: Try again.</dd> </dl> <p><strong>Example:</strong></p> <p>Check to see if an Erlang process is alive:</p> <pre data-language="erlang">int index = 0, is_alive;
ei_x_buff args, result;

ei_x_new(&amp;result);
ei_x_new(&amp;args);
ei_x_encode_list_header(&amp;args, 1);
ei_x_encode_pid(&amp;args, &amp;check_pid);
ei_x_encode_empty_list(&amp;args);

if (ei_rpc(&amp;ec, fd, "erlang", "is_process_alive",
           args.buff, args.index, &amp;result) &lt; 0)
    handle_error();

if (ei_decode_version(result.buff, &amp;index) &lt; 0
    || ei_decode_bool(result.buff, &amp;index, &amp;is_alive) &lt; 0)
    handle_error();</pre>  <h3><code>erlang_pid *ei_self(ei_cnode *ec)</code></h3> 
<p>Retrieves the pid of the C-node. Every C-node has a (pseudo) pid used in <code class="code">ei_send_reg</code>, <code class="code">ei_rpc</code>, and others. This is contained in a field in the <code class="code">ec</code> structure. It will be safe for a long time to fetch this field directly from the <code class="code">ei_cnode</code> structure.</p>  <h3><code>int ei_send(int fd, erlang_pid* to, char* buf, int len)</code></h3> 
<p>Sends an Erlang term to a process.</p> <ul> <li> <code class="code">fd</code> is an open descriptor to an Erlang connection.</li> <li> <code class="code">to</code> is the pid of the intended recipient of the message.</li> <li> <code class="code">buf</code> is the buffer containing the term in binary format.</li> <li> <code class="code">len</code> is the length of the message in bytes. </li> </ul> <p>Returns <code class="code">0</code> if successful, otherwise <code class="code">-1</code>. In the latter case it sets <code class="code">erl_errno</code> to <code class="code">EIO</code>.</p>  <h3><code>int ei_send_encoded(int fd, erlang_pid* to, char* buf, int len)</code></h3> 
<p>Works exactly as <code class="code">ei_send</code>, the alternative name is retained for backward compatibility. The function will <strong>not</strong> be removed without prior notice.</p>  <h3><code>int ei_send_encoded_tmo(int fd, erlang_pid* to, char* buf, int len, unsigned timeout_ms)</code></h3> 
<p>Equivalent to <code class="code">ei_send_encoded</code> with an optional time-out argument, see the description at the beginning of this manual page.</p>  <h3><code>int ei_send_reg_encoded(int fd, const erlang_pid *from, const char *to, const char *buf, int len)</code></h3> 
<p>This function is retained for compatibility with code generated by the interface compiler and with code following examples in the same application.</p> <p>The function works as <code class="code">ei_reg_send</code> with one exception. Instead of taking <code class="code">ei_cnode</code> as first argument, it takes a second argument, an <code class="code">erlang_pid</code>, which is to be the process identifier of the sending process (in the Erlang distribution protocol).</p> <p>A suitable <code class="code">erlang_pid</code> can be constructed from the <code class="code">ei_cnode</code> structure by the following example code:</p> <pre data-language="erlang">ei_cnode ec;
erlang_pid *self;
int fd; /* the connection fd */
...
self = ei_self(&amp;ec);
self-&gt;num = fd;</pre>  <h3><code>int ei_send_reg_encoded_tmo(int fd, const erlang_pid *from, const char *to, const char *buf, int len)</code></h3> 
<p>Equivalent to <code class="code">ei_send_reg_encoded</code> with an optional time-out argument, see the description at the beginning of this manual page.</p>  <h3><code>int ei_send_tmo(int fd, erlang_pid* to, char* buf, int len, unsigned timeout_ms)</code></h3> 
<p>Equivalent to <code class="code">ei_send</code> with an optional time-out argument, see the description at the beginning of this manual page.</p>  <h3>
<code>const char *ei_thisnodename(ei_cnode *ec)</code><code>const char *ei_thishostname(ei_cnode *ec)</code><code>const char *ei_thisalivename(ei_cnode *ec)</code>
</h3> 
<p>Can be used to retrieve information about the C-node. These values are initially set with <code class="code">ei_connect_init()</code> or <code class="code">ei_connect_xinit()</code>.</p> <p>These function simply fetch the appropriate field from the <code class="code">ec</code> structure. Read the field directly will probably be safe for a long time, so these functions are not really needed.</p>  <h3><code>int ei_unpublish(ei_cnode *ec)</code></h3> 
<p>Can be called by a process to unregister a specified node from EPMD on the local host. This is, however, usually not allowed, unless EPMD was started with flag <code class="code">-relaxed_command_check</code>, which it normally is not.</p> <p>To unregister a node you have published, you should close the descriptor that was returned by <code class="code">ei_publish()</code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This function is deprecated and will be removed in a future release.</p> </div> </div> <p><code class="code">ec</code> is the node structure of the node to unregister.</p> <p>If the node was successfully unregistered from EPMD, the function returns <code class="code">0</code>. Otherwise, <code class="code">-1</code> is returned and <code class="code">erl_errno</code> is set to <code class="code">EIO</code>.</p>  <h3><code>int ei_unpublish_tmo(ei_cnode *ec, unsigned timeout_ms)</code></h3> 
<p>Equivalent to <code class="code">ei_unpublish</code> with an optional time-out argument, see the description at the beginning of this manual page.</p>  </div> <h2> <span onmouseover="document.getElementById('ghlink-debug-information-id84164').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-debug-information-id84164').style.visibility = 'hidden';" id="debug_information">Debug Information</span> </h2>  <p>If a connection attempt fails, the following can be checked:</p> <ul> <li> <code class="code">erl_errno</code>.</li> <li>That the correct cookie was used</li> <li>That EPMD is running</li> <li>That the remote Erlang node on the other side is running the same version of Erlang as the <code class="code">ei</code> library</li> <li>That environment variable <code class="code">ERL_EPMD_PORT</code> is set correctly</li> </ul> <p>The connection attempt can be traced by setting a trace level by either using <code class="code">ei_set_tracelevel</code> or by setting environment variable <code class="code">EI_TRACELEVEL</code>. The trace levels have the following messages:</p> <ul> <li>1: Verbose error messages</li> <li>2: Above messages and verbose warning messages</li> <li>3: Above messages and progress reports for connection handling </li> <li>4: Above messages and progress reports for communication</li> <li>5: Above messages and progress reports for data conversion</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
