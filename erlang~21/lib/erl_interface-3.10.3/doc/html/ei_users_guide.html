
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>1. Erl_Interface User&#39;s Guide - Erlang 21 - W3cubDocs</title>
  
  <meta name="description" content="The Erl_Interface library contains functions that help you integrate programs written in C and Erlang. The functions in Erl_Interface support the &hellip;">
  <meta name="keywords" content="erl, interface, user&#39;s, guide, erlang, erlang~21">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/erlang~21/lib/erl_interface-3.10.3/doc/html/ei_users_guide.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/erlang~21.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~21/" class="_nav-link" title="" style="margin-left:0;">Erlang 21</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _erlang">
				
				
<h1>1 Erl_Interface User's Guide</h1> <h2><span onmouseover="document.getElementById('ghlink-introduction-id61510').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-introduction-id61510').style.visibility = 'hidden';" id="introduction">1.1 Introduction</span></h2> <p>The <code class="code">Erl_Interface</code> library contains functions that help you integrate programs written in C and Erlang. The functions in <code class="code">Erl_Interface</code> support the following:</p> <ul> <li>Manipulation of data represented as Erlang data types</li> <li>Conversion of data between C and Erlang formats</li> <li>Encoding and decoding of Erlang data types for transmission or storage</li> <li>Communication between C nodes and Erlang processes</li> <li>Backup and restore of C node state to and from <code>Mnesia</code> </li> </ul> <div class="note"> <div class="label">Note</div> <div class="content">

<p>By default, the <code class="code">Erl_Interface</code> libraries are only guaranteed to be compatible with other Erlang/OTP components from the same release as the libraries themselves. For information about how to communicate with Erlang/OTP components from earlier releases, see function <code><a href="ei#ei_set_compat_rel"><span class="code">ei:ei_set_compat_rel</span></a></code> and <code><a href="erl_eterm#erl_set_compat_rel"><span class="code">erl_eterm:erl_set_compat_rel</span></a></code>.</p> </div> </div> <h4><span onmouseover="document.getElementById('ghlink-scope-id64850').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-scope-id64850').style.visibility = 'hidden';" id="scope">Scope</span></h4> <p>In the following sections, these topics are described:</p> <ul> <li>Compiling your code for use with <code class="code">Erl_Interface</code> </li> <li>Initializing <code class="code">Erl_Interface</code> </li> <li>Encoding, decoding, and sending Erlang terms</li> <li>Building terms and patterns</li> <li>Pattern matching</li> <li>Connecting to a distributed Erlang node</li> <li>Using the Erlang Port Mapper Daemon (EPMD)</li> <li>Sending and receiving Erlang messages</li> <li>Remote procedure calls</li> <li>Using global names</li> <li>Using the registry</li> </ul> <h4><span onmouseover="document.getElementById('ghlink-prerequisites-id63689').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-prerequisites-id63689').style.visibility = 'hidden';" id="prerequisites">Prerequisites</span></h4> <p>It is assumed that the reader is familiar with the Erlang programming language.</p> <h2><span onmouseover="document.getElementById('ghlink-compiling-and-linking-your-code-id63537').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-compiling-and-linking-your-code-id63537').style.visibility = 'hidden';" id="compiling-and-linking-your-code">1.2 Compiling and Linking Your Code</span></h2> <p>To use any of the <code class="code">Erl_Interface</code> functions, include the following lines in your code:</p> <pre data-language="erlang">#include "erl_interface.h"
#include "ei.h"    </pre> <p>Determine where the top directory of your OTP installation is. To find this, start Erlang and enter the following command at the Eshell prompt:</p> <pre data-language="erlang">Eshell V4.7.4  (abort with ^G)
1&gt; code:root_dir().
/usr/local/otp    </pre> <p>To compile your code, ensure that your C compiler knows where to find <code class="code">erl_interface.h</code> by specifying an appropriate <code class="code">-I</code> argument on the command line, or add it to the <code class="code">CFLAGS</code> definition in your <code class="code">Makefile</code>. The correct value for this path is <code class="code">$OTPROOT/lib/erl_interface-$EIVSN/include</code>, where:</p> <ul> <li> <p><code class="code">$OTPROOT</code> is the path reported by <code class="code">code:root_dir/0</code> in the example above.</p> </li> <li> <p><code class="code">$EIVSN</code> is the version of the <code class="code">Erl_Interface</code> application, for example, <code class="code">erl_interface-3.2.3</code>.</p> </li> </ul> <p>Compiling the code:</p> <pre data-language="erlang">$ cc -c -I/usr/local/otp/lib/erl_interface-3.2.3/include myprog.c    </pre> <p>When linking:</p> <ul> <li>Specify the path to <code class="code">liberl_interface.a</code> and <code class="code">libei.a</code> with <code class="code">-L$OTPROOT/lib/erl_interface-3.2.3/lib</code>.</li> <li>Specify the name of the libraries with <code class="code">-lerl_interface -lei</code>.</li> </ul> <p>Do this on the command line or add the flags to the <code class="code">LDFLAGS</code> definition in your <code class="code">Makefile</code>.</p> <p>Linking the code:</p> <pre data-language="erlang">$ ld -L/usr/local/otp/lib/erl_interface-3.2.3/
                            lib myprog.o -lerl_interface -lei -o myprog    </pre> <p>On some systems it can be necessary to link with some more libraries (for example, <code class="code">libnsl.a</code> and <code class="code">libsocket.a</code> on Solaris, or <code class="code">wsock32.lib</code> on Windows) to use the communication facilities of <code class="code">Erl_Interface</code>.</p> <p>If you use the <code class="code">Erl_Interface</code> functions in a threaded application based on POSIX threads or Solaris threads, then <code class="code">Erl_Interface</code> needs access to some of the synchronization facilities in your threads package. You must specify extra compiler flags to indicate which of the packages you use. Define <code class="code">_REENTRANT</code> and either <code class="code">STHREADS</code> or <code class="code">PTHREADS</code>. The default is to use POSIX threads if <code class="code">_REENTRANT</code> is specified.</p> <h2><span onmouseover="document.getElementById('ghlink-initializing-the-erl_interface-library-id63274').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-initializing-the-erl_interface-library-id63274').style.visibility = 'hidden';" id="initializing-the-erl_interface-library">1.3 Initializing the Erl_Interface Library</span></h2> <p>Before calling any of the other <code class="code">Erl_Interface</code> functions, call <code class="code">erl_init()</code> exactly once to initialize the library. <code class="code">erl_init()</code> takes two arguments. However, the arguments are no longer used by <code class="code">Erl_Interface</code> and are therefore to be specified as <code class="code">erl_init(NULL,0)</code>.</p> <h2><span onmouseover="document.getElementById('ghlink-encoding,-decoding,-and-sending-erlang-terms-id63307').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-encoding,-decoding,-and-sending-erlang-terms-id63307').style.visibility = 'hidden';" id="encoding,-decoding,-and-sending-erlang-terms">1.4 Encoding, Decoding, and Sending Erlang Terms</span></h2> <p>Data sent between distributed Erlang nodes is encoded in the Erlang external format. You must therefore encode and decode Erlang terms into byte streams if you want to use the distribution protocol to communicate between a C program and Erlang.</p> <p>The <code class="code">Erl_Interface</code> library supports this activity. It has several C functions that create and manipulate Erlang data structures. The library also contains an encode and a decode function. The following example shows how to create and encode an Erlang tuple <code class="code">{tobbe,3928}</code>:</p> <pre data-language="erlang">ETERM *arr[2], *tuple;
char buf[BUFSIZ];
int i;
  
arr[0] = erl_mk_atom("tobbe");
arr[1] = erl_mk_integer(3928);
tuple  = erl_mk_tuple(arr, 2);
i = erl_encode(tuple, buf);    </pre> <p>Alternatively, you can use <code class="code">erl_send()</code> and <code class="code">erl_receive_msg</code>, which handle the encoding and decoding of messages transparently.</p> <p>For a complete description, see the following modules:</p> <ul> <li> <code><a href="erl_eterm"><span class="code">erl_eterm</span></a></code> for creating Erlang terms</li> <li> <code><a href="erl_marshal"><span class="code">erl_marshal</span></a></code> for encoding and decoding routines</li> </ul> <h2> <span onmouseover="document.getElementById('ghlink-building-terms-and-patterns-id63214').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-building-terms-and-patterns-id63214').style.visibility = 'hidden';" id="building_terms_and_patterns">1.5 Building Terms and Patterns</span> </h2> <p>The previous example can be simplified by using the <code><a href="erl_format"><span class="code">erl_format</span></a></code> module to create an Erlang term:</p> <pre data-language="erlang">ETERM *ep;
ep = erl_format("{~a,~i}", "tobbe", 3928);    </pre> <p>For a complete description of the different format directives, see the <code><a href="erl_format"><span class="code">erl_format</span></a></code> module.</p> <p>The following example is more complex:</p> <pre data-language="erlang">ETERM *ep;
ep = erl_format("[{name,~a},{age,~i},{data,~w}]",
                 "madonna", 
                 21, 
                 erl_format("[{adr,~s,~i}]", "E-street", 42));
erl_free_compound(ep);      </pre> <p>As in the previous examples, it is your responsibility to free the memory allocated for Erlang terms. In this example, <code class="code">erl_free_compound()</code> ensures that the complete term pointed to by <code class="code">ep</code> is released. This is necessary because the pointer from the second call to <code class="code">erl_format</code> is lost.</p> <p>The following example shows a slightly different solution:</p> <pre data-language="erlang">ETERM *ep,*ep2;
ep2 = erl_format("[{adr,~s,~i}]","E-street",42);
ep  = erl_format("[{name,~a},{age,~i},{data,~w}]",
                 "madonna", 21, ep2);
erl_free_term(ep);  
erl_free_term(ep2);      </pre> <p>In this case, you free the two terms independently. The order in which you free the terms <code class="code">ep</code> and <code class="code">ep2</code> is not important, because the <code class="code">Erl_Interface</code> library uses reference counting to determine when it is safe to remove objects.</p> <p>If you are unsure whether you have freed the terms properly, you can use the following function to see the status of the fixed term allocator:</p> <pre data-language="erlang">long allocated, freed;

erl_eterm_statistics(&amp;allocated,&amp;freed);
printf("currently allocated blocks: %ld\n",allocated);
printf("length of freelist: %ld\n",freed);

/* really free the freelist */
erl_eterm_release();</pre> <p>For more information, see the <code><a href="erl_malloc"><span class="code">erl_malloc</span></a></code> module.</p> <h2><span onmouseover="document.getElementById('ghlink-pattern-matching-id63828').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-pattern-matching-id63828').style.visibility = 'hidden';" id="pattern-matching">1.6 Pattern Matching</span></h2> <p>An Erlang pattern is a term that can contain unbound variables or <code class="code">"do not care"</code> symbols. Such a pattern can be matched against a term and, if the match is successful, any unbound variables in the pattern will be bound as a side effect. The content of a bound variable can then be retrieved:</p> <pre data-language="erlang">ETERM *pattern;
pattern = erl_format("{madonna,Age,_}");    </pre> <p>The <code><a href="erl_format#erl_match"><span class="code">erl_format:erl_match</span></a></code> function performs pattern matching. It takes a pattern and a term and tries to match them. As a side effect any unbound variables in the pattern will be bound. In the following example, a pattern is created with a variable <code class="code">Age</code>, which is included at two positions in the tuple. The pattern match is performed as follows:</p> <ul> <li> <p><code class="code">erl_match</code> binds the contents of <code class="code">Age</code> to <code class="code">21</code> the first time it reaches the variable.</p> </li> <li> <p>The second occurrence of <code class="code">Age</code> causes a test for equality between the terms, as <code class="code">Age</code> is already bound to <code class="code">21</code>. As <code class="code">Age</code> is bound to <code class="code">21</code>, the equality test succeeds and the match continues until the end of the pattern.</p> </li> <li> <p>If the end of the pattern is reached, the match succeeds and you can retrieve the contents of the variable.</p> </li> </ul> <pre data-language="erlang">ETERM *pattern,*term;
pattern = erl_format("{madonna,Age,Age}");
term    = erl_format("{madonna,21,21}");
if (erl_match(pattern, term)) {
  fprintf(stderr, "Yes, they matched: Age = ");
  ep = erl_var_content(pattern, "Age"); 
  erl_print_term(stderr, ep);
  fprintf(stderr,"\n");
  erl_free_term(ep);
}
erl_free_term(pattern);
erl_free_term(term);    </pre> <p>For more information, see the <code><a href="erl_format#erl_match"><span class="code">erl_format:erl_match</span></a></code> function.</p> <h2><span onmouseover="document.getElementById('ghlink-connecting-to-a-distributed-erlang-node-id62636').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-connecting-to-a-distributed-erlang-node-id62636').style.visibility = 'hidden';" id="connecting-to-a-distributed-erlang-node">1.7 Connecting to a Distributed Erlang Node</span></h2> <p>To connect to a distributed Erlang node, you must first initialize the connection routine with <code><a href="erl_connect#erl_connect_init"><span class="code">erl_connect:erl_connect_init</span></a></code>, which stores information, such as the hostname, node name, and IP address for later use:</p> <pre data-language="erlang">int identification_number = 99;
int creation=1;
char *cookie="a secret cookie string"; /* An example */
erl_connect_init(identification_number, cookie, creation);    </pre> <p>For more information, see the <code><a href="erl_connect"><span class="code">erl_connect</span></a></code> module.</p> <p>After initialization, you set up the connection to the Erlang node. To specify the Erlang node you want to connect to, use <code class="code">erl_connect()</code>. The following example sets up the connection and is to result in a valid socket file descriptor:</p> <pre data-language="erlang">int sockfd;
char *nodename="xyz@chivas.du.etx.ericsson.se"; /* An example */
if ((sockfd = erl_connect(nodename)) &lt; 0)
  erl_err_quit("ERROR: erl_connect failed");    </pre> <p><code class="code">erl_err_quit()</code> prints the specified string and terminates the program. For more information, see the <code><a href="erl_error"><span class="code">erl_error</span></a></code> module.</p> <h2><span onmouseover="document.getElementById('ghlink-using-epmd-id62709').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-using-epmd-id62709').style.visibility = 'hidden';" id="using-epmd">1.8 Using EPMD</span></h2> <p><code><span class="code">erts:epmd</span></code> is the Erlang Port Mapper Daemon. Distributed Erlang nodes register with <code class="code">epmd</code> on the local host to indicate to other nodes that they exist and can accept connections. <code class="code">epmd</code> maintains a register of node and port number information, and when a node wishes to connect to another node, it first contacts <code class="code">epmd</code> to find the correct port number to connect to.</p> <p>When you use <code><a href="erl_connect"><span class="code">erl_connect</span></a></code> to connect to an Erlang node, a connection is first made to <code class="code">epmd</code> and, if the node is known, a connection is then made to the Erlang node.</p> <p>C nodes can also register themselves with <code class="code">epmd</code> if they want other nodes in the system to be able to find and connect to them.</p> <p>Before registering with <code class="code">epmd</code>, you must first create a listen socket and bind it to a port. Then:</p> <pre data-language="erlang">int pub;

pub = erl_publish(port);    </pre> <p><code class="code">pub</code> is a file descriptor now connected to <code class="code">epmd</code>. <code class="code">epmd</code> monitors the other end of the connection. If it detects that the connection has been closed, the node becomes unregistered. So, if you explicitly close the descriptor or if your node fails, it becomes unregistered from <code class="code">epmd</code>.</p> <p>Notice that on some systems (such as VxWorks), a failed node is not detected by this mechanism, as the operating system does not automatically close descriptors that were left open when the node failed. If a node has failed in this way, <code class="code">epmd</code> prevents you from registering a new node with the old name, as it thinks that the old name is still in use. In this case, you must unregister the name explicitly:</p> <pre data-language="erlang">erl_unpublish(node);    </pre> <p>This causes <code class="code">epmd</code> to close the connection from the far end. Notice that if the name was in fact still in use by a node, the results of this operation are unpredictable. Also, doing this does not cause the local end of the connection to close, so resources can be consumed.</p> <h2><span onmouseover="document.getElementById('ghlink-sending-and-receiving-erlang-messages-id59190').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-sending-and-receiving-erlang-messages-id59190').style.visibility = 'hidden';" id="sending-and-receiving-erlang-messages">1.9 Sending and Receiving Erlang Messages</span></h2> <p>Use one of the following two functions to send messages:</p> <ul> <li><code><a href="erl_connect#erl_send"><span class="code">erl_connect:erl_send</span></a></code></li> <li><code><a href="erl_connect#erl_reg_send"><span class="code">erl_connect:erl_reg_send</span></a></code></li> </ul> <p>As in Erlang, messages can be sent to a pid or to a registered name. It is easier to send a message to a registered name, as it avoids the problem of finding a suitable pid.</p> <p>Use one of the following two functions to receive messages:</p> <ul> <li><code><a href="erl_connect#erl_receive"><span class="code">erl_connect:erl_receive</span></a></code></li> <li><code><a href="erl_connect#erl_receive_msg"><span class="code">erl_connect:erl_receive_msg</span></a></code></li> </ul> <p><code class="code">erl_receive()</code> receives the message into a buffer, while <code class="code">erl_receive_msg()</code> decodes the message into an Erlang term.</p> <h4><span onmouseover="document.getElementById('ghlink-example-of-sending-messages-id59273').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-example-of-sending-messages-id59273').style.visibility = 'hidden';" id="example-of-sending-messages">Example of Sending Messages</span></h4> <p>In the following example, <code class="code">{Pid, hello_world}</code> is sent to a registered process <code class="code">my_server</code>. The message is encoded by <code class="code">erl_send()</code>:</p> <pre data-language="erlang">extern const char *erl_thisnodename(void);
extern short erl_thiscreation(void);
#define SELF(fd) erl_mk_pid(erl_thisnodename(),fd,0,erl_thiscreation())
ETERM *arr[2], *emsg;
int sockfd, creation=1;
  
arr[0] = SELF(sockfd);
arr[1] = erl_mk_atom("Hello world");
emsg   = erl_mk_tuple(arr, 2);
  
erl_reg_send(sockfd, "my_server", emsg);
erl_free_term(emsg);      </pre> <p>The first element of the tuple that is sent is your own pid. This enables <code class="code">my_server</code> to reply. For more information about the primitives, see the <code><a href="erl_connect"><span class="code">erl_connect</span></a></code> module.</p> <h4><span onmouseover="document.getElementById('ghlink-example-of-receiving-messages-id58964').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-example-of-receiving-messages-id58964').style.visibility = 'hidden';" id="example-of-receiving-messages">Example of Receiving Messages</span></h4> <p>In this example, <code class="code">{Pid, Something}</code> is received. The received pid is then used to return <code class="code">{goodbye,Pid}</code>.</p> <pre data-language="erlang">ETERM *arr[2], *answer;
int sockfd,rc;
char buf[BUFSIZE];
ErlMessage emsg;
  
if ((rc = erl_receive_msg(sockfd , buf, BUFSIZE, &amp;emsg)) == ERL_MSG) {
   arr[0] = erl_mk_atom("goodbye");
   arr[1] = erl_element(1, emsg.msg); 
   answer = erl_mk_tuple(arr, 2);
   erl_send(sockfd, arr[1], answer);
   erl_free_term(answer);
   erl_free_term(emsg.msg);
   erl_free_term(emsg.to);
}      </pre> <p>To provide robustness, a distributed Erlang node occasionally polls all its connected neighbors in an attempt to detect failed nodes or communication links. A node that receives such a message is expected to respond immediately with an <code class="code">ERL_TICK</code> message. This is done automatically by <code class="code">erl_receive()</code>. However, when this has occurred, <code class="code">erl_receive</code> returns <code class="code">ERL_TICK</code> to the caller without storing a message into the <code class="code">ErlMessage</code> structure.</p> <p>When a message has been received, it is the caller's responsibility to free the received message <code class="code">emsg.msg</code> and <code class="code">emsg.to</code> or <code class="code">emsg.from</code>, depending on the type of message received.</p> <p>For more information, see the <code><a href="erl_connect"><span class="code">erl_connect</span></a></code> and <code><a href="erl_eterm"><span class="code">erl_eterm</span></a></code> modules.</p> <h2><span onmouseover="document.getElementById('ghlink-remote-procedure-calls-id64665').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-remote-procedure-calls-id64665').style.visibility = 'hidden';" id="remote-procedure-calls">1.10 Remote Procedure Calls</span></h2> <p>An Erlang node acting as a client to another Erlang node typically sends a request and waits for a reply. Such a request is included in a function call at a remote node and is called a remote procedure call.</p> <p>The following example shows how the <code class="code">Erl_Interface</code> library supports remote procedure calls:</p> <pre data-language="erlang">char modname[]=THE_MODNAME;
ETERM *reply,*ep;
ep = erl_format("[~a,[]]", modname);
if (!(reply = erl_rpc(fd, "c", "c", ep)))
  erl_err_msg("&lt;ERROR&gt; when compiling file: %s.erl !\n", modname);
erl_free_term(ep);
ep = erl_format("{ok,_}");
if (!erl_match(ep, reply))
  erl_err_msg("&lt;ERROR&gt; compiler errors !\n");
erl_free_term(ep);
erl_free_term(reply);    </pre> <p><code class="code">c:c/1</code> is called to compile the specified module on the remote node. <code class="code">erl_match()</code> checks that the compilation was successful by testing for the expected <code class="code">ok</code>.</p> <p>For more information about <code class="code">erl_rpc()</code> and its companions <code class="code">erl_rpc_to()</code> and <code class="code">erl_rpc_from()</code>, see the <code><a href="erl_connect"><span class="code">erl_connect</span></a></code> module.</p> <h2><span onmouseover="document.getElementById('ghlink-using-global-names-id64734').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-using-global-names-id64734').style.visibility = 'hidden';" id="using-global-names">1.11 Using Global Names</span></h2> <p>A C node has access to names registered through the <code><span class="code">global</span></code> module in Kernel. Names can be looked up, allowing the C node to send messages to named Erlang services. C nodes can also register global names, allowing them to provide named services to Erlang processes or other C nodes.</p> <p><code class="code">Erl_Interface</code> does not provide a native implementation of the global service. Instead it uses the global services provided by a "nearby" Erlang node. To use the services described in this section, it is necessary to first open a connection to an Erlang node.</p> <p>To see what names there are:</p> <pre data-language="erlang">char **names;
int count;
int i;

names = erl_global_names(fd,&amp;count);

if (names) 
  for (i=0; i&lt;count; i++) 
    printf("%s\n",names[i]);

free(names);    </pre> <p><code><a href="erl_global#erl_global_names"><span class="code">erl_global:erl_global_names</span></a></code> allocates and returns a buffer containing all the names known to the <code class="code">global</code> module in <code class="code">Kernel</code>. <code class="code">count</code> is initialized to indicate the number of names in the array. The array of strings in names is terminated by a <code class="code">NULL</code> pointer, so it is not necessary to use <code class="code">count</code> to determine when the last name is reached.</p> <p>It is the caller's responsibility to free the array. <code class="code">erl_global_names</code> allocates the array and all the strings using a single call to <code class="code">malloc()</code>, so <code class="code">free(names)</code> is all that is necessary.</p> <p>To look up one of the names:</p> <pre data-language="erlang">ETERM *pid;
char node[256];

pid = erl_global_whereis(fd,"schedule",node);    </pre> <p>If <code class="code">"schedule"</code> is known to the <code class="code">global</code> module in <code class="code">Kernel</code>, an Erlang pid is returned that can be used to send messages to the schedule service. Also, <code class="code">node</code> is initialized to contain the name of the node where the service is registered, so that you can make a connection to it by simply passing the variable to <code><a href="erl_connect"><span class="code">erl_connect</span></a></code>.</p> <p>Before registering a name, you should already have registered your port number with <code class="code">epmd</code>. This is not strictly necessary, but if you neglect to do so, then other nodes wishing to communicate with your service cannot find or connect to your process.</p> <p>Create a pid that Erlang processes can use to communicate with your service:</p> <pre data-language="erlang">ETERM *pid;

pid = erl_mk_pid(thisnode,14,0,0);
erl_global_register(fd,servicename,pid);    </pre> <p>After registering the name, use <code><a href="erl_connect#erl_accept"><span class="code">erl_connect:erl_accept</span></a></code> to wait for incoming connections.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>Remember to free <code class="code">pid</code> later with <code><a href="erl_malloc#erl_free_term"><span class="code">erl_malloc:erl_free_term</span></a></code>.</p> </div> </div> <p>To unregister a name:</p> <pre data-language="erlang">erl_global_unregister(fd,servicename);    </pre> <h2><span onmouseover="document.getElementById('ghlink-using-the-registry-id63968').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-using-the-registry-id63968').style.visibility = 'hidden';" id="using-the-registry">1.12 Using the Registry</span></h2> <p>This section describes the use of the registry, a simple mechanism for storing key-value pairs in a C-node, as well as backing them up or restoring them from an <code class="code">Mnesia</code> table on an Erlang node. For more detailed information about the individual API functions, see the <code><a href="registry"><span class="code">registry</span></a></code> module.</p> <p>Keys are strings, that is, <code class="code">NULL</code>-terminated arrays of characters, and values are arbitrary objects. Although integers and floating point numbers are treated specially by the registry, you can store strings or binary objects of any type as pointers.</p> <p>To start, open a registry:</p> <pre data-language="erlang">ei_reg *reg;

reg = ei_reg_open(45);    </pre> <p>The number <code class="code">45</code> in the example indicates the approximate number of objects that you expect to store in the registry. Internally the registry uses hash tables with collision chaining, so there is no absolute upper limit on the number of objects that the registry can contain, but if performance or memory usage is important, then you are to choose a number accordingly. The registry can be resized later.</p> <p>You can open as many registries as you like (if memory permits).</p> <p>Objects are stored and retrieved through set and get functions. The following example shows how to store integers, floats, strings, and arbitrary binary objects:</p> <pre data-language="erlang">struct bonk *b = malloc(sizeof(*b));
char *name = malloc(7);

ei_reg_setival(reg,"age",29); 
ei_reg_setfval(reg,"height",1.85);

strcpy(name,"Martin");
ei_reg_setsval(reg,"name",name); 

b-&gt;l = 42;
b-&gt;m = 12;
ei_reg_setpval(reg,"jox",b,sizeof(*b));    </pre> <p>If you try to store an object in the registry and there is an existing object with the same key, the new value replaces the old one. This is done regardless of whether the new object and the old one have the same type, so you can, for example, replace a string with an integer. If the existing value is a string or binary, it is freed before the new value is assigned.</p> <p>Stored values are retrieved from the registry as follows:</p> <pre data-language="erlang">long i;
double f;
char *s;
struct bonk *b;
int size;

i = ei_reg_getival(reg,"age");
f = ei_reg_getfval(reg,"height");
s = ei_reg_getsval(reg,"name");
b = ei_reg_getpval(reg,"jox",&amp;size);    </pre> <p>In all the above examples, the object must exist and it must be of the right type for the specified operation. If you do not know the type of an object, you can ask:</p> <pre data-language="erlang">struct ei_reg_stat buf;

ei_reg_stat(reg,"name",&amp;buf);    </pre> <p>Buf is initialized to contain object attributes.</p> <p>Objects can be removed from the registry:</p> <pre data-language="erlang">ei_reg_delete(reg,"name");    </pre> <p>When you are finished with a registry, close it to remove all the objects and free the memory back to the system:</p> <pre data-language="erlang">ei_reg_close(reg);    </pre> <h4><span onmouseover="document.getElementById('ghlink-backing-up-the-registry-to-mnesia-id63327').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-backing-up-the-registry-to-mnesia-id63327').style.visibility = 'hidden';" id="backing-up-the-registry-to-mnesia">Backing Up the Registry to Mnesia</span></h4> <p>The contents of a registry can be backed up to <code><span class="code">Mnesia</span></code> on a "nearby" Erlang node. You must provide an open connection to the Erlang node (see <code><a href="erl_connect"><span class="code">erl_connect</span></a></code>). Also, <code class="code">Mnesia</code> 3.0 or later must be running on the Erlang node before the backup is initiated:</p> <pre data-language="erlang">ei_reg_dump(fd, reg, "mtab", dumpflags);      </pre> <p>This example back up the contents of the registry to the specified <code class="code">Mnesia</code> table <code class="code">"mtab"</code>. Once a registry has been backed up to <code class="code">Mnesia</code> like this, more backups only affect objects that have been modified since the most recent backup, that is, objects that have been created, changed, or deleted. The backup operation is done as a single atomic transaction, so that either the entire backup is performed or none of it.</p> <p>Likewise, a registry can be restored from a <code class="code">Mnesia</code> table:</p> <pre data-language="erlang">ei_reg_restore(fd, reg, "mtab");      </pre> <p>This reads the entire contents of <code class="code">"mtab"</code> into the specified registry. After the restore, all the objects in the registry are marked as unmodified, so a later backup only affects objects that you have modified since the restore.</p> <p>Notice that if you restore to a non-empty registry, objects in the table overwrite objects in the registry with the same keys. Also, the <strong>entire</strong> contents of the registry is marked as unmodified after the restore, including any modified objects that were not overwritten by the restore operation. This may not be your intention.</p> <h4><span onmouseover="document.getElementById('ghlink-storing-strings-and-binaries-id63418').style.visibility = 'visible';" onmouseout="document.getElementById('ghlink-storing-strings-and-binaries-id63418').style.visibility = 'hidden';" id="storing-strings-and-binaries">Storing Strings and Binaries</span></h4> <p>When string or binary objects are stored in the registry it is important that some simple guidelines are followed.</p> <p>Most importantly, the object must have been created with a single call to <code class="code">malloc()</code> (or similar), so that it can later be removed by a single call to <code class="code">free()</code>. Objects are freed by the registry when it is closed, or when you assign a new value to an object that previously contained a string or binary.</p> <p>Notice that if you store binary objects that are context-dependent (for example, containing pointers or open file descriptors), they lose their meaning if they are backed up to a <code class="code">Mnesia</code> table and later restored in a different context.</p> <p>When you retrieve a stored string or binary value from the registry, the registry maintains a pointer to the object and you are passed a copy of that pointer. You should never free an object retrieved in this manner because when the registry later attempts to free it, a runtime error occurs that likely causes the C-node to crash.</p> <p>You are free to modify the contents of an object retrieved this way. However, when you do so, the registry is not aware of your changes, possibly causing it to be missed the next time you make an <code class="code">Mnesia</code> backup of the registry contents. This can be avoided if you mark the object as dirty after any such changes with <code><a href="registry#ei_reg_markdirty"><span class="code">registry:ei_reg_markdirty</span></a></code>, or pass appropriate flags to <code><a href="registry#ei_reg_dump"><span class="code">registry:ei_reg_dump</span></a></code>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
