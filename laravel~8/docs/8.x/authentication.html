
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Authentication - Laravel 8 - W3cubDocs</title>
  
  <meta name="description" content="Laravel makes implementing authentication very simple. In fact, almost everything is configured for you out of the box. The authentication &hellip;">
  <meta name="keywords" content="authentication, laravel, laravel~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/laravel~8/docs/8.x/authentication.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/laravel~8.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/laravel~8/" class="_nav-link" title="" style="margin-left:0;">Laravel 8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _laravel">
				
				
<section class="docs_main"> <h1>Authentication</h1> <ul> <li>
<a href="#introduction">Introduction</a> <ul> <li><a href="#introduction-database-considerations">Database Considerations</a></li> <li><a href="#ecosystem-overview">Ecosystem Overview</a></li> </ul>
</li> <li>
<a href="#authentication-quickstart">Authentication Quickstart</a> <ul> <li><a href="#included-routing">Routing</a></li> <li><a href="#included-views">Views</a></li> <li><a href="#included-authenticating">Authenticating</a></li> <li><a href="#retrieving-the-authenticated-user">Retrieving The Authenticated User</a></li> <li><a href="#protecting-routes">Protecting Routes</a></li> <li><a href="#login-throttling">Login Throttling</a></li> </ul>
</li> <li>
<a href="#authenticating-users">Manually Authenticating Users</a> <ul> <li><a href="#remembering-users">Remembering Users</a></li> <li><a href="#other-authentication-methods">Other Authentication Methods</a></li> </ul>
</li> <li>
<a href="#http-basic-authentication">HTTP Basic Authentication</a> <ul> <li><a href="#stateless-http-basic-authentication">Stateless HTTP Basic Authentication</a></li> </ul>
</li> <li>
<a href="#logging-out">Logging Out</a> <ul> <li><a href="#invalidating-sessions-on-other-devices">Invalidating Sessions On Other Devices</a></li> </ul>
</li> <li>
<a href="#password-confirmation">Password Confirmation</a> <ul> <li><a href="#password-confirmation-configuration">Configuration</a></li> <li><a href="#password-confirmation-routing">Routing</a></li> <li><a href="#password-confirmation-protecting-routes">Protecting Routes</a></li> </ul>
</li> <li><a href="socialite">Social Authentication</a></li> <li>
<a href="#adding-custom-guards">Adding Custom Guards</a> <ul> <li><a href="#closure-request-guards">Closure Request Guards</a></li> </ul>
</li> <li>
<a href="#adding-custom-user-providers">Adding Custom User Providers</a> <ul> <li><a href="#the-user-provider-contract">The User Provider Contract</a></li> <li><a href="#the-authenticatable-contract">The Authenticatable Contract</a></li> </ul>
</li> <li><a href="#events">Events</a></li> </ul>  <h2 id="introduction">Introduction</h2> <p>Laravel makes implementing authentication very simple. In fact, almost everything is configured for you out of the box. The authentication configuration file is located at <code>config/auth.php</code>, which contains several well documented options for tweaking the behavior of the authentication services.</p> <p>At its core, Laravel's authentication facilities are made up of "guards" and "providers". Guards define how users are authenticated for each request. For example, Laravel ships with a <code>session</code> guard which maintains state using session storage and cookies.</p> <p>Providers define how users are retrieved from your persistent storage. Laravel ships with support for retrieving users using Eloquent and the database query builder. However, you are free to define additional providers as needed for your application.</p> <p>Don't worry if this all sounds confusing now! Many applications will never need to modify the default authentication configuration.</p>  <h4 id="getting-started-fast">Getting Started Fast</h4> <p>Want to get started fast? Install <a href="https://jetstream.laravel.com">Laravel Jetstream</a> in a fresh Laravel application. After migrating your database, navigate your browser to <code>/register</code> or any other URL that is assigned to your application. Jetstream will take care of scaffolding your entire authentication system!</p>  <h3 id="introduction-database-considerations">Database Considerations</h3> <p>By default, Laravel includes an <code>App\Models\User</code> <a href="eloquent">Eloquent model</a> in your <code>app/Models</code> directory. This model may be used with the default Eloquent authentication driver. If your application is not using Eloquent, you may use the <code>database</code> authentication driver which uses the Laravel query builder.</p> <p>When building the database schema for the <code>App\Models\User</code> model, make sure the password column is at least 60 characters in length. Maintaining the default string column length of 255 characters would be a good choice.</p> <p>Also, you should verify that your <code>users</code> (or equivalent) table contains a nullable, string <code>remember_token</code> column of 100 characters. This column will be used to store a token for users that select the "remember me" option when logging into your application.</p>  <h3 id="ecosystem-overview">Ecosystem Overview</h3> <p>Laravel offers several packages related to authentication. Before continuing, we'll review the general authentication ecosystem in Laravel and discuss each package's intended purpose.</p> <p>First, consider how authentication works. When using a web browser, a user will provide their username and password via a login form. If these credentials are correct, the application will store information about the authenticated user in the user's <a href="session">session</a>. A cookie issued to the browser contains the session ID so that subsequent requests to the application can associate the user with the correct session. After the session cookie is received, the application will retrieve the session data based on the session ID, note that the authentication information has been stored in the session, and will consider the user as "authenticated".</p> <p>When a remote service needs to authenticate to access an API, cookies are not typically used because there is no web browser. Instead, the remote service sends an API token to the API on each request. The application may validate the incoming token against a table of valid API tokens and "authenticate" the request as being performed by the user associated with that API token.</p>  <h4 id="laravels-built-in-browser-authentication-services">Laravel's Built-in Browser Authentication Services</h4> <p>Laravel includes built-in authentication and session services which are typically accessed via the <code>Auth</code> and <code>Session</code> facades. These features provide cookie based authentication for requests that are initiated from web browsers. They provide methods that allow you to verify a user's credentials and authenticate the user. In addition, these services will automatically store the proper data in the user's session and issue the proper session cookie. A discussion of how to use these services is contained within this documentation.</p> <p><strong>Jetstream / Fortify</strong></p> <p>As discussed in this documentation, you can interact with these authentication services manually to build your application's own authentication layer. However, to help you get started more quickly, we have released free packages that provide robust, modern scaffolding of the entire authentication layer. These packages are <a href="https://jetstream.laravel.com">Laravel Jetstream</a> and <a href="https://github.com/laravel/fortify">Laravel Fortify</a>.</p> <p>Laravel Fortify is a headless authentication backend for Laravel that implements many of the features found in this documentation, including cookie-based authentication as well as other features such as two-factor authentication and email verification. Laravel Jetstream is a UI that consumes and exposes Fortify's authentication services with a beautiful, modern UI powered by <a href="https://tailwindcss.com">Tailwind CSS</a>, <a href="https://laravel-livewire.com">Laravel Livewire</a>, and / or <a href="https://inertiajs.com">Inertia.js</a>. Laravel Jetstream, in addition to offering browser-based cookie authentication, includes built-in integration with Laravel Sanctum to offer API token authentication. Laravel's API authentication offerings are discussed below.</p>  <h4 id="laravels-api-authentication-services">Laravel's API Authentication Services</h4> <p>Laravel provides two optional packages to assist you in managing API tokens and authenticating requests made with API tokens: <a href="passport">Passport</a> and <a href="sanctum">Sanctum</a>. Please note that these libraries and Laravel's built-in cookie based authentication libraries are not mutually exclusive. These libraries primarily focus on API token authentication while the built-in authentication services focus on cookie based browser authentication. Many applications will use both Laravel's built-in cookie based authentication services and one of Laravel's API authentication packages.</p> <p><strong>Passport</strong></p> <p>Passport is an OAuth2 authentication provider, offering a variety of OAuth2 "grant types" which allow you to issue various types of tokens. In general, this is a robust and complex package for API authentication. However, most applications do not require the complex features offered by the OAuth2 spec, which can be confusing for both users and developers. In addition, developers have been historically confused about how to authenticate SPA applications or mobile applications using OAuth2 authentication providers like Passport.</p> <p><strong>Sanctum</strong></p> <p>In response to the complexity of OAuth2 and developer confusion, we set out to build a simpler, more streamlined authentication package that could handle both first-party web requests from a web browser and API requests via tokens. This goal was realized with the release of <a href="sanctum">Laravel Sanctum</a>, which should be considered the preferred and recommended authentication package for applications that will be offering a first-party web UI in addition to an API, or will be powered by a single-page application that exists separately from the backend Laravel application, or applications that offer a mobile client.</p> <p>Laravel Sanctum is a hybrid web / API authentication package that can manage your application's entire authentication process. This is possible because when Sanctum based applications receive a request, Sanctum will first determine if the request includes a session cookie that references an authenticated session. Sanctum accomplishes this by calling Laravel's built-in authentication services which we discussed earlier. If the request is not being authenticated via a session cookie, Sanctum will inspect the request for an API token. If an API token is present, Sanctum will authenticate the request using that token. To learn more about this process, please consult Sanctum's <a href="sanctum#how-it-works">"how it works"</a> documentation.</p> <p>Laravel Sanctum is the API package we have chosen to include with the <a href="https://jetstream.laravel.com">Laravel Jetstream</a> authentication scaffolding because we believe it is the best fit for the majority of web application's authentication needs.</p>  <h4 id="summary-choosing-your-stack">Summary &amp; Choosing Your Stack</h4> <p>In summary, if your application will be accessed using a browser, your application will use Laravel's built-in authentication services.</p> <p>Next, if your application offers an API, you will choose between <a href="passport">Passport</a> or <a href="sanctum">Sanctum</a> to provide API token authentication for your application. In general, Sanctum should be preferred when possible since it is a simple, complete solution for API authentication, SPA authentication, and mobile authentication, including support for "scopes" or "abilities".</p> <p>Passport may be chosen when your application absolutely needs all of the features provided by the OAuth2 specification.</p> <p>And, if you would like to get started quickly, we are pleased to recommend <a href="https://jetstream.laravel.com">Laravel Jetstream</a> as a quick way to start a new Laravel application that already uses our preferred authentication stack of Laravel's built-in authentication services and Laravel Sanctum.</p>  <h2 id="authentication-quickstart">Authentication Quickstart</h2> <blockquote> <p>This portion of the documentation discusses authenticating users via the <a href="https://jetstream.laravel.com">Laravel Jetstream</a> package, which includes UI scaffolding to help you get started quickly. If you would like to integrate with Laravel's authentication systems directly, check out the documentation on <a href="#authenticating-users">manually authenticating users</a>.</p> </blockquote>  <h3 id="included-routing">Routing</h3> <p>Laravel's <code>laravel/jetstream</code> package provides a quick way to scaffold all of the routes, views, and other backend logic needed for authentication using a few simple commands:</p> <pre data-language="php">composer require laravel/jetstream

// Install Jetstream with the Livewire stack...
php artisan jetstream:install livewire

// Install Jetstream with the Inertia stack...
php artisan jetstream:install inertia</pre> <p>This command should be used on fresh applications and will install a layout view, registration and login views, as well as routes for all authentication end-points. A <code>/dashboard</code> route will also be generated to handle post-login requests to your application's dashboard.</p>  <h4 id="creating-applications-including-authentication">Creating Applications Including Authentication</h4> <p>If you are starting a brand new application and would like to include the authentication scaffolding, you may use the <code>--jet</code> directive when creating your application via the Laravel Installer. This command will create a new application with all of the authentication scaffolding compiled and installed:</p> <pre data-language="php">laravel new kitetail --jet</pre> <blockquote class="tip"> <p>To learn more about Jetstream, please visit the official <a href="https://jetstream.laravel.com">Jetstream documentation</a>.</p> </blockquote>  <h3 id="included-views">Views</h3> <p>As mentioned in the previous section, the <code>laravel/jetstream</code> package's <code>php artisan jetstream:install</code> command will create all of the views you need for authentication and place them in the <code>resources/views/auth</code> directory.</p> <p>Jetstream will also create a <code>resources/views/layouts</code> directory containing a base layout for your application. All of these views use the <a href="https://tailwindcss.com">Tailwind CSS</a> framework, but you are free to customize them however you wish.</p>  <h3 id="included-authenticating">Authenticating</h3> <p>Now that your application has been scaffolded for authentication, you are ready to register and authenticate! You may simply access your application in a browser since Jetstream's authentication controllers already contain the logic to authenticate existing users and store new users in the database.</p>  <h4 id="path-customization">Path Customization</h4> <p>When a user is successfully authenticated, they will typically be redirected to the <code>/home</code> URI. You can customize the post-authentication redirect path using the <code>HOME</code> constant defined in your <code>RouteServiceProvider</code>:</p> <pre data-language="php">public const HOME = '/home';</pre> <p>When using Laravel Jetstream, the Jetstream installation process will change the value of the <code>HOME</code> constant to <code>/dashboard</code>.</p>  <h3 id="retrieving-the-authenticated-user">Retrieving The Authenticated User</h3> <p>While handling an incoming request, you may access the authenticated user via the <code>Auth</code> facade:</p> <pre data-language="php">use Illuminate\Support\Facades\Auth;

// Get the currently authenticated user...
$user = Auth::user();

// Get the currently authenticated user's ID...
$id = Auth::id();</pre> <p>Alternatively, once a user is authenticated, you may access the authenticated user via an <code>Illuminate\Http\Request</code> instance. Remember, type-hinted classes will automatically be injected into your controller methods. By type-hinting the <code>Illuminate\Http\Request</code> object, you may gain convenient access to the authenticated user from any controller method in your application:</p> <pre data-language="php">&lt;?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class FlightController extends Controller
{
    /**
     * Get a list of all available flights.
     *
     * @param  Request  $request
     * @return Response
     */
    public function update(Request $request)
    {
        // $request-&gt;user() returns an instance of the authenticated user...
    }
}</pre>  <h4 id="determining-if-the-current-user-is-authenticated">Determining If The Current User Is Authenticated</h4> <p>To determine if the user is already logged into your application, you may use the <code>check</code> method on the <code>Auth</code> facade, which will return <code>true</code> if the user is authenticated:</p> <pre data-language="php">use Illuminate\Support\Facades\Auth;

if (Auth::check()) {
    // The user is logged in...
}</pre> <blockquote class="tip"> <p>Even though it is possible to determine if a user is authenticated using the <code>check</code> method, you will typically use a middleware to verify that the user is authenticated before allowing the user access to certain routes / controllers. To learn more about this, check out the documentation on <a href="authentication#protecting-routes">protecting routes</a>.</p> </blockquote>  <h3 id="protecting-routes">Protecting Routes</h3> <p><a href="middleware">Route middleware</a> can be used to only allow authenticated users to access a given route. Laravel ships with an <code>auth</code> middleware, which references the <code>Illuminate\Auth\Middleware\Authenticate</code> class. Since this middleware is already registered in your HTTP kernel, all you need to do is attach the middleware to a route definition:</p> <pre data-language="php">Route::get('flights', function () {
    // Only authenticated users may enter...
})-&gt;middleware('auth');</pre>  <h4 id="redirecting-unauthenticated-users">Redirecting Unauthenticated Users</h4> <p>When the <code>auth</code> middleware detects an unauthorized user, it will redirect the user to the <code>login</code> <a href="routing#named-routes">named route</a>. You may modify this behavior by updating the <code>redirectTo</code> function in your <code>app/Http/Middleware/Authenticate.php</code> file:</p> <pre data-language="php">/**
 * Get the path the user should be redirected to.
 *
 * @param  \Illuminate\Http\Request  $request
 * @return string
 */
protected function redirectTo($request)
{
    return route('login');
}</pre>  <h4 id="specifying-a-guard">Specifying A Guard</h4> <p>When attaching the <code>auth</code> middleware to a route, you may also specify which guard should be used to authenticate the user. The guard specified should correspond to one of the keys in the <code>guards</code> array of your <code>auth.php</code> configuration file:</p> <pre data-language="php">Route::get('flights', function () {
    // Only authenticated users may enter...
})-&gt;middleware('auth:api');</pre>  <h3 id="login-throttling">Login Throttling</h3> <p>If you are using Laravel Jetstream, rate limiting will automatically be applied to login attempts. By default, the user will not be able to login for one minute if they fail to provide the correct credentials after several attempts. The throttling is unique to the user's username / e-mail address and their IP address.</p> <blockquote class="tip"> <p>If you would like to rate limit your own routes, check out the <a href="routing#rate-limiting">rate limiting documentation</a>.</p> </blockquote>  <h2 id="authenticating-users">Manually Authenticating Users</h2> <p>You are not required to use the authentication scaffolding included with Laravel Jetstream. If you choose to not use this scaffolding, you will need to manage user authentication using the Laravel authentication classes directly. Don't worry, it's a cinch!</p> <p>We will access Laravel's authentication services via the <code>Auth</code> <a href="facades">facade</a>, so we'll need to make sure to import the <code>Auth</code> facade at the top of the class. Next, let's check out the <code>attempt</code> method:</p> <pre data-language="php">&lt;?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class LoginController extends Controller
{
    /**
     * Handle an authentication attempt.
     *
     * @param  \Illuminate\Http\Request $request
     *
     * @return Response
     */
    public function authenticate(Request $request)
    {
        $credentials = $request-&gt;only('email', 'password');

        if (Auth::attempt($credentials)) {
            // Authentication passed...
            return redirect()-&gt;intended('dashboard');
        }
    }
}</pre> <p>The <code>attempt</code> method accepts an array of key / value pairs as its first argument. The values in the array will be used to find the user in your database table. So, in the example above, the user will be retrieved by the value of the <code>email</code> column. If the user is found, the hashed password stored in the database will be compared with the <code>password</code> value passed to the method via the array. You should not hash the password specified as the <code>password</code> value, since the framework will automatically hash the value before comparing it to the hashed password in the database. If the two hashed passwords match an authenticated session will be started for the user.</p> <p>The <code>attempt</code> method will return <code>true</code> if authentication was successful. Otherwise, <code>false</code> will be returned.</p> <p>The <code>intended</code> method on the redirector will redirect the user to the URL they were attempting to access before being intercepted by the authentication middleware. A fallback URI may be given to this method in case the intended destination is not available.</p>  <h4 id="specifying-additional-conditions">Specifying Additional Conditions</h4> <p>If you wish, you may also add extra conditions to the authentication query in addition to the user's e-mail and password. For example, we may verify that the user is marked as "active":</p> <pre data-language="php">if (Auth::attempt(['email' =&gt; $email, 'password' =&gt; $password, 'active' =&gt; 1])) {
    // The user is active, not suspended, and exists.
}</pre> <blockquote> <p>In these examples, <code>email</code> is not a required option, it is merely used as an example. You should use whatever column name corresponds to a "username" in your database.</p> </blockquote>  <h4 id="accessing-specific-guard-instances">Accessing Specific Guard Instances</h4> <p>You may specify which guard instance you would like to utilize using the <code>guard</code> method on the <code>Auth</code> facade. This allows you to manage authentication for separate parts of your application using entirely separate authenticatable models or user tables.</p> <p>The guard name passed to the <code>guard</code> method should correspond to one of the guards configured in your <code>auth.php</code> configuration file:</p> <pre data-language="php">if (Auth::guard('admin')-&gt;attempt($credentials)) {
    //
}</pre>  <h4 id="manually-logging-out">Logging Out</h4> <p>To log users out of your application, you may use the <code>logout</code> method on the <code>Auth</code> facade. This will clear the authentication information in the user's session:</p> <pre data-language="php">Auth::logout();</pre>  <h3 id="remembering-users">Remembering Users</h3> <p>If you would like to provide "remember me" functionality in your application, you may pass a boolean value as the second argument to the <code>attempt</code> method, which will keep the user authenticated indefinitely, or until they manually logout. Your <code>users</code> table must include the string <code>remember_token</code> column, which will be used to store the "remember me" token.</p> <pre data-language="php">if (Auth::attempt(['email' =&gt; $email, 'password' =&gt; $password], $remember)) {
    // The user is being remembered...
}</pre> <p>If you are "remembering" users, you may use the <code>viaRemember</code> method to determine if the user was authenticated using the "remember me" cookie:</p> <pre data-language="php">if (Auth::viaRemember()) {
    //
}</pre>  <h3 id="other-authentication-methods">Other Authentication Methods</h3>  <h4 id="authenticate-a-user-instance">Authenticate A User Instance</h4> <p>If you need to log an existing user instance into your application, you may call the <code>login</code> method with the user instance. The given object must be an implementation of the <code>Illuminate\Contracts\Auth\Authenticatable</code> <a href="contracts">contract</a>. The <code>App\Models\User</code> model included with Laravel already implements this interface. This method of authentication is useful when you already have a valid user instance, such as directly after a user registers with your application:</p> <pre data-language="php">Auth::login($user);

// Login and "remember" the given user...
Auth::login($user, true);</pre> <p>You may specify the guard instance you would like to use:</p> <pre data-language="php">Auth::guard('admin')-&gt;login($user);</pre>  <h4 id="authenticate-a-user-by-id">Authenticate A User By ID</h4> <p>To log a user into the application by their ID, you may use the <code>loginUsingId</code> method. This method accepts the primary key of the user you wish to authenticate:</p> <pre data-language="php">Auth::loginUsingId(1);

// Login and "remember" the given user...
Auth::loginUsingId(1, true);</pre>  <h4 id="authenticate-a-user-once">Authenticate A User Once</h4> <p>You may use the <code>once</code> method to log a user into the application for a single request. No sessions or cookies will be utilized, which means this method may be helpful when building a stateless API:</p> <pre data-language="php">if (Auth::once($credentials)) {
    //
}</pre>  <h2 id="http-basic-authentication">HTTP Basic Authentication</h2> <p><a href="https://en.wikipedia.org/wiki/Basic_access_authentication">HTTP Basic Authentication</a> provides a quick way to authenticate users of your application without setting up a dedicated "login" page. To get started, attach the <code>auth.basic</code> <a href="middleware">middleware</a> to your route. The <code>auth.basic</code> middleware is included with the Laravel framework, so you do not need to define it:</p> <pre data-language="php">Route::get('profile', function () {
    // Only authenticated users may enter...
})-&gt;middleware('auth.basic');</pre> <p>Once the middleware has been attached to the route, you will automatically be prompted for credentials when accessing the route in your browser. By default, the <code>auth.basic</code> middleware will use the <code>email</code> column on the user record as the "username".</p>  <h4 id="a-note-on-fastcgi">A Note On FastCGI</h4> <p>If you are using PHP FastCGI, HTTP Basic authentication may not work correctly out of the box. The following lines should be added to your <code>.htaccess</code> file:</p> <pre data-language="php">RewriteCond %{HTTP:Authorization} ^(.+)$
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]</pre>  <h3 id="stateless-http-basic-authentication">Stateless HTTP Basic Authentication</h3> <p>You may also use HTTP Basic Authentication without setting a user identifier cookie in the session, which is particularly useful for API authentication. To do so, <a href="middleware">define a middleware</a> that calls the <code>onceBasic</code> method. If no response is returned by the <code>onceBasic</code> method, the request may be passed further into the application:</p> <pre data-language="php">&lt;?php

namespace App\Http\Middleware;

use Illuminate\Support\Facades\Auth;

class AuthenticateOnceWithBasicAuth
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, $next)
    {
        return Auth::onceBasic() ?: $next($request);
    }

}</pre> <p>Next, <a href="middleware#registering-middleware">register the route middleware</a> and attach it to a route:</p> <pre data-language="php">Route::get('api/user', function () {
    // Only authenticated users may enter...
})-&gt;middleware('auth.basic.once');</pre>  <h2 id="logging-out">Logging Out</h2> <p>To manually log users out of your application, you may use the <code>logout</code> method on the <code>Auth</code> facade. This will clear the authentication information in the user's session:</p> <pre data-language="php">use Illuminate\Support\Facades\Auth;

Auth::logout();</pre>  <h3 id="invalidating-sessions-on-other-devices">Invalidating Sessions On Other Devices</h3> <p>Laravel also provides a mechanism for invalidating and "logging out" a user's sessions that are active on other devices without invalidating the session on their current device. This feature is typically utilized when a user is changing or updating their password and you would like to invalidate sessions on other devices while keeping the current device authenticated.</p> <p>Before getting started, you should make sure that the <code>Illuminate\Session\Middleware\AuthenticateSession</code> middleware is present and un-commented in your <code>app/Http/Kernel.php</code> class' <code>web</code> middleware group:</p> <pre data-language="php">'web' =&gt; [
    // ...
    \Illuminate\Session\Middleware\AuthenticateSession::class,
    // ...
],</pre> <p>Then, you may use the <code>logoutOtherDevices</code> method on the <code>Auth</code> facade. This method requires the user to provide their current password, which your application should accept through an input form:</p> <pre data-language="php">use Illuminate\Support\Facades\Auth;

Auth::logoutOtherDevices($password);</pre> <p>When the <code>logoutOtherDevices</code> method is invoked, the user's other sessions will be invalidated entirely, meaning they will be "logged out" of all guards they were previously authenticated by.</p> <blockquote> <p>When using the <code>AuthenticateSession</code> middleware in combination with a custom route name for the <code>login</code> route, you must override the <code>unauthenticated</code> method on your application's exception handler to properly redirect users to your login page.</p> </blockquote>  <h2 id="password-confirmation">Password Confirmation</h2> <p>While building your application, you may occasionally have actions that should require the user to confirm their password before the action is performed. Laravel includes built-in middleware to make this process a breeze. Implementing this feature will require you to define two routes: one route to display a view asking the user to confirm their password, and one route to confirm that the password is valid and redirect the user to their intended destination.</p> <blockquote class="tip"> <p>The following documentation discusses how to integrate with Laravel's password confirmation features directly; however, if you would like to get started more quickly, the <a href="https://jetstream.laravel.com">Laravel Jetstream</a> authentication scaffolding package includes support for this feature!</p> </blockquote>  <h3 id="password-confirmation-configuration">Configuration</h3> <p>After confirming their password, a user will not be asked to confirm their password again for three hours. However, you may configure the length of time before the user is re-prompted for their password by changing the value of the <code>password_timeout</code> configuration value within your <code>auth</code> configuration file.</p>  <h3 id="password-confirmation-routing">Routing</h3>  <h4 id="the-password-confirmation-form">The Password Confirmation Form</h4> <p>First, we will define the route that is needed to display a view requesting that the user confirm their password:</p> <pre data-language="php">Route::get('/confirm-password', function () {
    return view('auth.confirm-password');
})-&gt;middleware(['auth'])-&gt;name('password.confirm');</pre> <p>As you might expect, the view that is returned by this route should have a form containing a <code>password</code> field. In addition, feel free to include text within the view that explains that the user is entering a protected area of the application and must confirm their password.</p>  <h4 id="confirming-the-password">Confirming The Password</h4> <p>Next, we will define a route that will handle the form request from the "confirm password" view. This route will be responsible for validating the password and redirecting the user to their intended destination:</p> <pre data-language="php">use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;

Route::post('/confirm-password', function (Request $request) {
    if (! Hash::check($request-&gt;password, $request-&gt;user()-&gt;password)) {
        return back()-&gt;withErrors([
            'password' =&gt; ['The provided password does not match our records.']
        ]);
    }

    $request-&gt;session()-&gt;passwordConfirmed();

    return redirect()-&gt;intended();
})-&gt;middleware(['auth', 'throttle:6,1'])-&gt;name('password.confirm');</pre> <p>Before moving on, let's examine this route in more detail. First, the request's <code>password</code> attribute is determined to actually match the authenticated user's password. If the password is valid, we need to inform Laravel's session that the user has confirmed their password. The <code>passwordConfirmed</code> method will set a timestamp in the user's session that Laravel can use to determine when the user last confirmed their password. Finally, we can redirect the user to their intended destination.</p>  <h3 id="password-confirmation-protecting-routes">Protecting Routes</h3> <p>You should ensure that any route that performs an action that should require recent password confirmation is assigned the <code>password.confirm</code> middleware. This middleware is included with the default installation of Laravel and will automatically store the user's intended destination in the session so that the user may be redirected to that location after confirming their password. After storing the user's intended destination in the session, the middleware will redirect the user to the <code>password.confirm</code> <a href="routing#named-routes">named route</a>:</p> <pre data-language="php">Route::get('/settings', function () {
    // ...
})-&gt;middleware(['password.confirm']);

Route::post('/settings', function () {
    // ...
})-&gt;middleware(['password.confirm']);</pre>  <h2 id="adding-custom-guards">Adding Custom Guards</h2> <p>You may define your own authentication guards using the <code>extend</code> method on the <code>Auth</code> facade. You should place this call to <code>extend</code> within a <a href="providers">service provider</a>. Since Laravel already ships with an <code>AuthServiceProvider</code>, we can place the code in that provider:</p> <pre data-language="php">&lt;?php

namespace App\Providers;

use App\Services\Auth\JwtGuard;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Auth;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * Register any application authentication / authorization services.
     *
     * @return void
     */
    public function boot()
    {
        $this-&gt;registerPolicies();

        Auth::extend('jwt', function ($app, $name, array $config) {
            // Return an instance of Illuminate\Contracts\Auth\Guard...

            return new JwtGuard(Auth::createUserProvider($config['provider']));
        });
    }
}</pre> <p>As you can see in the example above, the callback passed to the <code>extend</code> method should return an implementation of <code>Illuminate\Contracts\Auth\Guard</code>. This interface contains a few methods you will need to implement to define a custom guard. Once your custom guard has been defined, you may use this guard in the <code>guards</code> configuration of your <code>auth.php</code> configuration file:</p> <pre data-language="php">'guards' =&gt; [
    'api' =&gt; [
        'driver' =&gt; 'jwt',
        'provider' =&gt; 'users',
    ],
],</pre>  <h3 id="closure-request-guards">Closure Request Guards</h3> <p>The simplest way to implement a custom, HTTP request based authentication system is by using the <code>Auth::viaRequest</code> method. This method allows you to quickly define your authentication process using a single Closure.</p> <p>To get started, call the <code>Auth::viaRequest</code> method within the <code>boot</code> method of your <code>AuthServiceProvider</code>. The <code>viaRequest</code> method accepts an authentication driver name as its first argument. This name can be any string that describes your custom guard. The second argument passed to the method should be a Closure that receives the incoming HTTP request and returns a user instance or, if authentication fails, <code>null</code>:</p> <pre data-language="php">use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

/**
 * Register any application authentication / authorization services.
 *
 * @return void
 */
public function boot()
{
    $this-&gt;registerPolicies();

    Auth::viaRequest('custom-token', function ($request) {
        return User::where('token', $request-&gt;token)-&gt;first();
    });
}</pre> <p>Once your custom authentication driver has been defined, you use it as a driver within the <code>guards</code> configuration of your <code>auth.php</code> configuration file:</p> <pre data-language="php">'guards' =&gt; [
    'api' =&gt; [
        'driver' =&gt; 'custom-token',
    ],
],</pre>  <h2 id="adding-custom-user-providers">Adding Custom User Providers</h2> <p>If you are not using a traditional relational database to store your users, you will need to extend Laravel with your own authentication user provider. We will use the <code>provider</code> method on the <code>Auth</code> facade to define a custom user provider:</p> <pre data-language="php">&lt;?php

namespace App\Providers;

use App\Extensions\RiakUserProvider;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Auth;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * Register any application authentication / authorization services.
     *
     * @return void
     */
    public function boot()
    {
        $this-&gt;registerPolicies();

        Auth::provider('riak', function ($app, array $config) {
            // Return an instance of Illuminate\Contracts\Auth\UserProvider...

            return new RiakUserProvider($app-&gt;make('riak.connection'));
        });
    }
}</pre> <p>After you have registered the provider using the <code>provider</code> method, you may switch to the new user provider in your <code>auth.php</code> configuration file. First, define a <code>provider</code> that uses your new driver:</p> <pre data-language="php">'providers' =&gt; [
    'users' =&gt; [
        'driver' =&gt; 'riak',
    ],
],</pre> <p>Finally, you may use this provider in your <code>guards</code> configuration:</p> <pre data-language="php">'guards' =&gt; [
    'web' =&gt; [
        'driver' =&gt; 'session',
        'provider' =&gt; 'users',
    ],
],</pre>  <h3 id="the-user-provider-contract">The User Provider Contract</h3> <p>The <code>Illuminate\Contracts\Auth\UserProvider</code> implementations are only responsible for fetching an <code>Illuminate\Contracts\Auth\Authenticatable</code> implementation out of a persistent storage system, such as MySQL, Riak, etc. These two interfaces allow the Laravel authentication mechanisms to continue functioning regardless of how the user data is stored or what type of class is used to represent it.</p> <p>Let's take a look at the <code>Illuminate\Contracts\Auth\UserProvider</code> contract:</p> <pre data-language="php">&lt;?php

namespace Illuminate\Contracts\Auth;

interface UserProvider
{
    public function retrieveById($identifier);
    public function retrieveByToken($identifier, $token);
    public function updateRememberToken(Authenticatable $user, $token);
    public function retrieveByCredentials(array $credentials);
    public function validateCredentials(Authenticatable $user, array $credentials);
}</pre> <p>The <code>retrieveById</code> function typically receives a key representing the user, such as an auto-incrementing ID from a MySQL database. The <code>Authenticatable</code> implementation matching the ID should be retrieved and returned by the method.</p> <p>The <code>retrieveByToken</code> function retrieves a user by their unique <code>$identifier</code> and "remember me" <code>$token</code>, stored in a field <code>remember_token</code>. As with the previous method, the <code>Authenticatable</code> implementation should be returned.</p> <p>The <code>updateRememberToken</code> method updates the <code>$user</code> field <code>remember_token</code> with the new <code>$token</code>. A fresh token is assigned on a successful "remember me" login attempt or when the user is logging out.</p> <p>The <code>retrieveByCredentials</code> method receives the array of credentials passed to the <code>Auth::attempt</code> method when attempting to sign into an application. The method should then "query" the underlying persistent storage for the user matching those credentials. Typically, this method will run a query with a "where" condition on <code>$credentials['username']</code>. The method should then return an implementation of <code>Authenticatable</code>. <strong>This method should not attempt to do any password validation or authentication.</strong></p> <p>The <code>validateCredentials</code> method should compare the given <code>$user</code> with the <code>$credentials</code> to authenticate the user. For example, this method should probably use <code>Hash::check</code> to compare the value of <code>$user-&gt;getAuthPassword()</code> to the value of <code>$credentials['password']</code>. This method should return <code>true</code> or <code>false</code> indicating on whether the password is valid.</p>  <h3 id="the-authenticatable-contract">The Authenticatable Contract</h3> <p>Now that we have explored each of the methods on the <code>UserProvider</code>, let's take a look at the <code>Authenticatable</code> contract. Remember, the provider should return implementations of this interface from the <code>retrieveById</code>, <code>retrieveByToken</code>, and <code>retrieveByCredentials</code> methods:</p> <pre data-language="php">&lt;?php

namespace Illuminate\Contracts\Auth;

interface Authenticatable
{
    public function getAuthIdentifierName();
    public function getAuthIdentifier();
    public function getAuthPassword();
    public function getRememberToken();
    public function setRememberToken($value);
    public function getRememberTokenName();
}</pre> <p>This interface is simple. The <code>getAuthIdentifierName</code> method should return the name of the "primary key" field of the user and the <code>getAuthIdentifier</code> method should return the "primary key" of the user. In a MySQL back-end, again, this would be the auto-incrementing primary key. The <code>getAuthPassword</code> should return the user's hashed password. This interface allows the authentication system to work with any User class, regardless of what ORM or storage abstraction layer you are using. By default, Laravel includes a <code>User</code> class in the <code>app</code> directory which implements this interface, so you may consult this class for an implementation example.</p>  <h2 id="events">Events</h2> <p>Laravel raises a variety of <a href="events">events</a> during the authentication process. You may attach listeners to these events in your <code>EventServiceProvider</code>:</p> <pre data-language="php">/**
 * The event listener mappings for the application.
 *
 * @var array
 */
protected $listen = [
    'Illuminate\Auth\Events\Registered' =&gt; [
        'App\Listeners\LogRegisteredUser',
    ],

    'Illuminate\Auth\Events\Attempting' =&gt; [
        'App\Listeners\LogAuthenticationAttempt',
    ],

    'Illuminate\Auth\Events\Authenticated' =&gt; [
        'App\Listeners\LogAuthenticated',
    ],

    'Illuminate\Auth\Events\Login' =&gt; [
        'App\Listeners\LogSuccessfulLogin',
    ],

    'Illuminate\Auth\Events\Failed' =&gt; [
        'App\Listeners\LogFailedLogin',
    ],

    'Illuminate\Auth\Events\Validated' =&gt; [
        'App\Listeners\LogValidated',
    ],

    'Illuminate\Auth\Events\Verified' =&gt; [
        'App\Listeners\LogVerified',
    ],

    'Illuminate\Auth\Events\Logout' =&gt; [
        'App\Listeners\LogSuccessfulLogout',
    ],

    'Illuminate\Auth\Events\CurrentDeviceLogout' =&gt; [
        'App\Listeners\LogCurrentDeviceLogout',
    ],

    'Illuminate\Auth\Events\OtherDeviceLogout' =&gt; [
        'App\Listeners\LogOtherDeviceLogout',
    ],

    'Illuminate\Auth\Events\Lockout' =&gt; [
        'App\Listeners\LogLockout',
    ],

    'Illuminate\Auth\Events\PasswordReset' =&gt; [
        'App\Listeners\LogPasswordReset',
    ],
];</pre> </section><div class="_attribution">
  <p class="_attribution-p">
    © Taylor Otwell<br>Licensed under the MIT License.<br>Laravel is a trademark of Taylor Otwell.<br>
    <a href="https://laravel.com/docs/8.x/authentication" class="_attribution-link">https://laravel.com/docs/8.x/authentication</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
