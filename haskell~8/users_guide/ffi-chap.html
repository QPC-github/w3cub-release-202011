
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>12. Foreign Function Interface (FFI) - Haskell 8 - W3cubDocs</title>
  
  <meta name="description" content=" Allow use of the Haskell foreign function interface. ">
  <meta name="keywords" content="foreign, function, interface, ffi, haskell, haskell~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~8/users_guide/ffi-chap.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/haskell~8.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~8/" class="_nav-link" title="" style="margin-left:0;">Haskell 8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 id="ffi">12. Foreign function interface (FFI)</h1>
<div class="_sphinx">   <dl class="extension" id="foreign-function-interface-ffi"> <dt id="extension-ForeignFunctionInterface">
<code>ForeignFunctionInterface</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow use of the Haskell foreign function interface.</p> </dd>
</dl> <p>GHC (mostly) conforms to the Haskell Foreign Function Interface, whose definition is part of the Haskell Report on <a class="reference external" href="http://www.haskell.org/">http://www.haskell.org/</a>.</p> <p>FFI support is enabled by default, but can be enabled or disabled explicitly with the <a class="reference internal" href="#extension-ForeignFunctionInterface"><code>ForeignFunctionInterface</code></a> flag.</p> <p>GHC implements a number of GHC-specific extensions to the FFI Chapter of the Haskell 2010 Report. These extensions are described in <a class="reference internal" href="#ffi-ghcexts"><span class="std std-ref">GHC extensions to the FFI Chapter</span></a>, but please note that programs using these features are not portable. Hence, these features should be avoided where possible.</p> <p>The FFI libraries are documented in the accompanying library documentation; see for example the <a class="reference external" href="../libraries/base-4.13.0.0/foreign">Foreign</a> module.</p>  <h2 id="ghc-differences-to-the-ffi-chapter">12.1. GHC differences to the FFI Chapter</h2>  <h3 id="guaranteed-call-safety">12.1.1. Guaranteed call safety</h3> <p>The Haskell 2010 Report specifies that <code>safe</code> FFI calls must allow foreign calls to safely call into Haskell code. In practice, this means that the garbage collector must be able to run while these calls are in progress, moving heap-allocated Haskell values around arbitrarily.</p> <p>This greatly constrains library authors since it implies that it is not safe to pass any heap object reference to a <code>safe</code> foreign function call. For instance, it is often desirable to pass an unpinned <code>ByteArray#</code>s directly to native code to avoid making an otherwise-unnecessary copy. However, this can only be done safely if the array is guaranteed not to be moved by the garbage collector in the middle of the call.</p> <p>The Chapter does <em>not</em> require implementations to refrain from doing the same for <code>unsafe</code> calls, so strictly Haskell 2010-conforming programs cannot pass heap-allocated references to <code>unsafe</code> FFI calls either.</p> <p>In previous releases, GHC would take advantage of the freedom afforded by the Chapter by performing <code>safe</code> foreign calls in place of <code>unsafe</code> calls in the bytecode interpreter. This meant that some packages which worked when compiled would fail under GHCi (e.g. <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/13730">Issue #13730</a>).</p> <p>However, since version 8.4 this is no longer the case: GHC <strong>guarantees</strong> that garbage collection will never occur during an <code>unsafe</code> call, even in the bytecode interpreter, and further guarantees that <code>unsafe</code> calls will be performed in the calling thread.</p>    <h2 id="ffi-ghcexts">12.2. GHC extensions to the FFI Chapter</h2> <p id="ghc-extensions-to-the-ffi-chapter">The FFI features that are described in this section are specific to GHC. Your code will not be portable to other compilers if you use them.</p>  <h3 id="unboxed-types">12.2.1. Unboxed types</h3> <p>The following unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6): <code>Int#</code>, <code>Word#</code>, <code>Char#</code>, <code>Float#</code>, <code>Double#</code>, <code>Addr#</code>, <code>StablePtr# a</code>, <code>MutableByteArray#</code>, <code>ForeignObj#</code>, and <code>ByteArray#</code>.</p>   <h3 id="ffi-newtype-io">12.2.2. Newtype wrapping of the IO monad</h3> <p id="newtype-wrapping-of-the-io-monad">The FFI spec requires the IO monad to appear in various places, but it can sometimes be convenient to wrap the IO monad in a <code>newtype</code>, thus:</p> <pre data-language="haskell">newtype MyIO a = MIO (IO a)
</pre> <p>(A reason for doing so might be to prevent the programmer from calling arbitrary IO procedures in some part of the program.)</p> <p>The Haskell FFI already specifies that arguments and results of foreign imports and exports will be automatically unwrapped if they are newtypes (Section 3.2 of the FFI addendum). GHC extends the FFI by automatically unwrapping any newtypes that wrap the IO monad itself. More precisely, wherever the FFI specification requires an <code>IO</code> type, GHC will accept any newtype-wrapping of an <code>IO</code> type. For example, these declarations are OK:</p> <pre data-language="haskell">foreign import foo :: Int -&gt; MyIO Int
foreign import "dynamic" baz :: (Int -&gt; MyIO Int) -&gt; CInt -&gt; MyIO Int
</pre>   <h3 id="ffi-prim">12.2.3. Primitive imports</h3> <p id="primitive-imports">GHC extends the FFI with an additional calling convention <code>prim</code>, e.g.:</p> <pre data-language="haskell">foreign import prim "foo" foo :: ByteArray# -&gt; (# Int#, Int# #)
</pre> <p>This is used to import functions written in Cmm code that follow an internal GHC calling convention. The arguments and results must be unboxed types, except that an argument may be of type <code>Any</code> (by way of <code>unsafeCoerce#</code>) and the result type is allowed to be an unboxed tuple or the type <code>Any</code>.</p> <p>This feature is not intended for use outside of the core libraries that come with GHC. For more details see the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/PrimOps">GHC developer wiki</a>.</p>   <h3 id="ffi-interruptible">12.2.4. Interruptible foreign calls</h3> <dl class="extension" id="interruptible-foreign-calls"> <dt id="extension-InterruptibleFFI">
<code>InterruptibleFFI</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.2.1</td> </tr>  </table> </dd>
</dl> <p>This concerns the interaction of foreign calls with <code>Control.Concurrent.throwTo</code>. Normally when the target of a <code>throwTo</code> is involved in a foreign call, the exception is not raised until the call returns, and in the meantime the caller is blocked. This can result in unresponsiveness, which is particularly undesirable in the case of user interrupt (e.g. Control-C). The default behaviour when a Control-C signal is received (<code>SIGINT</code> on Unix) is to raise the <code>UserInterrupt</code> exception in the main thread; if the main thread is blocked in a foreign call at the time, then the program will not respond to the user interrupt.</p> <p>The problem is that it is not possible in general to interrupt a foreign call safely. However, GHC does provide a way to interrupt blocking system calls which works for most system calls on both Unix and Windows. When the <code>InterruptibleFFI</code> extension is enabled, a foreign call can be annotated with <code>interruptible</code> instead of <code>safe</code> or <code>unsafe</code>:</p> <pre data-language="haskell">foreign import ccall interruptible
   "sleep" sleepBlock :: CUint -&gt; IO CUint
</pre> <p><code>interruptible</code> behaves exactly as <code>safe</code>, except that when a <code>throwTo</code> is directed at a thread in an interruptible foreign call, an OS-specific mechanism will be used to attempt to cause the foreign call to return:</p> <dl class="docutils"> <dt>Unix systems</dt> <dd>The thread making the foreign call is sent a <code>SIGPIPE</code> signal using <code>pthread_kill()</code>. This is usually enough to cause a blocking system call to return with <code>EINTR</code> (GHC by default installs an empty signal handler for <code>SIGPIPE</code>, to override the default behaviour which is to terminate the process immediately).</dd> <dt>Windows systems</dt> <dd>[Vista and later only] The RTS calls the Win32 function <code>CancelSynchronousIo</code>, which will cause a blocking I/O operation to return with the error <code>ERROR_OPERATION_ABORTED</code>.</dd> </dl> <p>If the system call is successfully interrupted, it will return to Haskell whereupon the exception can be raised. Be especially careful when using <code>interruptible</code> that the caller of the foreign function is prepared to deal with the consequences of the call being interrupted; on Unix it is good practice to check for <code>EINTR</code> always, but on Windows it is not typically necessary to handle <code>ERROR_OPERATION_ABORTED</code>.</p>   <h3 id="ffi-capi">12.2.5. The CAPI calling convention</h3> <dl class="extension" id="the-capi-calling-convention"> <dt id="extension-CApiFFI">
<code>CApiFFI</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10.1</td> </tr>  </table> </dd>
</dl> <p>The <code>CApiFFI</code> extension allows a calling convention of <code>capi</code> to be used in foreign declarations, e.g.</p> <pre data-language="haskell">foreign import capi "header.h f" f :: CInt -&gt; IO CInt
</pre> <p>Rather than generating code to call <code>f</code> according to the platform’s ABI, we instead call <code>f</code> using the C API defined in the header <code>header.h</code>. Thus <code>f</code> can be called even if it may be defined as a CPP <code>#define</code> rather than a proper function.</p> <p>When using <code>capi</code>, it is also possible to import values, rather than functions. For example,</p> <pre data-language="haskell">foreign import capi "pi.h value pi" c_pi :: CDouble
</pre> <p>will work regardless of whether <code>pi</code> is defined as</p> <pre data-language="c">const double pi = 3.14;
</pre> <p>or with</p> <pre data-language="c">#define pi 3.14
</pre> <p>In order to tell GHC the C type that a Haskell type corresponds to when it is used with the CAPI, a <code>CTYPE</code> pragma can be used on the type definition. The header which defines the type can optionally also be specified. The syntax looks like:</p> <pre data-language="haskell">data    {-# CTYPE "unistd.h" "useconds_t" #-} T = ...
newtype {-# CTYPE            "useconds_t" #-} T = ...
</pre>   <h3 id="hs-thread-done">12.2.6. <code>hs_thread_done()</code>
</h3> <pre data-language="c">void hs_thread_done(void);
</pre> <p>GHC allocates a small amount of thread-local memory when a thread calls a Haskell function via a <code>foreign export</code>. This memory is not normally freed until <code>hs_exit()</code>; the memory is cached so that subsequent calls into Haskell are fast. However, if your application is long-running and repeatedly creates new threads that call into Haskell, you probably want to arrange that this memory is freed in those threads that have finished calling Haskell functions. To do this, call <code>hs_thread_done()</code> from the thread whose memory you want to free.</p> <p>Calling <code>hs_thread_done()</code> is entirely optional. You can call it as often or as little as you like. It is safe to call it from a thread that has never called any Haskell functions, or one that never will. If you forget to call it, the worst that can happen is that some memory remains allocated until <code>hs_exit()</code> is called. If you call it too often, the worst that can happen is that the next call to a Haskell function incurs some extra overhead.</p>   <h3 id="ffi-stable-ptr-extras">12.2.7. Freeing many stable pointers efficiently</h3> <p id="freeing-many-stable-pointers-efficiently">The standard function <code>hs_free_stable_ptr</code> locks the stable pointer table, frees the given stable pointer, and then unlocks the stable pointer table again. When freeing many stable pointers at once, it is usually more efficient to lock and unlock the table only once.</p> <pre data-language="c">extern void hs_lock_stable_ptr_table (void);

extern void hs_unlock_stable_ptr_table (void);

extern void hs_free_stable_ptr_unsafe (HsStablePtr sp);
</pre> <p><code>hs_free_stable_ptr_unsafe</code> must be used <em>only</em> when the table has been locked using <code>hs_lock_stable_ptr_table</code>. It must be unlocked afterwards using <code>hs_unlock_stable_ptr_table</code>. The Haskell garbage collector cannot run while the table is locked, so it should be unlocked promptly. The following operations are forbidden while the stable pointer table is locked:</p> <ul class="simple"> <li>Calling any Haskell function, whether or not that function manipulates stable pointers.</li> <li>Calling any FFI function that deals with the stable pointer table except for arbitrarily many calls to <code>hs_free_stable_ptr_unsafe</code> and the final call to <code>hs_unlock_stable_ptr_table</code>.</li> <li>Calling <code>hs_free_fun_ptr</code>.</li> </ul> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">GHC versions before 8.8 defined undocumented functions <code>hs_lock_stable_tables</code> and <code>hs_unlock_stable_tables</code> instead of <code>hs_lock_stable_ptr_table</code> and <code>hs_unlock_stable_ptr_table</code>. Those names are now deprecated.</p> </div>    <h2 id="ffi-ghc">12.3. Using the FFI with GHC</h2> <p id="using-the-ffi-with-ghc">The following sections also give some hints and tips on the use of the foreign function interface in GHC.</p>  <h3 id="foreign-export-ghc">12.3.1. Using <code>foreign export</code> and <code>foreign import ccall "wrapper"</code> with GHC</h3> <p id="using-foreign-export-and-foreign-import-ccall-wrapper-with-ghc">When GHC compiles a module (say <code>M.hs</code>) which uses <code>foreign export</code> or <code>foreign import "wrapper"</code>, it generates a <code>M_stub.h</code> for use by C programs.</p> <p>For a plain <code>foreign export</code>, the file <code>M_stub.h</code> contains a C prototype for the foreign exported function. For example, if we compile the following module:</p> <pre data-language="haskell">module Foo where

foreign export ccall foo :: Int -&gt; IO Int

foo :: Int -&gt; IO Int
foo n = return (length (f n))

f :: Int -&gt; [Int]
f 0 = []
f n = n:(f (n-1))
</pre> <p>Then <code>Foo_stub.h</code> will contain something like this:</p> <pre data-language="c">#include "HsFFI.h"
extern HsInt foo(HsInt a0);
</pre> <p>To invoke <code>foo()</code> from C, just <code>#include "Foo_stub.h"</code> and call <code>foo()</code>.</p> <p>The <code>Foo_stub.h</code> file can be redirected using the <code>-stubdir</code> option; see <a class="reference internal" href="separate_compilation#options-output"><span class="std std-ref">Redirecting the compilation output(s)</span></a>.</p>  <h4 id="using-own-main">12.3.1.1. Using your own <code>main()</code>
</h4> <p id="using-your-own-main">Normally, GHC’s runtime system provides a <code>main()</code>, which arranges to invoke <code>Main.main</code> in the Haskell program. However, you might want to link some Haskell code into a program which has a main function written in another language, say C. In order to do this, you have to initialize the Haskell runtime system explicitly.</p> <p>Let’s take the example from above, and invoke it from a standalone C program. Here’s the C code:</p> <pre data-language="c">#include &lt;stdio.h&gt;
#include "HsFFI.h"

#ifdef __GLASGOW_HASKELL__
#include "Foo_stub.h"
#endif

int main(int argc, char *argv[])
{
  int i;

  hs_init(&amp;argc, &amp;argv);

  for (i = 0; i &lt; 5; i++) {
    printf("%d\n", foo(2500));
  }

  hs_exit();
  return 0;
}
</pre> <p>We’ve surrounded the GHC-specific bits with <code>#ifdef __GLASGOW_HASKELL__</code>; the rest of the code should be portable across Haskell implementations that support the FFI standard.</p> <p>The call to <code>hs_init()</code> initializes GHC’s runtime system. Do NOT try to invoke any Haskell functions before calling <code>hs_init()</code>: bad things will undoubtedly happen.</p> <p>We pass references to <code>argc</code> and <code>argv</code> to <code>hs_init()</code> so that it can separate out any arguments for the RTS (i.e. those arguments between <code>+RTS...-RTS</code>).</p> <p>After we’ve finished invoking our Haskell functions, we can call <code>hs_exit()</code>, which terminates the RTS.</p> <p>There can be multiple calls to <code>hs_init()</code>, but each one should be matched by one (and only one) call to <code>hs_exit()</code>. The outermost <code>hs_exit()</code> will actually de-initialise the system. Note that currently GHC’s runtime cannot reliably re-initialise after this has happened; see <a class="reference internal" href="bugs#infelicities-ffi"><span class="std std-ref">The Foreign Function Interface</span></a>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">When linking the final program, it is normally easiest to do the link using GHC, although this isn’t essential. If you do use GHC, then don’t forget the flag <a class="reference internal" href="phases#ghc-flag--no-hs-main"><code>-no-hs-main</code></a>, otherwise GHC will try to link to the <code>Main</code> Haskell module.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">On Windows hs_init treats argv as UTF8-encoded. Passing other encodings might lead to unexpected results. Passing NULL as argv is valid but can lead to &lt;unknown&gt; showing up in error messages instead of the name of the executable.</p> </div> <p>To use <code>+RTS</code> flags with <code>hs_init()</code>, we have to modify the example slightly. By default, GHC’s RTS will only accept “safe” <code>+RTS</code> flags (see <a class="reference internal" href="phases#options-linker"><span class="std std-ref">Options affecting linking</span></a>), and the <code>-rtsopts[=⟨none|some|all⟩]</code> link-time flag overrides this. However, <code>-rtsopts[=⟨none|some|all⟩]</code> has no effect when <a class="reference internal" href="phases#ghc-flag--no-hs-main"><code>-no-hs-main</code></a> is in use (and the same goes for <a class="reference internal" href="#"><code>-with-rtsopts=⟨opts⟩</code></a>). To set these options we have to call a GHC-specific API instead of <code>hs_init()</code>:</p> <pre data-language="c">#include &lt;stdio.h&gt;
#include "HsFFI.h"

#ifdef __GLASGOW_HASKELL__
#include "Foo_stub.h"
#include "Rts.h"
#endif

int main(int argc, char *argv[])
{
  int i;

#if __GLASGOW_HASKELL__ &gt;= 703
  {
      RtsConfig conf = defaultRtsConfig;
      conf.rts_opts_enabled = RtsOptsAll;
      hs_init_ghc(&amp;argc, &amp;argv, conf);
  }
#else
  hs_init(&amp;argc, &amp;argv);
#endif

  for (i = 0; i &lt; 5; i++) {
    printf("%d\n", foo(2500));
  }

  hs_exit();
  return 0;
}
</pre> <p>Note two changes: we included <code>Rts.h</code>, which defines the GHC-specific external RTS interface, and we called <code>hs_init_ghc()</code> instead of <code>hs_init()</code>, passing an argument of type <code>RtsConfig</code>. <code>RtsConfig</code> is a struct with various fields that affect the behaviour of the runtime system. Its definition is:</p> <pre data-language="c">typedef struct {
    RtsOptsEnabledEnum rts_opts_enabled;
    const char *rts_opts;
} RtsConfig;

extern const RtsConfig defaultRtsConfig;

typedef enum {
    RtsOptsNone,         // +RTS causes an error
    RtsOptsSafeOnly,     // safe RTS options allowed; others cause an error
    RtsOptsAll           // all RTS options allowed
  } RtsOptsEnabledEnum;
</pre> <p>There is a default value <code>defaultRtsConfig</code> that should be used to initialise variables of type <code>RtsConfig</code>. More fields will undoubtedly be added to <code>RtsConfig</code> in the future, so in order to keep your code forwards-compatible it is best to initialise with <code>defaultRtsConfig</code> and then modify the required fields, as in the code sample above.</p>   <h4 id="ffi-library">12.3.1.2. Making a Haskell library that can be called from foreign code</h4> <p id="making-a-haskell-library-that-can-be-called-from-foreign-code">The scenario here is much like in <a class="reference internal" href="#using-own-main"><span class="std std-ref">Using your own main()</span></a>, except that the aim is not to link a complete program, but to make a library from Haskell code that can be deployed in the same way that you would deploy a library of C code.</p> <p>The main requirement here is that the runtime needs to be initialized before any Haskell code can be called, so your library should provide initialisation and deinitialisation entry points, implemented in C or C++. For example:</p> <pre data-language="c">#include &lt;stdlib.h&gt;
#include "HsFFI.h"

HsBool mylib_init(void){
  int argc = 2;
  char *argv[] = { "+RTS", "-A32m", NULL };
  char **pargv = argv;

  // Initialize Haskell runtime
  hs_init(&amp;argc, &amp;pargv);

  // do any other initialization here and
  // return false if there was a problem
  return HS_BOOL_TRUE;
}

void mylib_end(void){
  hs_exit();
}
</pre> <p>The initialisation routine, <code>mylib_init</code>, calls <code>hs_init()</code> as normal to initialise the Haskell runtime, and the corresponding deinitialisation function <code>mylib_end()</code> calls <code>hs_exit()</code> to shut down the runtime.</p>    <h3 id="glasgow-foreign-headers">12.3.2. Using header files</h3> <p id="using-header-files">C functions are normally declared using prototypes in a C header file. Earlier versions of GHC (6.8.3 and earlier) <code>#include</code>d the header file in the C source file generated from the Haskell code, and the C compiler could therefore check that the C function being called via the FFI was being called at the right type.</p> <p>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the <a class="reference internal" href="codegens#native-code-gen"><span class="std std-ref">native code generator</span></a> (<a class="reference internal" href="phases#ghc-flag--fasm"><code>-fasm</code></a>) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there’s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</p> <p>The <code>-#include</code> option is now deprecated, and the <code>include-files</code> field in a Cabal package specification is ignored.</p>   <h3 id="memory-allocation">12.3.3. Memory Allocation</h3> <p>The FFI libraries provide several ways to allocate memory for use with the FFI, and it isn’t always clear which way is the best. This decision may be affected by how efficient a particular kind of allocation is on a given compiler/platform, so this section aims to shed some light on how the different kinds of allocation perform with GHC.</p> <dl class="docutils"> <dt>
<code>alloca</code> </dt> <dd>
<p class="first">Useful for short-term allocation when the allocation is intended to scope over a given <code>IO</code> computation. This kind of allocation is commonly used when marshalling data to and from FFI functions.</p> <p class="last">In GHC, <code>alloca</code> is implemented using <code>MutableByteArray#</code>, so allocation and deallocation are fast: much faster than C’s <code>malloc/free</code>, but not quite as fast as stack allocation in C. Use <code>alloca</code> whenever you can.</p> </dd> <dt>
<code>mallocForeignPtr</code> </dt> <dd>
<p class="first">Useful for longer-term allocation which requires garbage collection. If you intend to store the pointer to the memory in a foreign data structure, then <code>mallocForeignPtr</code> is <em>not</em> a good choice, however.</p> <p class="last">In GHC, <code>mallocForeignPtr</code> is also implemented using <code>MutableByteArray#</code>. Although the memory is pointed to by a <code>ForeignPtr</code>, there are no actual finalizers involved (unless you add one with <code>addForeignPtrFinalizer</code>), and the deallocation is done using GC, so <code>mallocForeignPtr</code> is normally very cheap.</p> </dd> <dt>
<code>malloc/free</code> </dt> <dd>If all else fails, then you need to resort to <code>Foreign.malloc</code> and <code>Foreign.free</code>. These are just wrappers around the C functions of the same name, and their efficiency will depend ultimately on the implementations of these functions in your platform’s C library. We usually find <code>malloc</code> and <code>free</code> to be significantly slower than the other forms of allocation above.</dd> <dt>
<code>Foreign.Marshal.Pool</code> </dt> <dd>Pools are currently implemented using <code>malloc/free</code>, so while they might be a more convenient way to structure your memory allocation than using one of the other forms of allocation, they won’t be any more efficient. We do plan to provide an improved-performance implementation of Pools in the future, however.</dd> </dl>   <h3 id="ffi-threads">12.3.4. Multi-threading and the FFI</h3> <p id="multi-threading-and-the-ffi">In order to use the FFI in a multi-threaded setting, you must use the <a class="reference internal" href="phases#ghc-flag--threaded"><code>-threaded</code></a> option (see <a class="reference internal" href="phases#options-linker"><span class="std std-ref">Options affecting linking</span></a>).</p>  <h4 id="foreign-imports-and-multi-threading">12.3.4.1. Foreign imports and multi-threading</h4> <p>When you call a <code>foreign import</code>ed function that is annotated as <code>safe</code> (the default), and the program was linked using <a class="reference internal" href="phases#ghc-flag--threaded"><code>-threaded</code></a>, then the call will run concurrently with other running Haskell threads. If the program was linked without <a class="reference internal" href="phases#ghc-flag--threaded"><code>-threaded</code></a>, then the other Haskell threads will be blocked until the call returns.</p> <p>This means that if you need to make a foreign call to a function that takes a long time or blocks indefinitely, then you should mark it <code>safe</code> and use <a class="reference internal" href="phases#ghc-flag--threaded"><code>-threaded</code></a>. Some library functions make such calls internally; their documentation should indicate when this is the case.</p> <p>If you are making foreign calls from multiple Haskell threads and using <a class="reference internal" href="phases#ghc-flag--threaded"><code>-threaded</code></a>, make sure that the foreign code you are calling is thread-safe. In particularly, some GUI libraries are not thread-safe and require that the caller only invokes GUI methods from a single thread. If this is the case, you may need to restrict your GUI operations to a single Haskell thread, and possibly also use a bound thread (see <a class="reference internal" href="#haskell-threads-and-os-threads"><span class="std std-ref">The relationship between Haskell threads and OS threads</span></a>).</p> <p>Note that foreign calls made by different Haskell threads may execute in <em>parallel</em>, even when the <code>+RTS -N</code> flag is not being used (<a class="reference internal" href="using-concurrent#parallel-options"><span class="std std-ref">RTS options for SMP parallelism</span></a>). The <a class="reference internal" href="#"><code>-N ⟨x⟩</code></a> flag controls parallel execution of Haskell threads, but there may be an arbitrary number of foreign calls in progress at any one time, regardless of the <code>+RTS -N</code> value.</p> <p>If a call is annotated as <code>interruptible</code> and the program was multithreaded, the call may be interrupted in the event that the Haskell thread receives an exception. The mechanism by which the interrupt occurs is platform dependent, but is intended to cause blocking system calls to return immediately with an interrupted error code. The underlying operating system thread is not to be destroyed. See <a class="reference internal" href="#ffi-interruptible"><span class="std std-ref">Interruptible foreign calls</span></a> for more details.</p>   <h4 id="haskell-threads-and-os-threads">12.3.4.2. The relationship between Haskell threads and OS threads</h4> <p id="the-relationship-between-haskell-threads-and-os-threads">Normally there is no fixed relationship between Haskell threads and OS threads. This means that when you make a foreign call, that call may take place in an unspecified OS thread. Furthermore, there is no guarantee that multiple calls made by one Haskell thread will be made by the same OS thread.</p> <p>This usually isn’t a problem, and it allows the GHC runtime system to make efficient use of OS thread resources. However, there are cases where it is useful to have more control over which OS thread is used, for example when calling foreign code that makes use of thread-local state. For cases like this, we provide <em>bound threads</em>, which are Haskell threads tied to a particular OS thread. For information on bound threads, see the documentation for the <a class="reference external" href="../libraries/base-4.13.0.0/control-concurrent">Control.Concurrent</a> module.</p>   <h4 id="foreign-exports-and-multi-threading">12.3.4.3. Foreign exports and multi-threading</h4> <p>When the program is linked with <a class="reference internal" href="phases#ghc-flag--threaded"><code>-threaded</code></a>, then you may invoke <code>foreign export</code>ed functions from multiple OS threads concurrently. The runtime system must be initialised as usual by calling <code>hs_init()</code>, and this call must complete before invoking any <code>foreign export</code>ed functions.</p>   <h4 id="hs-exit">12.3.4.4. On the use of <code>hs_exit()</code>
</h4> <p id="on-the-use-of-hs-exit"><code>hs_exit()</code> normally causes the termination of any running Haskell threads in the system, and when <code>hs_exit()</code> returns, there will be no more Haskell threads running. The runtime will then shut down the system in an orderly way, generating profiling output and statistics if necessary, and freeing all the memory it owns.</p> <p>It isn’t always possible to terminate a Haskell thread forcibly: for example, the thread might be currently executing a foreign call, and we have no way to force the foreign call to complete. What’s more, the runtime must assume that in the worst case the Haskell code and runtime are about to be removed from memory (e.g. if this is a <a class="reference internal" href="win32-dlls#win32-dlls"><span class="std std-ref">Windows DLL</span></a>, <code>hs_exit()</code> is normally called before unloading the DLL). So <code>hs_exit()</code> <em>must</em> wait until all outstanding foreign calls return before it can return itself.</p> <p>The upshot of this is that if you have Haskell threads that are blocked in foreign calls, then <code>hs_exit()</code> may hang (or possibly busy-wait) until the calls return. Therefore it’s a good idea to make sure you don’t have any such threads in the system when calling <code>hs_exit()</code>. This includes any threads doing I/O, because I/O may (or may not, depending on the type of I/O and the platform) be implemented using blocking foreign calls.</p> <p>The GHC runtime treats program exit as a special case, to avoid the need to wait for blocked threads when a standalone executable exits. Since the program and all its threads are about to terminate at the same time that the code is removed from memory, it isn’t necessary to ensure that the threads have exited first. If you want this fast and loose version of <code>hs_exit()</code>, you can call:</p> <pre data-language="c">void hs_exit_nowait(void);
</pre> <p>instead. This is particularly useful if you have foreign libraries that need to call <code>hs_exit()</code> at program exit (perhaps via a C++ destructor): in this case you should use <code>hs_exit_nowait()</code>, because the thread that called <code>exit()</code> and is running C++ destructors is in a foreign call from Haskell that will never return, so <code>hs_exit()</code> would deadlock.</p>   <h4 id="hs-try-putmvar">12.3.4.5. Waking up Haskell threads from C</h4> <p id="waking-up-haskell-threads-from-c">Sometimes we want to be able to wake up a Haskell thread from some C code. For example, when using a callback-based C API, we register a C callback and then we need to wait for the callback to run.</p> <p>One way to do this is to create a <code>foreign export</code> that will do whatever needs to be done to wake up the Haskell thread - perhaps <code>putMVar</code> - and then call this from our C callback. There are a couple of problems with this:</p> <ol class="arabic simple"> <li>Calling a foreign export has a lot of overhead: it creates a complete new Haskell thread, for example.</li> <li>The call may block for a long time if a GC is in progress. We can’t use this method if the C API we’re calling doesn’t allow blocking in the callback.</li> </ol> <p>For these reasons GHC provides an external API to <code>tryPutMVar</code>, <code>hs_try_putmvar</code>, which you can use to cheaply and asynchronously wake up a Haskell thread from C/C++.</p> <pre data-language="c">void hs_try_putmvar (int capability, HsStablePtr sp);
</pre> <p>The C call <code>hs_try_putmvar(cap, mvar)</code> is equivalent to the Haskell call <code>tryPutMVar mvar ()</code>, except that it is</p> <ul class="simple"> <li>non-blocking: takes a bounded, short, amount of time</li> <li>asynchronous: the actual putMVar may be performed after the call returns (for example, if the RTS is currently garbage collecting). That’s why <code>hs_try_putmvar()</code> doesn’t return a result to say whether the put succeeded. It is your responsibility to ensure that the <code>MVar</code> is empty; if it is full, <code>hs_try_putmvar()</code> will have no effect.</li> </ul> <p><strong>Example</strong>. Suppose we have a C/C++ function to call that will return and then invoke a callback at some point in the future, passing us some data. We want to wait in Haskell for the callback to be called, and retrieve the data. We can do it like this:</p> <pre data-language="haskell">import GHC.Conc (newStablePtrPrimMVar, PrimMVar)

makeExternalCall = mask_ $ do
  mvar &lt;- newEmptyMVar
  sp &lt;- newStablePtrPrimMVar mvar
  fp &lt;- mallocForeignPtr
  withForeignPtr fp $ \presult -&gt; do
    cap &lt;- threadCapability =&lt;&lt; myThreadId
    scheduleCallback sp cap presult
    takeMVar mvar `onException`
      forkIO (do takeMVar mvar; touchForeignPtr fp)
    peek presult

foreign import ccall "scheduleCallback"
    scheduleCallback :: StablePtr PrimMVar
                     -&gt; Int
                     -&gt; Ptr Result
                     -&gt; IO ()
</pre> <p>And inside <code>scheduleCallback</code>, we create a callback that will in due course store the result data in the <code>Ptr Result</code>, and then call <code>hs_try_putmvar()</code>.</p> <p>There are a few things to note here.</p> <ul> <li>There’s a special function to create the <code>StablePtr</code>: <code>newStablePtrPrimMVar</code>, because the RTS needs a <code>StablePtr</code> to the primitive <code>MVar#</code> object, and we can’t create that directly. Do <em>not</em> just use <code>newStablePtr</code> on the <code>MVar</code>: your program will crash. </li> <li>The <code>StablePtr</code> is freed by <code>hs_try_putmvar()</code>. This is because it would otherwise be difficult to arrange to free the <code>StablePtr</code> reliably: we can’t free it in Haskell, because if the <code>takeMVar</code> is interrupted by an asynchronous exception, then the callback will fire at a later time. We can’t free it in C, because we don’t know when to free it (not when <code>hs_try_putmvar()</code> returns, because that is an async call that uses the <code>StablePtr</code> at some time in the future). </li> <li>The <code>mask_</code> is to avoid asynchronous exceptions before the <code>scheduleCallback</code> call, which would leak the <code>StablePtr</code>. </li> <li>
<p class="first">We find out the current capability number and pass it to C. This is passed back to <code>hs_try_putmvar</code>, and helps the RTS to know which capability it should try to perform the <code>tryPutMVar</code> on. If you don’t care, you can pass <code>-1</code> for the capability to <code>hs_try_putmvar</code>, and it will pick an arbitrary one.</p> <p>Picking the right capability will help avoid unnecessary context switches. Ideally you should pass the capability that the thread that will be woken up last ran on, which you can find by calling <code>threadCapability</code> in Haskell.</p> </li> <li>If you want to also pass some data back from the C callback to Haskell, this is best done by first allocating some memory in Haskell to receive the data, and passing the address to C, as we did in the above example. </li> <li>
<code>takeMVar</code> can be interrupted by an asynchronous exception. If this happens, the callback in C will still run at some point in the future, will still write the result, and will still call <code>hs_try_putmvar()</code>. Therefore we have to arrange that the memory for the result stays alive until the callback has run, so if an exception is thrown during <code>takeMVar</code> we fork another thread to wait for the callback and hold the memory alive using <code>touchForeignPtr</code>. </li> </ul> <p>For a fully working example, see <code>testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs</code> in the GHC source tree.</p>    <h3 id="ffi-floating-point">12.3.5. Floating point and the FFI</h3> <p id="floating-point-and-the-ffi">The standard C99 <code>fenv.h</code> header provides operations for inspecting and modifying the state of the floating point unit. In particular, the rounding mode used by floating point operations can be changed, and the exception flags can be tested.</p> <p>In Haskell, floating-point operations have pure types, and the evaluation order is unspecified. So strictly speaking, since the <code>fenv.h</code> functions let you change the results of, or observe the effects of floating point operations, use of <code>fenv.h</code> renders the behaviour of floating-point operations anywhere in the program undefined.</p> <p>Having said that, we <em>can</em> document exactly what GHC does with respect to the floating point state, so that if you really need to use <code>fenv.h</code> then you can do so with full knowledge of the pitfalls:</p> <ul class="simple"> <li>GHC completely ignores the floating-point environment, the runtime neither modifies nor reads it.</li> <li>The floating-point environment is not saved over a normal thread context-switch. So if you modify the floating-point state in one thread, those changes may be visible in other threads. Furthermore, testing the exception state is not reliable, because a context switch may change it. If you need to modify or test the floating point state and use threads, then you must use bound threads (<code>Control.Concurrent.forkOS</code>), because a bound thread has its own OS thread, and OS threads do save and restore the floating-point state.</li> <li>It is safe to modify the floating-point unit state temporarily during a foreign call, because foreign calls are never pre-empted by GHC.</li> </ul>    </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2002–2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/ffi-chap.html" class="_attribution-link">https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/ffi-chap.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
