
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>8.11. Options Related to a Particular Phase - Haskell 8 - W3cubDocs</title>
  
  <meta name="description" content="You may specify that a different program be used for one of the phases of the compilation system, in place of whatever the ghc has wired into it. &hellip;">
  <meta name="keywords" content="options, related, particular, phase, haskell, haskell~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~8/users_guide/phases.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/haskell~8.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~8/" class="_nav-link" title="" style="margin-left:0;">Haskell 8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 id="options-phases">8.11. Options related to a particular phase</h1>
<div class="_sphinx">    <h2 id="replacing-phases">8.11.1. Replacing the program for one or more phases</h2> <p id="options-related-to-a-particular-phase">You may specify that a different program be used for one of the phases of the compilation system, in place of whatever the <code>ghc</code> has wired into it. For example, you might want to try a different assembler. The following options allow you to change the external program used for a given compilation phase:</p> <dl class="ghc-flag"> <dt id="ghc-flag--pgmL ⟨cmd⟩">
<code>-pgmL ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the literate pre-processor.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmP ⟨cmd⟩">
<code>-pgmP ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the C pre-processor (with <code>-cpp</code> only).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmc ⟨cmd⟩">
<code>-pgmc ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the C compiler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmlo ⟨cmd⟩">
<code>-pgmlo ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the LLVM optimiser.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmlc ⟨cmd⟩">
<code>-pgmlc ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the LLVM compiler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgms ⟨cmd⟩">
<code>-pgms ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the splitter.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgma ⟨cmd⟩">
<code>-pgma ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the assembler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgml ⟨cmd⟩">
<code>-pgml ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the linker.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmdll ⟨cmd⟩">
<code>-pgmdll ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the DLL generator.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmF ⟨cmd⟩">
<code>-pgmF ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the pre-processor (with <code>-F</code> only).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmwindres ⟨cmd⟩">
<code>-pgmwindres ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the program to use for embedding manifests on Windows. Normally this is the program <code>windres</code>, which is supplied with a GHC installation. See <code>-fno-embed-manifest</code> in <a class="reference internal" href="#options-linker"><span class="std std-ref">Options affecting linking</span></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmlibtool ⟨cmd⟩">
<code>-pgmlibtool ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the libtool command (when using <code>-staticlib</code> only).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pgmi ⟨cmd⟩">
<code>-pgmi ⟨cmd⟩</code> </dt> <dd>
<p>Use ⟨cmd⟩ as the external interpreter command (see: <a class="reference internal" href="ghci#external-interpreter"><span class="std std-ref">Running the interpreter in a separate process</span></a>). Default: <code>ghc-iserv-prof</code> if <code>-prof</code> is enabled, <code>ghc-iserv-dyn</code> if <code>-dynamic</code> is enabled, or <code>ghc-iserv</code> otherwise.</p> </dd>
</dl>   <h2 id="forcing-options-through">8.11.2. Forcing options to a particular phase</h2> <p id="forcing-options-to-a-particular-phase">Options can be forced through to a particular compilation phase, using the following flags:</p> <dl class="ghc-flag"> <dt id="ghc-flag--optL ⟨option⟩">
<code>-optL ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the literate pre-processor</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optP ⟨option⟩">
<code>-optP ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to CPP (makes sense only if <code>-cpp</code> is also on).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optF ⟨option⟩">
<code>-optF ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the custom pre-processor (see <a class="reference internal" href="#pre-processor"><span class="std std-ref">Options affecting a Haskell pre-processor</span></a>).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optc ⟨option⟩">
<code>-optc ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the C compiler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optlo ⟨option⟩">
<code>-optlo ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the LLVM optimiser.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optlc ⟨option⟩">
<code>-optlc ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the LLVM compiler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--opta ⟨option⟩">
<code>-opta ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the assembler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optl ⟨option⟩">
<code>-optl ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the linker.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optdll ⟨option⟩">
<code>-optdll ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the DLL generator.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--optwindres ⟨option⟩">
<code>-optwindres ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to <code>windres</code> when embedding manifests on Windows. See <code>-fno-embed-manifest</code> in <a class="reference internal" href="#options-linker"><span class="std std-ref">Options affecting linking</span></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--opti ⟨option⟩">
<code>-opti ⟨option⟩</code> </dt> <dd>
<p>Pass ⟨option⟩ to the interpreter sub-process (see <a class="reference internal" href="ghci#external-interpreter"><span class="std std-ref">Running the interpreter in a separate process</span></a>). A common use for this is to pass RTS options e.g., <code>-opti+RTS -opti-A64m</code>, or to enable verbosity with <code>-opti-v</code> to see what messages are being exchanged by GHC and the interpreter.</p> </dd>
</dl> <p>So, for example, to force an <code>-Ewurble</code> option to the assembler, you would tell the driver <code>-opta-Ewurble</code> (the dash before the E is required).</p> <p>GHC is itself a Haskell program, so if you need to pass options directly to GHC’s runtime system you can enclose them in <code>+RTS ... -RTS</code> (see <a class="reference internal" href="runtime_control#runtime-control"><span class="std std-ref">Running a compiled program</span></a>).</p>   <h2 id="c-pre-processor">8.11.3. Options affecting the C pre-processor</h2> <dl class="extension" id="options-affecting-the-c-pre-processor"> <dt id="extension-CPP">
<code>CPP</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> </dd>
</dl> <dl class="ghc-flag" id="index-2"> <dt id="ghc-flag--cpp">
<code>-cpp</code> </dt> <dd>
<p>The C pre-processor <strong class="command">cpp</strong> is run over your Haskell code only if the <code>-cpp</code> option -cpp option is given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn’t need it.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--D⟨symbol⟩[=⟨value⟩]">
<code>-D⟨symbol⟩[=⟨value⟩]</code> </dt> <dd>
<p>Define macro ⟨symbol⟩ in the usual way. When no value is given, the value is taken to be <code>1</code>. For instance, <code>-DUSE_MYLIB</code> is equivalent to <code>-DUSE_MYLIB=1</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><a class="reference internal" href="#ghc-flag--D%E2%9F%A8symbol%E2%9F%A9%5B=%E2%9F%A8value%E2%9F%A9%5D"><code>-D⟨symbol⟩[=⟨value⟩]</code></a> does <em>not</em> affect <code>-D</code> macros passed to the C compiler when compiling an unregisterised build! In this case use the <code>-optc-Dfoo</code> hack… (see <a class="reference internal" href="#forcing-options-through"><span class="std std-ref">Forcing options to a particular phase</span></a>).</p> </div> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--U⟨symbol⟩">
<code>-U⟨symbol⟩</code> </dt> <dd>
<p>Undefine macro ⟨symbol⟩ in the usual way.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--I⟨dir⟩">
<code>-I⟨dir⟩</code> </dt> <dd>
<p>Specify a directory in which to look for <code>#include</code> files, in the usual C way.</p> </dd>
</dl> <p>The GHC driver pre-defines several macros when processing Haskell source code (<code>.hs</code> or <code>.lhs</code> files).</p>  <h3 id="id1">8.11.3.1. Standard CPP macros</h3> <p id="standard-cpp-macros">The symbols defined by GHC are listed below. To check which symbols are defined by your local GHC installation, the following trick is useful:</p> <pre data-language="sh">$ ghc -E -optP-dM -cpp foo.hs
$ cat foo.hspp
</pre> <p>(you need a file <code>foo.hs</code>, but it isn’t actually used).</p> <dl class="docutils"> <dt>
<code>__GLASGOW_HASKELL__</code> </dt> <dd>
<p class="first" id="index-3">For version <code>x.y.z</code> of GHC, the value of <code>__GLASGOW_HASKELL__</code> is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.2 of GHC, <code>__GLASGOW_HASKELL__==602</code>). More information in <a class="reference internal" href="intro#version-numbering"><span class="std std-ref">GHC version numbering policy</span></a>.</p> <p>With any luck, <code>__GLASGOW_HASKELL__</code> will be undefined in all other implementations that support C-style pre-processing.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The comparable symbols for other systems are: <code>__HUGS__</code> for Hugs, <code>__NHC__</code> for nhc98, and <code>__HBC__</code> for hbc).</p> </div> <p class="last">NB. This macro is set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. <code>.hs</code>, <code>.lhs</code>, <code>.c</code> and <code>.hc</code> files).</p> </dd> <dt>
<code>__GLASGOW_HASKELL_PATCHLEVEL1__; __GLASGOW_HASKELL_PATCHLEVEL2__</code> </dt> <dd>
<p class="first" id="index-5">These macros are available starting with GHC 7.10.1.</p> <p>For three-part GHC version numbers <code>x.y.z</code>, the value of <code>__GLASGOW_HASKELL_PATCHLEVEL1__</code> is the integer ⟨z⟩.</p> <p>For four-part GHC version numbers <code>x.y.z.z'</code>, the value of <code>__GLASGOW_HASKELL_PATCHLEVEL1__</code> is the integer ⟨z⟩ while the value of <code>__GLASGOW_HASKELL_PATCHLEVEL2__</code> is set to the integer ⟨z’⟩.</p> <p>These macros are provided for allowing finer granularity than is provided by <code>__GLASGOW_HASKELL__</code>. Usually, this should not be necessary as it’s expected for most APIs to remain stable between patchlevel releases, but occasionally internal API changes are necessary to fix bugs. Also conditional compilation on the patchlevel can be useful for working around bugs in older releases.</p> <div class="last admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">These macros are set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. <code>.hs</code>, <code>.lhs</code>, <code>.c</code> and <code>.hc</code> files).</p> </div> </dd> <dt>
<code>MIN_VERSION_GLASGOW_HASKELL(x,y,z,z')</code> </dt> <dd>
<p class="first" id="index-6">This macro is available starting with GHC 7.10.1.</p> <p>This macro is provided for convenience to write CPP conditionals testing whether the GHC version used is version <code>x.y.z.z'</code> or later.</p> <p>If compatibility with Haskell compilers (including GHC prior to version 7.10.1) which do not define <code>MIN_VERSION_GLASGOW_HASKELL</code> is required, the presence of the <code>MIN_VERSION_GLASGOW_HASKELL</code> macro needs to be ensured before it is called, e.g.:</p> <pre data-language="c">#ifdef MIN_VERSION_GLASGOW_HASKELL
#if MIN_VERSION_GLASGOW_HASKELL(7,10,2,0)
/* code that applies only to GHC 7.10.2 or later */
#endif
#endif
</pre> <div class="last admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">This macro is set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. <code>.hs</code>, <code>.lhs</code>, <code>.c</code> and <code>.hc</code> files).</p> </div> </dd> <dt>
<code>__GLASGOW_HASKELL_TH__</code> </dt> <dd>
<p class="first last" id="index-7">This is set to <code>1</code> when the compiler supports Template Haskell, and to <code>0</code> when not. The latter is the case for a stage-1 compiler during bootstrapping, or on architectures where the interpreter is not available.</p> </dd> <dt>
<code>__GLASGOW_HASKELL_LLVM__</code> </dt> <dd>
<p class="first last" id="index-8">Only defined when <code>-fllvm</code> is specified. When GHC is using version <code>x.y.z</code> of LLVM, the value of <code>__GLASGOW_HASKELL_LLVM__</code> is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example when using version 3.7 of LLVM, <code>__GLASGOW_HASKELL_LLVM__==307</code>).</p> </dd> <dt>
<code>__PARALLEL_HASKELL__</code> </dt> <dd>
<p class="first last" id="index-9">Only defined when <code>-parallel</code> is in use! This symbol is defined when pre-processing Haskell (input) and pre-processing C (GHC output).</p> </dd> <dt>
<code>os_HOST_OS=1</code> </dt> <dd>This define allows conditional compilation based on the Operating System, where⟨os⟩ is the name of the current Operating System (eg. <code>linux</code>, <code>mingw32</code> for Windows, <code>solaris</code>, etc.).</dd> <dt>
<code>arch_HOST_ARCH=1</code> </dt> <dd>This define allows conditional compilation based on the host architecture, where⟨arch⟩ is the name of the current architecture (eg. <code>i386</code>, <code>x86_64</code>, <code>powerpc</code>, <code>sparc</code>, etc.).</dd> <dt>
<code>VERSION_pkgname</code> </dt> <dd>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro expands to a string recording the version of <code>pkgname</code> that is exposed for module import. It is identical in behavior to the <code>VERSION_pkgname</code> macros that Cabal defines.</dd> <dt>
<code>MIN_VERSION_pkgname(x,y,z)</code> </dt> <dd>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro is provided for convenience to write CPP conditionals testing if a package version is <code>x.y.z</code> or later. It is identical in behavior to the <code>MIN_VERSION_pkgname</code> macros that Cabal defines.</dd> </dl>   <h3 id="cpp-string-gaps">8.11.3.2. CPP and string gaps</h3> <p id="cpp-and-string-gaps">A small word of warning: <a class="reference internal" href="#ghc-flag--cpp"><code>-cpp</code></a> is not friendly to “string gaps”. In other words, strings such as the following:</p> <pre data-language="haskell">strmod = "\
\ p \
\ "
</pre> <p>don’t work with <a class="reference internal" href="#ghc-flag--cpp"><code>-cpp</code></a>; <strong class="command">/usr/bin/cpp</strong> elides the backslash-newline pairs.</p> <p>However, it appears that if you add a space at the end of the line, then <code>cpp</code> (at least GNU <code>cpp</code> and possibly other <code>cpp</code>s) leaves the backslash-space pairs alone and the string gap works as expected.</p>    <h2 id="pre-processor">8.11.4. Options affecting a Haskell pre-processor</h2> <dl class="ghc-flag" id="options-affecting-a-haskell-pre-processor"> <dt id="ghc-flag--F">
<code>-F</code> </dt> <dd>
<p>A custom pre-processor is run over your Haskell source file only if the <code>-F</code> option is given.</p> <p>Running a custom pre-processor at compile-time is in some settings appropriate and useful. The <code>-F</code> option lets you run a pre-processor as part of the overall GHC compilation pipeline, which has the advantage over running a Haskell pre-processor separately in that it works in interpreted mode and you can continue to take reap the benefits of GHC’s recompilation checker.</p> <p>The pre-processor is run just before the Haskell compiler proper processes the Haskell input, but after the literate markup has been stripped away and (possibly) the C pre-processor has washed the Haskell input.</p> <p>Use <a class="reference internal" href="#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9"><code>-pgmF ⟨cmd⟩</code></a> to select the program to use as the preprocessor. When invoked, the ⟨cmd⟩ pre-processor is given at least three arguments on its command-line: the first argument is the name of the original source file, the second is the name of the file holding the input, and the third is the name of the file where ⟨cmd⟩ should write its output to.</p> <p>Additional arguments to the pre-processor can be passed in using the <a class="reference internal" href="#ghc-flag--optF%20%E2%9F%A8option%E2%9F%A9"><code>-optF ⟨option⟩</code></a> option. These are fed to ⟨cmd⟩ on the command line after the three standard input and output arguments.</p> <p>An example of a pre-processor is to convert your source files to the input encoding that GHC expects, i.e. create a script <code>convert.sh</code> containing the lines:</p> <pre data-language="sh">#!/bin/sh
( echo "{-# LINE 1 \"$2\" #-}" ; iconv -f l1 -t utf-8 $2 ) &gt; $3
</pre> <p>and pass <code>-F -pgmF convert.sh</code> to GHC. The <code>-f l1</code> option tells iconv to convert your Latin-1 file, supplied in argument <code>$2</code>, while the “-t utf-8” options tell iconv to return a UTF-8 encoded file. The result is redirected into argument <code>$3</code>. The <code>echo "{-# LINE 1 \"$2\" #-}"</code> just makes sure that your error positions are reported as in the original source file.</p> </dd>
</dl>   <h2 id="options-codegen">8.11.5. Options affecting code generation</h2> <dl class="ghc-flag" id="options-affecting-code-generation"> <dt id="ghc-flag--fasm">
<code>-fasm</code> </dt> <dd>
<p>Use GHC’s <a class="reference internal" href="codegens#native-code-gen"><span class="std std-ref">native code generator</span></a> rather than compiling via LLVM. <code>-fasm</code> is the default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fllvm">
<code>-fllvm</code> </dt> <dd>
<p>Compile via <a class="reference internal" href="codegens#llvm-code-gen"><span class="std std-ref">LLVM</span></a> instead of using the native code generator. This will generally take slightly longer than the native code generator to compile. Produced code is generally the same speed or faster than the other two code generators. Compiling via LLVM requires LLVM’s <strong class="command">opt</strong> and <strong class="command">llc</strong> executables to be in <code id="index-12">PATH</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Note that this GHC release expects an LLVM version in the 7 release series.</p> </div> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fno-code">
<code>-fno-code</code> </dt> <dd>
<p>Omit code generation (and all later phases) altogether. This is useful if you’re only interested in type checking code.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fwrite-interface">
<code>-fwrite-interface</code> </dt> <dd>
<p>Always write interface files. GHC will normally write interface files automatically, but this flag is useful with <a class="reference internal" href="#ghc-flag--fno-code"><code>-fno-code</code></a>, which normally suppresses generation of interface files. This is useful if you want to type check over multiple runs of GHC without compiling dependencies.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fobject-code">
<code>-fobject-code</code> </dt> <dd>
<p>Generate object code. This is the default outside of GHCi, and can be used with GHCi to cause object code to be generated in preference to bytecode.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fbyte-code">
<code>-fbyte-code</code> </dt> <dd>
<p>Generate byte-code instead of object-code. This is the default in GHCi. Byte-code can currently only be used in the interactive interpreter, not saved to disk. This option is only useful for reversing the effect of <a class="reference internal" href="#ghc-flag--fobject-code"><code>-fobject-code</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fPIC">
<code>-fPIC</code> </dt> <dd>
<p>Generate position-independent code (code that can be put into shared libraries). This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fexternal-dynamic-refs">
<code>-fexternal-dynamic-refs</code> </dt> <dd>
<p>When generating code, assume that entities imported from a different module might be dynamically linked. This flag is enabled automatically by <a class="reference internal" href="#ghc-flag--dynamic"><code>-dynamic</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fPIE">
<code>-fPIE</code> </dt> <dd>
<p>Generate code in such a way to be linkable into a position-independent executable This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform. To link the final executable use <a class="reference internal" href="#ghc-flag--pie"><code>-pie</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt>
<code>-dynamic</code> </dt> <dd>
<p>Build code for dynamic linking. This can reduce code size tremendously, but may slow-down cross-module calls of non-inlined functions. There can be some complications combining <a class="reference internal" href="#ghc-flag--shared"><code>-shared</code></a> with this flag relating to linking in the RTS under Linux. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10352">Issue #10352</a>.</p> <p>Note that using this option when linking causes GHC to link against shared libraries.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dynamic-too">
<code>-dynamic-too</code> </dt> <dd>
<p>Generates both dynamic and static object files in a single run of GHC. This option is functionally equivalent to running GHC twice, the second time adding <code>-dynamic -osuf dyn_o -hisuf dyn_hi</code>.</p> <p>Although it is equivalent to running GHC twice, using <code>-dynamic-too</code> is more efficient, because the earlier phases of the compiler up to code generation are performed just once.</p> <p>When using <code>-dynamic-too</code>, the options <code>-dyno</code>, <code>-dynosuf</code>, and <code>-dynhisuf</code> are the counterparts of <code>-o</code>, <code>-osuf</code>, and <code>-hisuf</code> respectively, but applying to the dynamic compilation.</p> </dd>
</dl>   <h2 id="options-linker">8.11.6. Options affecting linking</h2> <p id="options-affecting-linking">GHC has to link your code with various libraries, possibly including: user-supplied, GHC-supplied, and system-supplied (<code>-lm</code> math library, for example).</p> <dl class="ghc-flag"> <dt id="ghc-flag--l ⟨lib⟩">
<code>-l ⟨lib⟩</code> </dt> <dd>
<p>Link in the ⟨lib⟩ library. On Unix systems, this will be in a file called <code>lib<em>lib</em>.a</code> or <code>lib<em>lib</em>.so</code> which resides somewhere on the library directories path.</p> <p>Because of the sad state of most UNIX linkers, the order of such options does matter. If library ⟨foo⟩ requires library ⟨bar⟩, then in general <code>-l ⟨foo⟩</code> should come <em>before</em> <code>-l ⟨bar⟩</code> on the command line.</p> <p>There’s one other gotcha to bear in mind when using external libraries: if the library contains a <code>main()</code> function, then this will be a link conflict with GHC’s own <code>main()</code> function (eg. <code>libf2c</code> and <code>libl</code> have their own <code>main()</code>s).</p> <p>You can use an external main function if you initialize the RTS manually and pass <code>-no-hs-main</code>. See also <a class="reference internal" href="ffi-chap#using-own-main"><span class="std std-ref">Using your own main()</span></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--c">
<code>-c</code> </dt> <dd>
<p>Omits the link step. This option can be used with <a class="reference internal" href="using#ghc-flag---make"><code>--make</code></a> to avoid the automatic linking that takes place if the program contains a <code>Main</code> module.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--package ⟨name⟩">
<code>-package ⟨name⟩</code> </dt> <dd>
<p>If you are using a Haskell “package” (see <a class="reference internal" href="packages#packages"><span class="std std-ref">Packages</span></a>), don’t forget to add the relevant <code>-package</code> option when linking the program too: it will cause the appropriate libraries to be linked in with the program. Forgetting the <code>-package</code> option will likely result in several pages of link errors.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--framework ⟨name⟩">
<code>-framework ⟨name⟩</code> </dt> <dd>
<p>On Darwin/OS X/iOS only, link in the framework ⟨name⟩. This option corresponds to the <code>-framework</code> option for Apple’s Linker. Please note that frameworks and packages are two different things - frameworks don’t contain any Haskell code. Rather, they are Apple’s way of packaging shared libraries. To link to Apple’s “Carbon” API, for example, you’d use <code>-framework Carbon</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--staticlib">
<code>-staticlib</code> </dt> <dd>
<p>Link all passed files into a static library suitable for linking. To control the name, use the <a class="reference internal" href="#"><code>-o ⟨file⟩</code></a> option as usual. The default name is <code>liba.a</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--L ⟨dir⟩">
<code>-L ⟨dir⟩</code> </dt> <dd>
<p>Where to find user-supplied libraries… Prepend the directory ⟨dir⟩ to the library directories path.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--framework-path ⟨dir⟩">
<code>-framework-path ⟨dir⟩</code> </dt> <dd>
<p>On Darwin/OS X/iOS only, prepend the directory ⟨dir⟩ to the framework directories path. This option corresponds to the <code>-F</code> option for Apple’s Linker (<code>-F</code> already means something else for GHC).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--split-objs">
<code>-split-objs</code> </dt> <dd>
<p>Tell the linker to split the single object file that would normally be generated into multiple object files, one per top-level Haskell function or type in the module. This only makes sense for libraries, where it means that executables linked against the library are smaller as they only link against the object files that they need. However, assembling all the sections separately is expensive, so this is slower than compiling normally. Additionally, the size of the library itself (the <code>.a</code> file) can be a factor of 2 to 2.5 larger.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--split-sections">
<code>-split-sections</code> </dt> <dd>
<p>Place each generated function or data item into its own section in the output file if the target supports arbitrary sections. The name of the function or the name of the data item determines the section’s name in the output file.</p> <p>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables. The effect is similar to <a class="reference internal" href="#ghc-flag--split-objs"><code>-split-objs</code></a>, but somewhat more efficient - the generated library files are about 30% smaller than with <a class="reference internal" href="#ghc-flag--split-objs"><code>-split-objs</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--static">
<code>-static</code> </dt> <dd>
<p>Tell the linker to avoid shared Haskell libraries, if possible. This is the default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dynamic">
<code>-dynamic</code> </dt> <dd>
<p>This flag tells GHC to link against shared Haskell libraries. This flag only affects the selection of dependent libraries, not the form of the current target (see -shared). See <a class="reference internal" href="shared_libs#using-shared-libs"><span class="std std-ref">Using shared libraries</span></a> on how to create them.</p> <p>Note that this option also has an effect on code generation (see above).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--shared">
<code>-shared</code> </dt> <dd>
<p>Instead of creating an executable, GHC produces a shared object with this linker flag. Depending on the operating system target, this might be an ELF DSO, a Windows DLL, or a Mac OS dylib. GHC hides the operating system details beneath this uniform flag.</p> <p>The flags <a class="reference internal" href="#ghc-flag--dynamic"><code>-dynamic</code></a> and <a class="reference internal" href="#ghc-flag--static"><code>-static</code></a> control whether the resulting shared object links statically or dynamically to Haskell package libraries given as <a class="reference internal" href="#"><code>-package ⟨pkg⟩</code></a> option. Non-Haskell libraries are linked as gcc would regularly link it on your system, e.g. on most ELF system the linker uses the dynamic libraries when found.</p> <p>Object files linked into shared objects must be compiled with <a class="reference internal" href="#ghc-flag--fPIC"><code>-fPIC</code></a>, see <a class="reference internal" href="#options-codegen"><span class="std std-ref">Options affecting code generation</span></a></p> <p>When creating shared objects for Haskell packages, the shared object must be named properly, so that GHC recognizes the shared object when linked against this package. See shared object name mangling.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dynload">
<code>-dynload</code> </dt> <dd>
<p>This flag selects one of a number of modes for finding shared libraries at runtime. See <a class="reference internal" href="shared_libs#finding-shared-libs"><span class="std std-ref">Finding shared libraries at runtime</span></a> for a description of each mode.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--main-is ⟨thing⟩">
<code>-main-is ⟨thing⟩</code> </dt> <dd>
<p id="index-14">The normal rule in Haskell is that your program must supply a <code>main</code> function in module <code>Main</code>. When testing, it is often convenient to change which function is the “main” one, and the <code>-main-is</code> flag allows you to do so. The ⟨thing⟩ can be one of:</p> <ul class="simple"> <li>A lower-case identifier <code>foo</code>. GHC assumes that the main function is <code>Main.foo</code>.</li> <li>A module name <code>A</code>. GHC assumes that the main function is <code>A.main</code>.</li> <li>A qualified name <code>A.foo</code>. GHC assumes that the main function is <code>A.foo</code>.</li> </ul> <p>Strictly speaking, <code>-main-is</code> is not a link-phase flag at all; it has no effect on the link step. The flag must be specified when compiling the module containing the specified main function (e.g. module <code>A</code> in the latter two items above). It has no effect for other modules, and hence can safely be given to <code>ghc --make</code>. However, if all the modules are otherwise up to date, you may need to force recompilation both of the module where the new “main” is, and of the module where the “main” function used to be; <code>ghc</code> is not clever enough to figure out that they both need recompiling. You can force recompilation by removing the object file, or by using the <a class="reference internal" href="separate_compilation#ghc-flag--fforce-recomp"><code>-fforce-recomp</code></a> flag.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--no-hs-main">
<code>-no-hs-main</code> </dt> <dd>
<p id="index-15">In the event you want to include ghc-compiled code as part of another (non-Haskell) program, the RTS will not be supplying its definition of <code>main()</code> at link-time, you will have to. To signal that to the compiler when linking, use <code>-no-hs-main</code>. See also <a class="reference internal" href="ffi-chap#using-own-main"><span class="std std-ref">Using your own main()</span></a>.</p> <p>Notice that since the command-line passed to the linker is rather involved, you probably want to use <code>ghc</code> to do the final link of your `mixed-language’ application. This is not a requirement though, just try linking once with <a class="reference internal" href="using#ghc-flag--v"><code>-v</code></a> on to see what options the driver passes through to the linker.</p> <p>The <code>-no-hs-main</code> flag can also be used to persuade the compiler to do the link step in <a class="reference internal" href="using#ghc-flag---make"><code>--make</code></a> mode when there is no Haskell <code>Main</code> module present (normally the compiler will not attempt linking when there is no <code>Main</code>).</p> <p>The flags <a class="reference internal" href="#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D"><code>-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]</code></a> and <a class="reference internal" href="#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9"><code>-with-rtsopts=⟨opts⟩</code></a> have no effect when used with <a class="reference internal" href="#ghc-flag--no-hs-main"><code>-no-hs-main</code></a>, because they are implemented by changing the definition of <code>main</code> that GHC generates. See <a class="reference internal" href="ffi-chap#using-own-main"><span class="std std-ref">Using your own main()</span></a> for how to get the effect of <a class="reference internal" href="#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D"><code>-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]</code></a> and <a class="reference internal" href="#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9"><code>-with-rtsopts=⟨opts⟩</code></a> when using your own <code>main</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--debug">
<code>-debug</code> </dt> <dd>
<p>Link the program with a debugging version of the runtime system. The debugging runtime turns on numerous assertions and sanity checks, and provides extra options for producing debugging output at runtime (run the program with <code>+RTS -?</code> to see a list).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--threaded">
<code>-threaded</code> </dt> <dd>
<p>Link the program with the “threaded” version of the runtime system. The threaded runtime system is so-called because it manages multiple OS threads, as opposed to the default runtime system which is purely single-threaded.</p> <p>Note that you do <em>not</em> need <code>-threaded</code> in order to use concurrency; the single-threaded runtime supports concurrency between Haskell threads just fine.</p> <p>The threaded runtime system provides the following benefits:</p> <ul class="simple"> <li>It enables the <a class="reference internal" href="#"><code>-N ⟨x⟩</code></a> RTS option to be used, which allows threads to run in parallel on a multiprocessor or multicore machine. See <a class="reference internal" href="using-concurrent#using-smp"><span class="std std-ref">Using SMP parallelism</span></a>.</li> <li>If a thread makes a foreign call (and the call is not marked <code>unsafe</code>), then other Haskell threads in the program will continue to run while the foreign call is in progress. Additionally, <code>foreign export</code>ed Haskell functions may be called from multiple OS threads simultaneously. See <a class="reference internal" href="ffi-chap#ffi-threads"><span class="std std-ref">Multi-threading and the FFI</span></a>.</li> </ul> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--eventlog">
<code>-eventlog</code> </dt> <dd>
<p>Link the program with the “eventlog” version of the runtime system. A program linked in this way can generate a runtime trace of events (such as thread start/stop) to a binary file <code><em>program</em>.eventlog</code>, which can then be interpreted later by various tools. See <a class="reference internal" href="runtime_control#rts-eventlog"><span class="std std-ref">Tracing</span></a> for more information.</p> <p><a class="reference internal" href="#ghc-flag--eventlog"><code>-eventlog</code></a> can be used with <a class="reference internal" href="#ghc-flag--threaded"><code>-threaded</code></a>. It is implied by <a class="reference internal" href="#ghc-flag--debug"><code>-debug</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]">
<code>-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">all</td> </tr>  </table> <p>This option affects the processing of RTS control options given either on the command line or via the <a class="reference internal" href="runtime_control#envvar-GHCRTS" id="index-16"><code>GHCRTS</code></a> environment variable. There are three possibilities:</p> <dl class="docutils"> <dt>
<code>-rtsopts=none</code> </dt> <dd>Disable all processing of RTS options. If <code>+RTS</code> appears anywhere on the command line, then the program will abort with an error message. If the <code>GHCRTS</code> environment variable is set, then the program will emit a warning message, <code>GHCRTS</code> will be ignored, and the program will run as normal.</dd> <dt>
<code>-rtsopts=ignore</code> </dt> <dd>Disables all processing of RTS options. Unlike <code>none</code> this treats all RTS flags appearing on the command line the same way as regular arguments. (Passing them on to your program as arguments). <code>GHCRTS</code> options will be processed normally.</dd> <dt>
<code>-rtsopts=ignoreAll</code> </dt> <dd>Same as <code>ignore</code> but also ignores <code>GHCRTS</code>.</dd> <dt>
<code>-rtsopts=some</code> </dt> <dd>[this is the default setting] Enable only the “safe” RTS options: (Currently only <code>-?</code> and <code>--info</code>.) Any other RTS options on the command line or in the <code>GHCRTS</code> environment variable causes the program with to abort with an error message.</dd> <dt>
<code>-rtsopts=all or just -rtsopts</code> </dt> <dd>Enable <em>all</em> RTS option processing, both on the command line and through the <code>GHCRTS</code> environment variable.</dd> </dl> <p>In GHC 6.12.3 and earlier, the default was to process all RTS options. However, since RTS options can be used to write logging data to arbitrary files under the security context of the running program, there is a potential security problem. For this reason, GHC 7.0.1 and later default to <code>-rtsopts=some</code>.</p> <p>Note that <code>-rtsopts</code> has no effect when used with <a class="reference internal" href="#ghc-flag--no-hs-main"><code>-no-hs-main</code></a>; see <a class="reference internal" href="ffi-chap#using-own-main"><span class="std std-ref">Using your own main()</span></a> for details.</p> <p><code>-rtsopts</code> does not affect RTS options passed via <code>-with-rtsopts</code>; those are used regardless of <code>-rtsopts</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--with-rtsopts=⟨opts⟩">
<code>-with-rtsopts=⟨opts⟩</code> </dt> <dd>
<p>This option allows you to set the default RTS options at link-time. For example, <code>-with-rtsopts="-H128m"</code> sets the default heap size to 128MB. This will always be the default heap size for this program, unless the user overrides it. (Depending on the setting of the <code>-rtsopts</code> option, the user might not have the ability to change RTS options at run-time, in which case <code>-with-rtsopts</code> would be the <em>only</em> way to set them.)</p> <p>Use the runtime flag <a class="reference internal" href="runtime_control#rts-flag---info"><code>--info</code></a> on the executable program to see the options set with <code>-with-rtsopts</code>.</p> <p>Note that <code>-with-rtsopts</code> has no effect when used with <code>-no-hs-main</code>; see <a class="reference internal" href="ffi-chap#using-own-main"><span class="std std-ref">Using your own main()</span></a> for details.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--no-rtsopts-suggestions">
<code>-no-rtsopts-suggestions</code> </dt> <dd>
<p>This option disables RTS suggestions about linking with <a class="reference internal" href="#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D"><code>-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]</code></a> when they are not available. These suggestions would be unhelpful if the users have installed Haskell programs through their package managers. With this option enabled, these suggestions will not appear. It is recommended for people distributing binaries to build with either <code>-rtsopts</code> or <code>-no-rtsopts-suggestions</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fno-gen-manifest">
<code>-fno-gen-manifest</code> </dt> <dd>
<p>On Windows, GHC normally generates a manifestmanifest file when linking a binary. The manifest is placed in the file <code><em>prog</em>.exe.manifest`</code> where ⟨prog.exe⟩ is the name of the executable. The manifest file currently serves just one purpose: it disables the “installer detection” in Windows Vista that attempts to elevate privileges for executables with certain names (e.g. names containing “install”, “setup” or “patch”). Without the manifest file to turn off installer detection, attempting to run an executable that Windows deems to be an installer will return a permission error code to the invoker. Depending on the invoker, the result might be a dialog box asking the user for elevated permissions, or it might simply be a permission denied error.</p> <p>Installer detection can be also turned off globally for the system using the security control panel, but GHC by default generates binaries that don’t depend on the user having disabled installer detection.</p> <p>The <code>-fno-gen-manifest</code> disables generation of the manifest file. One reason to do this would be if you had a manifest file of your own, for example.</p> <p>In the future, GHC might use the manifest file for more things, such as supplying the location of dependent DLLs.</p> <p><a class="reference internal" href="#ghc-flag--fno-gen-manifest"><code>-fno-gen-manifest</code></a> also implies <a class="reference internal" href="#ghc-flag--fno-embed-manifest"><code>-fno-embed-manifest</code></a>, see below.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fno-embed-manifest">
<code>-fno-embed-manifest</code> </dt> <dd>
<p id="index-17">The manifest file that GHC generates when linking a binary on Windows is also embedded in the executable itself, by default. This means that the binary can be distributed without having to supply the manifest file too. The embedding is done by running <strong class="command">windres</strong>; to see exactly what GHC does to embed the manifest, use the <a class="reference internal" href="using#ghc-flag--v"><code>-v</code></a> flag. A GHC installation comes with its own copy of <code>windres</code> for this reason.</p> <p>See also <a class="reference internal" href="#ghc-flag--pgmwindres%20%E2%9F%A8cmd%E2%9F%A9"><code>-pgmwindres ⟨cmd⟩</code></a> (<a class="reference internal" href="#replacing-phases"><span class="std std-ref">Replacing the program for one or more phases</span></a>) and <a class="reference internal" href="#ghc-flag--optwindres%20%E2%9F%A8option%E2%9F%A9"><code>-optwindres ⟨option⟩</code></a> (<a class="reference internal" href="#forcing-options-through"><span class="std std-ref">Forcing options to a particular phase</span></a>).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fno-shared-implib">
<code>-fno-shared-implib</code> </dt> <dd>
<p>DLLs on Windows are typically linked to by linking to a corresponding <code>.lib</code> or <code>.dll.a</code> — the so-called import library. GHC will typically generate such a file for every DLL you create by compiling in <a class="reference internal" href="#ghc-flag--shared"><code>-shared</code></a> mode. However, sometimes you don’t want to pay the disk-space cost of creating this import library, which can be substantial — it might require as much space as the code itself, as Haskell DLLs tend to export lots of symbols.</p> <p>As long as you are happy to only be able to link to the DLL using <code>GetProcAddress</code> and friends, you can supply the <a class="reference internal" href="#ghc-flag--fno-shared-implib"><code>-fno-shared-implib</code></a> flag to disable the creation of the import library entirely.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--dylib-install-name ⟨path⟩">
<code>-dylib-install-name ⟨path⟩</code> </dt> <dd>
<p>On Darwin/OS X, dynamic libraries are stamped at build time with an “install name”, which is the ultimate install path of the library file. Any libraries or executables that subsequently link against it will pick up that path as their runtime search location for it. By default, ghc sets the install name to the location where the library is built. This option allows you to override it with the specified file path. (It passes <code>-install_name</code> to Apple’s linker.) Ignored on other platforms.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--rdynamic">
<code>-rdynamic</code> </dt> <dd>
<p>This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. Currently Linux and Windows/MinGW32 only. This is equivalent to using <code>-optl -rdynamic</code> on Linux, and <code>-optl -export-all-symbols</code> on Windows.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fwhole-archive-hs-libs">
<code>-fwhole-archive-hs-libs</code> </dt> <dd>
<p>When linking a binary executable, this inserts the flag <code>-Wl,--whole-archive</code> before any <code>-l</code> flags for Haskell libraries, and <code>-Wl,--no-whole-archive</code> afterwards (on OS X, the flag is <code>-Wl,-all_load</code>, there is no equivalent for <code>-Wl,--no-whole-archive</code>). This flag also disables the use of <code>-Wl,--gc-sections</code> (<code>-Wl,-dead_strip</code> on OS X).</p> <p>This is for specialist applications that may require symbols defined in these Haskell libraries at runtime even though they aren’t referenced by any other code linked into the executable. If you’re using <code>-fwhole-archive-hs-libs</code>, you probably also want <code>-rdynamic</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--pie">
<code>-pie</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.2.2</td> </tr>  </table> <p>This instructs the linker to produce a position-independent executable. This flag is only valid while producing executables and all object code being linked must have been produced with <a class="reference internal" href="#ghc-flag--fPIE"><code>-fPIE</code></a>.</p> <p>Position independent executables are required by some platforms as they enable address-space layout randomization (ASLR), a common security measure. They can also be useful as they can be dynamically loaded and used as shared libraries by other executables.</p> <p>Position independent executables should be dynamically-linked (e.g. built with <a class="reference internal" href="#ghc-flag--dynamic"><code>-dynamic</code></a> and only loaded into other dynamically-linked executables to ensure that only one <code>libHSrts</code> is present if loaded into the address space of another Haskell process.</p> <p>Also, you may need to use the <a class="reference internal" href="#ghc-flag--rdynamic"><code>-rdynamic</code></a> flag to ensure that that symbols are not dropped from your PIE objects.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--keep-cafs">
<code>-keep-cafs</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.8.1</td> </tr>  </table> <p>Disables the RTS’s normal behaviour of garbage-collecting CAFs (Constant Applicative Forms, in other words top-level expressions). This option is useful for specialised applications that do runtime dynamic linking, where code dynamically linked in the future might require the value of a CAF that would otherwise be garbage-collected.</p> </dd>
</dl>   </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2002–2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/phases.html" class="_attribution-link">https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/phases.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
