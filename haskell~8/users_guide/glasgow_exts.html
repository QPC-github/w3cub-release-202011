
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>11.1. Language Options - Haskell 8 - W3cubDocs</title>
  
  <meta name="description" content="As with all known Haskell systems, GHC implements some extensions to the standard Haskell language. They can all be enabled or disabled by command &hellip;">
  <meta name="keywords" content="language, options, unboxed, types, and, primitive, operations, syntactic, extensions, data, type, synonyms, record, system, “deriving”, mechanism, pattern, class, instances, declarations, families, datatype, promotion, kind, polymorphism, levity, type-level, literals, equality, constraints, coercible, constraint, quantified, signatures, lexically, scoped, variables, bindings, generalisation, visible, application, implicit, parameters, arbitrary-rank, impredicative, typed, holes, partial, custom, compile-time, errors, deferring, runtime, template, haskell, arrow, notation, bang, patterns, strict, assertions, static, pointers, pragmas, rewrite, rules, special, built-in, functions, generic, classes, programming, roles, hascallstack, haskell~8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~8/users_guide/glasgow_exts.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/haskell~8.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~8/" class="_nav-link" title="" style="margin-left:0;">Haskell 8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 id="options-language">11.1. Language options</h1>
<div class="_sphinx"> <p id="index-0">As with all known Haskell systems, GHC implements some extensions to the standard Haskell language. They can all be enabled or disabled by command line flags or language pragmas. By default GHC understands the most recent Haskell version it supports, plus a handful of extensions.</p> <p>Some of the Glasgow extensions serve to give you access to the underlying facilities with which we implement Haskell. Thus, you can get at the Raw Iron, if you are willing to write some non-portable code at a more primitive level. You need not be “stuck” on performance because of the implementation costs of Haskell’s “high-level” features—you can always code “under” them. In an extreme case, you can write all your time-critical code in C, and then just glue it together with Haskell!</p> <p>Before you get too carried away working at the lowest level (e.g., sloshing <code>MutableByteArray#</code>s around your program), you may wish to check if there are libraries that provide a “Haskellised veneer” over the features you want. The separate <a class="reference external" href="../libraries/index">libraries documentation</a> describes all the libraries that come with GHC.</p>   <p id="language-options">The language extensions control what variation of the language are permitted.</p> <p>Language options can be controlled in two ways:</p> <ul class="simple"> <li>Every language option can switched on by a command-line flag “<code>-X...</code>” (e.g. <code>-XTemplateHaskell</code>), and switched off by the flag “<code>-XNo...</code>”; (e.g. <code>-XNoTemplateHaskell</code>).</li> <li>Language options recognised by Cabal can also be enabled using the <code>LANGUAGE</code> pragma, thus <code>{-# LANGUAGE TemplateHaskell #-}</code> (see <a class="reference internal" href="#language-pragma"><span class="std std-ref">LANGUAGE pragma</span></a>).</li> </ul> <p>GHC supports these language options:</p> <table class="longtable docutils">  <thead valign="bottom"> <tr>
<th class="head"><span class="first last">Extension</span></th> <th class="head"><span class="first last">Description</span></th> </tr> </thead>  <tr>
<td><a class="reference internal" href="#extension-AllowAmbiguousTypes"><code>AllowAmbiguousTypes</code></a></td> <td>Allow the user to write ambiguous types, and the type inference engine to infer them.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-ApplicativeDo"><code>ApplicativeDo</code></a></td> <td>Enable Applicative do-notation desugaring</td> </tr> <tr>
<td><a class="reference internal" href="#extension-Arrows"><code>Arrows</code></a></td> <td>Enable arrow notation extension</td> </tr> <tr>
<td><a class="reference internal" href="#extension-BangPatterns"><code>BangPatterns</code></a></td> <td>Enable bang patterns.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-BinaryLiterals"><code>BinaryLiterals</code></a></td> <td>Enable support for binary literals.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-BlockArguments"><code>BlockArguments</code></a></td> <td>Allow <code>do</code> blocks and other constructs as function arguments.</td> </tr> <tr>
<td><a class="reference internal" href="ffi-chap#extension-CApiFFI"><code>CApiFFI</code></a></td> <td>Enable the CAPI calling convention.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-ConstrainedClassMethods"><code>ConstrainedClassMethods</code></a></td> <td>Enable constrained class methods.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-ConstraintKinds"><code>ConstraintKinds</code></a></td> <td>Enable a kind of constraints.</td> </tr> <tr>
<td><a class="reference internal" href="phases#extension-CPP"><code>CPP</code></a></td> <td>Enable the C preprocessor.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a></td> <td>Enable datatype promotion.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DatatypeContexts"><code>DatatypeContexts</code></a></td> <td>Allow contexts on <code>data</code> types.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DefaultSignatures"><code>DefaultSignatures</code></a></td> <td>Enable default signatures.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a></td> <td>Enable deriving for any class.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DeriveDataTypeable"><code>DeriveDataTypeable</code></a></td> <td>Enable deriving for the Data class. Implied by (deprecated) <code>AutoDeriveTypeable</code>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a></td> <td>Enable deriving for the Foldable class. Implied by <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a></td> <td>Enable deriving for the Functor class. Implied by <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DeriveGeneric"><code>DeriveGeneric</code></a></td> <td>Enable deriving for the Generic class.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DeriveLift"><code>DeriveLift</code></a></td> <td>Enable deriving for the Lift class</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a></td> <td>Enable deriving for the Traversable class. Implies <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> and <a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DerivingStrategies"><code>DerivingStrategies</code></a></td> <td>Enables deriving strategies.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DerivingVia"><code>DerivingVia</code></a></td> <td>Enable deriving instances <code>via</code> types of the same runtime representation. Implies <a class="reference internal" href="#extension-DerivingStrategies"><code>DerivingStrategies</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a></td> <td>Enable record field disambiguation. Implied by <a class="reference internal" href="#extension-RecordWildCards"><code>RecordWildCards</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a></td> <td>Allow definition of record types with identically-named fields.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-EmptyCase"><code>EmptyCase</code></a></td> <td>Allow empty case alternatives.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-EmptyDataDecls"><code>EmptyDataDecls</code></a></td> <td>Allow definition of empty <code>data</code> types.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-ExistentialQuantification"><code>ExistentialQuantification</code></a></td> <td>Enable liberalised type synonyms.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a></td> <td>Enable explicit universal quantification. Implied by <a class="reference internal" href="#extension-ScopedTypeVariables"><code>ScopedTypeVariables</code></a>, <a class="reference internal" href="#extension-LiberalTypeSynonyms"><code>LiberalTypeSynonyms</code></a>, <a class="reference internal" href="#extension-RankNTypes"><code>RankNTypes</code></a> and <a class="reference internal" href="#extension-ExistentialQuantification"><code>ExistentialQuantification</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a></td> <td>Enable using the keyword <code>type</code> to specify the namespace of entries in imports and exports (<a class="reference internal" href="#explicit-namespaces"><span class="std std-ref">Explicit namespaces in import/export</span></a>). Implied by <a class="reference internal" href="#extension-TypeOperators"><code>TypeOperators</code></a> and <a class="reference internal" href="#extension-TypeFamilies"><code>TypeFamilies</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="ghci#extension-ExtendedDefaultRules"><code>ExtendedDefaultRules</code></a></td> <td>Use GHCi’s extended default rules in a normal module.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-FlexibleContexts"><code>FlexibleContexts</code></a></td> <td>Enable flexible contexts. Implied by <a class="reference internal" href="#extension-ImplicitParams"><code>ImplicitParams</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-FlexibleInstances"><code>FlexibleInstances</code></a></td> <td>Enable flexible instances. Implies <a class="reference internal" href="#extension-TypeSynonymInstances"><code>TypeSynonymInstances</code></a>. Implied by <a class="reference internal" href="#extension-ImplicitParams"><code>ImplicitParams</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="ffi-chap#extension-ForeignFunctionInterface"><code>ForeignFunctionInterface</code></a></td> <td>Enable foreign function interface.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-FunctionalDependencies"><code>FunctionalDependencies</code></a></td> <td>Enable functional dependencies. Implies <a class="reference internal" href="#extension-MultiParamTypeClasses"><code>MultiParamTypeClasses</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-GADTs"><code>GADTs</code></a></td> <td>Enable generalised algebraic data types. Implies <a class="reference internal" href="#extension-GADTSyntax"><code>GADTSyntax</code></a> and <a class="reference internal" href="#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-GADTSyntax"><code>GADTSyntax</code></a></td> <td>Enable generalised algebraic data type syntax.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-GeneralisedNewtypeDeriving"><code>GeneralisedNewtypeDeriving</code></a></td> <td>Enable newtype deriving.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-HexFloatLiterals"><code>HexFloatLiterals</code></a></td> <td>Enable support for <a class="reference internal" href="#hex-float-literals"><span class="std std-ref">hexadecimal floating point literals</span></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-ImplicitParams"><code>ImplicitParams</code></a></td> <td>Enable Implicit Parameters. Implies <a class="reference internal" href="#extension-FlexibleContexts"><code>FlexibleContexts</code></a> and <a class="reference internal" href="#extension-FlexibleInstances"><code>FlexibleInstances</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-NoImplicitPrelude"><code>ImplicitPrelude</code></a></td> <td>Don’t implicitly <code>import Prelude</code>. Implied by <a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-ImpredicativeTypes"><code>ImpredicativeTypes</code></a></td> <td>Enable impredicative types. Implies <a class="reference internal" href="#extension-RankNTypes"><code>RankNTypes</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-IncoherentInstances"><code>IncoherentInstances</code></a></td> <td>Enable incoherent instances. Implies <a class="reference internal" href="#extension-OverlappingInstances"><code>OverlappingInstances</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-InstanceSigs"><code>InstanceSigs</code></a></td> <td>Enable instance signatures.</td> </tr> <tr>
<td><a class="reference internal" href="ffi-chap#extension-InterruptibleFFI"><code>InterruptibleFFI</code></a></td> <td>Enable interruptible FFI.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-KindSignatures"><code>KindSignatures</code></a></td> <td>Enable kind signatures. Implied by <a class="reference internal" href="#extension-TypeFamilies"><code>TypeFamilies</code></a> and <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-LambdaCase"><code>LambdaCase</code></a></td> <td>Enable lambda-case expressions.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-LiberalTypeSynonyms"><code>LiberalTypeSynonyms</code></a></td> <td>Enable liberalised type synonyms.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a></td> <td>Allow <code>#</code> as a postfix modifier on identifiers.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-MonadComprehensions"><code>MonadComprehensions</code></a></td> <td>Enable monad comprehensions.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-MonadFailDesugaring"><code>MonadFailDesugaring</code></a></td> <td>Enable monadfail desugaring.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a></td> <td>Enable do not generalise local bindings. Implied by <a class="reference internal" href="#extension-TypeFamilies"><code>TypeFamilies</code></a> and <a class="reference internal" href="#extension-GADTs"><code>GADTs</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-NoMonomorphismRestriction"><code>MonomorphismRestriction</code></a></td> <td>Disable the monomorphism restriction.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-MultiParamTypeClasses"><code>MultiParamTypeClasses</code></a></td> <td>Enable multi parameter type classes. Implied by <a class="reference internal" href="#extension-FunctionalDependencies"><code>FunctionalDependencies</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-MultiWayIf"><code>MultiWayIf</code></a></td> <td>Enable multi-way if-expressions.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-NamedFieldPuns"><code>NamedFieldPuns</code></a></td> <td>Enable record puns.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-NamedWildCards"><code>NamedWildCards</code></a></td> <td>Enable named wildcards.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-NegativeLiterals"><code>NegativeLiterals</code></a></td> <td>Enable support for negative literals.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-NPlusKPatterns"><code>NPlusKPatterns</code></a></td> <td>Enable support for <code>n+k</code> patterns. Implied by <code>Haskell98</code>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-NullaryTypeClasses"><code>NullaryTypeClasses</code></a></td> <td>Deprecated, does nothing. nullary (no parameter) type classes are now enabled using <a class="reference internal" href="#extension-MultiParamTypeClasses"><code>MultiParamTypeClasses</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-NumDecimals"><code>NumDecimals</code></a></td> <td>Enable support for ‘fractional’ integer literals.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-NumericUnderscores"><code>NumericUnderscores</code></a></td> <td>Enable support for <a class="reference internal" href="#numeric-underscores"><span class="std std-ref">numeric underscores</span></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-OverlappingInstances"><code>OverlappingInstances</code></a></td> <td>Enable overlapping instances.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-OverloadedLabels"><code>OverloadedLabels</code></a></td> <td>Enable overloaded labels.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-OverloadedLists"><code>OverloadedLists</code></a></td> <td>Enable overloaded lists.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-OverloadedStrings"><code>OverloadedStrings</code></a></td> <td>Enable overloaded string literals.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-PackageImports"><code>PackageImports</code></a></td> <td>Enable package-qualified imports.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-ParallelListComp"><code>ParallelListComp</code></a></td> <td>Enable parallel list comprehensions.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-PartialTypeSignatures"><code>PartialTypeSignatures</code></a></td> <td>Enable partial type signatures.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-NoPatternGuards"><code>PatternGuards</code></a></td> <td>Disable pattern guards. Implied by <code>Haskell98</code>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-PatternSynonyms"><code>PatternSynonyms</code></a></td> <td>Enable pattern synonyms.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a></td> <td>Enable kind polymorphism. Implies <a class="reference internal" href="#extension-KindSignatures"><code>KindSignatures</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-PostfixOperators"><code>PostfixOperators</code></a></td> <td>Enable postfix operators.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-QuantifiedConstraints"><code>QuantifiedConstraints</code></a></td> <td>Allow <code>forall</code> quantifiers in constraints.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-QuasiQuotes"><code>QuasiQuotes</code></a></td> <td>Enable quasiquotation.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-Rank2Types"><code>Rank2Types</code></a></td> <td>Enable rank-2 types. Synonym for <a class="reference internal" href="#extension-RankNTypes"><code>RankNTypes</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-RankNTypes"><code>RankNTypes</code></a></td> <td>Enable rank-N types. Implied by <a class="reference internal" href="#extension-ImpredicativeTypes"><code>ImpredicativeTypes</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a></td> <td>Employ rebindable syntax. Implies <a class="reference internal" href="#extension-NoImplicitPrelude"><code>NoImplicitPrelude</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-RecordWildCards"><code>RecordWildCards</code></a></td> <td>Enable record wildcards. Implies <a class="reference internal" href="#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-RecursiveDo"><code>RecursiveDo</code></a></td> <td>Enable recursive do (mdo) notation.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-RoleAnnotations"><code>RoleAnnotations</code></a></td> <td>Enable role annotations.</td> </tr> <tr>
<td><a class="reference internal" href="safe_haskell#extension-Safe"><code>Safe</code></a></td> <td>Enable the <a class="reference internal" href="safe_haskell#safe-haskell"><span class="std std-ref">Safe Haskell</span></a> Safe mode.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-ScopedTypeVariables"><code>ScopedTypeVariables</code></a></td> <td>Enable lexically-scoped type variables.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-StandaloneDeriving"><code>StandaloneDeriving</code></a></td> <td>Enable standalone deriving.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-StarIsType"><code>StarIsType</code></a></td> <td>Treat <code>*</code> as <code>Data.Kind.Type</code>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-StaticPointers"><code>StaticPointers</code></a></td> <td>Enable static pointers.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-Strict"><code>Strict</code></a></td> <td>Make bindings in the current module strict by default.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-StrictData"><code>StrictData</code></a></td> <td>Enable default strict datatype fields.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-TemplateHaskell"><code>TemplateHaskell</code></a></td> <td>Enable Template Haskell.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-TemplateHaskellQuotes"><code>TemplateHaskellQuotes</code></a></td> <td>Enable quotation subset of <a class="reference internal" href="#template-haskell"><span class="std std-ref">Template Haskell</span></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-NoTraditionalRecordSyntax"><code>TraditionalRecordSyntax</code></a></td> <td>Disable support for traditional record syntax (as supported by Haskell 98) <code>C {f = x}</code>
</td> </tr> <tr>
<td><a class="reference internal" href="#extension-TransformListComp"><code>TransformListComp</code></a></td> <td>Enable generalised list comprehensions.</td> </tr> <tr>
<td><a class="reference internal" href="safe_haskell#extension-Trustworthy"><code>Trustworthy</code></a></td> <td>Enable the <a class="reference internal" href="safe_haskell#safe-haskell"><span class="std std-ref">Safe Haskell</span></a> Trustworthy mode.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-TupleSections"><code>TupleSections</code></a></td> <td>Enable tuple sections.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-TypeApplications"><code>TypeApplications</code></a></td> <td>Enable type application syntax in terms and types.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-TypeFamilies"><code>TypeFamilies</code></a></td> <td>Enable type families. Implies <a class="reference internal" href="#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a>, <a class="reference internal" href="#extension-KindSignatures"><code>KindSignatures</code></a>, and <a class="reference internal" href="#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-TypeFamilyDependencies"><code>TypeFamilyDependencies</code></a></td> <td>Enable injective type families. Implies <a class="reference internal" href="#extension-TypeFamilies"><code>TypeFamilies</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-TypeInType"><code>TypeInType</code></a></td> <td>Deprecated. Enable kind polymorphism and datatype promotion.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-TypeOperators"><code>TypeOperators</code></a></td> <td>Enable type operators. Implies <a class="reference internal" href="#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-TypeSynonymInstances"><code>TypeSynonymInstances</code></a></td> <td>Enable type synonyms in instance heads. Implied by <a class="reference internal" href="#extension-FlexibleInstances"><code>FlexibleInstances</code></a>.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-UnboxedSums"><code>UnboxedSums</code></a></td> <td>Enable unboxed sums.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-UnboxedTuples"><code>UnboxedTuples</code></a></td> <td>Enable the use of unboxed tuple syntax.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-UndecidableInstances"><code>UndecidableInstances</code></a></td> <td>Enable undecidable instances.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-UndecidableSuperClasses"><code>UndecidableSuperClasses</code></a></td> <td>Allow all superclass constraints, including those that may result in non-termination of the typechecker.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-UnicodeSyntax"><code>UnicodeSyntax</code></a></td> <td>Enable unicode syntax.</td> </tr> <tr>
<td><a class="reference internal" href="safe_haskell#extension-Unsafe"><code>Unsafe</code></a></td> <td>Enable <a class="reference internal" href="safe_haskell#safe-haskell"><span class="std std-ref">Safe Haskell</span></a> Unsafe mode.</td> </tr> <tr>
<td><a class="reference internal" href="#extension-ViewPatterns"><code>ViewPatterns</code></a></td> <td>Enable view patterns.</td> </tr>  </table> <p>Although not recommended, the deprecated <a class="reference internal" href="#ghc-flag--fglasgow-exts"><code>-fglasgow-exts</code></a> flag enables a large swath of the extensions supported by GHC at once.</p> <dl class="ghc-flag"> <dt id="ghc-flag--fglasgow-exts">
<code>-fglasgow-exts</code> </dt> <dd>
<p>The flag <code>-fglasgow-exts</code> is equivalent to enabling the following extensions:</p> <table class="hlist"><tr>
<td>
<ul class="simple"> <li><a class="reference internal" href="#extension-ConstrainedClassMethods"><code>ConstrainedClassMethods</code></a></li> <li><a class="reference internal" href="#extension-DeriveDataTypeable"><code>DeriveDataTypeable</code></a></li> <li><a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a></li> <li><a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a></li> <li><a class="reference internal" href="#extension-DeriveGeneric"><code>DeriveGeneric</code></a></li> <li><a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a></li> <li><a class="reference internal" href="#extension-EmptyDataDecls"><code>EmptyDataDecls</code></a></li> <li><a class="reference internal" href="#extension-ExistentialQuantification"><code>ExistentialQuantification</code></a></li> <li><a class="reference internal" href="#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a></li> <li><a class="reference internal" href="#extension-FlexibleContexts"><code>FlexibleContexts</code></a></li> <li><a class="reference internal" href="#extension-FlexibleInstances"><code>FlexibleInstances</code></a></li> <li><a class="reference internal" href="ffi-chap#extension-ForeignFunctionInterface"><code>ForeignFunctionInterface</code></a></li> <li><a class="reference internal" href="#extension-FunctionalDependencies"><code>FunctionalDependencies</code></a></li> <li><a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code>GeneralizedNewtypeDeriving</code></a></li> <li><a class="reference internal" href="#extension-ImplicitParams"><code>ImplicitParams</code></a></li> <li><a class="reference internal" href="#extension-KindSignatures"><code>KindSignatures</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#extension-LiberalTypeSynonyms"><code>LiberalTypeSynonyms</code></a></li> <li><a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a></li> <li><a class="reference internal" href="#extension-MultiParamTypeClasses"><code>MultiParamTypeClasses</code></a></li> <li><a class="reference internal" href="#extension-ParallelListComp"><code>ParallelListComp</code></a></li> <li><a class="reference internal" href="#extension-NoPatternGuards"><code>PatternGuards</code></a></li> <li><a class="reference internal" href="#extension-PostfixOperators"><code>PostfixOperators</code></a></li> <li><a class="reference internal" href="#extension-RankNTypes"><code>RankNTypes</code></a></li> <li><a class="reference internal" href="#extension-RecursiveDo"><code>RecursiveDo</code></a></li> <li><a class="reference internal" href="#extension-ScopedTypeVariables"><code>ScopedTypeVariables</code></a></li> <li><a class="reference internal" href="#extension-StandaloneDeriving"><code>StandaloneDeriving</code></a></li> <li><a class="reference internal" href="#extension-TypeOperators"><code>TypeOperators</code></a></li> <li><a class="reference internal" href="#extension-TypeSynonymInstances"><code>TypeSynonymInstances</code></a></li> <li><a class="reference internal" href="#extension-UnboxedTuples"><code>UnboxedTuples</code></a></li> <li><a class="reference internal" href="#extension-UnicodeSyntax"><code>UnicodeSyntax</code></a></li> <li><code>UnliftedFFITypes</code></li> </ul> </td>
</tr></table> <p>Enabling these options is the <em>only</em> effect of <code>-fglasgow-exts</code>. We are trying to move away from this portmanteau flag, and towards enabling features individually.</p> </dd>
</dl>   <h1 id="primitives">11.2. Unboxed types and primitive operations</h1> <p id="unboxed-types-and-primitive-operations">GHC is built on a raft of primitive data types and operations; “primitive” in the sense that they cannot be defined in Haskell itself. While you really can use this stuff to write fast code, we generally find it a lot less painful, and more satisfying in the long run, to use higher-level language features and libraries. With any luck, the code you write will be optimised to the efficient unboxed version in any case. And if it isn’t, we’d like to know about it.</p> <p>All these primitive data types and operations are exported by the library <code>GHC.Prim</code>, for which there is <a class="reference external" href="#">detailed online documentation &lt;GHC.Prim.&gt;</a>. (This documentation is generated from the file <code>compiler/prelude/primops.txt.pp</code>.)</p> <p>If you want to mention any of the primitive data types or operations in your program, you must first import <code>GHC.Prim</code> to bring them into scope. Many of them have names ending in <code>#</code>, and to mention such names you need the <a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a> extension.</p> <p>The primops make extensive use of <a class="reference external" href="#glasgow-unboxed">unboxed types</a> and <a class="reference external" href="#unboxed-tuples">unboxed tuples</a>, which we briefly summarise here.</p>  <h2 id="glasgow-unboxed">11.2.1. Unboxed types</h2> <p id="unboxed-types">Most types in GHC are boxed, which means that values of that type are represented by a pointer to a heap object. The representation of a Haskell <code>Int</code>, for example, is a two-word heap object. An unboxed type, however, is represented by the value itself, no pointers or heap allocation are involved.</p> <p>Unboxed types correspond to the “raw machine” types you would use in C: <code>Int#</code> (long int), <code>Double#</code> (double), <code>Addr#</code> (void *), etc. The <em>primitive operations</em> (PrimOps) on these types are what you might expect; e.g., <code>(+#)</code> is addition on <code>Int#</code>s, and is the machine-addition that we all know and love—usually one instruction.</p> <p>Primitive (unboxed) types cannot be defined in Haskell, and are therefore built into the language and compiler. Primitive types are always unlifted; that is, a value of a primitive type cannot be bottom. (Note: a “boxed” type means that a value is represented by a pointer to a heap object; a “lifted” type means that terms of that type may be bottom. See the next paragraph for an example.) We use the convention (but it is only a convention) that primitive types, values, and operations have a <code>#</code> suffix (see <a class="reference internal" href="#magic-hash"><span class="std std-ref">The magic hash</span></a>). For some primitive types we have special syntax for literals, also described in the <a class="reference external" href="#magic-hash">same section</a>.</p> <p>Primitive values are often represented by a simple bit-pattern, such as <code>Int#</code>, <code>Float#</code>, <code>Double#</code>. But this is not necessarily the case: a primitive value might be represented by a pointer to a heap-allocated object. Examples include <code>Array#</code>, the type of primitive arrays. Thus, <code>Array#</code> is an unlifted, boxed type. A primitive array is heap-allocated because it is too big a value to fit in a register, and would be too expensive to copy around; in a sense, it is accidental that it is represented by a pointer. If a pointer represents a primitive value, then it really does point to that value: no unevaluated thunks, no indirections. Nothing can be at the other end of the pointer than the primitive value. A numerically-intensive program using unboxed types can go a <em>lot</em> faster than its “standard” counterpart—we saw a threefold speedup on one example.</p>   <h2 id="unboxed-type-kinds">11.2.2. Unboxed type kinds</h2> <p>Because unboxed types are represented without the use of pointers, we cannot store them in use a polymorphic datatype at an unboxed type. For example, the <code>Just</code> node of <code>Just 42#</code> would have to be different from the <code>Just</code> node of <code>Just 42</code>; the former stores an integer directly, while the latter stores a pointer. GHC currently does not support this variety of <code>Just</code> nodes (nor for any other datatype). Accordingly, the <em>kind</em> of an unboxed type is different from the kind of a boxed type.</p> <p>The Haskell Report describes that <code>*</code> (spelled <code>Type</code> and imported from <code>Data.Kind</code> in the GHC dialect of Haskell) is the kind of ordinary datatypes, such as <code>Int</code>. Furthermore, type constructors can have kinds with arrows; for example, <code>Maybe</code> has kind <code>Type -&gt; Type</code>. Unboxed types have a kind that specifies their runtime representation. For example, the type <code>Int#</code> has kind <code>TYPE 'IntRep</code> and <code>Double#</code> has kind <code>TYPE 'DoubleRep</code>. These kinds say that the runtime representation of an <code>Int#</code> is a machine integer, and the runtime representation of a <code>Double#</code> is a machine double-precision floating point. In contrast, the kind <code>Type</code> is actually just a synonym for <code>TYPE
'LiftedRep</code>. More details of the <code>TYPE</code> mechanisms appear in the <a class="reference external" href="#runtime-rep">section on runtime representation polymorphism</a>.</p> <p>Given that <code>Int#</code>‘s kind is not <code>Type</code>, it then it follows that <code>Maybe
Int#</code> is disallowed. Similarly, because type variables tend to be of kind <code>Type</code> (for example, in <code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code>, all the type variables have kind <code>Type</code>), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</p> <p>There are some restrictions on the use of primitive types:</p> <ul> <li>
<p class="first">You cannot define a newtype whose representation type (the argument type of the data constructor) is an unboxed type. Thus, this is illegal:</p> <pre data-language="haskell">newtype A = MkA Int#
</pre> </li> <li>You cannot bind a variable with an unboxed type in a <em>top-level</em> binding. </li> <li>You cannot bind a variable with an unboxed type in a <em>recursive</em> binding. </li> <li>
<p class="first">You may bind unboxed variables in a (non-recursive, non-top-level) pattern binding, but you must make any such pattern-match strict. (Failing to do so emits a warning <a class="reference internal" href="using-warnings#ghc-flag--Wunbanged-strict-patterns"><code>-Wunbanged-strict-patterns</code></a>.) For example, rather than:</p> <pre data-language="haskell">data Foo = Foo Int Int#

f x = let (Foo a b, w) = ..rhs.. in ..body..
</pre> <p>you must write:</p> <pre data-language="haskell">data Foo = Foo Int Int#

f x = let !(Foo a b, w) = ..rhs.. in ..body..
</pre> <p>since <code>b</code> has type <code>Int#</code>.</p> </li> </ul>   <h2 id="id1">11.2.3. Unboxed tuples</h2> <dl class="extension" id="unboxed-tuples"> <dt id="extension-UnboxedTuples">
<code>UnboxedTuples</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> </dd>
</dl> <p>Unboxed tuples aren’t really exported by <code>GHC.Exts</code>; they are a syntactic extension (<a class="reference internal" href="#extension-UnboxedTuples"><code>UnboxedTuples</code></a>). An unboxed tuple looks like this:</p> <pre data-language="haskell">(# e_1, ..., e_n #)
</pre> <p>where <code>e_1..e_n</code> are expressions of any type (primitive or non-primitive). The type of an unboxed tuple looks the same.</p> <p>Note that when unboxed tuples are enabled, <code>(#</code> is a single lexeme, so for example when using operators like <code>#</code> and <code>#-</code> you need to write <code>( # )</code> and <code>( #- )</code> rather than <code>(#)</code> and <code>(#-)</code>.</p> <p>Unboxed tuples are used for functions that need to return multiple values, but they avoid the heap allocation normally associated with using fully-fledged tuples. When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation. Many of the primitive operations listed in <code>primops.txt.pp</code> return unboxed tuples. In particular, the <code>IO</code> and <code>ST</code> monads use unboxed tuples to avoid unnecessary allocation during sequences of operations.</p> <p>There are some restrictions on the use of unboxed tuples:</p> <ul> <li>
<p class="first">The typical use of unboxed tuples is simply to return multiple values, binding those multiple results with a <code>case</code> expression, thus:</p> <pre data-language="haskell">f x y = (# x+1, y-1 #)
g x = case f x x of { (# a, b #) -&gt; a + b }
</pre> <p>You can have an unboxed tuple in a pattern binding, thus</p> <pre data-language="haskell">f x = let (# p,q #) = h x in ..body..
</pre> <p>If the types of <code>p</code> and <code>q</code> are not unboxed, the resulting binding is lazy like any other Haskell pattern binding. The above example desugars like this:</p> <pre data-language="haskell">f x = let t = case h x of { (# p,q #) -&gt; (p,q) }
          p = fst t
          q = snd t
      in ..body..
</pre> <p>Indeed, the bindings can even be recursive.</p> </li> </ul>   <h2 id="id2">11.2.4. Unboxed sums</h2> <dl class="extension" id="unboxed-sums"> <dt id="extension-UnboxedSums">
<code>UnboxedSums</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.2.1</td> </tr>  </table> <p>Enable the use of unboxed sum syntax.</p> </dd>
</dl> <p><code>-XUnboxedSums</code> enables new syntax for anonymous, unboxed sum types. The syntax for an unboxed sum type with N alternatives is</p> <pre data-language="haskell">(# t_1 | t_2 | ... | t_N #)
</pre> <p>where <code>t_1</code> ... <code>t_N</code> are types (which can be unlifted, including unboxed tuples and sums).</p> <p>Unboxed tuples can be used for multi-arity alternatives. For example:</p> <pre data-language="haskell">(# (# Int, String #) | Bool #)
</pre> <p>The term level syntax is similar. Leading and preceding bars (<code>|</code>) indicate which alternative it is. Here are two terms of the type shown above:</p> <pre data-language="haskell">(# (# 1, "foo" #) | #) -- first alternative

(# | True #) -- second alternative
</pre> <p>The pattern syntax reflects the term syntax:</p> <pre data-language="haskell">case x of
  (# (# i, str #) | #) -&gt; ...
  (# | bool #) -&gt; ...
</pre> <p>Unboxed sums are “unboxed” in the sense that, instead of allocating sums in the heap and representing values as pointers, unboxed sums are represented as their components, just like unboxed tuples. These “components” depend on alternatives of a sum type. Like unboxed tuples, unboxed sums are lazy in their lifted components.</p> <p>The code generator tries to generate as compact layout as possible for each unboxed sum. In the best case, size of an unboxed sum is size of its biggest alternative plus one word (for a tag). The algorithm for generating the memory layout for a sum type works like this:</p> <ul> <li>All types are classified as one of these classes: 32bit word, 64bit word, 32bit float, 64bit float, pointer. </li> <li>For each alternative of the sum type, a layout that consists of these fields is generated. For example, if an alternative has <code>Int</code>, <code>Float#</code> and <code>String</code> fields, the layout will have an 32bit word, 32bit float and pointer fields. </li> <li>
<p class="first">Layout fields are then overlapped so that the final layout will be as compact as possible. For example, suppose we have the unboxed sum:</p> <pre data-language="haskell">(# (# Word32#, String, Float# #)
|  (# Float#, Float#, Maybe Int #) #)
</pre> <p>The final layout will be something like</p> <pre data-language="haskell">Int32, Float32, Float32, Word32, Pointer
</pre> <p>The first <code>Int32</code> is for the tag. There are two <code>Float32</code> fields because floating point types can’t overlap with other types, because of limitations of the code generator that we’re hoping to overcome in the future. The second alternative needs two <code>Float32</code> fields: The <code>Word32</code> field is for the <code>Word32#</code> in the first alternative. The <code>Pointer</code> field is shared between <code>String</code> and <code>Maybe Int</code> values of the alternatives.</p> <p>As another example, this is the layout for the unboxed version of <code>Maybe a</code> type, <code>(# (# #) | a #)</code>:</p> <pre data-language="haskell">Int32, Pointer
</pre> <p>The <code>Pointer</code> field is not used when tag says that it’s <code>Nothing</code>. Otherwise <code>Pointer</code> points to the value in <code>Just</code>. As mentioned above, this type is lazy in its lifted field. Therefore, the type</p> <pre data-language="haskell">data Maybe' a = Maybe' (# (# #) | a #)
</pre> <p>is <em>precisely</em> isomorphic to the type <code>Maybe a</code>, although its memory representation is different.</p> <p>In the degenerate case where all the alternatives have zero width, such as the <code>Bool</code>-like <code>(# (# #) | (# #) #)</code>, the unboxed sum layout only has an <code>Int32</code> tag field (i.e., the whole thing is represented by an integer).</p> </li> </ul>    <h1 id="syntax-extns">11.3. Syntactic extensions</h1>  <h2 id="id3">11.3.1. Unicode syntax</h2> <dl class="extension" id="syntactic-extensions"> <dt id="extension-UnicodeSyntax">
<code>UnicodeSyntax</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Enable the use of Unicode characters in place of their equivalent ASCII sequences.</p> </dd>
</dl> <p>The language extension <a class="reference internal" href="#extension-UnicodeSyntax"><code>UnicodeSyntax</code></a> enables Unicode characters to be used to stand for certain ASCII character sequences. The following alternatives are provided:</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">ASCII</th> <th class="head">Unicode alternative</th> <th class="head">Code point</th> <th class="head">Name</th> </tr> </thead>  <tr>
<td><code>::</code></td> <td>∷</td> <td>0x2237</td> <td>PROPORTION</td> </tr> <tr>
<td><code>=&gt;</code></td> <td>⇒</td> <td>0x21D2</td> <td>RIGHTWARDS DOUBLE ARROW</td> </tr> <tr>
<td><code>-&gt;</code></td> <td>→</td> <td>0x2192</td> <td>RIGHTWARDS ARROW</td> </tr> <tr>
<td><code>&lt;-</code></td> <td>←</td> <td>0x2190</td> <td>LEFTWARDS ARROW</td> </tr> <tr>
<td><code>&gt;-</code></td> <td>⤚</td> <td>0x291a</td> <td>RIGHTWARDS ARROW-TAIL</td> </tr> <tr>
<td><code>-&lt;</code></td> <td>⤙</td> <td>0x2919</td> <td>LEFTWARDS ARROW-TAIL</td> </tr> <tr>
<td><code>&gt;&gt;-</code></td> <td>⤜</td> <td>0x291C</td> <td>RIGHTWARDS DOUBLE ARROW-TAIL</td> </tr> <tr>
<td><code>-&lt;&lt;</code></td> <td>⤛</td> <td>0x291B</td> <td>LEFTWARDS DOUBLE ARROW-TAIL</td> </tr> <tr>
<td><code>*</code></td> <td>★</td> <td>0x2605</td> <td>BLACK STAR</td> </tr> <tr>
<td><code>forall</code></td> <td>∀</td> <td>0x2200</td> <td>FOR ALL</td> </tr> <tr>
<td><code>(|</code></td> <td>⦇</td> <td>0x2987</td> <td>Z NOTATION LEFT IMAGE BRACKET</td> </tr> <tr>
<td><code>|)</code></td> <td>⦈</td> <td>0x2988</td> <td>Z NOTATION RIGHT IMAGE BRACKET</td> </tr> <tr>
<td><code>[|</code></td> <td>⟦</td> <td>0x27E6</td> <td>MATHEMATICAL LEFT WHITE SQUARE BRACKET</td> </tr> <tr>
<td><code>|]</code></td> <td>⟧</td> <td>0x27E7</td> <td>MATHEMATICAL RIGHT WHITE SQUARE BRACKET</td> </tr>  </table>   <h2 id="magic-hash">11.3.2. The magic hash</h2> <dl class="extension" id="the-magic-hash"> <dt id="extension-MagicHash">
<code>MagicHash</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Enables the use of the hash character (<code>#</code>) as an identifier suffix.</p> </dd>
</dl> <p>The language extension <a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a> allows <code>#</code> as a postfix modifier to identifiers. Thus, <code>x#</code> is a valid variable, and <code>T#</code> is a valid type constructor or data constructor.</p> <p>The hash sign does not change semantics at all. We tend to use variable names ending in “#” for unboxed values or types (e.g. <code>Int#</code>), but there is no requirement to do so; they are just plain ordinary variables. Nor does the <a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a> extension bring anything into scope. For example, to bring <code>Int#</code> into scope you must import <code>GHC.Prim</code> (see <a class="reference internal" href="#primitives"><span class="std std-ref">Unboxed types and primitive operations</span></a>); the <a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a> extension then allows you to <em>refer</em> to the <code>Int#</code> that is now in scope. Note that with this option, the meaning of <code>x#y = 0</code> is changed: it defines a function <code>x#</code> taking a single argument <code>y</code>; to define the operator <code>#</code>, put a space: <code>x # y = 0</code>.</p> <p>The <a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a> also enables some new forms of literals (see <a class="reference internal" href="#glasgow-unboxed"><span class="std std-ref">Unboxed types</span></a>):</p> <ul class="simple"> <li>
<code>'x'#</code> has type <code>Char#</code>
</li> <li>
<code>"foo"#</code> has type <code>Addr#</code>
</li> <li>
<code>3#</code> has type <code>Int#</code>. In general, any Haskell integer lexeme followed by a <code>#</code> is an <code>Int#</code> literal, e.g. <code>-0x3A#</code> as well as <code>32#</code>.</li> <li>
<code>3##</code> has type <code>Word#</code>. In general, any non-negative Haskell integer lexeme followed by <code>##</code> is a <code>Word#</code>.</li> <li>
<code>3.2#</code> has type <code>Float#</code>.</li> <li>
<code>3.2##</code> has type <code>Double#</code>
</li> </ul>   <h2 id="id4">11.3.3. Negative literals</h2> <dl class="extension" id="negative-literals"> <dt id="extension-NegativeLiterals">
<code>NegativeLiterals</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8.1</td> </tr>  </table> <p>Enable the use of un-parenthesized negative numeric literals.</p> </dd>
</dl> <p>The literal <code>-123</code> is, according to Haskell98 and Haskell 2010, desugared as <code>negate (fromInteger 123)</code>. The language extension <a class="reference internal" href="#extension-NegativeLiterals"><code>NegativeLiterals</code></a> means that it is instead desugared as <code>fromInteger (-123)</code>.</p> <p>This can make a difference when the positive and negative range of a numeric data type don’t match up. For example, in 8-bit arithmetic -128 is representable, but +128 is not. So <code>negate (fromInteger 128)</code> will elicit an unexpected integer-literal-overflow message.</p>   <h2 id="num-decimals">11.3.4. Fractional looking integer literals</h2> <dl class="extension" id="fractional-looking-integer-literals"> <dt id="extension-NumDecimals">
<code>NumDecimals</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8.1</td> </tr>  </table> <p>Allow the use of floating-point literal syntax for integral types.</p> </dd>
</dl> <p>Haskell 2010 and Haskell 98 define floating literals with the syntax <code>1.2e6</code>. These literals have the type <code>Fractional a =&gt; a</code>.</p> <p>The language extension <a class="reference internal" href="#extension-NumDecimals"><code>NumDecimals</code></a> allows you to also use the floating literal syntax for instances of <code>Integral</code>, and have values like <code>(1.2e6 :: Num a =&gt; a)</code></p>   <h2 id="binary-literals">11.3.5. Binary integer literals</h2> <dl class="extension" id="binary-integer-literals"> <dt id="extension-BinaryLiterals">
<code>BinaryLiterals</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10.1</td> </tr>  </table> <p>Allow the use of binary notation in integer literals.</p> </dd>
</dl> <p>Haskell 2010 and Haskell 98 allows for integer literals to be given in decimal, octal (prefixed by <code>0o</code> or <code>0O</code>), or hexadecimal notation (prefixed by <code>0x</code> or <code>0X</code>).</p> <p>The language extension <a class="reference internal" href="#extension-BinaryLiterals"><code>BinaryLiterals</code></a> adds support for expressing integer literals in binary notation with the prefix <code>0b</code> or <code>0B</code>. For instance, the binary integer literal <code>0b11001001</code> will be desugared into <code>fromInteger 201</code> when <a class="reference internal" href="#extension-BinaryLiterals"><code>BinaryLiterals</code></a> is enabled.</p>   <h2 id="hex-float-literals">11.3.6. Hexadecimal floating point literals</h2> <dl class="extension" id="hexadecimal-floating-point-literals"> <dt id="extension-HexFloatLiterals">
<code>HexFloatLiterals</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.4.1</td> </tr>  </table> <p>Allow writing floating point literals using hexadecimal notation.</p> </dd>
</dl> <p>The hexadecimal notation for floating point literals is useful when you need to specify floating point constants precisely, as the literal notation corresponds closely to the underlying bit-encoding of the number.</p> <p>In this notation floating point numbers are written using hexadecimal digits, and so the digits are interpreted using base 16, rather then the usual 10. This means that digits left of the decimal point correspond to positive powers of 16, while the ones to the right correspond to negative ones.</p> <p>You may also write an explicit exponent, which is similar to the exponent in decimal notation with the following differences: - the exponent begins with <code>p</code> instead of <code>e</code> - the exponent is written in base <code>10</code> (<strong>not</strong> 16) - the base of the exponent is <code>2</code> (<strong>not</strong> 16).</p> <p>In terms of the underlying bit encoding, each hexadecimal digit corresponds to 4 bits, and you may think of the exponent as “moving” the floating point by one bit left (negative) or right (positive). Here are some examples:</p> <ul class="simple"> <li>
<code>0x0.1</code> is the same as <code>1/16</code>
</li> <li>
<code>0x0.01</code> is the same as <code>1/256</code>
</li> <li>
<code>0xF.FF</code> is the same as <code>15 + 15/16 + 15/256</code>
</li> <li>
<code>0x0.1p4</code> is the same as <code>1</code>
</li> <li>
<code>0x0.1p-4</code> is the same as <code>1/256</code>
</li> <li>
<code>0x0.1p12</code> is the same as <code>256</code>
</li> </ul>   <h2 id="id5">11.3.7. Numeric underscores</h2> <dl class="extension" id="numeric-underscores"> <dt id="extension-NumericUnderscores">
<code>NumericUnderscores</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.6.1</td> </tr>  </table> <p>Allow the use of underscores in numeric literals.</p> </dd>
</dl> <p>GHC allows for numeric literals to be given in decimal, octal, hexadecimal, binary, or float notation.</p> <p>The language extension <a class="reference internal" href="#extension-NumericUnderscores"><code>NumericUnderscores</code></a> adds support for expressing underscores in numeric literals. For instance, the numeric literal <code>1_000_000</code> will be parsed into <code>1000000</code> when <a class="reference internal" href="#extension-NumericUnderscores"><code>NumericUnderscores</code></a> is enabled. That is, underscores in numeric literals are ignored when <a class="reference internal" href="#extension-NumericUnderscores"><code>NumericUnderscores</code></a> is enabled. See also <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/14473">Issue #14473</a>.</p> <p>For example:</p> <pre data-language="none">-- decimal
million    = 1_000_000
billion    = 1_000_000_000
lightspeed = 299_792_458
version    = 8_04_1
date       = 2017_12_31

-- hexadecimal
red_mask = 0xff_00_00
size1G   = 0x3fff_ffff

-- binary
bit8th   = 0b01_0000_0000
packbits = 0b1_11_01_0000_0_111
bigbits  = 0b1100_1011__1110_1111__0101_0011

-- float
pi       = 3.141_592_653_589_793
faraday  = 96_485.332_89
avogadro = 6.022_140_857e+23

-- function
isUnderMillion = (&lt; 1_000_000)

clip64M x
    | x &gt; 0x3ff_ffff = 0x3ff_ffff
    | otherwise = x

test8bit x = (0b01_0000_0000 .&amp;. x) /= 0
</pre> <p>About validity:</p> <pre data-language="none">x0 = 1_000_000   -- valid
x1 = 1__000000   -- valid
x2 = 1000000_    -- invalid
x3 = _1000000    -- invalid

e0 = 0.0001      -- valid
e1 = 0.000_1     -- valid
e2 = 0_.0001     -- invalid
e3 = _0.0001     -- invalid
e4 = 0._0001     -- invalid
e5 = 0.0001_     -- invalid

f0 = 1e+23       -- valid
f1 = 1_e+23      -- valid
f2 = 1__e+23     -- valid
f3 = 1e_+23      -- invalid

g0 = 1e+23       -- valid
g1 = 1e+_23      -- invalid
g2 = 1e+23_      -- invalid

h0 = 0xffff      -- valid
h1 = 0xff_ff     -- valid
h2 = 0x_ffff     -- valid
h3 = 0x__ffff    -- valid
h4 = _0xffff     -- invalid
</pre>   <h2 id="id6">11.3.8. Pattern guards</h2> <dl class="extension" id="pattern-guards"> <dt id="extension-NoPatternGuards">
<code>NoPatternGuards</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implied by:</th>
<td class="field-body"><code>Haskell98</code></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> </dd>
</dl> <p>Disable <a class="reference external" href="http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13">pattern guards</a>.</p>   <h2 id="id7">11.3.9. View patterns</h2> <dl class="extension" id="view-patterns"> <dt id="extension-ViewPatterns">
<code>ViewPatterns</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.10.1</td> </tr>  </table> <p>Allow use of view pattern syntax.</p> </dd>
</dl> <p>View patterns are enabled by the language extension <a class="reference internal" href="#extension-ViewPatterns"><code>ViewPatterns</code></a>. More information and examples of view patterns can be found on the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns">Wiki page</a>.</p> <p>View patterns are somewhat like pattern guards that can be nested inside of other patterns. They are a convenient way of pattern-matching against values of abstract types. For example, in a programming language implementation, we might represent the syntax of the types of the language as follows:</p> <pre data-language="haskell">type Typ

data TypView = Unit
             | Arrow Typ Typ

view :: Typ -&gt; TypView

-- additional operations for constructing Typ's ...
</pre> <p>The representation of Typ is held abstract, permitting implementations to use a fancy representation (e.g., hash-consing to manage sharing). Without view patterns, using this signature is a little inconvenient:</p> <pre data-language="haskell">size :: Typ -&gt; Integer
size t = case view t of
  Unit -&gt; 1
  Arrow t1 t2 -&gt; size t1 + size t2
</pre> <p>It is necessary to iterate the case, rather than using an equational function definition. And the situation is even worse when the matching against <code>t</code> is buried deep inside another pattern.</p> <p>View patterns permit calling the view function inside the pattern and matching against the result:</p> <pre data-language="haskell">size (view -&gt; Unit) = 1
size (view -&gt; Arrow t1 t2) = size t1 + size t2
</pre> <p>That is, we add a new form of pattern, written ⟨expression⟩ <code>-&gt;</code> ⟨pattern⟩ that means “apply the expression to whatever we’re trying to match against, and then match the result of that application against the pattern”. The expression can be any Haskell expression of function type, and view patterns can be used wherever patterns are used.</p> <p>The semantics of a pattern <code>(</code> ⟨exp⟩ <code>-&gt;</code> ⟨pat⟩ <code>)</code> are as follows:</p> <ul> <li>
<p class="first">Scoping: The variables bound by the view pattern are the variables bound by ⟨pat⟩.</p> <p>Any variables in ⟨exp⟩ are bound occurrences, but variables bound “to the left” in a pattern are in scope. This feature permits, for example, one argument to a function to be used in the view of another argument. For example, the function <code>clunky</code> from <a class="reference internal" href="#pattern-guards"><span class="std std-ref">Pattern guards</span></a> can be written using view patterns as follows:</p> <pre data-language="haskell">clunky env (lookup env -&gt; Just val1) (lookup env -&gt; Just val2) = val1 + val2
...other equations for clunky...
</pre> <p>More precisely, the scoping rules are:</p> <ul> <li>
<p class="first">In a single pattern, variables bound by patterns to the left of a view pattern expression are in scope. For example:</p> <pre data-language="haskell">example :: Maybe ((String -&gt; Integer,Integer), String) -&gt; Bool
example (Just ((f,_), f -&gt; 4)) = True
</pre> <p>Additionally, in function definitions, variables bound by matching earlier curried arguments may be used in view pattern expressions in later arguments:</p> <pre data-language="haskell">example :: (String -&gt; Integer) -&gt; String -&gt; Bool
example f (f -&gt; 4) = True
</pre> <p>That is, the scoping is the same as it would be if the curried arguments were collected into a tuple.</p> </li> <li>
<p class="first">In mutually recursive bindings, such as <code>let</code>, <code>where</code>, or the top level, view patterns in one declaration may not mention variables bound by other declarations. That is, each declaration must be self-contained. For example, the following program is not allowed:</p> <pre data-language="haskell">let {(x -&gt; y) = e1 ;
     (y -&gt; x) = e2 } in x
</pre> </li> </ul> <p>(For some amplification on this design choice see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/4061">Issue #4061</a>.</p> </li> <li>Typing: If ⟨exp⟩ has type ⟨T1⟩ <code>-&gt;</code> ⟨T2⟩ and ⟨pat⟩ matches a ⟨T2⟩, then the whole view pattern matches a ⟨T1⟩. </li> <li>
<p class="first">Matching: To the equations in Section 3.17.3 of the <a class="reference external" href="http://www.haskell.org/onlinereport/">Haskell 98 Report</a>, add the following:</p> <pre data-language="haskell">case v of { (e -&gt; p) -&gt; e1 ; _ -&gt; e2 }
 =
case (e v) of { p -&gt; e1 ; _ -&gt; e2 }
</pre> <p>That is, to match a variable ⟨v⟩ against a pattern <code>(</code> ⟨exp⟩ <code>-&gt;</code> ⟨pat⟩ <code>)</code>, evaluate <code>(</code> ⟨exp⟩ ⟨v⟩ <code>)</code> and match the result against ⟨pat⟩.</p> </li> <li>
<p class="first">Efficiency: When the same view function is applied in multiple branches of a function definition or a case expression (e.g., in <code>size</code> above), GHC makes an attempt to collect these applications into a single nested case expression, so that the view function is only applied once. Pattern compilation in GHC follows the matrix algorithm described in Chapter 4 of <a class="reference external" href="http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/">The Implementation of Functional Programming Languages</a>. When the top rows of the first column of a matrix are all view patterns with the “same” expression, these patterns are transformed into a single nested case. This includes, for example, adjacent view patterns that line up in a tuple, as in</p> <pre data-language="haskell">f ((view -&gt; A, p1), p2) = e1
f ((view -&gt; B, p3), p4) = e2
</pre> <p>The current notion of when two view pattern expressions are “the same” is very restricted: it is not even full syntactic equality. However, it does include variables, literals, applications, and tuples; e.g., two instances of <code>view ("hi", "there")</code> will be collected. However, the current implementation does not compare up to alpha-equivalence, so two instances of <code>(x, view x -&gt; y)</code> will not be coalesced.</p> </li> </ul>   <h2 id="id8">11.3.10. n+k patterns</h2> <dl class="extension" id="n-k-patterns"> <dt id="extension-NPlusKPatterns">
<code>NPlusKPatterns</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implied by:</th>
<td class="field-body"><code>Haskell98</code></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.12.1</td> </tr>  </table> <p>Enable use of <code>n+k</code> patterns.</p> </dd>
</dl>   <h2 id="recursive-do-notation">11.3.11. The recursive do-notation</h2> <dl class="extension" id="the-recursive-do-notation"> <dt id="extension-RecursiveDo">
<code>RecursiveDo</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow the use of recursive <code>do</code> notation.</p> </dd>
</dl> <p>The do-notation of Haskell 98 does not allow <em>recursive bindings</em>, that is, the variables bound in a do-expression are visible only in the textually following code block. Compare this to a let-expression, where bound variables are visible in the entire binding group.</p> <p>It turns out that such recursive bindings do indeed make sense for a variety of monads, but not all. In particular, recursion in this sense requires a fixed-point operator for the underlying monad, captured by the <code>mfix</code> method of the <code>MonadFix</code> class, defined in <code>Control.Monad.Fix</code> as follows:</p> <pre data-language="haskell">class Monad m =&gt; MonadFix m where
   mfix :: (a -&gt; m a) -&gt; m a
</pre> <p>Haskell’s <code>Maybe</code>, <code>[]</code> (list), <code>ST</code> (both strict and lazy versions), <code>IO</code>, and many other monads have <code>MonadFix</code> instances. On the negative side, the continuation monad, with the signature <code>(a -&gt; r) -&gt; r</code>, does not.</p> <p>For monads that do belong to the <code>MonadFix</code> class, GHC provides an extended version of the do-notation that allows recursive bindings. The <a class="reference internal" href="#extension-RecursiveDo"><code>RecursiveDo</code></a> (language pragma: <code>RecursiveDo</code>) provides the necessary syntactic support, introducing the keywords <code>mdo</code> and <code>rec</code> for higher and lower levels of the notation respectively. Unlike bindings in a <code>do</code> expression, those introduced by <code>mdo</code> and <code>rec</code> are recursively defined, much like in an ordinary let-expression. Due to the new keyword <code>mdo</code>, we also call this notation the <em>mdo-notation</em>.</p> <p>Here is a simple (albeit contrived) example:</p> <pre data-language="haskell">{-# LANGUAGE RecursiveDo #-}
justOnes = mdo { xs &lt;- Just (1:xs)
               ; return (map negate xs) }
</pre> <p>or equivalently</p> <pre data-language="haskell">{-# LANGUAGE RecursiveDo #-}
justOnes = do { rec { xs &lt;- Just (1:xs) }
              ; return (map negate xs) }
</pre> <p>As you can guess <code>justOnes</code> will evaluate to <code>Just [-1,-1,-1,...</code>.</p> <p>GHC’s implementation the mdo-notation closely follows the original translation as described in the paper <a class="reference external" href="http://leventerkok.github.io/papers/recdo.pdf">A recursive do for Haskell</a>, which in turn is based on the work <a class="reference external" href="http://leventerkok.github.io/papers/erkok-thesis.pdf">Value Recursion in Monadic Computations</a>. Furthermore, GHC extends the syntax described in the former paper with a lower level syntax flagged by the <code>rec</code> keyword, as we describe next.</p>  <h3 id="recursive-binding-groups">11.3.11.1. Recursive binding groups</h3> <p>The extension <a class="reference internal" href="#extension-RecursiveDo"><code>RecursiveDo</code></a> also introduces a new keyword <code>rec</code>, which wraps a mutually-recursive group of monadic statements inside a <code>do</code> expression, producing a single statement. Similar to a <code>let</code> statement inside a <code>do</code>, variables bound in the <code>rec</code> are visible throughout the <code>rec</code> group, and below it. For example, compare</p> <pre data-language="haskell">do { a &lt;- getChar            do { a &lt;- getChar
   ; let { r1 = f a r2          ; rec { r1 &lt;- f a r2
   ;     ; r2 = g r1 }          ;     ; r2 &lt;- g r1 }
   ; return (r1 ++ r2) }        ; return (r1 ++ r2) }
</pre> <p>In both cases, <code>r1</code> and <code>r2</code> are available both throughout the <code>let</code> or <code>rec</code> block, and in the statements that follow it. The difference is that <code>let</code> is non-monadic, while <code>rec</code> is monadic. (In Haskell <code>let</code> is really <code>letrec</code>, of course.)</p> <p>The semantics of <code>rec</code> is fairly straightforward. Whenever GHC finds a <code>rec</code> group, it will compute its set of bound variables, and will introduce an appropriate call to the underlying monadic value-recursion operator <code>mfix</code>, belonging to the <code>MonadFix</code> class. Here is an example:</p> <pre data-language="haskell">rec { b &lt;- f a c     ===&gt;    (b,c) &lt;- mfix (\ ~(b,c) -&gt; do { b &lt;- f a c
    ; c &lt;- f b a }                                         ; c &lt;- f b a
                                                           ; return (b,c) })
</pre> <p>As usual, the meta-variables <code>b</code>, <code>c</code> etc., can be arbitrary patterns. In general, the statement <code>rec ss</code> is desugared to the statement</p> <pre data-language="haskell">vs &lt;- mfix (\ ~vs -&gt; do { ss; return vs })
</pre> <p>where <code>vs</code> is a tuple of the variables bound by <code>ss</code>.</p> <p>Note in particular that the translation for a <code>rec</code> block only involves wrapping a call to <code>mfix</code>: it performs no other analysis on the bindings. The latter is the task for the <code>mdo</code> notation, which is described next.</p>   <h3 id="the-mdo-notation">11.3.11.2. The <code>mdo</code> notation</h3> <p>A <code>rec</code>-block tells the compiler where precisely the recursive knot should be tied. It turns out that the placement of the recursive knots can be rather delicate: in particular, we would like the knots to be wrapped around as minimal groups as possible. This process is known as <em>segmentation</em>, and is described in detail in Section 3.2 of <a class="reference external" href="http://leventerkok.github.io/papers/recdo.pdf">A recursive do for Haskell</a>. Segmentation improves polymorphism and reduces the size of the recursive knot. Most importantly, it avoids unnecessary interference caused by a fundamental issue with the so-called <em>right-shrinking</em> axiom for monadic recursion. In brief, most monads of interest (IO, strict state, etc.) do <em>not</em> have recursion operators that satisfy this axiom, and thus not performing segmentation can cause unnecessary interference, changing the termination behavior of the resulting translation. (Details can be found in Sections 3.1 and 7.2.2 of <a class="reference external" href="http://leventerkok.github.io/papers/erkok-thesis.pdf">Value Recursion in Monadic Computations</a>.)</p> <p>The <code>mdo</code> notation removes the burden of placing explicit <code>rec</code> blocks in the code. Unlike an ordinary <code>do</code> expression, in which variables bound by statements are only in scope for later statements, variables bound in an <code>mdo</code> expression are in scope for all statements of the expression. The compiler then automatically identifies minimal mutually recursively dependent segments of statements, treating them as if the user had wrapped a <code>rec</code> qualifier around them.</p> <p>The definition is syntactic:</p> <ul class="simple"> <li>A generator ⟨g⟩ <em>depends</em> on a textually following generator ⟨g’⟩, if<ul> <li>⟨g’⟩ defines a variable that is used by ⟨g⟩, or</li> <li>⟨g’⟩ textually appears between ⟨g⟩ and ⟨g’‘⟩, where ⟨g⟩ depends on ⟨g’‘⟩.</li> </ul> </li> <li>A <em>segment</em> of a given <code>mdo</code>-expression is a minimal sequence of generators such that no generator of the sequence depends on an outside generator. As a special case, although it is not a generator, the final expression in an <code>mdo</code>-expression is considered to form a segment by itself.</li> </ul> <p>Segments in this sense are related to <em>strongly-connected components</em> analysis, with the exception that bindings in a segment cannot be reordered and must be contiguous.</p> <p>Here is an example <code>mdo</code>-expression, and its translation to <code>rec</code> blocks:</p> <pre data-language="haskell">mdo { a &lt;- getChar      ===&gt; do { a &lt;- getChar
    ; b &lt;- f a c                ; rec { b &lt;- f a c
    ; c &lt;- f b a                ;     ; c &lt;- f b a }
    ; z &lt;- h a b                ; z &lt;- h a b
    ; d &lt;- g d e                ; rec { d &lt;- g d e
    ; e &lt;- g a z                ;     ; e &lt;- g a z }
    ; putChar c }               ; putChar c }
</pre> <p>Note that a given <code>mdo</code> expression can cause the creation of multiple <code>rec</code> blocks. If there are no recursive dependencies, <code>mdo</code> will introduce no <code>rec</code> blocks. In this latter case an <code>mdo</code> expression is precisely the same as a <code>do</code> expression, as one would expect.</p> <p>In summary, given an <code>mdo</code> expression, GHC first performs segmentation, introducing <code>rec</code> blocks to wrap over minimal recursive groups. Then, each resulting <code>rec</code> is desugared, using a call to <code>Control.Monad.Fix.mfix</code> as described in the previous section. The original <code>mdo</code>-expression typechecks exactly when the desugared version would do so.</p> <p>Here are some other important points in using the recursive-do notation:</p> <ul class="simple"> <li>It is enabled with the extension <a class="reference internal" href="#extension-RecursiveDo"><code>RecursiveDo</code></a>, or the <code>LANGUAGE RecursiveDo</code> pragma. (The same extension enables both <code>mdo</code>-notation, and the use of <code>rec</code> blocks inside <code>do</code> expressions.)</li> <li>
<code>rec</code> blocks can also be used inside <code>mdo</code>-expressions, which will be treated as a single statement. However, it is good style to either use <code>mdo</code> or <code>rec</code> blocks in a single expression.</li> <li>If recursive bindings are required for a monad, then that monad must be declared an instance of the <code>MonadFix</code> class.</li> <li>The following instances of <code>MonadFix</code> are automatically provided: List, Maybe, IO. Furthermore, the <code>Control.Monad.ST</code> and <code>Control.Monad.ST.Lazy</code> modules provide the instances of the <code>MonadFix</code> class for Haskell’s internal state monad (strict and lazy, respectively).</li> <li>Like <code>let</code> and <code>where</code> bindings, name shadowing is not allowed within an <code>mdo</code>-expression or a <code>rec</code>-block; that is, all the names bound in a single <code>rec</code> must be distinct. (GHC will complain if this is not the case.)</li> </ul>    <h2 id="applicative-do">11.3.12. Applicative do-notation</h2> <dl class="extension" id="applicative-do-notation"> <dt id="extension-ApplicativeDo">
<code>ApplicativeDo</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Allow use of <code>Applicative</code> <code>do</code> notation.</p> </dd>
</dl> <p>The language option <a class="reference internal" href="#extension-ApplicativeDo"><code>ApplicativeDo</code></a> enables an alternative translation for the do-notation, which uses the operators <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code>, along with <code>join</code> as far as possible. There are two main reasons for wanting to do this:</p> <ul class="simple"> <li>We can use do-notation with types that are an instance of <code>Applicative</code> and <code>Functor</code>, but not <code>Monad</code>
</li> <li>In some monads, using the applicative operators is more efficient than monadic bind. For example, it may enable more parallelism.</li> </ul> <p>Applicative do-notation desugaring preserves the original semantics, provided that the <code>Applicative</code> instance satisfies <code>&lt;*&gt; = ap</code> and <code>pure = return</code> (these are true of all the common monadic types). Thus, you can normally turn on <a class="reference internal" href="#extension-ApplicativeDo"><code>ApplicativeDo</code></a> without fear of breaking your program. There is one pitfall to watch out for; see <a class="reference internal" href="#applicative-do-pitfall"><span class="std std-ref">Things to watch out for</span></a>.</p> <p>There are no syntactic changes with <a class="reference internal" href="#extension-ApplicativeDo"><code>ApplicativeDo</code></a>. The only way it shows up at the source level is that you can have a <code>do</code> expression that doesn’t require a <code>Monad</code> constraint. For example, in GHCi:</p> <pre data-language="haskell">Prelude&gt; :set -XApplicativeDo
Prelude&gt; :t \m -&gt; do { x &lt;- m; return (not x) }
\m -&gt; do { x &lt;- m; return (not x) }
  :: Functor f =&gt; f Bool -&gt; f Bool
</pre> <p>This example only requires <code>Functor</code>, because it is translated into <code>(\x -&gt;
not x) &lt;$&gt; m</code>. A more complex example requires <code>Applicative</code>,</p> <pre data-language="haskell">Prelude&gt; :t \m -&gt; do { x &lt;- m 'a'; y &lt;- m 'b'; return (x || y) }
\m -&gt; do { x &lt;- m 'a'; y &lt;- m 'b'; return (x || y) }
  :: Applicative f =&gt; (Char -&gt; f Bool) -&gt; f Bool
</pre> <p>Here GHC has translated the expression into</p> <pre data-language="haskell">(\x y -&gt; x || y) &lt;$&gt; m 'a' &lt;*&gt; m 'b'
</pre> <p>It is possible to see the actual translation by using <a class="reference internal" href="debugging#ghc-flag--ddump-ds"><code>-ddump-ds</code></a>, but be warned, the output is quite verbose.</p> <p>Note that if the expression can’t be translated into uses of <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code> only, then it will incur a <code>Monad</code> constraint as usual. This happens when there is a dependency on a value produced by an earlier statement in the <code>do</code>-block:</p> <pre data-language="haskell">Prelude&gt; :t \m -&gt; do { x &lt;- m True; y &lt;- m x; return (x || y) }
\m -&gt; do { x &lt;- m True; y &lt;- m x; return (x || y) }
  :: Monad m =&gt; (Bool -&gt; m Bool) -&gt; m Bool
</pre> <p>Here, <code>m x</code> depends on the value of <code>x</code> produced by the first statement, so the expression cannot be translated using <code>&lt;*&gt;</code>.</p> <p>In general, the rule for when a <code>do</code> statement incurs a <code>Monad</code> constraint is as follows. If the do-expression has the following form:</p> <pre data-language="haskell">do p1 &lt;- E1; ...; pn &lt;- En; return E
</pre> <p>where none of the variables defined by <code>p1...pn</code> are mentioned in <code>E1...En</code>, and <code>p1...pn</code> are all variables or lazy patterns, then the expression will only require <code>Applicative</code>. Otherwise, the expression will require <code>Monad</code>. The block may return a pure expression <code>E</code> depending upon the results <code>p1...pn</code> with either <code>return</code> or <code>pure</code>.</p> <p>Note: the final statement must match one of these patterns exactly:</p> <ul class="simple"> <li><code>return E</code></li> <li><code>return $ E</code></li> <li><code>pure E</code></li> <li><code>pure $ E</code></li> </ul> <p>otherwise GHC cannot recognise it as a <code>return</code> statement, and the transformation to use <code>&lt;$&gt;</code> that we saw above does not apply. In particular, slight variations such as <code>return . Just $ x</code> or <code>let x
= e in return x</code> would not be recognised.</p> <p>If the final statement is not of one of these forms, GHC falls back to standard <code>do</code> desugaring, and the expression will require a <code>Monad</code> constraint.</p> <p>When the statements of a <code>do</code> expression have dependencies between them, and <code>ApplicativeDo</code> cannot infer an <code>Applicative</code> type, it uses a heuristic algorithm to try to use <code>&lt;*&gt;</code> as much as possible. This algorithm usually finds the best solution, but in rare complex cases it might miss an opportunity. There is an algorithm that finds the optimal solution, provided as an option:</p> <dl class="ghc-flag"> <dt id="ghc-flag--foptimal-applicative-do">
<code>-foptimal-applicative-do</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Enables an alternative algorithm for choosing where to use <code>&lt;*&gt;</code> in conjunction with the <code>ApplicativeDo</code> language extension. This algorithm always finds the optimal solution, but it is expensive: <code>O(n^3)</code>, so this option can lead to long compile times when there are very large <code>do</code> expressions (over 100 statements). The default <code>ApplicativeDo</code> algorithm is <code>O(n^2)</code>.</p> </dd>
</dl>  <h3 id="applicative-do-strict">11.3.12.1. Strict patterns</h3> <p id="strict-patterns">A strict pattern match in a bind statement prevents <code>ApplicativeDo</code> from transforming that statement to use <code>Applicative</code>. This is because the transformation would change the semantics by making the expression lazier.</p> <p>For example, this code will require a <code>Monad</code> constraint:</p> <pre data-language="haskell">&gt; :t \m -&gt; do { (x:xs) &lt;- m; return x }
\m -&gt; do { (x:xs) &lt;- m; return x } :: Monad m =&gt; m [b] -&gt; m b
</pre> <p>but making the pattern match lazy allows it to have a <code>Functor</code> constraint:</p> <pre data-language="haskell">&gt; :t \m -&gt; do { ~(x:xs) &lt;- m; return x }
\m -&gt; do { ~(x:xs) &lt;- m; return x } :: Functor f =&gt; f [b] -&gt; f b
</pre> <p>A “strict pattern match” is any pattern match that can fail. For example, <code>()</code>, <code>(x:xs)</code>, <code>!z</code>, and <code>C x</code> are strict patterns, but <code>x</code> and <code>~(1,2)</code> are not. For the purposes of <code>ApplicativeDo</code>, a pattern match against a <code>newtype</code> constructor is considered strict.</p> <p>When there’s a strict pattern match in a sequence of statements, <code>ApplicativeDo</code> places a <code>&gt;&gt;=</code> between that statement and the one that follows it. The sequence may be transformed to use <code>&lt;*&gt;</code> elsewhere, but the strict pattern match and the following statement will always be connected with <code>&gt;&gt;=</code>, to retain the same strictness semantics as the standard do-notation. If you don’t want this, simply put a <code>~</code> on the pattern match to make it lazy.</p>   <h3 id="applicative-do-pitfall">11.3.12.2. Things to watch out for</h3> <p id="things-to-watch-out-for">Your code should just work as before when <a class="reference internal" href="#extension-ApplicativeDo"><code>ApplicativeDo</code></a> is enabled, provided you use conventional <code>Applicative</code> instances. However, if you define a <code>Functor</code> or <code>Applicative</code> instance using do-notation, then it will likely get turned into an infinite loop by GHC. For example, if you do this:</p> <pre data-language="haskell">instance Functor MyType where
    fmap f m = do x &lt;- m; return (f x)
</pre> <p>Then applicative desugaring will turn it into</p> <pre data-language="haskell">instance Functor MyType where
    fmap f m = fmap (\x -&gt; f x) m
</pre> <p>And the program will loop at runtime. Similarly, an <code>Applicative</code> instance like this</p> <pre data-language="haskell">instance Applicative MyType where
    pure = return
    x &lt;*&gt; y = do f &lt;- x; a &lt;- y; return (f a)
</pre> <p>will result in an infinte loop when <code>&lt;*&gt;</code> is called.</p> <p>Just as you wouldn’t define a <code>Monad</code> instance using the do-notation, you shouldn’t define <code>Functor</code> or <code>Applicative</code> instance using do-notation (when using <code>ApplicativeDo</code>) either. The correct way to define these instances in terms of <code>Monad</code> is to use the <code>Monad</code> operations directly, e.g.</p> <pre data-language="haskell">instance Functor MyType where
    fmap f m = m &gt;&gt;= return . f

instance Applicative MyType where
    pure = return
    (&lt;*&gt;) = ap
</pre>    <h2 id="id9">11.3.13. Parallel List Comprehensions</h2> <dl class="extension" id="parallel-list-comprehensions"> <dt id="extension-ParallelListComp">
<code>ParallelListComp</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow parallel list comprehension syntax.</p> </dd>
</dl> <p>Parallel list comprehensions are a natural extension to list comprehensions. List comprehensions can be thought of as a nice syntax for writing maps and filters. Parallel comprehensions extend this to include the <code>zipWith</code> family.</p> <p>A parallel list comprehension has multiple independent branches of qualifier lists, each separated by a <code>|</code> symbol. For example, the following zips together two lists:</p> <pre data-language="haskell">[ (x, y) | x &lt;- xs | y &lt;- ys ]
</pre> <p>The behaviour of parallel list comprehensions follows that of zip, in that the resulting list will have the same length as the shortest branch.</p> <p>We can define parallel list comprehensions by translation to regular comprehensions. Here’s the basic idea:</p> <p>Given a parallel comprehension of the form:</p> <pre data-language="haskell">[ e | p1 &lt;- e11, p2 &lt;- e12, ...
    | q1 &lt;- e21, q2 &lt;- e22, ...
    ...
]
</pre> <p>This will be translated to:</p> <pre data-language="haskell">[ e | ((p1,p2), (q1,q2), ...) &lt;- zipN [(p1,p2) | p1 &lt;- e11, p2 &lt;- e12, ...]
                                      [(q1,q2) | q1 &lt;- e21, q2 &lt;- e22, ...]
                                      ...
]
</pre> <p>where <code>zipN</code> is the appropriate zip for the given number of branches.</p>   <h2 id="generalised-list-comprehensions">11.3.14. Generalised (SQL-like) List Comprehensions</h2> <dl class="extension" id="generalised-sql-like-list-comprehensions"> <dt id="extension-TransformListComp">
<code>TransformListComp</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.10.1</td> </tr>  </table> <p>Allow use of generalised list (SQL-like) comprehension syntax. This introduces the <code>group</code>, <code>by</code>, and <code>using</code> keywords.</p> </dd>
</dl> <p>Generalised list comprehensions are a further enhancement to the list comprehension syntactic sugar to allow operations such as sorting and grouping which are familiar from SQL. They are fully described in the paper <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf">Comprehensive comprehensions: comprehensions with “order by” and “group by”</a>, except that the syntax we use differs slightly from the paper.</p> <p>The extension is enabled with the extension <a class="reference internal" href="#extension-TransformListComp"><code>TransformListComp</code></a>.</p> <p>Here is an example:</p> <pre data-language="haskell">employees = [ ("Simon", "MS", 80)
            , ("Erik", "MS", 100)
            , ("Phil", "Ed", 40)
            , ("Gordon", "Ed", 45)
            , ("Paul", "Yale", 60) ]

output = [ (the dept, sum salary)
         | (name, dept, salary) &lt;- employees
         , then group by dept using groupWith
         , then sortWith by (sum salary)
         , then take 5 ]
</pre> <p>In this example, the list <code>output</code> would take on the value:</p> <pre data-language="haskell">[("Yale", 60), ("Ed", 85), ("MS", 180)]
</pre> <p>There are three new keywords: <code>group</code>, <code>by</code>, and <code>using</code>. (The functions <code>sortWith</code> and <code>groupWith</code> are not keywords; they are ordinary functions that are exported by <code>GHC.Exts</code>.)</p> <p>There are five new forms of comprehension qualifier, all introduced by the (existing) keyword <code>then</code>:</p> <ul> <li>
<pre data-language="haskell">then f
</pre> <p>This statement requires that f have the type forall a. [a] -&gt; [a] . You can see an example of its use in the motivating example, as this form is used to apply take 5 .</p> </li> <li>
<pre data-language="haskell">then f by e
</pre> <p>This form is similar to the previous one, but allows you to create a function which will be passed as the first argument to f. As a consequence f must have the type <code>forall a. (a -&gt; t) -&gt; [a] -&gt; [a]</code>. As you can see from the type, this function lets f “project out” some information from the elements of the list it is transforming.</p> <p>An example is shown in the opening example, where <code>sortWith</code> is supplied with a function that lets it find out the <code>sum salary</code> for any item in the list comprehension it transforms.</p> </li> <li>
<pre data-language="haskell">then group by e using f
</pre> <p>This is the most general of the grouping-type statements. In this form, f is required to have type <code>forall a. (a -&gt; t) -&gt; [a] -&gt; [[a]]</code>. As with the <code>then f by e</code> case above, the first argument is a function supplied to f by the compiler which lets it compute e on every element of the list being transformed. However, unlike the non-grouping case, f additionally partitions the list into a number of sublists: this means that at every point after this statement, binders occurring before it in the comprehension refer to <em>lists</em> of possible values, not single values. To help understand this, let’s look at an example:</p> <pre data-language="haskell">-- This works similarly to groupWith in GHC.Exts, but doesn't sort its input first
groupRuns :: Eq b =&gt; (a -&gt; b) -&gt; [a] -&gt; [[a]]
groupRuns f = groupBy (\x y -&gt; f x == f y)

output = [ (the x, y)
| x &lt;- ([1..3] ++ [1..2])
, y &lt;- [4..6]
, then group by x using groupRuns ]
</pre> <p>This results in the variable <code>output</code> taking on the value below:</p> <pre data-language="haskell">[(1, [4, 5, 6]), (2, [4, 5, 6]), (3, [4, 5, 6]), (1, [4, 5, 6]), (2, [4, 5, 6])]
</pre> <p>Note that we have used the <code>the</code> function to change the type of x from a list to its original numeric type. The variable y, in contrast, is left unchanged from the list form introduced by the grouping.</p> </li> <li>
<pre data-language="haskell">then group using f
</pre> <p>With this form of the group statement, f is required to simply have the type <code>forall a. [a] -&gt; [[a]]</code>, which will be used to group up the comprehension so far directly. An example of this form is as follows:</p> <pre data-language="haskell">output = [ x
| y &lt;- [1..5]
, x &lt;- "hello"
, then group using inits]
</pre> <p>This will yield a list containing every prefix of the word “hello” written out 5 times:</p> <pre data-language="haskell">["","h","he","hel","hell","hello","helloh","hellohe","hellohel","hellohell","hellohello","hellohelloh",...]
</pre> </li> </ul>   <h2 id="id10">11.3.15. Monad comprehensions</h2> <dl class="extension" id="monad-comprehensions"> <dt id="extension-MonadComprehensions">
<code>MonadComprehensions</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.2.1</td> </tr>  </table> <p>Enable list comprehension syntax for arbitrary monads.</p> </dd>
</dl> <p>Monad comprehensions generalise the list comprehension notation, including parallel comprehensions (<a class="reference internal" href="#parallel-list-comprehensions"><span class="std std-ref">Parallel List Comprehensions</span></a>) and transform comprehensions (<a class="reference internal" href="#generalised-list-comprehensions"><span class="std std-ref">Generalised (SQL-like) List Comprehensions</span></a>) to work for any monad.</p> <p>Monad comprehensions support:</p> <ul> <li>
<p class="first">Bindings:</p> <pre data-language="haskell">[ x + y | x &lt;- Just 1, y &lt;- Just 2 ]
</pre> <p>Bindings are translated with the <code>(&gt;&gt;=)</code> and <code>return</code> functions to the usual do-notation:</p> <pre data-language="haskell">do x &lt;- Just 1
   y &lt;- Just 2
   return (x+y)
</pre> </li> <li>
<p class="first">Guards:</p> <pre data-language="haskell">[ x | x &lt;- [1..10], x &lt;= 5 ]
</pre> <p>Guards are translated with the <code>guard</code> function, which requires a <code>MonadPlus</code> instance:</p> <pre data-language="haskell">do x &lt;- [1..10]
   guard (x &lt;= 5)
   return x
</pre> </li> <li>
<p class="first">Transform statements (as with <a class="reference internal" href="#extension-TransformListComp"><code>TransformListComp</code></a>):</p> <pre data-language="haskell">[ x+y | x &lt;- [1..10], y &lt;- [1..x], then take 2 ]
</pre> <p>This translates to:</p> <pre data-language="haskell">do (x,y) &lt;- take 2 (do x &lt;- [1..10]
                       y &lt;- [1..x]
                       return (x,y))
   return (x+y)
</pre> </li> <li>
<p class="first">Group statements (as with <a class="reference internal" href="#extension-TransformListComp"><code>TransformListComp</code></a>):</p> <pre data-language="haskell">[ x | x &lt;- [1,1,2,2,3], then group by x using GHC.Exts.groupWith ]
[ x | x &lt;- [1,1,2,2,3], then group using myGroup ]
</pre> </li> <li>
<p class="first">Parallel statements (as with <a class="reference internal" href="#extension-ParallelListComp"><code>ParallelListComp</code></a>):</p> <pre data-language="haskell">[ (x+y) | x &lt;- [1..10]
        | y &lt;- [11..20]
        ]
</pre> <p>Parallel statements are translated using the <code>mzip</code> function, which requires a <code>MonadZip</code> instance defined in <a class="reference external" href="../libraries/base-4.13.0.0/control-monad-zip">Control.Monad.Zip</a>:</p> <pre data-language="haskell">do (x,y) &lt;- mzip (do x &lt;- [1..10]
                     return x)
                 (do y &lt;- [11..20]
                     return y)
   return (x+y)
</pre> </li> </ul> <p>All these features are enabled by default if the <a class="reference internal" href="#extension-MonadComprehensions"><code>MonadComprehensions</code></a> extension is enabled. The types and more detailed examples on how to use comprehensions are explained in the previous chapters <a class="reference internal" href="#generalised-list-comprehensions"><span class="std std-ref">Generalised (SQL-like) List Comprehensions</span></a> and <a class="reference internal" href="#parallel-list-comprehensions"><span class="std std-ref">Parallel List Comprehensions</span></a>. In general you just have to replace the type <code>[a]</code> with the type <code>Monad m =&gt; m a</code> for monad comprehensions.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Even though most of these examples are using the list monad, monad comprehensions work for any monad. The <code>base</code> package offers all necessary instances for lists, which make <a class="reference internal" href="#extension-MonadComprehensions"><code>MonadComprehensions</code></a> backward compatible to built-in, transform and parallel list comprehensions.</p> </div> <p>More formally, the desugaring is as follows. We write <code>D[ e | Q]</code> to mean the desugaring of the monad comprehension <code>[ e | Q]</code>:</p> <pre data-language="none">Expressions: e
Declarations: d
Lists of qualifiers: Q,R,S

-- Basic forms
D[ e | ]               = return e
D[ e | p &lt;- e, Q ]  = e &gt;&gt;= \p -&gt; D[ e | Q ]
D[ e | e, Q ]          = guard e &gt;&gt; \p -&gt; D[ e | Q ]
D[ e | let d, Q ]      = let d in D[ e | Q ]

-- Parallel comprehensions (iterate for multiple parallel branches)
D[ e | (Q | R), S ]    = mzip D[ Qv | Q ] D[ Rv | R ] &gt;&gt;= \(Qv,Rv) -&gt; D[ e | S ]

-- Transform comprehensions
D[ e | Q then f, R ]                  = f D[ Qv | Q ] &gt;&gt;= \Qv -&gt; D[ e | R ]

D[ e | Q then f by b, R ]             = f (\Qv -&gt; b) D[ Qv | Q ] &gt;&gt;= \Qv -&gt; D[ e | R ]

D[ e | Q then group using f, R ]      = f D[ Qv | Q ] &gt;&gt;= \ys -&gt;
                                        case (fmap selQv1 ys, ..., fmap selQvn ys) of
                                         Qv -&gt; D[ e | R ]

D[ e | Q then group by b using f, R ] = f (\Qv -&gt; b) D[ Qv | Q ] &gt;&gt;= \ys -&gt;
                                        case (fmap selQv1 ys, ..., fmap selQvn ys) of
                                           Qv -&gt; D[ e | R ]

where  Qv is the tuple of variables bound by Q (and used subsequently)
       selQvi is a selector mapping Qv to the ith component of Qv

Operator     Standard binding       Expected type
--------------------------------------------------------------------
return       GHC.Base               t1 -&gt; m t2
(&gt;&gt;=)        GHC.Base               m1 t1 -&gt; (t2 -&gt; m2 t3) -&gt; m3 t3
(&gt;&gt;)         GHC.Base               m1 t1 -&gt; m2 t2         -&gt; m3 t3
guard        Control.Monad          t1 -&gt; m t2
fmap         GHC.Base               forall a b. (a-&gt;b) -&gt; n a -&gt; n b
mzip         Control.Monad.Zip      forall a b. m a -&gt; m b -&gt; m (a,b)
</pre> <p>The comprehension should typecheck when its desugaring would typecheck, except that (as discussed in <a class="reference internal" href="#generalised-list-comprehensions"><span class="std std-ref">Generalised (SQL-like) List Comprehensions</span></a>) in the “then <code>f</code>” and “then group using <code>f</code>” clauses, when the “by <code>b</code>” qualifier is omitted, argument <code>f</code> should have a polymorphic type. In particular, “then <code>Data.List.sort</code>” and “then group using <code>Data.List.group</code>” are insufficiently polymorphic.</p> <p>Monad comprehensions support rebindable syntax (<a class="reference internal" href="#rebindable-syntax"><span class="std std-ref">Rebindable syntax and the implicit Prelude import</span></a>). Without rebindable syntax, the operators from the “standard binding” module are used; with rebindable syntax, the operators are looked up in the current lexical scope. For example, parallel comprehensions will be typechecked and desugared using whatever “<code>mzip</code>” is in scope.</p> <p>The rebindable operators must have the “Expected type” given in the table above. These types are surprisingly general. For example, you can use a bind operator with the type</p> <pre data-language="haskell">(&gt;&gt;=) :: T x y a -&gt; (a -&gt; T y z b) -&gt; T x z b
</pre> <p>In the case of transform comprehensions, notice that the groups are parameterised over some arbitrary type <code>n</code> (provided it has an <code>fmap</code>, as well as the comprehension being over an arbitrary monad.</p>   <h2 id="monadfail-desugaring">11.3.16. New monadic failure desugaring mechanism</h2> <dl class="extension" id="new-monadic-failure-desugaring-mechanism"> <dt id="extension-MonadFailDesugaring">
<code>MonadFailDesugaring</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Use the <code>MonadFail.fail</code> instead of the legacy <code>Monad.fail</code> function when desugaring refutable patterns in <code>do</code> blocks.</p> </dd>
</dl> <p>The <code>-XMonadFailDesugaring</code> extension switches the desugaring of <code>do</code>-blocks to use <code>MonadFail.fail</code> instead of <code>Monad.fail</code>.</p> <p>This extension is enabled by default since GHC 8.6.1, under the <a class="reference external" href="https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail">MonadFail Proposal (MFP)</a>.</p> <p>This extension is temporary, and will be deprecated in a future release.</p>   <h2 id="rebindable-syntax">11.3.17. Rebindable syntax and the implicit Prelude import</h2> <dl class="extension" id="rebindable-syntax-and-the-implicit-prelude-import"> <dt id="extension-NoImplicitPrelude">
<code>NoImplicitPrelude</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Don’t import <code>Prelude</code> by default.</p> </dd>
</dl> <p>GHC normally imports <code>Prelude.hi</code> files for you. If you’d rather it didn’t, then give it a <code>-XNoImplicitPrelude</code> option. The idea is that you can then import a Prelude of your own. (But don’t call it <code>Prelude</code>; the Haskell module namespace is flat, and you must not conflict with any Prelude module.)</p> <dl class="extension"> <dt id="extension-RebindableSyntax">
<code>RebindableSyntax</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-NoImplicitPrelude"><code>NoImplicitPrelude</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.0.1</td> </tr>  </table> <p>Enable rebinding of a variety of usually-built-in operations.</p> </dd>
</dl> <p>Suppose you are importing a Prelude of your own in order to define your own numeric class hierarchy. It completely defeats that purpose if the literal “1” means “<code>Prelude.fromInteger 1</code>”, which is what the Haskell Report specifies. So the <a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a> extension causes the following pieces of built-in syntax to refer to <em>whatever is in scope</em>, not the Prelude versions:</p> <ul class="simple"> <li>An integer literal <code>368</code> means “<code>fromInteger (368::Integer)</code>”, rather than “<code>Prelude.fromInteger (368::Integer)</code>”.</li> <li>Fractional literals are handled in just the same way, except that the translation is <code>fromRational (3.68::Rational)</code>.</li> <li>String literals are also handled the same way, except that the translation is <code>fromString ("368"::String)</code>.</li> <li>The equality test in an overloaded numeric pattern uses whatever <code>(==)</code> is in scope.</li> <li>The subtraction operation, and the greater-than-or-equal test, in <code>n+k</code> patterns use whatever <code>(-)</code> and <code>(&gt;=)</code> are in scope.</li> <li>Negation (e.g. “<code>- (f x)</code>”) means “<code>negate (f x)</code>”, both in numeric patterns, and expressions.</li> <li>Conditionals (e.g. “<code>if</code> e1 <code>then</code> e2 <code>else</code> e3”) means “<code>ifThenElse</code> e1 e2 e3”. However <code>case</code> expressions are unaffected.</li> <li>“Do” notation is translated using whatever functions <code>(&gt;&gt;=)</code>, <code>(&gt;&gt;)</code>, and <code>fail</code>, are in scope (not the Prelude versions). List comprehensions, <code>mdo</code> (<a class="reference internal" href="#recursive-do-notation"><span class="std std-ref">The recursive do-notation</span></a>), and parallel array comprehensions, are unaffected.</li> <li>Arrow notation (see <a class="reference internal" href="#arrow-notation"><span class="std std-ref">Arrow notation</span></a>) uses whatever <code>arr</code>, <code>(&gt;&gt;&gt;)</code>, <code>first</code>, <code>app</code>, <code>(|||)</code> and <code>loop</code> functions are in scope. But unlike the other constructs, the types of these functions must match the Prelude types very closely. Details are in flux; if you want to use this, ask!</li> <li>List notation, such as <code>[x,y]</code> or <code>[m..n]</code> can also be treated via rebindable syntax if you use <code>-XOverloadedLists</code>; see <a class="reference internal" href="#overloaded-lists"><span class="std std-ref">Overloaded lists</span></a>.</li> <li>An overloaded label “<code>#foo</code>” means “<code>fromLabel @"foo"</code>”, rather than “<code>GHC.OverloadedLabels.fromLabel @"foo"</code>” (see <a class="reference internal" href="#overloaded-labels"><span class="std std-ref">Overloaded labels</span></a>).</li> </ul> <p><a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a> implies <a class="reference internal" href="#extension-NoImplicitPrelude"><code>NoImplicitPrelude</code></a>.</p> <p>In all cases (apart from arrow notation), the static semantics should be that of the desugared form, even if that is a little unexpected. For example, the static semantics of the literal <code>368</code> is exactly that of <code>fromInteger (368::Integer)</code>; it’s fine for <code>fromInteger</code> to have any of the types:</p> <pre data-language="haskell">fromInteger :: Integer -&gt; Integer
fromInteger :: forall a. Foo a =&gt; Integer -&gt; a
fromInteger :: Num a =&gt; a -&gt; Integer
fromInteger :: Integer -&gt; Bool -&gt; Bool
</pre> <p>Be warned: this is an experimental facility, with fewer checks than usual. Use <code>-dcore-lint</code> to typecheck the desugared program. If Core Lint is happy you should be all right.</p>  <h3 id="things-unaffected-by-rebindablesyntax">11.3.17.1. Things unaffected by <a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a>
</h3> <p><a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a> does not apply to any code generated from a <code>deriving</code> clause or declaration. To see why, consider the following code:</p> <pre data-language="haskell">{-# LANGUAGE RebindableSyntax, OverloadedStrings #-}
newtype Text = Text String

fromString :: String -&gt; Text
fromString = Text

data Foo = Foo deriving Show
</pre> <p>This will generate code to the effect of:</p> <pre data-language="haskell">instance Show Foo where
  showsPrec _ Foo = showString "Foo"
</pre> <p>But because <a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a> and <a class="reference internal" href="#extension-OverloadedStrings"><code>OverloadedStrings</code></a> are enabled, the <code>"Foo"</code> string literal would now be of type <code>Text</code>, not <code>String</code>, which <code>showString</code> doesn’t accept! This causes the generated <code>Show</code> instance to fail to typecheck. It’s hard to imagine any scenario where it would be desirable have <a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a> behavior within derived code, so GHC simply ignores <a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a> entirely when checking derived code.</p>    <h2 id="id11">11.3.18. Postfix operators</h2> <dl class="extension" id="postfix-operators"> <dt id="extension-PostfixOperators">
<code>PostfixOperators</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10.1</td> </tr>  </table> <p>Allow the use of post-fix operators</p> </dd>
</dl> <p>The <a class="reference internal" href="#extension-PostfixOperators"><code>PostfixOperators</code></a> extension enables a small extension to the syntax of left operator sections, which allows you to define postfix operators. The extension is this: the left section</p> <pre data-language="haskell">(e !)
</pre> <p>is equivalent (from the point of view of both type checking and execution) to the expression</p> <pre data-language="haskell">((!) e)
</pre> <p>(for any expression <code>e</code> and operator <code>(!)</code>. The strict Haskell 98 interpretation is that the section is equivalent to</p> <pre data-language="haskell">(\y -&gt; (!) e y)
</pre> <p>That is, the operator must be a function of two arguments. GHC allows it to take only one argument, and that in turn allows you to write the function postfix.</p> <p>The extension does not extend to the left-hand side of function definitions; you must define such a function in prefix form.</p>   <h2 id="id12">11.3.19. Tuple sections</h2> <dl class="extension" id="tuple-sections"> <dt id="extension-TupleSections">
<code>TupleSections</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.12</td> </tr>  </table> <p>Allow the use of tuple section syntax</p> </dd>
</dl> <p>The <a class="reference internal" href="#extension-TupleSections"><code>TupleSections</code></a> extension enables partially applied tuple constructors. For example, the following program</p> <pre data-language="haskell">(, True)
</pre> <p>is considered to be an alternative notation for the more unwieldy alternative</p> <pre data-language="haskell">\x -&gt; (x, True)
</pre> <p>You can omit any combination of arguments to the tuple, as in the following</p> <pre data-language="haskell">(, "I", , , "Love", , 1337)
</pre> <p>which translates to</p> <pre data-language="haskell">\a b c d -&gt; (a, "I", b, c, "Love", d, 1337)
</pre> <p>If you have <a class="reference external" href="#unboxed-tuples">unboxed tuples</a> enabled, tuple sections will also be available for them, like so</p> <pre data-language="haskell">(# , True #)
</pre> <p>Because there is no unboxed unit tuple, the following expression</p> <pre data-language="haskell">(# #)
</pre> <p>continues to stand for the unboxed singleton tuple data constructor.</p>   <h2 id="id13">11.3.20. Lambda-case</h2> <dl class="extension" id="lambda-case"> <dt id="extension-LambdaCase">
<code>LambdaCase</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.6.1</td> </tr>  </table> <p>Allow the use of lambda-case syntax.</p> </dd>
</dl> <p>The <a class="reference internal" href="#extension-LambdaCase"><code>LambdaCase</code></a> extension enables expressions of the form</p> <pre data-language="haskell">\case { p1 -&gt; e1; ...; pN -&gt; eN }
</pre> <p>which is equivalent to</p> <pre data-language="haskell">\freshName -&gt; case freshName of { p1 -&gt; e1; ...; pN -&gt; eN }
</pre> <p>Note that <code>\case</code> starts a layout, so you can write</p> <pre data-language="haskell">\case
  p1 -&gt; e1
  ...
  pN -&gt; eN
</pre>   <h2 id="empty-case">11.3.21. Empty case alternatives</h2> <dl class="extension" id="empty-case-alternatives"> <dt id="extension-EmptyCase">
<code>EmptyCase</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8.1</td> </tr>  </table> <p>Allow empty case expressions.</p> </dd>
</dl> <p>The <a class="reference internal" href="#extension-EmptyCase"><code>EmptyCase</code></a> extension enables case expressions, or lambda-case expressions, that have no alternatives, thus:</p> <pre data-language="haskell">case e of { }   -- No alternatives
</pre> <p>or</p> <pre data-language="haskell">\case { }       -- -XLambdaCase is also required
</pre> <p>This can be useful when you know that the expression being scrutinised has no non-bottom values. For example:</p> <pre data-language="haskell">data Void
f :: Void -&gt; Int
f x = case x of { }
</pre> <p>With dependently-typed features it is more useful (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/2431">Issue #2431</a>). For example, consider these two candidate definitions of <code>absurd</code>:</p> <pre data-language="haskell">data a :~: b where
  Refl :: a :~: a

absurd :: True :~: False -&gt; a
absurd x = error "absurd"    -- (A)
absurd x = case x of {}      -- (B)
</pre> <p>We much prefer (B). Why? Because GHC can figure out that <code>(True :~: False)</code> is an empty type. So (B) has no partiality and GHC is able to compile with <a class="reference internal" href="using-warnings#ghc-flag--Wincomplete-patterns"><code>-Wincomplete-patterns</code></a> and <a class="reference internal" href="using-warnings#ghc-flag--Werror"><code>-Werror</code></a>. On the other hand (A) looks dangerous, and GHC doesn’t check to make sure that, in fact, the function can never get called.</p>   <h2 id="multi-way-if">11.3.22. Multi-way if-expressions</h2> <dl class="extension" id="multi-way-if-expressions"> <dt id="extension-MultiWayIf">
<code>MultiWayIf</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.6.1</td> </tr>  </table> <p>Allow the use of multi-way-<code>if</code> syntax.</p> </dd>
</dl> <p>With <a class="reference internal" href="#extension-MultiWayIf"><code>MultiWayIf</code></a> extension GHC accepts conditional expressions with multiple branches:</p> <pre data-language="haskell">if | guard1 -&gt; expr1
   | ...
   | guardN -&gt; exprN
</pre> <p>which is roughly equivalent to</p> <pre data-language="haskell">case () of
  _ | guard1 -&gt; expr1
  ...
  _ | guardN -&gt; exprN
</pre> <p>Multi-way if expressions introduce a new layout context. So the example above is equivalent to:</p> <pre data-language="haskell">if { | guard1 -&gt; expr1
   ; | ...
   ; | guardN -&gt; exprN
   }
</pre> <p>The following behaves as expected:</p> <pre data-language="haskell">if | guard1 -&gt; if | guard2 -&gt; expr2
                  | guard3 -&gt; expr3
   | guard4 -&gt; expr4
</pre> <p>because layout translates it as</p> <pre data-language="haskell">if { | guard1 -&gt; if { | guard2 -&gt; expr2
                    ; | guard3 -&gt; expr3
                    }
   ; | guard4 -&gt; expr4
   }
</pre> <p>Layout with multi-way if works in the same way as other layout contexts, except that the semi-colons between guards in a multi-way if are optional. So it is not necessary to line up all the guards at the same column; this is consistent with the way guards work in function definitions and case expressions.</p>   <h2 id="id14">11.3.23. Local Fixity Declarations</h2> <p id="local-fixity-declarations">A careful reading of the Haskell 98 Report reveals that fixity declarations (<code>infix</code>, <code>infixl</code>, and <code>infixr</code>) are permitted to appear inside local bindings such those introduced by <code>let</code> and <code>where</code>. However, the Haskell Report does not specify the semantics of such bindings very precisely.</p> <p>In GHC, a fixity declaration may accompany a local binding:</p> <pre data-language="haskell">let f = ...
    infixr 3 `f`
in
    ...
</pre> <p>and the fixity declaration applies wherever the binding is in scope. For example, in a <code>let</code>, it applies in the right-hand sides of other <code>let</code>-bindings and the body of the <code>let</code>C. Or, in recursive <code>do</code> expressions (<a class="reference internal" href="#recursive-do-notation"><span class="std std-ref">The recursive do-notation</span></a>), the local fixity declarations of a <code>let</code> statement scope over other statements in the group, just as the bound name does.</p> <p>Moreover, a local fixity declaration <em>must</em> accompany a local binding of that name: it is not possible to revise the fixity of name bound elsewhere, as in</p> <pre data-language="haskell">let infixr 9 $ in ...
</pre> <p>Because local fixity declarations are technically Haskell 98, no extension is necessary to enable them.</p>   <h2 id="package-imports">11.3.24. Import and export extensions</h2>  <h3 id="import-and-export-extensions">11.3.24.1. Hiding things the imported module doesn’t export</h3> <p>Technically in Haskell 2010 this is illegal:</p> <pre data-language="haskell">module A( f ) where
  f = True

module B where
  import A hiding( g )  -- A does not export g
  g = f
</pre> <p>The <code>import A hiding( g )</code> in module <code>B</code> is technically an error (<a class="reference external" href="http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1">Haskell Report, 5.3.1</a>) because <code>A</code> does not export <code>g</code>. However GHC allows it, in the interests of supporting backward compatibility; for example, a newer version of <code>A</code> might export <code>g</code>, and you want <code>B</code> to work in either case.</p> <p>The warning <a class="reference internal" href="using-warnings#ghc-flag--Wdodgy-imports"><code>-Wdodgy-imports</code></a>, which is off by default but included with <a class="reference internal" href="using-warnings#ghc-flag--W"><code>-W</code></a>, warns if you hide something that the imported module does not export.</p>   <h3 id="id15">11.3.24.2. Package-qualified imports</h3> <dl class="extension" id="package-qualified-imports"> <dt id="extension-PackageImports">
<code>PackageImports</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.10.1</td> </tr>  </table> <p>Allow the use of package-qualified <code>import</code> syntax.</p> </dd>
</dl> <p>With the <a class="reference internal" href="#extension-PackageImports"><code>PackageImports</code></a> extension, GHC allows import declarations to be qualified by the package name that the module is intended to be imported from. For example:</p> <pre data-language="haskell">import "network" Network.Socket
</pre> <p>would import the module <code>Network.Socket</code> from the package <code>network</code> (any version). This may be used to disambiguate an import when the same module is available from multiple packages, or is present in both the current package being built and an external package.</p> <p>The special package name <code>this</code> can be used to refer to the current package being built.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">You probably don’t need to use this feature, it was added mainly so that we can build backwards-compatible versions of packages when APIs change. It can lead to fragile dependencies in the common case: modules occasionally move from one package to another, rendering any package-qualified imports broken. See also <a class="reference internal" href="packages#package-thinning-and-renaming"><span class="std std-ref">Thinning and renaming modules</span></a> for an alternative way of disambiguating between module names.</p> </div>   <h3 id="safe-imports-ext">11.3.24.3. Safe imports</h3> <dl class="extension" id="safe-imports"> <dt>
<code>Safe</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.2.1</td> </tr>  </table> <p>Declare the Safe Haskell state of the current module.</p> </dd>
</dl> <dl class="extension"> <dt>
<code>Trustworthy</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.2.1</td> </tr>  </table> <p>Declare the Safe Haskell state of the current module.</p> </dd>
</dl> <dl class="extension"> <dt>
<code>Unsafe</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.4.1</td> </tr>  </table> <p>Declare the Safe Haskell state of the current module.</p> </dd>
</dl> <p>With the <a class="reference internal" href="safe_haskell#extension-Safe"><code>Safe</code></a>, <a class="reference internal" href="safe_haskell#extension-Trustworthy"><code>Trustworthy</code></a> and <a class="reference internal" href="safe_haskell#extension-Unsafe"><code>Unsafe</code></a> language flags, GHC extends the import declaration syntax to take an optional <code>safe</code> keyword after the <code>import</code> keyword. This feature is part of the Safe Haskell GHC extension. For example:</p> <pre data-language="haskell">import safe qualified Network.Socket as NS
</pre> <p>would import the module <code>Network.Socket</code> with compilation only succeeding if <code>Network.Socket</code> can be safely imported. For a description of when a import is considered safe see <a class="reference internal" href="safe_haskell#safe-haskell"><span class="std std-ref">Safe Haskell</span></a>.</p>   <h3 id="explicit-namespaces">11.3.24.4. Explicit namespaces in import/export</h3> <dl class="extension" id="explicit-namespaces-in-import-export"> <dt id="extension-ExplicitNamespaces">
<code>ExplicitNamespaces</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.6.1</td> </tr>  </table> <p>Enable use of explicit namespaces in module export lists.</p> </dd>
</dl> <p>In an import or export list, such as</p> <pre data-language="haskell">module M( f, (++) ) where ...
  import N( f, (++) )
  ...
</pre> <p>the entities <code>f</code> and <code>(++)</code> are <em>values</em>. However, with type operators (<a class="reference internal" href="#type-operators"><span class="std std-ref">Type operators</span></a>) it becomes possible to declare <code>(++)</code> as a <em>type constructor</em>. In that case, how would you export or import it?</p> <p>The <a class="reference internal" href="#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a> extension allows you to prefix the name of a type constructor in an import or export list with “<code>type</code>” to disambiguate this case, thus:</p> <pre data-language="haskell">module M( f, type (++) ) where ...
  import N( f, type (++) )
  ...
module N( f, type (++) ) where
  data family a ++ b = L a | R b
</pre> <p>The extension <a class="reference internal" href="#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a> is implied by <a class="reference internal" href="#extension-TypeOperators"><code>TypeOperators</code></a> and (for some reason) by <a class="reference internal" href="#extension-TypeFamilies"><code>TypeFamilies</code></a>.</p> <p>In addition, with <a class="reference internal" href="#extension-PatternSynonyms"><code>PatternSynonyms</code></a> you can prefix the name of a data constructor in an import or export list with the keyword <code>pattern</code>, to allow the import or export of a data constructor without its parent type constructor (see <a class="reference internal" href="#patsyn-impexp"><span class="std std-ref">Import and export of pattern synonyms</span></a>).</p>    <h2 id="block-arguments">11.3.25. More liberal syntax for function arguments</h2> <dl class="extension" id="more-liberal-syntax-for-function-arguments"> <dt id="extension-BlockArguments">
<code>BlockArguments</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.6.1</td> </tr>  </table> <p>Allow <code>do</code> expressions, lambda expressions, etc. to be directly used as a function argument.</p> </dd>
</dl> <p>In Haskell 2010, certain kinds of expressions can be used without parentheses as an argument to an operator, but not as an argument to a function. They include <code>do</code>, lambda, <code>if</code>, <code>case</code>, and <code>let</code> expressions. Some GHC extensions also define language constructs of this type: <code>mdo</code> (<a class="reference internal" href="#recursive-do-notation"><span class="std std-ref">The recursive do-notation</span></a>), <code>\case</code> (<a class="reference internal" href="#lambda-case"><span class="std std-ref">Lambda-case</span></a>), and <code>proc</code> (<a class="reference internal" href="#arrow-notation"><span class="std std-ref">Arrow notation</span></a>).</p> <p>The <a class="reference internal" href="#extension-BlockArguments"><code>BlockArguments</code></a> extension allows these constructs to be directly used as a function argument. For example:</p> <pre data-language="haskell">when (x &gt; 0) do
  print x
  exitFailure
</pre> <p>will be parsed as:</p> <pre data-language="haskell">when (x &gt; 0) (do
  print x
  exitFailure)
</pre> <p>and</p> <pre data-language="haskell">withForeignPtr fptr \ptr -&gt; c_memcpy buf ptr size
</pre> <p>will be parsed as:</p> <pre data-language="haskell">withForeignPtr fptr (\ptr -&gt; c_memcpy buf ptr size)
</pre>  <h3 id="changes-to-the-grammar">11.3.25.1. Changes to the grammar</h3> <p>The Haskell report <a class="reference external" href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003">defines</a> the <code>lexp</code> nonterminal thus (<code>*</code> indicates a rule of interest):</p> <pre data-language="haskell">lexp  →  \ apat1 … apatn -&gt; exp            (lambda abstraction, n ≥ 1)  *
      |  let decls in exp                  (let expression)             *
      |  if exp [;] then exp [;] else exp  (conditional)                *
      |  case exp of { alts }              (case expression)            *
      |  do { stmts }                      (do expression)              *
      |  fexp

fexp  →  [fexp] aexp                       (function application)

aexp  →  qvar                              (variable)
      |  gcon                              (general constructor)
      |  literal
      |  ( exp )                           (parenthesized expression)
      |  qcon { fbind1 … fbindn }          (labeled construction)
      |  aexp { fbind1 … fbindn }          (labelled update)
      |  …
</pre> <p>The <a class="reference internal" href="#extension-BlockArguments"><code>BlockArguments</code></a> extension moves these production rules under <code>aexp</code>:</p> <pre data-language="haskell">lexp  →  fexp

fexp  →  [fexp] aexp                       (function application)

aexp  →  qvar                              (variable)
      |  gcon                              (general constructor)
      |  literal
      |  ( exp )                           (parenthesized expression)
      |  qcon { fbind1 … fbindn }          (labeled construction)
      |  aexp { fbind1 … fbindn }          (labelled update)
      |  \ apat1 … apatn -&gt; exp            (lambda abstraction, n ≥ 1)  *
      |  let decls in exp                  (let expression)             *
      |  if exp [;] then exp [;] else exp  (conditional)                *
      |  case exp of { alts }              (case expression)            *
      |  do { stmts }                      (do expression)              *
      |  …
</pre> <p>Now the <code>lexp</code> nonterminal is redundant and can be dropped from the grammar.</p> <p>Note that this change relies on an existing meta-rule to resolve ambiguities:</p>  The grammar is ambiguous regarding the extent of lambda abstractions, let expressions, and conditionals. The ambiguity is resolved by the meta-rule that each of these constructs extends as far to the right as possible. <p>For example, <code>f \a -&gt; a b</code> will be parsed as <code>f (\a -&gt; a b)</code>, not as <code>f
(\a -&gt; a) b</code>.</p>    <h2 id="syntax-stolen">11.3.26. Summary of stolen syntax</h2> <p id="summary-of-stolen-syntax">Turning on an option that enables special syntax <em>might</em> cause working Haskell 98 code to fail to compile, perhaps because it uses a variable name which has become a reserved word. This section lists the syntax that is “stolen” by language extensions. We use notation and nonterminal names from the Haskell 98 lexical syntax (see the Haskell 98 Report). We only list syntax changes here that might affect existing working programs (i.e. “stolen” syntax). Many of these extensions will also enable new context-free syntax, but in all cases programs written to use the new syntax would not be compilable without the option enabled.</p> <p>There are two classes of special syntax:</p> <ul class="simple"> <li>New reserved words and symbols: character sequences which are no longer available for use as identifiers in the program.</li> <li>Other special syntax: sequences of characters that have a different meaning when this particular option is turned on.</li> </ul> <p>The following syntax is stolen:</p> <dl class="docutils"> <dt>
<code>forall</code> </dt> <dd>
<p class="first last" id="index-6">Stolen (in types) by default (see <a class="reference internal" href="bugs#infelicities-lexical"><span class="std std-ref">Lexical syntax</span></a>). <code>forall</code> is a reserved keyword and never a type variable, in accordance with <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0043-forall-keyword.rst">GHC Proposal #43</a>.</p> </dd> <dt>
<code>mdo</code> </dt> <dd>
<p class="first last" id="index-7">Stolen by: <a class="reference internal" href="#extension-RecursiveDo"><code>RecursiveDo</code></a></p> </dd> <dt>
<code>foreign</code> </dt> <dd>
<p class="first last" id="index-8">Stolen by: <a class="reference internal" href="ffi-chap#extension-ForeignFunctionInterface"><code>ForeignFunctionInterface</code></a></p> </dd> <dt>
<code>rec, proc, -&lt;, &gt;-, -&lt;&lt;, &gt;&gt;-, (|, |)</code> </dt> <dd>
<p class="first last" id="index-9">Stolen by: <a class="reference internal" href="#extension-Arrows"><code>Arrows</code></a></p> </dd> <dt>
<code>?varid</code> </dt> <dd>
<p class="first last" id="index-10">Stolen by: <a class="reference internal" href="#extension-ImplicitParams"><code>ImplicitParams</code></a></p> </dd> <dt>
<code>[|, [e|, [p|, [d|, [t|, [||, [e||</code> </dt> <dd>
<p class="first last" id="index-11">Stolen by: <a class="reference internal" href="#extension-QuasiQuotes"><code>QuasiQuotes</code></a>. Moreover, this introduces an ambiguity with list comprehension syntax. See the <a class="reference internal" href="#quasi-quotes-list-comprehension-ambiguity"><span class="std std-ref">discussion on quasi-quoting</span></a> for details.</p> </dd> <dt>
<code>$(, $$(, $varid, $$varid</code> </dt> <dd>
<p class="first last" id="index-12">Stolen by: <a class="reference internal" href="#extension-TemplateHaskell"><code>TemplateHaskell</code></a></p> </dd> <dt>
<code>[varid|</code> </dt> <dd>
<p class="first last" id="index-13">Stolen by: <a class="reference internal" href="#extension-QuasiQuotes"><code>QuasiQuotes</code></a></p> </dd> <dt>
<code>⟨varid⟩, #⟨char⟩, #, ⟨string⟩, #, ⟨integer⟩, #, ⟨float⟩, #, ⟨float⟩, ##</code> </dt> <dd>Stolen by: <a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a>
</dd> <dt>
<code>(#, #)</code> </dt> <dd>Stolen by: <a class="reference internal" href="#extension-UnboxedTuples"><code>UnboxedTuples</code></a>
</dd> <dt>
<code>⟨varid⟩, !, ⟨varid⟩</code> </dt> <dd>Stolen by: <a class="reference internal" href="#extension-BangPatterns"><code>BangPatterns</code></a>
</dd> <dt>
<code>pattern</code> </dt> <dd>Stolen by: <a class="reference internal" href="#extension-PatternSynonyms"><code>PatternSynonyms</code></a>
</dd> <dt>
<code>static</code> </dt> <dd>Stolen by: <a class="reference internal" href="#extension-StaticPointers"><code>StaticPointers</code></a>
</dd> </dl>    <h1 id="data-type-extensions">11.4. Extensions to data types and type synonyms</h1>  <h2 id="nullary-types">11.4.1. Data types with no constructors</h2> <dl class="extension" id="extensions-to-data-types-and-type-synonyms"> <dt id="extension-EmptyDataDecls">
<code>EmptyDataDecls</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow definition of empty <code>data</code> types.</p> </dd>
</dl> <p>With the <a class="reference internal" href="#extension-EmptyDataDecls"><code>EmptyDataDecls</code></a> extension, GHC lets you declare a data type with no constructors.</p> <p>You only need to enable this extension if the language you’re using is Haskell 98, in which a data type must have at least one constructor. Haskell 2010 relaxed this rule to allow data types with no constructors, and thus <a class="reference internal" href="#extension-EmptyDataDecls"><code>EmptyDataDecls</code></a> is enabled by default when the language is Haskell 2010.</p> <p>For example:</p> <pre data-language="haskell">data S      -- S :: Type
data T a    -- T :: Type -&gt; Type
</pre> <p>Syntactically, the declaration lacks the “= constrs” part. The type can be parameterised over types of any kind, but if the kind is not <code>Type</code> then an explicit kind annotation must be used (see <a class="reference internal" href="#kinding"><span class="std std-ref">Explicitly-kinded quantification</span></a>).</p> <p>Such data types have only one value, namely bottom. Nevertheless, they can be useful when defining “phantom types”.</p> <p>In conjunction with the <a class="reference internal" href="#ghc-flag--XEmptyDataDeriving"><code>-XEmptyDataDeriving</code></a> extension, empty data declarations can also derive instances of standard type classes (see <a class="reference internal" href="#empty-data-deriving"><span class="std std-ref">Deriving instances for empty data types</span></a>).</p>   <h2 id="datatype-contexts">11.4.2. Data type contexts</h2> <dl class="extension" id="data-type-contexts"> <dt id="extension-DatatypeContexts">
<code>DatatypeContexts</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.0.1</td> </tr>  </table> <p>Allow contexts on <code>data</code> types.</p> </dd>
</dl> <p>Haskell allows datatypes to be given contexts, e.g.</p> <pre data-language="haskell">data Eq a =&gt; Set a = NilSet | ConsSet a (Set a)
</pre> <p>give constructors with types:</p> <pre data-language="haskell">NilSet :: Set a
ConsSet :: Eq a =&gt; a -&gt; Set a -&gt; Set a
</pre> <p>This is widely considered a misfeature, and is going to be removed from the language. In GHC, it is controlled by the deprecated extension <code>DatatypeContexts</code>.</p>   <h2 id="infix-tycons">11.4.3. Infix type constructors, classes, and type variables</h2> <p id="infix-type-constructors-classes-and-type-variables">GHC allows type constructors, classes, and type variables to be operators, and to be written infix, very much like expressions. More specifically:</p> <ul> <li>A type constructor or class can be any non-reserved operator. Symbols used in types are always like capitalized identifiers; they are never variables. Note that this is different from the lexical syntax of data constructors, which are required to begin with a <code>:</code>. </li> <li>
<p class="first">Data type and type-synonym declarations can be written infix, parenthesised if you want further arguments. E.g.</p> <pre data-language="haskell">data a :*: b = Foo a b
type a :+: b = Either a b
class a :=: b where ...

data (a :**: b) x = Baz a b x
type (a :++: b) y = Either (a,b) y
</pre> </li> <li>
<p class="first">Types, and class constraints, can be written infix. For example</p> <pre data-language="haskell">x :: Int :*: Bool
f :: (a :=: b) =&gt; a -&gt; b
</pre> </li> <li>Back-quotes work as for expressions, both for type constructors and type variables; e.g. <code>Int `Either` Bool</code>, or <code>Int `a` Bool</code>. Similarly, parentheses work the same; e.g. <code>(:*:) Int Bool</code>. </li> <li>
<p class="first">Fixities may be declared for type constructors, or classes, just as for data constructors. However, one cannot distinguish between the two in a fixity declaration; a fixity declaration sets the fixity for a data constructor and the corresponding type constructor. For example:</p> <pre data-language="haskell">infixl 7 T, :*:
</pre> <p>sets the fixity for both type constructor <code>T</code> and data constructor <code>T</code>, and similarly for <code>:*:</code>. <code>Int `a` Bool</code>.</p> </li> <li>The function arrow <code>-&gt;</code> is <code>infixr</code> with fixity -1. </li> </ul>   <h2 id="id16">11.4.4. Type operators</h2> <dl class="extension" id="type-operators"> <dt id="extension-TypeOperators">
<code>TypeOperators</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow the use and definition of types with operator names.</p> </dd>
</dl> <p>In types, an operator symbol like <code>(+)</code> is normally treated as a type <em>variable</em>, just like <code>a</code>. Thus in Haskell 98 you can say</p> <pre data-language="haskell">type T (+) = ((+), (+))
-- Just like: type T a = (a,a)

f :: T Int -&gt; Int
f (x,y)= x
</pre> <p>As you can see, using operators in this way is not very useful, and Haskell 98 does not even allow you to write them infix.</p> <p>The language <a class="reference internal" href="#extension-TypeOperators"><code>TypeOperators</code></a> changes this behaviour:</p> <ul> <li>Operator symbols become type <em>constructors</em> rather than type <em>variables</em>. </li> <li>
<p class="first">Operator symbols in types can be written infix, both in definitions and uses. For example:</p> <pre data-language="haskell">data a + b = Plus a b
type Foo = Int + Bool
</pre> </li> <li>
<p class="first">There is now some potential ambiguity in import and export lists; for example if you write <code>import M( (+) )</code> do you mean the <em>function</em> <code>(+)</code> or the <em>type constructor</em> <code>(+)</code>? The default is the former, but with <a class="reference internal" href="#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a> (which is implied by <a class="reference internal" href="#extension-TypeOperators"><code>TypeOperators</code></a>) GHC allows you to specify the latter by preceding it with the keyword <code>type</code>, thus:</p> <pre data-language="haskell">import M( type (+) )
</pre> <p>See <a class="reference internal" href="#explicit-namespaces"><span class="std std-ref">Explicit namespaces in import/export</span></a>.</p> </li> <li>The fixity of a type operator may be set using the usual fixity declarations but, as in <a class="reference internal" href="#infix-tycons"><span class="std std-ref">Infix type constructors, classes, and type variables</span></a>, the function and type constructor share a single fixity. </li> </ul>   <h2 id="type-synonyms">11.4.5. Liberalised type synonyms</h2> <dl class="extension" id="liberalised-type-synonyms"> <dt id="extension-LiberalTypeSynonyms">
<code>LiberalTypeSynonyms</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Relax many of the Haskell 98 rules on type synonym definitions.</p> </dd>
</dl> <p>Type synonyms are like macros at the type level, but Haskell 98 imposes many rules on individual synonym declarations. With the <a class="reference internal" href="#extension-LiberalTypeSynonyms"><code>LiberalTypeSynonyms</code></a> extension, GHC does validity checking on types <em>only after expanding type synonyms</em>. That means that GHC can be very much more liberal about type synonyms than Haskell 98.</p> <ul> <li>
<p class="first">You can write a <code>forall</code> (including overloading) in a type synonym, thus:</p> <pre data-language="haskell">type Discard a = forall b. Show b =&gt; a -&gt; b -&gt; (a, String)

f :: Discard a
f x y = (x, show y)

g :: Discard Int -&gt; (Int,String)    -- A rank-2 type
g f = f 3 True
</pre> </li> <li>
<p class="first">If you also use <a class="reference internal" href="#extension-UnboxedTuples"><code>UnboxedTuples</code></a>, you can write an unboxed tuple in a type synonym:</p> <pre data-language="haskell">type Pr = (# Int, Int #)

h :: Int -&gt; Pr
h x = (# x, x #)
</pre> </li> <li>
<p class="first">You can apply a type synonym to a forall type:</p> <pre data-language="haskell">type Foo a = a -&gt; a -&gt; Bool

f :: Foo (forall b. b-&gt;b)
</pre> <p>After expanding the synonym, <code>f</code> has the legal (in GHC) type:</p> <pre data-language="haskell">f :: (forall b. b-&gt;b) -&gt; (forall b. b-&gt;b) -&gt; Bool
</pre> </li> <li>
<p class="first">You can apply a type synonym to a partially applied type synonym:</p> <pre data-language="haskell">type Generic i o = forall x. i x -&gt; o x
type Id x = x

foo :: Generic Id []
</pre> <p>After expanding the synonym, <code>foo</code> has the legal (in GHC) type:</p> <pre data-language="haskell">foo :: forall x. x -&gt; [x]
</pre> </li> </ul> <p>GHC currently does kind checking before expanding synonyms (though even that could be changed).</p> <p>After expanding type synonyms, GHC does validity checking on types, looking for the following malformedness which isn’t detected simply by kind checking:</p> <ul class="simple"> <li>Type constructor applied to a type involving for-alls (if <a class="reference internal" href="#extension-ImpredicativeTypes"><code>ImpredicativeTypes</code></a> is off)</li> <li>Partially-applied type synonym.</li> </ul> <p>So, for example, this will be rejected:</p> <pre data-language="haskell">type Pr = forall a. a

h :: [Pr]
h = ...
</pre> <p>because GHC does not allow type constructors applied to for-all types.</p>   <h2 id="existential-quantification">11.4.6. Existentially quantified data constructors</h2> <dl class="extension" id="existentially-quantified-data-constructors"> <dt id="extension-ExistentialQuantification">
<code>ExistentialQuantification</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow existentially quantified type variables in types.</p> </dd>
</dl> <p>The idea of using existential quantification in data type declarations was suggested by Perry, and implemented in Hope+ (Nigel Perry, <em>The Implementation of Practical Functional Programming Languages</em>, PhD Thesis, University of London, 1991). It was later formalised by Laufer and Odersky (<em>Polymorphic type inference and abstract data types</em>, TOPLAS, 16(5), pp. 1411-1430, 1994). It’s been in Lennart Augustsson’s <code>hbc</code> Haskell compiler for several years, and proved very useful. Here’s the idea. Consider the declaration:</p> <pre data-language="haskell">data Foo = forall a. MkFoo a (a -&gt; Bool)
         | Nil
</pre> <p>The data type <code>Foo</code> has two constructors with types:</p> <pre data-language="haskell">MkFoo :: forall a. a -&gt; (a -&gt; Bool) -&gt; Foo
Nil   :: Foo
</pre> <p>Notice that the type variable <code>a</code> in the type of <code>MkFoo</code> does not appear in the data type itself, which is plain <code>Foo</code>. For example, the following expression is fine:</p> <pre data-language="haskell">[MkFoo 3 even, MkFoo 'c' isUpper] :: [Foo]
</pre> <p>Here, <code>(MkFoo 3 even)</code> packages an integer with a function <code>even</code> that maps an integer to <code>Bool</code>; and <code>MkFoo 'c'
isUpper</code> packages a character with a compatible function. These two things are each of type <code>Foo</code> and can be put in a list.</p> <p>What can we do with a value of type <code>Foo</code>? In particular, what happens when we pattern-match on <code>MkFoo</code>?</p> <pre data-language="haskell">f (MkFoo val fn) = ???
</pre> <p>Since all we know about <code>val</code> and <code>fn</code> is that they are compatible, the only (useful) thing we can do with them is to apply <code>fn</code> to <code>val</code> to get a boolean. For example:</p> <pre data-language="haskell">f :: Foo -&gt; Bool
f (MkFoo val fn) = fn val
</pre> <p>What this allows us to do is to package heterogeneous values together with a bunch of functions that manipulate them, and then treat that collection of packages in a uniform manner. You can express quite a bit of object-oriented-like programming this way.</p>  <h3 id="existential">11.4.6.1. Why existential?</h3> <p id="why-existential">What has this to do with <em>existential</em> quantification? Simply that <code>MkFoo</code> has the (nearly) isomorphic type</p> <pre data-language="haskell">MkFoo :: (exists a . (a, a -&gt; Bool)) -&gt; Foo
</pre> <p>But Haskell programmers can safely think of the ordinary <em>universally</em> quantified type given above, thereby avoiding adding a new existential quantification construct.</p>   <h3 id="existential-with-context">11.4.6.2. Existentials and type classes</h3> <p id="existentials-and-type-classes">An easy extension is to allow arbitrary contexts before the constructor. For example:</p> <pre data-language="haskell">data Baz = forall a. Eq a =&gt; Baz1 a a
         | forall b. Show b =&gt; Baz2 b (b -&gt; b)
</pre> <p>The two constructors have the types you’d expect:</p> <pre data-language="haskell">Baz1 :: forall a. Eq a =&gt; a -&gt; a -&gt; Baz
Baz2 :: forall b. Show b =&gt; b -&gt; (b -&gt; b) -&gt; Baz
</pre> <p>But when pattern matching on <code>Baz1</code> the matched values can be compared for equality, and when pattern matching on <code>Baz2</code> the first matched value can be converted to a string (as well as applying the function to it). So this program is legal:</p> <pre data-language="haskell">f :: Baz -&gt; String
f (Baz1 p q) | p == q    = "Yes"
             | otherwise = "No"
f (Baz2 v fn)            = show (fn v)
</pre> <p>Operationally, in a dictionary-passing implementation, the constructors <code>Baz1</code> and <code>Baz2</code> must store the dictionaries for <code>Eq</code> and <code>Show</code> respectively, and extract it on pattern matching.</p>   <h3 id="existential-records">11.4.6.3. Record Constructors</h3> <p id="record-constructors">GHC allows existentials to be used with records syntax as well. For example:</p> <pre data-language="haskell">data Counter a = forall self. NewCounter
    { _this    :: self
    , _inc     :: self -&gt; self
    , _display :: self -&gt; IO ()
    , tag      :: a
    }
</pre> <p>Here <code>tag</code> is a public field, with a well-typed selector function <code>tag :: Counter a -&gt; a</code>. The <code>self</code> type is hidden from the outside; any attempt to apply <code>_this</code>, <code>_inc</code> or <code>_display</code> as functions will raise a compile-time error. In other words, <em>GHC defines a record selector function only for fields whose type does not mention the existentially-quantified variables</em>. (This example used an underscore in the fields for which record selectors will not be defined, but that is only programming style; GHC ignores them.)</p> <p>To make use of these hidden fields, we need to create some helper functions:</p> <pre data-language="haskell">inc :: Counter a -&gt; Counter a
inc (NewCounter x i d t) = NewCounter
    { _this = i x, _inc = i, _display = d, tag = t }

display :: Counter a -&gt; IO ()
display NewCounter{ _this = x, _display = d } = d x
</pre> <p>Now we can define counters with different underlying implementations:</p> <pre data-language="haskell">counterA :: Counter String
counterA = NewCounter
    { _this = 0, _inc = (1+), _display = print, tag = "A" }

counterB :: Counter String
counterB = NewCounter
    { _this = "", _inc = ('#':), _display = putStrLn, tag = "B" }

main = do
    display (inc counterA)         -- prints "1"
    display (inc (inc counterB))   -- prints "##"
</pre> <p>Record update syntax is supported for existentials (and GADTs):</p> <pre data-language="haskell">setTag :: Counter a -&gt; a -&gt; Counter a
setTag obj t = obj{ tag = t }
</pre> <p>The rule for record update is this:</p>  the types of the updated fields may mention only the universally-quantified type variables of the data constructor. For GADTs, the field may mention only types that appear as a simple type-variable argument in the constructor’s result type. <p>For example:</p> <pre data-language="haskell">data T a b where { T1 { f1::a, f2::b, f3::(b,c) } :: T a b } -- c is existential
upd1 t x = t { f1=x }   -- OK:   upd1 :: T a b -&gt; a' -&gt; T a' b
upd2 t x = t { f3=x }   -- BAD   (f3's type mentions c, which is
                        --        existentially quantified)

data G a b where { G1 { g1::a, g2::c } :: G a [c] }
upd3 g x = g { g1=x }   -- OK:   upd3 :: G a b -&gt; c -&gt; G c b
upd4 g x = g { g2=x }   -- BAD (f2's type mentions c, which is not a simple
                        --      type-variable argument in G1's result type)
</pre>   <h3 id="restrictions">11.4.6.4. Restrictions</h3> <p>There are several restrictions on the ways in which existentially-quantified constructors can be used.</p> <ul> <li>
<p class="first">When pattern matching, each pattern match introduces a new, distinct, type for each existential type variable. These types cannot be unified with any other type, nor can they escape from the scope of the pattern match. For example, these fragments are incorrect:</p> <pre data-language="haskell">f1 (MkFoo a f) = a
</pre> <p>Here, the type bound by <code>MkFoo</code> “escapes”, because <code>a</code> is the result of <code>f1</code>. One way to see why this is wrong is to ask what type <code>f1</code> has:</p> <pre data-language="haskell">f1 :: Foo -&gt; a             -- Weird!
</pre> <p>What is this “<code>a</code>” in the result type? Clearly we don’t mean this:</p> <pre data-language="haskell">f1 :: forall a. Foo -&gt; a   -- Wrong!
</pre> <p>The original program is just plain wrong. Here’s another sort of error</p> <pre data-language="haskell">f2 (Baz1 a b) (Baz1 p q) = a==q
</pre> <p>It’s ok to say <code>a==b</code> or <code>p==q</code>, but <code>a==q</code> is wrong because it equates the two distinct types arising from the two <code>Baz1</code> constructors.</p> </li> <li>
<p class="first">You can’t pattern-match on an existentially quantified constructor in a <code>let</code> or <code>where</code> group of bindings. So this is illegal:</p> <pre data-language="haskell">f3 x = a==b where { Baz1 a b = x }
</pre> <p>Instead, use a <code>case</code> expression:</p> <pre data-language="haskell">f3 x = case x of Baz1 a b -&gt; a==b
</pre> <p>In general, you can only pattern-match on an existentially-quantified constructor in a <code>case</code> expression or in the patterns of a function definition. The reason for this restriction is really an implementation one. Type-checking binding groups is already a nightmare without existentials complicating the picture. Also an existential pattern binding at the top level of a module doesn’t make sense, because it’s not clear how to prevent the existentially-quantified type “escaping”. So for now, there’s a simple-to-state restriction. We’ll see how annoying it is.</p> </li> <li>
<p class="first">You can’t use existential quantification for <code>newtype</code> declarations. So this is illegal:</p> <pre data-language="haskell">newtype T = forall a. Ord a =&gt; MkT a
</pre> <p>Reason: a value of type <code>T</code> must be represented as a pair of a dictionary for <code>Ord t</code> and a value of type <code>t</code>. That contradicts the idea that <code>newtype</code> should have no concrete representation. You can get just the same efficiency and effect by using <code>data</code> instead of <code>newtype</code>. If there is no overloading involved, then there is more of a case for allowing an existentially-quantified <code>newtype</code>, because the <code>data</code> version does carry an implementation cost, but single-field existentially quantified constructors aren’t much use. So the simple restriction (no existential stuff on <code>newtype</code>) stands, unless there are convincing reasons to change it.</p> </li> <li>
<p class="first">You can’t use <code>deriving</code> to define instances of a data type with existentially quantified data constructors. Reason: in most cases it would not make sense. For example:;</p> <pre data-language="haskell">data T = forall a. MkT [a] deriving( Eq )
</pre> <p>To derive <code>Eq</code> in the standard way we would need to have equality between the single component of two <code>MkT</code> constructors:</p> <pre data-language="haskell">instance Eq T where
  (MkT a) == (MkT b) = ???
</pre> <p>But <code>a</code> and <code>b</code> have distinct types, and so can’t be compared. It’s just about possible to imagine examples in which the derived instance would make sense, but it seems altogether simpler simply to prohibit such declarations. Define your own instances!</p> </li> </ul>    <h2 id="gadt-style">11.4.7. Declaring data types with explicit constructor signatures</h2> <dl class="extension" id="declaring-data-types-with-explicit-constructor-signatures"> <dt id="extension-GADTSyntax">
<code>GADTSyntax</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.2.1</td> </tr>  </table> <p>Allow the use of GADT syntax in data type definitions (but not GADTs themselves; for this see <a class="reference internal" href="#extension-GADTs"><code>GADTs</code></a>)</p> </dd>
</dl> <p>When the <code>GADTSyntax</code> extension is enabled, GHC allows you to declare an algebraic data type by giving the type signatures of constructors explicitly. For example:</p> <pre data-language="haskell">data Maybe a where
    Nothing :: Maybe a
    Just    :: a -&gt; Maybe a
</pre> <p>The form is called a “GADT-style declaration” because Generalised Algebraic Data Types, described in <a class="reference internal" href="#gadt"><span class="std std-ref">Generalised Algebraic Data Types (GADTs)</span></a>, can only be declared using this form.</p> <p>Notice that GADT-style syntax generalises existential types (<a class="reference internal" href="#existential-quantification"><span class="std std-ref">Existentially quantified data constructors</span></a>). For example, these two declarations are equivalent:</p> <pre data-language="haskell">data Foo = forall a. MkFoo a (a -&gt; Bool)
data Foo' where { MKFoo :: a -&gt; (a-&gt;Bool) -&gt; Foo' }
</pre> <p>Any data type that can be declared in standard Haskell 98 syntax can also be declared using GADT-style syntax. The choice is largely stylistic, but GADT-style declarations differ in one important respect: they treat class constraints on the data constructors differently. Specifically, if the constructor is given a type-class context, that context is made available by pattern matching. For example:</p> <pre data-language="haskell">data Set a where
  MkSet :: Eq a =&gt; [a] -&gt; Set a

makeSet :: Eq a =&gt; [a] -&gt; Set a
makeSet xs = MkSet (nub xs)

insert :: a -&gt; Set a -&gt; Set a
insert a (MkSet as) | a `elem` as = MkSet as
                    | otherwise   = MkSet (a:as)
</pre> <p>A use of <code>MkSet</code> as a constructor (e.g. in the definition of <code>makeSet</code>) gives rise to a <code>(Eq a)</code> constraint, as you would expect. The new feature is that pattern-matching on <code>MkSet</code> (as in the definition of <code>insert</code>) makes <em>available</em> an <code>(Eq a)</code> context. In implementation terms, the <code>MkSet</code> constructor has a hidden field that stores the <code>(Eq a)</code> dictionary that is passed to <code>MkSet</code>; so when pattern-matching that dictionary becomes available for the right-hand side of the match. In the example, the equality dictionary is used to satisfy the equality constraint generated by the call to <code>elem</code>, so that the type of <code>insert</code> itself has no <code>Eq</code> constraint.</p> <p>For example, one possible application is to reify dictionaries:</p> <pre data-language="haskell">data NumInst a where
  MkNumInst :: Num a =&gt; NumInst a

intInst :: NumInst Int
intInst = MkNumInst

plus :: NumInst a -&gt; a -&gt; a -&gt; a
plus MkNumInst p q = p + q
</pre> <p>Here, a value of type <code>NumInst a</code> is equivalent to an explicit <code>(Num a)</code> dictionary.</p> <p>All this applies to constructors declared using the syntax of <a class="reference internal" href="#existential-with-context"><span class="std std-ref">Existentials and type classes</span></a>. For example, the <code>NumInst</code> data type above could equivalently be declared like this:</p> <pre data-language="haskell">data NumInst a
   = Num a =&gt; MkNumInst (NumInst a)
</pre> <p>Notice that, unlike the situation when declaring an existential, there is no <code>forall</code>, because the <code>Num</code> constrains the data type’s universally quantified type variable <code>a</code>. A constructor may have both universal and existential type variables: for example, the following two declarations are equivalent:</p> <pre data-language="haskell">data T1 a
 = forall b. (Num a, Eq b) =&gt; MkT1 a b
data T2 a where
 MkT2 :: (Num a, Eq b) =&gt; a -&gt; b -&gt; T2 a
</pre> <p>All this behaviour contrasts with Haskell 98’s peculiar treatment of contexts on a data type declaration (Section 4.2.1 of the Haskell 98 Report). In Haskell 98 the definition</p> <pre data-language="haskell">data Eq a =&gt; Set' a = MkSet' [a]
</pre> <p>gives <code>MkSet'</code> the same type as <code>MkSet</code> above. But instead of <em>making available</em> an <code>(Eq a)</code> constraint, pattern-matching on <code>MkSet'</code> <em>requires</em> an <code>(Eq a)</code> constraint! GHC faithfully implements this behaviour, odd though it is. But for GADT-style declarations, GHC’s behaviour is much more useful, as well as much more intuitive.</p> <p>The rest of this section gives further details about GADT-style data type declarations.</p> <ul> <li>The result type of each data constructor must begin with the type constructor being defined. If the result type of all constructors has the form <code>T a1 ... an</code>, where <code>a1 ... an</code> are distinct type variables, then the data type is <em>ordinary</em>; otherwise is a <em>generalised</em> data type (<a class="reference internal" href="#gadt"><span class="std std-ref">Generalised Algebraic Data Types (GADTs)</span></a>). </li> <li>
<p class="first">As with other type signatures, you can give a single signature for several data constructors. In this example we give a single signature for <code>T1</code> and <code>T2</code>:</p> <pre data-language="haskell">data T a where
  T1,T2 :: a -&gt; T a
  T3 :: T a
</pre> </li> <li>
<p class="first">The type signature of each constructor is independent, and is implicitly universally quantified as usual. In particular, the type variable(s) in the “<code>data T a where</code>” header have no scope, and different constructors may have different universally-quantified type variables:</p> <pre data-language="haskell">data T a where        -- The 'a' has no scope
  T1,T2 :: b -&gt; T b   -- Means forall b. b -&gt; T b
  T3 :: T a           -- Means forall a. T a
</pre> </li> <li>
<p class="first">A constructor signature may mention type class constraints, which can differ for different constructors. For example, this is fine:</p> <pre data-language="haskell">data T a where
  T1 :: Eq b =&gt; b -&gt; b -&gt; T b
  T2 :: (Show c, Ix c) =&gt; c -&gt; [c] -&gt; T c
</pre> <p>When pattern matching, these constraints are made available to discharge constraints in the body of the match. For example:</p> <pre data-language="haskell">f :: T a -&gt; String
f (T1 x y) | x==y      = "yes"
           | otherwise = "no"
f (T2 a b)             = show a
</pre> <p>Note that <code>f</code> is not overloaded; the <code>Eq</code> constraint arising from the use of <code>==</code> is discharged by the pattern match on <code>T1</code> and similarly the <code>Show</code> constraint arising from the use of <code>show</code>.</p> </li> <li>
<p class="first">Unlike a Haskell-98-style data type declaration, the type variable(s) in the “<code>data Set a where</code>” header have no scope. Indeed, one can write a kind signature instead:</p> <pre data-language="haskell">data Set :: Type -&gt; Type where ...
</pre> <p>or even a mixture of the two:</p> <pre data-language="haskell">data Bar a :: (Type -&gt; Type) -&gt; Type where ...
</pre> <p>The type variables (if given) may be explicitly kinded, so we could also write the header for <code>Foo</code> like this:</p> <pre data-language="haskell">data Bar a (b :: Type -&gt; Type) where ...
</pre> </li> <li>
<p class="first">You can use strictness annotations, in the obvious places in the constructor type:</p> <pre data-language="haskell">data Term a where
    Lit    :: !Int -&gt; Term Int
    If     :: Term Bool -&gt; !(Term a) -&gt; !(Term a) -&gt; Term a
    Pair   :: Term a -&gt; Term b -&gt; Term (a,b)
</pre> </li> <li>
<p class="first">You can use a <code>deriving</code> clause on a GADT-style data type declaration. For example, these two declarations are equivalent</p> <pre data-language="haskell">data Maybe1 a where {
    Nothing1 :: Maybe1 a ;
    Just1    :: a -&gt; Maybe1 a
  } deriving( Eq, Ord )

data Maybe2 a = Nothing2 | Just2 a
     deriving( Eq, Ord )
</pre> </li> <li>
<p class="first">The type signature may have quantified type variables that do not appear in the result type:</p> <pre data-language="haskell">data Foo where
   MkFoo :: a -&gt; (a-&gt;Bool) -&gt; Foo
   Nil   :: Foo
</pre> <p>Here the type variable <code>a</code> does not appear in the result type of either constructor. Although it is universally quantified in the type of the constructor, such a type variable is often called “existential”. Indeed, the above declaration declares precisely the same type as the <code>data Foo</code> in <a class="reference internal" href="#existential-quantification"><span class="std std-ref">Existentially quantified data constructors</span></a>.</p> <p>The type may contain a class context too, of course:</p> <pre data-language="haskell">data Showable where
  MkShowable :: Show a =&gt; a -&gt; Showable
</pre> </li> <li>
<p class="first">You can use record syntax on a GADT-style data type declaration:</p> <pre data-language="haskell">data Person where
    Adult :: { name :: String, children :: [Person] } -&gt; Person
    Child :: Show a =&gt; { name :: !String, funny :: a } -&gt; Person
</pre> <p>As usual, for every constructor that has a field <code>f</code>, the type of field <code>f</code> must be the same (modulo alpha conversion). The <code>Child</code> constructor above shows that the signature may have a context, existentially-quantified variables, and strictness annotations, just as in the non-record case. (NB: the “type” that follows the double-colon is not really a type, because of the record syntax and strictness annotations. A “type” of this form can appear only in a constructor signature.)</p> </li> <li>Record updates are allowed with GADT-style declarations, only fields that have the following property: the type of the field mentions no existential type variables. </li> <li>
<p class="first">As in the case of existentials declared using the Haskell-98-like record syntax (<a class="reference internal" href="#existential-records"><span class="std std-ref">Record Constructors</span></a>), record-selector functions are generated only for those fields that have well-typed selectors. Here is the example of that section, in GADT-style syntax:</p> <pre data-language="haskell">data Counter a where
    NewCounter :: { _this    :: self
                  , _inc     :: self -&gt; self
                  , _display :: self -&gt; IO ()
                  , tag      :: a
                  } -&gt; Counter a
</pre> <p>As before, only one selector function is generated here, that for <code>tag</code>. Nevertheless, you can still use all the field names in pattern matching and record construction.</p> </li> <li>
<p class="first">In a GADT-style data type declaration there is no obvious way to specify that a data constructor should be infix, which makes a difference if you derive <code>Show</code> for the type. (Data constructors declared infix are displayed infix by the derived <code>show</code>.) So GHC implements the following design: a data constructor declared in a GADT-style data type declaration is displayed infix by <code>Show</code> iff (a) it is an operator symbol, (b) it has two arguments, (c) it has a programmer-supplied fixity declaration. For example</p> <pre data-language="haskell">infix 6 (:--:)
data T a where
  (:--:) :: Int -&gt; Bool -&gt; T Int
</pre> </li> </ul>   <h2 id="gadt">11.4.8. Generalised Algebraic Data Types (GADTs)</h2> <dl class="extension" id="generalised-algebraic-data-types-gadts"> <dt id="extension-GADTs">
<code>GADTs</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body">
<a class="reference internal" href="#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a>, <a class="reference internal" href="#extension-GADTSyntax"><code>GADTSyntax</code></a>
</td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow use of Generalised Algebraic Data Types (GADTs).</p> </dd>
</dl> <p>Generalised Algebraic Data Types generalise ordinary algebraic data types by allowing constructors to have richer return types. Here is an example:</p> <pre data-language="haskell">data Term a where
    Lit    :: Int -&gt; Term Int
    Succ   :: Term Int -&gt; Term Int
    IsZero :: Term Int -&gt; Term Bool
    If     :: Term Bool -&gt; Term a -&gt; Term a -&gt; Term a
    Pair   :: Term a -&gt; Term b -&gt; Term (a,b)
</pre> <p>Notice that the return type of the constructors is not always <code>Term a</code>, as is the case with ordinary data types. This generality allows us to write a well-typed <code>eval</code> function for these <code>Terms</code>:</p> <pre data-language="haskell">eval :: Term a -&gt; a
eval (Lit i)      = i
eval (Succ t)     = 1 + eval t
eval (IsZero t)   = eval t == 0
eval (If b e1 e2) = if eval b then eval e1 else eval e2
eval (Pair e1 e2) = (eval e1, eval e2)
</pre> <p>The key point about GADTs is that <em>pattern matching causes type refinement</em>. For example, in the right hand side of the equation</p> <pre data-language="haskell">eval :: Term a -&gt; a
eval (Lit i) =  ...
</pre> <p>the type <code>a</code> is refined to <code>Int</code>. That’s the whole point! A precise specification of the type rules is beyond what this user manual aspires to, but the design closely follows that described in the paper <a class="reference external" href="http://research.microsoft.com/%7Esimonpj/papers/gadt/">Simple unification-based type inference for GADTs</a>, (ICFP 2006). The general principle is this: <em>type refinement is only carried out based on user-supplied type annotations</em>. So if no type signature is supplied for <code>eval</code>, no type refinement happens, and lots of obscure error messages will occur. However, the refinement is quite general. For example, if we had:</p> <pre data-language="haskell">eval :: Term a -&gt; a -&gt; a
eval (Lit i) j =  i+j
</pre> <p>the pattern match causes the type <code>a</code> to be refined to <code>Int</code> (because of the type of the constructor <code>Lit</code>), and that refinement also applies to the type of <code>j</code>, and the result type of the <code>case</code> expression. Hence the addition <code>i+j</code> is legal.</p> <p>These and many other examples are given in papers by Hongwei Xi, and Tim Sheard. There is a longer introduction <a class="reference external" href="http://www.haskell.org/haskellwiki/GADT">on the wiki</a>, and Ralf Hinze’s <a class="reference external" href="http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf">Fun with phantom types</a> also has a number of examples. Note that papers may use different notation to that implemented in GHC.</p> <p>The rest of this section outlines the extensions to GHC that support GADTs. The extension is enabled with <a class="reference internal" href="#extension-GADTs"><code>GADTs</code></a>. The <a class="reference internal" href="#extension-GADTs"><code>GADTs</code></a> extension also sets <a class="reference internal" href="#extension-GADTSyntax"><code>GADTSyntax</code></a> and <a class="reference internal" href="#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a>.</p> <ul> <li>A GADT can only be declared using GADT-style syntax (<a class="reference internal" href="#gadt-style"><span class="std std-ref">Declaring data types with explicit constructor signatures</span></a>); the old Haskell 98 syntax for data declarations always declares an ordinary data type. The result type of each constructor must begin with the type constructor being defined, but for a GADT the arguments to the type constructor can be arbitrary monotypes. For example, in the <code>Term</code> data type above, the type of each constructor must end with <code>Term ty</code>, but the <code>ty</code> need not be a type variable (e.g. the <code>Lit</code> constructor). </li> <li>It is permitted to declare an ordinary algebraic data type using GADT-style syntax. What makes a GADT into a GADT is not the syntax, but rather the presence of data constructors whose result type is not just <code>T a b</code>. </li> <li>You cannot use a <code>deriving</code> clause for a GADT; only for an ordinary data type. </li> <li>
<p class="first">As mentioned in <a class="reference internal" href="#gadt-style"><span class="std std-ref">Declaring data types with explicit constructor signatures</span></a>, record syntax is supported. For example:</p> <pre data-language="haskell">data Term a where
    Lit    :: { val  :: Int }      -&gt; Term Int
    Succ   :: { num  :: Term Int } -&gt; Term Int
    Pred   :: { num  :: Term Int } -&gt; Term Int
    IsZero :: { arg  :: Term Int } -&gt; Term Bool
    Pair   :: { arg1 :: Term a
              , arg2 :: Term b
              }                    -&gt; Term (a,b)
    If     :: { cnd  :: Term Bool
              , tru  :: Term a
              , fls  :: Term a
              }                    -&gt; Term a
</pre> <p>However, for GADTs there is the following additional constraint: every constructor that has a field <code>f</code> must have the same result type (modulo alpha conversion) Hence, in the above example, we cannot merge the <code>num</code> and <code>arg</code> fields above into a single name. Although their field types are both <code>Term Int</code>, their selector functions actually have different types:</p> <pre data-language="haskell">num :: Term Int -&gt; Term Int
arg :: Term Bool -&gt; Term Int
</pre> </li> <li>
<p class="first">When pattern-matching against data constructors drawn from a GADT, for example in a <code>case</code> expression, the following rules apply:</p> <ul class="simple"> <li>The type of the scrutinee must be rigid.</li> <li>The type of the entire <code>case</code> expression must be rigid.</li> <li>The type of any free variable mentioned in any of the <code>case</code> alternatives must be rigid.</li> </ul> <p>A type is “rigid” if it is completely known to the compiler at its binding site. The easiest way to ensure that a variable a rigid type is to give it a type signature. For more precise details see <a class="reference external" href="http://research.microsoft.com/%7Esimonpj/papers/gadt/">Simple unification-based type inference for GADTs</a>. The criteria implemented by GHC are given in the Appendix.</p> </li> </ul>    <h1 id="record-system-extensions">11.5. Extensions to the record system</h1>  <h2 id="id17">11.5.1. Traditional record syntax</h2> <dl class="extension" id="extensions-to-the-record-system"> <dt id="extension-NoTraditionalRecordSyntax">
<code>NoTraditionalRecordSyntax</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.4.1</td> </tr>  </table> <p>Disallow use of record syntax.</p> </dd>
</dl> <p>Traditional record syntax, such as <code>C {f = x}</code>, is enabled by default. To disable it, you can use the <a class="reference internal" href="#extension-NoTraditionalRecordSyntax"><code>NoTraditionalRecordSyntax</code></a> extension.</p>   <h2 id="disambiguate-fields">11.5.2. Record field disambiguation</h2> <dl class="extension" id="record-field-disambiguation"> <dt id="extension-DisambiguateRecordFields">
<code>DisambiguateRecordFields</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow the compiler to automatically choose between identically-named record selectors based on type (if the choice is unambiguous).</p> </dd>
</dl> <p>In record construction and record pattern matching it is entirely unambiguous which field is referred to, even if there are two different data types in scope with a common field name. For example:</p> <pre data-language="haskell">module M where
  data S = MkS { x :: Int, y :: Bool }

module Foo where
  import M

  data T = MkT { x :: Int }

  ok1 (MkS { x = n }) = n+1   -- Unambiguous
  ok2 n = MkT { x = n+1 }     -- Unambiguous

  bad1 k = k { x = 3 }        -- Ambiguous
  bad2 k = x k                -- Ambiguous
</pre> <p>Even though there are two <code>x</code>‘s in scope, it is clear that the <code>x</code> in the pattern in the definition of <code>ok1</code> can only mean the field <code>x</code> from type <code>S</code>. Similarly for the function <code>ok2</code>. However, in the record update in <code>bad1</code> and the record selection in <code>bad2</code> it is not clear which of the two types is intended.</p> <p>Haskell 98 regards all four as ambiguous, but with the <a class="reference internal" href="#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a> extension, GHC will accept the former two. The rules are precisely the same as those for instance declarations in Haskell 98, where the method names on the left-hand side of the method bindings in an instance declaration refer unambiguously to the method of that class (provided they are in scope at all), even if there are other variables in scope with the same name. This reduces the clutter of qualified names when you import two records from different modules that use the same field name.</p> <p>Some details:</p> <ul> <li>
<p class="first">Field disambiguation can be combined with punning (see <a class="reference internal" href="#record-puns"><span class="std std-ref">Record puns</span></a>). For example:</p> <pre data-language="haskell">module Foo where
  import M
  x=True
  ok3 (MkS { x }) = x+1   -- Uses both disambiguation and punning
</pre> </li> <li>
<p class="first">With <a class="reference internal" href="#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a> you can use <em>unqualified</em> field names even if the corresponding selector is only in scope <em>qualified</em> For example, assuming the same module <code>M</code> as in our earlier example, this is legal:</p> <pre data-language="haskell">module Foo where
  import qualified M    -- Note qualified

  ok4 (M.MkS { x = n }) = n+1   -- Unambiguous
</pre> <p>Since the constructor <code>MkS</code> is only in scope qualified, you must name it <code>M.MkS</code>, but the field <code>x</code> does not need to be qualified even though <code>M.x</code> is in scope but <code>x</code> is not (In effect, it is qualified by the constructor).</p> </li> </ul>   <h2 id="id18">11.5.3. Duplicate record fields</h2> <dl class="extension" id="duplicate-record-fields"> <dt id="extension-DuplicateRecordFields">
<code>DuplicateRecordFields</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Allow definition of record types with identically-named fields.</p> </dd>
</dl> <p>Going beyond <a class="reference internal" href="#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a> (see <a class="reference internal" href="#disambiguate-fields"><span class="std std-ref">Record field disambiguation</span></a>), the <a class="reference internal" href="#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a> extension allows multiple datatypes to be declared using the same field names in a single module. For example, it allows this:</p> <pre data-language="haskell">module M where
  data S = MkS { x :: Int }
  data T = MkT { x :: Bool }
</pre> <p>Uses of fields that are always unambiguous because they mention the constructor, including construction and pattern-matching, may freely use duplicated field names. For example, the following are permitted (just as with <a class="reference internal" href="#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a>):</p> <pre data-language="haskell">s = MkS { x = 3 }

f (MkT { x = b }) = b
</pre> <p>Field names used as selector functions or in record updates must be unambiguous, either because there is only one such field in scope, or because a type signature is supplied, as described in the following sections.</p>  <h3 id="selector-functions">11.5.3.1. Selector functions</h3> <p>Fields may be used as selector functions only if they are unambiguous, so this is still not allowed if both <code>S(x)</code> and <code>T(x)</code> are in scope:</p> <pre data-language="haskell">bad r = x r
</pre> <p>An ambiguous selector may be disambiguated by the type being “pushed down” to the occurrence of the selector (see <a class="reference internal" href="#higher-rank-type-inference"><span class="std std-ref">Type inference</span></a> for more details on what “pushed down” means). For example, the following are permitted:</p> <pre data-language="haskell">ok1 = x :: S -&gt; Int

ok2 :: S -&gt; Int
ok2 = x

ok3 = k x -- assuming we already have k :: (S -&gt; Int) -&gt; _
</pre> <p>In addition, the datatype that is meant may be given as a type signature on the argument to the selector:</p> <pre data-language="haskell">ok4 s = x (s :: S)
</pre> <p>However, we do not infer the type of the argument to determine the datatype, or have any way of deferring the choice to the constraint solver. Thus the following is ambiguous:</p> <pre data-language="haskell">bad :: S -&gt; Int
bad s = x s
</pre> <p>Even though a field label is duplicated in its defining module, it may be possible to use the selector unambiguously elsewhere. For example, another module could import <code>S(x)</code> but not <code>T(x)</code>, and then use <code>x</code> unambiguously.</p>   <h3 id="record-updates">11.5.3.2. Record updates</h3> <p>In a record update such as <code>e { x = 1 }</code>, if there are multiple <code>x</code> fields in scope, then the type of the context must fix which record datatype is intended, or a type annotation must be supplied. Consider the following definitions:</p> <pre data-language="haskell">data S = MkS { foo :: Int }
data T = MkT { foo :: Int, bar :: Int }
data U = MkU { bar :: Int, baz :: Int }
</pre> <p>Without <a class="reference internal" href="#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a>, an update mentioning <code>foo</code> will always be ambiguous if all these definitions were in scope. When the extension is enabled, there are several options for disambiguating updates:</p> <ul> <li>
<p class="first">Check for types that have all the fields being updated. For example:</p> <pre data-language="haskell">f x = x { foo = 3, bar = 2 }
</pre> <p>Here <code>f</code> must be updating <code>T</code> because neither <code>S</code> nor <code>U</code> have both fields.</p> </li> <li>
<p class="first">Use the type being pushed in to the record update, as in the following:</p> <pre data-language="haskell">g1 :: T -&gt; T
g1 x = x { foo = 3 }

g2 x = x { foo = 3 } :: T

g3 = k (x { foo = 3 }) -- assuming we already have k :: T -&gt; _
</pre> </li> <li>
<p class="first">Use an explicit type signature on the record expression, as in:</p> <pre data-language="haskell">h x = (x :: T) { foo = 3 }
</pre> </li> </ul> <p>The type of the expression being updated will not be inferred, and no constraint-solving will be performed, so the following will be rejected as ambiguous:</p> <pre data-language="haskell">let x :: T
    x = blah
in x { foo = 3 }

\x -&gt; [x { foo = 3 },  blah :: T ]

\ (x :: T) -&gt; x { foo = 3 }
</pre>   <h3 id="import-and-export-of-record-fields">11.5.3.3. Import and export of record fields</h3> <p>When <a class="reference internal" href="#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a> is enabled, an ambiguous field must be exported as part of its datatype, rather than at the top level. For example, the following is legal:</p> <pre data-language="haskell">module M (S(x), T(..)) where
  data S = MkS { x :: Int }
  data T = MkT { x :: Bool }
</pre> <p>However, this would not be permitted, because <code>x</code> is ambiguous:</p> <pre data-language="haskell">module M (x) where ...
</pre> <p>Similar restrictions apply on import.</p>    <h2 id="id19">11.5.4. Record puns</h2> <dl class="extension" id="record-puns"> <dt id="extension-NamedFieldPuns">
<code>NamedFieldPuns</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.10.1</td> </tr>  </table> <p>Allow use of record puns.</p> </dd>
</dl> <p>Record puns are enabled by the language extension <a class="reference internal" href="#extension-NamedFieldPuns"><code>NamedFieldPuns</code></a>.</p> <p>When using records, it is common to write a pattern that binds a variable with the same name as a record field, such as:</p> <pre data-language="haskell">data C = C {a :: Int}
f (C {a = a}) = a
</pre> <p>Record punning permits the variable name to be elided, so one can simply write</p> <pre data-language="haskell">f (C {a}) = a
</pre> <p>to mean the same pattern as above. That is, in a record pattern, the pattern <code>a</code> expands into the pattern <code>a = a</code> for the same name <code>a</code>.</p> <p>Note that:</p> <ul> <li>
<p class="first">Record punning can also be used in an expression, writing, for example,</p> <pre data-language="haskell">let a = 1 in C {a}
</pre> <p>instead of</p> <pre data-language="haskell">let a = 1 in C {a = a}
</pre> <p>The expansion is purely syntactic, so the expanded right-hand side expression refers to the nearest enclosing variable that is spelled the same as the field name.</p> </li> <li>
<p class="first">Puns and other patterns can be mixed in the same record:</p> <pre data-language="haskell">data C = C {a :: Int, b :: Int}
f (C {a, b = 4}) = a
</pre> </li> <li>Puns can be used wherever record patterns occur (e.g. in <code>let</code> bindings or at the top-level). </li> <li>
<p class="first">A pun on a qualified field name is expanded by stripping off the module qualifier. For example:</p> <pre data-language="haskell">f (C {M.a}) = a
</pre> <p>means</p> <pre data-language="haskell">f (M.C {M.a = a}) = a
</pre> <p>(This is useful if the field selector <code>a</code> for constructor <code>M.C</code> is only in scope in qualified form.)</p> </li> </ul>   <h2 id="id20">11.5.5. Record wildcards</h2> <dl class="extension" id="record-wildcards"> <dt id="extension-RecordWildCards">
<code>RecordWildCards</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body">
<a class="reference internal" href="#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a>.</td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow the use of wildcards in record construction and pattern matching.</p> </dd>
</dl> <p>Record wildcards are enabled by the language extension <a class="reference internal" href="#extension-RecordWildCards"><code>RecordWildCards</code></a>. This exension implies <a class="reference internal" href="#extension-DisambiguateRecordFields"><code>DisambiguateRecordFields</code></a>.</p> <p>For records with many fields, it can be tiresome to write out each field individually in a record pattern, as in</p> <pre data-language="haskell">data C = C {a :: Int, b :: Int, c :: Int, d :: Int}
f (C {a = 1, b = b, c = c, d = d}) = b + c + d
</pre> <p>Record wildcard syntax permits a “<code>..</code>” in a record pattern, where each elided field <code>f</code> is replaced by the pattern <code>f = f</code>. For example, the above pattern can be written as</p> <pre data-language="haskell">f (C {a = 1, ..}) = b + c + d
</pre> <p>More details:</p> <ul> <li>
<p class="first">Record wildcards in patterns can be mixed with other patterns, including puns (<a class="reference internal" href="#record-puns"><span class="std std-ref">Record puns</span></a>); for example, in a pattern <code>(C {a = 1, b, ..})</code>. Additionally, record wildcards can be used wherever record patterns occur, including in <code>let</code> bindings and at the top-level. For example, the top-level binding</p> <pre data-language="haskell">C {a = 1, ..} = e
</pre> <p>defines <code>b</code>, <code>c</code>, and <code>d</code>.</p> </li> <li>
<p class="first">Record wildcards can also be used in an expression, when constructing a record. For example,</p> <pre data-language="haskell">let {a = 1; b = 2; c = 3; d = 4} in C {..}
</pre> <p>in place of</p> <pre data-language="haskell">let {a = 1; b = 2; c = 3; d = 4} in C {a=a, b=b, c=c, d=d}
</pre> <p>The expansion is purely syntactic, so the record wildcard expression refers to the nearest enclosing variables that are spelled the same as the omitted field names.</p> </li> <li>
<p class="first">For both pattern and expression wildcards, the “<code>..</code>” expands to the missing <em>in-scope</em> record fields. Specifically the expansion of “<code>C {..}</code>” includes <code>f</code> if and only if:</p> <ul class="simple"> <li>
<code>f</code> is a record field of constructor <code>C</code>.</li> <li>The record field <code>f</code> is in scope somehow (either qualified or unqualified).</li> </ul> <p>These rules restrict record wildcards to the situations in which the user could have written the expanded version. For example</p> <pre data-language="haskell">module M where
  data R = R { a,b,c :: Int }
module X where
  import M( R(R,a,c) )
  f a b = R { .. }
</pre> <p>The <code>R{..}</code> expands to <code>R{a=a}</code>, omitting <code>b</code> since the record field is not in scope, and omitting <code>c</code> since the variable <code>c</code> is not in scope (apart from the binding of the record selector <code>c</code>, of course).</p> </li> <li>
<p class="first">When record wildcards are use in record construction, a field <code>f</code> is initialised only if <code>f</code> is in scope, and is not imported or bound at top level. For example, <code>f</code> can be bound by an enclosing pattern match or let/where-binding. For example</p> <pre data-language="haskell">module M where
  import A( a )

  data R = R { a,b,c,d :: Int }

  c = 3 :: Int

  f b = R { .. }  -- Expands to R { b = b, d = d }
    where
      d = b+1
</pre> <p>Here, <code>a</code> is imported, and <code>c</code> is bound at top level, so neither contribute to the expansion of the “<code>..</code>”. The motivation here is that it should be easy for the reader to figure out what the “<code>..</code>” expands to.</p> </li> <li>
<p class="first">Record wildcards cannot be used (a) in a record update construct, and (b) for data constructors that are not declared with record fields. For example:</p> <pre data-language="haskell">f x = x { v=True, .. }   -- Illegal (a)

data T = MkT Int Bool
g = MkT { .. }           -- Illegal (b)
h (MkT { .. }) = True    -- Illegal (b)
</pre> </li> </ul>   <h2 id="id21">11.5.6. Record field selector polymorphism</h2> <p id="record-field-selector-polymorphism">The module <a class="reference external" href="../libraries/base-4.13.0.0/ghc-records">GHC.Records</a> defines the following:</p> <pre data-language="haskell">class HasField (x :: k) r a | x r -&gt; a where
  getField :: r -&gt; a
</pre> <p>A <code>HasField x r a</code> constraint represents the fact that <code>x</code> is a field of type <code>a</code> belonging to a record type <code>r</code>. The <code>getField</code> method gives the record selector function.</p> <p>This allows definitions that are polymorphic over record types with a specified field. For example, the following works with any record type that has a field <code>name :: String</code>:</p> <pre data-language="haskell">foo :: HasField "name" r String =&gt; r -&gt; String
foo r = reverse (getField @"name" r)
</pre> <p><code>HasField</code> is a magic built-in typeclass (similar to <code>Coercible</code>, for example). It is given special treatment by the constraint solver (see <a class="reference internal" href="#solving-hasfield-constraints"><span class="std std-ref">Solving HasField constraints</span></a>). Users may define their own instances of <code>HasField</code> also (see <a class="reference internal" href="#virtual-record-fields"><span class="std std-ref">Virtual record fields</span></a>).</p>  <h3 id="id22">11.5.6.1. Solving HasField constraints</h3> <p id="solving-hasfield-constraints">If the constraint solver encounters a constraint <code>HasField x r a</code> where <code>r</code> is a concrete datatype with a field <code>x</code> in scope, it will automatically solve the constraint using the field selector as the dictionary, unifying <code>a</code> with the type of the field if necessary. This happens irrespective of which extensions are enabled.</p> <p>For example, if the following datatype is in scope</p> <pre data-language="haskell">data Person = Person { name :: String }
</pre> <p>the end result is rather like having an instance</p> <pre data-language="haskell">instance HasField "name" Person String where
  getField = name
</pre> <p>except that this instance is not actually generated anywhere, rather the constraint is solved directly by the constraint solver.</p> <p>A field must be in scope for the corresponding <code>HasField</code> constraint to be solved. This retains the existing representation hiding mechanism, whereby a module may choose not to export a field, preventing client modules from accessing or updating it directly.</p> <p>Solving <code>HasField</code> constraints depends on the field selector functions that are generated for each datatype definition:</p> <ul> <li>
<p class="first">If a record field does not have a selector function because its type would allow an existential variable to escape, the corresponding <code>HasField</code> constraint will not be solved. For example,</p> <pre data-language="haskell">{-# LANGUAGE ExistentialQuantification #-}
data Exists t = forall x . MkExists { unExists :: t x }
</pre> <p>does not give rise to a selector <code>unExists :: Exists t -&gt; t x</code> and we will not solve <code>HasField "unExists" (Exists t) a</code> automatically.</p> </li> <li>
<p class="first">If a record field has a polymorphic type (and hence the selector function is higher-rank), the corresponding <code>HasField</code> constraint will not be solved, because doing so would violate the functional dependency on <code>HasField</code> and/or require impredicativity. For example,</p> <pre data-language="haskell">{-# LANGUAGE RankNTypes #-}
data Higher = MkHigher { unHigher :: forall t . t -&gt; t }
</pre> <p>gives rise to a selector <code>unHigher :: Higher -&gt; (forall t . t -&gt; t)</code> but does not lead to solution of the constraint <code>HasField "unHigher" Higher a</code>.</p> </li> <li>
<p class="first">A record GADT may have a restricted type for a selector function, which may lead to additional unification when solving <code>HasField</code> constraints. For example,</p> <pre data-language="haskell">{-# LANGUAGE GADTs #-}
data Gadt t where
  MkGadt :: { unGadt :: Maybe v } -&gt; Gadt [v]
</pre> <p>gives rise to a selector <code>unGadt :: Gadt [v] -&gt; Maybe v</code>, so the solver will reduce the constraint <code>HasField "unGadt" (Gadt t) b</code> by unifying <code>t ~ [v]</code> and <code>b ~ Maybe v</code> for some fresh metavariable <code>v</code>, rather as if we had an instance</p> <pre data-language="haskell">instance (t ~ [v], b ~ Maybe v) =&gt; HasField "unGadt" (Gadt t) b
</pre> </li> <li>
<p class="first">If a record type has an old-fashioned datatype context, the <code>HasField</code> constraint will be reduced to solving the constraints from the context. For example,</p> <pre data-language="haskell">{-# LANGUAGE DatatypeContexts #-}
data Eq a =&gt; Silly a = MkSilly { unSilly :: a }
</pre> <p>gives rise to a selector <code>unSilly :: Eq a =&gt; Silly a -&gt; a</code>, so the solver will reduce the constraint <code>HasField "unSilly" (Silly a) b</code> to <code>Eq a</code> (and unify <code>a</code> with <code>b</code>), rather as if we had an instance</p> <pre data-language="haskell">instance (Eq a, a ~ b) =&gt; HasField "unSilly" (Silly a) b
</pre> </li> </ul>   <h3 id="id23">11.5.6.2. Virtual record fields</h3> <p id="virtual-record-fields">Users may define their own instances of <code>HasField</code>, provided they do not conflict with the built-in constraint solving behaviour. This allows “virtual” record fields to be defined for datatypes that do not otherwise have them.</p> <p>For example, this instance would make the <code>name</code> field of <code>Person</code> accessible using <code>#fullname</code> as well:</p> <pre data-language="haskell">instance HasField "fullname" Person String where
  getField = name
</pre> <p>More substantially, an anonymous records library could provide <code>HasField</code> instances for its anonymous records, and thus be compatible with the polymorphic record selectors introduced by this proposal. For example, something like this makes it possible to use <code>getField</code> to access <code>Record</code> values with the appropriate string in the type-level list of fields:</p> <pre data-language="haskell">data Record (xs :: [(k, Type)]) where
  Nil  :: Record '[]
  Cons :: Proxy x -&gt; a -&gt; Record xs -&gt; Record ('(x, a) ': xs)

instance HasField x (Record ('(x, a) ': xs)) a where
  getField (Cons _ v _) = v
instance HasField x (Record xs) a =&gt; HasField x (Record ('(y, b) ': xs)) a where
  getField (Cons _ _ r) = getField @x r

r :: Record '[ '("name", String) ]
r = Cons Proxy "R" Nil)

x = getField @"name" r
</pre> <p>Since representations such as this can support field labels with kinds other than <code>Symbol</code>, the <code>HasField</code> class is poly-kinded (even though the built-in constraint solving works only at kind <code>Symbol</code>). In particular, this allows users to declare scoped field labels such as in the following example:</p> <pre data-language="haskell">data PersonFields = Name

s :: Record '[ '(Name, String) ]
s = Cons Proxy "S" Nil

y = getField @Name s
</pre> <p>In order to avoid conflicting with the built-in constraint solving, the following user-defined <code>HasField</code> instances are prohibited (in addition to the usual rules, such as the prohibition on type families appearing in instance heads):</p> <ul class="simple"> <li>
<code>HasField _ r _</code> where <code>r</code> is a variable;</li> <li>
<code>HasField _ (T ...) _</code> if <code>T</code> is a data family (because it might have fields introduced later, using data instance declarations);</li> <li>
<code>HasField x (T ...) _</code> if <code>x</code> is a variable and <code>T</code> has any fields at all (but this instance is permitted if <code>T</code> has no fields);</li> <li>
<code>HasField "foo" (T ...) _</code> if <code>T</code> has a field <code>foo</code> (but this instance is permitted if it does not).</li> </ul> <p>If a field has a higher-rank or existential type, the corresponding <code>HasField</code> constraint will not be solved automatically (as described above), but in the interests of simplicity we do not permit users to define their own instances either. If a field is not in scope, the corresponding instance is still prohibited, to avoid conflicts in downstream modules.</p>     <h1 id="deriving">11.6. Extensions to the “deriving” mechanism</h1> <p id="extensions-to-the-deriving-mechanism">Haskell 98 allows the programmer to add a deriving clause to a data type declaration, to generate a standard instance declaration for specified class. GHC extends this mechanism along several axes:</p> <ul> <li>The derivation mechanism can be used separtely from the data type declaration, using the <a class="reference external" href="#stand-alone-deriving">standalone deriving mechanism</a>. </li> <li>In Haskell 98, the only derivable classes are <code>Eq</code>, <code>Ord</code>, <code>Enum</code>, <code>Ix</code>, <code>Bounded</code>, <code>Read</code>, and <code>Show</code>. <a class="reference external" href="#deriving-extra">Various language extensions</a> extend this list. </li> <li>
<p class="first">Besides the stock approach to deriving instances by generating all method definitions, GHC supports two additional deriving strategies, which can derive arbitrary classes:</p> <ul class="simple"> <li>
<a class="reference external" href="#newtype-deriving">Generalised newtype deriving</a> for newtypes and</li> <li>
<a class="reference external" href="#derive-any-class">deriving any class</a> using an empty instance declaration.</li> </ul> <p>The user can optionally declare the desired <a class="reference external" href="#deriving-stragies">deriving strategy</a>, especially if the compiler chooses the wrong one <a class="reference external" href="#default-deriving-strategy">by default</a>.</p> </li> </ul>  <h2 id="empty-data-deriving">11.6.1. Deriving instances for empty data types</h2> <dl class="ghc-flag" id="deriving-instances-for-empty-data-types"> <dt id="ghc-flag--XEmptyDataDeriving">
<code>-XEmptyDataDeriving</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.4.1</td> </tr>  </table> <p>Allow deriving instances of standard type classes for empty data types.</p> </dd>
</dl> <p>One can write data types with no constructors using the <a class="reference internal" href="#extension-EmptyDataDecls"><code>-XEmptyDataDecls</code></a> flag (see <a class="reference internal" href="#nullary-types"><span class="std std-ref">Data types with no constructors</span></a>), which is on by default in Haskell 2010. What is not on by default is the ability to derive type class instances for these types. This ability is enabled through use of the <a class="reference internal" href="#ghc-flag--XEmptyDataDeriving"><code>-XEmptyDataDeriving</code></a> flag. For instance, this lets one write:</p> <pre data-language="haskell">data Empty deriving (Eq, Ord, Read, Show)
</pre> <p>This would generate the following instances:</p> <pre data-language="haskell">instance Eq Empty where
  _ == _ = True

instance Ord Empty where
  compare _ _ = EQ

instance Read Empty where
  readPrec = pfail

instance Show Empty where
  showsPrec _ x = case x of {}
</pre> <p>The <a class="reference internal" href="#ghc-flag--XEmptyDataDeriving"><code>-XEmptyDataDeriving</code></a> flag is only required to enable deriving of these four “standard” type classes (which are mentioned in the Haskell Report). Other extensions to the <code>deriving</code> mechanism, which are explained below in greater detail, do not require <a class="reference internal" href="#ghc-flag--XEmptyDataDeriving"><code>-XEmptyDataDeriving</code></a> to be used in conjunction with empty data types. These include:</p> <ul class="simple"> <li>
<a class="reference internal" href="#extension-StandaloneDeriving"><code>-XStandaloneDeriving</code></a> (see <a class="reference internal" href="#stand-alone-deriving"><span class="std std-ref">Stand-alone deriving declarations</span></a>)</li> <li>Type classes which require their own extensions to be enabled to be derived, such as <a class="reference internal" href="#extension-DeriveFunctor"><code>-XDeriveFunctor</code></a> (see <a class="reference internal" href="#deriving-extra"><span class="std std-ref">Deriving instances of extra classes (Data, etc.)</span></a>)</li> <li>
<a class="reference internal" href="#extension-DeriveAnyClass"><code>-XDeriveAnyClass</code></a> (see <a class="reference internal" href="#derive-any-class"><span class="std std-ref">Deriving any other class</span></a>)</li> </ul>   <h2 id="deriving-inferred">11.6.2. Inferred context for deriving clauses</h2> <p id="inferred-context-for-deriving-clauses">The Haskell Report is vague about exactly when a <code>deriving</code> clause is legal. For example:</p> <pre data-language="haskell">data T0 f a = MkT0 a         deriving( Eq )
data T1 f a = MkT1 (f a)     deriving( Eq )
data T2 f a = MkT2 (f (f a)) deriving( Eq )
</pre> <p>The natural generated <code>Eq</code> code would result in these instance declarations:</p> <pre data-language="haskell">instance Eq a         =&gt; Eq (T0 f a) where ...
instance Eq (f a)     =&gt; Eq (T1 f a) where ...
instance Eq (f (f a)) =&gt; Eq (T2 f a) where ...
</pre> <p>The first of these is obviously fine. The second is still fine, although less obviously. The third is not Haskell 98, and risks losing termination of instances.</p> <p>GHC takes a conservative position: it accepts the first two, but not the third. The rule is this: each constraint in the inferred instance context must consist only of type variables, with no repetitions.</p> <p>This rule is applied regardless of flags. If you want a more exotic context, you can write it yourself, using the <a class="reference external" href="#stand-alone-deriving">standalone deriving mechanism</a>.</p>   <h2 id="stand-alone-deriving">11.6.3. Stand-alone deriving declarations</h2> <dl class="extension" id="stand-alone-deriving-declarations"> <dt id="extension-StandaloneDeriving">
<code>StandaloneDeriving</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow the use of stand-alone <code>deriving</code> declarations.</p> </dd>
</dl> <p>GHC allows stand-alone <code>deriving</code> declarations, enabled by <a class="reference internal" href="#extension-StandaloneDeriving"><code>StandaloneDeriving</code></a>:</p> <pre data-language="haskell">data Foo a = Bar a | Baz String

deriving instance Eq a =&gt; Eq (Foo a)
</pre> <p>The syntax is identical to that of an ordinary instance declaration apart from (a) the keyword <code>deriving</code>, and (b) the absence of the <code>where</code> part.</p> <p>However, standalone deriving differs from a <code>deriving</code> clause in a number of important ways:</p> <ul> <li>The standalone deriving declaration does not need to be in the same module as the data type declaration. (But be aware of the dangers of orphan instances (<a class="reference internal" href="separate_compilation#orphan-modules"><span class="std std-ref">Orphan modules and instance declarations</span></a>). </li> <li>
<p class="first">In most cases, you must supply an explicit context (in the example the context is <code>(Eq a)</code>), exactly as you would in an ordinary instance declaration. (In contrast, in a <code>deriving</code> clause attached to a data type declaration, the context is inferred.)</p> <p>The exception to this rule is that the context of a standalone deriving declaration can infer its context when a single, extra-wildcards constraint is used as the context, such as in:</p> <pre data-language="haskell">deriving instance _ =&gt; Eq (Foo a)
</pre> <p>This is essentially the same as if you had written <code>deriving Foo</code> after the declaration for <code>data Foo a</code>. Using this feature requires the use of <a class="reference internal" href="#extension-PartialTypeSignatures"><code>PartialTypeSignatures</code></a> (<a class="reference internal" href="#partial-type-signatures"><span class="std std-ref">Partial Type Signatures</span></a>).</p> </li> <li>
<p class="first">Unlike a <code>deriving</code> declaration attached to a <code>data</code> declaration, the instance can be more specific than the data type (assuming you also use <a class="reference internal" href="#extension-FlexibleInstances"><code>FlexibleInstances</code></a>, <a class="reference internal" href="#instance-rules"><span class="std std-ref">Relaxed rules for instance contexts</span></a>). Consider for example</p> <pre data-language="haskell">data Foo a = Bar a | Baz String

deriving instance Eq a =&gt; Eq (Foo [a])
deriving instance Eq a =&gt; Eq (Foo (Maybe a))
</pre> <p>This will generate a derived instance for <code>(Foo [a])</code> and <code>(Foo (Maybe a))</code>, but other types such as <code>(Foo (Int,Bool))</code> will not be an instance of <code>Eq</code>.</p> </li> <li>
<p class="first">Unlike a <code>deriving</code> declaration attached to a <code>data</code> declaration, GHC does not restrict the form of the data type. Instead, GHC simply generates the appropriate boilerplate code for the specified class, and typechecks it. If there is a type error, it is your problem. (GHC will show you the offending code if it has a type error.)</p> <p>The merit of this is that you can derive instances for GADTs and other exotic data types, providing only that the boilerplate code does indeed typecheck. For example:</p> <pre data-language="haskell">data T a where
   T1 :: T Int
   T2 :: T Bool

deriving instance Show (T a)
</pre> <p>In this example, you cannot say <code>... deriving( Show )</code> on the data type declaration for <code>T</code>, because <code>T</code> is a GADT, but you <em>can</em> generate the instance declaration using stand-alone deriving.</p> <p>The down-side is that, if the boilerplate code fails to typecheck, you will get an error message about that code, which you did not write. Whereas, with a <code>deriving</code> clause the side-conditions are necessarily more conservative, but any error message may be more comprehensible.</p> </li> <li>
<p class="first">Under most circumstances, you cannot use standalone deriving to create an instance for a data type whose constructors are not all in scope. This is because the derived instance would generate code that uses the constructors behind the scenes, which would break abstraction.</p> <p>The one exception to this rule is <a class="reference internal" href="#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a>, since deriving an instance via <a class="reference internal" href="#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a> simply generates an empty instance declaration, which does not require the use of any constructors. See the <a class="reference external" href="#derive-any-class">deriving any class</a> section for more details.</p> </li> </ul> <p>In other ways, however, a standalone deriving obeys the same rules as ordinary deriving:</p> <ul> <li>A <code>deriving instance</code> declaration must obey the same rules concerning form and termination as ordinary instance declarations, controlled by the same flags; see <a class="reference internal" href="#instance-decls"><span class="std std-ref">Instance declarations</span></a>. </li> <li>
<p class="first">The stand-alone syntax is generalised for newtypes in exactly the same way that ordinary <code>deriving</code> clauses are generalised (<a class="reference internal" href="#newtype-deriving"><span class="std std-ref">Generalised derived instances for newtypes</span></a>). For example:</p> <pre data-language="haskell">newtype Foo a = MkFoo (State Int a)

deriving instance MonadState Int Foo
</pre> <p>GHC always treats the <em>last</em> parameter of the instance (<code>Foo</code> in this example) as the type whose instance is being derived.</p> </li> </ul>   <h2 id="deriving-extra">11.6.4. Deriving instances of extra classes (<code>Data</code>, etc.)</h2> <p id="deriving-instances-of-extra-classes-data-etc">Haskell 98 allows the programmer to add “<code>deriving( Eq, Ord )</code>” to a data type declaration, to generate a standard instance declaration for classes specified in the <code>deriving</code> clause. In Haskell 98, the only classes that may appear in the <code>deriving</code> clause are the standard classes <code>Eq</code>, <code>Ord</code>, <code>Enum</code>, <code>Ix</code>, <code>Bounded</code>, <code>Read</code>, and <code>Show</code>.</p> <p>GHC extends this list with several more classes that may be automatically derived:</p> <ul class="simple"> <li>With <a class="reference internal" href="#extension-DeriveGeneric"><code>DeriveGeneric</code></a>, you can derive instances of the classes <code>Generic</code> and <code>Generic1</code>, defined in <code>GHC.Generics</code>. You can use these to define generic functions, as described in <a class="reference internal" href="#generic-programming"><span class="std std-ref">Generic programming</span></a>.</li> <li>With <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a>, you can derive instances of the class <code>Functor</code>, defined in <code>GHC.Base</code>.</li> <li>With <a class="reference internal" href="#extension-DeriveDataTypeable"><code>DeriveDataTypeable</code></a>, you can derive instances of the class <code>Data</code>, defined in <code>Data.Data</code>.</li> <li>With <a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a>, you can derive instances of the class <code>Foldable</code>, defined in <code>Data.Foldable</code>.</li> <li>With <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a>, you can derive instances of the class <code>Traversable</code>, defined in <code>Data.Traversable</code>. Since the <code>Traversable</code> instance dictates the instances of <code>Functor</code> and <code>Foldable</code>, you’ll probably want to derive them too, so <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a> implies <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> and <a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a>.</li> <li>With <a class="reference internal" href="#extension-DeriveLift"><code>DeriveLift</code></a>, you can derive instances of the class <code>Lift</code>, defined in the <code>Language.Haskell.TH.Syntax</code> module of the <code>template-haskell</code> package.</li> </ul> <p>You can also use a standalone deriving declaration instead (see <a class="reference internal" href="#stand-alone-deriving"><span class="std std-ref">Stand-alone deriving declarations</span></a>).</p> <p>In each case the appropriate class must be in scope before it can be mentioned in the <code>deriving</code> clause.</p>  <h3 id="deriving-functor">11.6.4.1. Deriving <code>Functor</code> instances</h3> <dl class="extension" id="deriving-functor-instances"> <dt id="extension-DeriveFunctor">
<code>DeriveFunctor</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10.1</td> </tr>  </table> <p>Allow automatic deriving of instances for the <code>Functor</code> typeclass.</p> </dd>
</dl> <p>With <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a>, one can derive <code>Functor</code> instances for data types of kind <code>Type -&gt; Type</code>. For example, this declaration:</p> <pre data-language="haskell">data Example a = Ex a Char (Example a) (Example Char)
  deriving Functor
</pre> <p>would generate the following instance:</p> <pre data-language="haskell">instance Functor Example where
  fmap f (Ex a1 a2 a3 a4) = Ex (f a1) a2 (fmap f a3) a4
</pre> <p>The basic algorithm for <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> walks the arguments of each constructor of a data type, applying a mapping function depending on the type of each argument. If a plain type variable is found that is syntactically equivalent to the last type parameter of the data type (<code>a</code> in the above example), then we apply the function <code>f</code> directly to it. If a type is encountered that is not syntactically equivalent to the last type parameter <em>but does mention</em> the last type parameter somewhere in it, then a recursive call to <code>fmap</code> is made. If a type is found which doesn’t mention the last type parameter at all, then it is left alone.</p> <p>The second of those cases, in which a type is unequal to the type parameter but does contain the type parameter, can be surprisingly tricky. For example, the following example compiles:</p> <pre data-language="haskell">newtype Right a = Right (Either Int a) deriving Functor
</pre> <p>Modifying the code slightly, however, produces code which will not compile:</p> <pre data-language="haskell">newtype Wrong a = Wrong (Either a Int) deriving Functor
</pre> <p>The difference involves the placement of the last type parameter, <code>a</code>. In the <code>Right</code> case, <code>a</code> occurs within the type <code>Either Int a</code>, and moreover, it appears as the last type argument of <code>Either</code>. In the <code>Wrong</code> case, however, <code>a</code> is not the last type argument to <code>Either</code>; rather, <code>Int</code> is.</p> <p>This distinction is important because of the way <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> works. The derived <code>Functor Right</code> instance would be:</p> <pre data-language="haskell">instance Functor Right where
  fmap f (Right a) = Right (fmap f a)
</pre> <p>Given a value of type <code>Right a</code>, GHC must produce a value of type <code>Right b</code>. Since the argument to the <code>Right</code> constructor has type <code>Either Int a</code>, the code recursively calls <code>fmap</code> on it to produce a value of type <code>Either Int b</code>, which is used in turn to construct a final value of type <code>Right b</code>.</p> <p>The generated code for the <code>Functor Wrong</code> instance would look exactly the same, except with <code>Wrong</code> replacing every occurrence of <code>Right</code>. The problem is now that <code>fmap</code> is being applied recursively to a value of type <code>Either a Int</code>. This cannot possibly produce a value of type <code>Either b Int</code>, as <code>fmap</code> can only change the last type parameter! This causes the generated code to be ill-typed.</p> <p>As a general rule, if a data type has a derived <code>Functor</code> instance and its last type parameter occurs on the right-hand side of the data declaration, then either it must (1) occur bare (e.g., <code>newtype Id a = Id a</code>), or (2) occur as the last argument of a type constructor (as in <code>Right</code> above).</p> <p>There are two exceptions to this rule:</p> <ol class="arabic"> <li>
<p class="first">Tuple types. When a non-unit tuple is used on the right-hand side of a data declaration, <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> treats it as a product of distinct types. In other words, the following code:</p> <pre data-language="haskell">newtype Triple a = Triple (a, Int, [a]) deriving Functor
</pre> <p>Would result in a generated <code>Functor</code> instance like so:</p> <pre data-language="haskell">instance Functor Triple where
  fmap f (Triple a) =
    Triple (case a of
                 (a1, a2, a3) -&gt; (f a1, a2, fmap f a3))
</pre> <p>That is, <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> pattern-matches its way into tuples and maps over each type that constitutes the tuple. The generated code is reminiscent of what would be generated from <code>data Triple a = Triple a Int [a]</code>, except with extra machinery to handle the tuple.</p> </li> <li>
<p class="first">Function types. The last type parameter can appear anywhere in a function type as long as it occurs in a <em>covariant</em> position. To illustrate what this means, consider the following three examples:</p> <pre data-language="haskell">newtype CovFun1 a = CovFun1 (Int -&gt; a) deriving Functor
newtype CovFun2 a = CovFun2 ((a -&gt; Int) -&gt; a) deriving Functor
newtype CovFun3 a = CovFun3 (((Int -&gt; a) -&gt; Int) -&gt; a) deriving Functor
</pre> <p>All three of these examples would compile without issue. On the other hand:</p> <pre data-language="haskell">newtype ContraFun1 a = ContraFun1 (a -&gt; Int) deriving Functor
newtype ContraFun2 a = ContraFun2 ((Int -&gt; a) -&gt; Int) deriving Functor
newtype ContraFun3 a = ContraFun3 (((a -&gt; Int) -&gt; a) -&gt; Int) deriving Functor
</pre> <p>While these examples look similar, none of them would successfully compile. This is because all occurrences of the last type parameter <code>a</code> occur in <em>contravariant</em> positions, not covariant ones.</p> <p>Intuitively, a covariant type is <em>produced</em>, and a contravariant type is <em>consumed</em>. Most types in Haskell are covariant, but the function type is special in that the lefthand side of a function arrow reverses variance. If a function type <code>a -&gt; b</code> appears in a covariant position (e.g., <code>CovFun1</code> above), then <code>a</code> is in a contravariant position and <code>b</code> is in a covariant position. Similarly, if <code>a -&gt; b</code> appears in a contravariant position (e.g., <code>CovFun2</code> above), then <code>a</code> is in <code>a</code> covariant position and <code>b</code> is in a contravariant position.</p> <p>To see why a data type with a contravariant occurrence of its last type parameter cannot have a derived <code>Functor</code> instance, let’s suppose that a <code>Functor ContraFun1</code> instance exists. The implementation would look something like this:</p> <pre data-language="haskell">instance Functor ContraFun1 where
  fmap f (ContraFun g) = ContraFun (\x -&gt; _)
</pre> <p>We have <code>f :: a -&gt; b</code>, <code>g :: a -&gt; Int</code>, and <code>x :: b</code>. Using these, we must somehow fill in the hole (denoted with an underscore) with a value of type <code>Int</code>. What are our options?</p> <p>We could try applying <code>g</code> to <code>x</code>. This won’t work though, as <code>g</code> expects an argument of type <code>a</code>, and <code>x :: b</code>. Even worse, we can’t turn <code>x</code> into something of type <code>a</code>, since <code>f</code> also needs an argument of type <code>a</code>! In short, there’s no good way to make this work.</p> <p>On the other hand, a derived <code>Functor</code> instances for the <code>CovFun</code>s are within the realm of possibility:</p> <pre data-language="haskell">instance Functor CovFun1 where
  fmap f (CovFun1 g) = CovFun1 (\x -&gt; f (g x))

instance Functor CovFun2 where
  fmap f (CovFun2 g) = CovFun2 (\h -&gt; f (g (\x -&gt; h (f x))))

instance Functor CovFun3 where
  fmap f (CovFun3 g) = CovFun3 (\h -&gt; f (g (\k -&gt; h (\x -&gt; f (k x)))))
</pre> </li> </ol> <p>There are some other scenarios in which a derived <code>Functor</code> instance will fail to compile:</p> <ol class="arabic"> <li>A data type has no type parameters (e.g., <code>data Nothing = Nothing</code>). </li> <li>A data type’s last type variable is used in a <a class="reference internal" href="#extension-DatatypeContexts"><code>DatatypeContexts</code></a> constraint (e.g., <code>data Ord a =&gt; O a = O a</code>). </li> <li>
<p class="first">A data type’s last type variable is used in an <a class="reference internal" href="#extension-ExistentialQuantification"><code>ExistentialQuantification</code></a> constraint, or is refined in a GADT. For example,</p> <pre data-language="haskell">data T a b where
    T4 :: Ord b =&gt; b -&gt; T a b
    T5 :: b -&gt; T b b
    T6 :: T a (b,b)

deriving instance Functor (T a)
</pre> <p>would not compile successfully due to the way in which <code>b</code> is constrained.</p> </li> </ol> <p>When the last type parameter has a phantom role (see <a class="reference internal" href="#roles"><span class="std std-ref">Roles</span></a>), the derived <code>Functor</code> instance will not be produced using the usual algorithm. Instead, the entire value will be coerced.</p> <pre data-language="haskell">data Phantom a = Z | S (Phantom a) deriving Functor
</pre> <p>will produce the following instance:</p> <pre data-language="haskell">instance Functor Phantom where
  fmap _ = coerce
</pre> <p>When a type has no constructors, the derived <code>Functor</code> instance will simply force the (bottom) value of the argument using <a class="reference internal" href="#extension-EmptyCase"><code>EmptyCase</code></a>.</p> <pre data-language="haskell">data V a deriving Functor
type role V nominal
</pre> <p>will produce</p>  <dl class="docutils"> <dt>instance Functor V where</dt> <dd>fmap _ z = case z of</dd> </dl>    <h3 id="deriving-foldable">11.6.4.2. Deriving <code>Foldable</code> instances</h3> <dl class="extension" id="deriving-foldable-instances"> <dt id="extension-DeriveFoldable">
<code>DeriveFoldable</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10.1</td> </tr>  </table> <p>Allow automatic deriving of instances for the <code>Foldable</code> typeclass.</p> </dd>
</dl> <p>With <a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a>, one can derive <code>Foldable</code> instances for data types of kind <code>Type -&gt; Type</code>. For example, this declaration:</p> <pre data-language="haskell">data Example a = Ex a Char (Example a) (Example Char)
  deriving Foldable
</pre> <p>would generate the following instance:</p> <pre data-language="haskell">instance Foldable Example where
  foldr f z (Ex a1 a2 a3 a4) = f a1 (foldr f z a3)
  foldMap f (Ex a1 a2 a3 a4) = mappend (f a1) (foldMap f a3)
</pre> <p>The algorithm for <a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a> is adapted from the <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> algorithm, but it generates definitions for <code>foldMap</code>, <code>foldr</code>, and <code>null</code> instead of <code>fmap</code>. In addition, <a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a> filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not need to be folded over.</p> <p>When the type parameter has a phantom role (see <a class="reference internal" href="#roles"><span class="std std-ref">Roles</span></a>), <a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a> derives a trivial instance. For example, this declaration:</p> <pre data-language="haskell">data Phantom a = Z | S (Phantom a)
</pre> <p>will generate the following instance.</p> <pre data-language="haskell">instance Foldable Phantom where
  foldMap _ _ = mempty
</pre> <p>Similarly, when the type has no constructors, <a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a> will derive a trivial instance:</p> <pre data-language="haskell">data V a deriving Foldable
type role V nominal
</pre> <p>will generate the following.</p> <pre data-language="haskell">instance Foldable V where
  foldMap _ _ = mempty
</pre> <p>Here are the differences between the generated code for <code>Functor</code> and <code>Foldable</code>:</p> <p>#. When a bare type variable <code>a</code> is encountered, <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> would generate <code>f a</code> for an <code>fmap</code> definition. <a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a> would generate <code>f a z</code> for <code>foldr</code>, <code>f a</code> for <code>foldMap</code>, and <code>False</code> for <code>null</code>.</p> <ol class="arabic"> <li>
<p class="first">When a type that is not syntactically equivalent to <code>a</code>, but which does contain <code>a</code>, is encountered, <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> recursively calls <code>fmap</code> on it. Similarly, <a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a> would recursively call <code>foldr</code> and <code>foldMap</code>. Depending on the context, <code>null</code> may recursively call <code>null</code> or <code>all null</code>. For example, given</p> <pre data-language="haskell">data F a = F (P a)
data G a = G (P (a, Int))
data H a = H (P (Q a))
</pre> <p><code>Foldable</code> deriving will produce</p> <pre data-language="haskell">null (F x) = null x
null (G x) = null x
null (H x) = all null x
</pre> </li> <li>
<p class="first"><a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> puts everything back together again at the end by invoking the constructor. <a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a>, however, builds up a value of some type. For <code>foldr</code>, this is accomplished by chaining applications of <code>f</code> and recursive <code>foldr</code> calls on the state value <code>z</code>. For <code>foldMap</code>, this happens by combining all values with <code>mappend</code>. For <code>null</code>, the values are usually combined with <code>&amp;&amp;</code>. However, if any of the values is known to be <code>False</code>, all the rest will be dropped. For example,</p> <pre data-language="haskell">data SnocList a = Nil | Snoc (SnocList a) a
</pre> <p>will not produce</p> <pre data-language="haskell">null (Snoc xs _) = null xs &amp;&amp; False
</pre> <p>(which would walk the whole list), but rather</p> <pre data-language="haskell">null (Snoc _ _) = False
</pre> </li> </ol> <p>There are some other differences regarding what data types can have derived <code>Foldable</code> instances:</p> <ol class="arabic"> <li>Data types containing function types on the right-hand side cannot have derived <code>Foldable</code> instances. </li> <li>
<p class="first"><code>Foldable</code> instances can be derived for data types in which the last type parameter is existentially constrained or refined in a GADT. For example, this data type:</p> <pre data-language="haskell">data E a where
    E1 :: (a ~ Int) =&gt; a   -&gt; E a
    E2 ::              Int -&gt; E Int
    E3 :: (a ~ Int) =&gt; a   -&gt; E Int
    E4 :: (a ~ Int) =&gt; Int -&gt; E a

deriving instance Foldable E
</pre> <p>would have the following generated <code>Foldable</code> instance:</p> <pre data-language="haskell">instance Foldable E where
    foldr f z (E1 e) = f e z
    foldr f z (E2 e) = z
    foldr f z (E3 e) = z
    foldr f z (E4 e) = z

    foldMap f (E1 e) = f e
    foldMap f (E2 e) = mempty
    foldMap f (E3 e) = mempty
    foldMap f (E4 e) = mempty
</pre> <p>Notice how every constructor of <code>E</code> utilizes some sort of existential quantification, but only the argument of <code>E1</code> is actually “folded over”. This is because we make a deliberate choice to only fold over universally polymorphic types that are syntactically equivalent to the last type parameter. In particular:</p> </li> </ol>  <ul class="simple"> <li>We don’t fold over the arguments of <code>E1</code> or <code>E4</code> because even though <code>(a ~ Int)</code>, <code>Int</code> is not syntactically equivalent to <code>a</code>.</li> <li>We don’t fold over the argument of <code>E3</code> because <code>a</code> is not universally polymorphic. The <code>a</code> in <code>E3</code> is (implicitly) existentially quantified, so it is not the same as the last type parameter of <code>E</code>.</li> </ul>    <h3 id="deriving-traversable">11.6.4.3. Deriving <code>Traversable</code> instances</h3> <dl class="extension" id="deriving-traversable-instances"> <dt id="extension-DeriveTraversable">
<code>DeriveTraversable</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body">
<a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a>, <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a>
</td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10.1</td> </tr>  </table> <p>Allow automatic deriving of instances for the <code>Traversable</code> typeclass.</p> </dd>
</dl> <p>With <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a>, one can derive <code>Traversable</code> instances for data types of kind <code>Type -&gt; Type</code>. For example, this declaration:</p> <pre data-language="haskell">data Example a = Ex a Char (Example a) (Example Char)
  deriving (Functor, Foldable, Traversable)
</pre> <p>would generate the following <code>Traversable</code> instance:</p> <pre data-language="haskell">instance Traversable Example where
  traverse f (Ex a1 a2 a3 a4)
    = fmap (\b1 b3 -&gt; Ex b1 a2 b3 a4) (f a1) &lt;*&gt; traverse f a3
</pre> <p>The algorithm for <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a> is adapted from the <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> algorithm, but it generates a definition for <code>traverse</code> instead of <code>fmap</code>. In addition, <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a> filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not produce any effects in a traversal.</p> <p>When the type parameter has a phantom role (see <a class="reference internal" href="#roles"><span class="std std-ref">Roles</span></a>), <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a> coerces its argument. For example, this declaration:</p> <pre data-language="haskell">data Phantom a = Z | S (Phantom a) deriving Traversable
</pre> <p>will generate the following instance:</p> <pre data-language="haskell">instance Traversable Phantom where
  traverse _ z = pure (coerce z)
</pre> <p>When the type has no constructors, <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a> will derive the laziest instance it can.</p> <pre data-language="haskell">data V a deriving Traversable
type role V nominal
</pre> <p>will generate the following, using <a class="reference internal" href="#extension-EmptyCase"><code>EmptyCase</code></a>:</p> <pre data-language="haskell">instance Traversable V where
  traverse _ z = pure (case z of)
</pre> <p>Here are the differences between the generated code in each extension:</p> <ol class="arabic simple"> <li>When a bare type variable <code>a</code> is encountered, both <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> and <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a> would generate <code>f a</code> for an <code>fmap</code> and <code>traverse</code> definition, respectively.</li> <li>When a type that is not syntactically equivalent to <code>a</code>, but which does contain <code>a</code>, is encountered, <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> recursively calls <code>fmap</code> on it. Similarly, <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a> would recursively call <code>traverse</code>.</li> <li>
<a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a> puts everything back together again at the end by invoking the constructor. <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a> does something similar, but it works in an <code>Applicative</code> context by chaining everything together with <code>(&lt;*&gt;)</code>.</li> </ol> <p>Unlike <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a>, <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a> cannot be used on data types containing a function type on the right-hand side.</p> <p>For a full specification of the algorithms used in <a class="reference internal" href="#extension-DeriveFunctor"><code>DeriveFunctor</code></a>, <a class="reference internal" href="#extension-DeriveFoldable"><code>DeriveFoldable</code></a>, and <a class="reference internal" href="#extension-DeriveTraversable"><code>DeriveTraversable</code></a>, see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor">this wiki page</a>.</p>   <h3 id="deriving-data">11.6.4.4. Deriving <code>Data</code> instances</h3> <dl class="extension" id="deriving-data-instances"> <dt id="extension-DeriveDataTypeable">
<code>DeriveDataTypeable</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Enable automatic deriving of instances for the <code>Data</code> typeclass</p> </dd>
</dl>   <h3 id="deriving-typeable">11.6.4.5. Deriving <code>Typeable</code> instances</h3> <p id="deriving-typeable-instances">The class <code>Typeable</code> is very special:</p> <ul> <li>
<code>Typeable</code> is kind-polymorphic (see <a class="reference internal" href="#kind-polymorphism"><span class="std std-ref">Kind polymorphism</span></a>). </li> <li>GHC has a custom solver for discharging constraints that involve class <code>Typeable</code>, and handwritten instances are forbidden. This ensures that the programmer cannot subvert the type system by writing bogus instances. </li> <li>Derived instances of <code>Typeable</code> may be declared if the <a class="reference internal" href="#extension-DeriveDataTypeable"><code>DeriveDataTypeable</code></a> extension is enabled, but they are ignored, and they may be reported as an error in a later version of the compiler. </li> <li>
<p class="first">The rules for solving `Typeable` constraints are as follows:</p> <ul> <li>
<p class="first">A concrete type constructor applied to some types.</p> <pre data-language="haskell">instance (Typeable t1, .., Typeable t_n) =&gt;
  Typeable (T t1 .. t_n)
</pre> <p>This rule works for any concrete type constructor, including type constructors with polymorphic kinds. The only restriction is that if the type constructor has a polymorphic kind, then it has to be applied to all of its kinds parameters, and these kinds need to be concrete (i.e., they cannot mention kind variables).</p> </li> <li>
<p class="first">A type variable applied to some types:</p> <pre data-language="haskell">instance (Typeable f, Typeable t1, .., Typeable t_n) =&gt;
  Typeable (f t1 .. t_n)
</pre> </li> <li>
<p class="first">A concrete type literal.:</p> <pre data-language="haskell">instance Typeable 0       -- Type natural literals
instance Typeable "Hello" -- Type-level symbols
</pre> </li> </ul> </li> </ul>   <h3 id="deriving-lift">11.6.4.6. Deriving <code>Lift</code> instances</h3> <dl class="extension" id="deriving-lift-instances"> <dt id="extension-DeriveLift">
<code>DeriveLift</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Enable automatic deriving of instances for the <code>Lift</code> typeclass for Template Haskell.</p> </dd>
</dl> <p>The class <code>Lift</code>, unlike other derivable classes, lives in <code>template-haskell</code> instead of <code>base</code>. Having a data type be an instance of <code>Lift</code> permits its values to be promoted to Template Haskell expressions (of type <code>ExpQ</code>), which can then be spliced into Haskell source code.</p> <p>Here is an example of how one can derive <code>Lift</code>:</p> <pre data-language="haskell">{-# LANGUAGE DeriveLift #-}
module Bar where

import Language.Haskell.TH.Syntax

data Foo a = Foo a | a :^: a deriving Lift

{-
instance (Lift a) =&gt; Lift (Foo a) where
    lift (Foo a)
    = appE
        (conE
            (mkNameG_d "package-name" "Bar" "Foo"))
        (lift a)
    lift (u :^: v)
    = infixApp
        (lift u)
        (conE
            (mkNameG_d "package-name" "Bar" ":^:"))
        (lift v)
-}

-----
{-# LANGUAGE TemplateHaskell #-}
module Baz where

import Bar
import Language.Haskell.TH.Lift

foo :: Foo String
foo = $(lift $ Foo "foo")

fooExp :: Lift a =&gt; Foo a -&gt; Q Exp
fooExp f = [| f |]
</pre> <p><a class="reference internal" href="#extension-DeriveLift"><code>DeriveLift</code></a> also works for certain unboxed types (<code>Addr#</code>, <code>Char#</code>, <code>Double#</code>, <code>Float#</code>, <code>Int#</code>, and <code>Word#</code>):</p> <pre data-language="haskell">{-# LANGUAGE DeriveLift, MagicHash #-}
module Unboxed where

import GHC.Exts
import Language.Haskell.TH.Syntax

data IntHash = IntHash Int# deriving Lift

{-
instance Lift IntHash where
    lift (IntHash i)
    = appE
        (conE
            (mkNameG_d "package-name" "Unboxed" "IntHash"))
        (litE
            (intPrimL (toInteger (I# i))))
-}
</pre>    <h2 id="newtype-deriving">11.6.5. Generalised derived instances for newtypes</h2> <dl class="extension" id="generalised-derived-instances-for-newtypes"> <dt id="extension-GeneralisedNewtypeDeriving">
<code>GeneralisedNewtypeDeriving</code> </dt> <dt id="extension-GeneralizedNewtypeDeriving">
<code>GeneralizedNewtypeDeriving</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1. British spelling since 8.6.1.</td> </tr>  </table> <p>Enable GHC’s cunning generalised deriving mechanism for <code>newtype</code>s</p> </dd>
</dl> <p>When you define an abstract type using <code>newtype</code>, you may want the new type to inherit some instances from its representation. In Haskell 98, you can inherit instances of <code>Eq</code>, <code>Ord</code>, <code>Enum</code> and <code>Bounded</code> by deriving them, but for any other classes you have to write an explicit instance declaration. For example, if you define</p> <pre data-language="haskell">newtype Dollars = Dollars Int
</pre> <p>and you want to use arithmetic on <code>Dollars</code>, you have to explicitly define an instance of <code>Num</code>:</p> <pre data-language="haskell">instance Num Dollars where
  Dollars a + Dollars b = Dollars (a+b)
  ...
</pre> <p>All the instance does is apply and remove the <code>newtype</code> constructor. It is particularly galling that, since the constructor doesn’t appear at run-time, this instance declaration defines a dictionary which is <em>wholly equivalent</em> to the <code>Int</code> dictionary, only slower!</p> <p><a class="reference internal" href="#extension-DerivingVia"><code>DerivingVia</code></a> (see <a class="reference internal" href="#deriving-via"><span class="std std-ref">Deriving via</span></a>) is a generalization of this idea.</p>  <h3 id="generalized-newtype-deriving">11.6.5.1. Generalising the deriving clause</h3> <p id="generalising-the-deriving-clause">GHC now permits such instances to be derived instead, using the extension <a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code>GeneralizedNewtypeDeriving</code></a>, so one can write</p> <pre data-language="haskell">newtype Dollars = Dollars { getDollars :: Int } deriving (Eq,Show,Num)
</pre> <p>and the implementation uses the <em>same</em> <code>Num</code> dictionary for <code>Dollars</code> as for <code>Int</code>. In other words, GHC will generate something that resembles the following code</p> <pre data-language="haskell">instance Num Int =&gt; Num Dollars
</pre> <p>and then attempt to simplify the <code>Num Int</code> context as much as possible. GHC knows that there is a <code>Num Int</code> instance in scope, so it is able to discharge the <code>Num Int</code> constraint, leaving the code that GHC actually generates</p> <pre data-language="haskell">instance Num Dollars
</pre> <p>One can think of this instance being implemented with the same code as the <code>Num Int</code> instance, but with <code>Dollars</code> and <code>getDollars</code> added wherever necessary in order to make it typecheck. (In practice, GHC uses a somewhat different approach to code generation. See the <a class="reference internal" href="#precise-gnd-specification"><span class="std std-ref">A more precise specification</span></a> section below for more details.)</p> <p>We can also derive instances of constructor classes in a similar way. For example, suppose we have implemented state and failure monad transformers, such that</p> <pre data-language="haskell">instance Monad m =&gt; Monad (State s m)
instance Monad m =&gt; Monad (Failure m)
</pre> <p>In Haskell 98, we can define a parsing monad by</p> <pre data-language="haskell">type Parser tok m a = State [tok] (Failure m) a
</pre> <p>which is automatically a monad thanks to the instance declarations above. With the extension, we can make the parser type abstract, without needing to write an instance of class <code>Monad</code>, via</p> <pre data-language="haskell">newtype Parser tok m a = Parser (State [tok] (Failure m) a)
                       deriving Monad
</pre> <p>In this case the derived instance declaration is of the form</p> <pre data-language="haskell">instance Monad (State [tok] (Failure m)) =&gt; Monad (Parser tok m)
</pre> <p>Notice that, since <code>Monad</code> is a constructor class, the instance is a <em>partial application</em> of the newtype, not the entire left hand side. We can imagine that the type declaration is “eta-converted” to generate the context of the instance declaration.</p> <p>We can even derive instances of multi-parameter classes, provided the newtype is the last class parameter. In this case, a “partial application” of the class appears in the <code>deriving</code> clause. For example, given the class</p> <pre data-language="haskell">class StateMonad s m | m -&gt; s where ...
instance Monad m =&gt; StateMonad s (State s m) where ...
</pre> <p>then we can derive an instance of <code>StateMonad</code> for <code>Parser</code> by</p> <pre data-language="haskell">newtype Parser tok m a = Parser (State [tok] (Failure m) a)
                       deriving (Monad, StateMonad [tok])
</pre> <p>The derived instance is obtained by completing the application of the class to the new type:</p> <pre data-language="haskell">instance StateMonad [tok] (State [tok] (Failure m)) =&gt;
         StateMonad [tok] (Parser tok m)
</pre> <p>As a result of this extension, all derived instances in newtype declarations are treated uniformly (and implemented just by reusing the dictionary for the representation type), <em>except</em> <code>Show</code> and <code>Read</code>, which really behave differently for the newtype and its representation.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>It is sometimes necessary to enable additional language extensions when deriving instances via <a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code>GeneralizedNewtypeDeriving</code></a>. For instance, consider a simple class and instance using <a class="reference internal" href="#extension-UnboxedTuples"><code>UnboxedTuples</code></a> syntax:</p> <pre data-language="haskell">{-# LANGUAGE UnboxedTuples #-}

module Lib where

class AClass a where
  aMethod :: a -&gt; (# Int, a #)

instance AClass Int where
  aMethod x = (# x, x #)
</pre> <p>The following will fail with an “Illegal unboxed tuple” error, since the derived instance produced by the compiler makes use of unboxed tuple syntax,</p> <pre data-language="haskell">{-# LANGUAGE GeneralizedNewtypeDeriving #-}

import Lib

newtype Int' = Int' Int
             deriving (AClass)
</pre> <p>However, enabling the <a class="reference internal" href="#extension-UnboxedTuples"><code>UnboxedTuples</code></a> extension allows the module to compile. Similar errors may occur with a variety of extensions, including:</p>  <ul class="simple"> <li><a class="reference internal" href="#extension-UnboxedTuples"><code>UnboxedTuples</code></a></li> <li><a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a></li> <li><a class="reference internal" href="#extension-MultiParamTypeClasses"><code>MultiParamTypeClasses</code></a></li> <li><a class="reference internal" href="#extension-FlexibleContexts"><code>FlexibleContexts</code></a></li> </ul>  </div>   <h3 id="precise-gnd-specification">11.6.5.2. A more precise specification</h3> <p id="a-more-precise-specification">A derived instance is derived only for declarations of these forms (after expansion of any type synonyms)</p> <pre data-language="haskell">newtype T v1..vn                   = MkT (t vk+1..vn) deriving (C t1..tj)
newtype instance T s1..sk vk+1..vn = MkT (t vk+1..vn) deriving (C t1..tj)
</pre> <p>where</p> <ul class="simple"> <li>
<code>v1..vn</code> are type variables, and <code>t</code>, <code>s1..sk</code>, <code>t1..tj</code> are types.</li> <li>The <code>(C t1..tj)</code> is a partial applications of the class <code>C</code>, where the arity of <code>C</code> is exactly <code>j+1</code>. That is, <code>C</code> lacks exactly one type argument.</li> <li>
<code>k</code> is chosen so that <code>C t1..tj (T v1...vk)</code> is well-kinded. (Or, in the case of a <code>data instance</code>, so that <code>C t1..tj (T s1..sk)</code> is well kinded.)</li> <li>The type <code>t</code> is an arbitrary type.</li> <li>The type variables <code>vk+1...vn</code> do not occur in the types <code>t</code>, <code>s1..sk</code>, or <code>t1..tj</code>.</li> <li>
<code>C</code> is not <code>Read</code>, <code>Show</code>, <code>Typeable</code>, or <code>Data</code>. These classes should not “look through” the type or its constructor. You can still derive these classes for a newtype, but it happens in the usual way, not via this new mechanism. Confer with <a class="reference internal" href="#default-deriving-strategy"><span class="std std-ref">Default deriving strategy</span></a>.</li> <li>It is safe to coerce each of the methods of <code>C</code>. That is, the missing last argument to <code>C</code> is not used at a nominal role in any of the <code>C</code>‘s methods. (See <a class="reference internal" href="#roles"><span class="std std-ref">Roles</span></a>.)</li> <li>
<code>C</code> is allowed to have associated type families, provided they meet the requirements laid out in the section on <a class="reference internal" href="#gnd-and-associated-types"><span class="std std-ref">GND and associated types</span></a>.</li> </ul> <p>Then the derived instance declaration is of the form</p> <pre data-language="haskell">instance C t1..tj t =&gt; C t1..tj (T v1...vk)
</pre> <p>Note that if <code>C</code> does not contain any class methods, the instance context is wholly unnecessary, and as such GHC will instead generate:</p> <pre data-language="haskell">instance C t1..tj (T v1..vk)
</pre> <p>As an example which does <em>not</em> work, consider</p> <pre data-language="haskell">newtype NonMonad m s = NonMonad (State s m s) deriving Monad
</pre> <p>Here we cannot derive the instance</p> <pre data-language="haskell">instance Monad (State s m) =&gt; Monad (NonMonad m)
</pre> <p>because the type variable <code>s</code> occurs in <code>State s m</code>, and so cannot be “eta-converted” away. It is a good thing that this <code>deriving</code> clause is rejected, because <code>NonMonad m</code> is not, in fact, a monad — for the same reason. Try defining <code>&gt;&gt;=</code> with the correct type: you won’t be able to.</p> <p>Notice also that the <em>order</em> of class parameters becomes important, since we can only derive instances for the last one. If the <code>StateMonad</code> class above were instead defined as</p> <pre data-language="haskell">class StateMonad m s | m -&gt; s where ...
</pre> <p>then we would not have been able to derive an instance for the <code>Parser</code> type above. We hypothesise that multi-parameter classes usually have one “main” parameter for which deriving new instances is most interesting.</p> <p>Lastly, all of this applies only for classes other than <code>Read</code>, <code>Show</code>, <code>Typeable</code>, and <code>Data</code>, for which the stock derivation applies (section 4.3.3. of the Haskell Report). (For the standard classes <code>Eq</code>, <code>Ord</code>, <code>Ix</code>, and <code>Bounded</code> it is immaterial whether the stock method is used or the one described here.)</p>   <h3 id="gnd-and-associated-types">11.6.5.3. Associated type families</h3> <p id="associated-type-families"><a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code>GeneralizedNewtypeDeriving</code></a> also works for some type classes with associated type families. Here is an example:</p> <pre data-language="haskell">class HasRing a where
  type Ring a

newtype L1Norm a = L1Norm a
  deriving HasRing
</pre> <p>The derived <code>HasRing</code> instance would look like</p> <pre data-language="haskell">instance HasRing (L1Norm a) where
  type Ring (L1Norm a) = Ring a
</pre> <p>To be precise, if the class being derived is of the form</p> <pre data-language="haskell">class C c_1 c_2 ... c_m where
  type T1 t1_1 t1_2 ... t1_n
  ...
  type Tk tk_1 tk_2 ... tk_p
</pre> <p>and the newtype is of the form</p> <pre data-language="haskell">newtype N n_1 n_2 ... n_q = MkN &lt;rep-type&gt;
</pre> <p>then you can derive a <code>C c_1 c_2 ... c_(m-1)</code> instance for <code>N n_1 n_2 ... n_q</code>, provided that:</p> <ul> <li>
<p class="first">The type parameter <code>c_m</code> occurs once in each of the type variables of <code>T1</code> through <code>Tk</code>. Imagine a class where this condition didn’t hold. For example:</p> <pre data-language="haskell">class Bad a b where
  type B a

instance Bad Int a where
  type B Int = Char

newtype Foo a = Foo a
  deriving (Bad Int)
</pre> <p>For the derived <code>Bad Int</code> instance, GHC would need to generate something like this:</p> <pre data-language="haskell">instance Bad Int (Foo a) where
  type B Int = B ???
</pre> <p>Now we’re stuck, since we have no way to refer to <code>a</code> on the right-hand side of the <code>B</code> family instance, so this instance doesn’t really make sense in a <a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code>GeneralizedNewtypeDeriving</code></a> setting.</p> </li> <li>
<p class="first"><code>C</code> does not have any associated data families (only type families). To see why data families are forbidden, imagine the following scenario:</p> <pre data-language="haskell">class Ex a where
  data D a

instance Ex Int where
  data D Int = DInt Bool

newtype Age = MkAge Int deriving Ex
</pre> <p>For the derived <code>Ex</code> instance, GHC would need to generate something like this:</p> <pre data-language="haskell">instance Ex Age where
  data D Age = ???
</pre> <p>But it is not clear what GHC would fill in for <code>???</code>, as each data family instance must generate fresh data constructors.</p> </li> </ul> <p>If both of these conditions are met, GHC will generate this instance:</p> <pre data-language="haskell">instance C c_1 c_2 ... c_(m-1) &lt;rep-type&gt; =&gt;
         C c_1 c_2 ... c_(m-1) (N n_1 n_2 ... n_q) where
  type T1 t1_1 t1_2 ... (N n_1 n_2 ... n_q) ... t1_n
     = T1 t1_1 t1_2 ... &lt;rep-type&gt;          ... t1_n
  ...
  type Tk tk_1 tk_2 ... (N n_1 n_2 ... n_q) ... tk_p
     = Tk tk_1 tk_2 ... &lt;rep-type&gt;          ... tk_p
</pre> <p>Again, if <code>C</code> contains no class methods, the instance context will be redundant, so GHC will instead generate <code>instance C c_1 c_2 ... c_(m-1) (N n_1 n_2 ... n_q)</code>.</p> <p>Beware that in some cases, you may need to enable the <a class="reference internal" href="#extension-UndecidableInstances"><code>UndecidableInstances</code></a> extension in order to use this feature. Here’s a pathological case that illustrates why this might happen:</p> <pre data-language="haskell">class C a where
  type T a

newtype Loop = MkLoop Loop
  deriving C
</pre> <p>This will generate the derived instance:</p> <pre data-language="haskell">instance C Loop where
  type T Loop = T Loop
</pre> <p>Here, it is evident that attempting to use the type <code>T Loop</code> will throw the typechecker into an infinite loop, as its definition recurses endlessly. In other cases, you might need to enable <a class="reference internal" href="#extension-UndecidableInstances"><code>UndecidableInstances</code></a> even if the generated code won’t put the typechecker into a loop. For example:</p> <pre data-language="haskell">instance C Int where
  type C Int = Int

newtype MyInt = MyInt Int
  deriving C
</pre> <p>This will generate the derived instance:</p> <pre data-language="haskell">instance C MyInt where
  type T MyInt = T Int
</pre> <p>Although typechecking <code>T MyInt</code> will terminate, GHC’s termination checker isn’t sophisticated enough to determine this, so you’ll need to enable <a class="reference internal" href="#extension-UndecidableInstances"><code>UndecidableInstances</code></a> in order to use this derived instance. If you do go down this route, make sure you can convince yourself that all of the type family instances you’re deriving will eventually terminate if used!</p> <p>Note that <a class="reference internal" href="#extension-DerivingVia"><code>DerivingVia</code></a> (see <a class="reference internal" href="#deriving-via"><span class="std std-ref">Deriving via</span></a>) uses essentially the same specification to derive instances of associated type families as well (except that it uses the <code>via</code> type instead of the underlying <code>rep-type</code> of a newtype).</p>    <h2 id="derive-any-class">11.6.6. Deriving any other class</h2> <dl class="extension" id="deriving-any-other-class"> <dt id="extension-DeriveAnyClass">
<code>DeriveAnyClass</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10.1</td> </tr>  </table> <p>Allow use of any typeclass in <code>deriving</code> clauses.</p> </dd>
</dl> <p>With <a class="reference internal" href="#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a> you can derive any other class. The compiler will simply generate an instance declaration with no explicitly-defined methods. This is mostly useful in classes whose <a class="reference external" href="#minimal-pragma">minimal set</a> is empty, and especially when writing <a class="reference external" href="#generic-programming">generic functions</a>.</p> <p>As an example, consider a simple pretty-printer class <code>SPretty</code>, which outputs pretty strings:</p> <pre data-language="haskell">{-# LANGUAGE DefaultSignatures, DeriveAnyClass #-}

class SPretty a where
  sPpr :: a -&gt; String
  default sPpr :: Show a =&gt; a -&gt; String
  sPpr = show
</pre> <p>If a user does not provide a manual implementation for <code>sPpr</code>, then it will default to <code>show</code>. Now we can leverage the <a class="reference internal" href="#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a> extension to easily implement a <code>SPretty</code> instance for a new data type:</p> <pre data-language="haskell">data Foo = Foo deriving (Show, SPretty)
</pre> <p>The above code is equivalent to:</p> <pre data-language="haskell">data Foo = Foo deriving Show
instance SPretty Foo
</pre> <p>That is, an <code>SPretty Foo</code> instance will be created with empty implementations for all methods. Since we are using <a class="reference internal" href="#extension-DefaultSignatures"><code>DefaultSignatures</code></a> in this example, a default implementation of <code>sPpr</code> is filled in automatically.</p> <p>Note the following details</p> <ul> <li>In case you try to derive some class on a newtype, and <a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code>GeneralizedNewtypeDeriving</code></a> is also on, <a class="reference internal" href="#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a> takes precedence. </li> <li>
<p class="first">The instance context is determined by the type signatures of the derived class’s methods. For instance, if the class is:</p> <pre data-language="haskell">class Foo a where
  bar :: a -&gt; String
  default bar :: Show a =&gt; a -&gt; String
  bar = show

  baz :: a -&gt; a -&gt; Bool
  default baz :: Ord a =&gt; a -&gt; a -&gt; Bool
  baz x y = compare x y == EQ
</pre> <p>And you attempt to derive it using <a class="reference internal" href="#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a>:</p> <pre data-language="haskell">instance Eq   a =&gt; Eq   (Option a) where ...
instance Ord  a =&gt; Ord  (Option a) where ...
instance Show a =&gt; Show (Option a) where ...

data Option a = None | Some a deriving Foo
</pre> <p>Then the derived <code>Foo</code> instance will be:</p> <pre data-language="haskell">instance (Show a, Ord a) =&gt; Foo (Option a)
</pre> <p>Since the default type signatures for <code>bar</code> and <code>baz</code> require <code>Show a</code> and <code>Ord a</code> constraints, respectively.</p> <p>Constraints on the non-default type signatures can play a role in inferring the instance context as well. For example, if you have this class:</p> <pre data-language="haskell">class HigherEq f where
  (==#) :: f a -&gt; f a -&gt; Bool
  default (==#) :: Eq (f a) =&gt; f a -&gt; f a -&gt; Bool
  x ==# y = (x == y)
</pre> <p>And you tried to derive an instance for it:</p> <pre data-language="haskell">instance Eq a =&gt; Eq (Option a) where ...
data Option a = None | Some a deriving HigherEq
</pre> <p>Then it will fail with an error to the effect of:</p> <pre data-language="haskell">No instance for (Eq a)
    arising from the 'deriving' clause of a data type declaration
</pre> <p>That is because we require an <code>Eq (Option a)</code> instance from the default type signature for <code>(==#)</code>, which in turn requires an <code>Eq a</code> instance, which we don’t have in scope. But if you tweak the definition of <code>HigherEq</code> slightly:</p> <pre data-language="haskell">class HigherEq f where
  (==#) :: Eq a =&gt; f a -&gt; f a -&gt; Bool
  default (==#) :: Eq (f a) =&gt; f a -&gt; f a -&gt; Bool
  x ==# y = (x == y)
</pre> <p>Then it becomes possible to derive a <code>HigherEq Option</code> instance. Note that the only difference is that now the non-default type signature for <code>(==#)</code> brings in an <code>Eq a</code> constraint. Constraints from non-default type signatures never appear in the derived instance context itself, but they can be used to discharge obligations that are demanded by the default type signatures. In the example above, the default type signature demanded an <code>Eq a</code> instance, and the non-default signature was able to satisfy that request, so the derived instance is simply:</p> <pre data-language="haskell">instance HigherEq Option
</pre> </li> <li>
<p class="first"><a class="reference internal" href="#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a> can be used with partially applied classes, such as</p> <pre data-language="haskell">data T a = MKT a deriving( D Int )
</pre> <p>which generates</p> <pre data-language="haskell">instance D Int a =&gt; D Int (T a) where {}
</pre> </li> <li>
<p class="first"><a class="reference internal" href="#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a> can be used to fill in default instances for associated type families:</p> <pre data-language="haskell">{-# LANGUAGE DeriveAnyClass, TypeFamilies #-}

class Sizable a where
  type Size a
  type Size a = Int

data Bar = Bar deriving Sizable

doubleBarSize :: Size Bar -&gt; Size Bar
doubleBarSize s = 2*s
</pre> <p>The <code>deriving( Sizable )</code> is equivalent to saying</p> <pre data-language="haskell">instance Sizeable Bar where {}
</pre> <p>and then the normal rules for filling in associated types from the default will apply, making <code>Size Bar</code> equal to <code>Int</code>.</p> </li> </ul>   <h2 id="id24">11.6.7. Deriving strategies</h2> <dl class="extension" id="deriving-strategies"> <dt id="extension-DerivingStrategies">
<code>DerivingStrategies</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.2.1</td> </tr>  </table> <p>Allow multiple <code>deriving</code>, each optionally qualified with a <em>strategy</em>.</p> </dd>
</dl> <p>In most scenarios, every <code>deriving</code> statement generates a typeclass instance in an unambiguous fashion. There is a corner case, however, where simultaneously enabling both the <a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code>GeneralizedNewtypeDeriving</code></a> and <a class="reference internal" href="#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a> extensions can make deriving become ambiguous. Consider the following example</p> <pre data-language="haskell">{-# LANGUAGE DeriveAnyClass, GeneralizedNewtypeDeriving #-}
newtype Foo = MkFoo Bar deriving C
</pre> <p>One could either pick the <code>DeriveAnyClass</code> approach to deriving <code>C</code> or the <code>GeneralizedNewtypeDeriving</code> approach to deriving <code>C</code>, both of which would be equally as valid. GHC defaults to favoring <code>DeriveAnyClass</code> in such a dispute, but this is not a satisfying solution, since that leaves users unable to use both language extensions in a single module.</p> <p>To make this more robust, GHC has a notion of deriving strategies, which allow the user to explicitly request which approach to use when deriving an instance. To enable this feature, one must enable the <a class="reference internal" href="#extension-DerivingStrategies"><code>DerivingStrategies</code></a> language extension. A deriving strategy can be specified in a deriving clause</p> <pre data-language="haskell">newtype Foo = MkFoo Bar
  deriving newtype C
</pre> <p>Or in a standalone deriving declaration</p> <pre data-language="haskell">deriving anyclass instance C Foo
</pre> <p><a class="reference internal" href="#extension-DerivingStrategies"><code>DerivingStrategies</code></a> also allows the use of multiple deriving clauses per data declaration so that a user can derive some instance with one deriving strategy and other instances with another deriving strategy. For example</p> <pre data-language="haskell">newtype Baz = Baz Quux
  deriving          (Eq, Ord)
  deriving stock    (Read, Show)
  deriving newtype  (Num, Floating)
  deriving anyclass C
</pre> <p>Currently, the deriving strategies are:</p> <ul class="simple"> <li>
<code>stock</code>: Have GHC implement a “standard” instance for a data type, if possible (e.g., <code>Eq</code>, <code>Ord</code>, <code>Generic</code>, <code>Data</code>, <code>Functor</code>, etc.)</li> <li>
<code>anyclass</code>: Use <a class="reference internal" href="#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a> (see <a class="reference internal" href="#derive-any-class"><span class="std std-ref">Deriving any other class</span></a>)</li> <li>
<dl class="first docutils"> <dt>
<code>newtype: Use</code> <a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code>GeneralizedNewtypeDeriving</code></a>
</dt> <dd>(see <a class="reference internal" href="#newtype-deriving"><span class="std std-ref">Generalised derived instances for newtypes</span></a>)</dd> </dl> </li> <li>
<code>via</code>: Use <a class="reference internal" href="#extension-DerivingVia"><code>DerivingVia</code></a> (see <a class="reference internal" href="#deriving-via"><span class="std std-ref">Deriving via</span></a>)</li> </ul>  <h3 id="id25">11.6.7.1. Default deriving strategy</h3> <p id="default-deriving-strategy">If an explicit deriving strategy is not given, multiple strategies may apply. In that case, GHC chooses the strategy as follows:</p> <ol class="arabic"> <li>
<p class="first">Stock type classes, i.e. those specified in the report and those enabled by <a class="reference external" href="#deriving-extra">language extensions</a>, are derived using the <code>stock</code> strategy, with the following exception:</p> <ul class="simple"> <li>For newtypes, <code>Eq</code>, <code>Ord</code>, <code>Ix</code> and <code>Bounded</code> are always derived using the <code>newtype</code> strategy, even without <code>GeneralizedNewtypeDeriving</code> enabled. (There should be no observable difference to instances derived using the stock strategy.)</li> <li>Also for newtypes, <code>Functor</code>, <code>Foldable</code> and <code>Enum</code> are derived using the <code>newtype</code> strategy if <code>GeneralizedNewtypeDeriving</code> is enabled and the derivation succeeds.</li> </ul> </li> <li>
<p class="first">For other any type class:</p> <ol class="arabic simple"> <li>When <code>DeriveAnyClass</code> is enabled, use <code>anyclass</code>.</li> <li>When <code>GeneralizedNewtypeDeriving</code> is enabled and we are deriving for a newtype, then use <code>newytype</code>.</li> </ol> <p>If both rules apply to a deriving clause, then <code>anyclass</code> is used and the user is warned about the ambiguity. The warning can be avoided by explicitly stating the desired deriving strategy.</p> </li> </ol>    <h2 id="id26">11.6.8. Deriving via</h2> <dl class="extension" id="deriving-via"> <dt id="extension-DerivingVia">
<code>DerivingVia</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-DerivingStrategies"><code>DerivingStrategies</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.6.1</td> </tr>  </table> </dd>
</dl> <p>This allows <code>deriving</code> a class instance for a type by specifying another type of equal runtime representation (such that there exists a <code>Coercible</code> instance between the two: see <a class="reference internal" href="#coercible"><span class="std std-ref">The Coercible constraint</span></a>) that is already an instance of the that class.</p> <p><a class="reference internal" href="#extension-DerivingVia"><code>DerivingVia</code></a> is indicated by the use of the <code>via</code> deriving strategy. <code>via</code> requires specifying another type (the <code>via</code> type) to <code>coerce</code> through. For example, this code:</p> <pre data-language="haskell">{-# LANGUAGE DerivingVia #-}

import Numeric

newtype Hex a = Hex a

instance (Integral a, Show a) =&gt; Show (Hex a) where
  show (Hex a) = "0x" ++ showHex a ""

newtype Unicode = U Int
  deriving Show
    via (Hex Int)

-- &gt;&gt;&gt; euroSign
-- 0x20ac
euroSign :: Unicode
euroSign = U 0x20ac
</pre> <p>Generates the following instance</p> <pre data-language="haskell">instance Show Unicode where
  show :: Unicode -&gt; String
  show = Data.Coerce.coerce
    @(Hex Int -&gt; String)
    @(Unicode -&gt; String)
    show
</pre> <p>This extension generalizes <a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code>GeneralizedNewtypeDeriving</code></a>. To derive <code>Num Unicode</code> with GND (<code>deriving newtype Num</code>) it must reuse the <code>Num Int</code> instance. With <code>DerivingVia</code>, we can explicitly specify the representation type <code>Int</code>:</p> <pre data-language="haskell">newtype Unicode = U Int
  deriving Num
    via Int

  deriving Show
    via (Hex Int)

euroSign :: Unicode
euroSign = 0x20ac
</pre> <p>Code duplication is common in instance declarations. A familiar pattern is lifting operations over an <code>Applicative</code> functor. Instead of having catch-all instances for <code>f a</code> which overlap with all other such instances, like so:</p> <pre data-language="haskell">instance (Applicative f, Semigroup a) =&gt; Semigroup (f a) ..
instance (Applicative f, Monoid    a) =&gt; Monoid    (f a) ..
</pre> <p>We can instead create a newtype <code>App</code> (where <code>App f a</code> and <code>f a</code> are represented the same in memory) and use <a class="reference internal" href="#extension-DerivingVia"><code>DerivingVia</code></a> to explicitly enable uses of this pattern:</p> <pre data-language="haskell">{-# LANGUAGE DerivingVia, DeriveFunctor, GeneralizedNewtypeDeriving #-}

import Control.Applicative

newtype App f a = App (f a) deriving newtype (Functor, Applicative)

instance (Applicative f, Semigroup a) =&gt; Semigroup (App f a) where
  (&lt;&gt;) = liftA2 (&lt;&gt;)

instance (Applicative f, Monoid a) =&gt; Monoid (App f a) where
  mempty = pure mempty

data Pair a = MkPair a a
  deriving stock
    Functor

  deriving (Semigroup, Monoid)
    via (App Pair a)

instance Applicative Pair where
  pure a = MkPair a a

  MkPair f g &lt;*&gt; MkPair a b = MkPair (f a) (g b)
</pre> <p>Note that the <code>via</code> type does not have to be a <code>newtype</code>. The only restriction is that it is coercible with the original data type. This means there can be arbitrary nesting of newtypes, as in the following example:</p> <pre data-language="haskell">newtype Kleisli m a b = (a -&gt; m b)
  deriving (Semigroup, Monoid)
    via (a -&gt; App m b)
</pre> <p>Here we make use of the <code>Monoid ((-&gt;) a)</code> instance.</p>    <h1 id="id27">11.7. Pattern synonyms</h1> <dl class="extension" id="pattern-synonyms"> <dt id="extension-PatternSynonyms">
<code>PatternSynonyms</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8.1</td> </tr>  </table> <p>Allow the definition of pattern synonyms.</p> </dd>
</dl> <p>Pattern synonyms are enabled by the language extension <a class="reference internal" href="#extension-PatternSynonyms"><code>PatternSynonyms</code></a>, which is required for defining them, but <em>not</em> for using them. More information and examples of pattern synonyms can be found on the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/PatternSynonyms">Wiki page</a>.</p> <p>Pattern synonyms enable giving names to parametrized pattern schemes. They can also be thought of as abstract constructors that don’t have a bearing on data representation. For example, in a programming language implementation, we might represent types of the language as follows:</p> <pre data-language="haskell">data Type = App String [Type]
</pre> <p>Here are some examples of using said representation. Consider a few types of the <code>Type</code> universe encoded like this:</p> <pre data-language="haskell">App "-&gt;" [t1, t2]          -- t1 -&gt; t2
App "Int" []               -- Int
App "Maybe" [App "Int" []] -- Maybe Int
</pre> <p>This representation is very generic in that no types are given special treatment. However, some functions might need to handle some known types specially, for example the following two functions collect all argument types of (nested) arrow types, and recognize the <code>Int</code> type, respectively:</p> <pre data-language="haskell">collectArgs :: Type -&gt; [Type]
collectArgs (App "-&gt;" [t1, t2]) = t1 : collectArgs t2
collectArgs _                   = []

isInt :: Type -&gt; Bool
isInt (App "Int" []) = True
isInt _              = False
</pre> <p>Matching on <code>App</code> directly is both hard to read and error prone to write. And the situation is even worse when the matching is nested:</p> <pre data-language="haskell">isIntEndo :: Type -&gt; Bool
isIntEndo (App "-&gt;" [App "Int" [], App "Int" []]) = True
isIntEndo _                                       = False
</pre> <p>Pattern synonyms permit abstracting from the representation to expose matchers that behave in a constructor-like manner with respect to pattern matching. We can create pattern synonyms for the known types we care about, without committing the representation to them (note that these don’t have to be defined in the same module as the <code>Type</code> type):</p> <pre data-language="haskell">pattern Arrow t1 t2 = App "-&gt;"    [t1, t2]
pattern Int         = App "Int"   []
pattern Maybe t     = App "Maybe" [t]
</pre> <p>Which enables us to rewrite our functions in a much cleaner style:</p> <pre data-language="haskell">collectArgs :: Type -&gt; [Type]
collectArgs (Arrow t1 t2) = t1 : collectArgs t2
collectArgs _             = []

isInt :: Type -&gt; Bool
isInt Int = True
isInt _   = False

isIntEndo :: Type -&gt; Bool
isIntEndo (Arrow Int Int) = True
isIntEndo _               = False
</pre> <p>In general there are three kinds of pattern synonyms. Unidirectional, bidirectional and explicitly bidirectional. The examples given so far are examples of bidirectional pattern synonyms. A bidirectional synonym behaves the same as an ordinary data constructor. We can use it in a pattern context to deconstruct values and in an expression context to construct values. For example, we can construct the value <code>intEndo</code> using the pattern synonyms <code>Arrow</code> and <code>Int</code> as defined previously.</p> <pre data-language="haskell">intEndo :: Type
intEndo = Arrow Int Int
</pre> <p>This example is equivalent to the much more complicated construction if we had directly used the <code>Type</code> constructors.</p> <pre data-language="haskell">intEndo :: Type
intEndo = App "-&gt;" [App "Int" [], App "Int" []]
</pre> <p>Unidirectional synonyms can only be used in a pattern context and are defined as follows:</p> <pre data-language="haskell">pattern Head x &lt;- x:xs
</pre> <p>In this case, <code>Head</code> ⟨x⟩ cannot be used in expressions, only patterns, since it wouldn’t specify a value for the ⟨xs⟩ on the right-hand side. However, we can define an explicitly bidirectional pattern synonym by separately specifying how to construct and deconstruct a type. The syntax for doing this is as follows:</p> <pre data-language="haskell">pattern HeadC x &lt;- x:xs where
  HeadC x = [x]
</pre> <p>We can then use <code>HeadC</code> in both expression and pattern contexts. In a pattern context it will match the head of any list with length at least one. In an expression context it will construct a singleton list.</p> <p>Explicitly bidirectional pattern synonyms offer greater flexibility than implicitly bidirectional ones in terms of the syntax that is permitted. For instance, the following is not a legal implicitly bidirectional pattern synonym:</p> <pre data-language="haskell">pattern StrictJust a = Just !a
</pre> <p>This is illegal because the use of <a class="reference internal" href="#extension-BangPatterns"><code>BangPatterns</code></a> on the right-hand sides prevents it from being a well formed expression. However, constructing a strict pattern synonym is quite possible with an explicitly bidirectional pattern synonym:</p> <pre data-language="haskell">pattern StrictJust a &lt;- Just !a where
  StrictJust !a = Just a
</pre> <p>Constructing an explicitly bidirectional pattern synonym also:</p> <ul class="simple"> <li>can create different data constructors from the underlying data type, not just the one appearing in the pattern match;</li> <li>can call any functions or conditional logic, especially validation, of course providing it constructs a result of the right type;</li> <li>can use guards on the lhs of the <code>=</code>;</li> <li>can have multiple equations.</li> </ul> <p>For example:</p> <pre data-language="haskell">data PosNeg = Pos Int | Neg Int
pattern Smarter{ nonneg } &lt;- Pos nonneg  where
  Smarter x = if x &gt;= 0 then (Pos x) else (Neg x)
</pre> <p>Or using guards:</p> <pre data-language="haskell">pattern Smarter{ nonneg } &lt;- Pos nonneg  where
  Smarter x | x &gt;= 0    = (Pos x)
            | otherwise = (Neg x)
</pre> <p>There is an extensive Haskell folk art of <a class="reference external" href="https://wiki.haskell.org/Smart_constructor">smart constructors</a>, essentially functions that wrap validation around a constructor, and avoid exposing its representation. The downside is that the underlying constructor can’t be used as a matcher. Pattern synonyms can be used as genuinely smart constructors, for both validation and matching.</p> <p>The table below summarises where each kind of pattern synonym can be used.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Context</th> <th class="head">Unidirectional</th> <th class="head">Bidirectional</th> <th class="head">Explicitly Bidirectional</th> </tr> </thead>  <tr>
<td>Pattern</td> <td>Yes</td> <td>Yes</td> <td>Yes</td> </tr> <tr>
<td>Expression</td> <td>No</td> <td>Yes (Inferred)</td> <td>Yes (Explicit)</td> </tr>  </table>  <h2 id="record-patsyn">11.7.1. Record Pattern Synonyms</h2> <p id="record-pattern-synonyms">It is also possible to define pattern synonyms which behave just like record constructors. The syntax for doing this is as follows:</p> <pre data-language="haskell">pattern Point :: Int -&gt; Int -&gt; (Int, Int)
pattern Point{x, y} = (x, y)
</pre> <p>The idea is that we can then use <code>Point</code> just as if we had defined a new datatype <code>MyPoint</code> with two fields <code>x</code> and <code>y</code>.</p> <pre data-language="haskell">data MyPoint = Point { x :: Int, y :: Int }
</pre> <p>Whilst a normal pattern synonym can be used in two ways, there are then seven ways in which to use <code>Point</code>. Precisely the ways in which a normal record constructor can be used.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Usage</th> <th class="head">Example</th> </tr> </thead>  <tr>
<td>As a constructor</td> <td><code>zero = Point 0 0</code></td> </tr> <tr>
<td>As a constructor with record syntax</td> <td><code>zero = Point { x = 0, y = 0}</code></td> </tr> <tr>
<td>In a pattern context</td> <td><code>isZero (Point 0 0) = True</code></td> </tr> <tr>
<td>In a pattern context with record syntax</td> <td><code>isZero (Point { x = 0, y = 0 }</code></td> </tr> <tr>
<td>In a pattern context with field puns</td> <td><code>getX (Point {x}) = x</code></td> </tr> <tr>
<td>In a record update</td> <td><code>(0, 0) { x = 1 } == (1,0)</code></td> </tr> <tr>
<td>Using record selectors</td> <td><code>x (0,0) == 0</code></td> </tr>  </table> <p>For a unidirectional record pattern synonym we define record selectors but do not allow record updates or construction.</p> <p>The syntax and semantics of pattern synonyms are elaborated in the following subsections. There are also lots more details in the <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf">paper</a>.</p> <p>See the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/PatternSynonyms">Wiki page</a> for more details.</p>   <h2 id="syntax-and-scoping-of-pattern-synonyms">11.7.2. Syntax and scoping of pattern synonyms</h2> <p>A pattern synonym declaration can be either unidirectional, bidirectional or explicitly bidirectional. The syntax for unidirectional pattern synonyms is:</p> <pre data-language="haskell">pattern pat_lhs &lt;- pat
</pre> <p>the syntax for bidirectional pattern synonyms is:</p> <pre data-language="haskell">pattern pat_lhs = pat
</pre> <p>and the syntax for explicitly bidirectional pattern synonyms is:</p> <pre data-language="haskell">pattern pat_lhs &lt;- pat where
  pat_lhs = expr                      -- lhs restricted, see below
</pre> <p>We can define either prefix, infix or record pattern synonyms by modifying the form of <code>pat_lhs</code>. The syntax for these is as follows:</p> <table class="docutils">   <tr>
<td>Prefix</td> <td><code>Name args</code></td> </tr> <tr>
<td>Infix</td> <td>
<code>arg1 `Name` arg2</code> or <code>arg1 op arg2</code>
</td> </tr> <tr>
<td>Record</td> <td><code>Name{arg1,arg2,...,argn}</code></td> </tr>  </table> <p>The <code>pat_lhs</code> for explicitly bidirectional construction cannot use Record syntax. (Because the rhs <em>expr</em> might be constructing different data constructors.) It can use guards with multiple equations.</p> <p>Pattern synonym declarations can only occur in the top level of a module. In particular, they are not allowed as local definitions.</p> <p>The variables in the left-hand side of the definition are bound by the pattern on the right-hand side. For bidirectional pattern synonyms, all the variables of the right-hand side must also occur on the left-hand side; also, wildcard patterns and view patterns are not allowed. For unidirectional and explicitly bidirectional pattern synonyms, there is no restriction on the right-hand side pattern.</p> <p>Pattern synonyms cannot be defined recursively.</p> <p><a class="reference internal" href="#complete-pragma"><span class="std std-ref">COMPLETE pragmas</span></a> can be specified in order to tell the pattern match exhaustiveness checker that a set of pattern synonyms is complete.</p>   <h2 id="patsyn-impexp">11.7.3. Import and export of pattern synonyms</h2> <p id="import-and-export-of-pattern-synonyms">The name of the pattern synonym is in the same namespace as proper data constructors. Like normal data constructors, pattern synonyms can be imported and exported through association with a type constructor or independently.</p> <p>To export them on their own, in an export or import specification, you must prefix pattern names with the <code>pattern</code> keyword, e.g.:</p> <pre data-language="haskell">module Example (pattern Zero) where

data MyNum = MkNum Int

pattern Zero :: MyNum
pattern Zero = MkNum 0
</pre> <p>Without the <code>pattern</code> prefix, <code>Zero</code> would be interpreted as a type constructor in the export list.</p> <p>You may also use the <code>pattern</code> keyword in an import/export specification to import or export an ordinary data constructor. For example:</p> <pre data-language="haskell">import Data.Maybe( pattern Just )
</pre> <p>would bring into scope the data constructor <code>Just</code> from the <code>Maybe</code> type, without also bringing the type constructor <code>Maybe</code> into scope.</p> <p>To bundle a pattern synonym with a type constructor, we list the pattern synonym in the export list of a module which exports the type constructor. For example, to bundle <code>Zero</code> with <code>MyNum</code> we could write the following:</p> <pre data-language="haskell">module Example ( MyNum(Zero) ) where
</pre> <p>If a module was then to import <code>MyNum</code> from <code>Example</code>, it would also import the pattern synonym <code>Zero</code>.</p> <p>It is also possible to use the special token <code>..</code> in an export list to mean all currently bundled constructors. For example, we could write:</p> <pre data-language="haskell">module Example ( MyNum(.., Zero) ) where
</pre> <p>in which case, <code>Example</code> would export the type constructor <code>MyNum</code> with the data constructor <code>MkNum</code> and also the pattern synonym <code>Zero</code>.</p> <p>Bundled pattern synonyms are type checked to ensure that they are of the same type as the type constructor which they are bundled with. A pattern synonym <code>P</code> can not be bundled with a type constructor <code>T</code> if <code>P</code>‘s type is visibly incompatible with <code>T</code>.</p> <p>A module which imports <code>MyNum(..)</code> from <code>Example</code> and then re-exports <code>MyNum(..)</code> will also export any pattern synonyms bundled with <code>MyNum</code> in <code>Example</code>. A more complete specification can be found on the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/PatternSynonyms/AssociatingSynonyms">wiki.</a></p>   <h2 id="patsyn-typing">11.7.4. Typing of pattern synonyms</h2> <p id="typing-of-pattern-synonyms">Given a pattern synonym definition of the form</p> <pre data-language="haskell">pattern P var1 var2 ... varN &lt;- pat
</pre> <p>it is assigned a <em>pattern type</em> of the form</p> <pre data-language="haskell">pattern P :: CReq =&gt; CProv =&gt; t1 -&gt; t2 -&gt; ... -&gt; tN -&gt; t
</pre> <p>where ⟨CReq⟩ and ⟨CProv⟩ are type contexts, and ⟨t1⟩, ⟨t2⟩, ..., ⟨tN⟩ and ⟨t⟩ are types. Notice the unusual form of the type, with two contexts ⟨CReq⟩ and ⟨CProv⟩:</p> <ul class="simple"> <li>⟨CReq⟩ are the constraints <em>required</em> to match the pattern.</li> <li>⟨CProv⟩ are the constraints <em>made available (provided)</em> by a successful pattern match.</li> </ul> <p>For example, consider</p> <pre data-language="haskell">data T a where
  MkT :: (Show b) =&gt; a -&gt; b -&gt; T a

f1 :: (Num a, Eq a) =&gt; T a -&gt; String
f1 (MkT 42 x) = show x

pattern ExNumPat :: (Num a, Eq a) =&gt; (Show b) =&gt; b -&gt; T a
pattern ExNumPat x = MkT 42 x

f2 :: (Eq a, Num a) =&gt; T a -&gt; String
f2 (ExNumPat x) = show x
</pre> <p>Here <code>f1</code> does not use pattern synonyms. To match against the numeric pattern <code>42</code> <em>requires</em> the caller to satisfy the constraints <code>(Num a, Eq a)</code>, so they appear in <code>f1</code>‘s type. The call to <code>show</code> generates a <code>(Show b)</code> constraint, where <code>b</code> is an existentially type variable bound by the pattern match on <code>MkT</code>. But the same pattern match also <em>provides</em> the constraint <code>(Show b)</code> (see <code>MkT</code>‘s type), and so all is well.</p> <p>Exactly the same reasoning applies to <code>ExNumPat</code>: matching against <code>ExNumPat</code> <em>requires</em> the constraints <code>(Num a, Eq a)</code>, and <em>provides</em> the constraint <code>(Show b)</code>.</p> <p>Note also the following points</p> <ul> <li>In the common case where <code>CProv</code> is empty, (i.e., <code>()</code>), it can be omitted altogether in the above pattern type signature for <code>P</code>. </li> <li>
<p class="first">However, if <code>CProv</code> is non-empty, while <code>CReq</code> is, the above pattern type signature for <code>P</code> must be specified as</p> <pre data-language="haskell">P :: () =&gt; CProv =&gt; t1 -&gt; t2 -&gt; .. -&gt; tN -&gt; t
</pre> </li> <li>The GHCi <a class="reference internal" href="ghci#ghci-cmd-:info"><code>:info</code></a> command shows pattern types in this format. </li> <li>
<p class="first">You may specify an explicit <em>pattern signature</em>, as we did for <code>ExNumPat</code> above, to specify the type of a pattern, just as you can for a function. As usual, the type signature can be less polymorphic than the inferred type. For example</p> <pre data-language="haskell">-- Inferred type would be 'a -&gt; [a]'
pattern SinglePair :: (a, a) -&gt; [(a, a)]
pattern SinglePair x = [x]
</pre> <p>Just like signatures on value-level bindings, pattern synonym signatures can apply to more than one pattern. For instance,</p> <pre data-language="haskell">pattern Left', Right' :: a -&gt; Either a a
pattern Left' x  = Left x
pattern Right' x = Right x
</pre> </li> <li>
<p class="first">The rules for lexically-scoped type variables (see <a class="reference internal" href="#scoped-type-variables"><span class="std std-ref">Lexically scoped type variables</span></a>) apply to pattern-synonym signatures. As those rules specify, only the type variables from an explicit, syntactically-visible outer <code>forall</code> (the universals) scope over the definition of the pattern synonym; the existentials, bound by the inner forall, do not. For example</p> <pre data-language="haskell">data T a where
   MkT :: Bool -&gt; b -&gt; (b-&gt;Int) -&gt; a -&gt; T a

pattern P :: forall a. forall b. b -&gt; (b-&gt;Int) -&gt; a -&gt; T a
pattern P x y v &lt;- MkT True x y (v::a)
</pre> <p>Here the universal type variable <code>a</code> scopes over the definition of <code>P</code>, but the existential <code>b</code> does not. (c.f. discussion on Trac #14998.)</p> </li> <li>
<p class="first">For a bidirectional pattern synonym, a use of the pattern synonym as an expression has the type</p> <pre data-language="haskell">(CReq, CProv) =&gt; t1 -&gt; t2 -&gt; ... -&gt; tN -&gt; t
</pre> <p>So in the previous example, when used in an expression, <code>ExNumPat</code> has type</p> <pre data-language="haskell">ExNumPat :: (Num a, Eq a, Show b) =&gt; b -&gt; T t
</pre> <p>Notice that this is a tiny bit more restrictive than the expression <code>MkT 42 x</code> which would not require <code>(Eq a)</code>.</p> </li> <li>
<p class="first">Consider these two pattern synonyms:</p> <pre data-language="haskell">data S a where
   S1 :: Bool -&gt; S Bool

pattern P1 :: Bool -&gt; Maybe Bool
pattern P1 b = Just b

pattern P2 :: () =&gt; (b ~ Bool) =&gt; Bool -&gt; S b
pattern P2 b = S1 b

f :: Maybe a -&gt; String
f (P1 x) = "no no no"     -- Type-incorrect

g :: S a -&gt; String
g (P2 b) = "yes yes yes"  -- Fine
</pre> <p>Pattern <code>P1</code> can only match against a value of type <code>Maybe Bool</code>, so function <code>f</code> is rejected because the type signature is <code>Maybe a</code>. (To see this, imagine expanding the pattern synonym.)</p> <p>On the other hand, function <code>g</code> works fine, because matching against <code>P2</code> (which wraps the GADT <code>S</code>) provides the local equality <code>(a~Bool)</code>. If you were to give an explicit pattern signature <code>P2 :: Bool -&gt; S Bool</code>, then <code>P2</code> would become less polymorphic, and would behave exactly like <code>P1</code> so that <code>g</code> would then be rejected.</p> <p>In short, if you want GADT-like behaviour for pattern synonyms, then (unlike concrete data constructors like <code>S1</code>) you must write its type with explicit provided equalities. For a concrete data constructor like <code>S1</code> you can write its type signature as either <code>S1 :: Bool -&gt; S Bool</code> or <code>S1 :: (b~Bool) =&gt; Bool -&gt; S b</code>; the two are equivalent. Not so for pattern synonyms: the two forms are different, in order to distinguish the two cases above. (See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/9953">Issue #9953</a> for discussion of this choice.)</p> </li> </ul>   <h2 id="matching-of-pattern-synonyms">11.7.5. Matching of pattern synonyms</h2> <p>A pattern synonym occurrence in a pattern is evaluated by first matching against the pattern synonym itself, and then on the argument patterns.</p> <p>More precisely, the semantics of pattern matching is given in <a class="reference external" href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17">Section 3.17 of the Haskell 2010 report</a>. To the informal semantics in Section 3.17.2 we add this extra rule:</p> <ul class="simple"> <li>If the pattern is a constructor pattern <code>(P p1 ... pn)</code>, where <code>P</code> is a pattern synonym defined by <code>P x1 ... xn = p</code> or <code>P x1 ... xn &lt;- p</code>, then:<ol class="loweralpha"> <li>Match the value <code>v</code> against <code>p</code>. If this match fails or diverges, so does the whole (pattern synonym) match. Otherwise the match against <code>p</code> must bind the variables <code>x1 ... xn</code>; let them be bound to values <code>v1 ... vn</code>.</li> <li>Match <code>v1</code> against <code>p1</code>, <code>v2</code> against <code>p2</code> and so on. If any of these matches fail or diverge, so does the whole match.</li> <li>If all the matches against the <code>pi</code> succeed, the match succeeds, binding the variables bound by the <code>pi</code> . (The <code>xi</code> are not bound; they remain local to the pattern synonym declaration.)</li> </ol> </li> </ul> <p>For example, in the following program, <code>f</code> and <code>f'</code> are equivalent:</p> <pre data-language="haskell">pattern Pair x y &lt;- [x, y]

f (Pair True True) = True
f _                = False

f' [x, y] | True &lt;- x, True &lt;- y = True
f' _                              = False
</pre> <p>Note that the strictness of <code>f</code> differs from that of <code>g</code> defined below:</p> <pre data-language="none">g [True, True] = True
g _            = False

*Main&gt; f (False:undefined)
*** Exception: Prelude.undefined
*Main&gt; g (False:undefined)
False
</pre>    <h1 id="type-class-extensions">11.8. Class and instances declarations</h1>  <h2 id="multi-param-type-classes">11.8.1. Class declarations</h2> <p id="class-and-instances-declarations">This section, and the next one, documents GHC’s type-class extensions. There’s lots of background in the paper <a class="reference external" href="http://research.microsoft.com/~simonpj/Papers/type-class-design-space/">Type classes: exploring the design space</a> (Simon Peyton Jones, Mark Jones, Erik Meijer).</p>  <h3 id="multi-parameter-type-classes">11.8.1.1. Multi-parameter type classes</h3> <dl class="extension"> <dt id="extension-MultiParamTypeClasses">
<code>MultiParamTypeClasses</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-ConstrainedClassMethods"><code>ConstrainedClassMethods</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow the definition of typeclasses with more than one parameter.</p> </dd>
</dl> <p>Multi-parameter type classes are permitted, with extension <a class="reference internal" href="#extension-MultiParamTypeClasses"><code>MultiParamTypeClasses</code></a>. For example:</p> <pre data-language="haskell">class Collection c a where
    union :: c a -&gt; c a -&gt; c a
    ...etc.
</pre>   <h3 id="superclass-rules">11.8.1.2. The superclasses of a class declaration</h3> <dl class="extension" id="the-superclasses-of-a-class-declaration"> <dt id="extension-FlexibleContexts">
<code>FlexibleContexts</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow the use of complex constraints in class declaration contexts.</p> </dd>
</dl> <p>In Haskell 98 the context of a class declaration (which introduces superclasses) must be simple; that is, each predicate must consist of a class applied to type variables. The extension <a class="reference internal" href="#extension-FlexibleContexts"><code>FlexibleContexts</code></a> (<a class="reference internal" href="#flexible-contexts"><span class="std std-ref">The context of a type signature</span></a>) lifts this restriction, so that the only restriction on the context in a class declaration is that the class hierarchy must be acyclic. So these class declarations are OK:</p> <pre data-language="haskell">class Functor (m k) =&gt; FiniteMap m k where
  ...

class (Monad m, Monad (t m)) =&gt; Transform t m where
  lift :: m a -&gt; (t m) a
</pre> <p>As in Haskell 98, the class hierarchy must be acyclic. However, the definition of “acyclic” involves only the superclass relationships. For example, this is okay:</p> <pre data-language="haskell">class C a where
  op :: D b =&gt; a -&gt; b -&gt; b

class C a =&gt; D a where ...
</pre> <p>Here, <code>C</code> is a superclass of <code>D</code>, but it’s OK for a class operation <code>op</code> of <code>C</code> to mention <code>D</code>. (It would not be OK for <code>D</code> to be a superclass of <code>C</code>.)</p> <p>With the extension that adds a <a class="reference external" href="#constraint-kind">kind of constraints</a>, you can write more exotic superclass definitions. The superclass cycle check is even more liberal in these case. For example, this is OK:</p> <pre data-language="haskell">class A cls c where
  meth :: cls c =&gt; c -&gt; c

class A B c =&gt; B c where
</pre> <p>A superclass context for a class <code>C</code> is allowed if, after expanding type synonyms to their right-hand-sides, and uses of classes (other than <code>C</code>) to their superclasses, <code>C</code> does not occur syntactically in the context.</p>   <h3 id="class-method-types">11.8.1.3. Constrained class method types</h3> <dl class="extension" id="constrained-class-method-types"> <dt id="extension-ConstrainedClassMethods">
<code>ConstrainedClassMethods</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allows the definition of further constraints on individual class methods.</p> </dd>
</dl> <p>Haskell 98 prohibits class method types to mention constraints on the class type variable, thus:</p> <pre data-language="haskell">class Seq s a where
  fromList :: [a] -&gt; s a
  elem     :: Eq a =&gt; a -&gt; s a -&gt; Bool
</pre> <p>The type of <code>elem</code> is illegal in Haskell 98, because it contains the constraint <code>Eq a</code>, which constrains only the class type variable (in this case <code>a</code>). this case <code>a</code>). More precisely, a constraint in a class method signature is rejected if</p> <ul> <li>
<p class="first">The constraint mentions at least one type variable. So this is allowed:</p> <pre data-language="haskell">class C a where
  op1 :: HasCallStack =&gt; a -&gt; a
  op2 :: (?x::Int) =&gt; Int -&gt; a
</pre> </li> <li>
<p class="first">All of the type variables mentioned are bound by the class declaration, and none is locally quantified. Examples:</p> <pre data-language="haskell">class C a where
  op3 :: Eq a =&gt; a -&gt; a    -- Rejected: constrains class variable only
  op4 :: D b =&gt; a -&gt; b     -- Accepted: constrains a locally-quantified variable `b`
  op5 :: D (a,b) =&gt; a -&gt; b -- Accepted: constrains a locally-quantified variable `b`
</pre> </li> </ul> <p>GHC lifts this restriction with language extension <a class="reference internal" href="#extension-ConstrainedClassMethods"><code>ConstrainedClassMethods</code></a>. The restriction is a pretty stupid one in the first place, so <a class="reference internal" href="#extension-ConstrainedClassMethods"><code>ConstrainedClassMethods</code></a> is implied by <a class="reference internal" href="#extension-MultiParamTypeClasses"><code>MultiParamTypeClasses</code></a>.</p>   <h3 id="class-default-signatures">11.8.1.4. Default method signatures</h3> <dl class="extension" id="default-method-signatures"> <dt id="extension-DefaultSignatures">
<code>DefaultSignatures</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.2.1</td> </tr>  </table> <p>Allows the definition of default method signatures in class definitions.</p> </dd>
</dl> <p>Haskell 98 allows you to define a default implementation when declaring a class:</p> <pre data-language="haskell">class Enum a where
  enum :: [a]
  enum = []
</pre> <p>The type of the <code>enum</code> method is <code>[a]</code>, and this is also the type of the default method. You can lift this restriction and give another type to the default method using the extension <a class="reference internal" href="#extension-DefaultSignatures"><code>DefaultSignatures</code></a>. For instance, if you have written a generic implementation of enumeration in a class <code>GEnum</code> with method <code>genum</code> in terms of <code>GHC.Generics</code>, you can specify a default method that uses that generic implementation:</p> <pre data-language="haskell">class Enum a where
  enum :: [a]
  default enum :: (Generic a, GEnum (Rep a)) =&gt; [a]
  enum = map to genum
</pre> <p>We reuse the keyword <code>default</code> to signal that a signature applies to the default method only; when defining instances of the <code>Enum</code> class, the original type <code>[a]</code> of <code>enum</code> still applies. When giving an empty instance, however, the default implementation <code>(map to genum)</code> is filled-in, and type-checked with the type <code>(Generic a, GEnum (Rep a)) =&gt; [a]</code>.</p> <p>The type signature for a default method of a type class must take on the same form as the corresponding main method’s type signature. Otherwise, the typechecker will reject that class’s definition. By “take on the same form”, we mean that the default type signature should differ from the main type signature only in their contexts. Therefore, if you have a method <code>bar</code>:</p> <pre data-language="haskell">class Foo a where
  bar :: forall b. C =&gt; a -&gt; b -&gt; b
</pre> <p>Then a default method for <code>bar</code> must take on the form:</p> <pre data-language="haskell">default bar :: forall b. C' =&gt; a -&gt; b -&gt; b
</pre> <p><code>C</code> is allowed to be different from <code>C'</code>, but the right-hand sides of the type signatures must coincide. We require this because when you declare an empty instance for a class that uses <a class="reference internal" href="#extension-DefaultSignatures"><code>DefaultSignatures</code></a>, GHC implicitly fills in the default implementation like this:</p> <pre data-language="haskell">instance Foo Int where
  bar = default_bar @Int
</pre> <p>Where <code>@Int</code> utilizes visible type application (<a class="reference internal" href="#visible-type-application"><span class="std std-ref">Visible type application</span></a>) to instantiate the <code>b</code> in <code>default bar :: forall b. C' =&gt; a -&gt; b -&gt; b</code>. In order for this type application to work, the default type signature for <code>bar</code> must have the same type variable order as the non-default signature! But there is no obligation for <code>C</code> and <code>C'</code> to be the same (see, for instance, the <code>Enum</code> example above, which relies on this).</p> <p>To further explain this example, the right-hand side of the default type signature for <code>bar</code> must be something that is alpha-equivalent to <code>forall b. a -&gt; b -&gt; b</code> (where <code>a</code> is bound by the class itself, and is thus free in the methods’ type signatures). So this would also be an acceptable default type signature:</p> <pre data-language="haskell">default bar :: forall x. C' =&gt; a -&gt; x -&gt; x
</pre> <p>But not this (since the free variable <code>a</code> is in the wrong place):</p> <pre data-language="haskell">default bar :: forall b. C' =&gt; b -&gt; a -&gt; b
</pre> <p>Nor this, since we can’t match the type variable <code>b</code> with the concrete type <code>Int</code>:</p> <pre data-language="haskell">default bar :: C' =&gt; a -&gt; Int -&gt; Int
</pre> <p>That last one deserves a special mention, however, since <code>a -&gt; Int -&gt; Int</code> is a straightforward instantiation of <code>forall b. a -&gt; b -&gt; b</code>. You can still write such a default type signature, but you now must use type equalities to do so:</p> <pre data-language="haskell">default bar :: forall b. (C', b ~ Int) =&gt; a -&gt; b -&gt; b
</pre> <p>We use default signatures to simplify generic programming in GHC (<a class="reference internal" href="#generic-programming"><span class="std std-ref">Generic programming</span></a>).</p>   <h3 id="id28">11.8.1.5. Nullary type classes</h3> <dl class="extension" id="nullary-type-classes"> <dt id="extension-NullaryTypeClasses">
<code>NullaryTypeClasses</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8.1</td> </tr>  </table> <p>Allows the use definition of type classes with no parameters. This extension has been replaced by <a class="reference internal" href="#extension-MultiParamTypeClasses"><code>MultiParamTypeClasses</code></a>.</p> </dd>
</dl> <p>Nullary (no parameter) type classes are enabled with <a class="reference internal" href="#extension-MultiParamTypeClasses"><code>MultiParamTypeClasses</code></a>; historically, they were enabled with the (now deprecated) <a class="reference internal" href="#extension-NullaryTypeClasses"><code>NullaryTypeClasses</code></a>. Since there are no available parameters, there can be at most one instance of a nullary class. A nullary type class might be used to document some assumption in a type signature (such as reliance on the Riemann hypothesis) or add some globally configurable settings in a program. For example,</p> <pre data-language="haskell">class RiemannHypothesis where
  assumeRH :: a -&gt; a

-- Deterministic version of the Miller test
-- correctness depends on the generalised Riemann hypothesis
isPrime :: RiemannHypothesis =&gt; Integer -&gt; Bool
isPrime n = assumeRH (...)
</pre> <p>The type signature of <code>isPrime</code> informs users that its correctness depends on an unproven conjecture. If the function is used, the user has to acknowledge the dependence with:</p> <pre data-language="haskell">instance RiemannHypothesis where
  assumeRH = id
</pre>    <h2 id="id29">11.8.2. Functional dependencies</h2> <dl class="extension" id="functional-dependencies"> <dt id="extension-FunctionalDependencies">
<code>FunctionalDependencies</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-MultiParamTypeClasses"><code>MultiParamTypeClasses</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow use of functional dependencies in class declarations.</p> </dd>
</dl> <p>Functional dependencies are implemented as described by Mark Jones in <a class="reference internal" href="#jones2000" id="id30">[Jones2000]</a>.</p> <p>Functional dependencies are introduced by a vertical bar in the syntax of a class declaration; e.g.</p> <pre data-language="haskell">class (Monad m) =&gt; MonadState s m | m -&gt; s where ...

class Foo a b c | a b -&gt; c where ...
</pre> <p>More documentation can be found in the <a class="reference external" href="https://wiki.haskell.org/Functional_dependencies">Haskell Wiki</a>.</p> <table class="docutils citation" frame="void" id="jones2000" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id30">[Jones2000]</a></td>
<td>“<a class="reference external" href="https://web.cecs.pdx.edu/~mpj/pubs/fundeps.html">Type Classes with Functional Dependencies</a>”, Mark P. Jones, In <em>Proceedings of the 9th European Symposium on Programming</em>, ESOP 2000, Berlin, Germany, March 2000, Springer-Verlag LNCS 1782, .</td>
</tr>  </table>  <h3 id="rules-for-functional-dependencies">11.8.2.1. Rules for functional dependencies</h3> <p>In a class declaration, all of the class type variables must be reachable (in the sense mentioned in <a class="reference internal" href="#flexible-contexts"><span class="std std-ref">The context of a type signature</span></a>) from the free variables of each method type. For example:</p> <pre data-language="haskell">class Coll s a where
  empty  :: s
  insert :: s -&gt; a -&gt; s
</pre> <p>is not OK, because the type of <code>empty</code> doesn’t mention <code>a</code>. Functional dependencies can make the type variable reachable:</p> <pre data-language="haskell">class Coll s a | s -&gt; a where
  empty  :: s
  insert :: s -&gt; a -&gt; s
</pre> <p>Alternatively <code>Coll</code> might be rewritten</p> <pre data-language="haskell">class Coll s a where
  empty  :: s a
  insert :: s a -&gt; a -&gt; s a
</pre> <p>which makes the connection between the type of a collection of <code>a</code>‘s (namely <code>(s a)</code>) and the element type <code>a</code>. Occasionally this really doesn’t work, in which case you can split the class like this:</p> <pre data-language="haskell">class CollE s where
  empty  :: s

class CollE s =&gt; Coll s a where
  insert :: s -&gt; a -&gt; s
</pre>   <h3 id="background-on-functional-dependencies">11.8.2.2. Background on functional dependencies</h3> <p>The following description of the motivation and use of functional dependencies is taken from the Hugs user manual, reproduced here (with minor changes) by kind permission of Mark Jones.</p> <p>Consider the following class, intended as part of a library for collection types:</p> <pre data-language="haskell">class Collects e ce where
    empty  :: ce
    insert :: e -&gt; ce -&gt; ce
    member :: e -&gt; ce -&gt; Bool
</pre> <p>The type variable <code>e</code> used here represents the element type, while <code>ce</code> is the type of the container itself. Within this framework, we might want to define instances of this class for lists or characteristic functions (both of which can be used to represent collections of any equality type), bit sets (which can be used to represent collections of characters), or hash tables (which can be used to represent any collection whose elements have a hash function). Omitting standard implementation details, this would lead to the following declarations:</p> <pre data-language="haskell">instance Eq e =&gt; Collects e [e] where ...
instance Eq e =&gt; Collects e (e -&gt; Bool) where ...
instance Collects Char BitSet where ...
instance (Hashable e, Collects a ce)
           =&gt; Collects e (Array Int ce) where ...
</pre> <p>All this looks quite promising; we have a class and a range of interesting implementations. Unfortunately, there are some serious problems with the class declaration. First, the empty function has an ambiguous type:</p> <pre data-language="haskell">empty :: Collects e ce =&gt; ce
</pre> <p>By “ambiguous” we mean that there is a type variable <code>e</code> that appears on the left of the <code>=&gt;</code> symbol, but not on the right. The problem with this is that, according to the theoretical foundations of Haskell overloading, we cannot guarantee a well-defined semantics for any term with an ambiguous type.</p> <p>We can sidestep this specific problem by removing the empty member from the class declaration. However, although the remaining members, insert and member, do not have ambiguous types, we still run into problems when we try to use them. For example, consider the following two functions:</p> <pre data-language="haskell">f x y = insert x . insert y
g     = f True 'a'
</pre> <p>for which GHC infers the following types:</p> <pre data-language="haskell">f :: (Collects a c, Collects b c) =&gt; a -&gt; b -&gt; c -&gt; c
g :: (Collects Bool c, Collects Char c) =&gt; c -&gt; c
</pre> <p>Notice that the type for <code>f</code> allows the two parameters <code>x</code> and <code>y</code> to be assigned different types, even though it attempts to insert each of the two values, one after the other, into the same collection. If we’re trying to model collections that contain only one type of value, then this is clearly an inaccurate type. Worse still, the definition for g is accepted, without causing a type error. As a result, the error in this code will not be flagged at the point where it appears. Instead, it will show up only when we try to use <code>g</code>, which might even be in a different module.</p>  <h4 id="an-attempt-to-use-constructor-classes">11.8.2.2.1. An attempt to use constructor classes</h4> <p>Faced with the problems described above, some Haskell programmers might be tempted to use something like the following version of the class declaration:</p> <pre data-language="haskell">class Collects e c where
   empty  :: c e
   insert :: e -&gt; c e -&gt; c e
   member :: e -&gt; c e -&gt; Bool
</pre> <p>The key difference here is that we abstract over the type constructor <code>c</code> that is used to form the collection type <code>c e</code>, and not over that collection type itself, represented by <code>ce</code> in the original class declaration. This avoids the immediate problems that we mentioned above: empty has type <code>Collects e c =&gt; c e</code>, which is not ambiguous.</p> <p>The function <code>f</code> from the previous section has a more accurate type:</p> <pre data-language="haskell">f :: (Collects e c) =&gt; e -&gt; e -&gt; c e -&gt; c e
</pre> <p>The function <code>g</code> from the previous section is now rejected with a type error as we would hope because the type of <code>f</code> does not allow the two arguments to have different types. This, then, is an example of a multiple parameter class that does actually work quite well in practice, without ambiguity problems. There is, however, a catch. This version of the <code>Collects</code> class is nowhere near as general as the original class seemed to be: only one of the four instances for <code>Collects</code> given above can be used with this version of Collects because only one of them—the instance for lists—has a collection type that can be written in the form <code>c
e</code>, for some type constructor <code>c</code>, and element type <code>e</code>.</p>   <h4 id="adding-functional-dependencies">11.8.2.2.2. Adding functional dependencies</h4> <p>To get a more useful version of the <code>Collects</code> class, GHC provides a mechanism that allows programmers to specify dependencies between the parameters of a multiple parameter class (For readers with an interest in theoretical foundations and previous work: The use of dependency information can be seen both as a generalisation of the proposal for “parametric type classes” that was put forward by Chen, Hudak, and Odersky, or as a special case of Mark Jones’s later framework for “improvement” of qualified types. The underlying ideas are also discussed in a more theoretical and abstract setting in a manuscript <a class="reference internal" href="#jones1999" id="id31">[Jones1999]</a>, where they are identified as one point in a general design space for systems of implicit parameterisation). To start with an abstract example, consider a declaration such as:</p> <pre data-language="haskell">class C a b where ...
</pre> <table class="docutils citation" frame="void" id="jones1999" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id31">[Jones1999]</a></td>
<td>“<a class="reference external" href="https://web.cecs.pdx.edu/~mpj/pubs/fdtr.html">Exploring the Design Space for Type-based Implicit Parameterization</a>”, Mark P. Jones, Oregon Graduate Institute of Science &amp; Technology, Technical Report, July 1999.</td>
</tr>  </table> <p>which tells us simply that <code>C</code> can be thought of as a binary relation on types (or type constructors, depending on the kinds of <code>a</code> and <code>b</code>). Extra clauses can be included in the definition of classes to add information about dependencies between parameters, as in the following examples:</p> <pre data-language="haskell">class D a b | a -&gt; b where ...
class E a b | a -&gt; b, b -&gt; a where ...
</pre> <p>The notation <code>a -&gt; b</code> used here between the <code>|</code> and <code>where</code> symbols — not to be confused with a function type — indicates that the <code>a</code> parameter uniquely determines the <code>b</code> parameter, and might be read as “<code>a</code> determines <code>b</code>.” Thus <code>D</code> is not just a relation, but actually a (partial) function. Similarly, from the two dependencies that are included in the definition of <code>E</code>, we can see that <code>E</code> represents a (partial) one-to-one mapping between types.</p> <p>More generally, dependencies take the form <code>x1 ... xn -&gt; y1 ... ym</code>, where <code>x1</code>, ..., <code>xn</code>, and <code>y1</code>, ..., <code>yn</code> are type variables with n&gt;0 and m&gt;=0, meaning that the <code>y</code> parameters are uniquely determined by the <code>x</code> parameters. Spaces can be used as separators if more than one variable appears on any single side of a dependency, as in <code>t -&gt; a b</code>. Note that a class may be annotated with multiple dependencies using commas as separators, as in the definition of <code>E</code> above. Some dependencies that we can write in this notation are redundant, and will be rejected because they don’t serve any useful purpose, and may instead indicate an error in the program. Examples of dependencies like this include <code>a -&gt; a</code>, <code>a -&gt; a a</code>, <code>a -&gt;</code>, etc. There can also be some redundancy if multiple dependencies are given, as in <code>a-&gt;b</code>, <code>b-&gt;c</code>, <code>a-&gt;c</code>, and in which some subset implies the remaining dependencies. Examples like this are not treated as errors. Note that dependencies appear only in class declarations, and not in any other part of the language. In particular, the syntax for instance declarations, class constraints, and types is completely unchanged.</p> <p>By including dependencies in a class declaration, we provide a mechanism for the programmer to specify each multiple parameter class more precisely. The compiler, on the other hand, is responsible for ensuring that the set of instances that are in scope at any given point in the program is consistent with any declared dependencies. For example, the following pair of instance declarations cannot appear together in the same scope because they violate the dependency for <code>D</code>, even though either one on its own would be acceptable:</p> <pre data-language="haskell">instance D Bool Int where ...
instance D Bool Char where ...
</pre> <p>Note also that the following declaration is not allowed, even by itself:</p> <pre data-language="haskell">instance D [a] b where ...
</pre> <p>The problem here is that this instance would allow one particular choice of <code>[a]</code> to be associated with more than one choice for <code>b</code>, which contradicts the dependency specified in the definition of <code>D</code>. More generally, this means that, in any instance of the form:</p> <pre data-language="haskell">instance D t s where ...
</pre> <p>for some particular types <code>t</code> and <code>s</code>, the only variables that can appear in <code>s</code> are the ones that appear in <code>t</code>, and hence, if the type <code>t</code> is known, then <code>s</code> will be uniquely determined.</p> <p>The benefit of including dependency information is that it allows us to define more general multiple parameter classes, without ambiguity problems, and with the benefit of more accurate types. To illustrate this, we return to the collection class example, and annotate the original definition of <code>Collects</code> with a simple dependency:</p> <pre data-language="haskell">class Collects e ce | ce -&gt; e where
   empty  :: ce
   insert :: e -&gt; ce -&gt; ce
   member :: e -&gt; ce -&gt; Bool
</pre> <p>The dependency <code>ce -&gt; e</code> here specifies that the type <code>e</code> of elements is uniquely determined by the type of the collection <code>ce</code>. Note that both parameters of Collects are of kind <code>Type</code>; there are no constructor classes here. Note too that all of the instances of <code>Collects</code> that we gave earlier can be used together with this new definition.</p> <p>What about the ambiguity problems that we encountered with the original definition? The empty function still has type <code>Collects e ce =&gt; ce</code>, but it is no longer necessary to regard that as an ambiguous type: Although the variable <code>e</code> does not appear on the right of the <code>=&gt;</code> symbol, the dependency for class <code>Collects</code> tells us that it is uniquely determined by <code>ce</code>, which does appear on the right of the <code>=&gt;</code> symbol. Hence the context in which empty is used can still give enough information to determine types for both <code>ce</code> and <code>e</code>, without ambiguity. More generally, we need only regard a type as ambiguous if it contains a variable on the left of the <code>=&gt;</code> that is not uniquely determined (either directly or indirectly) by the variables on the right.</p> <p>Dependencies also help to produce more accurate types for user defined functions, and hence to provide earlier detection of errors, and less cluttered types for programmers to work with. Recall the previous definition for a function <code>f</code>:</p> <pre data-language="haskell">f x y = insert x y = insert x . insert y
</pre> <p>for which we originally obtained a type:</p> <pre data-language="haskell">f :: (Collects a c, Collects b c) =&gt; a -&gt; b -&gt; c -&gt; c
</pre> <p>Given the dependency information that we have for <code>Collects</code>, however, we can deduce that <code>a</code> and <code>b</code> must be equal because they both appear as the second parameter in a <code>Collects</code> constraint with the same first parameter <code>c</code>. Hence we can infer a shorter and more accurate type for <code>f</code>:</p> <pre data-language="haskell">f :: (Collects a c) =&gt; a -&gt; a -&gt; c -&gt; c
</pre> <p>In a similar way, the earlier definition of <code>g</code> will now be flagged as a type error.</p> <p>Although we have given only a few examples here, it should be clear that the addition of dependency information can help to make multiple parameter classes more useful in practice, avoiding ambiguity problems, and allowing more general sets of instance declarations.</p>     <h2 id="instance-decls">11.8.3. Instance declarations</h2> <p id="instance-declarations">An instance declaration has the form</p> <pre data-language="haskell">instance ( assertion1, ..., assertionn) =&gt; class type1 ... typem where ...
</pre> <p>The part before the “<code>=&gt;</code>” is the <em>context</em>, while the part after the “<code>=&gt;</code>” is the <em>head</em> of the instance declaration.</p>  <h3 id="id32">11.8.3.1. Instance resolution</h3> <p id="instance-resolution">When GHC tries to resolve, say, the constraint <code>C Int Bool</code>, it tries to match every instance declaration against the constraint, by instantiating the head of the instance declaration. Consider these declarations:</p> <pre data-language="haskell">instance context1 =&gt; C Int a     where ...  -- (A)
instance context2 =&gt; C a   Bool  where ...  -- (B)
</pre> <p>GHC’s default behaviour is that <em>exactly one instance must match the constraint it is trying to resolve</em>. For example, the constraint <code>C Int Bool</code> matches instances (A) and (B), and hence would be rejected; while <code>C Int Char</code> matches only (A) and hence (A) is chosen.</p> <p>Notice that</p> <ul class="simple"> <li>When matching, GHC takes no account of the context of the instance declaration (<code>context1</code> etc).</li> <li>It is fine for there to be a <em>potential</em> of overlap (by including both declarations (A) and (B), say); an error is only reported if a particular constraint matches more than one.</li> </ul> <p>See also <a class="reference internal" href="#instance-overlap"><span class="std std-ref">Overlapping instances</span></a> for flags that loosen the instance resolution rules.</p>   <h3 id="flexible-instance-head">11.8.3.2. Relaxed rules for the instance head</h3> <dl class="extension" id="relaxed-rules-for-the-instance-head"> <dt id="extension-TypeSynonymInstances">
<code>TypeSynonymInstances</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow definition of type class instances for type synonyms.</p> </dd>
</dl> <dl class="extension"> <dt id="extension-FlexibleInstances">
<code>FlexibleInstances</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-TypeSynonymInstances"><code>TypeSynonymInstances</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow definition of type class instances with arbitrary nested types in the instance head.</p> </dd>
</dl> <p>In Haskell 98 the head of an instance declaration must be of the form <code>C (T a1 ... an)</code>, where <code>C</code> is the class, <code>T</code> is a data type constructor, and the <code>a1 ... an</code> are distinct type variables. In the case of multi-parameter type classes, this rule applies to each parameter of the instance head (Arguably it should be okay if just one has this form and the others are type variables, but that’s the rules at the moment).</p> <p>GHC relaxes this rule in two ways:</p> <ul> <li>
<p class="first">With the <a class="reference internal" href="#extension-TypeSynonymInstances"><code>TypeSynonymInstances</code></a> extension, instance heads may use type synonyms. As always, using a type synonym is just shorthand for writing the RHS of the type synonym definition. For example:</p> <pre data-language="haskell">type Point a = (a,a)
instance C (Point a)   where ...
</pre> <p>is legal. The instance declaration is equivalent to</p> <pre data-language="haskell">instance C (a,a) where ...
</pre> <p>As always, type synonyms must be fully applied. You cannot, for example, write:</p> <pre data-language="haskell">instance Monad Point where ...
</pre> </li> <li>
<p class="first">The <a class="reference internal" href="#extension-FlexibleInstances"><code>FlexibleInstances</code></a> extension allows the head of the instance declaration to mention arbitrary nested types. For example, this becomes a legal instance declaration</p> <pre data-language="haskell">instance C (Maybe Int) where ...
</pre> <p>See also the <a class="reference external" href="#instance-overlap">rules on overlap</a>.</p> <p>The <a class="reference internal" href="#extension-FlexibleInstances"><code>FlexibleInstances</code></a> extension implies <a class="reference internal" href="#extension-TypeSynonymInstances"><code>TypeSynonymInstances</code></a>.</p> </li> </ul> <p>However, the instance declaration must still conform to the rules for instance termination: see <a class="reference internal" href="#instance-termination"><span class="std std-ref">Instance termination rules</span></a>.</p>   <h3 id="instance-rules">11.8.3.3. Relaxed rules for instance contexts</h3> <p id="relaxed-rules-for-instance-contexts">In Haskell 98, the class constraints in the context of the instance declaration must be of the form <code>C a</code> where <code>a</code> is a type variable that occurs in the head.</p> <p>The <a class="reference internal" href="#extension-FlexibleContexts"><code>FlexibleContexts</code></a> extension relaxes this rule, as well as relaxing the corresponding rule for type signatures (see <a class="reference internal" href="#flexible-contexts"><span class="std std-ref">The context of a type signature</span></a>). Specifically, <a class="reference internal" href="#extension-FlexibleContexts"><code>FlexibleContexts</code></a>, allows (well-kinded) class constraints of form <code>(C t1 ... tn)</code> in the context of an instance declaration.</p> <p>Notice that the extension does not affect equality constraints in an instance context; they are permitted by <a class="reference internal" href="#extension-TypeFamilies"><code>TypeFamilies</code></a> or <a class="reference internal" href="#extension-GADTs"><code>GADTs</code></a>.</p> <p>However, the instance declaration must still conform to the rules for instance termination: see <a class="reference internal" href="#instance-termination"><span class="std std-ref">Instance termination rules</span></a>.</p>   <h3 id="instance-termination">11.8.3.4. Instance termination rules</h3> <dl class="extension" id="instance-termination-rules"> <dt id="extension-UndecidableInstances">
<code>UndecidableInstances</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Permit definition of instances which may lead to type-checker non-termination.</p> </dd>
</dl> <p>Regardless of <a class="reference internal" href="#extension-FlexibleInstances"><code>FlexibleInstances</code></a> and <a class="reference internal" href="#extension-FlexibleContexts"><code>FlexibleContexts</code></a>, instance declarations must conform to some rules that ensure that instance resolution will terminate. The restrictions can be lifted with <a class="reference internal" href="#extension-UndecidableInstances"><code>UndecidableInstances</code></a> (see <a class="reference internal" href="#undecidable-instances"><span class="std std-ref">Undecidable instances</span></a>).</p> <p>The rules are these:</p> <ol class="arabic simple"> <li>The Paterson Conditions: for each class constraint <code>(C t1 ... tn)</code> in the context<ol class="arabic"> <li>No type variable has more occurrences in the constraint than in the head</li> <li>The constraint has fewer constructors and variables (taken together and counting repetitions) than the head</li> <li>The constraint mentions no type functions. A type function application can in principle expand to a type of arbitrary size, and so are rejected out of hand</li> </ol> </li> <li>The Coverage Condition. For each functional dependency, ⟨tvs⟩<sub>left</sub> <code>-&gt;</code> ⟨tvs⟩<sub>right</sub>, of the class, every type variable in S(⟨tvs⟩<sub>right</sub>) must appear in S(⟨tvs⟩<sub>left</sub>), where S is the substitution mapping each type variable in the class declaration to the corresponding type in the instance head.</li> </ol> <p>These restrictions ensure that instance resolution terminates: each reduction step makes the problem smaller by at least one constructor. You can find lots of background material about the reason for these restrictions in the paper <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf">Understanding functional dependencies via Constraint Handling Rules</a>.</p> <p>For example, these are okay:</p> <pre data-language="haskell">instance C Int [a]          -- Multiple parameters
instance Eq (S [a])         -- Structured type in head

    -- Repeated type variable in head
instance C4 a a =&gt; C4 [a] [a]
instance Stateful (ST s) (MutVar s)

    -- Head can consist of type variables only
instance C a
instance (Eq a, Show b) =&gt; C2 a b

    -- Non-type variables in context
instance Show (s a) =&gt; Show (Sized s a)
instance C2 Int a =&gt; C3 Bool [a]
instance C2 Int a =&gt; C3 [a] b
</pre> <p>But these are not:</p> <pre data-language="haskell">    -- Context assertion no smaller than head
instance C a =&gt; C a where ...
    -- (C b b) has more occurrences of b than the head
instance C b b =&gt; Foo [b] where ...
</pre> <p>The same restrictions apply to instances generated by <code>deriving</code> clauses. Thus the following is accepted:</p> <pre data-language="haskell">data MinHeap h a = H a (h a)
  deriving (Show)
</pre> <p>because the derived instance</p> <pre data-language="haskell">instance (Show a, Show (h a)) =&gt; Show (MinHeap h a)
</pre> <p>conforms to the above rules.</p> <p>A useful idiom permitted by the above rules is as follows. If one allows overlapping instance declarations then it’s quite convenient to have a “default instance” declaration that applies if something more specific does not:</p> <pre data-language="haskell">instance C a where
  op = ... -- Default
</pre>   <h3 id="id33">11.8.3.5. Undecidable instances</h3> <p id="undecidable-instances">Sometimes even the termination rules of <a class="reference internal" href="#instance-termination"><span class="std std-ref">Instance termination rules</span></a> are too onerous. So GHC allows you to experiment with more liberal rules: if you use the experimental extension <a class="reference internal" href="#extension-UndecidableInstances"><code>UndecidableInstances</code></a>, both the Paterson Conditions and the Coverage Condition (described in <a class="reference internal" href="#instance-termination"><span class="std std-ref">Instance termination rules</span></a>) are lifted. Termination is still ensured by having a fixed-depth recursion stack. If you exceed the stack depth you get a sort of backtrace, and the opportunity to increase the stack depth with <code>-freduction-depth=⟨n⟩</code>. However, if you should exceed the default reduction depth limit, it is probably best just to disable depth checking, with <code>-freduction-depth=0</code>. The exact depth your program requires depends on minutiae of your code, and it may change between minor GHC releases. The safest bet for released code – if you’re sure that it should compile in finite time – is just to disable the check.</p> <p>For example, sometimes you might want to use the following to get the effect of a “class synonym”:</p> <pre data-language="haskell">class (C1 a, C2 a, C3 a) =&gt; C a where { }

instance (C1 a, C2 a, C3 a) =&gt; C a where { }
</pre> <p>This allows you to write shorter signatures:</p> <pre data-language="haskell">f :: C a =&gt; ...
</pre> <p>instead of</p> <pre data-language="haskell">f :: (C1 a, C2 a, C3 a) =&gt; ...
</pre> <p>The restrictions on functional dependencies (<a class="reference internal" href="#functional-dependencies"><span class="std std-ref">Functional dependencies</span></a>) are particularly troublesome. It is tempting to introduce type variables in the context that do not appear in the head, something that is excluded by the normal rules. For example:</p> <pre data-language="haskell">class HasConverter a b | a -&gt; b where
   convert :: a -&gt; b

data Foo a = MkFoo a

instance (HasConverter a b,Show b) =&gt; Show (Foo a) where
   show (MkFoo value) = show (convert value)
</pre> <p>This is dangerous territory, however. Here, for example, is a program that would make the typechecker loop:</p> <pre data-language="haskell">class D a
class F a b | a-&gt;b
instance F [a] [[a]]
instance (D c, F a c) =&gt; D [a]   -- 'c' is not mentioned in the head
</pre> <p>Similarly, it can be tempting to lift the coverage condition:</p> <pre data-language="haskell">class Mul a b c | a b -&gt; c where
  (.*.) :: a -&gt; b -&gt; c

instance Mul Int Int Int where (.*.) = (*)
instance Mul Int Float Float where x .*. y = fromIntegral x * y
instance Mul a b c =&gt; Mul a [b] [c] where x .*. v = map (x.*.) v
</pre> <p>The third instance declaration does not obey the coverage condition; and indeed the (somewhat strange) definition:</p> <pre data-language="haskell">f = \ b x y -&gt; if b then x .*. [y] else y
</pre> <p>makes instance inference go into a loop, because it requires the constraint <code>(Mul a [b] b)</code>.</p> <p>The <a class="reference internal" href="#extension-UndecidableInstances"><code>UndecidableInstances</code></a> extension is also used to lift some of the restrictions imposed on type family instances. See <a class="reference internal" href="#type-family-decidability"><span class="std std-ref">Decidability of type synonym instances</span></a>.</p>   <h3 id="instance-overlap">11.8.3.6. Overlapping instances</h3> <dl class="extension" id="overlapping-instances"> <dt id="extension-OverlappingInstances">
<code>OverlappingInstances</code> </dt> <dd>
<p>Deprecated extension to weaken checks intended to ensure instance resolution termination.</p> </dd>
</dl> <dl class="extension"> <dt id="extension-IncoherentInstances">
<code>IncoherentInstances</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Deprecated extension to weaken checks intended to ensure instance resolution termination.</p> </dd>
</dl> <p>In general, as discussed in <a class="reference internal" href="#instance-resolution"><span class="std std-ref">Instance resolution</span></a>, <em>GHC requires that it be unambiguous which instance declaration should be used to resolve a type-class constraint</em>. GHC also provides a way to loosen the instance resolution, by allowing more than one instance to match, <em>provided there is a most specific one</em>. Moreover, it can be loosened further, by allowing more than one instance to match irrespective of whether there is a most specific one. This section gives the details.</p> <p>To control the choice of instance, it is possible to specify the overlap behavior for individual instances with a pragma, written immediately after the <code>instance</code> keyword. The pragma may be one of: <code>{-# OVERLAPPING #-}</code>, <code>{-# OVERLAPPABLE #-}</code>, <code>{-# OVERLAPS #-}</code>, or <code>{-# INCOHERENT #-}</code>.</p> <p>The matching behaviour is also influenced by two module-level language extension flags: <a class="reference internal" href="#extension-OverlappingInstances"><code>OverlappingInstances</code></a> and <a class="reference internal" href="#extension-IncoherentInstances"><code>IncoherentInstances</code></a>. These extensions are now deprecated (since GHC 7.10) in favour of the fine-grained per-instance pragmas.</p> <p>A more precise specification is as follows. The willingness to be overlapped or incoherent is a property of the <em>instance declaration</em> itself, controlled as follows:</p> <ul class="simple"> <li>An instance is <em>incoherent</em> if: it has an <code>INCOHERENT</code> pragma; or if the instance has no pragma and it appears in a module compiled with <a class="reference internal" href="#extension-IncoherentInstances"><code>IncoherentInstances</code></a>.</li> <li>An instance is <em>overlappable</em> if: it has an <code>OVERLAPPABLE</code> or <code>OVERLAPS</code> pragma; or if the instance has no pragma and it appears in a module compiled with <a class="reference internal" href="#extension-OverlappingInstances"><code>OverlappingInstances</code></a>; or if the instance is incoherent.</li> <li>An instance is <em>overlapping</em> if: it has an <code>OVERLAPPING</code> or <code>OVERLAPS</code> pragma; or if the instance has no pragma and it appears in a module compiled with <a class="reference internal" href="#extension-OverlappingInstances"><code>OverlappingInstances</code></a>; or if the instance is incoherent.</li> </ul> <p>Now suppose that, in some client module, we are searching for an instance of the <em>target constraint</em> <code>(C ty1 .. tyn)</code>. The search works like this:</p> <ul class="simple"> <li>Find all instances <span class="math">\(I\)</span> that <em>match</em> the target constraint; that is, the target constraint is a substitution instance of <span class="math">\(I\)</span>. These instance declarations are the <em>candidates</em>.</li> <li>If no candidates remain, the search failes</li> <li>Eliminate any candidate <span class="math">\(IX\)</span> for which there is another candidate <span class="math">\(IY\)</span> such that both of the following hold:<ul> <li>
<span class="math">\(IY\)</span> is strictly more specific than <span class="math">\(IX\)</span>. That is, <span class="math">\(IY\)</span> is a substitution instance of <span class="math">\(IX\)</span> but not vice versa.</li> <li>Either <span class="math">\(IX\)</span> is <em>overlappable</em>, or <span class="math">\(IY\)</span> is <em>overlapping</em>. (This “either/or” design, rather than a “both/and” design, allow a client to deliberately override an instance from a library, without requiring a change to the library.)</li> </ul> </li> <li>If all the remaining candidates are incoherent, the search suceeds, returning an arbitrary surviving candidate.</li> <li>If more than one non-incoherent candidate remains, the search fails.</li> <li>Otherwise there is exactly one non-incoherent candidate; call it the “prime candidate”.</li> <li>Now find all instances, or in-scope given constraints, that <em>unify</em> with the target constraint, but do not <em>match</em> it. Such non-candidate instances might match when the target constraint is further instantiated. If all of them are incoherent top-level instances, the search succeeds, returning the prime candidate. Otherwise the search fails.</li> </ul> <p>Notice that these rules are not influenced by flag settings in the client module, where the instances are <em>used</em>. These rules make it possible for a library author to design a library that relies on overlapping instances without the client having to know.</p> <p>Errors are reported <em>lazily</em> (when attempting to solve a constraint), rather than <em>eagerly</em> (when the instances themselves are defined). Consider, for example</p> <pre data-language="haskell">instance C Int  b where ..
instance C a Bool where ..
</pre> <p>These potentially overlap, but GHC will not complain about the instance declarations themselves, regardless of flag settings. If we later try to solve the constraint <code>(C Int Char)</code> then only the first instance matches, and all is well. Similarly with <code>(C Bool Bool)</code>. But if we try to solve <code>(C Int Bool)</code>, both instances match and an error is reported.</p> <p>As a more substantial example of the rules in action, consider</p> <pre data-language="haskell">instance {-# OVERLAPPABLE #-} context1 =&gt; C Int b     where ...  -- (A)
instance {-# OVERLAPPABLE #-} context2 =&gt; C a   Bool  where ...  -- (B)
instance {-# OVERLAPPABLE #-} context3 =&gt; C a   [b]   where ...  -- (C)
instance {-# OVERLAPPING  #-} context4 =&gt; C Int [Int] where ...  -- (D)
</pre> <p>Now suppose that the type inference engine needs to solve the constraint <code>C Int [Int]</code>. This constraint matches instances (A), (C) and (D), but the last is more specific, and hence is chosen.</p> <p>If (D) did not exist then (A) and (C) would still be matched, but neither is most specific. In that case, the program would be rejected, unless <a class="reference internal" href="#extension-IncoherentInstances"><code>IncoherentInstances</code></a> is enabled, in which case it would be accepted and (A) or (C) would be chosen arbitrarily.</p> <p>An instance declaration is <em>more specific</em> than another iff the head of former is a substitution instance of the latter. For example (D) is “more specific” than (C) because you can get from (C) to (D) by substituting <code>a := Int</code>.</p> <p>The final bullet (about unifiying instances) makes GHC conservative about committing to an overlapping instance. For example:</p> <pre data-language="haskell">f :: [b] -&gt; [b]
f x = ...
</pre> <p>Suppose that from the RHS of <code>f</code> we get the constraint <code>C b [b]</code>. But GHC does not commit to instance (C), because in a particular call of <code>f</code>, <code>b</code> might be instantiated to <code>Int</code>, in which case instance (D) would be more specific still. So GHC rejects the program.</p> <p>If, however, you enable the extension <a class="reference internal" href="#extension-IncoherentInstances"><code>IncoherentInstances</code></a> when compiling the module that contains (D), GHC will instead pick (C), without complaining about the problem of subsequent instantiations.</p> <p>Notice that we gave a type signature to <code>f</code>, so GHC had to <em>check</em> that <code>f</code> has the specified type. Suppose instead we do not give a type signature, asking GHC to <em>infer</em> it instead. In this case, GHC will refrain from simplifying the constraint <code>C Int [b]</code> (for the same reason as before) but, rather than rejecting the program, it will infer the type</p> <pre data-language="haskell">f :: C b [b] =&gt; [b] -&gt; [b]
</pre> <p>That postpones the question of which instance to pick to the call site for <code>f</code> by which time more is known about the type <code>b</code>. You can write this type signature yourself if you use the <a class="reference internal" href="#extension-FlexibleContexts"><code>FlexibleContexts</code></a> extension.</p> <p>Exactly the same situation can arise in instance declarations themselves. Suppose we have</p> <pre data-language="haskell">class Foo a where
   f :: a -&gt; a
instance Foo [b] where
   f x = ...
</pre> <p>and, as before, the constraint <code>C Int [b]</code> arises from <code>f</code>‘s right hand side. GHC will reject the instance, complaining as before that it does not know how to resolve the constraint <code>C Int [b]</code>, because it matches more than one instance declaration. The solution is to postpone the choice by adding the constraint to the context of the instance declaration, thus:</p> <pre data-language="haskell">instance C Int [b] =&gt; Foo [b] where
   f x = ...
</pre> <p>(You need <a class="reference internal" href="#extension-FlexibleInstances"><code>FlexibleInstances</code></a> to do this.)</p> <p>In the unification check in the final bullet, GHC also uses the “in-scope given constraints”. Consider for example</p> <pre data-language="haskell">instance C a Int

g :: forall b c. C b Int =&gt; blah
g = ...needs (C c Int)...
</pre> <p>Here GHC will not solve the constraint <code>(C c Int)</code> from the top-level instance, because a particular call of <code>g</code> might instantiate both <code>b</code> and <code>c</code> to the same type, which would allow the constraint to be solved in a different way. This latter restriction is principally to make the constraint-solver complete. (Interested folk can read <code>Note [Instance and Given overlap]</code> in <code>TcInteract</code>.) It is easy to avoid: in a type signature avoid a constraint that matches a top-level instance. The flag <a class="reference internal" href="using-warnings#ghc-flag--Wsimplifiable-class-constraints"><code>-Wsimplifiable-class-constraints</code></a> warns about such signatures.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>Overlapping instances must be used with care. They can give rise to incoherence (i.e. different instance choices are made in different parts of the program) even without <a class="reference internal" href="#extension-IncoherentInstances"><code>IncoherentInstances</code></a>. Consider:</p> <pre data-language="haskell">{-# LANGUAGE OverlappingInstances #-}
module Help where

    class MyShow a where
    myshow :: a -&gt; String

    instance MyShow a =&gt; MyShow [a] where
    myshow xs = concatMap myshow xs

    showHelp :: MyShow a =&gt; [a] -&gt; String
    showHelp xs = myshow xs

{-# LANGUAGE FlexibleInstances, OverlappingInstances #-}
module Main where
    import Help

    data T = MkT

    instance MyShow T where
    myshow x = "Used generic instance"

    instance MyShow [T] where
    myshow xs = "Used more specific instance"

    main = do { print (myshow [MkT]); print (showHelp [MkT]) }
</pre> <p>In function <code>showHelp</code> GHC sees no overlapping instances, and so uses the <code>MyShow [a]</code> instance without complaint. In the call to <code>myshow</code> in <code>main</code>, GHC resolves the <code>MyShow [T]</code> constraint using the overlapping instance declaration in module <code>Main</code>. As a result, the program prints</p> <pre data-language="none">"Used more specific instance"
"Used generic instance"
</pre> <p class="last">(An alternative possible behaviour, not currently implemented, would be to reject module <code>Help</code> on the grounds that a later instance declaration might overlap the local one.)</p> </div>   <h3 id="instance-sigs">11.8.3.7. Instance signatures: type signatures in instance declarations</h3> <dl class="extension" id="instance-signatures-type-signatures-in-instance-declarations"> <dt id="extension-InstanceSigs">
<code>InstanceSigs</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.6.1</td> </tr>  </table> <p>Allow type signatures for members in instance definitions.</p> </dd>
</dl> <p>In Haskell, you can’t write a type signature in an instance declaration, but it is sometimes convenient to do so, and the language extension <a class="reference internal" href="#extension-InstanceSigs"><code>InstanceSigs</code></a> allows you to do so. For example:</p> <pre data-language="haskell">data T a = MkT a a
instance Eq a =&gt; Eq (T a) where
  (==) :: T a -&gt; T a -&gt; Bool   -- The signature
  (==) (MkT x1 x2) (MkTy y1 y2) = x1==y1 &amp;&amp; x2==y2
</pre> <p>Some details</p> <ul> <li>
<p class="first">The type signature in the instance declaration must be more polymorphic than (or the same as) the one in the class declaration, instantiated with the instance type. For example, this is fine:</p> <pre data-language="haskell">instance Eq a =&gt; Eq (T a) where
   (==) :: forall b. b -&gt; b -&gt; Bool
   (==) x y = True
</pre> <p>Here the signature in the instance declaration is more polymorphic than that required by the instantiated class method.</p> </li> <li>The code for the method in the instance declaration is typechecked against the type signature supplied in the instance declaration, as you would expect. So if the instance signature is more polymorphic than required, the code must be too. </li> <li>
<p class="first">One stylistic reason for wanting to write a type signature is simple documentation. Another is that you may want to bring scoped type variables into scope. For example:</p> <pre data-language="haskell">class C a where
  foo :: b -&gt; a -&gt; (a, [b])

instance C a =&gt; C (T a) where
  foo :: forall b. b -&gt; T a -&gt; (T a, [b])
  foo x (T y) = (T y, xs)
     where
       xs :: [b]
       xs = [x,x,x]
</pre> <p>Provided that you also specify <a class="reference internal" href="#extension-ScopedTypeVariables"><code>ScopedTypeVariables</code></a> (<a class="reference internal" href="#scoped-type-variables"><span class="std std-ref">Lexically scoped type variables</span></a>), the <code>forall b</code> scopes over the definition of <code>foo</code>, and in particular over the type signature for <code>xs</code>.</p> </li> </ul>    <h2 id="overloaded-strings">11.8.4. Overloaded string literals</h2> <dl class="extension" id="overloaded-string-literals"> <dt id="extension-OverloadedStrings">
<code>OverloadedStrings</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Enable overloaded string literals (e.g. string literals desugared via the <code>IsString</code> class).</p> </dd>
</dl> <p>GHC supports <em>overloaded string literals</em>. Normally a string literal has type <code>String</code>, but with overloaded string literals enabled (with <a class="reference internal" href="#extension-OverloadedStrings"><code>OverloadedStrings</code></a>) a string literal has type <code>(IsString a) =&gt; a</code>.</p> <p>This means that the usual string syntax can be used, e.g., for <code>ByteString</code>, <code>Text</code>, and other variations of string like types. String literals behave very much like integer literals, i.e., they can be used in both expressions and patterns. If used in a pattern the literal will be replaced by an equality test, in the same way as an integer literal is.</p> <p>The class <code>IsString</code> is defined as:</p> <pre data-language="haskell">class IsString a where
    fromString :: String -&gt; a
</pre> <p>The only predefined instance is the obvious one to make strings work as usual:</p> <pre data-language="haskell">instance IsString [Char] where
    fromString cs = cs
</pre> <p>The class <code>IsString</code> is not in scope by default. If you want to mention it explicitly (for example, to give an instance declaration for it), you can import it from module <code>Data.String</code>.</p> <p>Haskell’s defaulting mechanism (<a class="reference external" href="http://www.haskell.org/onlinereport/decls.html#sect4.3.4">Haskell Report, Section 4.3.4</a>) is extended to cover string literals, when <a class="reference internal" href="#extension-OverloadedStrings"><code>OverloadedStrings</code></a> is specified. Specifically:</p> <ul class="simple"> <li>Each type in a <code>default</code> declaration must be an instance of <code>Num</code> <em>or</em> of <code>IsString</code>.</li> <li>If no <code>default</code> declaration is given, then it is just as if the module contained the declaration <code>default( Integer, Double, String)</code>.</li> <li>The standard defaulting rule is extended thus: defaulting applies when all the unresolved constraints involve standard classes <em>or</em> <code>IsString</code>; and at least one is a numeric class <em>or</em> <code>IsString</code>.</li> </ul> <p>So, for example, the expression <code>length "foo"</code> will give rise to an ambiguous use of <code>IsString a0</code> which, because of the above rules, will default to <code>String</code>.</p> <p>A small example:</p> <pre data-language="haskell">module Main where

import Data.String( IsString(..) )

newtype MyString = MyString String deriving (Eq, Show)
instance IsString MyString where
    fromString = MyString

greet :: MyString -&gt; MyString
greet "hello" = "world"
greet other = other

main = do
    print $ greet "hello"
    print $ greet "fool"
</pre> <p>Note that deriving <code>Eq</code> is necessary for the pattern matching to work since it gets translated into an equality comparison.</p>   <h2 id="id34">11.8.5. Overloaded labels</h2> <dl class="extension" id="overloaded-labels"> <dt id="extension-OverloadedLabels">
<code>OverloadedLabels</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Enable use of the <code>#foo</code> overloaded label syntax.</p> </dd>
</dl> <p>GHC supports <em>overloaded labels</em>, a form of identifier whose interpretation may depend both on its type and on its literal text. When the <a class="reference internal" href="#extension-OverloadedLabels"><code>OverloadedLabels</code></a> extension is enabled, an overloaded label can be written with a prefix hash, for example <code>#foo</code>. The type of this expression is <code>IsLabel "foo" a =&gt; a</code>.</p> <p>The class <code>IsLabel</code> is defined as:</p> <pre data-language="haskell">class IsLabel (x :: Symbol) a where
  fromLabel :: a
</pre> <p>This is rather similar to the class <code>IsString</code> (see <a class="reference internal" href="#overloaded-strings"><span class="std std-ref">Overloaded string literals</span></a>), but with an additional type parameter that makes the text of the label available as a type-level string (see <a class="reference internal" href="#type-level-literals"><span class="std std-ref">Type-Level Literals</span></a>). Note that <code>fromLabel</code> had an extra <code>Proxy# x</code> argument in GHC 8.0, but this was removed in GHC 8.2 as a type application (see <a class="reference internal" href="#visible-type-application"><span class="std std-ref">Visible type application</span></a>) can be used instead.</p> <p>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing <a class="reference external" href="../libraries/base-4.13.0.0/ghc-overloadedlabels">GHC.OverloadedLabels</a>. Unlike <code>IsString</code>, there are no special defaulting rules for <code>IsLabel</code>.</p> <p>During typechecking, GHC will replace an occurrence of an overloaded label like <code>#foo</code> with <code>fromLabel @"foo"</code>. This will have some type <code>alpha</code> and require the solution of a class constraint <code>IsLabel "foo" alpha</code>.</p> <p>The intention is for <code>IsLabel</code> to be used to support overloaded record fields and perhaps anonymous records. Thus, it may be given instances for base datatypes (in particular <code>(-&gt;)</code>) in the future.</p> <p>If <a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a> is enabled, overloaded labels will be desugared using whatever <code>fromLabel</code> function is in scope, rather than always using <code>GHC.OverloadedLabels.fromLabel</code>.</p> <p>When writing an overloaded label, there must be no space between the hash sign and the following identifier. The <a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a> extension makes use of postfix hash signs; if <a class="reference internal" href="#extension-OverloadedLabels"><code>OverloadedLabels</code></a> and <a class="reference internal" href="#extension-MagicHash"><code>MagicHash</code></a> are both enabled then <code>x#y</code> means <code>x# y</code>, but if only <a class="reference internal" href="#extension-OverloadedLabels"><code>OverloadedLabels</code></a> is enabled then it means <code>x #y</code>. The <a class="reference internal" href="#extension-UnboxedTuples"><code>UnboxedTuples</code></a> extension makes <code>(#</code> a single lexeme, so when <a class="reference internal" href="#extension-UnboxedTuples"><code>UnboxedTuples</code></a> is enabled you must write a space between an opening parenthesis and an overloaded label. To avoid confusion, you are strongly encouraged to put a space before the hash when using <a class="reference internal" href="#extension-OverloadedLabels"><code>OverloadedLabels</code></a>.</p> <p>When using <a class="reference internal" href="#extension-OverloadedLabels"><code>OverloadedLabels</code></a> (or other extensions that make use of hash signs) in a <code>.hsc</code> file (see <a class="reference internal" href="utils#hsc2hs"><span class="std std-ref">Writing Haskell interfaces to C code: hsc2hs</span></a>), the hash signs must be doubled (write <code>##foo</code> instead of <code>#foo</code>) to avoid them being treated as <code>hsc2hs</code> directives.</p> <p>Here is an extension of the record access example in <a class="reference internal" href="#type-level-literals"><span class="std std-ref">Type-Level Literals</span></a> showing how an overloaded label can be used as a record selector:</p> <pre data-language="haskell">{-# LANGUAGE DataKinds, KindSignatures, MultiParamTypeClasses,
             FunctionalDependencies, FlexibleInstances,
             OverloadedLabels, ScopedTypeVariables #-}

import GHC.OverloadedLabels (IsLabel(..))
import GHC.TypeLits (Symbol)

data Label (l :: Symbol) = Get

class Has a l b | a l -&gt; b where
  from :: a -&gt; Label l -&gt; b

data Point = Point Int Int deriving Show

instance Has Point "x" Int where from (Point x _) _ = x
instance Has Point "y" Int where from (Point _ y) _ = y

instance Has a l b =&gt; IsLabel l (a -&gt; b) where
  fromLabel x = from x (Get :: Label l)

example = #x (Point 1 2)
</pre>   <h2 id="id35">11.8.6. Overloaded lists</h2> <dl class="extension" id="overloaded-lists"> <dt id="extension-OverloadedLists">
<code>OverloadedLists</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8.1</td> </tr>  </table> <p>Enable overloaded list syntax (e.g. desugaring of lists via the <code>IsList</code> class).</p> </dd>
</dl> <p>GHC supports <em>overloading of the list notation</em>. Let us recap the notation for constructing lists. In Haskell, the list notation can be used in the following seven ways:</p> <pre data-language="haskell">[]          -- Empty list
[x]         -- x : []
[x,y,z]     -- x : y : z : []
[x .. ]     -- enumFrom x
[x,y ..]    -- enumFromThen x y
[x .. y]    -- enumFromTo x y
[x,y .. z]  -- enumFromThenTo x y z
</pre> <p>When the <code>OverloadedLists</code> extension is turned on, the aforementioned seven notations are desugared as follows:</p> <pre data-language="haskell">[]          -- fromListN 0 []
[x]         -- fromListN 1 (x : [])
[x,y,z]     -- fromListN 3 (x : y : z : [])
[x .. ]     -- fromList (enumFrom x)
[x,y ..]    -- fromList (enumFromThen x y)
[x .. y]    -- fromList (enumFromTo x y)
[x,y .. z]  -- fromList (enumFromThenTo x y z)
</pre> <p>This extension allows programmers to use the list notation for construction of structures like: <code>Set</code>, <code>Map</code>, <code>IntMap</code>, <code>Vector</code>, <code>Text</code> and <code>Array</code>. The following code listing gives a few examples:</p> <pre data-language="haskell">['0' .. '9']             :: Set Char
[1 .. 10]                :: Vector Int
[("default",0), (k1,v1)] :: Map String Int
['a' .. 'z']             :: Text
</pre> <p>List patterns are also overloaded. When the <code>OverloadedLists</code> extension is turned on, these definitions are desugared as follows</p> <pre data-language="haskell">f [] = ...          -- f (toList -&gt; []) = ...
g [x,y,z] = ...     -- g (toList -&gt; [x,y,z]) = ...
</pre> <p>(Here we are using view-pattern syntax for the translation, see <a class="reference internal" href="#view-patterns"><span class="std std-ref">View patterns</span></a>.)</p>  <h3 id="the-islist-class">11.8.6.1. The <code>IsList</code> class</h3> <p>In the above desugarings, the functions <code>toList</code>, <code>fromList</code> and <code>fromListN</code> are all methods of the <code>IsList</code> class, which is itself exported from the <code>GHC.Exts</code> module. The type class is defined as follows:</p> <pre data-language="haskell">class IsList l where
  type Item l

  fromList :: [Item l] -&gt; l
  toList   :: l -&gt; [Item l]

  fromListN :: Int -&gt; [Item l] -&gt; l
  fromListN _ = fromList
</pre> <p>The <code>IsList</code> class and its methods are intended to be used in conjunction with the <code>OverloadedLists</code> extension.</p> <ul class="simple"> <li>The type function <code>Item</code> returns the type of items of the structure <code>l</code>.</li> <li>The function <code>fromList</code> constructs the structure <code>l</code> from the given list of <code>Item l</code>.</li> <li>The function <code>fromListN</code> takes the input list’s length as a hint. Its behaviour should be equivalent to <code>fromList</code>. The hint can be used for more efficient construction of the structure <code>l</code> compared to <code>fromList</code>. If the given hint is not equal to the input list’s length the behaviour of <code>fromListN</code> is not specified.</li> <li>The function <code>toList</code> should be the inverse of <code>fromList</code>.</li> </ul> <p>It is perfectly fine to declare new instances of <code>IsList</code>, so that list notation becomes useful for completely new data types. Here are several example instances:</p> <pre data-language="haskell">instance IsList [a] where
  type Item [a] = a
  fromList = id
  toList = id

instance (Ord a) =&gt; IsList (Set a) where
  type Item (Set a) = a
  fromList = Set.fromList
  toList = Set.toList

instance (Ord k) =&gt; IsList (Map k v) where
  type Item (Map k v) = (k,v)
  fromList = Map.fromList
  toList = Map.toList

instance IsList (IntMap v) where
  type Item (IntMap v) = (Int,v)
  fromList = IntMap.fromList
  toList = IntMap.toList

instance IsList Text where
  type Item Text = Char
  fromList = Text.pack
  toList = Text.unpack

instance IsList (Vector a) where
  type Item (Vector a) = a
  fromList  = Vector.fromList
  fromListN = Vector.fromListN
  toList = Vector.toList
</pre>   <h3 id="id36">11.8.6.2. Rebindable syntax</h3> <p>When desugaring list notation with <a class="reference internal" href="#extension-OverloadedLists"><code>OverloadedLists</code></a> GHC uses the <code>fromList</code> (etc) methods from module <code>GHC.Exts</code>. You do not need to import <code>GHC.Exts</code> for this to happen.</p> <p>However if you use <a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a>, then GHC instead uses whatever is in scope with the names of <code>toList</code>, <code>fromList</code> and <code>fromListN</code>. That is, these functions are rebindable; c.f. <a class="reference internal" href="#rebindable-syntax"><span class="std std-ref">Rebindable syntax and the implicit Prelude import</span></a>.</p>   <h3 id="defaulting">11.8.6.3. Defaulting</h3> <p>Currently, the <code>IsList</code> class is not accompanied with defaulting rules. Although feasible, not much thought has gone into how to specify the meaning of the default declarations like:</p> <pre data-language="haskell">default ([a])
</pre>   <h3 id="speculation-about-the-future">11.8.6.4. Speculation about the future</h3> <p>The current implementation of the <code>OverloadedLists</code> extension can be improved by handling the lists that are only populated with literals in a special way. More specifically, the compiler could allocate such lists statically using a compact representation and allow <code>IsList</code> instances to take advantage of the compact representation. Equipped with this capability the <code>OverloadedLists</code> extension will be in a good position to subsume the <code>OverloadedStrings</code> extension (currently, as a special case, string literals benefit from statically allocated compact representation).</p>    <h2 id="undecidable-or-recursive-superclasses">11.8.7. Undecidable (or recursive) superclasses</h2> <dl class="extension"> <dt id="extension-UndecidableSuperClasses">
<code>UndecidableSuperClasses</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Allow all superclass constraints, including those that may result in non-termination of the typechecker.</p> </dd>
</dl> <p>The language extension <a class="reference internal" href="#extension-UndecidableSuperClasses"><code>UndecidableSuperClasses</code></a> allows much more flexible constraints in superclasses.</p> <p>A class cannot generally have itself as a superclass. So this is illegal</p> <pre data-language="haskell">class C a =&gt; D a where ...
class D a =&gt; C a where ...
</pre> <p>GHC implements this test conservatively when type functions, or type variables, are involved. For example</p> <pre data-language="haskell">type family F a :: Constraint
class F a =&gt; C a where ...
</pre> <p>GHC will complain about this, because you might later add</p> <pre data-language="haskell">type instance F Int = C Int
</pre> <p>and now we’d be in a superclass loop. Here’s an example involving a type variable</p> <pre data-language="haskell">class f (C f) =&gt; C f
class c       =&gt; Id c
</pre> <p>If we expanded the superclasses of <code>C Id</code> we’d get first <code>Id (C Id)</code> and thence <code>C Id</code> again.</p> <p>But superclass constraints like these are sometimes useful, and the conservative check is annoying where no actual recursion is involved.</p> <p>Moreover genuninely-recursive superclasses are sometimes useful. Here’s a real-life example (Trac #10318)</p> <pre data-language="haskell">class (Frac (Frac a) ~ Frac a,
       Fractional (Frac a),
       IntegralDomain (Frac a))
    =&gt; IntegralDomain a where
 type Frac a :: Type
</pre> <p>Here the superclass cycle does terminate but it’s not entirely straightforward to see that it does.</p> <p>With the language extension <a class="reference internal" href="#extension-UndecidableSuperClasses"><code>UndecidableSuperClasses</code></a> GHC lifts all restrictions on superclass constraints. If there really <em>is</em> a loop, GHC will only expand it to finite depth.</p>    <h1 id="id37">11.9. Type families</h1> <dl class="extension" id="type-families"> <dt id="extension-TypeFamilies">
<code>TypeFamilies</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body">
<a class="reference internal" href="#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a>, <a class="reference internal" href="#extension-KindSignatures"><code>KindSignatures</code></a>, <a class="reference internal" href="#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a>
</td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow use and definition of indexed type and data families.</p> </dd>
</dl> <p>Indexed type families form an extension to facilitate type-level programming. Type families are a generalisation of associated data types <a class="reference internal" href="#assocdatatypes2005" id="id38">[AssocDataTypes2005]</a> and associated type synonyms <a class="reference internal" href="#assoctypesyn2005" id="id39">[AssocTypeSyn2005]</a> Type families themselves are described in Schrijvers 2008 <a class="reference internal" href="#typefamilies2008" id="id40">[TypeFamilies2008]</a>. Type families essentially provide type-indexed data types and named functions on types, which are useful for generic programming and highly parameterised library interfaces as well as interfaces with enhanced static information, much like dependent types. They might also be regarded as an alternative to functional dependencies, but provide a more functional style of type-level programming than the relational style of functional dependencies.</p> <p>Indexed type families, or type families for short, are type constructors that represent sets of types. Set members are denoted by supplying the type family constructor with type parameters, which are called type indices. The difference between vanilla parametrised type constructors and family constructors is much like between parametrically polymorphic functions and (ad-hoc polymorphic) methods of type classes. Parametric polymorphic functions behave the same at all type instances, whereas class methods can change their behaviour in dependence on the class type parameters. Similarly, vanilla type constructors imply the same data representation for all type instances, but family constructors can have varying representation types for varying type indices.</p> <p>Indexed type families come in three flavours: data families, open type synonym families, and closed type synonym families. They are the indexed family variants of algebraic data types and type synonyms, respectively. The instances of data families can be data types and newtypes.</p> <p>Type families are enabled by the language extension <a class="reference internal" href="#extension-TypeFamilies"><code>TypeFamilies</code></a>. Additional information on the use of type families in GHC is available on <a class="reference external" href="http://www.haskell.org/haskellwiki/GHC/Indexed_types">the Haskell wiki page on type families</a>.</p> <table class="docutils citation" frame="void" id="assocdatatypes2005" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id38">[AssocDataTypes2005]</a></td>
<td>“<a class="reference external" href="http://www.cse.unsw.edu.au/~chak/papers/CKPM05.html">Associated Types with Class</a>”, M. Chakravarty, G. Keller, S. Peyton Jones, and S. Marlow. In Proceedings of “The 32nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL‘05)”, pages 1-13, ACM Press, 2005.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="assoctypesyn2005" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id39">[AssocTypeSyn2005]</a></td>
<td>“<a class="reference external" href="http://www.cse.unsw.edu.au/~chak/papers/CKP05.html">Type Associated Type Synonyms</a>”. M. Chakravarty, G. Keller, and S. Peyton Jones. In Proceedings of “The Tenth ACM SIGPLAN International Conference on Functional Programming”, ACM Press, pages 241-253, 2005.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="typefamilies2008" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id40">[TypeFamilies2008]</a></td>
<td>“<a class="reference external" href="http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html">Type Checking with Open Type Functions</a>”, T. Schrijvers, S. Peyton-Jones, M. Chakravarty, and M. Sulzmann, in Proceedings of “ICFP 2008: The 13th ACM SIGPLAN International Conference on Functional Programming”, ACM Press, pages 51-62, 2008.</td>
</tr>  </table>  <h2 id="id41">11.9.1. Data families</h2> <p id="data-families">Data families appear in two flavours: (1) they can be defined on the toplevel or (2) they can appear inside type classes (in which case they are known as associated types). The former is the more general variant, as it lacks the requirement for the type-indexes to coincide with the class parameters. However, the latter can lead to more clearly structured code and compiler warnings if some type instances were - possibly accidentally - omitted. In the following, we always discuss the general toplevel form first and then cover the additional constraints placed on associated types.</p>  <h3 id="id42">11.9.1.1. Data family declarations</h3> <p id="data-family-declarations">Indexed data families are introduced by a signature, such as</p> <pre data-language="haskell">data family GMap k :: Type -&gt; Type
</pre> <p>The special <code>family</code> distinguishes family from standard data declarations. The result kind annotation is optional and, as usual, defaults to <code>Type</code> if omitted. An example is</p> <pre data-language="haskell">data family Array e
</pre> <p>Named arguments can also be given explicit kind signatures if needed. Just as with <a class="reference internal" href="#gadt"><span class="std std-ref">GADT declarations</span></a> named arguments are entirely optional, so that we can declare <code>Array</code> alternatively with</p> <pre data-language="haskell">data family Array :: Type -&gt; Type
</pre> <p>Unlike with ordinary data definitions, the result kind of a data family does not need to be <code>Type</code>: it can alternatively be a kind variable (with <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a>). Data instances’ kinds must end in <code>Type</code>, however.</p>   <h3 id="id43">11.9.1.2. Data instance declarations</h3> <p id="data-instance-declarations">Instance declarations of data and newtype families are very similar to standard data and newtype declarations. The only two differences are that the keyword <code>data</code> or <code>newtype</code> is followed by <code>instance</code> and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed in type parameters, and type synonyms are allowed as long as they are fully applied and expand to a type that is itself admissible - exactly as this is required for occurrences of type synonyms in class instance parameters. For example, the <code>Either</code> instance for <code>GMap</code> is</p> <pre data-language="haskell">data instance GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
</pre> <p>In this example, the declaration has only one variant. In general, it can be any number.</p> <p>When <a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is enabled, type or kind variables used on the left hand side can be explicitly bound. For example:</p> <pre data-language="haskell">data instance forall a (b :: Proxy a). F (Proxy b) = FProxy Bool
</pre> <p>When an explicit <code>forall</code> is present, all <em>type</em> variables mentioned which are not already in scope must be bound by the <code>forall</code>. Kind variables will be implicitly bound if necessary, for example:</p> <pre data-language="haskell">data instance forall (a :: k). F a = FOtherwise
</pre> <p>When the flag <a class="reference internal" href="using-warnings#ghc-flag--Wunused-type-patterns"><code>-Wunused-type-patterns</code></a> is enabled, type variables that are mentioned in the patterns on the left hand side, but not used on the right hand side are reported. Variables that occur multiple times on the left hand side are also considered used. To suppress the warnings, unused variables should be either replaced or prefixed with underscores. Type variables starting with an underscore (<code>_x</code>) are otherwise treated as ordinary type variables.</p> <p>This resembles the wildcards that can be used in <a class="reference internal" href="#partial-type-signatures"><span class="std std-ref">Partial Type Signatures</span></a>. However, there are some differences. No error messages reporting the inferred types are generated, nor does the extension <a class="reference internal" href="#extension-PartialTypeSignatures"><code>PartialTypeSignatures</code></a> have any effect.</p> <p>A type or kind variable explicitly bound using <a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a> but not used on the left hand side will generate an error, not a warning.</p> <p>Data and newtype instance declarations are only permitted when an appropriate family declaration is in scope - just as a class instance declaration requires the class declaration to be visible. Moreover, each instance declaration has to conform to the kind determined by its family declaration. This implies that the number of parameters of an instance declaration matches the arity determined by the kind of the family.</p> <p>A data family instance declaration can use the full expressiveness of ordinary <code>data</code> or <code>newtype</code> declarations:</p> <ul> <li>
<p class="first">Although, a data family is <em>introduced</em> with the keyword “<code>data</code>”, a data family <em>instance</em> can use either <code>data</code> or <code>newtype</code>. For example:</p> <pre data-language="haskell">data family T a
data    instance T Int  = T1 Int | T2 Bool
newtype instance T Char = TC Bool
</pre> </li> <li>
<p class="first">A <code>data instance</code> can use GADT syntax for the data constructors, and indeed can define a GADT. For example:</p> <pre data-language="haskell">data family G a b
data instance G [a] b where
   G1 :: c -&gt; G [Int] b
   G2 :: G [a] Bool
</pre> </li> <li>You can use a <code>deriving</code> clause on a <code>data instance</code> or <code>newtype instance</code> declaration. </li> </ul> <p>Even if data families are defined as toplevel declarations, functions that perform different computations for different family instances may still need to be defined as methods of type classes. In particular, the following is not possible:</p> <pre data-language="haskell">data family T a
data instance T Int  = A
data instance T Char = B
foo :: T a -&gt; Int
foo A = 1
foo B = 2
</pre> <p>Instead, you would have to write <code>foo</code> as a class operation, thus:</p> <pre data-language="haskell">class Foo a where
  foo :: T a -&gt; Int
instance Foo Int where
  foo A = 1
instance Foo Char where
  foo B = 2
</pre> <p>Given the functionality provided by GADTs (Generalised Algebraic Data Types), it might seem as if a definition, such as the above, should be feasible. However, type families - in contrast to GADTs - are <em>open;</em> i.e., new instances can always be added, possibly in other modules. Supporting pattern matching across different data instances would require a form of extensible case construct.</p>   <h3 id="data-family-overlap">11.9.1.3. Overlap of data instances</h3> <p id="overlap-of-data-instances">The instance declarations of a data family used in a single program may not overlap at all, independent of whether they are associated or not. In contrast to type class instances, this is not only a matter of consistency, but one of type safety.</p>    <h2 id="id44">11.9.2. Synonym families</h2> <p id="synonym-families">Type families appear in three flavours: (1) they can be defined as open families on the toplevel, (2) they can be defined as closed families on the toplevel, or (3) they can appear inside type classes (in which case they are known as associated type synonyms). Toplevel families are more general, as they lack the requirement for the type-indexes to coincide with the class parameters. However, associated type synonyms can lead to more clearly structured code and compiler warnings if some type instances were - possibly accidentally - omitted. In the following, we always discuss the general toplevel forms first and then cover the additional constraints placed on associated types. Note that closed associated type synonyms do not exist.</p>  <h3 id="id45">11.9.2.1. Type family declarations</h3> <p id="type-family-declarations">Open indexed type families are introduced by a signature, such as</p> <pre data-language="haskell">type family Elem c :: Type
</pre> <p>The special <code>family</code> distinguishes family from standard type declarations. The result kind annotation is optional and, as usual, defaults to <code>Type</code> if omitted. An example is</p> <pre data-language="haskell">type family Elem c
</pre> <p>Parameters can also be given explicit kind signatures if needed. We call the number of parameters in a type family declaration, the family’s arity, and all applications of a type family must be fully saturated with respect to that arity. This requirement is unlike ordinary type synonyms and it implies that the kind of a type family is not sufficient to determine a family’s arity, and hence in general, also insufficient to determine whether a type family application is well formed. As an example, consider the following declaration:</p> <pre data-language="haskell">type family F a b :: Type -&gt; Type
  -- F's arity is 2,
  -- although its overall kind is Type -&gt; Type -&gt; Type -&gt; Type
</pre> <p>Given this declaration the following are examples of well-formed and malformed types:</p> <pre data-language="haskell">F Char [Int]       -- OK!  Kind: Type -&gt; Type
F Char [Int] Bool  -- OK!  Kind: Type
F IO Bool          -- WRONG: kind mismatch in the first argument
F Bool             -- WRONG: unsaturated application
</pre> <p>The result kind annotation is optional and defaults to <code>Type</code> (like argument kinds) if omitted. Polykinded type families can be declared using a parameter in the kind annotation:</p> <pre data-language="haskell">type family F a :: k
</pre> <p>In this case the kind parameter <code>k</code> is actually an implicit parameter of the type family.</p>   <h3 id="id46">11.9.2.2. Type instance declarations</h3> <p id="type-instance-declarations">Instance declarations of type families are very similar to standard type synonym declarations. The only two differences are that the keyword <code>type</code> is followed by <code>instance</code> and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed, and type synonyms are allowed as long as they are fully applied and expand to a type that is admissible - these are the exact same requirements as for data instances. For example, the <code>[e]</code> instance for <code>Elem</code> is</p> <pre data-language="haskell">type instance Elem [e] = e
</pre> <p>Type arguments can be replaced with underscores (<code>_</code>) if the names of the arguments don’t matter. This is the same as writing type variables with unique names. Unused type arguments can be replaced or prefixed with underscores to avoid warnings when the <a class="reference internal" href="using-warnings#ghc-flag--Wunused-type-patterns"><code>-Wunused-type-patterns</code></a> flag is enabled. The same rules apply as for <a class="reference internal" href="#data-instance-declarations"><span class="std std-ref">Data instance declarations</span></a>.</p> <p>Also in the same way as <a class="reference internal" href="#data-instance-declarations"><span class="std std-ref">Data instance declarations</span></a>, when <a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is enabled, type and kind variables can be explicilty bound in a type instance declaration.</p> <p>Type family instance declarations are only legitimate when an appropriate family declaration is in scope - just like class instances require the class declaration to be visible. Moreover, each instance declaration has to conform to the kind determined by its family declaration, and the number of type parameters in an instance declaration must match the number of type parameters in the family declaration. Finally, the right-hand side of a type instance must be a monotype (i.e., it may not include foralls) and after the expansion of all saturated vanilla type synonyms, no synonyms, except family synonyms may remain.</p>   <h3 id="id47">11.9.2.3. Closed type families</h3> <p id="closed-type-families">A type family can also be declared with a <code>where</code> clause, defining the full set of equations for that family. For example:</p> <pre data-language="haskell">type family F a where
  F Int  = Double
  F Bool = Char
  F a    = String
</pre> <p>A closed type family’s equations are tried in order, from top to bottom, when simplifying a type family application. In this example, we declare an instance for <code>F</code> such that <code>F Int</code> simplifies to <code>Double</code>, <code>F Bool</code> simplifies to <code>Char</code>, and for any other type <code>a</code> that is known not to be <code>Int</code> or <code>Bool</code>, <code>F a</code> simplifies to <code>String</code>. Note that GHC must be sure that <code>a</code> cannot unify with <code>Int</code> or <code>Bool</code> in that last case; if a programmer specifies just <code>F a</code> in their code, GHC will not be able to simplify the type. After all, <code>a</code> might later be instantiated with <code>Int</code>.</p> <p>A closed type family’s equations have the same restrictions and extensions as the equations for open type family instances. For instance, when <a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is enabled, type or kind variables used on the left hand side of an equation can be explicitly bound, such as in:</p> <pre data-language="haskell">type family R a where
  forall t a. R (t a) = [a]
  forall a.   R a     = a
</pre> <p>A closed type family may be declared with no equations. Such closed type families are opaque type-level definitions that will never reduce, are not necessarily injective (unlike empty data types), and cannot be given any instances. This is different from omitting the equations of a closed type family in a <code>hs-boot</code> file, which uses the syntax <code>where ..</code>, as in that case there may or may not be equations given in the <code>hs</code> file.</p>   <h3 id="id48">11.9.2.4. Type family examples</h3> <p id="type-family-examples">Here are some examples of admissible and illegal type instances:</p> <pre data-language="haskell">type family F a :: Type
type instance F [Int]   = Int   -- OK!
type instance F String  = Char  -- OK!
type instance F (F a)   = a     -- WRONG: type parameter mentions a type family
type instance
  F (forall a. (a, b))  = b     -- WRONG: a forall type appears in a type parameter
type instance
  F Float = forall a.a          -- WRONG: right-hand side may not be a forall type
type family H a where          -- OK!
  H Int  = Int
  H Bool = Bool
  H a    = String
type instance H Char = Char    -- WRONG: cannot have instances of closed family
type family K a where          -- OK!

type family G a b :: Type -&gt; Type
type instance G Int            = (,)     -- WRONG: must be two type parameters
type instance G Int Char Float = Double  -- WRONG: must be two type parameters
</pre>   <h3 id="type-family-overlap">11.9.2.5. Compatibility and apartness of type family equations</h3> <p id="compatibility-and-apartness-of-type-family-equations">There must be some restrictions on the equations of type families, lest we define an ambiguous rewrite system. So, equations of open type families are restricted to be compatible. Two type patterns are compatible if</p> <ol class="arabic simple"> <li>all corresponding types and implicit kinds in the patterns are apart, or</li> <li>the two patterns unify producing a substitution, and the right-hand sides are equal under that substitution.</li> </ol> <p>Two types are considered apart if, for all possible substitutions, the types cannot reduce to a common reduct.</p> <p>The first clause of “compatible” is the more straightforward one. It says that the patterns of two distinct type family instances cannot overlap. For example, the following is disallowed:</p> <pre data-language="haskell">type instance F Int = Bool
type instance F Int = Char
</pre> <p>The second clause is a little more interesting. It says that two overlapping type family instances are allowed if the right-hand sides coincide in the region of overlap. Some examples help here:</p> <pre data-language="haskell">type instance F (a, Int) = [a]
type instance F (Int, b) = [b]   -- overlap permitted

type instance G (a, Int)  = [a]
type instance G (Char, a) = [a]  -- ILLEGAL overlap, as [Char] /= [Int]
</pre> <p>Note that this compatibility condition is independent of whether the type family is associated or not, and it is not only a matter of consistency, but one of type safety.</p> <p>For a polykinded type family, the kinds are checked for apartness just like types. For example, the following is accepted:</p> <pre data-language="haskell">type family J a :: k
type instance J Int = Bool
type instance J Int = Maybe
</pre> <p>These instances are compatible because they differ in their implicit kind parameter; the first uses <code>Type</code> while the second uses <code>Type -&gt; Type</code>.</p> <p>The definition for “compatible” uses a notion of “apart”, whose definition in turn relies on type family reduction. This condition of “apartness”, as stated, is impossible to check, so we use this conservative approximation: two types are considered to be apart when the two types cannot be unified, even by a potentially infinite unifier. Allowing the unifier to be infinite disallows the following pair of instances:</p> <pre data-language="haskell">type instance H x   x = Int
type instance H [x] x = Bool
</pre> <p>The type patterns in this pair equal if <code>x</code> is replaced by an infinite nesting of lists. Rejecting instances such as these is necessary for type soundness.</p> <p>Compatibility also affects closed type families. When simplifying an application of a closed type family, GHC will select an equation only when it is sure that no incompatible previous equation will ever apply. Here are some examples:</p> <pre data-language="haskell">type family F a where
  F Int = Bool
  F a   = Char

type family G a where
  G Int = Int
  G a   = a
</pre> <p>In the definition for <code>F</code>, the two equations are incompatible – their patterns are not apart, and yet their right-hand sides do not coincide. Thus, before GHC selects the second equation, it must be sure that the first can never apply. So, the type <code>F a</code> does not simplify; only a type such as <code>F Double</code> will simplify to <code>Char</code>. In <code>G</code>, on the other hand, the two equations are compatible. Thus, GHC can ignore the first equation when looking at the second. So, <code>G a</code> will simplify to <code>a</code>.</p> <p>However see <a class="reference internal" href="ghci#ghci-decls"><span class="std std-ref">Type, class and other declarations</span></a> for the overlap rules in GHCi.</p>   <h3 id="type-family-decidability">11.9.2.6. Decidability of type synonym instances</h3> <dl class="extension" id="decidability-of-type-synonym-instances"> <dt>
<code>UndecidableInstances</code> </dt> <dd>
<p>Relax restrictions on the decidability of type synonym family instances.</p> </dd>
</dl> <p>In order to guarantee that type inference in the presence of type families decidable, we need to place a number of additional restrictions on the formation of type instance declarations (c.f., Definition 5 (Relaxed Conditions) of “<a class="reference external" href="http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html">Type Checking with Open Type Functions</a>”). Instance declarations have the general form</p> <pre data-language="haskell">type instance F t1 .. tn = t
</pre> <p>where we require that for every type family application <code>(G s1 .. sm)</code> in <code>t</code>,</p> <ol class="arabic simple"> <li>
<code>s1 .. sm</code> do not contain any type family constructors,</li> <li>the total number of symbols (data type constructors and type variables) in <code>s1 .. sm</code> is strictly smaller than in <code>t1 .. tn</code>, and</li> <li>for every type variable <code>a</code>, <code>a</code> occurs in <code>s1 .. sm</code> at most as often as in <code>t1 .. tn</code>.</li> </ol> <p>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, ‘’loopy equalities’‘, such as <code>a ~ [F a]</code>, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</p> <p>If the option <a class="reference internal" href="#extension-UndecidableInstances"><code>UndecidableInstances</code></a> is passed to the compiler, the above restrictions are not enforced and it is on the programmer to ensure termination of the normalisation of type families during type inference.</p>    <h2 id="type-wildcards-lhs">11.9.3. Wildcards on the LHS of data and type family instances</h2> <p id="wildcards-on-the-lhs-of-data-and-type-family-instances">When the name of a type argument of a data or type instance declaration doesn’t matter, it can be replaced with an underscore (<code>_</code>). This is the same as writing a type variable with a unique name.</p> <pre data-language="haskell">data family F a b :: Type
data instance F Int _ = Int
-- Equivalent to  data instance F Int b = Int

type family T a :: Type
type instance T (a,_) = a
-- Equivalent to  type instance T (a,b) = a
</pre> <p>This use of underscore for wildcard in a type pattern is exactly like pattern matching in the term language, but is rather different to the use of a underscore in a partial type signature (see <a class="reference internal" href="#type-wildcards"><span class="std std-ref">Type Wildcards</span></a>).</p> <p>A type variable beginning with an underscore is not treated specially in a type or data instance declaration. For example:</p> <pre data-language="haskell">data instance F Bool _a = _a -&gt; Int
-- Equivalent to  data instance F Bool a = a -&gt; Int
</pre> <p>Contrast this with the special treatment of named wildcards in type signatures (<a class="reference internal" href="#named-wildcards"><span class="std std-ref">Named Wildcards</span></a>).</p>   <h2 id="assoc-decl">11.9.4. Associated data and type families</h2> <p id="associated-data-and-type-families">A data or type synonym family can be declared as part of a type class, thus:</p> <pre data-language="haskell">class GMapKey k where
  data GMap k :: Type -&gt; Type
  ...

class Collects ce where
  type Elem ce :: Type
  ...
</pre> <p>When doing so, we (optionally) may drop the “<code>family</code>” keyword.</p> <p>The type parameters must all be type variables, of course, and some (but not necessarily all) of then can be the class parameters. Each class parameter may only be used at most once per associated type, but some may be omitted and they may be in an order other than in the class head. Hence, the following contrived example is admissible:</p> <pre data-language="haskell">class C a b c where
  type T c a x :: Type
</pre> <p>Here <code>c</code> and <code>a</code> are class parameters, but the type is also indexed on a third parameter <code>x</code>.</p>  <h3 id="assoc-inst">11.9.4.1. Associated instances</h3> <p id="associated-instances">When an associated data or type synonym family instance is declared within a type class instance, we (optionally) may drop the <code>instance</code> keyword in the family instance:</p> <pre data-language="haskell">instance (GMapKey a, GMapKey b) =&gt; GMapKey (Either a b) where
  data GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
  ...

instance Eq (Elem [e]) =&gt; Collects [e] where
  type Elem [e] = e
  ...
</pre> <p>The data or type family instance for an associated type must follow the rule that the type indexes corresponding to class parameters must have precisely the same as type given in the instance head. For example:</p> <pre data-language="haskell">class Collects ce where
  type Elem ce :: Type

instance Eq (Elem [e]) =&gt; Collects [e] where
  -- Choose one of the following alternatives:
  type Elem [e] = e       -- OK
  type Elem [x] = x       -- BAD; '[x]' is different to '[e]' from head
  type Elem x   = x       -- BAD; 'x' is different to '[e]'
  type Elem [Maybe x] = x -- BAD: '[Maybe x]' is different to '[e]'
</pre> <p>Note the following points:</p> <ul> <li>An instance for an associated family can only appear as part of an instance declarations of the class in which the family was declared, just as with the equations of the methods of a class. </li> <li>
<p class="first">The type variables on the right hand side of the type family equation must, as usual, be explicitly bound by the left hand side. This restriction is relaxed for <em>kind</em> variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound. For example, these are legitimate:</p> <pre data-language="haskell">data family Nat :: k -&gt; k -&gt; Type
-- k is implicitly bound by an invisible kind pattern
newtype instance Nat :: (k -&gt; Type) -&gt; (k -&gt; Type) -&gt; Type where
  Nat :: (forall xx. f xx -&gt; g xx) -&gt; Nat f g

class Funct f where
  type Codomain f :: Type
instance Funct ('KProxy :: KProxy o) where
  -- o is implicitly bound by the kind signature
  -- of the LHS type pattern ('KProxy)
  type Codomain 'KProxy = NatTr (Proxy :: o -&gt; Type)
</pre> </li> <li>The instance for an associated type can be omitted in class instances. In that case, unless there is a default instance (see <a class="reference internal" href="#assoc-decl-defs"><span class="std std-ref">Associated type synonym defaults</span></a>), the corresponding instance type is not inhabited; i.e., only diverging expressions, such as <code>undefined</code>, can assume the type. </li> <li>
<p class="first">Although it is unusual, there (currently) can be <em>multiple</em> instances for an associated family in a single instance declaration. For example, this is legitimate:</p> <pre data-language="haskell">instance GMapKey Flob where
  data GMap Flob [v] = G1 v
  data GMap Flob Int = G2 Int
  ...
</pre> <p>Here we give two data instance declarations, one in which the last parameter is <code>[v]</code>, and one for which it is <code>Int</code>. Since you cannot give any <em>subsequent</em> instances for <code>(GMap Flob ...)</code>, this facility is most useful when the free indexed parameter is of a kind with a finite number of alternatives (unlike <code>Type</code>).</p> </li> <li>
<p class="first">When <a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is enabled, type and kind variables can be explicily bound in associated data or type family instances in the same way (and with the same restrictions) as <a class="reference internal" href="#data-instance-declarations"><span class="std std-ref">Data instance declarations</span></a> or <a class="reference internal" href="#type-instance-declarations"><span class="std std-ref">Type instance declarations</span></a>. For example, adapting the above, the following is accepted:</p> <pre data-language="haskell">instance Eq (Elem [e]) =&gt; Collects [e] where
  type forall e. Elem [e] = e
</pre> </li> </ul>   <h3 id="assoc-decl-defs">11.9.4.2. Associated type synonym defaults</h3> <p id="associated-type-synonym-defaults">It is possible for the class defining the associated type to specify a default for associated type instances. So for example, this is OK:</p> <pre data-language="haskell">class IsBoolMap v where
  type Key v
  type instance Key v = Int

  lookupKey :: Key v -&gt; v -&gt; Maybe Bool

instance IsBoolMap [(Int, Bool)] where
  lookupKey = lookup
</pre> <p>In an <code>instance</code> declaration for the class, if no explicit <code>type instance</code> declaration is given for the associated type, the default declaration is used instead, just as with default class methods.</p> <p>Note the following points:</p> <ul> <li>The <code>instance</code> keyword is optional. </li> <li>There can be at most one default declaration for an associated type synonym. </li> <li>A default declaration is not permitted for an associated <em>data</em> type. </li> <li>
<p class="first">The default declaration must mention only type <em>variables</em> on the left hand side, and the right hand side must mention only type variables that are explicitly bound on the left hand side. This restriction is relaxed for <em>kind</em> variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound on the left hand side.</p> <p>Because of this, unlike <a class="reference internal" href="#assoc-inst"><span class="std std-ref">Associated instances</span></a>, explicit binding of type/kind variables in default declarations is not permitted by <a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a>.</p> </li> <li>Unlike the associated type family declaration itself, the type variables of the default instance are independent of those of the parent class. </li> </ul> <p>Here are some examples:</p> <pre data-language="haskell">class C (a :: Type) where
  type F1 a :: Type
  type instance F1 a = [a]     -- OK
  type instance F1 a = a-&gt;a    -- BAD; only one default instance is allowed

  type F2 b a                  -- OK; note the family has more type
                               --     variables than the class
  type instance F2 c d = c-&gt;d  -- OK; you don't have to use 'a' in the type instance

  type F3 a
  type F3 [b] = b              -- BAD; only type variables allowed on the LHS

  type F4 a
  type F4 b = a                -- BAD; 'a' is not in scope  in the RHS

  type F5 a :: [k]
  type F5 a = ('[] :: [x])     -- OK; the kind variable x is implicitly
                                      bound by an invisible kind pattern
                                      on the LHS

  type F6 a
  type F6 a =
    Proxy ('[] :: [x])         -- BAD; the kind variable x is not bound,
                                       even by an invisible kind pattern

  type F7 (x :: a) :: [a]
  type F7 x = ('[] :: [a])     -- OK; the kind variable a is implicitly
                                      bound by the kind signature of the
                                      LHS type pattern
</pre>   <h3 id="scoping-class-params">11.9.4.3. Scoping of class parameters</h3> <p id="scoping-of-class-parameters">The visibility of class parameters in the right-hand side of associated family instances depends <em>solely</em> on the parameters of the family. As an example, consider the simple class declaration</p> <pre data-language="haskell">class C a b where
  data T a
</pre> <p>Only one of the two class parameters is a parameter to the data family. Hence, the following instance declaration is invalid:</p> <pre data-language="haskell">instance C [c] d where
  data T [c] = MkT (c, d)    -- WRONG!!  'd' is not in scope
</pre> <p>Here, the right-hand side of the data instance mentions the type variable <code>d</code> that does not occur in its left-hand side. We cannot admit such data instances as they would compromise type safety.</p> <p>Bear in mind that it is also possible for the <em>right</em>-hand side of an associated family instance to contain <em>kind</em> parameters (by using the <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a> extension). For instance, this class and instance are perfectly admissible:</p> <pre data-language="haskell">class C k where
  type T :: k

instance C (Maybe a) where
  type T = (Nothing :: Maybe a)
</pre> <p>Here, although the right-hand side <code>(Nothing :: Maybe a)</code> mentions a kind variable <code>a</code> which does not occur on the left-hand side, this is acceptable, because <code>a</code> is <em>implicitly</em> bound by <code>T</code>‘s kind pattern.</p> <p>A kind variable can also be bound implicitly in a LHS type pattern, as in this example:</p> <pre data-language="haskell">class C a where
  type T (x :: a) :: [a]

instance C (Maybe a) where
  type T x = ('[] :: [Maybe a])
</pre> <p>In <code>('[] :: [Maybe a])</code>, the kind variable <code>a</code> is implicitly bound by the kind signature of the LHS type pattern <code>x</code>.</p>   <h3 id="instance-contexts-and-associated-type-and-data-instances">11.9.4.4. Instance contexts and associated type and data instances</h3> <p>Associated type and data instance declarations do not inherit any context specified on the enclosing instance. For type instance declarations, it is unclear what the context would mean. For data instance declarations, it is unlikely a user would want the context repeated for every data constructor. The only place where the context might likely be useful is in a <code>deriving</code> clause of an associated data instance. However, even here, the role of the outer instance context is murky. So, for clarity, we just stick to the rule above: the enclosing instance context is ignored. If you need to use a non-trivial context on a derived instance, use a <a class="reference internal" href="#extension-StandaloneDeriving"><code>standalone deriving</code></a> clause (at the top level).</p>    <h2 id="data-family-import-export">11.9.5. Import and export</h2> <p id="import-and-export">The rules for export lists (Haskell Report <a class="reference external" href="http://www.haskell.org/onlinereport/modules.html#sect5.2">Section 5.2</a>) needs adjustment for type families:</p> <ul class="simple"> <li>The form <code>T(..)</code>, where <code>T</code> is a data family, names the family <code>T</code> and all the in-scope constructors (whether in scope qualified or unqualified) that are data instances of <code>T</code>.</li> <li>The form <code>T(.., ci, .., fj, ..)</code>, where <code>T</code> is a data family, names <code>T</code> and the specified constructors <code>ci</code> and fields <code>fj</code> as usual. The constructors and field names must belong to some data instance of <code>T</code>, but are not required to belong to the <em>same</em> instance.</li> <li>The form <code>C(..)</code>, where <code>C</code> is a class, names the class <code>C</code> and all its methods <em>and associated types</em>.</li> <li>The form <code>C(.., mi, .., type Tj, ..)</code>, where <code>C</code> is a class, names the class <code>C</code>, and the specified methods <code>mi</code> and associated types <code>Tj</code>. The types need a keyword “<code>type</code>” to distinguish them from data constructors.</li> <li>Whenever there is no export list and a data instance is defined, the corresponding data family type constructor is exported along with the new data constructors, regardless of whether the data family is defined locally or in another module.</li> </ul>  <h3 id="data-family-impexp-examples">11.9.5.1. Examples</h3> <p id="examples">Recall our running <code>GMapKey</code> class example:</p> <pre data-language="haskell">class GMapKey k where
  data GMap k :: Type -&gt; Type
  insert :: GMap k v -&gt; k -&gt; v -&gt; GMap k v
  lookup :: GMap k v -&gt; k -&gt; Maybe v
  empty  :: GMap k v

instance (GMapKey a, GMapKey b) =&gt; GMapKey (Either a b) where
  data GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
  ...method declarations...
</pre> <p>Here are some export lists and their meaning:</p> <ul> <li>
<pre data-language="haskell">module GMap( GMapKey )
</pre> <p>Exports just the class name.</p> </li> <li>
<pre data-language="haskell">module GMap( GMapKey(..) )
</pre> <p>Exports the class, the associated type <code>GMap</code> and the member functions <code>empty</code>, <code>lookup</code>, and <code>insert</code>. The data constructors of <code>GMap</code> (in this case <code>GMapEither</code>) are not exported.</p> </li> <li>
<pre data-language="haskell">module GMap( GMapKey( type GMap, empty, lookup, insert ) )
</pre> <p>Same as the previous item. Note the “<code>type</code>” keyword.</p> </li> <li>
<pre data-language="haskell">module GMap( GMapKey(..), GMap(..) )
</pre> <p>Same as previous item, but also exports all the data constructors for <code>GMap</code>, namely <code>GMapEither</code>.</p> </li> <li>
<pre data-language="haskell">module GMap ( GMapKey( empty, lookup, insert), GMap(..) )
</pre> <p>Same as previous item.</p> </li> <li>
<pre data-language="haskell">module GMap ( GMapKey, empty, lookup, insert, GMap(..) )
</pre> <p>Same as previous item.</p> </li> </ul> <p>Two things to watch out for:</p> <ul> <li>You cannot write <code>GMapKey(type GMap(..))</code> — i.e., sub-component specifications cannot be nested. To specify <code>GMap</code>‘s data constructors, you have to list it separately. </li> <li>
<p class="first">Consider this example:</p> <pre data-language="haskell">module X where
  data family D

module Y where
  import X
  data instance D Int = D1 | D2
</pre> <p>Module <code>Y</code> exports all the entities defined in <code>Y</code>, namely the data constructors <code>D1</code> and <code>D2</code>, and <em>implicitly</em> the data family <code>D</code>, even though it’s defined in <code>X</code>. This means you can write <code>import Y( D(D1,D2) )</code> <em>without</em> giving an explicit export list like this:</p> <pre data-language="haskell">     module Y( D(..) ) where ...
or   module Y( module Y, D ) where ...
</pre> </li> </ul>   <h3 id="data-family-impexp-instances">11.9.5.2. Instances</h3> <p id="instances">Family instances are implicitly exported, just like class instances. However, this applies only to the heads of instances, not to the data constructors an instance defines.</p>    <h2 id="ty-fams-in-instances">11.9.6. Type families and instance declarations</h2> <p id="type-families-and-instance-declarations">Type families require us to extend the rules for the form of instance heads, which are given in <a class="reference internal" href="#flexible-instance-head"><span class="std std-ref">Relaxed rules for the instance head</span></a>. Specifically:</p> <ul class="simple"> <li>Data type families may appear in an instance head</li> <li>Type synonym families may not appear (at all) in an instance head</li> </ul> <p>The reason for the latter restriction is that there is no way to check for instance matching. Consider</p> <pre data-language="haskell">type family F a
type instance F Bool = Int

class C a

instance C Int
instance C (F a)
</pre> <p>Now a constraint <code>(C (F Bool))</code> would match both instances. The situation is especially bad because the type instance for <code>F Bool</code> might be in another module, or even in a module that is not yet written.</p> <p>However, type class instances of instances of data families can be defined much like any other data type. For example, we can say</p> <pre data-language="haskell">data instance T Int = T1 Int | T2 Bool
instance Eq (T Int) where
  (T1 i) == (T1 j) = i==j
  (T2 i) == (T2 j) = i==j
  _      == _      = False
</pre> <p>Note that class instances are always for particular <em>instances</em> of a data family and never for an entire family as a whole. This is for essentially the same reasons that we cannot define a toplevel function that performs pattern matching on the data constructors of <em>different</em> instances of a single type family. It would require a form of extensible case construct.</p> <p>Data instance declarations can also have <code>deriving</code> clauses. For example, we can write</p> <pre data-language="haskell">data GMap () v = GMapUnit (Maybe v)
               deriving Show
</pre> <p>which implicitly defines an instance of the form</p> <pre data-language="haskell">instance Show v =&gt; Show (GMap () v) where ...
</pre>   <h2 id="injective-ty-fams">11.9.7. Injective type families</h2> <dl class="extension" id="injective-type-families"> <dt id="extension-TypeFamilyDependencies">
<code>TypeFamilyDependencies</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-TypeFamilies"><code>TypeFamilies</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Allow functional dependency annotations on type families. This allows one to define injective type families.</p> </dd>
</dl> <p>Starting with GHC 8.0 type families can be annotated with injectivity information. This information is then used by GHC during type checking to resolve type ambiguities in situations where a type variable appears only under type family applications. Consider this contrived example:</p> <pre data-language="haskell">type family Id a
type instance Id Int = Int
type instance Id Bool = Bool

id :: Id t -&gt; Id t
id x = x
</pre> <p>Here the definition of <code>id</code> will be rejected because type variable <code>t</code> appears only under type family applications and is thus ambiguous. But this code will be accepted if we tell GHC that <code>Id</code> is injective, which means it will be possible to infer <code>t</code> at call sites from the type of the argument:</p> <pre data-language="haskell">type family Id a = r | r -&gt; a
</pre> <p>Injective type families are enabled with <code>-XTypeFamilyDependencies</code> language extension. This extension implies <code>-XTypeFamilies</code>.</p> <p>For full details on injective type families refer to Haskell Symposium 2015 paper <a class="reference external" href="http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf">Injective type families for Haskell</a>.</p>  <h3 id="injective-ty-fams-syntax">11.9.7.1. Syntax of injectivity annotation</h3> <p id="syntax-of-injectivity-annotation">Injectivity annotation is added after type family head and consists of two parts:</p> <ul class="simple"> <li>a type variable that names the result of a type family. Syntax: <code>= tyvar</code> or <code>= (tyvar :: kind)</code>. Type variable must be fresh.</li> <li>an injectivity annotation of the form <code>| A -&gt; B</code>, where <code>A</code> is the result type variable (see previous bullet) and <code>B</code> is a list of argument type and kind variables in which type family is injective. It is possible to omit some variables if type family is not injective in them.</li> </ul> <p>Examples:</p> <pre data-language="haskell">type family Id a = result | result -&gt; a where
type family F a b c = d | d -&gt; a c b
type family G (a :: k) b c = foo | foo -&gt; k b where
</pre> <p>For open and closed type families it is OK to name the result but skip the injectivity annotation. This is not the case for associated type synonyms, where the named result without injectivity annotation will be interpreted as associated type synonym default.</p>   <h3 id="injective-ty-fams-typecheck">11.9.7.2. Verifying injectivity annotation against type family equations</h3> <p id="verifying-injectivity-annotation-against-type-family-equations">Once the user declares type family to be injective GHC must verify that this declaration is correct, ie. type family equations don’t violate the injectivity annotation. A general idea is that if at least one equation (bullets (1), (2) and (3) below) or a pair of equations (bullets (4) and (5) below) violates the injectivity annotation then a type family is not injective in a way user claims and an error is reported. In the bullets below <em>RHS</em> refers to the right-hand side of the type family equation being checked for injectivity. <em>LHS</em> refers to the arguments of that type family equation. Below are the rules followed when checking injectivity of a type family:</p> <ol class="arabic"> <li>If a RHS of a type family equation is a type family application GHC reports that the type family is not injective. </li> <li>If a RHS of a type family equation is a bare type variable we require that all LHS variables (including implicit kind variables) are also bare. In other words, this has to be a sole equation of that type family and it has to cover all possible patterns. If the patterns are not covering GHC reports that the type family is not injective. </li> <li>If a LHS type variable that is declared as injective is not mentioned on injective position in the RHS GHC reports that the type family is not injective. Injective position means either argument to a type constructor or injective argument to a type family. </li> <li>
<p class="first"><em>Open type families</em> Open type families are typechecked incrementally. This means that when a module is imported type family instances contained in that module are checked against instances present in already imported modules.</p> <p>A pair of an open type family equations is checked by attempting to unify their RHSs. If the RHSs don’t unify this pair does not violate injectivity annotation. If unification succeeds with a substitution then LHSs of unified equations must be identical under that substitution. If they are not identical then GHC reports that the type family is not injective.</p> </li> <li>
<p class="first">In a <em>closed type family</em> all equations are ordered and in one place. Equations are also checked pair-wise but this time an equation has to be paired with all the preceeding equations. Of course a single-equation closed type family is trivially injective (unless (1), (2) or (3) above holds).</p> <p>When checking a pair of closed type family equations GHC tried to unify their RHSs. If they don’t unify this pair of equations does not violate injectivity annotation. If the RHSs can be unified under some substitution (possibly empty) then either the LHSs unify under the same substitution or the LHS of the latter equation is subsumed by earlier equations. If neither condition is met GHC reports that a type family is not injective.</p> </li> </ol> <p>Note that for the purpose of injectivity check in bullets (4) and (5) GHC uses a special variant of unification algorithm that treats type family applications as possibly unifying with anything.</p>     <h1 id="promotion">11.10. Datatype promotion</h1> <dl class="extension" id="datatype-promotion"> <dt id="extension-DataKinds">
<code>DataKinds</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.4.1</td> </tr>  </table> <p>Allow promotion of data types to kind level.</p> </dd>
</dl> <p>This section describes <em>data type promotion</em>, an extension to the kind system that complements kind polymorphism. It is enabled by <a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a>, and described in more detail in the paper <a class="reference external" href="http://dreixel.net/research/pdf/ghp.pdf">Giving Haskell a Promotion</a>, which appeared at TLDI 2012.</p>  <h2 id="motivation">11.10.1. Motivation</h2> <p>Standard Haskell has a rich type language. Types classify terms and serve to avoid many common programming mistakes. The kind language, however, is relatively simple, distinguishing only regular types (kind <code>Type</code>) and type constructors (e.g. kind <code>Type -&gt; Type -&gt; Type</code>). In particular when using advanced type system features, such as type families (<a class="reference internal" href="#type-families"><span class="std std-ref">Type families</span></a>) or GADTs (<a class="reference internal" href="#gadt"><span class="std std-ref">Generalised Algebraic Data Types (GADTs)</span></a>), this simple kind system is insufficient, and fails to prevent simple errors. Consider the example of type-level natural numbers, and length-indexed vectors:</p> <pre data-language="haskell">data Ze
data Su n

data Vec :: Type -&gt; Type -&gt; Type where
  Nil  :: Vec a Ze
  Cons :: a -&gt; Vec a n -&gt; Vec a (Su n)
</pre> <p>The kind of <code>Vec</code> is <code>Type -&gt; Type -&gt; Type</code>. This means that, e.g., <code>Vec Int Char</code> is a well-kinded type, even though this is not what we intend when defining length-indexed vectors.</p> <p>With <a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a>, the example above can then be rewritten to:</p> <pre data-language="haskell">data Nat = Ze | Su Nat

data Vec :: Type -&gt; Nat -&gt; Type where
  Nil  :: Vec a 'Ze
  Cons :: a -&gt; Vec a n -&gt; Vec a ('Su n)
</pre> <p>With the improved kind of <code>Vec</code>, things like <code>Vec Int Char</code> are now ill-kinded, and GHC will report an error.</p>   <h2 id="overview">11.10.2. Overview</h2> <p>With <a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a>, GHC automatically promotes every datatype to be a kind and its (value) constructors to be type constructors. The following types</p> <pre data-language="haskell">data Nat = Zero | Succ Nat

data List a = Nil | Cons a (List a)

data Pair a b = Pair a b

data Sum a b = L a | R b
</pre> <p>give rise to the following kinds and type constructors (where promoted constructors are prefixed by a tick <code>'</code>):</p> <pre data-language="haskell">Nat :: Type
'Zero :: Nat
'Succ :: Nat -&gt; Nat

List :: Type -&gt; Type
'Nil  :: forall k. List k
'Cons :: forall k. k -&gt; List k -&gt; List k

Pair  :: Type -&gt; Type -&gt; Type
'Pair :: forall k1 k2. k1 -&gt; k2 -&gt; Pair k1 k2

Sum :: Type -&gt; Type -&gt; Type
'L :: k1 -&gt; Sum k1 k2
'R :: k2 -&gt; Sum k1 k2
</pre> <p>Virtually all data constructors, even those with rich kinds, can be promoted. There are only a couple of exceptions to this rule:</p> <ul> <li>Data family instance constructors cannot be promoted at the moment. GHC’s type theory just isn’t up to the task of promoting data families, which requires full dependent types. </li> <li>
<p class="first">Data constructors with contexts that contain non-equality constraints cannot be promoted. For example:</p> <pre data-language="haskell">data Foo :: Type -&gt; Type where
  MkFoo1 :: a ~ Int         =&gt; Foo a    -- promotable
  MkFoo2 :: a ~~ Int        =&gt; Foo a    -- promotable
  MkFoo3 :: Show a          =&gt; Foo a    -- not promotable
</pre> <p><code>MkFoo1</code> and <code>MkFoo2</code> can be promoted, since their contexts only involve equality-oriented constraints. However, <code>MkFoo3</code>‘s context contains a non-equality constraint <code>Show a</code>, and thus cannot be promoted.</p> </li> </ul>   <h2 id="promotion-syntax">11.10.3. Distinguishing between types and constructors</h2> <p id="distinguishing-between-types-and-constructors">In the examples above, all promoted constructors are prefixed with a single quote mark <code>'</code>. This mark tells GHC to look in the data constructor namespace for a name, not the type (constructor) namespace. Consider</p> <pre data-language="haskell">data P = MkP    -- 1

data Prom = P   -- 2
</pre> <p>We can thus distinguish the type <code>P</code> (which has a constructor <code>MkP</code>) from the promoted data constructor <code>'P</code> (of kind <code>Prom</code>).</p> <p>As a convenience, GHC allows you to omit the quote mark when the name is unambiguous. However, our experience has shown that the quote mark helps to make code more readable and less error-prone. GHC thus supports <a class="reference internal" href="using-warnings#ghc-flag--Wunticked-promoted-constructors"><code>-Wunticked-promoted-constructors</code></a> that will warn you if you use a promoted data constructor without a preceding quote mark.</p> <p>Just as in the case of Template Haskell (<a class="reference internal" href="#th-syntax"><span class="std std-ref">Syntax</span></a>), GHC gets confused if you put a quote mark before a data constructor whose second character is a quote mark. In this case, just put a space between the promotion quote and the data constructor:</p> <pre data-language="haskell">data T = A'
type S = 'A'   -- ERROR: looks like a character
type R = ' A'  -- OK: promoted `A'`
</pre>   <h2 id="promoted-lists-and-tuples">11.10.4. Promoted list and tuple types</h2> <p id="promoted-list-and-tuple-types">With <a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a>, Haskell’s list and tuple types are natively promoted to kinds, and enjoy the same convenient syntax at the type level, albeit prefixed with a quote:</p> <pre data-language="haskell">data HList :: [Type] -&gt; Type where
  HNil  :: HList '[]
  HCons :: a -&gt; HList t -&gt; HList (a ': t)

data Tuple :: (Type,Type) -&gt; Type where
  Tuple :: a -&gt; b -&gt; Tuple '(a,b)

foo0 :: HList '[]
foo0 = HNil

foo1 :: HList '[Int]
foo1 = HCons (3::Int) HNil

foo2 :: HList [Int, Bool]
foo2 = ...
</pre> <p>For type-level lists of <em>two or more elements</em>, such as the signature of <code>foo2</code> above, the quote may be omitted because the meaning is unambiguous. But for lists of one or zero elements (as in <code>foo0</code> and <code>foo1</code>), the quote is required, because the types <code>[]</code> and <code>[Int]</code> have existing meanings in Haskell.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The declaration for <code>HCons</code> also requires <a class="reference internal" href="#extension-TypeOperators"><code>TypeOperators</code></a> because of infix type operator <code>(':)</code></p> </div>   <h2 id="promotion-existentials">11.10.5. Promoting existential data constructors</h2> <p id="promoting-existential-data-constructors">Note that we do promote existential data constructors that are otherwise suitable. For example, consider the following:</p> <pre data-language="haskell">data Ex :: Type where
  MkEx :: forall a. a -&gt; Ex
</pre> <p>Both the type <code>Ex</code> and the data constructor <code>MkEx</code> get promoted, with the polymorphic kind <code>'MkEx :: forall k. k -&gt; Ex</code>. Somewhat surprisingly, you can write a type family to extract the member of a type-level existential:</p> <pre data-language="haskell">type family UnEx (ex :: Ex) :: k
type instance UnEx (MkEx x) = x
</pre> <p>At first blush, <code>UnEx</code> seems poorly-kinded. The return kind <code>k</code> is not mentioned in the arguments, and thus it would seem that an instance would have to return a member of <code>k</code> <em>for any</em> <code>k</code>. However, this is not the case. The type family <code>UnEx</code> is a kind-indexed type family. The return kind <code>k</code> is an implicit parameter to <code>UnEx</code>. The elaborated definitions are as follows (where implicit parameters are denoted by braces):</p> <pre data-language="haskell">type family UnEx {k :: Type} (ex :: Ex) :: k
type instance UnEx {k} (MkEx @k x) = x
</pre> <p>Thus, the instance triggers only when the implicit parameter to <code>UnEx</code> matches the implicit parameter to <code>MkEx</code>. Because <code>k</code> is actually a parameter to <code>UnEx</code>, the kind is not escaping the existential, and the above code is valid.</p> <p>See also <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/7347">Issue #7347</a>.</p>    <h1 id="id49">11.11. Kind polymorphism</h1> <dl class="extension" id="kind-polymorphism"> <dt id="extension-TypeInType">
<code>TypeInType</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body">
<a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a>, <a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a>, <a class="reference internal" href="#extension-KindSignatures"><code>KindSignatures</code></a>
</td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>The extension <a class="reference internal" href="#extension-TypeInType"><code>TypeInType</code></a> is now deprecated: its sole effect is to switch on <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a> (and hence <a class="reference internal" href="#extension-KindSignatures"><code>KindSignatures</code></a>) and <a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a>.</p> </dd>
</dl> <dl class="extension"> <dt id="extension-PolyKinds">
<code>PolyKinds</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-KindSignatures"><code>KindSignatures</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.4.1</td> </tr>  </table> <p>Allow kind polymorphic types.</p> </dd>
</dl> <p>This section describes GHC’s kind system, as it appears in version 8.0 and beyond. The kind system as described here is always in effect, with or without extensions, although it is a conservative extension beyond standard Haskell. The extensions above simply enable syntax and tweak the inference algorithm to allow users to take advantage of the extra expressiveness of GHC’s kind system.</p>  <h2 id="overview-of-kind-polymorphism">11.11.1. Overview of kind polymorphism</h2> <p>Consider inferring the kind for</p> <pre data-language="haskell">data App f a = MkApp (f a)
</pre> <p>In Haskell 98, the inferred kind for <code>App</code> is <code>(Type -&gt; Type) -&gt; Type -&gt;
Type</code>. But this is overly specific, because another suitable Haskell 98 kind for <code>App</code> is <code>((Type -&gt; Type) -&gt; Type) -&gt; (Type -&gt; Type) -&gt; Type</code>, where the kind assigned to <code>a</code> is <code>Type -&gt; Type</code>. Indeed, without kind signatures (<a class="reference internal" href="#extension-KindSignatures"><code>KindSignatures</code></a>), it is necessary to use a dummy constructor to get a Haskell compiler to infer the second kind. With kind polymorphism (<a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a>), GHC infers the kind <code>forall k. (k -&gt; Type) -&gt; k -&gt;
Type</code> for <code>App</code>, which is its most general kind.</p> <p>Thus, the chief benefit of kind polymorphism is that we can now infer these most general kinds and use <code>App</code> at a variety of kinds:</p> <pre data-language="haskell">App Maybe Int   -- `k` is instantiated to Type

data T a = MkT (a Int)    -- `a` is inferred to have kind (Type -&gt; Type)
App T Maybe     -- `k` is instantiated to (Type -&gt; Type)
</pre>   <h2 id="overview-of-type-in-type">11.11.2. Overview of Type-in-Type</h2> <p>GHC 8 extends the idea of kind polymorphism by declaring that types and kinds are indeed one and the same. Nothing within GHC distinguishes between types and kinds. Another way of thinking about this is that the type <code>Bool</code> and the “promoted kind” <code>Bool</code> are actually identical. (Note that term <code>True</code> and the type <code>'True</code> are still distinct, because the former can be used in expressions and the latter in types.) This lack of distinction between types and kinds is a hallmark of dependently typed languages. Full dependently typed languages also remove the difference between expressions and types, but doing that in GHC is a story for another day.</p> <p>One simplification allowed by combining types and kinds is that the type of <code>Type</code> is just <code>Type</code>. It is true that the <code>Type :: Type</code> axiom can lead to non-termination, but this is not a problem in GHC, as we already have other means of non-terminating programs in both types and expressions. This decision (among many, many others) <em>does</em> mean that despite the expressiveness of GHC’s type system, a “proof” you write in Haskell is not an irrefutable mathematical proof. GHC promises only partial correctness, that if your programs compile and run to completion, their results indeed have the types assigned. It makes no claim about programs that do not finish in a finite amount of time.</p> <p>To learn more about this decision and the design of GHC under the hood please see the <a class="reference external" href="http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf">paper</a> introducing this kind system to GHC/Haskell.</p>   <h2 id="principles-of-kind-inference">11.11.3. Principles of kind inference</h2> <p>Generally speaking, when <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a> is on, GHC tries to infer the most general kind for a declaration. In many cases (for example, in a datatype declaration) the definition has a right-hand side to inform kind inference. But that is not always the case. Consider</p> <pre data-language="haskell">type family F a
</pre> <p>Type family declarations have no right-hand side, but GHC must still infer a kind for <code>F</code>. Since there are no constraints, it could infer <code>F :: forall k1 k2. k1 -&gt; k2</code>, but that seems <em>too</em> polymorphic. So GHC defaults those entirely-unconstrained kind variables to <code>Type</code> and we get <code>F :: Type -&gt; Type</code>. You can still declare <code>F</code> to be kind-polymorphic using kind signatures:</p> <pre data-language="haskell">type family F1 a                -- F1 :: Type -&gt; Type
type family F2 (a :: k)         -- F2 :: forall k. k -&gt; Type
type family F3 a :: k           -- F3 :: forall k. Type -&gt; k
type family F4 (a :: k1) :: k2  -- F4 :: forall k1 k2. k1 -&gt; k2
</pre> <p>The general principle is this:</p> <ul class="simple"> <li>
<em>When there is a right-hand side, GHC infers the most polymorphic kind consistent with the right-hand side.</em> Examples: ordinary data type and GADT declarations, class declarations. In the case of a class declaration the role of “right hand side” is played by the class method signatures.</li> <li>
<em>When there is no right hand side, GHC defaults argument and result kinds to ``Type``, except when directed otherwise by a kind signature</em>. Examples: data and open type family declarations.</li> </ul> <p>This rule has occasionally-surprising consequences (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10132">Issue #10132</a>.</p> <pre data-language="haskell">class C a where    -- Class declarations are generalised
                   -- so C :: forall k. k -&gt; Constraint
  data D1 a        -- No right hand side for these two family
  type F1 a        -- declarations, but the class forces (a :: k)
                   -- so   D1, F1 :: forall k. k -&gt; Type

data D2 a   -- No right-hand side so D2 :: Type -&gt; Type
type F2 a   -- No right-hand side so F2 :: Type -&gt; Type
</pre> <p>The kind-polymorphism from the class declaration makes <code>D1</code> kind-polymorphic, but not so <code>D2</code>; and similarly <code>F1</code>, <code>F1</code>.</p>   <h2 id="inferring-variable-order">11.11.4. Inferring the order of variables in a type/class declaration</h2> <p id="inferring-the-order-of-variables-in-a-type-class-declaration">It is possible to get intricate dependencies among the type variables introduced in a type or class declaration. Here is an example:</p> <pre data-language="haskell">data T a (b :: k) c = MkT (a c)
</pre> <p>After analysing this declaration, GHC will discover that <code>a</code> and <code>c</code> can be kind-polymorphic, with <code>a :: k2 -&gt; Type</code> and <code>c :: k2</code>. We thus infer the following kind:</p> <pre data-language="haskell">T :: forall {k2 :: Type} (k :: Type). (k2 -&gt; Type) -&gt; k -&gt; k2 -&gt; Type
</pre> <p>Note that <code>k2</code> is placed <em>before</em> <code>k</code>, and that <code>k</code> is placed <em>before</em> <code>a</code>. Also, note that <code>k2</code> is written here in braces. As explained with <a class="reference internal" href="#extension-TypeApplications"><code>TypeApplications</code></a> (<a class="reference internal" href="#inferred-vs-specified"><span class="std std-ref">Inferred vs. specified type variables</span></a>), type and kind variables that GHC generalises over, but not written in the original program, are not available for visible type application. (These are called <em>inferred</em> variables.) Such variables are written in braces with <a class="reference internal" href="using#ghc-flag--fprint-explicit-foralls"><code>-fprint-explicit-foralls</code></a> enabled.</p> <p>The general principle is this:</p>  <ul class="simple"> <li>Variables not available for type application come first.</li> <li>Then come variables the user has written, implicitly brought into scope in a type variable’s kind.</li> <li>Lastly come the normal type variables of a declaration.</li> <li>Variables not given an explicit ordering by the user are sorted according to ScopedSort (<span class="xref std std-ref">ScopedSort</span>).</li> </ul>  <p>With the <code>T</code> example above, we could bind <code>k</code> <em>after</em> <code>a</code>; doing so would not violate dependency concerns. However, it would violate our general principle, and so <code>k</code> comes first.</p> <p>Sometimes, this ordering does not respect dependency. For example:</p> <pre data-language="haskell">data T2 k (a :: k) (c :: Proxy '[a, b])
</pre> <p>It must be that <code>a</code> and <code>b</code> have the same kind. Note also that <code>b</code> is implicitly declared in <code>c</code>‘s kind. Thus, according to our general principle, <code>b</code> must come <em>before</em> <code>k</code>. However, <code>b</code> <em>depends on</em> <code>k</code>. We thus reject <code>T2</code> with a suitable error message.</p> <p>In keeping with the way that class methods list their class variables first, associated types also list class variables before others. This means that the inferred variables from the class come before the specified variables from the class, which come before other implicitly bound variables. Here is an example:</p> <pre data-language="haskell">class C (a :: k) b where
  type F (c :: j) (d :: Proxy m) a b
</pre> <p>We infer these kinds:</p> <pre data-language="haskell">C :: forall {k2 :: Type} (k :: Type). k -&gt; k2 -&gt; Constraint
F :: forall {k2 :: Type} (k :: Type)
            {k3 :: Type} (j :: Type) (m :: k3).
            j -&gt; Proxy m -&gt; k -&gt; k2 -&gt; Type
</pre> <p>The “general principle” described here is meant to make all this more predictable for users. It would not be hard to extend GHC to relax this principle. If you should want a change here, consider writing a <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/">proposal</a> to do so.</p>   <h2 id="index-15">11.11.5. Complete user-supplied kind signatures and polymorphic recursion</h2> <p id="complete-user-supplied-kind-signatures-and-polymorphic-recursion">Just as in type inference, kind inference for recursive types can only use <em>monomorphic</em> recursion. Consider this (contrived) example:</p> <pre data-language="haskell">data T m a = MkT (m a) (T Maybe (m a))
-- GHC infers kind  T :: (Type -&gt; Type) -&gt; Type -&gt; Type
</pre> <p>The recursive use of <code>T</code> forced the second argument to have kind <code>Type</code>. However, just as in type inference, you can achieve polymorphic recursion by giving a <em>complete user-supplied kind signature</em> (or CUSK) for <code>T</code>. A CUSK is present when all argument kinds and the result kind are known, without any need for inference. For example:</p> <pre data-language="haskell">data T (m :: k -&gt; Type) :: k -&gt; Type where
  MkT :: m a -&gt; T Maybe (m a) -&gt; T m a
</pre> <p>The complete user-supplied kind signature specifies the polymorphic kind for <code>T</code>, and this signature is used for all the calls to <code>T</code> including the recursive ones. In particular, the recursive use of <code>T</code> is at kind <code>Type</code>.</p> <p>What exactly is considered to be a “complete user-supplied kind signature” for a type constructor? These are the forms:</p> <ul> <li>
<p class="first">For a datatype, every type variable must be annotated with a kind. In a GADT-style declaration, there may also be a kind signature (with a top-level <code>::</code> in the header), but the presence or absence of this annotation does not affect whether or not the declaration has a complete signature.</p> <pre data-language="haskell">data T1 :: (k -&gt; Type) -&gt; k -&gt; Type       where ...
-- Yes;  T1 :: forall k. (k-&gt;Type) -&gt; k -&gt; Type

data T2 (a :: k -&gt; Type) :: k -&gt; Type     where ...
-- Yes;  T2 :: forall k. (k-&gt;Type) -&gt; k -&gt; Type

data T3 (a :: k -&gt; Type) (b :: k) :: Type where ...
-- Yes;  T3 :: forall k. (k-&gt;Type) -&gt; k -&gt; Type

data T4 (a :: k -&gt; Type) (b :: k)      where ...
-- Yes;  T4 :: forall k. (k-&gt;Type) -&gt; k -&gt; Type

data T5 a (b :: k) :: Type             where ...
-- No;  kind is inferred

data T6 a b                         where ...
-- No;  kind is inferred
</pre> </li> <li>
<p class="first">For a datatype with a top-level <code>::</code>: all kind variables introduced after the <code>::</code> must be explicitly quantified.</p> <pre data-language="haskell">data T1 :: k -&gt; Type            -- No CUSK: `k` is not explicitly quantified
data T2 :: forall k. k -&gt; Type  -- CUSK: `k` is bound explicitly
data T3 :: forall (k :: Type). k -&gt; Type   -- still a CUSK
</pre> </li> <li>For a class, every type variable must be annotated with a kind. </li> <li>
<p class="first">For a type synonym, every type variable and the result type must all be annotated with kinds:</p> <pre data-language="haskell">type S1 (a :: k) = (a :: k)    -- Yes   S1 :: forall k. k -&gt; k
type S2 (a :: k) = a           -- No    kind is inferred
type S3 (a :: k) = Proxy a     -- No    kind is inferred
</pre> <p>Note that in <code>S2</code> and <code>S3</code>, the kind of the right-hand side is rather apparent, but it is still not considered to have a complete signature – no inference can be done before detecting the signature.</p> </li> <li>
<p class="first">An un-associated open type or data family declaration <em>always</em> has a CUSK; un-annotated type variables default to kind <code>Type</code>:</p> <pre data-language="haskell">data family D1 a                  -- D1 :: Type -&gt; Type
data family D2 (a :: k)           -- D2 :: forall k. k -&gt; Type
data family D3 (a :: k) :: Type   -- D3 :: forall k. k -&gt; Type
type family S1 a :: k -&gt; Type     -- S1 :: forall k. Type -&gt; k -&gt; Type
</pre> </li> <li>
<p class="first">An associated type or data family declaration has a CUSK precisely if its enclosing class has a CUSK.</p> <pre data-language="haskell">class C a where                -- no CUSK
  type AT a b                  -- no CUSK, b is defaulted

class D (a :: k) where         -- yes CUSK
  type AT2 a b                 -- yes CUSK, b is defaulted
</pre> </li> <li>A closed type family has a complete signature when all of its type variables are annotated and a return kind (with a top-level <code>::</code>) is supplied. </li> </ul> <p>It is possible to write a datatype that syntactically has a CUSK (according to the rules above) but actually requires some inference. As a very contrived example, consider</p> <pre data-language="haskell">data Proxy a           -- Proxy :: forall k. k -&gt; Type
data X (a :: Proxy k)
</pre> <p>According to the rules above <code>X</code> has a CUSK. Yet, the kind of <code>k</code> is undetermined. It is thus quantified over, giving <code>X</code> the kind <code>forall k1 (k :: k1). Proxy k -&gt; Type</code>.</p>   <h2 id="kind-inference-in-closed-type-families">11.11.6. Kind inference in closed type families</h2> <p>Although all open type families are considered to have a complete user-supplied kind signature, we can relax this condition for closed type families, where we have equations on which to perform kind inference. GHC will infer kinds for the arguments and result types of a closed type family.</p> <p>GHC supports <em>kind-indexed</em> type families, where the family matches both on the kind and type. GHC will <em>not</em> infer this behaviour without a complete user-supplied kind signature, as doing so would sometimes infer non-principal types. Indeed, we can see kind-indexing as a form of polymorphic recursion, where a type is used at a kind other than its most general in its own definition.</p> <p>For example:</p> <pre data-language="haskell">type family F1 a where
  F1 True  = False
  F1 False = True
  F1 x     = x
-- F1 fails to compile: kind-indexing is not inferred

type family F2 (a :: k) where
  F2 True  = False
  F2 False = True
  F2 x     = x
-- F2 fails to compile: no complete signature

type family F3 (a :: k) :: k where
  F3 True  = False
  F3 False = True
  F3 x     = x
-- OK
</pre>   <h2 id="kind-inference-in-class-instance-declarations">11.11.7. Kind inference in class instance declarations</h2> <p>Consider the following example of a poly-kinded class and an instance for it:</p> <pre data-language="haskell">class C a where
  type F a

instance C b where
  type F b = b -&gt; b
</pre> <p>In the class declaration, nothing constrains the kind of the type <code>a</code>, so it becomes a poly-kinded type variable <code>(a :: k)</code>. Yet, in the instance declaration, the right-hand side of the associated type instance <code>b -&gt; b</code> says that <code>b</code> must be of kind <code>Type</code>. GHC could theoretically propagate this information back into the instance head, and make that instance declaration apply only to type of kind <code>Type</code>, as opposed to types of any kind. However, GHC does <em>not</em> do this.</p> <p>In short: GHC does <em>not</em> propagate kind information from the members of a class instance declaration into the instance declaration head.</p> <p>This lack of kind inference is simply an engineering problem within GHC, but getting it to work would make a substantial change to the inference infrastructure, and it’s not clear the payoff is worth it. If you want to restrict <code>b</code>‘s kind in the instance above, just use a kind signature in the instance head.</p>   <h2 id="kind-inference-in-type-signatures">11.11.8. Kind inference in type signatures</h2> <p>When kind-checking a type, GHC considers only what is written in that type when figuring out how to generalise the type’s kind.</p> <p>For example, consider these definitions (with <a class="reference internal" href="#extension-ScopedTypeVariables"><code>ScopedTypeVariables</code></a>):</p> <pre data-language="haskell">data Proxy a    -- Proxy :: forall k. k -&gt; Type
p :: forall a. Proxy a
p = Proxy :: Proxy (a :: Type)
</pre> <p>GHC reports an error, saying that the kind of <code>a</code> should be a kind variable <code>k</code>, not <code>Type</code>. This is because, by looking at the type signature <code>forall a. Proxy a</code>, GHC assumes <code>a</code>‘s kind should be generalised, not restricted to be <code>Type</code>. The function definition is then rejected for being more specific than its type signature.</p>   <h2 id="explicit-kind-quantification">11.11.9. Explicit kind quantification</h2> <p>Enabled by <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a>, GHC supports explicit kind quantification, as in these examples:</p> <pre data-language="haskell">data Proxy :: forall k. k -&gt; Type
f :: (forall k (a :: k). Proxy a -&gt; ()) -&gt; Int
</pre> <p>Note that the second example has a <code>forall</code> that binds both a kind <code>k</code> and a type variable <code>a</code> of kind <code>k</code>. In general, there is no limit to how deeply nested this sort of dependency can work. However, the dependency must be well-scoped: <code>forall (a :: k) k. ...</code> is an error.</p> <p>For backward compatibility, kind variables <em>do not</em> need to be bound explicitly, even if the type starts with <code>forall</code>.</p> <p>Accordingly, the rule for kind quantification in higher-rank contexts has changed slightly. In GHC 7, if a kind variable was mentioned for the first time in the kind of a variable bound in a non-top-level <code>forall</code>, the kind variable was bound there, too. That is, in <code>f :: (forall (a :: k). ...) -&gt; ...</code>, the <code>k</code> was bound by the same <code>forall</code> as the <code>a</code>. In GHC 8, however, all kind variables mentioned in a type are bound at the outermost level. If you want one bound in a higher-rank <code>forall</code>, include it explicitly.</p>   <h2 id="kind-indexed-gadts">11.11.10. Kind-indexed GADTs</h2> <p>Consider the type</p> <pre data-language="haskell">data G (a :: k) where
  GInt    :: G Int
  GMaybe  :: G Maybe
</pre> <p>This datatype <code>G</code> is GADT-like in both its kind and its type. Suppose you have <code>g :: G a</code>, where <code>a :: k</code>. Then pattern matching to discover that <code>g</code> is in fact <code>GMaybe</code> tells you both that <code>k ~ (Type -&gt; Type)</code> and <code>a ~ Maybe</code>. The definition for <code>G</code> requires that <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a> be in effect, but pattern-matching on <code>G</code> requires no extension beyond <a class="reference internal" href="#extension-GADTs"><code>GADTs</code></a>. That this works is actually a straightforward extension of regular GADTs and a consequence of the fact that kinds and types are the same.</p> <p>Note that the datatype <code>G</code> is used at different kinds in its body, and therefore that kind-indexed GADTs use a form of polymorphic recursion. It is thus only possible to use this feature if you have provided a complete user-supplied kind signature for the datatype (<a class="reference internal" href="#complete-kind-signatures"><span class="std std-ref">Complete user-supplied kind signatures and polymorphic recursion</span></a>).</p>   <h2 id="higher-rank-kinds">11.11.11. Higher-rank kinds</h2> <p>In concert with <a class="reference internal" href="#extension-RankNTypes"><code>RankNTypes</code></a>, GHC supports higher-rank kinds. Here is an example:</p> <pre data-language="haskell">-- Heterogeneous propositional equality
data (a :: k1) :~~: (b :: k2) where
  HRefl :: a :~~: a

class HTestEquality (t :: forall k. k -&gt; Type) where
  hTestEquality :: forall k1 k2 (a :: k1) (b :: k2). t a -&gt; t b -&gt; Maybe (a :~~: b)
</pre> <p>Note that <code>hTestEquality</code> takes two arguments where the type variable <code>t</code> is applied to types of different kinds. That type variable must then be polykinded. Accordingly, the kind of <code>HTestEquality</code> (the class) is <code>(forall k. k -&gt; Type) -&gt; Constraint</code>, a higher-rank kind.</p> <p>A big difference with higher-rank kinds as compared with higher-rank types is that <code>forall</code>s in kinds <em>cannot</em> be moved. This is best illustrated by example. Suppose we want to have an instance of <code>HTestEquality</code> for <code>(:~~:)</code>.</p> <pre data-language="haskell">instance HTestEquality ((:~~:) a) where
  hTestEquality HRefl HRefl = Just HRefl
</pre> <p>With the declaration of <code>(:~~:)</code> above, it gets kind <code>forall k1 k2. k1 -&gt; k2 -&gt; Type</code>. Thus, the type <code>(:~~:) a</code> has kind <code>k2 -&gt; Type</code> for some <code>k2</code>. GHC cannot then <em>regeneralize</em> this kind to become <code>forall k2. k2 -&gt; Type</code> as desired. Thus, the instance is rejected as ill-kinded.</p> <p>To allow for such an instance, we would have to define <code>(:~~:)</code> as follows:</p> <pre data-language="haskell">data (:~~:) :: forall k1. k1 -&gt; forall k2. k2 -&gt; Type where
  HRefl :: a :~~: a
</pre> <p>In this redefinition, we give an explicit kind for <code>(:~~:)</code>, deferring the choice of <code>k2</code> until after the first argument (<code>a</code>) has been given. With this declaration for <code>(:~~:)</code>, the instance for <code>HTestEquality</code> is accepted.</p> <p>Another difference between higher-rank kinds and types can be found in their treatment of inferred and user-specified type variables. Consider the following program:</p> <pre data-language="haskell">newtype Foo (f :: forall k. k -&gt; Type) = MkFoo (f Int)
data Proxy a = Proxy

foo :: Foo Proxy
foo = MkFoo Proxy
</pre> <p>The kind of <code>Foo</code>‘s parameter is <code>forall k. k -&gt; Type</code>, but the kind of <code>Proxy</code> is <code>forall {k}. k -&gt; Type</code>, where <code>{k}</code> denotes that the kind variable <code>k</code> is to be inferred, not specified by the user. (See <a class="reference internal" href="#visible-type-application"><span class="std std-ref">Visible type application</span></a> for more discussion on the inferred-specified distinction). GHC does not consider <code>forall k. k -&gt; Type</code> and <code>forall {k}. k -&gt; Type</code> to be equal at the kind level, and thus rejects <code>Foo Proxy</code> as ill-kinded.</p>   <h2 id="the-kind-type">11.11.12. The kind <code>Type</code>
</h2> <dl class="extension"> <dt id="extension-StarIsType">
<code>StarIsType</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.6.1</td> </tr>  </table> <p>Treat the unqualified uses of the <code>*</code> type operator as nullary and desugar to <code>Data.Kind.Type</code>.</p> </dd>
</dl> <p>The kind <code>Type</code> (imported from <code>Data.Kind</code>) classifies ordinary types. With <a class="reference internal" href="#extension-StarIsType"><code>StarIsType</code></a> (currently enabled by default), <code>*</code> is desugared to <code>Type</code>, but using this legacy syntax is not recommended due to conflicts with <a class="reference internal" href="#extension-TypeOperators"><code>TypeOperators</code></a>. This also applies to <code>★</code>, the Unicode variant of <code>*</code>.</p>   <h2 id="inferring-dependency-in-datatype-declarations">11.11.13. Inferring dependency in datatype declarations</h2> <p>If a type variable <code>a</code> in a datatype, class, or type family declaration depends on another such variable <code>k</code> in the same declaration, two properties must hold:</p> <ul class="simple"> <li>
<code>a</code> must appear after <code>k</code> in the declaration, and</li> <li>
<code>k</code> must appear explicitly in the kind of <em>some</em> type variable in that declaration.</li> </ul> <p>The first bullet simply means that the dependency must be well-scoped. The second bullet concerns GHC’s ability to infer dependency. Inferring this dependency is difficult, and GHC currently requires the dependency to be made explicit, meaning that <code>k</code> must appear in the kind of a type variable, making it obvious to GHC that dependency is intended. For example:</p> <pre data-language="haskell">data Proxy k (a :: k)            -- OK: dependency is "obvious"
data Proxy2 k a = P (Proxy k a)  -- ERROR: dependency is unclear
</pre> <p>In the second declaration, GHC cannot immediately tell that <code>k</code> should be a dependent variable, and so the declaration is rejected.</p> <p>It is conceivable that this restriction will be relaxed in the future, but it is (at the time of writing) unclear if the difficulties around this scenario are theoretical (inferring this dependency would mean our type system does not have principal types) or merely practical (inferring this dependency is hard, given GHC’s implementation). So, GHC takes the easy way out and requires a little help from the user.</p>   <h2 id="inferring-dependency-in-user-written-foralls">11.11.14. Inferring dependency in user-written <code>forall</code>s</h2> <p>A programmer may use <code>forall</code> in a type to introduce new quantified type variables. These variables may depend on each other, even in the same <code>forall</code>. However, GHC requires that the dependency be inferrable from the body of the <code>forall</code>. Here are some examples:</p> <pre data-language="haskell">data Proxy k (a :: k) = MkProxy   -- just to use below

f :: forall k a. Proxy k a        -- This is just fine. We see that (a :: k).
f = undefined

g :: Proxy k a -&gt; ()              -- This is to use below.
g = undefined

data Sing a
h :: forall k a. Sing k -&gt; Sing a -&gt; ()  -- No obvious relationship between k and a
h _ _ = g (MkProxy :: Proxy k a)  -- This fails. We didn't know that a should have kind k.
</pre> <p>Note that in the last example, it’s impossible to learn that <code>a</code> depends on <code>k</code> in the body of the <code>forall</code> (that is, the <code>Sing k -&gt; Sing a -&gt; ()</code>). And so GHC rejects the program.</p>   <h2 id="kind-defaulting-without-polykinds">11.11.15. Kind defaulting without PolyKinds</h2> <p>Without <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a>, GHC refuses to generalise over kind variables. It thus defaults kind variables to <code>Type</code> when possible; when this is not possible, an error is issued.</p> <p>Here is an example of this in action:</p> <pre data-language="haskell">{-# LANGUAGE PolyKinds #-}
import Data.Kind (Type)
data Proxy a = P   -- inferred kind: Proxy :: k -&gt; Type
data Compose f g x = MkCompose (f (g x))
  -- inferred kind: Compose :: (b -&gt; Type) -&gt; (a -&gt; b) -&gt; a -&gt; Type

-- separate module having imported the first
{-# LANGUAGE NoPolyKinds, DataKinds #-}
z = Proxy :: Proxy 'MkCompose
</pre> <p>In the last line, we use the promoted constructor <code>'MkCompose</code>, which has kind</p> <pre data-language="haskell">forall (a :: Type) (b :: Type) (f :: b -&gt; Type) (g :: a -&gt; b) (x :: a).
  f (g x) -&gt; Compose f g x
</pre> <p>Now we must infer a type for <code>z</code>. To do so without generalising over kind variables, we must default the kind variables of <code>'MkCompose</code>. We can easily default <code>a</code> and <code>b</code> to <code>Type</code>, but <code>f</code> and <code>g</code> would be ill-kinded if defaulted. The definition for <code>z</code> is thus an error.</p>   <h2 id="pretty-printing-in-the-presence-of-kind-polymorphism">11.11.16. Pretty-printing in the presence of kind polymorphism</h2> <p>With kind polymorphism, there is quite a bit going on behind the scenes that may be invisible to a Haskell programmer. GHC supports several flags that control how types are printed in error messages and at the GHCi prompt. See the <a class="reference internal" href="using#pretty-printing-types"><span class="std std-ref">discussion of type pretty-printing options</span></a> for further details. If you are using kind polymorphism and are confused as to why GHC is rejecting (or accepting) your program, we encourage you to turn on these flags, especially <a class="reference internal" href="using#ghc-flag--fprint-explicit-kinds"><code>-fprint-explicit-kinds</code></a>.</p>    <h1 id="index-16">11.12. Levity polymorphism</h1> <p id="levity-polymorphism">In order to allow full flexibility in how kinds are used, it is necessary to use the kind system to differentiate between boxed, lifted types (normal, everyday types like <code>Int</code> and <code>[Bool]</code>) and unboxed, primitive types (<a class="reference internal" href="#primitives"><span class="std std-ref">Unboxed types and primitive operations</span></a>) like <code>Int#</code>. We thus have so-called levity polymorphism.</p> <p>Here are the key definitions, all available from <code>GHC.Exts</code>:</p> <pre data-language="haskell">TYPE :: RuntimeRep -&gt; Type   -- highly magical, built into GHC

data RuntimeRep = LiftedRep     -- for things like `Int`
                | UnliftedRep   -- for things like `Array#`
                | IntRep        -- for `Int#`
                | TupleRep [RuntimeRep]  -- unboxed tuples, indexed by the representations of the elements
                | SumRep [RuntimeRep]    -- unboxed sums, indexed by the representations of the disjuncts
                | ...

type Type = TYPE LiftedRep    -- Type is just an ordinary type synonym
</pre> <p>The idea is that we have a new fundamental type constant <code>TYPE</code>, which is parameterised by a <code>RuntimeRep</code>. We thus get <code>Int# :: TYPE 'IntRep</code> and <code>Bool :: TYPE 'LiftedRep</code>. Anything with a type of the form <code>TYPE x</code> can appear to either side of a function arrow <code>-&gt;</code>. We can thus say that <code>-&gt;</code> has type <code>TYPE r1 -&gt; TYPE r2 -&gt; TYPE 'LiftedRep</code>. The result is always lifted because all functions are lifted in GHC.</p>  <h2 id="no-levity-polymorphic-variables-or-arguments">11.12.1. No levity-polymorphic variables or arguments</h2> <p>If GHC didn’t have to compile programs that run in the real world, that would be the end of the story. But representation polymorphism can cause quite a bit of trouble for GHC’s code generator. Consider</p> <pre data-language="haskell">bad :: forall (r1 :: RuntimeRep) (r2 :: RuntimeRep)
              (a :: TYPE r1) (b :: TYPE r2).
       (a -&gt; b) -&gt; a -&gt; b
bad f x = f x
</pre> <p>This seems like a generalisation of the standard <code>$</code> operator. If we think about compiling this to runnable code, though, problems appear. In particular, when we call <code>bad</code>, we must somehow pass <code>x</code> into <code>bad</code>. How wide (that is, how many bits) is <code>x</code>? Is it a pointer? What kind of register (floating-point or integral) should <code>x</code> go in? It’s all impossible to say, because <code>x</code>‘s type, <code>a :: TYPE r1</code> is levity polymorphic. We thus forbid such constructions, via the following straightforward rule:</p>  No variable may have a levity-polymorphic type. <p>This eliminates <code>bad</code> because the variable <code>x</code> would have a representation-polymorphic type.</p> <p>However, not all is lost. We can still do this:</p> <pre data-language="haskell">($) :: forall r (a :: Type) (b :: TYPE r).
       (a -&gt; b) -&gt; a -&gt; b
f $ x = f x
</pre> <p>Here, only <code>b</code> is levity polymorphic. There are no variables with a levity-polymorphic type. And the code generator has no trouble with this. Indeed, this is the true type of GHC’s <code>$</code> operator, slightly more general than the Haskell 98 version.</p> <p>Because the code generator must store and move arguments as well as variables, the logic above applies equally well to function arguments, which may not be levity-polymorphic.</p>   <h2 id="levity-polymorphic-bottoms">11.12.2. Levity-polymorphic bottoms</h2> <p>We can use levity polymorphism to good effect with <code>error</code> and <code>undefined</code>, whose types are given here:</p> <pre data-language="haskell">undefined :: forall (r :: RuntimeRep) (a :: TYPE r).
             HasCallStack =&gt; a
error :: forall (r :: RuntimeRep) (a :: TYPE r).
         HasCallStack =&gt; String -&gt; a
</pre> <p>These functions do not bind a levity-polymorphic variable, and so are accepted. Their polymorphism allows users to use these to conveniently stub out functions that return unboxed types.</p>   <h2 id="printing-levity-polymorphic-types">11.12.3. Printing levity-polymorphic types</h2> <dl class="ghc-flag"> <dt id="ghc-flag--fprint-explicit-runtime-reps">
<code>-fprint-explicit-runtime-reps</code> </dt> <dd>
<p>Print <code>RuntimeRep</code> parameters as they appear; otherwise, they are defaulted to <code>'LiftedRep</code>.</p> </dd>
</dl> <p>Most GHC users will not need to worry about levity polymorphism or unboxed types. For these users, seeing the levity polymorphism in the type of <code>$</code> is unhelpful. And thus, by default, it is suppressed, by supposing all type variables of type <code>RuntimeRep</code> to be <code>'LiftedRep</code> when printing, and printing <code>TYPE 'LiftedRep</code> as <code>Type</code> (or <code>*</code> when <a class="reference internal" href="#extension-StarIsType"><code>StarIsType</code></a> is on).</p> <p>Should you wish to see levity polymorphism in your types, enable the flag <a class="reference internal" href="using#ghc-flag--fprint-explicit-runtime-reps"><code>-fprint-explicit-runtime-reps</code></a>.</p>    <h1 id="id50">11.13. Type-Level Literals</h1> <p id="type-level-literals">GHC supports numeric and string literals at the type level, giving convenient access to a large number of predefined type-level constants. Numeric literals are of kind <code>Nat</code>, while string literals are of kind <code>Symbol</code>. This feature is enabled by the <a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a> language extension.</p> <p>The kinds of the literals and all other low-level operations for this feature are defined in module <code>GHC.TypeLits</code>. Note that the module defines some type-level operators that clash with their value-level counterparts (e.g. <code>(+)</code>). Import and export declarations referring to these operators require an explicit namespace annotation (see <a class="reference internal" href="#explicit-namespaces"><span class="std std-ref">Explicit namespaces in import/export</span></a>).</p> <p>Here is an example of using type-level numeric literals to provide a safe interface to a low-level function:</p> <pre data-language="haskell">import GHC.TypeLits
import Data.Word
import Foreign

newtype ArrPtr (n :: Nat) a = ArrPtr (Ptr a)

clearPage :: ArrPtr 4096 Word8 -&gt; IO ()
clearPage (ArrPtr p) = ...
</pre> <p>Here is an example of using type-level string literals to simulate simple record operations:</p> <pre data-language="haskell">data Label (l :: Symbol) = Get

class Has a l b | a l -&gt; b where
  from :: a -&gt; Label l -&gt; b

data Point = Point Int Int deriving Show

instance Has Point "x" Int where from (Point x _) _ = x
instance Has Point "y" Int where from (Point _ y) _ = y

example = from (Point 1 2) (Get :: Label "x")
</pre>  <h2 id="typelit-runtime">11.13.1. Runtime Values for Type-Level Literals</h2> <p id="runtime-values-for-type-level-literals">Sometimes it is useful to access the value-level literal associated with a type-level literal. This is done with the functions <code>natVal</code> and <code>symbolVal</code>. For example:</p> <pre data-language="haskell">GHC.TypeLits&gt; natVal (Proxy :: Proxy 2)
2
</pre> <p>These functions are overloaded because they need to return a different result, depending on the type at which they are instantiated.</p> <pre data-language="haskell">natVal :: KnownNat n =&gt; proxy n -&gt; Integer

-- instance KnownNat 0
-- instance KnownNat 1
-- instance KnownNat 2
-- ...
</pre> <p>GHC discharges the constraint as soon as it knows what concrete type-level literal is being used in the program. Note that this works only for <em>literals</em> and not arbitrary type expressions. For example, a constraint of the form <code>KnownNat (a + b)</code> will <em>not</em> be simplified to <code>(KnownNat a, KnownNat b)</code>; instead, GHC will keep the constraint as is, until it can simplify <code>a + b</code> to a constant value.</p> <p>It is also possible to convert a run-time integer or string value to the corresponding type-level literal. Of course, the resulting type literal will be unknown at compile-time, so it is hidden in an existential type. The conversion may be performed using <code>someNatVal</code> for integers and <code>someSymbolVal</code> for strings:</p> <pre data-language="haskell">someNatVal :: Integer -&gt; Maybe SomeNat
SomeNat    :: KnownNat n =&gt; Proxy n -&gt; SomeNat
</pre> <p>The operations on strings are similar.</p>   <h2 id="typelit-tyfuns">11.13.2. Computing With Type-Level Naturals</h2> <p id="computing-with-type-level-naturals">GHC 7.8 can evaluate arithmetic expressions involving type-level natural numbers. Such expressions may be constructed using the type-families <code>(+), (*), (^)</code> for addition, multiplication, and exponentiation. Numbers may be compared using <code>(&lt;=?)</code>, which returns a promoted boolean value, or <code>(&lt;=)</code>, which compares numbers as a constraint. For example:</p> <pre data-language="none">GHC.TypeLits&gt; natVal (Proxy :: Proxy (2 + 3))
5
</pre> <p>At present, GHC is quite limited in its reasoning about arithmetic: it will only evaluate the arithmetic type functions and compare the results— in the same way that it does for any other type function. In particular, it does not know more general facts about arithmetic, such as the commutativity and associativity of <code>(+)</code>, for example.</p> <p>However, it is possible to perform a bit of “backwards” evaluation. For example, here is how we could get GHC to compute arbitrary logarithms at the type level:</p> <pre data-language="none">lg :: Proxy base -&gt; Proxy (base ^ pow) -&gt; Proxy pow
lg _ _ = Proxy

GHC.TypeLits&gt; natVal (lg (Proxy :: Proxy 2) (Proxy :: Proxy 8))
3
</pre>    <h1 id="equality-constraints-coercible-and-the-kind-constraint">11.14. Equality constraints, Coercible, and the kind Constraint</h1>  <h2 id="id51">11.14.1. Equality constraints</h2> <p id="equality-constraints">A type context can include equality constraints of the form <code>t1 ~ t2</code>, which denote that the types <code>t1</code> and <code>t2</code> need to be the same. In the presence of type families, whether two types are equal cannot generally be decided locally. Hence, the contexts of function signatures may include equality constraints, as in the following example:</p> <pre data-language="haskell">sumCollects :: (Collects c1, Collects c2, Elem c1 ~ Elem c2) =&gt; c1 -&gt; c2 -&gt; c2
</pre> <p>where we require that the element type of <code>c1</code> and <code>c2</code> are the same. In general, the types <code>t1</code> and <code>t2</code> of an equality constraint may be arbitrary monotypes; i.e., they may not contain any quantifiers, independent of whether higher-rank types are otherwise enabled.</p> <p>Equality constraints can also appear in class and instance contexts. The former enable a simple translation of programs using functional dependencies into programs using family synonyms instead. The general idea is to rewrite a class declaration of the form</p> <pre data-language="haskell">class C a b | a -&gt; b
</pre> <p>to</p> <pre data-language="haskell">class (F a ~ b) =&gt; C a b where
  type F a
</pre> <p>That is, we represent every functional dependency (FD) <code>a1 .. an -&gt; b</code> by an FD type family <code>F a1 .. an</code> and a superclass context equality <code>F a1 .. an ~ b</code>, essentially giving a name to the functional dependency. In class instances, we define the type instances of FD families in accordance with the class head. Method signatures are not affected by that process.</p>   <h2 id="index-17">11.14.2. Heterogeneous equality</h2> <p id="heterogeneous-equality">GHC also supports <em>kind-heterogeneous</em> equality, which relates two types of potentially different kinds. Heterogeneous equality is spelled <code>~~</code>. Here are the kinds of <code>~</code> and <code>~~</code> to better understand their difference:</p> <pre data-language="haskell">(~)  :: forall k. k -&gt; k -&gt; Constraint
(~~) :: forall k1 k2. k1 -&gt; k2 -&gt; Constraint
</pre> <p>Users will most likely want <code>~</code>, but <code>~~</code> is available if GHC cannot know, a priori, that the two types of interest have the same kind. Evidence that <code>(a :: k1) ~~ (b :: k2)</code> tells GHC both that <code>k1</code> and <code>k2</code> are the same and that <code>a</code> and <code>b</code> are the same.</p> <p>Because <code>~</code> is the more common equality relation, GHC prints out <code>~~</code> like <code>~</code> unless <a class="reference internal" href="using#ghc-flag--fprint-equality-relations"><code>-fprint-equality-relations</code></a> is set.</p>   <h2 id="unlifted-heterogeneous-equality">11.14.3. Unlifted heterogeneous equality</h2> <p>Internal to GHC is yet a third equality relation <code>(~#)</code>. It is heterogeneous (like <code>~~</code>) and is used only internally. It may appear in error messages and other output only when <a class="reference internal" href="using#ghc-flag--fprint-equality-relations"><code>-fprint-equality-relations</code></a> is enabled.</p>   <h2 id="coercible">11.14.4. The <code>Coercible</code> constraint</h2> <p id="the-coercible-constraint">The constraint <code>Coercible t1 t2</code> is similar to <code>t1 ~ t2</code>, but denotes representational equality between <code>t1</code> and <code>t2</code> in the sense of Roles (<a class="reference internal" href="#roles"><span class="std std-ref">Roles</span></a>). It is exported by <a class="reference external" href="../libraries/base-4.13.0.0/data-coerce">Data.Coerce</a>, which also contains the documentation. More details and discussion can be found in the paper <a class="reference external" href="https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf">“Safe Coercions”</a>.</p>   <h2 id="constraint-kind">11.14.5. The <code>Constraint</code> kind</h2> <dl class="extension" id="the-constraint-kind"> <dt id="extension-ConstraintKinds">
<code>ConstraintKinds</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.4.1</td> </tr>  </table> <p>Allow types of kind <code>Constraint</code> to be used in contexts.</p> </dd>
</dl> <p>Normally, <em>constraints</em> (which appear in types to the left of the <code>=&gt;</code> arrow) have a very restricted syntax. They can only be:</p> <ul class="simple"> <li>Class constraints, e.g. <code>Show a</code>
</li> <li>
<a class="reference internal" href="#extension-ImplicitParams"><code>Implicit parameter</code></a> constraints, e.g. <code>?x::Int</code> (with the <a class="reference internal" href="#extension-ImplicitParams"><code>ImplicitParams</code></a> extension)</li> <li>
<a class="reference internal" href="#equality-constraints"><span class="std std-ref">Equality constraints</span></a>, e.g. <code>a ~ Int</code> (with the <a class="reference internal" href="#extension-TypeFamilies"><code>TypeFamilies</code></a> or <a class="reference internal" href="#extension-GADTs"><code>GADTs</code></a> extensions)</li> </ul> <p>With the <a class="reference internal" href="#extension-ConstraintKinds"><code>ConstraintKinds</code></a> extension, GHC becomes more liberal in what it accepts as constraints in your program. To be precise, with this flag any <em>type</em> of the new kind <code>Constraint</code> can be used as a constraint. The following things have kind <code>Constraint</code>:</p> <ul> <li>Anything which is already valid as a constraint without the flag: saturated applications to type classes, implicit parameter and equality constraints. </li> <li>Tuples, all of whose component types have kind <code>Constraint</code>. So for example the type <code>(Show a, Ord a)</code> is of kind <code>Constraint</code>. </li> <li>
<p class="first">Anything whose form is not yet known, but the user has declared to have kind <code>Constraint</code> (for which they need to import it from <code>Data.Kind</code>). So for example <code>type Foo (f :: Type -&gt; Constraint) = forall b. f b =&gt; b -&gt; b</code> is allowed, as well as examples involving type families:</p> <pre data-language="haskell">type family Typ a b :: Constraint
type instance Typ Int  b = Show b
type instance Typ Bool b = Num b

func :: Typ a b =&gt; a -&gt; b -&gt; b
func = ...
</pre> </li> </ul> <p>Note that because constraints are just handled as types of a particular kind, this extension allows type constraint synonyms:</p> <pre data-language="haskell">type Stringy a = (Read a, Show a)
foo :: Stringy a =&gt; a -&gt; (String, String -&gt; a)
foo x = (show x, read)
</pre> <p>Presently, only standard constraints, tuples and type synonyms for those two sorts of constraint are permitted in instance contexts and superclasses (without extra flags). The reason is that permitting more general constraints can cause type checking to loop, as it would with these two programs:</p> <pre data-language="haskell">type family Clsish u a
type instance Clsish () a = Cls a
class Clsish () a =&gt; Cls a where
</pre> <pre data-language="haskell">class OkCls a where

type family OkClsish u a
type instance OkClsish () a = OkCls a
instance OkClsish () a =&gt; OkCls a where
</pre> <p>You may write programs that use exotic sorts of constraints in instance contexts and superclasses, but to do so you must use <a class="reference internal" href="#extension-UndecidableInstances"><code>UndecidableInstances</code></a> to signal that you don’t mind if the type checker fails to terminate.</p>    <h1 id="id52">11.15. Quantified constraints</h1> <dl class="extension" id="quantified-constraints"> <dt id="extension-QuantifiedConstraints">
<code>QuantifiedConstraints</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.6.1</td> </tr>  </table> <p>Allow constraints to quantify over types.</p> </dd>
</dl> <p>The extension <a class="reference internal" href="#extension-QuantifiedConstraints"><code>QuantifiedConstraints</code></a> introduces <strong>quantified constraints</strong>, which give a new level of expressiveness in constraints. For example, consider</p> <pre data-language="haskell">data Rose f a = Branch a (f (Rose f a))

instance (Eq a, ???) =&gt; Eq (Rose f a)
  where
    (Branch x1 c1) == (Branch x2 c2)
       = x1==x1 &amp;&amp; c1==c2
</pre> <p>From the <code>x1==x2</code> we need <code>Eq a</code>, which is fine. From <code>c1==c2</code> we need <code>Eq (f (Rose f a))</code> which is <em>not</em> fine in Haskell today; we have no way to solve such a constraint.</p> <p><a class="reference internal" href="#extension-QuantifiedConstraints"><code>QuantifiedConstraints</code></a> lets us write this</p> <pre data-language="haskell">instance (Eq a, forall b. (Eq b) =&gt; Eq (f b))
       =&gt; Eq (Rose f a)
  where
    (Branch x1 c1) == (Branch x2 c2)
       = x1==x1 &amp;&amp; c1==c2
</pre> <p>Here, the quantified constraint <code>forall b. (Eq b) =&gt; Eq (f b)</code> behaves a bit like a local instance declaration, and makes the instance typeable.</p> <p>The paper <a class="reference external" href="http://i.cs.hku.hk/~bruno//papers/hs2017.pdf">Quantified class constraints</a> (by Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) describes this feature in technical detail, with examples, and so is a primary reference source for this proposal.</p>  <h2 id="id53">11.15.1. Motivation</h2> <p>Introducing quantified constraints offers two main benefits:</p> <ul> <li>
<p class="first">Firstly, they enable terminating resolution where this was not possible before. Consider for instance the following instance declaration for the general rose datatype</p> <pre data-language="haskell">data Rose f x = Rose x (f (Rose f x))

instance (Eq a, forall b. Eq b =&gt; Eq (f b)) =&gt; Eq (Rose f a) where
  (Rose x1 rs1) == (Rose x2 rs2) = x1 == x2 &amp;&amp; rs1 == rs2
</pre> <p>This extension allows us to write constraints of the form <code>forall b. Eq b =&gt;
Eq (f b)</code>, which is needed to solve the <code>Eq (f (Rose f x))</code> constraint arising from the second usage of the <code>(==)</code> method.</p> </li> <li>
<p class="first">Secondly, quantified constraints allow for more concise and precise specifications. As an example, consider the MTL type class for monad transformers:</p> <pre data-language="haskell">class Trans t where
  lift :: Monad m =&gt; m a -&gt; (t m) a
</pre> <p>The developer knows that a monad transformer takes a monad <code>m</code> into a new monad <code>t m</code>. But this property is not formally specified in the above declaration. This omission becomes an issue when defining monad transformer composition:</p> <pre data-language="haskell">newtype (t1 * t2) m a = C { runC :: t1 (t2 m) a }

instance (Trans t1, Trans t2) =&gt; Trans (t1 * t2) where
  lift = C . lift . lift
</pre> <p>The goal here is to <code>lift</code> from monad <code>m</code> to <code>t2 m</code> and then <code>lift</code> this again into <code>t1 (t2 m)</code>. However, this second <code>lift</code> can only be accepted when <code>(t2 m)</code> is a monad and there is no way of establishing that this fact universally holds.</p> <p>Quantified constraints enable this property to be made explicit in the <code>Trans</code> class declaration:</p> <pre data-language="haskell">class (forall m. Monad m =&gt; Monad (t m)) =&gt; Trans t where
  lift :: Monad m =&gt; m a -&gt; (t m) a
</pre> </li> </ul> <p>This idea is very old; see Seciton 7 of <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/derivable-type-classes/">Derivable type classes</a>.</p>   <h2 id="syntax-changes">11.15.2. Syntax changes</h2> <p><a class="reference external" href="https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-18000010.5">Haskell 2010</a> defines a <code>context</code> (the bit to the left of <code>=&gt;</code> in a type) like this</p> <pre data-language="none">context ::= class
        |   ( class1, ..., classn )

class ::= qtycls tyvar
        |  qtycls (tyvar atype1 ... atypen)
</pre> <p>We to extend <code>class</code> (warning: this is a rather confusingly named non-terminal symbol) with two extra forms, namely precisely what can appear in an instance declaration</p> <pre data-language="none">class ::= ...
      | [context =&gt;] qtycls inst
      | [context =&gt;] tyvar inst
</pre> <p>The definition of <code>inst</code> is unchanged from the Haskell Report (roughly, just a type). The <code>context =&gt;</code> part is optional. That is the only syntactic change to the language.</p> <p>Notes:</p> <ul> <li>
<p class="first">Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of <code>class</code>. Specifically, with <a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a> and <code>MultiParameterTypeClasses</code> the syntax becomes</p> <pre data-language="none">class ::= ...
       | [forall tyavrs .] [context =&gt;] qtycls inst1 ... instn
       | [forall tyavrs .] [context =&gt;] tyvar inst1 ... instn
</pre> <p>Note that an explicit <code>forall</code> is often absolutely essential. Consider the rose-tree example</p> <pre data-language="haskell">instance (Eq a, forall b. Eq b =&gt; Eq (f b)) =&gt; Eq (Rose f a) where ...
</pre> <p>Without the <code>forall b</code>, the type variable <code>b</code> would be quantified over the whole instance declaration, which is not what is intended.</p> </li> <li>
<p class="first">One of these new quantified constraints can appear anywhere that any other constraint can, not just in instance declarations. Notably, it can appear in a type signature for a value binding, data constructor, or expression. For example</p> <pre data-language="haskell">f :: (Eq a, forall b. Eq b =&gt; Eq (f b)) =&gt; Rose f a -&gt; Rose f a -&gt; Bool
f t1 t2 = not (t1 == t2)
</pre> </li> <li>
<p class="first">The form with a type variable at the head allows this:</p> <pre data-language="haskell">instance (forall xx. c (Free c xx)) =&gt; Monad (Free c) where
    Free f &gt;&gt;= g = f g
</pre> <p>See <a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/14733#comment:6">Iceland Jack’s summary</a>. The key point is that the bit to the right of the <code>=&gt;</code> may be headed by a type <em>variable</em> (<code>c</code> in this case), rather than a class. It should not be one of the forall’d variables, though.</p> <p>(NB: this goes beyond what is described in <a class="reference external" href="http://i.cs.hku.hk/~bruno//papers/hs2017.pdf">the paper</a>, but does not seem to introduce any new technical difficulties.)</p> </li> </ul>   <h2 id="typing-changes">11.15.3. Typing changes</h2> <p>See <a class="reference external" href="http://i.cs.hku.hk/~bruno//papers/hs2017.pdf">the paper</a>.</p>   <h2 id="superclasses">11.15.4. Superclasses</h2> <p>Suppose we have:</p> <pre data-language="haskell">f :: forall m. (forall a. Ord a =&gt; Ord (m a)) =&gt; m Int -&gt; Bool
f x = x == x
</pre> <p>From the <code>x==x</code> we need an <code>Eq (m Int)</code> constraint, but the context only gives us a way to figure out <code>Ord (m a)</code> constraints. But from the given constraint <code>forall a. Ord a =&gt; Ord (m a)</code> we derive a second given constraint <code>forall a. Ord a =&gt; Eq (m a)</code>, and from that we can readily solve <code>Eq (m Int)</code>. This process is very similar to the way that superclasses already work: given an <code>Ord a</code> constraint we derive a second given <code>Eq a</code> constraint.</p> <p>NB: This treatment of superclasses goes beyond <a class="reference external" href="http://i.cs.hku.hk/~bruno//papers/hs2017.pdf">the paper</a>, but is specifically desired by users.</p>   <h2 id="overlap">11.15.5. Overlap</h2> <p>Quantified constraints can potentially lead to overlapping local axioms. Consider for instance the following example:</p> <pre data-language="haskell">class A a where {}
class B a where {}
class C a where {}
class (A a =&gt; C a) =&gt; D a where {}
class (B a =&gt; C a) =&gt; E a where {}

class C a =&gt; F a where {}
instance (B a, D a, E a) =&gt; F a where {}
</pre> <p>When type checking the instance declaration for <code>F a</code>, we need to check that the superclass <code>C</code> of <code>F</code> holds. We thus try to entail the constraint <code>C a</code> under the theory containing:</p> <ul class="simple"> <li>The instance axioms : <code>(B a, D a, E a) =&gt; F a</code>
</li> <li>The local axioms from the instance context : <code>B a</code>, <code>D a</code> and <code>E a</code>
</li> <li>The closure of the superclass relation over these local axioms : <code>A a =&gt; C a</code> and <code>B a =&gt; C a</code>
</li> </ul> <p>However, the <code>A a =&gt; C a</code> and <code>B a =&gt; C a</code> axioms both match the wanted constraint <code>C a</code>. There are several possible approaches for handling these overlapping local axioms:</p> <ul> <li>
<p class="first"><strong>Pick first</strong>. We can simply select the <strong>first matching axiom</strong> we encounter. In the above example, this would be <code>A a =&gt; C a</code>. We’d then need to entail <code>A a</code>, for which we have no matching axioms available, causing the above program to be rejected.</p> <p>But suppose we made a slight adjustment to the order of the instance context, putting <code>E a</code> before <code>D a</code>:</p> <pre data-language="haskell">instance (B a, E a, D a) =&gt; F a where {}
</pre> <p>The first matching axiom we encounter while entailing <code>C a</code>, is <code>B a =&gt; C a</code>. We have a local axiom <code>B a</code> available, so now the program is suddenly accepted. This behaviour, where the ordering of an instance context determines whether or not the program is accepted, seems rather confusing for the developer.</p> </li> <li>
<strong>Reject if in doubt</strong>. An alternative approach would be to check for overlapping axioms, when solving a constraint. When multiple matching axioms are discovered, we <strong>reject the program</strong>. This approach is a bit conservative, in that it may reject working programs. But it seem much more transparent towards the developer, who can be presented with a clear message, explaining why the program is rejected. </li> <li>
<p class="first"><strong>Backtracking</strong>. Lastly, a simple form of <strong>backtracking</strong> could be introduced. We simply select the first matching axiom we encounter and when the entailment fails, we backtrack and look for other axioms that might match the wanted constraint.</p> <p>This seems the most intuitive and transparent approach towards the developer, who no longer needs to concern himself with the fact that his code might contain overlapping axioms or with the ordering of his instance contexts. But backtracking would apply equally to ordinary instance selection (in the presence of overlapping instances), so it is a much more pervasive change, with substantial consequences for the type inference engine.</p> </li> </ul> <p>GHC adopts <strong>Reject if in doubt</strong> for now. We can see how painful it is in practice, and try something more ambitious if necessary.</p>   <h2 id="instance-lookup">11.15.6. Instance lookup</h2> <p>In the light of the overlap decision, instance lookup works like this when trying to solve a class constraint <code>C t</code></p> <ol class="arabic simple"> <li>First see if there is a given un-quantified constraint <code>C t</code>. If so, use it to solve the constraint.</li> <li>If not, look at all the available given quantified constraints; if exactly one one matches <code>C t</code>, choose it; if more than one matches, report an error.</li> <li>If no quantified constraints match, look up in the global instances, as described in <a class="reference internal" href="#instance-resolution"><span class="std std-ref">Instance resolution</span></a> and <a class="reference internal" href="#instance-overlap"><span class="std std-ref">Overlapping instances</span></a>.</li> </ol>   <h2 id="termination">11.15.7. Termination</h2> <p>GHC uses the <a class="reference internal" href="#instance-termination"><span class="std std-ref">Paterson Conditions</span></a> to ensure that instance resolution terminates. How are those rules modified for quantified constraints? In two ways.</p> <ul class="simple"> <li>Each quantified constraint, taken by itself, must satisfy the termination rules for an instance declaration.</li> <li>After “for each class constraint <code>(C t1 ... tn)</code>”, add “or each quantified constraint <code>(forall as. context =&gt; C t1 .. tn)</code>“</li> </ul> <p>Note that the second item only at the <em>head</em> of the quantified constraint, not its context. Reason: the head is the new goal that has to be solved if we use the instance declaration.</p> <p>Of course, <code>UndecidableInstances</code> lifts the Paterson Conditions, as now.</p>   <h2 id="coherence">11.15.8. Coherence</h2> <p>Although quantified constraints are a little like local instance declarations, they differ in one big way: the local instances are written by the compiler, not the user, and hence cannot introduce incoherence. Consider</p> <pre data-language="haskell">f :: (forall a. Eq a =&gt; Eq (f a)) =&gt; f b -&gt; f Bool
f x = ...rhs...
</pre> <p>In <code>...rhs...</code> there is, in effect a local instance for <code>Eq (f a)</code> for any <code>a</code>. But at a call site for <code>f</code> the compiler itself produces evidence to pass to <code>f</code>. For example, if we called <code>f Nothing</code>, then <code>f</code> is <code>Maybe</code> and the compiler must prove (at the call site) that <code>forall a. Eq a =&gt; Eq (Maybe a)</code> holds. It can do this easily, by appealing to the existing instance declaration for <code>Eq (Maybe a)</code>.</p> <p>In short, quantifed constraints do not introduce incoherence.</p>    <h1 id="id56">11.16. Extensions to type signatures</h1>  <h2 id="explicit-foralls">11.16.1. Explicit universal quantification (forall)</h2> <dl class="extension" id="extensions-to-type-signatures"> <dt id="extension-ExplicitForAll">
<code>ExplicitForAll</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.12.1</td> </tr>  </table> <p>Allow use of the <code>forall</code> keyword in places where universal quantification is implicit.</p> </dd>
</dl> <p>Haskell type signatures are implicitly quantified. When the language option <a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is used, the keyword <code>forall</code> allows us to say exactly what this means. For example:</p> <pre data-language="haskell">g :: b -&gt; b
</pre> <p>means this:</p> <pre data-language="haskell">g :: forall b. (b -&gt; b)
</pre> <p>The two are treated identically, except that the latter may bring type variables into scope (see <a class="reference internal" href="#scoped-type-variables"><span class="std std-ref">Lexically scoped type variables</span></a>).</p> <p>This extension also enables explicit quantification of type and kind variables in <a class="reference internal" href="#data-instance-declarations"><span class="std std-ref">Data instance declarations</span></a>, <a class="reference internal" href="#type-instance-declarations"><span class="std std-ref">Type instance declarations</span></a>, <a class="reference internal" href="#closed-type-families"><span class="std std-ref">Closed type families</span></a>, <a class="reference internal" href="#assoc-inst"><span class="std std-ref">Associated instances</span></a>, and <a class="reference internal" href="#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>.</p> <p>Notes:</p> <ul> <li>
<p class="first">As well in type signatures, you can also use an explicit <code>forall</code> in an instance declaration:</p> <pre data-language="haskell">instance forall a. Eq a =&gt; Eq [a] where ...
</pre> </li> <li>
<p class="first">If the <a class="reference internal" href="using-warnings#ghc-flag--Wunused-foralls"><code>-Wunused-foralls</code></a> flag is enabled, a warning will be emitted when you write a type variable in an explicit <code>forall</code> statement that is otherwise unused. For instance:</p> <pre data-language="haskell">g :: forall a b. (b -&gt; b)
</pre> <p>would warn about the unused type variable <code>a</code>.</p> </li> </ul>   <h2 id="flexible-contexts">11.16.2. The context of a type signature</h2> <p id="the-context-of-a-type-signature">The <a class="reference internal" href="#extension-FlexibleContexts"><code>FlexibleContexts</code></a> extension lifts the Haskell 98 restriction that the type-class constraints in a type signature must have the form <em>(class type-variable)</em> or <em>(class (type-variable type1 type2 ... typen))</em>. With <a class="reference internal" href="#extension-FlexibleContexts"><code>FlexibleContexts</code></a> these type signatures are perfectly okay</p> <pre data-language="haskell">g :: Eq [a] =&gt; ...
g :: Ord (T a ()) =&gt; ...
</pre> <p>The flag <a class="reference internal" href="#extension-FlexibleContexts"><code>FlexibleContexts</code></a> also lifts the corresponding restriction on class declarations (<a class="reference internal" href="#superclass-rules"><span class="std std-ref">The superclasses of a class declaration</span></a>) and instance declarations (<a class="reference internal" href="#instance-rules"><span class="std std-ref">Relaxed rules for instance contexts</span></a>).</p>   <h2 id="ambiguity">11.16.3. Ambiguous types and the ambiguity check</h2> <dl class="extension" id="ambiguous-types-and-the-ambiguity-check"> <dt id="extension-AllowAmbiguousTypes">
<code>AllowAmbiguousTypes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8.1</td> </tr>  </table> <p>Allow type signatures which appear that they would result in an unusable binding.</p> </dd>
</dl> <p>Each user-written type signature is subjected to an <em>ambiguity check</em>. The ambiguity check rejects functions that can never be called; for example:</p> <pre data-language="haskell">f :: C a =&gt; Int
</pre> <p>The idea is there can be no legal calls to <code>f</code> because every call will give rise to an ambiguous constraint. Indeed, the <em>only</em> purpose of the ambiguity check is to report functions that cannot possibly be called. We could soundly omit the ambiguity check on type signatures entirely, at the expense of delaying ambiguity errors to call sites. Indeed, the language extension <a class="reference internal" href="#extension-AllowAmbiguousTypes"><code>AllowAmbiguousTypes</code></a> switches off the ambiguity check.</p> <p>Ambiguity can be subtle. Consider this example which uses functional dependencies:</p> <pre data-language="haskell">class D a b | a -&gt; b where ..
h :: D Int b =&gt; Int
</pre> <p>The <code>Int</code> may well fix <code>b</code> at the call site, so that signature should not be rejected. Moreover, the dependencies might be hidden. Consider</p> <pre data-language="haskell">class X a b where ...
class D a b | a -&gt; b where ...
instance D a b =&gt; X [a] b where...
h :: X a b =&gt; a -&gt; a
</pre> <p>Here <code>h</code>‘s type looks ambiguous in <code>b</code>, but here’s a legal call:</p> <pre data-language="haskell">...(h [True])...
</pre> <p>That gives rise to a <code>(X [Bool] beta)</code> constraint, and using the instance means we need <code>(D Bool beta)</code> and that fixes <code>beta</code> via <code>D</code>‘s fundep!</p> <p>Behind all these special cases there is a simple guiding principle. Consider</p> <pre data-language="haskell">f :: type
f = ...blah...

g :: type
g = f
</pre> <p>You would think that the definition of <code>g</code> would surely typecheck! After all <code>f</code> has exactly the same type, and <code>g=f</code>. But in fact <code>f</code>‘s type is instantiated and the instantiated constraints are solved against the constraints bound by <code>g</code>‘s signature. So, in the case an ambiguous type, solving will fail. For example, consider the earlier definition <code>f :: C a =&gt; Int</code>:</p> <pre data-language="haskell">f :: C a =&gt; Int
f = ...blah...

g :: C a =&gt; Int
g = f
</pre> <p>In <code>g</code>‘s definition, we’ll instantiate to <code>(C alpha)</code> and try to deduce <code>(C alpha)</code> from <code>(C a)</code>, and fail.</p> <p>So in fact we use this as our <em>definition</em> of ambiguity: a type <code>ty</code> is ambiguous if and only if <code>((undefined :: ty) :: ty)</code> would fail to typecheck. We use a very similar test for <em>inferred</em> types, to ensure that they too are unambiguous.</p> <p><em>Switching off the ambiguity check.</em> Even if a function has an ambiguous type according the “guiding principle”, it is possible that the function is callable. For example:</p> <pre data-language="haskell">class D a b where ...
instance D Bool b where ...

strange :: D a b =&gt; a -&gt; a
strange = ...blah...

foo = strange True
</pre> <p>Here <code>strange</code>‘s type is ambiguous, but the call in <code>foo</code> is OK because it gives rise to a constraint <code>(D Bool beta)</code>, which is soluble by the <code>(D Bool b)</code> instance.</p> <p>Another way of getting rid of the ambiguity at the call site is to use the <a class="reference internal" href="#extension-TypeApplications"><code>TypeApplications</code></a> extension to specify the types. For example:</p> <pre data-language="haskell">class D a b where
  h :: b
instance D Int Int where ...

main = print (h @Int @Int)
</pre> <p>Here <code>a</code> is ambiguous in the definition of <code>D</code> but later specified to be <code>Int</code> using type applications.</p> <p><a class="reference internal" href="#extension-AllowAmbiguousTypes"><code>AllowAmbiguousTypes</code></a> allows you to switch off the ambiguity check. However, even with ambiguity checking switched off, GHC will complain about a function that can <em>never</em> be called, such as this one:</p> <pre data-language="haskell">f :: (Int ~ Bool) =&gt; a -&gt; a
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p><em>A historical note.</em> GHC used to impose some more restrictive and less principled conditions on type signatures. For type <code>forall tv1..tvn (c1, ...,cn) =&gt; type</code> GHC used to require</p>  <ol class="loweralpha simple"> <li>that each universally quantified type variable <code>tvi</code> must be “reachable” from <code>type</code>, and</li> <li>that every constraint <code>ci</code> mentions at least one of the universally quantified type variables <code>tvi</code>. These ad-hoc restrictions are completely subsumed by the new ambiguity check.</li> </ol>  </div>   <h2 id="kinding">11.16.4. Explicitly-kinded quantification</h2> <dl class="extension" id="explicitly-kinded-quantification"> <dt id="extension-KindSignatures">
<code>KindSignatures</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow explicit kind signatures on type variables.</p> </dd>
</dl> <p>Haskell infers the kind of each type variable. Sometimes it is nice to be able to give the kind explicitly as (machine-checked) documentation, just as it is nice to give a type signature for a function. On some occasions, it is essential to do so. For example, in his paper “Restricted Data Types in Haskell” (Haskell Workshop 1999) John Hughes had to define the data type:</p> <pre data-language="haskell">data Set cxt a = Set [a]
               | Unused (cxt a -&gt; ())
</pre> <p>The only use for the <code>Unused</code> constructor was to force the correct kind for the type variable <code>cxt</code>.</p> <p>GHC now instead allows you to specify the kind of a type variable directly, wherever a type variable is explicitly bound, with the extension <a class="reference internal" href="#extension-KindSignatures"><code>KindSignatures</code></a>.</p> <p>This extension enables kind signatures in the following places:</p> <ul> <li>
<p class="first"><code>data</code> declarations:</p> <pre data-language="haskell">data Set (cxt :: Type -&gt; Type) a = Set [a]
</pre> </li> <li>
<p class="first"><code>type</code> declarations:</p> <pre data-language="haskell">type T (f :: Type -&gt; Type) = f Int
</pre> </li> <li>
<p class="first"><code>class</code> declarations:</p> <pre data-language="haskell">class (Eq a) =&gt; C (f :: Type -&gt; Type) a where ...
</pre> </li> <li>
<p class="first"><code>forall</code>‘s in type signatures:</p> <pre data-language="haskell">f :: forall (cxt :: Type -&gt; Type). Set cxt Int
</pre> </li> </ul> <p>The parentheses are required.</p> <p>As part of the same extension, you can put kind annotations in types as well. Thus:</p> <pre data-language="haskell">f :: (Int :: Type) -&gt; Int
g :: forall a. a -&gt; (a :: Type)
</pre> <p>The syntax is</p> <pre data-language="none">atype ::= '(' ctype '::' kind ')
</pre> <p>The parentheses are required.</p>    <h1 id="universal-quantification">11.17. Lexically scoped type variables</h1> <dl class="extension" id="lexically-scoped-type-variables"> <dt id="extension-ScopedTypeVariables">
<code>ScopedTypeVariables</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Enable lexical scoping of type variables explicitly introduced with <code>forall</code>.</p> </dd>
</dl> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p><code>ScopedTypeVariables</code> breaks GHC’s usual rule that explicit <code>forall</code> is optional and doesn’t affect semantics. For the <a class="reference internal" href="#decl-type-sigs"><span class="std std-ref">Declaration type signatures</span></a> (or <a class="reference internal" href="#exp-type-sigs"><span class="std std-ref">Expression type signatures</span></a>) examples in this section, the explicit <code>forall</code> is required. (If omitted, usually the program will not compile; in a few cases it will compile but the functions get a different signature.) To trigger those forms of <code>ScopedTypeVariables</code>, the <code>forall</code> must appear against the top-level signature (or outer expression) but <em>not</em> against nested signatures referring to the same type variables.</p> <p class="last">Explicit <code>forall</code> is not always required – see <a class="reference internal" href="#pattern-equiv-form"><span class="std std-ref">pattern signature equivalent</span></a> for the example in this section, or <a class="reference internal" href="#pattern-type-sigs"><span class="std std-ref">Pattern type signatures</span></a>.</p> </div> <p>GHC supports <em>lexically scoped type variables</em>, without which some type signatures are simply impossible to write. For example:</p> <pre data-language="haskell">f :: forall a. [a] -&gt; [a]
f xs = ys ++ ys
     where
       ys :: [a]
       ys = reverse xs
</pre> <p>The type signature for <code>f</code> brings the type variable <code>a</code> into scope, because of the explicit <code>forall</code> (<a class="reference internal" href="#decl-type-sigs"><span class="std std-ref">Declaration type signatures</span></a>). The type variables bound by a <code>forall</code> scope over the entire definition of the accompanying value declaration. In this example, the type variable <code>a</code> scopes over the whole definition of <code>f</code>, including over the type signature for <code>ys</code>. In Haskell 98 it is not possible to declare a type for <code>ys</code>; a major benefit of scoped type variables is that it becomes possible to do so.</p> <p id="pattern-equiv-form">An equivalent form for that example, avoiding explicit <code>forall</code> uses <a class="reference internal" href="#pattern-type-sigs"><span class="std std-ref">Pattern type signatures</span></a>:</p> <pre data-language="haskell">f :: [a] -&gt; [a]
f (xs :: [aa]) = xs ++ ys
  where
    ys :: [aa]
    ys = reverse xs
</pre> <p>Unlike the <code>forall</code> form, type variable <code>a</code> from <code>f</code>‘s signature is not scoped over <code>f</code>‘s equation(s). Type variable <code>aa</code> bound by the pattern signature is scoped over the right-hand side of <code>f</code>‘s equation. (Therefore there is no need to use a distinct type variable; using <code>a</code> would be equivalent.)</p>  <h2 id="id57">11.17.1. Overview</h2> <p>The design follows the following principles</p> <ul class="simple"> <li>A scoped type variable stands for a type <em>variable</em>, and not for a <em>type</em>. (This is a change from GHC’s earlier design.)</li> <li>Furthermore, distinct lexical type variables stand for distinct type variables. This means that every programmer-written type signature (including one that contains free scoped type variables) denotes a <em>rigid</em> type; that is, the type is fully known to the type checker, and no inference is involved.</li> <li>Lexical type variables may be alpha-renamed freely, without changing the program.</li> </ul> <p>A <em>lexically scoped type variable</em> can be bound by:</p> <ul class="simple"> <li>A declaration type signature (<a class="reference internal" href="#decl-type-sigs"><span class="std std-ref">Declaration type signatures</span></a>)</li> <li>An expression type signature (<a class="reference internal" href="#exp-type-sigs"><span class="std std-ref">Expression type signatures</span></a>)</li> <li>A pattern type signature (<a class="reference internal" href="#pattern-type-sigs"><span class="std std-ref">Pattern type signatures</span></a>)</li> <li>Class and instance declarations (<a class="reference internal" href="#cls-inst-scoped-tyvars"><span class="std std-ref">Class and instance declarations</span></a>)</li> </ul> <p>In Haskell, a programmer-written type signature is implicitly quantified over its free type variables (<a class="reference external" href="http://www.haskell.org/onlinereport/decls.html#sect4.1.2">Section 4.1.2</a> of the Haskell Report). Lexically scoped type variables affect this implicit quantification rules as follows: any type variable that is in scope is <em>not</em> universally quantified. For example, if type variable <code>a</code> is in scope, then</p> <pre data-language="haskell">(e :: a -&gt; a)     means     (e :: a -&gt; a)
(e :: b -&gt; b)     means     (e :: forall b. b-&gt;b)
(e :: a -&gt; b)     means     (e :: forall b. a-&gt;b)
</pre>   <h2 id="decl-type-sigs">11.17.2. Declaration type signatures</h2> <p id="declaration-type-signatures">A declaration type signature that has <em>explicit</em> quantification (using <code>forall</code>) brings into scope the explicitly-quantified type variables, in the definition of the named function. For example:</p> <pre data-language="haskell">f :: forall a. [a] -&gt; [a]
f (x:xs) = xs ++ [ x :: a ]
</pre> <p>The “<code>forall a</code>” brings “<code>a</code>” into scope in the definition of “<code>f</code>”.</p> <p>This only happens if:</p> <ul> <li>
<p class="first">The quantification in <code>f</code>‘s type signature is explicit. For example:</p> <pre data-language="haskell">g :: [a] -&gt; [a]
g (x:xs) = xs ++ [ x :: a ]
</pre> <p>This program will be rejected, because “<code>a</code>” does not scope over the definition of “<code>g</code>”, so “<code>x::a</code>” means “<code>x::forall a. a</code>” by Haskell’s usual implicit quantification rules.</p> </li> <li>
<p class="first">The type variable is quantified by the single, syntactically visible, outermost <code>forall</code> of the type signature. For example, GHC will reject all of the following examples:</p> <pre data-language="haskell">f1 :: forall a. forall b. a -&gt; [b] -&gt; [b]
f1 _ (x:xs) = xs ++ [ x :: b ]

f2 :: forall a. a -&gt; forall b. [b] -&gt; [b]
f2 _ (x:xs) = xs ++ [ x :: b ]

type Foo = forall b. [b] -&gt; [b]

f3 :: Foo
f3 (x:xs) = xs ++ [ x :: b ]
</pre> <p>In <code>f1</code> and <code>f2</code>, the type variable <code>b</code> is not quantified by the outermost <code>forall</code>, so it is not in scope over the bodies of the functions. Neither is <code>b</code> in scope over the body of <code>f3</code>, as the <code>forall</code> is tucked underneath the <code>Foo</code> type synonym.</p> </li> <li>
<p class="first">The signature gives a type for a function binding or a bare variable binding, not a pattern binding. For example:</p> <pre data-language="haskell">f1 :: forall a. [a] -&gt; [a]
f1 (x:xs) = xs ++ [ x :: a ]   -- OK

f2 :: forall a. [a] -&gt; [a]
f2 = \(x:xs) -&gt; xs ++ [ x :: a ]   -- OK

f3 :: forall a. [a] -&gt; [a]
Just f3 = Just (\(x:xs) -&gt; xs ++ [ x :: a ])   -- Not OK!
</pre> <p><code>f1</code> is a function binding, and <code>f2</code> binds a bare variable; in both cases the type signature brings <code>a</code> into scope. However the binding for <code>f3</code> is a pattern binding, and so <code>f3</code> is a fresh variable brought into scope by the pattern, not connected with top level <code>f3</code>. Then type variable <code>a</code> is not in scope of the right-hand side of <code>Just f3 = ...</code>.</p> </li> </ul>   <h2 id="exp-type-sigs">11.17.3. Expression type signatures</h2> <p id="expression-type-signatures">An expression type signature that has <em>explicit</em> quantification (using <code>forall</code>) brings into scope the explicitly-quantified type variables, in the annotated expression. For example:</p> <pre data-language="haskell">f = runST ( (op &gt;&gt;= \(x :: STRef s Int) -&gt; g x) :: forall s. ST s Bool )
</pre> <p>Here, the type signature <code>forall s. ST s Bool</code> brings the type variable <code>s</code> into scope, in the annotated expression <code>(op &gt;&gt;= \(x :: STRef s Int) -&gt; g x)</code>.</p>   <h2 id="pattern-type-sigs">11.17.4. Pattern type signatures</h2> <p id="pattern-type-signatures">A type signature may occur in any pattern; this is a <em>pattern type signature</em>. For example:</p> <pre data-language="haskell">-- f and g assume that 'a' is already in scope
f = \(x::Int, y::a) -&gt; x

g (x::a) = x

h ((x,y) :: (Int,Bool)) = (y,x)
</pre> <p>In the case where all the type variables in the pattern type signature are already in scope (i.e. bound by the enclosing context), matters are simple: the signature simply constrains the type of the pattern in the obvious way.</p> <p>Unlike expression and declaration type signatures, pattern type signatures are not implicitly generalised. The pattern in a <em>pattern binding</em> may only mention type variables that are already in scope. For example:</p> <pre data-language="haskell">f :: forall a. [a] -&gt; (Int, [a])
f xs = (n, zs)
  where
    (ys::[a], n) = (reverse xs, length xs) -- OK
    (zs::[a])    = xs ++ ys                     -- OK

    Just (v::b)  = ...  -- Not OK; b is not in scope
</pre> <p>Here, the pattern signatures for <code>ys</code> and <code>zs</code> are fine, but the one for <code>v</code> is not because <code>b</code> is not in scope.</p> <p>However, in all patterns <em>other</em> than pattern bindings, a pattern type signature may mention a type variable that is not in scope; in this case, <em>the signature brings that type variable into scope</em>. For example:</p> <pre data-language="haskell">-- same f and g as above, now assuming that 'a' is not already in scope
f = \(x::Int, y::a) -&gt; x           -- 'a' is in scope on RHS of -&gt;

g (x::a) = x :: a

hh (Just (v :: b)) = v :: b
</pre> <p>The pattern type signature makes the type variable available on the right-hand side of the equation.</p> <p>Bringing type variables into scope is particularly important for existential data constructors. For example:</p> <pre data-language="haskell">data T = forall a. MkT [a]

k :: T -&gt; T
k (MkT [t::a]) =
    MkT t3
  where
    (t3::[a]) = [t,t,t]
</pre> <p>Here, the pattern type signature <code>[t::a]</code> mentions a lexical type variable that is not already in scope. Indeed, it <em>must not</em> already be in scope, because it is bound by the pattern match. The effect is to bring it into scope, standing for the existentially-bound type variable.</p> <p>It does seem odd that the existentially-bound type variable <em>must not</em> be already in scope. Contrast that usually name-bindings merely shadow (make a ‘hole’) in a same-named outer variable’s scope. But we must have <em>some</em> way to bring such type variables into scope, else we could not name existentially-bound type variables in subsequent type signatures.</p> <p>Compare the two (identical) definitions for examples <code>f</code>, <code>g</code>; they are both legal whether or not <code>a</code> is already in scope. They differ in that <em>if</em> <code>a</code> is already in scope, the signature constrains the pattern, rather than the pattern binding the variable.</p>   <h2 id="cls-inst-scoped-tyvars">11.17.5. Class and instance declarations</h2> <p id="class-and-instance-declarations">The type variables in the head of a <code>class</code> or <code>instance</code> declaration scope over the methods defined in the <code>where</code> part. You do not even need an explicit <code>forall</code> (although you are allowed an explicit <code>forall</code> in an <code>instance</code> declaration; see <a class="reference internal" href="#explicit-foralls"><span class="std std-ref">Explicit universal quantification (forall)</span></a>). For example:</p> <pre data-language="haskell">class C a where
  op :: [a] -&gt; a

  op xs = let ys::[a]
              ys = reverse xs
          in
          head ys

instance C b =&gt; C [b] where
  op xs = reverse (head (xs :: [[b]]))
</pre>    <h1 id="bindings-and-generalisation">11.18. Bindings and generalisation</h1>  <h2 id="monomorphism">11.18.1. Switching off the dreaded Monomorphism Restriction</h2> <dl class="extension" id="switching-off-the-dreaded-monomorphism-restriction"> <dt id="extension-NoMonomorphismRestriction">
<code>NoMonomorphismRestriction</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Prevents the compiler from applying the monomorphism restriction to bindings lacking explicit type signatures.</p> </dd>
</dl> <p>Haskell’s monomorphism restriction (see <a class="reference external" href="http://www.haskell.org/onlinereport/decls.html#sect4.5.5">Section 4.5.5</a> of the Haskell Report) can be completely switched off by <a class="reference internal" href="#extension-NoMonomorphismRestriction"><code>NoMonomorphismRestriction</code></a>. Since GHC 7.8.1, the monomorphism restriction is switched off by default in GHCi’s interactive options (see <a class="reference internal" href="ghci#ghci-interactive-options"><span class="std std-ref">Setting options for interactive evaluation only</span></a>).</p>   <h2 id="mono-local-binds">11.18.2. Let-generalisation</h2> <dl class="extension" id="let-generalisation"> <dt id="extension-MonoLocalBinds">
<code>MonoLocalBinds</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.12.1</td> </tr>  </table> <p>Infer less polymorphic types for local bindings by default.</p> </dd>
</dl> <p>An ML-style language usually generalises the type of any <code>let</code>-bound or <code>where</code>-bound variable, so that it is as polymorphic as possible. With the extension <a class="reference internal" href="#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a> GHC implements a slightly more conservative policy, using the following rules:</p> <ul class="simple"> <li>A variable is <em>closed</em> if and only if<ul> <li>the variable is let-bound</li> <li>one of the following holds:<ul> <li>the variable has an explicit type signature that has no free type variables, or</li> <li>its binding group is fully generalised (see next bullet)</li> </ul> </li> </ul> </li> <li>A binding group is <em>fully generalised</em> if and only if<ul> <li>each of its free variables is either imported or closed, and</li> <li>the binding is not affected by the monomorphism restriction (<a class="reference external" href="http://www.haskell.org/onlinereport/decls.html#sect4.5.5">Haskell Report, Section 4.5.5</a>)</li> </ul> </li> </ul> <p>For example, consider</p> <pre data-language="haskell">f x = x + 1
g x = let h y = f y * 2
          k z = z+x
      in  h x + k x
</pre> <p>Here <code>f</code> is generalised because it has no free variables; and its binding group is unaffected by the monomorphism restriction; and hence <code>f</code> is closed. The same reasoning applies to <code>g</code>, except that it has one closed free variable, namely <code>f</code>. Similarly <code>h</code> is closed, <em>even though it is not bound at top level</em>, because its only free variable <code>f</code> is closed. But <code>k</code> is not closed, because it mentions <code>x</code> which is not closed (because it is not let-bound).</p> <p>Notice that a top-level binding that is affected by the monomorphism restriction is not closed, and hence may in turn prevent generalisation of bindings that mention it.</p> <p>The rationale for this more conservative strategy is given in <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf">the papers</a> “Let should not be generalised” and “Modular type inference with local assumptions”, and a related <a class="reference external" href="http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7">blog post</a>.</p> <p>The extension <a class="reference internal" href="#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a> is implied by <a class="reference internal" href="#extension-TypeFamilies"><code>TypeFamilies</code></a> and <a class="reference internal" href="#extension-GADTs"><code>GADTs</code></a>. You can switch it off again with <code>NoMonoLocalBinds</code> but type inference becomes less predictable if you do so. (Read the papers!)</p>    <h1 id="id58">11.19. Visible type application</h1> <dl class="extension" id="visible-type-application"> <dt id="extension-TypeApplications">
<code>TypeApplications</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Allow the use of type application syntax.</p> </dd>
</dl> <p>The <a class="reference internal" href="#extension-TypeApplications"><code>TypeApplications</code></a> extension allows you to use <em>visible type application</em> in expressions. Here is an example: <code>show (read @Int "5")</code>. The <code>@Int</code> is the visible type application; it specifies the value of the type variable in <code>read</code>‘s type.</p> <p>A visible type application is preceded with an <code>@</code> sign. (To disambiguate the syntax, the <code>@</code> must be preceded with a non-identifier letter, usually a space. For example, <code>read@Int 5</code> would not parse.) It can be used whenever the full polymorphic type of the function is known. If the function is an identifier (the common case), its type is considered known only when the identifier has been given a type signature. If the identifier does not have a type signature, visible type application cannot be used.</p> <p>GHC also permits visible kind application, where users can declare the kind arguments to be instantiated in kind-polymorphic cases. Its usage parallels visible type application in the term level, as specified above.</p>  <h2 id="inferred-vs-specified">11.19.1. Inferred vs. specified type variables</h2> <p id="inferred-vs-specified-type-variables">GHC tracks a distinction between what we call <em>inferred</em> and <em>specified</em> type variables. Only specified type variables are available for instantiation with visible type application. An example illustrates this well:</p> <pre data-language="haskell">f :: (Eq b, Eq a) =&gt; a -&gt; b -&gt; Bool
f x y = (x == x) &amp;&amp; (y == y)

g x y = (x == x) &amp;&amp; (y == y)
</pre> <p>The functions <code>f</code> and <code>g</code> have the same body, but only <code>f</code> is given a type signature. When GHC is figuring out how to process a visible type application, it must know what variable to instantiate. It thus must be able to provide an ordering to the type variables in a function’s type.</p> <p>If the user has supplied a type signature, as in <code>f</code>, then this is easy: we just take the ordering from the type signature, going left to right and using the first occurrence of a variable to choose its position within the ordering. Thus, the variables in <code>f</code> will be <code>b</code>, then <code>a</code>.</p> <p>In contrast, there is no reliable way to do this for <code>g</code>; we will not know whether <code>Eq a</code> or <code>Eq b</code> will be listed first in the constraint in <code>g</code>‘s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with <code>g</code>.</p> <p>We say that the type variables in <code>f</code> are <em>specified</em>, while those in <code>g</code> are <em>inferred</em>. The general rule is this: if the user has written a type variable in the source program, it is <em>specified</em>; if not, it is <em>inferred</em>.</p> <p>Thus rule applies in datatype declarations, too. For example, if we have <code>data Proxy a = Proxy</code> (and <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a> is enabled), then <code>a</code> will be assigned kind <code>k</code>, where <code>k</code> is a fresh kind variable. Because <code>k</code> was not written by the user, it will be unavailable for type application in the type of the constructor <code>Proxy</code>; only the <code>a</code> will be available.</p> <p>When <a class="reference internal" href="using#ghc-flag--fprint-explicit-foralls"><code>-fprint-explicit-foralls</code></a> is enabled, inferred variables are printed in braces. Thus, the type of the data constructor <code>Proxy</code> from the previous example would be <code>forall {k} (a :: k). Proxy a</code>. We can observe this behavior in a GHCi session:</p> <pre data-language="haskell">&gt; :set -XTypeApplications -fprint-explicit-foralls
&gt; let myLength1 :: Foldable f =&gt; f a -&gt; Int; myLength1 = length
&gt; :type +v myLength1
myLength1 :: forall (f :: * -&gt; *) a. Foldable f =&gt; f a -&gt; Int
&gt; let myLength2 = length
&gt; :type +v myLength2
myLength2 :: forall {a} {t :: * -&gt; *}. Foldable t =&gt; t a -&gt; Int
&gt; :type +v myLength2 @[]

&lt;interactive&gt;:1:1: error:
    • Cannot apply expression of type ‘t0 a0 -&gt; Int’
      to a visible type argument ‘[]’
    • In the expression: myLength2 @[]
</pre> <p>Notice that since <code>myLength1</code> was defined with an explicit type signature, <a class="reference internal" href="ghci#ghci-cmd-:type%20+v"><code>:type +v</code></a> reports that all of its type variables are available for type application. On the other hand, <code>myLength2</code> was not given a type signature. As a result, all of its type variables are surrounded with braces, and trying to use visible type application with <code>myLength2</code> fails.</p> <p>Also note the use of <a class="reference internal" href="ghci#ghci-cmd-:type%20+v"><code>:type +v</code></a> in the GHCi session above instead of <a class="reference internal" href="ghci#ghci-cmd-:type"><code>:type</code></a>. This is because <a class="reference internal" href="ghci#ghci-cmd-:type"><code>:type</code></a> gives you the type that would be inferred for a variable assigned to the expression provided (that is, the type of <code>x</code> in <code>let x = &lt;expr&gt;</code>). As we saw above with <code>myLength2</code>, this type will have no variables available to visible type application. On the other hand, <a class="reference internal" href="ghci#ghci-cmd-:type%20+v"><code>:type +v</code></a> gives you the actual type of the expression provided. To illustrate this:</p> <pre data-language="haskell">&gt; :type myLength1
myLength1 :: forall {a} {f :: * -&gt; *}. Foldable f =&gt; f a -&gt; Int
&gt; :type myLength2
myLength2 :: forall {a} {t :: * -&gt; *}. Foldable t =&gt; t a -&gt; Int
</pre> <p id="scopedsort">Using <a class="reference internal" href="ghci#ghci-cmd-:type"><code>:type</code></a> might lead one to conclude that none of the type variables in <code>myLength1</code>‘s type signature are available for type application. This isn’t true, however! Be sure to use <a class="reference internal" href="ghci#ghci-cmd-:type%20+v"><code>:type +v</code></a> if you want the most accurate information with respect to visible type application properties.</p>   <h2 id="index-19">11.19.2. Ordering of specified variables</h2> <p id="ordering-of-specified-variables">In the simple case of the previous section, we can say that specified variables appear in left-to-right order. However, not all cases are so simple. Here are the rules in the subtler cases:</p> <ul> <li>If an identifier’s type has a <code>forall</code>, then the order of type variables as written in the <code>forall</code> is retained. </li> <li>
<p class="first">If the type signature includes any kind annotations (either on variable binders or as annotations on types), any variables used in kind annotations come before any variables never used in kind annotations. This rule is not recursive: if there is an annotation within an annotation, then the variables used therein are on equal footing. Examples:</p> <pre data-language="haskell">f :: Proxy (a :: k) -&gt; Proxy (b :: j) -&gt; ()
  -- as if f :: forall k j a b. ...

g :: Proxy (b :: j) -&gt; Proxy (a :: (Proxy :: (k -&gt; Type) -&gt; Type) Proxy) -&gt; ()
  -- as if g :: forall j k b a. ...
  -- NB: k is in a kind annotation within a kind annotation
</pre> </li> <li>
<p class="first">If any of the variables depend on other variables (that is, if some of the variables are <em>kind</em> variables), the variables are reordered so that kind variables come before type variables, preserving the left-to-right order as much as possible. That is, GHC performs a stable topological sort on the variables. Example:</p> <pre data-language="haskell">h :: Proxy (a :: (j, k)) -&gt; Proxy (b :: Proxy a) -&gt; ()
  -- as if h :: forall j k a b. ...
</pre> <p>In this example, all of <code>a</code>, <code>j</code>, and <code>k</code> are considered kind variables and will always be placed before <code>b</code>, a lowly type variable. (Note that <code>a</code> is used in <code>b</code>‘s kind.) Yet, even though <code>a</code> appears lexically before <code>j</code> and <code>k</code>, <code>j</code> and <code>k</code> are quantified first, because <code>a</code> depends on <code>j</code> and <code>k</code>. Note further that <code>j</code> and <code>k</code> are not reordered with respect to each other, even though doing so would not violate dependency conditions.</p> <p>A “stable topological sort” here, we mean that we perform this algorithm (which we call <em>ScopedSort</em>):</p> <ul class="simple"> <li>Work left-to-right through the input list of type variables, with a cursor.</li> <li>If variable <code>v</code> at the cursor is depended on by any earlier variable <code>w</code>, move <code>v</code> immediately before the leftmost such <code>w</code>.</li> </ul> </li> <li>Class methods’ type arguments include the class type variables, followed by any variables an individual method is polymorphic in. So, <code>class Monad m where return :: a -&gt; m a</code> means that <code>return</code>‘s type arguments are <code>m, a</code>. </li> <li>With the <a class="reference internal" href="#extension-RankNTypes"><code>RankNTypes</code></a> extension (<a class="reference internal" href="#universal-quantification"><span class="std std-ref">Lexically scoped type variables</span></a>), it is possible to declare type arguments somewhere other than the beginning of a type. For example, we can have <code>pair :: forall a. a -&gt; forall b. b -&gt; (a, b)</code> and then say <code>pair @Bool True @Char</code> which would have type <code>Char -&gt; (Bool, Char)</code>. </li> <li>Partial type signatures (<a class="reference internal" href="#partial-type-signatures"><span class="std std-ref">Partial Type Signatures</span></a>) work nicely with visible type application. If you want to specify only the second type argument to <code>wurble</code>, then you can say <code>wurble @_ @Int</code>. The first argument is a wildcard, just like in a partial type signature. However, if used in a visible type application/visible kind application, it is <em>not</em> necessary to specify <a class="reference internal" href="#extension-PartialTypeSignatures"><code>PartialTypeSignatures</code></a> and your code will not generate a warning informing you of the omitted type. </li> </ul> <p>The section in this manual on kind polymorphism describes how variables in type and class declarations are ordered (<a class="reference internal" href="#inferring-variable-order"><span class="std std-ref">Inferring the order of variables in a type/class declaration</span></a>).</p>    <h1 id="id59">11.20. Implicit parameters</h1> <dl class="extension" id="implicit-parameters"> <dt id="extension-ImplicitParams">
<code>ImplicitParams</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow definition of functions expecting implicit parameters.</p> </dd>
</dl> <p>Implicit parameters are implemented as described in <a class="reference internal" href="#lewis2000" id="id60">[Lewis2000]</a> and enabled with the option <a class="reference internal" href="#extension-ImplicitParams"><code>ImplicitParams</code></a>. (Most of the following, still rather incomplete, documentation is due to Jeff Lewis.)</p> <table class="docutils citation" frame="void" id="lewis2000" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id60">[Lewis2000]</a></td>
<td>“Implicit parameters: dynamic scoping with static types”, J Lewis, MB Shields, E Meijer, J Launchbury, <em>27th ACM Symposium on Principles of Programming Languages (POPL‘00)</em>, Boston, Jan 2000.</td>
</tr>  </table> <p>A variable is called <em>dynamically bound</em> when it is bound by the calling context of a function and <em>statically bound</em> when bound by the callee’s context. In Haskell, all variables are statically bound. Dynamic binding of variables is a notion that goes back to Lisp, but was later discarded in more modern incarnations, such as Scheme. Dynamic binding can be very confusing in an untyped language, and unfortunately, typed languages, in particular Hindley-Milner typed languages like Haskell, only support static scoping of variables.</p> <p>However, by a simple extension to the type class system of Haskell, we can support dynamic binding. Basically, we express the use of a dynamically bound variable as a constraint on the type. These constraints lead to types of the form <code>(?x::t') =&gt; t</code>, which says “this function uses a dynamically-bound variable <code>?x</code> of type <code>t'</code>”. For example, the following expresses the type of a sort function, implicitly parameterised by a comparison function named <code>cmp</code>.</p> <pre data-language="haskell">sort :: (?cmp :: a -&gt; a -&gt; Bool) =&gt; [a] -&gt; [a]
</pre> <p>The dynamic binding constraints are just a new form of predicate in the type class system.</p> <p>An implicit parameter occurs in an expression using the special form <code>?x</code>, where <code>x</code> is any valid identifier (e.g. <code>ord ?x</code> is a valid expression). Use of this construct also introduces a new dynamic-binding constraint in the type of the expression. For example, the following definition shows how we can define an implicitly parameterised sort function in terms of an explicitly parameterised <code>sortBy</code> function:</p> <pre data-language="haskell">sortBy :: (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; [a]

sort   :: (?cmp :: a -&gt; a -&gt; Bool) =&gt; [a] -&gt; [a]
sort    = sortBy ?cmp
</pre>  <h2 id="implicit-parameter-type-constraints">11.20.1. Implicit-parameter type constraints</h2> <p>Dynamic binding constraints behave just like other type class constraints in that they are automatically propagated. Thus, when a function is used, its implicit parameters are inherited by the function that called it. For example, our <code>sort</code> function might be used to pick out the least value in a list:</p> <pre data-language="haskell">least   :: (?cmp :: a -&gt; a -&gt; Bool) =&gt; [a] -&gt; a
least xs = head (sort xs)
</pre> <p>Without lifting a finger, the <code>?cmp</code> parameter is propagated to become a parameter of <code>least</code> as well. With explicit parameters, the default is that parameters must always be explicit propagated. With implicit parameters, the default is to always propagate them.</p> <p>An implicit-parameter type constraint differs from other type class constraints in the following way: All uses of a particular implicit parameter must have the same type. This means that the type of <code>(?x, ?x)</code> is <code>(?x::a) =&gt; (a,a)</code>, and not <code>(?x::a, ?x::b) =&gt; (a, b)</code>, as would be the case for type class constraints.</p> <p>You can’t have an implicit parameter in the context of a class or instance declaration. For example, both these declarations are illegal:</p> <pre data-language="haskell">class (?x::Int) =&gt; C a where ...
instance (?x::a) =&gt; Foo [a] where ...
</pre> <p>Reason: exactly which implicit parameter you pick up depends on exactly where you invoke a function. But the “invocation” of instance declarations is done behind the scenes by the compiler, so it’s hard to figure out exactly where it is done. Easiest thing is to outlaw the offending types.</p> <p>Implicit-parameter constraints do not cause ambiguity. For example, consider:</p> <pre data-language="haskell">f :: (?x :: [a]) =&gt; Int -&gt; Int
f n = n + length ?x

g :: (Read a, Show a) =&gt; String -&gt; String
g s = show (read s)
</pre> <p>Here, <code>g</code> has an ambiguous type, and is rejected, but <code>f</code> is fine. The binding for <code>?x</code> at <code>f</code>‘s call site is quite unambiguous, and fixes the type <code>a</code>.</p>   <h2 id="implicit-parameter-bindings">11.20.2. Implicit-parameter bindings</h2> <p>An implicit parameter is <em>bound</em> using the standard <code>let</code> or <code>where</code> binding forms. For example, we define the <code>min</code> function by binding <code>cmp</code>.</p> <pre data-language="haskell">min :: Ord a =&gt; [a] -&gt; a
min  = let ?cmp = (&lt;=) in least
</pre> <p>A group of implicit-parameter bindings may occur anywhere a normal group of Haskell bindings can occur, except at top level. That is, they can occur in a <code>let</code> (including in a list comprehension, or do-notation, or pattern guards), or a <code>where</code> clause. Note the following points:</p> <ul> <li>An implicit-parameter binding group must be a collection of simple bindings to implicit-style variables (no function-style bindings, and no type signatures); these bindings are neither polymorphic or recursive. </li> <li>You may not mix implicit-parameter bindings with ordinary bindings in a single <code>let</code> expression; use two nested <code>let</code>s instead. (In the case of <code>where</code> you are stuck, since you can’t nest <code>where</code> clauses.) </li> <li>
<p class="first">You may put multiple implicit-parameter bindings in a single binding group; but they are <em>not</em> treated as a mutually recursive group (as ordinary <code>let</code> bindings are). Instead they are treated as a non-recursive group, simultaneously binding all the implicit parameter. The bindings are not nested, and may be re-ordered without changing the meaning of the program. For example, consider:</p> <pre data-language="haskell">f t = let { ?x = t; ?y = ?x+(1::Int) } in ?x + ?y
</pre> <p>The use of <code>?x</code> in the binding for <code>?y</code> does not “see” the binding for <code>?x</code>, so the type of <code>f</code> is</p> <pre data-language="haskell">f :: (?x::Int) =&gt; Int -&gt; Int
</pre> </li> </ul>   <h2 id="implicit-parameters-and-polymorphic-recursion">11.20.3. Implicit parameters and polymorphic recursion</h2> <p>Consider these two definitions:</p> <pre data-language="haskell">len1 :: [a] -&gt; Int
len1 xs = let ?acc = 0 in len_acc1 xs

len_acc1 [] = ?acc
len_acc1 (x:xs) = let ?acc = ?acc + (1::Int) in len_acc1 xs

------------

len2 :: [a] -&gt; Int
len2 xs = let ?acc = 0 in len_acc2 xs

len_acc2 :: (?acc :: Int) =&gt; [a] -&gt; Int
len_acc2 [] = ?acc
len_acc2 (x:xs) = let ?acc = ?acc + (1::Int) in len_acc2 xs
</pre> <p>The only difference between the two groups is that in the second group <code>len_acc</code> is given a type signature. In the former case, <code>len_acc1</code> is monomorphic in its own right-hand side, so the implicit parameter <code>?acc</code> is not passed to the recursive call. In the latter case, because <code>len_acc2</code> has a type signature, the recursive call is made to the <em>polymorphic</em> version, which takes <code>?acc</code> as an implicit parameter. So we get the following results in GHCi:</p> <pre data-language="none">Prog&gt; len1 "hello"
0
Prog&gt; len2 "hello"
5
</pre> <p>Adding a type signature dramatically changes the result! This is a rather counter-intuitive phenomenon, worth watching out for.</p>   <h2 id="implicit-parameters-and-monomorphism">11.20.4. Implicit parameters and monomorphism</h2> <p>GHC applies the dreaded Monomorphism Restriction (section 4.5.5 of the Haskell Report) to implicit parameters. For example, consider:</p> <pre data-language="haskell">f :: Int -&gt; Int
f v = let ?x = 0     in
      let y = ?x + v in
      let ?x = 5     in
      y
</pre> <p>Since the binding for <code>y</code> falls under the Monomorphism Restriction it is not generalised, so the type of <code>y</code> is simply <code>Int</code>, not <code>(?x::Int) =&gt; Int</code>. Hence, <code>(f 9)</code> returns result <code>9</code>. If you add a type signature for <code>y</code>, then <code>y</code> will get type <code>(?x::Int) =&gt; Int</code>, so the occurrence of <code>y</code> in the body of the <code>let</code> will see the inner binding of <code>?x</code>, so <code>(f 9)</code> will return <code>14</code>.</p>    <h1 id="arbitrary-rank-polymorphism">11.21. Arbitrary-rank polymorphism</h1> <dl class="extension"> <dt id="extension-RankNTypes">
<code>RankNTypes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow types of arbitrary rank.</p> </dd>
</dl> <dl class="extension"> <dt id="extension-Rank2Types">
<code>Rank2Types</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>A deprecated alias of <a class="reference internal" href="#extension-RankNTypes"><code>RankNTypes</code></a>.</p> </dd>
</dl> <p>GHC’s type system supports <em>arbitrary-rank</em> explicit universal quantification in types. For example, all the following types are legal:</p> <pre data-language="haskell">f1 :: forall a b. a -&gt; b -&gt; a
g1 :: forall a b. (Ord a, Eq  b) =&gt; a -&gt; b -&gt; a

f2 :: (forall a. a-&gt;a) -&gt; Int -&gt; Int
g2 :: (forall a. Eq a =&gt; [a] -&gt; a -&gt; Bool) -&gt; Int -&gt; Int

f3 :: ((forall a. a-&gt;a) -&gt; Int) -&gt; Bool -&gt; Bool

f4 :: Int -&gt; (forall a. a -&gt; a)
</pre> <p>Here, <code>f1</code> and <code>g1</code> are rank-1 types, and can be written in standard Haskell (e.g. <code>f1 :: a-&gt;b-&gt;a</code>). The <code>forall</code> makes explicit the universal quantification that is implicitly added by Haskell.</p> <p>The functions <code>f2</code> and <code>g2</code> have rank-2 types; the <code>forall</code> is on the left of a function arrow. As <code>g2</code> shows, the polymorphic type on the left of the function arrow can be overloaded.</p> <p>The function <code>f3</code> has a rank-3 type; it has rank-2 types on the left of a function arrow.</p> <p>The language option <a class="reference internal" href="#extension-RankNTypes"><code>RankNTypes</code></a> (which implies <a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a>) enables higher-rank types. That is, you can nest <code>forall</code>s arbitrarily deep in function arrows. For example, a forall-type (also called a “type scheme”), including a type-class context, is legal:</p> <ul class="simple"> <li>On the left or right (see <code>f4</code>, for example) of a function arrow</li> <li>As the argument of a constructor, or type of a field, in a data type declaration. For example, any of the <code>f1, f2, f3, g1, g2</code> above would be valid field type signatures.</li> <li>As the type of an implicit parameter</li> <li>In a pattern type signature (see <a class="reference internal" href="#scoped-type-variables"><span class="std std-ref">Lexically scoped type variables</span></a>)</li> </ul> <p>The <a class="reference internal" href="#extension-RankNTypes"><code>RankNTypes</code></a> option is also required for any type with a <code>forall</code> or context to the right of an arrow (e.g. <code>f :: Int -&gt; forall a. a-&gt;a</code>, or <code>g :: Int -&gt; Ord a =&gt; a -&gt; a</code>). Such types are technically rank 1, but are clearly not Haskell-98, and an extra extension did not seem worth the bother.</p> <p>In particular, in <code>data</code> and <code>newtype</code> declarations the constructor arguments may be polymorphic types of any rank; see examples in <a class="reference internal" href="#univ"><span class="std std-ref">Examples</span></a>. Note that the declared types are nevertheless always monomorphic. This is important because by default GHC will not instantiate type variables to a polymorphic type (<a class="reference internal" href="#impredicative-polymorphism"><span class="std std-ref">Impredicative polymorphism</span></a>).</p> <p>The obsolete language options <code>PolymorphicComponents</code> and <a class="reference internal" href="#extension-Rank2Types"><code>Rank2Types</code></a> are synonyms for <a class="reference internal" href="#extension-RankNTypes"><code>RankNTypes</code></a>. They used to specify finer distinctions that GHC no longer makes. (They should really elicit a deprecation warning, but they don’t, purely to avoid the need to library authors to change their old flags specifications.)</p>  <h2 id="id61">11.21.1. Examples</h2> <p id="univ">These are examples of <code>data</code> and <code>newtype</code> declarations whose data constructors have polymorphic argument types:</p> <pre data-language="haskell">data T a = T1 (forall b. b -&gt; b -&gt; b) a

data MonadT m = MkMonad { return :: forall a. a -&gt; m a,
                          bind   :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
                        }

newtype Swizzle = MkSwizzle (forall a. Ord a =&gt; [a] -&gt; [a])
</pre> <p>The constructors have rank-2 types:</p> <pre data-language="haskell">T1 :: forall a. (forall b. b -&gt; b -&gt; b) -&gt; a -&gt; T a

MkMonad :: forall m. (forall a. a -&gt; m a)
                  -&gt; (forall a b. m a -&gt; (a -&gt; m b) -&gt; m b)
                  -&gt; MonadT m

MkSwizzle :: (forall a. Ord a =&gt; [a] -&gt; [a]) -&gt; Swizzle
</pre> <p>In earlier versions of GHC, it was possible to omit the <code>forall</code> in the type of the constructor if there was an explicit context. For example:</p> <pre data-language="haskell">newtype Swizzle' = MkSwizzle' (Ord a =&gt; [a] -&gt; [a])
</pre> <p>Since GHC 8.0 declarations such as <code>MkSwizzle'</code> will cause an out-of-scope error.</p> <p>As for type signatures, implicit quantification happens for non-overloaded types too. So if you write this:</p> <pre data-language="haskell">f :: (a -&gt; a) -&gt; a
</pre> <p>it’s just as if you had written this:</p> <pre data-language="haskell">f :: forall a. (a -&gt; a) -&gt; a
</pre> <p>That is, since the type variable <code>a</code> isn’t in scope, it’s implicitly universally quantified.</p> <p>You construct values of types <code>T1, MonadT, Swizzle</code> by applying the constructor to suitable values, just as usual. For example,</p> <pre data-language="haskell">a1 :: T Int
a1 = T1 (\xy-&gt;x) 3

a2, a3 :: Swizzle
a2 = MkSwizzle sort
a3 = MkSwizzle reverse

a4 :: MonadT Maybe
a4 = let r x = Just x
     b m k = case m of
           Just y -&gt; k y
           Nothing -&gt; Nothing
     in
     MkMonad r b

mkTs :: (forall b. b -&gt; b -&gt; b) -&gt; a -&gt; [T a]
mkTs f x y = [T1 f x, T1 f y]
</pre> <p>The type of the argument can, as usual, be more general than the type required, as <code>(MkSwizzle reverse)</code> shows. (<code>reverse</code> does not need the <code>Ord</code> constraint.)</p> <p>When you use pattern matching, the bound variables may now have polymorphic types. For example:</p> <pre data-language="haskell">f :: T a -&gt; a -&gt; (a, Char)
f (T1 w k) x = (w k x, w 'c' 'd')

g :: (Ord a, Ord b) =&gt; Swizzle -&gt; [a] -&gt; (a -&gt; b) -&gt; [b]
g (MkSwizzle s) xs f = s (map f (s xs))

h :: MonadT m -&gt; [m a] -&gt; m [a]
h m [] = return m []
h m (x:xs) = bind m x          $ \y -&gt;
             bind m (h m xs)   $ \ys -&gt;
             return m (y:ys)
</pre> <p>In the function <code>h</code> we use the record selectors <code>return</code> and <code>bind</code> to extract the polymorphic bind and return functions from the <code>MonadT</code> data structure, rather than using pattern matching.</p>   <h2 id="higher-rank-type-inference">11.21.2. Type inference</h2> <p id="type-inference">In general, type inference for arbitrary-rank types is undecidable. GHC uses an algorithm proposed by Odersky and Laufer (“Putting type annotations to work”, POPL‘96) to get a decidable algorithm by requiring some help from the programmer. We do not yet have a formal specification of “some help” but the rule is this:</p>  For a lambda-bound or case-bound variable, x, either the programmer provides an explicit polymorphic type for x, or GHC’s type inference will assume that x’s type has no foralls in it. <p>What does it mean to “provide” an explicit type for x? You can do that by giving a type signature for x directly, using a pattern type signature (<a class="reference internal" href="#scoped-type-variables"><span class="std std-ref">Lexically scoped type variables</span></a>), thus:</p> <pre data-language="haskell">\ f :: (forall a. a-&gt;a) -&gt; (f True, f 'c')
</pre> <p>Alternatively, you can give a type signature to the enclosing context, which GHC can “push down” to find the type for the variable:</p> <pre data-language="haskell">(\ f -&gt; (f True, f 'c')) :: (forall a. a-&gt;a) -&gt; (Bool,Char)
</pre> <p>Here the type signature on the expression can be pushed inwards to give a type signature for f. Similarly, and more commonly, one can give a type signature for the function itself:</p> <pre data-language="haskell">h :: (forall a. a-&gt;a) -&gt; (Bool,Char)
h f = (f True, f 'c')
</pre> <p>You don’t need to give a type signature if the lambda bound variable is a constructor argument. Here is an example we saw earlier:</p> <pre data-language="haskell">f :: T a -&gt; a -&gt; (a, Char)
f (T1 w k) x = (w k x, w 'c' 'd')
</pre> <p>Here we do not need to give a type signature to <code>w</code>, because it is an argument of constructor <code>T1</code> and that tells GHC all it needs to know.</p>   <h2 id="id62">11.21.3. Implicit quantification</h2> <p id="implicit-quantification">GHC performs implicit quantification as follows. At the outermost level (only) of user-written types, if and only if there is no explicit <code>forall</code>, GHC finds all the type variables mentioned in the type that are not already in scope, and universally quantifies them. For example, the following pairs are equivalent:</p> <pre data-language="haskell">f :: a -&gt; a
f :: forall a. a -&gt; a

g (x::a) = let
              h :: a -&gt; b -&gt; b
              h x y = y
           in ...
g (x::a) = let
              h :: forall b. a -&gt; b -&gt; b
              h x y = y
           in ...
</pre> <p>Notice that GHC always adds implicit quantifiers <em>at the outermost level</em> of a user-written type; it does <em>not</em> find the inner-most possible quantification point. For example:</p> <pre data-language="haskell">f :: (a -&gt; a) -&gt; Int
         -- MEANS
f :: forall a. (a -&gt; a) -&gt; Int
         -- NOT
f :: (forall a. a -&gt; a) -&gt; Int


g :: (Ord a =&gt; a -&gt; a) -&gt; Int
         -- MEANS
g :: forall a. (Ord a =&gt; a -&gt; a) -&gt; Int
         -- NOT
g :: (forall a. Ord a =&gt; a -&gt; a) -&gt; Int
</pre> <p>If you want the latter type, you can write your <code>forall</code>s explicitly. Indeed, doing so is strongly advised for rank-2 types.</p> <p>Sometimes there <em>is</em> no “outermost level”, in which case no implicit quantification happens:</p> <pre data-language="haskell">data PackMap a b s t = PackMap (Monad f =&gt; (a -&gt; f b) -&gt; s -&gt; f t)
</pre> <p>This is rejected because there is no “outermost level” for the types on the RHS (it would obviously be terrible to add extra parameters to <code>PackMap</code>), so no implicit quantification happens, and the declaration is rejected (with “<code>f</code> is out of scope”). Solution: use an explicit <code>forall</code>:</p> <pre data-language="haskell">data PackMap a b s t = PackMap (forall f. Monad f =&gt; (a -&gt; f b) -&gt; s -&gt; f t)
</pre>    <h1 id="id63">11.22. Impredicative polymorphism</h1> <dl class="extension" id="impredicative-polymorphism"> <dt id="extension-ImpredicativeTypes">
<code>ImpredicativeTypes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-RankNTypes"><code>RankNTypes</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.10.1</td> </tr>  </table> <p>Allow impredicative polymorphic types.</p> </dd>
</dl> <p>In general, GHC will only instantiate a polymorphic function at a monomorphic type (one with no foralls). For example,</p> <pre data-language="haskell">runST :: (forall s. ST s a) -&gt; a
id :: forall b. b -&gt; b

foo = id runST   -- Rejected
</pre> <p>The definition of <code>foo</code> is rejected because one would have to instantiate <code>id</code>‘s type with <code>b := (forall s. ST s a) -&gt; a</code>, and that is not allowed. Instantiating polymorphic type variables with polymorphic types is called <em>impredicative polymorphism</em>.</p> <p>GHC has extremely flaky support for <em>impredicative polymorphism</em>, enabled with <a class="reference internal" href="#extension-ImpredicativeTypes"><code>ImpredicativeTypes</code></a>. If it worked, this would mean that you <em>could</em> call a polymorphic function at a polymorphic type, and parameterise data structures over polymorphic types. For example:</p> <pre data-language="haskell">f :: Maybe (forall a. [a] -&gt; [a]) -&gt; Maybe ([Int], [Char])
f (Just g) = Just (g [3], g "hello")
f Nothing  = Nothing
</pre> <p>Notice here that the <code>Maybe</code> type is parameterised by the <em>polymorphic</em> type <code>(forall a. [a] -&gt; [a])</code>. However <em>the extension should be considered highly experimental, and certainly un-supported</em>. You are welcome to try it, but please don’t rely on it working consistently, or working the same in subsequent releases. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/ImpredicativePolymorphism">this wiki page</a> for more details.</p> <p>If you want impredicative polymorphism, the main workaround is to use a newtype wrapper. The <code>id runST</code> example can be written using this workaround like this:</p> <pre data-language="haskell">runST :: (forall s. ST s a) -&gt; a
id :: forall b. b -&gt; b

newtype Wrap a = Wrap { unWrap :: (forall s. ST s a) -&gt; a }

foo :: (forall s. ST s a) -&gt; a
foo = unWrap (id (Wrap runST))
      -- Here id is called at monomorphic type (Wrap a)
</pre>   <h1 id="id64">11.23. Typed Holes</h1> <p id="typed-holes">Typed holes are a feature of GHC that allows special placeholders written with a leading underscore (e.g., “<code>_</code>”, “<code>_foo</code>”, “<code>_bar</code>”), to be used as expressions. During compilation these holes will generate an error message that describes which type is expected at the hole’s location, information about the origin of any free type variables, and a list of local bindings that might help fill the hole and bindings in scope that fit the type of the hole that might help fill the hole with actual code. Typed holes are always enabled in GHC.</p> <p>The goal of typed holes is to help with writing Haskell code rather than to change the type system. Typed holes can be used to obtain extra information from the type checker, which might otherwise be hard to get. Normally, using GHCi, users can inspect the (inferred) type signatures of all top-level bindings. However, this method is less convenient with terms that are not defined on top-level or inside complex expressions. Holes allow the user to check the type of the term they are about to write.</p> <p>For example, compiling the following module with GHC:</p> <pre data-language="haskell">f :: a -&gt; a
f x = _
</pre> <p>will fail with the following error:</p> <pre data-language="haskell">hole.hs:2:7:
    Found hole `_' with type: a
    Where: `a' is a rigid type variable bound by
               the type signature for f :: a -&gt; a at hole.hs:1:6
    In the expression: _
    In an equation for `f': f x = _
    Relevant bindings include
      x :: a (bound at hole.hs:2:3)
      f :: a -&gt; a (bound at hole.hs:2:1)
    Valid hole fits include x :: a (bound at hole.hs:2:3)
</pre> <p>Here are some more details:</p> <ul> <li>
<p class="first">A “<code>Found hole</code>” error usually terminates compilation, like any other type error. After all, you have omitted some code from your program. Nevertheless, you can run and test a piece of code containing holes, by using the <a class="reference internal" href="using-warnings#ghc-flag--fdefer-typed-holes"><code>-fdefer-typed-holes</code></a> flag. This flag defers errors produced by typed holes until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by <a class="reference internal" href="using-warnings#ghc-flag--Wtyped-holes"><code>-Wno-typed-holes</code></a>.</p> <p>The same behaviour for “<code>Variable out of scope</code>” errors, it terminates compilation by default. You can defer such errors by using the <a class="reference internal" href="using-warnings#ghc-flag--fdefer-out-of-scope-variables"><code>-fdefer-out-of-scope-variables</code></a> flag. This flag defers errors produced by out of scope variables until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by <a class="reference internal" href="using-warnings#ghc-flag--Wdeferred-out-of-scope-variables"><code>-Wno-deferred-out-of-scope-variables</code></a>.</p> <p>The result is that a hole or a variable will behave like <code>undefined</code>, but with the added benefits that it shows a warning at compile time, and will show the same message if it gets evaluated at runtime. This behaviour follows that of the <a class="reference internal" href="using-warnings#ghc-flag--fdefer-type-errors"><code>-fdefer-type-errors</code></a> option, which implies <a class="reference internal" href="using-warnings#ghc-flag--fdefer-typed-holes"><code>-fdefer-typed-holes</code></a> and <a class="reference internal" href="using-warnings#ghc-flag--fdefer-out-of-scope-variables"><code>-fdefer-out-of-scope-variables</code></a>. See <a class="reference internal" href="#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a>.</p> </li> <li>
<p class="first">All unbound identifiers are treated as typed holes, <em>whether or not they start with an underscore</em>. The only difference is in the error message:</p> <pre data-language="haskell">cons z = z : True : _x : y
</pre> <p>yields the errors</p> <pre data-language="none">Foo.hs:3:21: error:
   Found hole: _x :: Bool
   Or perhaps ‘_x’ is mis-spelled, or not in scope
   In the first argument of ‘(:)’, namely ‘_x’
   In the second argument of ‘(:)’, namely ‘_x : y’
   In the second argument of ‘(:)’, namely ‘True : _x : y’
   Relevant bindings include
     z :: Bool (bound at Foo.hs:3:6)
   cons :: Bool -&gt; [Bool] (bound at Foo.hs:3:1)
   Valid hole fits include
     z :: Bool (bound at mpt.hs:2:6)
     otherwise :: Bool
       (imported from ‘Prelude’ at mpt.hs:1:8-10
       (and originally defined in ‘GHC.Base’))
     False :: Bool
       (imported from ‘Prelude’ at mpt.hs:1:8-10
       (and originally defined in ‘GHC.Types’))
     True :: Bool
       (imported from ‘Prelude’ at mpt.hs:1:8-10
       (and originally defined in ‘GHC.Types’))
     maxBound :: forall a. Bounded a =&gt; a
       with maxBound @Bool
       (imported from ‘Prelude’ at mpt.hs:1:8-10
       (and originally defined in ‘GHC.Enum’))
     minBound :: forall a. Bounded a =&gt; a
       with minBound @Bool
       (imported from ‘Prelude’ at mpt.hs:1:8-10
       (and originally defined in ‘GHC.Enum’))

Foo.hs:3:26: error:
    Variable not in scope: y :: [Bool]
</pre> <p>More information is given for explicit holes (i.e. ones that start with an underscore), than for out-of-scope variables, because the latter are often unintended typos, so the extra information is distracting. If you want the detailed information, use a leading underscore to make explicit your intent to use a hole.</p> </li> <li>
<p class="first">Unbound identifiers with the same name are never unified, even within the same function, but shown individually. For example:</p> <pre data-language="haskell">cons = _x : _x
</pre> <p>results in the following errors:</p> <pre data-language="none">unbound.hs:1:8:
    Found hole '_x' with type: a
    Where: `a' is a rigid type variable bound by
               the inferred type of cons :: [a] at unbound.hs:1:1
    In the first argument of `(:)', namely `_x'
    In the expression: _x : _x
    In an equation for `cons': cons = _x : _x
    Relevant bindings include cons :: [a] (bound at unbound.hs:1:1)

unbound.hs:1:13:
    Found hole: _x :: [a]
    Where: ‘a’ is a rigid type variable bound by
            the inferred type of cons :: [a]
            at unbound.hs:3:1-12
    Or perhaps ‘_x’ is mis-spelled, or not in scope
    In the second argument of ‘(:)’, namely ‘_x’
    In the expression: _x : _x
    In an equation for ‘cons’: cons = _x : _x
    Relevant bindings include cons :: [a] (bound at unbound.hs:3:1)
    Valid hole fits include
      cons :: forall a. [a]
        with cons @a
        (defined at mpt.hs:3:1)
      mempty :: forall a. Monoid a =&gt; a
        with mempty @[a]
        (imported from ‘Prelude’ at mpt.hs:1:8-10
        (and originally defined in ‘GHC.Base’))
</pre> <p>Notice the two different types reported for the two different occurrences of <code>_x</code>.</p> </li> <li>
<p class="first">No language extension is required to use typed holes. The lexeme “<code>_</code>” was previously illegal in Haskell, but now has a more informative error message. The lexeme “<code>_x</code>” is a perfectly legal variable, and its behaviour is unchanged when it is in scope. For example</p> <pre data-language="haskell">f _x = _x + 1
</pre> <p>does not elict any errors. Only a variable <em>that is not in scope</em> (whether or not it starts with an underscore) is treated as an error (which it always was), albeit now with a more informative error message.</p> </li> <li>Unbound data constructors used in expressions behave exactly as above. However, unbound data constructors used in <em>patterns</em> cannot be deferred, and instead bring compilation to a halt. (In implementation terms, they are reported by the renamer rather than the type checker.) </li> <li>
<p class="first">The list of valid hole fits is found by checking which bindings in scope would fit into the hole. As an example, compiling the following module with GHC:</p> <pre data-language="haskell">import Data.List (inits)

g :: [String]
g = _ "hello, world"
</pre> <p>yields the errors:</p> <pre data-language="none">• Found hole: _ :: [Char] -&gt; [String]
• In the expression: _
  In the expression: _ "hello, world"
  In an equation for ‘g’: g = _ "hello, world"
• Relevant bindings include g :: [String] (bound at mpt.hs:6:1)
  Valid hole fits include
    lines :: String -&gt; [String]
      (imported from ‘Prelude’ at mpt.hs:3:8-9
       (and originally defined in ‘base-4.11.0.0:Data.OldList’))
    words :: String -&gt; [String]
      (imported from ‘Prelude’ at mpt.hs:3:8-9
       (and originally defined in ‘base-4.11.0.0:Data.OldList’))
    inits :: forall a. [a] -&gt; [[a]]
      with inits @Char
      (imported from ‘Data.List’ at mpt.hs:4:19-23
       (and originally defined in ‘base-4.11.0.0:Data.OldList’))
    repeat :: forall a. a -&gt; [a]
      with repeat @String
      (imported from ‘Prelude’ at mpt.hs:3:8-9
       (and originally defined in ‘GHC.List’))
    fail :: forall (m :: * -&gt; *). Monad m =&gt; forall a. String -&gt; m a
      with fail @[] @String
      (imported from ‘Prelude’ at mpt.hs:3:8-9
       (and originally defined in ‘GHC.Base’))
    return :: forall (m :: * -&gt; *). Monad m =&gt; forall a. a -&gt; m a
      with return @[] @String
      (imported from ‘Prelude’ at mpt.hs:3:8-9
       (and originally defined in ‘GHC.Base’))
    pure :: forall (f :: * -&gt; *). Applicative f =&gt; forall a. a -&gt; f a
      with pure @[] @String
      (imported from ‘Prelude’ at mpt.hs:3:8-9
       (and originally defined in ‘GHC.Base’))
    read :: forall a. Read a =&gt; String -&gt; a
      with read @[String]
      (imported from ‘Prelude’ at mpt.hs:3:8-9
       (and originally defined in ‘Text.Read’))
    mempty :: forall a. Monoid a =&gt; a
      with mempty @([Char] -&gt; [String])
      (imported from ‘Prelude’ at mpt.hs:3:8-9
       (and originally defined in ‘GHC.Base’))
</pre> </li> </ul> <p>There are a few flags for controlling the amount of context information shown for typed holes:</p> <dl class="ghc-flag"> <dt id="ghc-flag--fshow-hole-constraints">
<code>-fshow-hole-constraints</code> </dt> <dd>
<p>When reporting typed holes, also print constraints that are in scope. Example:</p> <pre data-language="haskell">f :: Eq a =&gt; a -&gt; Bool
f x = _
</pre> <p>results in the following message:</p> <pre data-language="none">show_constraints.hs:4:7: error:
    • Found hole: _ :: Bool
    • In the expression: _
      In an equation for ‘f’: f x = _
    • Relevant bindings include
        x :: a (bound at show_constraints.hs:4:3)
        f :: a -&gt; Bool (bound at show_constraints.hs:4:1)
      Constraints include Eq a (from show_constraints.hs:3:1-22)
      Valid hole fits include
        otherwise :: Bool
        False :: Bool
        True :: Bool
        maxBound :: forall a. Bounded a =&gt; a
          with maxBound @Bool
        minBound :: forall a. Bounded a =&gt; a
          with minBound @Bool
</pre> </dd>
</dl>  <h2 id="typed-hole-valid-hole-fits">11.23.1. Valid Hole Fits</h2> <p id="valid-hole-fits">GHC sometimes suggests valid hole fits for typed holes, which is configurable by a few flags.</p> <dl class="ghc-flag"> <dt id="ghc-flag--fno-show-valid-hole-fits">
<code>-fno-show-valid-hole-fits</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>This flag can be toggled to turn off the display of valid hole fits entirely.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fmax-valid-hole-fits=⟨n⟩">
<code>-fmax-valid-hole-fits=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">6</td> </tr>  </table> <p>The list of valid hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with <code>-fno-max-valid-hole-fits</code> displays all found hole fits.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fshow-type-of-hole-fits">
<code>-fshow-type-of-hole-fits</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>By default, the hole fits show the type of the hole fit. This can be turned off by the reverse of this flag.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fshow-type-app-of-hole-fits">
<code>-fshow-type-app-of-hole-fits</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>By default, the hole fits show the type application needed to make this hole fit fit the type of the hole, e.g. for the hole <code>(_ :: Int -&gt; [Int])</code>, <code>mempty</code> is a hole fit with <code>mempty @(Int -&gt; [Int])</code>. This can be toggled off with the reverse of this flag.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fshow-docs-of-hole-fits">
<code>-fshow-docs-of-hole-fits</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>It can sometime be the case that the name and type of a valid hole fit is not enough to realize what the fit stands for. This flag adds the documentation of the fit to the message, if the documentation is available (and the module from which the function comes was compiled with the <code>-haddock</code> flag).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fshow-type-app-vars-of-hole-fits">
<code>-fshow-type-app-vars-of-hole-fits</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>By default, the hole fits show the type application needed to make this hole fit fit the type of the hole, e.g. for the hole <code>(_ :: Int -&gt; [Int])</code>, <code>mempty :: Monoid a =&gt; a</code> is a hole fit with <code>mempty @(Int -&gt; [Int])</code>. This flag toggles whether to show <code>a ~ (Int -&gt; [Int])</code> instead of <code>mempty @(Int -&gt; [Int])</code> in the where clause of the valid hole fit message.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fshow-provenance-of-hole-fits">
<code>-fshow-provenance-of-hole-fits</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>By default, each hole fit shows the provenance information of its hole fit, i.e. where it was bound or defined, and what module it was originally defined in if it was imported. This can be toggled off using the reverse of this flag.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--funclutter-valid-hole-fits">
<code>-funclutter-valid-hole-fits</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>This flag can be toggled to decrease the verbosity of the valid hole fit suggestions by not showing the provenance nor type application of the suggestions.</p> </dd>
</dl>  <h3 id="typed-holes-refinement-hole-fits">11.23.1.1. Refinement Hole Fits</h3> <p id="refinement-hole-fits">When the flag <a class="reference internal" href="#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9"><code>-frefinement-level-hole-fits=⟨n⟩</code></a> is set to an <code>n</code> larger than <code>0</code>, GHC will offer up a list of valid refinement hole fits, which are valid hole fits that need up to <code>n</code> levels of additional refinement to be complete, where each level represents an additional hole in the hole fit that requires filling in. As an example, consider the hole in</p> <pre data-language="haskell">f :: [Integer] -&gt; Integer
f = _
</pre> <p>When the refinement level is not set, it will only offer valid hole fits suggestions:</p> <pre data-language="haskell">Valid hole fits include
  f :: [Integer] -&gt; Integer
  head :: forall a. [a] -&gt; a
    with head @Integer
  last :: forall a. [a] -&gt; a
    with last @Integer
  maximum :: forall (t :: * -&gt; *).
              Foldable t =&gt;
              forall a. Ord a =&gt; t a -&gt; a
    with maximum @[] @Integer
  minimum :: forall (t :: * -&gt; *).
              Foldable t =&gt;
              forall a. Ord a =&gt; t a -&gt; a
    with minimum @[] @Integer
  product :: forall (t :: * -&gt; *).
              Foldable t =&gt;
              forall a. Num a =&gt; t a -&gt; a
    with product @[] @Integer
  sum :: forall (t :: * -&gt; *).
          Foldable t =&gt;
          forall a. Num a =&gt; t a -&gt; a
    with sum @[] @Integer
</pre> <p>However, with <a class="reference internal" href="#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9"><code>-frefinement-level-hole-fits=⟨n⟩</code></a> set to e.g. <code>1</code>, it will additionally offer up a list of refinement hole fits, in this case:</p> <pre data-language="haskell">Valid refinement hole fits include
  foldl1 (_ :: Integer -&gt; Integer -&gt; Integer)
    with foldl1 @[] @Integer
    where foldl1 :: forall (t :: * -&gt; *).
                    Foldable t =&gt;
                    forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a
  foldr1 (_ :: Integer -&gt; Integer -&gt; Integer)
    with foldr1 @[] @Integer
    where foldr1 :: forall (t :: * -&gt; *).
                    Foldable t =&gt;
                    forall a. (a -&gt; a -&gt; a) -&gt; t a -&gt; a
  const (_ :: Integer)
    with const @Integer @[Integer]
    where const :: forall a b. a -&gt; b -&gt; a
  ($) (_ :: [Integer] -&gt; Integer)
    with ($) @'GHC.Types.LiftedRep @[Integer] @Integer
    where ($) :: forall a b. (a -&gt; b) -&gt; a -&gt; b
  fail (_ :: String)
    with fail @((-&gt;) [Integer]) @Integer
    where fail :: forall (m :: * -&gt; *).
                  Monad m =&gt;
                  forall a. String -&gt; m a
  return (_ :: Integer)
    with return @((-&gt;) [Integer]) @Integer
    where return :: forall (m :: * -&gt; *). Monad m =&gt; forall a. a -&gt; m a
  (Some refinement hole fits suppressed;
    use -fmax-refinement-hole-fits=N or -fno-max-refinement-hole-fits)
</pre> <p>Which shows that the hole could be replaced with e.g. <code>foldl1 _</code>. While not fixing the hole, this can help users understand what options they have.</p> <dl class="ghc-flag"> <dt id="ghc-flag--frefinement-level-hole-fits=⟨n⟩">
<code>-frefinement-level-hole-fits=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>The list of valid refinement hole fits is generated by considering hole fits with a varying amount of additional holes. The amount of holes in a refinement can be set by this flag. If the flag is set to 0 or not set at all, no valid refinement hole fits will be suggested.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fabstract-refinement-hole-fits">
<code>-fabstract-refinement-hole-fits</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>Valid list of valid refinement hole fits can often grow large when the refinement level is <code>&gt;= 2</code>, with holes like <code>head _ _</code> or <code>fst _ _</code>, which are valid refinements, but which are unlikely to be relevant since one or more of the holes are still completely open, in that neither the type nor kind of those holes are constrained by the proposed identifier at all. By default, such holes are not reported. By turning this flag on, such holes are included in the list of valid refinement hole fits.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fmax-refinement-hole-fits=⟨n⟩">
<code>-fmax-refinement-hole-fits=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">6</td> </tr>  </table> <p>The list of valid refinement hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with <code>-fno-max-refinement-hole-fits</code> displays all found hole fits.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fshow-hole-matches-of-hole-fits">
<code>-fshow-hole-matches-of-hole-fits</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>The types of the additional holes in refinement hole fits are displayed in the output, e.g. <code>foldl1 (_ :: a -&gt; a -&gt; a)</code> is a refinement for the hole <code>_ :: [a] -&gt; a</code>. If this flag is toggled off, the output will display only <code>foldl1 _</code>, which can be used as a direct replacement for the hole, without requiring <code>-XScopedTypeVariables</code>.</p> </dd>
</dl>   <h3 id="sorting-valid-hole-fits">11.23.1.2. Sorting Valid Hole Fits</h3> <p>There are currently two ways to sort valid hole fits. Sorting can be toggled with <code>-fsort-valid-hole-fits</code></p> <dl class="ghc-flag"> <dt id="ghc-flag--fno-sort-valid-hole-fits">
<code>-fno-sort-valid-hole-fits</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>By default the valid hole fits are sorted to show the most relevant hole fits at the top of the list of valid hole fits. This can be toggled off with this flag.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fsort-by-size-hole-fits">
<code>-fsort-by-size-hole-fits</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Sorts by how big the types the quantified type variables in the type of the function would have to be in order to match the type of the hole.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fsort-by-subsumption-hole-fits">
<code>-fsort-by-subsumption-hole-fits</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>An alternative sort. Sorts by checking which hole fits subsume other hole fits, such that if hole fit a could be used as hole fits for hole fit b, then b appears before a in the output. It is more precise than the default sort, but also a lot slower, since a subsumption check has to be run for each pair of valid hole fits.</p> </dd>
</dl>     <h1 id="id65">11.24. Partial Type Signatures</h1> <dl class="extension" id="partial-type-signatures"> <dt id="extension-PartialTypeSignatures">
<code>PartialTypeSignatures</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10.1</td> </tr>  </table> <p>Type checker will allow inferred types for holes.</p> </dd>
</dl> <p>A partial type signature is a type signature containing special placeholders written with a leading underscore (e.g., “<code>_</code>”, “<code>_foo</code>”, “<code>_bar</code>”) called <em>wildcards</em>. Partial type signatures are to type signatures what <a class="reference internal" href="#typed-holes"><span class="std std-ref">Typed Holes</span></a> are to expressions. During compilation these wildcards or holes will generate an error message that describes which type was inferred at the hole’s location, and information about the origin of any free type variables. GHC reports such error messages by default.</p> <p>Unlike <a class="reference internal" href="#typed-holes"><span class="std std-ref">Typed Holes</span></a>, which make the program incomplete and will generate errors when they are evaluated, this needn’t be the case for holes in type signatures. The type checker is capable (in most cases) of type-checking a binding with or without a type signature. A partial type signature bridges the gap between the two extremes, the programmer can choose which parts of a type to annotate and which to leave over to the type-checker to infer.</p> <p>By default, the type-checker will report an error message for each hole in a partial type signature, informing the programmer of the inferred type. When the <a class="reference internal" href="#extension-PartialTypeSignatures"><code>PartialTypeSignatures</code></a> extension is enabled, the type-checker will accept the inferred type for each hole, generating warnings instead of errors. Additionally, these warnings can be silenced with the <a class="reference internal" href="using-warnings#ghc-flag--Wpartial-type-signatures"><code>-Wno-partial-type-signatures</code></a> flag.</p> <p>However, because GHC must <em>infer</em> the type when part of a type is left out, it is unable to use polymorphic recursion. The same restriction takes place when the type signature is omitted completely.</p>  <h2 id="pts-syntax">11.24.1. Syntax</h2> <p id="syntax">A (partial) type signature has the following form: <code>forall a b .. . (C1, C2, ..) =&gt; tau</code>. It consists of three parts:</p> <ul class="simple"> <li>The type variables: <code>a b ..</code>
</li> <li>The constraints: <code>(C1, C2, ..)</code>
</li> <li>The (mono)type: <code>tau</code>
</li> </ul> <p>We distinguish three kinds of wildcards.</p>  <h3 id="id66">11.24.1.1. Type Wildcards</h3> <p id="type-wildcards">Wildcards occurring within the monotype (tau) part of the type signature are <em>type wildcards</em> (“type” is often omitted as this is the default kind of wildcard). Type wildcards can be instantiated to any monotype like <code>Bool</code> or <code>Maybe [Bool]</code>, including functions and higher-kinded types like <code>(Int -&gt; Bool)</code> or <code>Maybe</code>.</p> <pre data-language="haskell">not' :: Bool -&gt; _
not' x = not x
-- Inferred: Bool -&gt; Bool

maybools :: _
maybools = Just [True]
-- Inferred: Maybe [Bool]

just1 :: _ Int
just1 = Just 1
-- Inferred: Maybe Int

filterInt :: _ -&gt; _ -&gt; [Int]
filterInt = filter -- has type forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
-- Inferred: (Int -&gt; Bool) -&gt; [Int] -&gt; [Int]
</pre> <p>For instance, the first wildcard in the type signature <code>not'</code> would produce the following error message:</p> <pre data-language="none">Test.hs:4:17: error:
    • Found type wildcard ‘_’ standing for ‘Bool’
      To use the inferred type, enable PartialTypeSignatures
    • In the type signature:
        not' :: Bool -&gt; _
    • Relevant bindings include
        not' :: Bool -&gt; Bool (bound at Test.hs:5:1)
</pre> <p>When a wildcard is not instantiated to a monotype, it will be generalised over, i.e. replaced by a fresh type variable, e.g.</p> <pre data-language="haskell">foo :: _ -&gt; _
foo x = x
-- Inferred: forall t. t -&gt; t

filter' :: _
filter' = filter -- has type forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
-- Inferred: (a -&gt; Bool) -&gt; [a] -&gt; [a]
</pre>   <h3 id="id67">11.24.1.2. Named Wildcards</h3> <dl class="extension" id="named-wildcards"> <dt id="extension-NamedWildCards">
<code>NamedWildCards</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10.1</td> </tr>  </table> <p>Allow naming of wildcards (e.g. <code>_x</code>) in type signatures.</p> </dd>
</dl> <p>Type wildcards can also be named by giving the underscore an identifier as suffix, i.e. <code>_a</code>. These are called <em>named wildcards</em>. All occurrences of the same named wildcard within one type signature will unify to the same type. For example:</p> <pre data-language="haskell">f :: _x -&gt; _x
f ('c', y) = ('d', error "Urk")
-- Inferred: forall t. (Char, t) -&gt; (Char, t)
</pre> <p>The named wildcard forces the argument and result types to be the same. Lacking a signature, GHC would have inferred <code>forall a b. (Char, a) -&gt; (Char, b)</code>. A named wildcard can be mentioned in constraints, provided it also occurs in the monotype part of the type signature to make sure that it unifies with something:</p> <pre data-language="haskell">somethingShowable :: Show _x =&gt; _x -&gt; _
somethingShowable x = show x
-- Inferred type: Show a =&gt; a -&gt; String

somethingShowable' :: Show _x =&gt; _x -&gt; _
somethingShowable' x = show (not x)
-- Inferred type: Bool -&gt; String
</pre> <p>Besides an extra-constraints wildcard (see <a class="reference internal" href="#extra-constraints-wildcard"><span class="std std-ref">Extra-Constraints Wildcard</span></a>), only named wildcards can occur in the constraints, e.g. the <code>_x</code> in <code>Show _x</code>.</p> <p>Named wildcards <em>should not be confused with type variables</em>. Even though syntactically similar, named wildcards can unify with monotypes as well as be generalised over (and behave as type variables).</p> <p>In the first example above, <code>_x</code> is generalised over (and is effectively replaced by a fresh type variable <code>a</code>). In the second example, <code>_x</code> is unified with the <code>Bool</code> type, and as <code>Bool</code> implements the <code>Show</code> type class, the constraint <code>Show Bool</code> can be simplified away.</p> <p>By default, GHC (as the Haskell 2010 standard prescribes) parses identifiers starting with an underscore in a type as type variables. To treat them as named wildcards, the <a class="reference internal" href="#extension-NamedWildCards"><code>NamedWildCards</code></a> extension should be enabled. The example below demonstrated the effect.</p> <pre data-language="haskell">foo :: _a -&gt; _a
foo _ = False
</pre> <p>Compiling this program without enabling <a class="reference internal" href="#extension-NamedWildCards"><code>NamedWildCards</code></a> produces the following error message complaining about the type variable <code>_a</code> no matching the actual type <code>Bool</code>.</p> <pre data-language="none">Test.hs:5:9: error:
    • Couldn't match expected type ‘_a’ with actual type ‘Bool’
      ‘_a’ is a rigid type variable bound by
        the type signature for:
          foo :: forall _a. _a -&gt; _a
        at Test.hs:4:8
    • In the expression: False
      In an equation for ‘foo’: foo _ = False
    • Relevant bindings include foo :: _a -&gt; _a (bound at Test.hs:5:1)
</pre> <p>Compiling this program with <a class="reference internal" href="#extension-NamedWildCards"><code>NamedWildCards</code></a> (as well as <a class="reference internal" href="#extension-PartialTypeSignatures"><code>PartialTypeSignatures</code></a>) enabled produces the following error message reporting the inferred type of the named wildcard <code>_a</code>.</p> <pre data-language="none">Test.hs:4:8: warning: [-Wpartial-type-signatures]
    • Found type wildcard ‘_a’ standing for ‘Bool’
    • In the type signature:
        foo :: _a -&gt; _a
    • Relevant bindings include
        foo :: Bool -&gt; Bool (bound at Test.hs:5:1)
</pre>   <h3 id="id68">11.24.1.3. Extra-Constraints Wildcard</h3> <p id="extra-constraints-wildcard">The third kind of wildcard is the <em>extra-constraints wildcard</em>. The presence of an extra-constraints wildcard indicates that an arbitrary number of extra constraints may be inferred during type checking and will be added to the type signature. In the example below, the extra-constraints wildcard is used to infer three extra constraints.</p> <pre data-language="haskell">arbitCs :: _ =&gt; a -&gt; String
arbitCs x = show (succ x) ++ show (x == x)
-- Inferred:
--   forall a. (Enum a, Eq a, Show a) =&gt; a -&gt; String
-- Error:
Test.hs:5:12: error:
    Found constraint wildcard ‘_’ standing for ‘(Show a, Eq a, Enum a)’
    To use the inferred type, enable PartialTypeSignatures
    In the type signature:
      arbitCs :: _ =&gt; a -&gt; String
</pre> <p>An extra-constraints wildcard shouldn’t prevent the programmer from already listing the constraints he knows or wants to annotate, e.g.</p> <pre data-language="haskell">-- Also a correct partial type signature:
arbitCs' :: (Enum a, _) =&gt; a -&gt; String
arbitCs' x = arbitCs x
-- Inferred:
--   forall a. (Enum a, Show a, Eq a) =&gt; a -&gt; String
-- Error:
Test.hs:9:22: error:
    Found constraint wildcard ‘_’ standing for ‘()’
    To use the inferred type, enable PartialTypeSignatures
    In the type signature:
      arbitCs' :: (Enum a, _) =&gt; a -&gt; String
</pre> <p>An extra-constraints wildcard can also lead to zero extra constraints to be inferred, e.g.</p> <pre data-language="haskell">noCs :: _ =&gt; String
noCs = "noCs"
-- Inferred: String
-- Error:
Test.hs:13:9: error:
    Found constraint wildcard ‘_’ standing for ‘()’
    To use the inferred type, enable PartialTypeSignatures
    In the type signature:
      noCs :: _ =&gt; String
</pre> <p>As a single extra-constraints wildcard is enough to infer any number of constraints, only one is allowed in a type signature and it should come last in the list of constraints.</p> <p>Extra-constraints wildcards cannot be named.</p>    <h2 id="pts-where">11.24.2. Where can they occur?</h2> <p id="where-can-they-occur">Partial type signatures are allowed for bindings, pattern and expression signatures, except that extra-constraints wildcards are not supported in pattern or expression signatures. In the following example a wildcard is used in each of the three possible contexts.</p> <pre data-language="haskell">{-# LANGUAGE ScopedTypeVariables #-}
foo :: _
foo (x :: _) = (x :: _)
-- Inferred: forall w_. w_ -&gt; w_
</pre> <p>Anonymous and named wildcards <em>can</em> occur on the left hand side of a type or data instance declaration; see <a class="reference internal" href="#type-wildcards-lhs"><span class="std std-ref">Wildcards on the LHS of data and type family instances</span></a>.</p> <p>Anonymous wildcards are also allowed in visible type applications/ visible kind applications (<a class="reference internal" href="#visible-type-application"><span class="std std-ref">Visible type application</span></a>). If you want to specify only the second type argument to <code>wurble</code>, then you can say <code>wurble @_ @Int</code> where the first argument is a wildcard.</p> <p>Standalone <code>deriving</code> declarations permit the use of a single, extra-constraints wildcard, like so:</p> <pre data-language="haskell">deriving instance _ =&gt; Eq (Foo a)
</pre> <p>This denotes a derived <code>Eq (Foo a)</code> instance where the context is inferred, in much the same way that ordinary <code>deriving</code> clauses do. Any other use of wildcards in a standalone <code>deriving</code> declaration is prohibited.</p> <p>In all other contexts, type wildcards are disallowed, and a named wildcard is treated as an ordinary type variable. For example:</p> <pre data-language="haskell">class C _ where ...          -- Illegal
instance Eq (T _)            -- Illegal (currently; would actually make sense)
instance Eq _a =&gt; Eq (T _a)  -- Perfectly fine, same as  Eq a =&gt; Eq (T a)
</pre> <p>Partial type signatures can also be used in <a class="reference internal" href="#template-haskell"><span class="std std-ref">Template Haskell</span></a> splices.</p> <ul> <li>
<p class="first">Declaration splices: partial type signature are fully supported.</p> <pre data-language="haskell">{-# LANGUAGE TemplateHaskell, NamedWildCards #-}
$( [d| foo :: _ =&gt; _a -&gt; _a -&gt; _
       foo x y = x == y|] )
</pre> </li> <li>
<p class="first">Expression splices: anonymous and named wildcards can be used in expression signatures. Extra-constraints wildcards are not supported, just like in regular expression signatures.</p> <pre data-language="haskell">{-# LANGUAGE TemplateHaskell, NamedWildCards #-}
$( [e| foo = (Just True :: _m _) |] )
</pre> </li> <li>Typed expression splices: the same wildcards as in (untyped) expression splices are supported. </li> <li>
<p class="first">Pattern splices: anonymous and named wildcards can be used in pattern signatures. Note that <a class="reference internal" href="#extension-ScopedTypeVariables"><code>ScopedTypeVariables</code></a> has to be enabled to allow pattern signatures. Extra-constraints wildcards are not supported, just like in regular pattern signatures.</p> <pre data-language="haskell">{-# LANGUAGE TemplateHaskell, ScopedTypeVariables #-}
foo $( [p| (x :: _) |] ) = x
</pre> </li> <li>
<p class="first">Type splices: only anonymous wildcards are supported in type splices. Named and extra-constraints wildcards are not.</p> <pre data-language="haskell">{-# LANGUAGE TemplateHaskell #-}
foo :: $( [t| _ |] ) -&gt; a
foo x = x
</pre> </li> </ul>    <h1 id="custom-errors">11.25. Custom compile-time errors</h1> <p id="custom-compile-time-errors">When designing embedded domain specific languages in Haskell, it is useful to have something like <code>error</code> at the type level. In this way, the EDSL designer may show a type error that is specific to the DSL, rather than the standard GHC type error.</p> <p>For example, consider a type class that is not intended to be used with functions, but the user accidentally used it at a function type, perhaps because they missed an argument to some function. Then, instead of getting the standard GHC message about a missing instance, it would be nicer to emit a more friendly message specific to the EDSL. Similarly, the reduction of a type-level function may get stuck due to an error, at which point it would be nice to report an EDSL specific error, rather than a generic error about an ambiguous type.</p> <p>To solve this, GHC provides a single type-level function,</p> <pre data-language="haskell">type family TypeError (msg :: ErrorMessage) :: k
</pre> <p>along with a small type-level language (via <a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a>) for constructing pretty-printed error messages,</p> <pre data-language="haskell">-- ErrorMessage is intended to be used as a kind
data ErrorMessage =
      Text Symbol                        -- Show this text as is
    | forall t. ShowType t               -- Pretty print a type
    | ErrorMessage :&lt;&gt;: ErrorMessage     -- Put two chunks of error message next to each other
    | ErrorMessage :$$: ErrorMessage     -- Put two chunks of error message above each other
</pre> <p>in the <a class="reference external" href="../libraries/base-4.13.0.0/ghc-typelits">GHC.TypeLits</a> module.</p> <p>For instance, we might use this interface to provide a more useful error message for applications of <code>show</code> on unsaturated functions like this,</p> <pre data-language="haskell">{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}

import GHC.TypeLits

instance TypeError (Text "Cannot 'Show' functions." :$$:
                    Text "Perhaps there is a missing argument?")
         =&gt; Show (a -&gt; b) where
   showsPrec = error "unreachable"

main = print negate
</pre> <p>Which will produce the following compile-time error,</p> <pre data-language="none">Test.hs:12:8: error:
    • Cannot 'Show' functions.
      Perhaps there is a missing argument?
    • In the expression: print negate
      In an equation for ‘main’: main = print negate
</pre>   <h1 id="defer-type-errors">11.26. Deferring type errors to runtime</h1> <p id="deferring-type-errors-to-runtime">While developing, sometimes it is desirable to allow compilation to succeed even if there are type errors in the code. Consider the following case:</p> <pre data-language="haskell">module Main where

a :: Int
a = 'a'

main = print "b"
</pre> <p>Even though <code>a</code> is ill-typed, it is not used in the end, so if all that we’re interested in is <code>main</code> it can be useful to be able to ignore the problems in <code>a</code>.</p> <p>For more motivation and details please refer to the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime">Wiki</a> page or the <a class="reference external" href="http://dreixel.net/research/pdf/epdtecp.pdf">original paper</a>.</p>  <h2 id="enabling-deferring-of-type-errors">11.26.1. Enabling deferring of type errors</h2> <p>The flag <a class="reference internal" href="using-warnings#ghc-flag--fdefer-type-errors"><code>-fdefer-type-errors</code></a> controls whether type errors are deferred to runtime. Type errors will still be emitted as warnings, but will not prevent compilation. You can use <code>-Wno-type-errors</code> to suppress these warnings.</p> <p>This flag implies the <a class="reference internal" href="using-warnings#ghc-flag--fdefer-typed-holes"><code>-fdefer-typed-holes</code></a> and <a class="reference internal" href="using-warnings#ghc-flag--fdefer-out-of-scope-variables"><code>-fdefer-out-of-scope-variables</code></a> flags, which enables this behaviour for <a class="reference external" href="#typed-holes">typed holes</a> and variables. Should you so wish, it is possible to enable <a class="reference internal" href="using-warnings#ghc-flag--fdefer-type-errors"><code>-fdefer-type-errors</code></a> without enabling <a class="reference internal" href="using-warnings#ghc-flag--fdefer-typed-holes"><code>-fdefer-typed-holes</code></a> or <a class="reference internal" href="using-warnings#ghc-flag--fdefer-out-of-scope-variables"><code>-fdefer-out-of-scope-variables</code></a>, by explicitly specifying <a class="reference internal" href="using-warnings#ghc-flag--fdefer-typed-holes"><code>-fno-defer-typed-holes</code></a> or <a class="reference internal" href="using-warnings#ghc-flag--fdefer-out-of-scope-variables"><code>-fno-defer-out-of-scope-variables</code></a> on the command-line after the <a class="reference internal" href="using-warnings#ghc-flag--fdefer-type-errors"><code>-fdefer-type-errors</code></a> flag.</p> <p>At runtime, whenever a term containing a type error would need to be evaluated, the error is converted into a runtime exception of type <code>TypeError</code>. Note that type errors are deferred as much as possible during runtime, but invalid coercions are never performed, even when they would ultimately result in a value of the correct type. For example, given the following code:</p> <pre data-language="haskell">x :: Int
x = 0

y :: Char
y = x

z :: Int
z = y
</pre> <p>evaluating <code>z</code> will result in a runtime <code>TypeError</code>.</p>   <h2 id="deferred-type-errors-in-ghci">11.26.2. Deferred type errors in GHCi</h2> <p>The flag <a class="reference internal" href="using-warnings#ghc-flag--fdefer-type-errors"><code>-fdefer-type-errors</code></a> works in GHCi as well, with one exception: for “naked” expressions typed at the prompt, type errors don’t get delayed, so for example:</p> <pre data-language="haskell">Prelude&gt; fst (True, 1 == 'a')

&lt;interactive&gt;:2:12:
    No instance for (Num Char) arising from the literal `1'
    Possible fix: add an instance declaration for (Num Char)
    In the first argument of `(==)', namely `1'
    In the expression: 1 == 'a'
    In the first argument of `fst', namely `(True, 1 == 'a')'
</pre> <p>Otherwise, in the common case of a simple type error such as typing <code>reverse True</code> at the prompt, you would get a warning and then an immediately-following type error when the expression is evaluated.</p> <p>This exception doesn’t apply to statements, as the following example demonstrates:</p> <pre data-language="none">Prelude&gt; let x = (True, 1 == 'a')

&lt;interactive&gt;:3:16: Warning:
    No instance for (Num Char) arising from the literal `1'
    Possible fix: add an instance declaration for (Num Char)
    In the first argument of `(==)', namely `1'
    In the expression: 1 == 'a'
    In the expression: (True, 1 == 'a')
Prelude&gt; fst x
True
</pre>   <h2 id="limitations-of-deferred-type-errors">11.26.3. Limitations of deferred type errors</h2> <p>The errors that can be deferred are:</p> <ul class="simple"> <li>Out of scope term variables</li> <li>Equality constraints; e.g. <code>ord True</code> gives rise to an insoluble equality constraint <code>Char ~ Bool</code>, which can be deferred.</li> <li>Type-class and implicit-parameter constraints</li> </ul> <p>All other type errors are reported immediately, and cannot be deferred; for example, an ill-kinded type signature, an instance declaration that is non-terminating or ill-formed, a type-family instance that does not obey the declared injectivity constraints, etc etc.</p> <p>In a few cases, even equality constraints cannot be deferred. Specifically:</p> <ul> <li>
<p class="first">Kind-equalities cannot be deferred, e.g.</p> <pre data-language="haskell">f :: Int Bool -&gt; Char
</pre> <p>This type signature contains a kind error which cannot be deferred.</p> </li> <li>Type equalities under a forall cannot be deferred (c.f. Trac #14605). </li> </ul>    <h1 id="id69">11.27. Template Haskell</h1> <p id="template-haskell">Template Haskell allows you to do compile-time meta-programming in Haskell. The background to the main technical innovations is discussed in “<a class="reference external" href="http://research.microsoft.com/~simonpj/papers/meta-haskell/">Template Meta-programming for Haskell</a>” (Proc Haskell Workshop 2002).</p> <p>The <a class="reference external" href="http://www.haskell.org/haskellwiki/Template_Haskell">Template Haskell</a> page on the GHC Wiki has a wealth of information. You may also consult the <a class="reference external" href="#">Haddock reference documentation &lt;Language.Haskell.TH.&gt;</a>. Many changes to the original design are described in <a class="reference external" href="https://www.haskell.org/ghc/docs/papers/th2.ps">Notes on Template Haskell version 2</a>. Not all of these changes are in GHC, however.</p> <p>The first example from that paper is set out below (<a class="reference internal" href="#th-example"><span class="std std-ref">A Template Haskell Worked Example</span></a>) as a worked example to help get you started.</p> <p>The documentation here describes the realisation of Template Haskell in GHC. It is not detailed enough to understand Template Haskell; see the <a class="reference external" href="http://haskell.org/haskellwiki/Template_Haskell">Wiki page</a>.</p>  <h2 id="id70">11.27.1. Syntax</h2> <dl class="extension" id="th-syntax"> <dt id="extension-TemplateHaskell">
<code>TemplateHaskell</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-TemplateHaskellQuotes"><code>TemplateHaskellQuotes</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.0. Typed splices introduced in GHC 7.8.1.</td> </tr>  </table> <p>Enable Template Haskell’s splice and quotation syntax.</p> </dd>
</dl> <dl class="extension"> <dt id="extension-TemplateHaskellQuotes">
<code>TemplateHaskellQuotes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Enable only Template Haskell’s quotation syntax.</p> </dd>
</dl> <p>Template Haskell has the following new syntactic constructions. You need to use the extension <a class="reference internal" href="#extension-TemplateHaskell"><code>TemplateHaskell</code></a> to switch these syntactic extensions on. Alternatively, the <a class="reference internal" href="#extension-TemplateHaskellQuotes"><code>TemplateHaskellQuotes</code></a> extension can be used to enable the quotation subset of Template Haskell (i.e. without splice syntax). The <a class="reference internal" href="#extension-TemplateHaskellQuotes"><code>TemplateHaskellQuotes</code></a> extension is considered safe under <a class="reference internal" href="safe_haskell#safe-haskell"><span class="std std-ref">Safe Haskell</span></a> while <a class="reference internal" href="#extension-TemplateHaskell"><code>TemplateHaskell</code></a> is not.</p> <ul> <li>
<p class="first">A splice is written <code>$x</code>, where <code>x</code> is an identifier, or <code>$(...)</code>, where the ”...” is an arbitrary expression. There must be no space between the “$” and the identifier or parenthesis. This use of “$” overrides its meaning as an infix operator, just as “M.x” overrides the meaning of ”.” as an infix operator. If you want the infix operator, put spaces around it.</p> <p>A splice can occur in place of</p> <ul class="simple"> <li>an expression; the spliced expression must have type <code>Q Exp</code>
</li> <li>a pattern; the spliced pattern must have type <code>Q Pat</code>
</li> <li>a type; the spliced expression must have type <code>Q Type</code>
</li> <li>a list of declarations at top level; the spliced expression must have type <code>Q [Dec]</code>
</li> </ul> <p>Inside a splice you can only call functions defined in imported modules, not functions defined elsewhere in the same module. Note that declaration splices are not allowed anywhere except at top level (outside any other declarations).</p> </li> <li>
<p class="first">A expression quotation is written in Oxford brackets, thus:</p> <ul class="simple"> <li>
<code>[| ... |]</code>, or <code>[e| ... |]</code>, where the ”...” is an expression; the quotation has type <code>Q Exp</code>.</li> <li>
<code>[d| ... |]</code>, where the ”...” is a list of top-level declarations; the quotation has type <code>Q [Dec]</code>.</li> <li>
<code>[t| ... |]</code>, where the ”...” is a type; the quotation has type <code>Q Type</code>.</li> <li>
<code>[p| ... |]</code>, where the ”...” is a pattern; the quotation has type <code>Q Pat</code>.</li> </ul> <p>See <a class="reference internal" href="#pts-where"><span class="std std-ref">Where can they occur?</span></a> for using partial type signatures in quotations.</p> </li> <li>
<p class="first">A <em>typed</em> expression splice is written <code>$$x</code>, where <code>x</code> is an identifier, or <code>$$(...)</code>, where the ”...” is an arbitrary expression.</p> <p>A typed expression splice can occur in place of an expression; the spliced expression must have type <code>Q (TExp a)</code></p> </li> <li>
<p class="first">A <em>typed</em> expression quotation is written as <code>[|| ... ||]</code>, or <code>[e|| ... ||]</code>, where the ”...” is an expression; if the ”...” expression has type <code>a</code>, then the quotation has type <code>Q (TExp a)</code>.</p> <p>Values of type <code>TExp a</code> may be converted to values of type <code>Exp</code> using the function <code>unType :: TExp a -&gt; Exp</code>.</p> </li> <li>
<p class="first">A quasi-quotation can appear in a pattern, type, expression, or declaration context and is also written in Oxford brackets:</p> <ul class="simple"> <li>
<code>[varid| ... |]</code>, where the ”...” is an arbitrary string; a full description of the quasi-quotation facility is given in <a class="reference internal" href="#th-quasiquotation"><span class="std std-ref">Template Haskell Quasi-quotation</span></a>.</li> </ul> </li> <li>
<p class="first">A name can be quoted with either one or two prefix single quotes:</p> <ul> <li>
<p class="first"><code>'f</code> has type <code>Name</code>, and names the function <code>f</code>. Similarly <code>'C</code> has type <code>Name</code> and names the data constructor <code>C</code>. In general <code>'</code>⟨thing⟩ interprets ⟨thing⟩ in an expression context.</p> <p>A name whose second character is a single quote (sadly) cannot be quoted in this way, because it will be parsed instead as a quoted character. For example, if the function is called <code>f'7</code> (which is a legal Haskell identifier), an attempt to quote it as <code>'f'7</code> would be parsed as the character literal <code>'f'</code> followed by the numeric literal <code>7</code>. There is no current escape mechanism in this (unusual) situation.</p> </li> <li>
<code>''T</code> has type <code>Name</code>, and names the type constructor <code>T</code>. That is, <code>''</code>⟨thing⟩ interprets ⟨thing⟩ in a type context. </li> </ul> <p>These <code>Names</code> can be used to construct Template Haskell expressions, patterns, declarations etc. They may also be given as an argument to the <code>reify</code> function.</p> </li> <li>
<p class="first">It is possible for a splice to expand to an expression that contain names which are not in scope at the site of the splice. As an example, consider the following code:</p> <pre data-language="haskell">module Bar where

import Language.Haskell.TH

add1 :: Int -&gt; Q Exp
add1 x = [| x + 1 |]
</pre> <p>Now consider a splice using <code>add1</code> in a separate module:</p> <pre data-language="haskell">module Foo where

import Bar

two :: Int
two = $(add1 1)
</pre> <p>Template Haskell cannot know what the argument to <code>add1</code> will be at the function’s definition site, so a lifting mechanism is used to promote <code>x</code> into a value of type <code>Q Exp</code>. This functionality is exposed to the user as the <code>Lift</code> typeclass in the <code>Language.Haskell.TH.Syntax</code> module. If a type has a <code>Lift</code> instance, then any of its values can be lifted to a Template Haskell expression:</p> <pre data-language="haskell">class Lift t where
    lift :: t -&gt; Q Exp
</pre> <p>In general, if GHC sees an expression within Oxford brackets (e.g., <code>[|
foo bar |]</code>, then GHC looks up each name within the brackets. If a name is global (e.g., suppose <code>foo</code> comes from an import or a top-level declaration), then the fully qualified name is used directly in the quotation. If the name is local (e.g., suppose <code>bar</code> is bound locally in the function definition <code>mkFoo bar = [| foo bar |]</code>), then GHC uses <code>lift</code> on it (so GHC pretends <code>[| foo bar |]</code> actually contains <code>[|
foo $(lift bar) |]</code>). Local names, which are not in scope at splice locations, are actually evaluated when the quotation is processed.</p> <p>The <code>template-haskell</code> library provides <code>Lift</code> instances for many common data types. Furthermore, it is possible to derive <code>Lift</code> instances automatically by using the <a class="reference internal" href="#extension-DeriveLift"><code>DeriveLift</code></a> language extension. See <a class="reference internal" href="#deriving-lift"><span class="std std-ref">Deriving Lift instances</span></a> for more information.</p> </li> <li>
<p class="first">You may omit the <code>$(...)</code> in a top-level declaration splice. Simply writing an expression (rather than a declaration) implies a splice. For example, you can write</p> <pre data-language="haskell">module Foo where
import Bar

f x = x

$(deriveStuff 'f)   -- Uses the $(...) notation

g y = y+1

deriveStuff 'g      -- Omits the $(...)

h z = z-1
</pre> <p>This abbreviation makes top-level declaration slices quieter and less intimidating.</p> </li> <li>
<p class="first">Pattern splices introduce variable binders but scoping of variables in expressions inside the pattern’s scope is only checked when a splice is run. Note that pattern splices that occur outside of any quotation brackets are run at compile time. Pattern splices occurring inside a quotation bracket are <em>not</em> run at compile time; they are run when the bracket is spliced in, sometime later. For example,</p> <pre data-language="haskell">mkPat :: Q Pat
mkPat = [p| (x, y) |]

-- in another module:
foo :: (Char, String) -&gt; String
foo $(mkPat) = x : z

bar :: Q Exp
bar = [| \ $(mkPat) -&gt; x : w |]
</pre> <p>will fail with <code>z</code> being out of scope in the definition of <code>foo</code> but it will <em>not</em> fail with <code>w</code> being out of scope in the definition of <code>bar</code>. That will only happen when <code>bar</code> is spliced.</p> </li> <li>
<p class="first">A pattern quasiquoter <em>may</em> generate binders that scope over the right-hand side of a definition because these binders are in scope lexically. For example, given a quasiquoter <code>haskell</code> that parses Haskell, in the following code, the <code>y</code> in the right-hand side of <code>f</code> refers to the <code>y</code> bound by the <code>haskell</code> pattern quasiquoter, <em>not</em> the top-level <code>y = 7</code>.</p> <pre data-language="haskell">y :: Int
y = 7

f :: Int -&gt; Int -&gt; Int
f n = \ [haskell|y|] -&gt; y+n
</pre> </li> <li>
<p class="first">Top-level declaration splices break up a source file into <em>declaration groups</em>. A <em>declaration group</em> is the group of declarations created by a top-level declaration splice, plus those following it, down to but not including the next top-level declaration splice. N.B. only top-level splices delimit declaration groups, not expression splices. The first declaration group in a module includes all top-level definitions down to but not including the first top-level declaration splice.</p> <p>Each declaration group is mutually recursive only within the group. Declaration groups can refer to definitions within previous groups, but not later ones.</p> <p>Accordingly, the type environment seen by <code>reify</code> includes all the top-level declarations up to the end of the immediately preceding declaration group, but no more.</p> <p>Unlike normal declaration splices, declaration quasiquoters do not cause a break. These quasiquoters are expanded before the rest of the declaration group is processed, and the declarations they generate are merged into the surrounding declaration group. Consequently, the type environment seen by <code>reify</code> from a declaration quasiquoter will not include anything from the quasiquoter’s declaration group.</p> <p>Concretely, consider the following code</p> <pre data-language="haskell">module M where

import ...

f x = x

$(th1 4)

h y = k y y $(blah1)

[qq|blah|]

k x y z = x + y + z

$(th2 10)

w z = $(blah2)
</pre> <p>In this example, a <code>reify</code> inside...</p> <ol class="arabic simple"> <li>The splice <code>$(th1 ...)</code> would see the definition of <code>f</code> - the splice is top-level and thus all definitions in the previous declaration group are visible (that is, all definitions in the module up-to, but not including, the splice itself).</li> <li>The splice <code>$(blah1)</code> cannot refer to the function <code>w</code> - <code>w</code> is part of a later declaration group, and thus invisible, similarly, <code>$(blah1)</code> cannot see the definition of <code>h</code> (since it is part of the same declaration group as <code>$(blah1)</code>. However, the splice <code>$(blah1)</code> can see the definition of <code>f</code> (since it is in the immediately preceding declaration group).</li> <li>The splice <code>$(th2 ...)</code> would see the definition of <code>f</code>, all the bindings created by <code>$(th1 ...)</code>, the definition of <code>h</code> and all bindings created by <code>[qq|blah|]</code> (they are all in previous declaration groups).</li> <li>The body of <code>h</code> <em>can</em> refer to the function <code>k</code> appearing on the other side of the declaration quasiquoter, as quasiquoters do not cause a declaration group to be broken up.</li> <li>The <code>qq</code> quasiquoter would be able to see the definition of <code>f</code> from the preceding declaration group, but not the definitions of <code>h</code> or <code>k</code>, or any definitions from subsequent declaration groups.</li> <li>The splice <code>$(blah2)</code> would see the same definitions as the splice <code>$(th2 ...)</code> (but <em>not</em> any bindings it creates).</li> </ol> <p>Note that since an expression splice is unable to refer to declarations in the same declaration group, we can introduce a top-level (empty) splice to break up the declaration group</p> <pre data-language="haskell">module M where

data D = C1 | C2

f1 = $(th1 ...)

$(return [])

f2 = $(th2 ...)
</pre> <p>Here</p> <ol class="arabic simple"> <li>The splice <code>$(th1 ...)</code> <em>cannot</em> refer to <code>D</code> - it is in the same declaration group.</li> <li>The declaration group containing <code>D</code> is terminated by the empty top-level declaration splice <code>$(return [])</code> (recall, <code>Q</code> is a Monad, so we may simply <code>return</code> the empty list of declarations).</li> <li>Since the declaration group containing <code>D</code> is in the previous declaration group, the splice <code>$(th2 ...)</code> <em>can</em> refer to <code>D</code>.</li> </ol> </li> <li>
<p class="first">Expression quotations accept most Haskell language constructs. However, there are some GHC-specific extensions which expression quotations currently do not support, including</p> <ul class="simple"> <li>Recursive <code>do</code>-statements (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/1262">Issue #1262</a>)</li> <li>Type holes in typed splices (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10945">Issue #10945</a> and <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10946">Issue #10946</a>)</li> </ul> </li> </ul> <p>(Compared to the original paper, there are many differences of detail. The syntax for a declaration splice uses “<code>$</code>” not “<code>splice</code>”. The type of the enclosed expression must be <code>Q [Dec]</code>, not <code>[Q Dec]</code>. Typed expression splices and quotations are supported.)</p>   <h2 id="th-usage">11.27.2. Using Template Haskell</h2> <ul id="using-template-haskell"> <li>The data types and monadic constructor functions for Template Haskell are in the library <code>Language.Haskell.TH.Syntax</code>. </li> <li>You can only run a function at compile time if it is imported from another module. That is, you can’t define a function in a module, and call it from within a splice in the same module. (It would make sense to do so, but it’s hard to implement.) </li> <li>
<p class="first">You can only run a function at compile time if it is imported from another module <em>that is not part of a mutually-recursive group of modules that includes the module currently being compiled</em>. Furthermore, all of the modules of the mutually-recursive group must be reachable by non-SOURCE imports from the module where the splice is to be run.</p> <p>For example, when compiling module A, you can only run Template Haskell functions imported from B if B does not import A (directly or indirectly). The reason should be clear: to run B we must compile and run A, but we are currently type-checking A.</p> </li> <li>If you are building GHC from source, you need at least a stage-2 bootstrap compiler to run Template Haskell splices and quasi-quotes. A stage-1 compiler will only accept regular quotes of Haskell. Reason: TH splices and quasi-quotes compile and run a program, and then looks at the result. So it’s important that the program it compiles produces results whose representations are identical to those of the compiler itself. </li> </ul> <p>Template Haskell works in any mode (<a class="reference internal" href="using#ghc-flag---make"><code>--make</code></a>, <a class="reference internal" href="using#ghc-flag---interactive"><code>--interactive</code></a>, or file-at-a-time). There used to be a restriction to the former two, but that restriction has been lifted.</p>   <h2 id="th-view-gen-code">11.27.3. Viewing Template Haskell generated code</h2> <p id="viewing-template-haskell-generated-code">The flag <a class="reference internal" href="debugging#ghc-flag--ddump-splices"><code>-ddump-splices</code></a> shows the expansion of all top-level declaration splices, both typed and untyped, as they happen. As with all dump flags, the default is for this output to be sent to stdout. For a non-trivial program, you may be interested in combining this with the <a class="reference internal" href="debugging#ghc-flag--ddump-to-file"><code>-ddump-to-file</code></a> flag (see <a class="reference internal" href="debugging#dumping-output"><span class="std std-ref">Dumping out compiler intermediate structures</span></a>. For each file using Template Haskell, this will show the output in a <code>.dump-splices</code> file.</p> <p>The flag <a class="reference internal" href="debugging#ghc-flag--dth-dec-file"><code>-dth-dec-file</code></a> dumps the expansions of all top-level TH declaration splices, both typed and untyped, in the file <code>M.th.hs</code> for each module <code>M</code> being compiled. Note that other types of splices (expressions, types, and patterns) are not shown. Application developers can check this into their repository so that they can grep for identifiers that were defined in Template Haskell. This is similar to using <a class="reference internal" href="debugging#ghc-flag--ddump-to-file"><code>-ddump-to-file</code></a> with <a class="reference internal" href="debugging#ghc-flag--ddump-splices"><code>-ddump-splices</code></a> but it always generates a file instead of being coupled to <a class="reference internal" href="debugging#ghc-flag--ddump-to-file"><code>-ddump-to-file</code></a>. The format is also different: it does not show code from the original file, instead it only shows generated code and has a comment for the splice location of the original file.</p> <p>Below is a sample output of <a class="reference internal" href="debugging#ghc-flag--ddump-splices"><code>-ddump-splices</code></a></p> <pre data-language="haskell">TH_pragma.hs:(6,4)-(8,26): Splicing declarations
  [d| foo :: Int -&gt; Int
      foo x = x + 1 |]
======&gt;
  foo :: Int -&gt; Int
  foo x = (x + 1)
</pre> <p>Below is the output of the same sample using <a class="reference internal" href="debugging#ghc-flag--dth-dec-file"><code>-dth-dec-file</code></a></p> <pre data-language="haskell">-- TH_pragma.hs:(6,4)-(8,26): Splicing declarations
foo :: Int -&gt; Int
foo x = (x + 1)
</pre>   <h2 id="th-example">11.27.4. A Template Haskell Worked Example</h2> <p id="a-template-haskell-worked-example">To help you get over the confidence barrier, try out this skeletal worked example. First cut and paste the two modules below into <code>Main.hs</code> and <code>Printf.hs</code>:</p> <pre data-language="haskell">{- Main.hs -}
module Main where

-- Import our template "pr"
import Printf ( pr )

-- The splice operator $ takes the Haskell source code
-- generated at compile time by "pr" and splices it into
-- the argument of "putStrLn".
main = putStrLn ( $(pr "Hello") )


{- Printf.hs -}
module Printf where

-- Skeletal printf from the paper.
-- It needs to be in a separate module to the one where
-- you intend to use it.

-- Import some Template Haskell syntax
import Language.Haskell.TH

-- Describe a format string
data Format = D | S | L String

-- Parse a format string.  This is left largely to you
-- as we are here interested in building our first ever
-- Template Haskell program and not in building printf.
parse :: String -&gt; [Format]
parse s   = [ L s ]

-- Generate Haskell source code from a parsed representation
-- of the format string.  This code will be spliced into
-- the module which calls "pr", at compile time.
gen :: [Format] -&gt; Q Exp
gen [D]   = [| \n -&gt; show n |]
gen [S]   = [| \s -&gt; s |]
gen [L s] = stringE s

-- Here we generate the Haskell code for the splice
-- from an input format string.
pr :: String -&gt; Q Exp
pr s = gen (parse s)
</pre> <p>Now run the compiler,</p> <pre data-language="none">$ ghc --make -XTemplateHaskell main.hs -o main
</pre> <p>Run <code>main</code> and here is your output:</p> <pre data-language="none">$ ./main
Hello
</pre>   <h2 id="th-profiling">11.27.5. Using Template Haskell with Profiling</h2> <p id="using-template-haskell-with-profiling">Template Haskell relies on GHC’s built-in bytecode compiler and interpreter to run the splice expressions. The bytecode interpreter runs the compiled expression on top of the same runtime on which GHC itself is running; this means that the compiled code referred to by the interpreted expression must be compatible with this runtime, and in particular this means that object code that is compiled for profiling <em>cannot</em> be loaded and used by a splice expression, because profiled object code is only compatible with the profiling version of the runtime.</p> <p>This causes difficulties if you have a multi-module program containing Template Haskell code and you need to compile it for profiling, because GHC cannot load the profiled object code and use it when executing the splices.</p> <p>Fortunately GHC provides two workarounds.</p> <p>The first option is to compile the program twice:</p> <ol class="arabic"> <li>Compile the program or library first the normal way, without <a class="reference internal" href="profiling#ghc-flag--prof"><code>-prof</code></a>. </li> <li>Then compile it again with <a class="reference internal" href="profiling#ghc-flag--prof"><code>-prof</code></a>, and additionally use <code>-osuf
p_o</code> to name the object files differently (you can choose any suffix that isn’t the normal object suffix here). GHC will automatically load the object files built in the first step when executing splice expressions. If you omit the <a class="reference internal" href="#"><code>-osuf ⟨suffix⟩</code></a> flag when building with <a class="reference internal" href="profiling#ghc-flag--prof"><code>-prof</code></a> and Template Haskell is used, GHC will emit an error message. </li> </ol> <p id="index-21">The second option is to add the flag <a class="reference internal" href="ghci#ghc-flag--fexternal-interpreter"><code>-fexternal-interpreter</code></a> (see <a class="reference internal" href="ghci#external-interpreter"><span class="std std-ref">Running the interpreter in a separate process</span></a>), which runs the interpreter in a separate process, wherein it can load and run the profiled code directly. There’s no need to compile the code twice, just add <a class="reference internal" href="ghci#ghc-flag--fexternal-interpreter"><code>-fexternal-interpreter</code></a> and it should just work. (this option is experimental in GHC 8.0.x, but it may become the default in future releases).</p>   <h2 id="th-quasiquotation">11.27.6. Template Haskell Quasi-quotation</h2> <dl class="extension" id="template-haskell-quasi-quotation"> <dt id="extension-QuasiQuotes">
<code>QuasiQuotes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.10.1</td> </tr>  </table> <p>Enable Template Haskell Quasi-quotation syntax.</p> </dd>
</dl> <p>Quasi-quotation allows patterns and expressions to be written using programmer-defined concrete syntax; the motivation behind the extension and several examples are documented in “<a class="reference external" href="http://www.cs.tufts.edu/comp/150FP/archive/geoff-mainland/quasiquoting.pdf">Why It’s Nice to be Quoted: Quasiquoting for Haskell</a>” (Proc Haskell Workshop 2007). The example below shows how to write a quasiquoter for a simple expression language.</p> <p>Here are the salient features</p> <ul> <li>
<p class="first">A quasi-quote has the form <code>[quoter| string |]</code>.</p> <ul class="simple"> <li>The ⟨quoter⟩ must be the name of an imported quoter, either qualified or unqualified; it cannot be an arbitrary expression.</li> <li>The ⟨quoter⟩ cannot be “<code>e</code>”, “<code>t</code>”, “<code>d</code>”, or “<code>p</code>”, since those overlap with Template Haskell quotations.</li> <li>There must be no spaces in the token <code>[quoter|</code>.</li> <li>The quoted ⟨string⟩ can be arbitrary, and may contain newlines.</li> <li>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence <code>"|]"</code>. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string <code>"|~]"</code> instead), and make your quoter function interpret <code>"|~]"</code> as <code>"|]"</code>. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/5348">Issue #5348</a> for details.</li> </ul> </li> <li>
<p class="first">A quasiquote may appear in place of</p> <ul class="simple"> <li>An expression</li> <li>A pattern</li> <li>A type</li> <li>A top-level declaration</li> </ul> <p>(Only the first two are described in the paper.)</p> </li> <li>
<p class="first">A quoter is a value of type <code>Language.Haskell.TH.Quote.QuasiQuoter</code>, which is defined thus:</p> <pre data-language="haskell">data QuasiQuoter = QuasiQuoter { quoteExp  :: String -&gt; Q Exp,
                                 quotePat  :: String -&gt; Q Pat,
                                 quoteType :: String -&gt; Q Type,
                                 quoteDec  :: String -&gt; Q [Dec] }
</pre> <p>That is, a quoter is a tuple of four parsers, one for each of the contexts in which a quasi-quote can occur.</p> </li> <li>A quasi-quote is expanded by applying the appropriate parser to the string enclosed by the Oxford brackets. The context of the quasi-quote (expression, pattern, type, declaration) determines which of the parsers is called. </li> <li>Unlike normal declaration splices of the form <code>$(...)</code>, declaration quasi-quotes do not cause a declaration group break. See <a class="reference internal" href="#th-syntax"><span class="std std-ref">Syntax</span></a> for more information. </li> </ul> <div class="admonition warning" id="quasi-quotes-list-comprehension-ambiguity"> <p class="first admonition-title">Warning</p> <p id="index-22"><a class="reference internal" href="#extension-QuasiQuotes"><code>QuasiQuotes</code></a> introduces an unfortunate ambiguity with list comprehension syntax. Consider the following,</p> <pre data-language="haskell">let x = [v| v &lt;- [0..10]]
</pre> <p class="last">Without <a class="reference internal" href="#extension-QuasiQuotes"><code>QuasiQuotes</code></a> this is parsed as a list comprehension. With <a class="reference internal" href="#extension-QuasiQuotes"><code>QuasiQuotes</code></a> this is parsed as a quasi-quote; however, this parse will fail due to the lack of a closing <code>|]</code>. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/11679">Issue #11679</a>.</p> </div> <p>The example below shows quasi-quotation in action. The quoter <code>expr</code> is bound to a value of type <code>QuasiQuoter</code> defined in module <code>Expr</code>. The example makes use of an antiquoted variable <code>n</code>, indicated by the syntax <code>'int:n</code> (this syntax for anti-quotation was defined by the parser’s author, <em>not</em> by GHC). This binds <code>n</code> to the integer value argument of the constructor <code>IntExpr</code> when pattern matching. Please see the referenced paper for further details regarding anti-quotation as well as the description of a technique that uses SYB to leverage a single parser of type <code>String -&gt; a</code> to generate both an expression parser that returns a value of type <code>Q Exp</code> and a pattern parser that returns a value of type <code>Q Pat</code>.</p> <p>Quasiquoters must obey the same stage restrictions as Template Haskell, e.g., in the example, <code>expr</code> cannot be defined in <code>Main.hs</code> where it is used, but must be imported.</p> <pre data-language="haskell">{- ------------- file Main.hs --------------- -}
module Main where

import Expr

main :: IO ()
main = do { print $ eval [expr|1 + 2|]
          ; case IntExpr 1 of
              { [expr|'int:n|] -&gt; print n
              ;  _              -&gt; return ()
              }
          }


{- ------------- file Expr.hs --------------- -}
module Expr where

import qualified Language.Haskell.TH as TH
import Language.Haskell.TH.Quote

data Expr  =  IntExpr Integer
           |  AntiIntExpr String
           |  BinopExpr BinOp Expr Expr
           |  AntiExpr String
    deriving(Show, Typeable, Data)

data BinOp  =  AddOp
            |  SubOp
            |  MulOp
            |  DivOp
    deriving(Show, Typeable, Data)

eval :: Expr -&gt; Integer
eval (IntExpr n)        = n
eval (BinopExpr op x y) = (opToFun op) (eval x) (eval y)
  where
    opToFun AddOp = (+)
    opToFun SubOp = (-)
    opToFun MulOp = (*)
    opToFun DivOp = div

expr = QuasiQuoter { quoteExp = parseExprExp, quotePat =  parseExprPat }

-- Parse an Expr, returning its representation as
-- either a Q Exp or a Q Pat. See the referenced paper
-- for how to use SYB to do this by writing a single
-- parser of type String -&gt; Expr instead of two
-- separate parsers.

parseExprExp :: String -&gt; Q Exp
parseExprExp ...

parseExprPat :: String -&gt; Q Pat
parseExprPat ...
</pre> <p>Now run the compiler:</p> <pre data-language="none">$ ghc --make -XQuasiQuotes Main.hs -o main
</pre> <p>Run “main” and here is your output:</p> <pre data-language="none">$ ./main
3
1
</pre>    <h1 id="id71">11.28. Arrow notation</h1> <dl class="extension" id="arrow-notation"> <dt id="extension-Arrows">
<code>Arrows</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Enable arrow notation.</p> </dd>
</dl> <p>Arrows are a generalisation of monads introduced by John Hughes. For more details, see</p> <ul class="simple"> <li>“Generalising Monads to Arrows”, John Hughes, in Science of Computer Programming 37, pp. 67–111, May 2000. The paper that introduced arrows: a friendly introduction, motivated with programming examples.</li> <li>“<a class="reference external" href="http://www.soi.city.ac.uk/~ross/papers/notation.html">A New Notation for Arrows</a>”, Ross Paterson, in ICFP, Sep 2001. Introduced the notation described here.</li> <li>“<a class="reference external" href="http://www.soi.city.ac.uk/~ross/papers/fop.html">Arrows and Computation</a>”, Ross Paterson, in The Fun of Programming, Palgrave, 2003.</li> <li>“<a class="reference external" href="http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf">Programming with Arrows</a>”, John Hughes, in 5th International Summer School on Advanced Functional Programming, Lecture Notes in Computer Science vol. 3622, Springer, 2004. This paper includes another introduction to the notation, with practical examples.</li> <li>“<a class="reference external" href="http://www.haskell.org/ghc/docs/papers/arrow-rules.pdf">Type and Translation Rules for Arrow Notation in GHC</a>”, Ross Paterson and Simon Peyton Jones, September 16, 2004. A terse enumeration of the formal rules used (extracted from comments in the source code).</li> <li>The arrows web page at <code>http://www.haskell.org/arrows/</code> &lt;<a class="reference external" href="http://www.haskell.org/arrows/">http://www.haskell.org/arrows/</a>&gt;`__.</li> </ul> <p>With the <a class="reference internal" href="#extension-Arrows"><code>Arrows</code></a> extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the <a class="reference external" href="../libraries/base-4.13.0.0/control-arrow">Control.Arrow</a> module. What follows is a brief introduction to the notation; it won’t make much sense unless you’ve read Hughes’s paper.</p> <p>The extension adds a new kind of expression for defining arrows:</p> <pre data-language="none">exp10 ::= ...
       |  proc apat -&gt; cmd
</pre> <p>where <code>proc</code> is a new keyword. The variables of the pattern are bound in the body of the <code>proc</code>-expression, which is a new sort of thing called a command. The syntax of commands is as follows:</p> <pre data-language="none">cmd   ::= exp10 -&lt;  exp
       |  exp10 -&lt;&lt; exp
       |  cmd0
</pre> <p>with ⟨cmd⟩<sup>0</sup> up to ⟨cmd⟩<sup>9</sup> defined using infix operators as for expressions, and</p> <pre data-language="none">cmd10 ::= \ apat ... apat -&gt; cmd
       |  let decls in cmd
       |  if exp then cmd else cmd
       |  case exp of { calts }
       |  do { cstmt ; ... cstmt ; cmd }
       |  fcmd

fcmd  ::= fcmd aexp
       |  ( cmd )
       |  (| aexp cmd ... cmd |)

cstmt ::= let decls
       |  pat &lt;- cmd
       |  rec { cstmt ; ... cstmt [;] }
       |  cmd
</pre> <p>where ⟨calts⟩ are like ⟨alts⟩ except that the bodies are commands instead of expressions.</p> <p>Commands produce values, but (like monadic computations) may yield more than one value, or none, and may do other things as well. For the most part, familiarity with monadic notation is a good guide to using commands. However the values of expressions, even monadic ones, are determined by the values of the variables they contain; this is not necessarily the case for commands.</p> <p>A simple example of the new notation is the expression</p> <pre data-language="haskell">proc x -&gt; f -&lt; x+1
</pre> <p>We call this a procedure or arrow abstraction. As with a lambda expression, the variable <code>x</code> is a new variable bound within the <code>proc</code>-expression. It refers to the input to the arrow. In the above example, <code>-&lt;</code> is not an identifier but a new reserved symbol used for building commands from an expression of arrow type and an expression to be fed as input to that arrow. (The weird look will make more sense later.) It may be read as analogue of application for arrows. The above example is equivalent to the Haskell expression</p> <pre data-language="haskell">arr (\ x -&gt; x+1) &gt;&gt;&gt; f
</pre> <p>That would make no sense if the expression to the left of <code>-&lt;</code> involves the bound variable <code>x</code>. More generally, the expression to the left of <code>-&lt;</code> may not involve any local variable, i.e. a variable bound in the current arrow abstraction. For such a situation there is a variant <code>-&lt;&lt;</code>, as in</p> <pre data-language="haskell">proc x -&gt; f x -&lt;&lt; x+1
</pre> <p>which is equivalent to</p> <pre data-language="haskell">arr (\ x -&gt; (f x, x+1)) &gt;&gt;&gt; app
</pre> <p>so in this case the arrow must belong to the <code>ArrowApply</code> class. Such an arrow is equivalent to a monad, so if you’re using this form you may find a monadic formulation more convenient.</p>  <h2 id="do-notation-for-commands">11.28.1. do-notation for commands</h2> <p>Another form of command is a form of <code>do</code>-notation. For example, you can write</p> <pre data-language="haskell">proc x -&gt; do
        y &lt;- f -&lt; x+1
        g -&lt; 2*y
        let z = x+y
        t &lt;- h -&lt; x*z
        returnA -&lt; t+z
</pre> <p>You can read this much like ordinary <code>do</code>-notation, but with commands in place of monadic expressions. The first line sends the value of <code>x+1</code> as an input to the arrow <code>f</code>, and matches its output against <code>y</code>. In the next line, the output is discarded. The arrow <code>returnA</code> is defined in the <a class="reference external" href="../libraries/base-4.13.0.0/control-arrow">Control.Arrow</a> module as <code>arr id</code>. The above example is treated as an abbreviation for</p> <pre data-language="haskell">arr (\ x -&gt; (x, x)) &gt;&gt;&gt;
        first (arr (\ x -&gt; x+1) &gt;&gt;&gt; f) &gt;&gt;&gt;
        arr (\ (y, x) -&gt; (y, (x, y))) &gt;&gt;&gt;
        first (arr (\ y -&gt; 2*y) &gt;&gt;&gt; g) &gt;&gt;&gt;
        arr snd &gt;&gt;&gt;
        arr (\ (x, y) -&gt; let z = x+y in ((x, z), z)) &gt;&gt;&gt;
        first (arr (\ (x, z) -&gt; x*z) &gt;&gt;&gt; h) &gt;&gt;&gt;
        arr (\ (t, z) -&gt; t+z) &gt;&gt;&gt;
        returnA
</pre> <p>Note that variables not used later in the composition are projected out. After simplification using rewrite rules (see <a class="reference internal" href="#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>) defined in the <a class="reference external" href="../libraries/base-4.13.0.0/control-arrow">Control.Arrow</a> module, this reduces to</p> <pre data-language="haskell">arr (\ x -&gt; (x+1, x)) &gt;&gt;&gt;
        first f &gt;&gt;&gt;
        arr (\ (y, x) -&gt; (2*y, (x, y))) &gt;&gt;&gt;
        first g &gt;&gt;&gt;
        arr (\ (_, (x, y)) -&gt; let z = x+y in (x*z, z)) &gt;&gt;&gt;
        first h &gt;&gt;&gt;
        arr (\ (t, z) -&gt; t+z)
</pre> <p>which is what you might have written by hand. With arrow notation, GHC keeps track of all those tuples of variables for you.</p> <p>Note that although the above translation suggests that <code>let</code>-bound variables like <code>z</code> must be monomorphic, the actual translation produces Core, so polymorphic variables are allowed.</p> <p>It’s also possible to have mutually recursive bindings, using the new <code>rec</code> keyword, as in the following example:</p> <pre data-language="haskell">counter :: ArrowCircuit a =&gt; a Bool Int
counter = proc reset -&gt; do
        rec     output &lt;- returnA -&lt; if reset then 0 else next
                next &lt;- delay 0 -&lt; output+1
        returnA -&lt; output
</pre> <p>The translation of such forms uses the <code>loop</code> combinator, so the arrow concerned must belong to the <code>ArrowLoop</code> class.</p>   <h2 id="conditional-commands">11.28.2. Conditional commands</h2> <p>In the previous example, we used a conditional expression to construct the input for an arrow. Sometimes we want to conditionally execute different commands, as in</p> <pre data-language="haskell">proc (x,y) -&gt;
        if f x y
        then g -&lt; x+1
        else h -&lt; y+2
</pre> <p>which is translated to</p> <pre data-language="haskell">arr (\ (x,y) -&gt; if f x y then Left x else Right y) &gt;&gt;&gt;
        (arr (\x -&gt; x+1) &gt;&gt;&gt; g) ||| (arr (\y -&gt; y+2) &gt;&gt;&gt; h)
</pre> <p>Since the translation uses <code>|||</code>, the arrow concerned must belong to the <code>ArrowChoice</code> class.</p> <p>There are also <code>case</code> commands, like</p> <pre data-language="haskell">case input of
    [] -&gt; f -&lt; ()
    [x] -&gt; g -&lt; x+1
    x1:x2:xs -&gt; do
        y &lt;- h -&lt; (x1, x2)
        ys &lt;- k -&lt; xs
        returnA -&lt; y:ys
</pre> <p>The syntax is the same as for <code>case</code> expressions, except that the bodies of the alternatives are commands rather than expressions. The translation is similar to that of <code>if</code> commands.</p>   <h2 id="defining-your-own-control-structures">11.28.3. Defining your own control structures</h2> <p>As we’re seen, arrow notation provides constructs, modelled on those for expressions, for sequencing, value recursion and conditionals. But suitable combinators, which you can define in ordinary Haskell, may also be used to build new commands out of existing ones. The basic idea is that a command defines an arrow from environments to values. These environments assign values to the free local variables of the command. Thus combinators that produce arrows from arrows may also be used to build commands from commands. For example, the <code>ArrowPlus</code> class includes a combinator</p> <pre data-language="haskell">ArrowPlus a =&gt; (&lt;+&gt;) :: a b c -&gt; a b c -&gt; a b c
</pre> <p>so we can use it to build commands:</p> <pre data-language="haskell">expr' = proc x -&gt; do
                returnA -&lt; x
        &lt;+&gt; do
                symbol Plus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x + y
        &lt;+&gt; do
                symbol Minus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x - y
</pre> <p>(The <code>do</code> on the first line is needed to prevent the first <code>&lt;+&gt; ...</code> from being interpreted as part of the expression on the previous line.) This is equivalent to</p> <pre data-language="haskell">expr' = (proc x -&gt; returnA -&lt; x)
        &lt;+&gt; (proc x -&gt; do
                symbol Plus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x + y)
        &lt;+&gt; (proc x -&gt; do
                symbol Minus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x - y)
</pre> <p>We are actually using <code>&lt;+&gt;</code> here with the more specific type</p> <pre data-language="haskell">ArrowPlus a =&gt; (&lt;+&gt;) :: a (e,()) c -&gt; a (e,()) c -&gt; a (e,()) c
</pre> <p>It is essential that this operator be polymorphic in <code>e</code> (representing the environment input to the command and thence to its subcommands) and satisfy the corresponding naturality property</p> <pre data-language="haskell">arr (first k) &gt;&gt;&gt; (f &lt;+&gt; g) = (arr (first k) &gt;&gt;&gt; f) &lt;+&gt; (arr (first k) &gt;&gt;&gt; g)
</pre> <p>at least for strict <code>k</code>. (This should be automatic if you’re not using <code>seq</code>.) This ensures that environments seen by the subcommands are environments of the whole command, and also allows the translation to safely trim these environments. (The second component of the input pairs can contain unnamed input values, as described in the next section.) The operator must also not use any variable defined within the current arrow abstraction.</p> <p>We could define our own operator</p> <pre data-language="haskell">untilA :: ArrowChoice a =&gt; a (e,s) () -&gt; a (e,s) Bool -&gt; a (e,s) ()
untilA body cond = proc x -&gt; do
        b &lt;- cond -&lt; x
        if b then returnA -&lt; ()
        else do
                body -&lt; x
                untilA body cond -&lt; x
</pre> <p>and use it in the same way. Of course this infix syntax only makes sense for binary operators; there is also a more general syntax involving special brackets:</p> <pre data-language="haskell">proc x -&gt; do
        y &lt;- f -&lt; x+1
        (|untilA (increment -&lt; x+y) (within 0.5 -&lt; x)|)
</pre>   <h2 id="primitive-constructs">11.28.4. Primitive constructs</h2> <p>Some operators will need to pass additional inputs to their subcommands. For example, in an arrow type supporting exceptions, the operator that attaches an exception handler will wish to pass the exception that occurred to the handler. Such an operator might have a type</p> <pre data-language="haskell">handleA :: ... =&gt; a (e,s) c -&gt; a (e,(Ex,s)) c -&gt; a (e,s) c
</pre> <p>where <code>Ex</code> is the type of exceptions handled. You could then use this with arrow notation by writing a command</p> <pre data-language="haskell">body `handleA` \ ex -&gt; handler
</pre> <p>so that if an exception is raised in the command <code>body</code>, the variable <code>ex</code> is bound to the value of the exception and the command <code>handler</code>, which typically refers to <code>ex</code>, is entered. Though the syntax here looks like a functional lambda, we are talking about commands, and something different is going on. The input to the arrow represented by a command consists of values for the free local variables in the command, plus a stack of anonymous values. In all the prior examples, we made no assumptions about this stack. In the second argument to <code>handleA</code>, the value of the exception has been added to the stack input to the handler. The command form of lambda merely gives this value a name.</p> <p>More concretely, the input to a command consists of a pair of an environment and a stack. Each value on the stack is paired with the remainder of the stack, with an empty stack being <code>()</code>. So operators like <code>handleA</code> that pass extra inputs to their subcommands can be designed for use with the notation by placing the values on the stack paired with the environment in this way. More precisely, the type of each argument of the operator (and its result) should have the form</p> <pre data-language="haskell">a (e, (t1, ... (tn, ())...)) t
</pre> <p>where ⟨e⟩ is a polymorphic variable (representing the environment) and ⟨ti⟩ are the types of the values on the stack, with ⟨t1⟩ being the “top”. The polymorphic variable ⟨e⟩ must not occur in ⟨a⟩, ⟨ti⟩ or ⟨t⟩. However the arrows involved need not be the same. Here are some more examples of suitable operators:</p> <pre data-language="haskell">bracketA :: ... =&gt; a (e,s) b -&gt; a (e,(b,s)) c -&gt; a (e,(c,s)) d -&gt; a (e,s) d
runReader :: ... =&gt; a (e,s) c -&gt; a' (e,(State,s)) c
runState :: ... =&gt; a (e,s) c -&gt; a' (e,(State,s)) (c,State)
</pre> <p>We can supply the extra input required by commands built with the last two by applying them to ordinary expressions, as in</p> <pre data-language="haskell">proc x -&gt; do
        s &lt;- ...
        (|runReader (do { ... })|) s
</pre> <p>which adds <code>s</code> to the stack of inputs to the command built using <code>runReader</code>.</p> <p>The command versions of lambda abstraction and application are analogous to the expression versions. In particular, the beta and eta rules describe equivalences of commands. These three features (operators, lambda abstraction and application) are the core of the notation; everything else can be built using them, though the results would be somewhat clumsy. For example, we could simulate <code>do</code>-notation by defining</p> <pre data-language="haskell">bind :: Arrow a =&gt; a (e,s) b -&gt; a (e,(b,s)) c -&gt; a (e,s) c
u `bind` f = returnA &amp;&amp;&amp; u &gt;&gt;&gt; f

bind_ :: Arrow a =&gt; a (e,s) b -&gt; a (e,s) c -&gt; a (e,s) c
u `bind_` f = u `bind` (arr fst &gt;&gt;&gt; f)
</pre> <p>We could simulate <code>if</code> by defining</p> <pre data-language="haskell">cond :: ArrowChoice a =&gt; a (e,s) b -&gt; a (e,s) b -&gt; a (e,(Bool,s)) b
cond f g = arr (\ (e,(b,s)) -&gt; if b then Left (e,s) else Right (e,s)) &gt;&gt;&gt; f ||| g
</pre>   <h2 id="differences-with-the-paper">11.28.5. Differences with the paper</h2> <ul class="simple"> <li>Instead of a single form of arrow application (arrow tail) with two translations, the implementation provides two forms <code>-&lt;</code> (first-order) and <code>-&lt;&lt;</code> (higher-order).</li> <li>User-defined operators are flagged with banana brackets instead of a new <code>form</code> keyword.</li> <li>In the paper and the previous implementation, values on the stack were paired to the right of the environment in a single argument, but now the environment and stack are separate arguments.</li> </ul>   <h2 id="portability">11.28.6. Portability</h2> <p>Although only GHC implements arrow notation directly, there is also a preprocessor (available from the <a class="reference external" href="http://www.haskell.org/arrows/">arrows web page</a>) that translates arrow notation into Haskell 98 for use with other Haskell systems. You would still want to check arrow programs with GHC; tracing type errors in the preprocessor output is not easy. Modules intended for both GHC and the preprocessor must observe some additional restrictions:</p> <ul class="simple"> <li>The module must import <a class="reference external" href="../libraries/base-4.13.0.0/control-arrow">Control.Arrow</a>.</li> <li>The preprocessor cannot cope with other Haskell extensions. These would have to go in separate modules.</li> <li>Because the preprocessor targets Haskell (rather than Core), <code>let</code>-bound variables are monomorphic.</li> </ul>    <h1 id="bang-patterns">11.29. Bang patterns and Strict Haskell</h1> <p id="bang-patterns-and-strict-haskell">In high-performance Haskell code (e.g. numeric code) eliminating thunks from an inner loop can be a huge win. GHC supports three extensions to allow the programmer to specify use of strict (call-by-value) evaluation rather than lazy (call-by-need) evaluation.</p> <ul class="simple"> <li>Bang patterns (<a class="reference internal" href="#extension-BangPatterns"><code>BangPatterns</code></a>) makes pattern matching and let bindings stricter.</li> <li>Strict data types (<a class="reference internal" href="#extension-StrictData"><code>StrictData</code></a>) makes constructor fields strict by default, on a per-module basis.</li> <li>Strict pattern (<a class="reference internal" href="#extension-Strict"><code>Strict</code></a>) makes all patterns and let bindings strict by default, on a per-module basis.</li> </ul> <p>The latter two extensions are simply a way to avoid littering high-performance code with bang patterns, making it harder to read.</p> <p>Bang patterns and strict matching do not affect the type system in any way.</p>  <h2 id="id72">11.29.1. Bang patterns</h2> <dl class="extension" id="bang-patterns-informal"> <dt id="extension-BangPatterns">
<code>BangPatterns</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow use of bang pattern syntax.</p> </dd>
</dl> <p>GHC supports an extension of pattern matching called <em>bang patterns</em>, written <code>!pat</code>. Bang patterns are under consideration for Haskell Prime. The <a class="reference external" href="http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns">Haskell prime feature description</a> contains more discussion and examples than the material below.</p> <p>The main idea is to add a single new production to the syntax of patterns:</p> <pre data-language="haskell">pat ::= !pat
</pre> <p>Matching an expression <code>e</code> against a pattern <code>!p</code> is done by first evaluating <code>e</code> (to WHNF) and then matching the result against <code>p</code>. Example:</p> <pre data-language="haskell">f1 !x = True
</pre> <p>This definition makes <code>f1</code> is strict in <code>x</code>, whereas without the bang it would be lazy. Bang patterns can be nested of course:</p> <pre data-language="haskell">f2 (!x, y) = [x,y]
</pre> <p>Here, <code>f2</code> is strict in <code>x</code> but not in <code>y</code>.</p> <p>Note the following points:</p> <ul> <li>
<p class="first">A bang only really has an effect if it precedes a variable or wild-card pattern:</p> <pre data-language="haskell">f3 !(x,y) = [x,y]
f4 (x,y)  = [x,y]
</pre> <p>Here, <code>f3</code> and <code>f4</code> are identical; putting a bang before a pattern that forces evaluation anyway does nothing.</p> </li> <li>
<p class="first">A bang pattern is allowed in a let or where clause, and makes the binding strict. For example:</p> <pre data-language="haskell">let !x = e in body
let !(p,q) = e in body
</pre> <p>In both cases <code>e</code> is evaluated before starting to evaluate <code>body</code>.</p> <p>However, <em>nested</em> bangs in a let/where pattern binding behave uniformly with all other forms of pattern matching. For example</p> <pre data-language="haskell">let (!x,[y]) = e in b
</pre> <p>is equivalent to this:</p> <pre data-language="haskell">let { t = case e of (x,[y]) -&gt; x `seq` (x,y)
      x = fst t
      y = snd t }
in b
</pre> <p>The binding is lazy, but when either <code>x</code> or <code>y</code> is evaluated by <code>b</code> the entire pattern is matched, including forcing the evaluation of <code>x</code>.</p> <p>See <a class="reference internal" href="#recursive-and-polymorphic-let-bindings"><span class="std std-ref">Semantics of let bindings with bang patterns</span></a> for the detailed semantics.</p> </li> <li>A pattern with a bang at the outermost level is not allowed at the top level of a module. </li> <li>
<p class="first">Bang patterns work in <code>case</code> expressions too, of course:</p> <pre data-language="haskell">g5 x = let y = f x in body
g6 x = case f x of { y -&gt; body }
g7 x = case f x of { !y -&gt; body }
</pre> <p>The functions <code>g5</code> and <code>g6</code> mean exactly the same thing. But <code>g7</code> evaluates <code>(f x)</code>, binds <code>y</code> to the result, and then evaluates <code>body</code>.</p> </li> <li>
<p class="first">There is one problem with syntactic ambiguity. Consider:</p> <pre data-language="haskell">f !x = 3
</pre> <p>Is this a definition of the infix function “<code>(!)</code>”, or of the “<code>f</code>” with a bang pattern? GHC resolves this ambiguity in favour of the latter. If you want to define <code>(!)</code> with bang-patterns enabled, you have to do so using prefix notation:</p> <pre data-language="haskell">(!) f x = 3
</pre> </li> </ul>   <h2 id="strict-data">11.29.2. Strict-by-default data types</h2> <dl class="extension" id="strict-by-default-data-types"> <dt id="extension-StrictData">
<code>StrictData</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Make fields of data types defined in the current module strict by default.</p> </dd>
</dl> <p>Informally the <code>StrictData</code> language extension switches data type declarations to be strict by default allowing fields to be lazy by adding a <code>~</code> in front of the field.</p> <p>When the user writes</p> <pre data-language="haskell">data T = C a
data T' = C' ~a
</pre> <p>we interpret it as if they had written</p> <pre data-language="haskell">data T = C !a
data T' = C' a
</pre> <p>The extension only affects definitions in this module.</p>   <h2 id="strict">11.29.3. Strict-by-default pattern bindings</h2> <dl class="extension" id="strict-by-default-pattern-bindings"> <dt id="extension-Strict">
<code>Strict</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-StrictData"><code>StrictData</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Make bindings in the current module strict by default.</p> </dd>
</dl> <p>Informally the <code>Strict</code> language extension switches functions, data types, and bindings to be strict by default, allowing optional laziness by adding <code>~</code> in front of a variable. This essentially reverses the present situation where laziness is default and strictness can be optionally had by adding <code>!</code> in front of a variable.</p> <p><code>Strict</code> implies <a class="reference internal" href="#strict-data"><span class="std std-ref">StrictData</span></a>.</p> <ul> <li>
<p class="first"><strong>Function definitions</strong></p> <p>When the user writes</p> <pre data-language="haskell">f x = ...
</pre> <p>we interpret it as if they had written</p> <pre data-language="haskell">f !x = ...
</pre> <p>Adding <code>~</code> in front of <code>x</code> gives the regular lazy behavior.</p> <p>Turning patterns into irrefutable ones requires <code>~(~p)</code> or <code>(~ ~p)</code> when <code>Strict</code> is enabled.</p> </li> <li>
<p class="first"><strong>Let/where bindings</strong></p> <p>When the user writes</p> <pre data-language="haskell">let x = ...
let pat = ...
</pre> <p>we interpret it as if they had written</p> <pre data-language="haskell">let !x = ...
let !pat = ...
</pre> <p>Adding <code>~</code> in front of <code>x</code> gives the regular lazy behavior. The general rule is that we add an implicit bang on the outermost pattern, unless disabled with <code>~</code>.</p> </li> <li>
<p class="first"><strong>Pattern matching in case expressions, lambdas, do-notation, etc</strong></p> <p>The outermost pattern of all pattern matches gets an implicit bang, unless disabled with <code>~</code>. This applies to case expressions, patterns in lambda, do-notation, list comprehension, and so on. For example</p> <pre data-language="haskell">case x of (a,b) -&gt; rhs
</pre> <p>is interpreted as</p> <pre data-language="haskell">case x of !(a,b) -&gt; rhs
</pre> <p>Since the semantics of pattern matching in case expressions is strict, this usually has no effect whatsoever. But it does make a difference in the degenerate case of variables and newtypes. So</p> <pre data-language="haskell">case x of y -&gt; rhs
</pre> <p>is lazy in Haskell, but with <code>Strict</code> is interpreted as</p> <pre data-language="haskell">case x of !y -&gt; rhs
</pre> <p>which evaluates <code>x</code>. Similarly, if <code>newtype Age = MkAge Int</code>, then</p> <pre data-language="haskell">case x of MkAge i -&gt; rhs
</pre> <p>is lazy in Haskell; but with <code>Strict</code> the added bang makes it strict.</p> <p>Similarly</p> <pre data-language="haskell">\ x -&gt; body
do { x &lt;- rhs; blah }
[ e | x &lt;- rhs; blah }
</pre> <p>all get implicit bangs on the <code>x</code> pattern.</p> </li> <li>
<p class="first"><strong>Nested patterns</strong></p> <p>Notice that we do <em>not</em> put bangs on nested patterns. For example</p> <pre data-language="haskell">let (p,q) = if flob then (undefined, undefined) else (True, False)
in ...
</pre> <p>will behave like</p> <pre data-language="haskell">let !(p,q) = if flob then (undefined, undefined) else (True,False)
in ...
</pre> <p>which will strictly evaluate the right hand side, and bind <code>p</code> and <code>q</code> to the components of the pair. But the pair itself is lazy (unless we also compile the <code>Prelude</code> with <code>Strict</code>; see <a class="reference internal" href="#strict-modularity"><span class="std std-ref">Modularity</span></a> below). So <code>p</code> and <code>q</code> may end up bound to undefined. See also <a class="reference internal" href="#recursive-and-polymorphic-let-bindings"><span class="std std-ref">Dynamic semantics of bang patterns</span></a> below.</p> </li> <li>
<p class="first"><strong>Top level bindings</strong></p> <p>are unaffected by <code>Strict</code>. For example:</p> <pre data-language="haskell">x = factorial 20
(y,z) = if x &gt; 10 then True else False
</pre> <p>Here <code>x</code> and the pattern binding <code>(y,z)</code> remain lazy. Reason: there is no good moment to force them, until first use.</p> </li> <li>
<p class="first"><strong>Newtypes</strong></p> <p>There is no effect on newtypes, which simply rename existing types. For example:</p> <pre data-language="haskell">newtype T = C a
f (C x)  = rhs1
g !(C x) = rhs2
</pre> <p>In ordinary Haskell, <code>f</code> is lazy in its argument and hence in <code>x</code>; and <code>g</code> is strict in its argument and hence also strict in <code>x</code>. With <code>Strict</code>, both become strict because <code>f</code>‘s argument gets an implicit bang.</p> </li> </ul>   <h2 id="strict-modularity">11.29.4. Modularity</h2> <p id="modularity"><code>Strict</code> and <code>StrictData</code> only affects definitions in the module they are used in. Functions and data types imported from other modules are unaffected. For example, we won’t evaluate the argument to <code>Just</code> before applying the constructor. Similarly we won’t evaluate the first argument to <code>Data.Map.findWithDefault</code> before applying the function.</p> <p>This is crucial to preserve correctness. Entities defined in other modules might rely on laziness for correctness (whether functional or performance).</p> <p>Tuples, lists, <code>Maybe</code>, and all the other types from <code>Prelude</code> continue to have their existing, lazy, semantics.</p>   <h2 id="bang-patterns-sem">11.29.5. Dynamic semantics of bang patterns</h2> <p id="dynamic-semantics-of-bang-patterns">The semantics of Haskell pattern matching is described in <a class="reference external" href="http://www.haskell.org/onlinereport/exps.html#sect3.17.2">Section 3.17.2</a> of the Haskell Report. To this description add one extra item 10, saying:</p> <ul class="simple"> <li>Matching the pattern <code>!pat</code> against a value <code>v</code> behaves as follows:<ul> <li>if <code>v</code> is bottom, the match diverges</li> <li>otherwise, <code>pat</code> is matched against <code>v</code>
</li> </ul> </li> </ul> <p>Similarly, in Figure 4 of <a class="reference external" href="http://www.haskell.org/onlinereport/exps.html#sect3.17.3">Section 3.17.3</a>, add a new case (t):</p> <pre data-language="haskell">case v of { !pat -&gt; e; _ -&gt; e' }
   = v `seq` case v of { pat -&gt; e; _ -&gt; e' }
</pre> <p>That leaves let expressions, whose translation is given in <a class="reference external" href="http://www.haskell.org/onlinereport/exps.html#sect3.12">Section 3.12</a> of the Haskell Report. Replace the “Translation” there with the following one. Given <code>let { bind1 ... bindn } in body</code>:</p> <div class="admonition-force admonition"> <p class="first admonition-title">FORCE</p> <p class="last">Replace any binding <code>!p = e</code> with <code>v = case e of p -&gt; (x1, ..., xn); (x1, ..., xn) = v</code> and replace <code>body</code> with <code>v seq body</code>, where <code>v</code> is fresh. This translation works fine if <code>p</code> is already a variable <code>x</code>, but can obviously be optimised by not introducing a fresh variable <code>v</code>.</p> </div> <div class="admonition-split admonition"> <p class="first admonition-title">SPLIT</p> <p class="last">Replace any binding <code>p = e</code>, where <code>p</code> is not a variable, with <code>v = e; x1 = case v of p -&gt; x1; ...; xn = case v of p -&gt; xn</code>, where <code>v</code> is fresh and <code>x1</code>.. <code>xn</code> are the bound variables of <code>p</code>. Again if <code>e</code> is a variable, this can be optimised by not introducing a fresh variable.</p> </div> <p>The result will be a (possibly) recursive set of bindings, binding only simple variables on the left hand side. (One could go one step further, as in the Haskell Report and make the recursive bindings non-recursive using <code>fix</code>, but we do not do so in Core, and it only obfuscates matters, so we do not do so here.)</p> <p>The translation is carefully crafted to make bang patterns meaningful for recursive and polymorphic bindings as well as straightforward non-recursive bindings.</p> <p>Here are some examples of how this translation works. The first expression of each sequence is Haskell source; the subsequent ones are Core.</p> <p>Here is a simple non-recursive case:</p> <pre data-language="haskell">let x :: Int     -- Non-recursive
    !x = factorial y
in body

===&gt; (FORCE)
    let x = factorial y in x `seq` body

===&gt; (inline seq)
    let x = factorial y in case x of x -&gt; body

===&gt; (inline x)
    case factorial y of x -&gt; body
</pre> <p>Same again, only with a pattern binding:</p> <pre data-language="haskell">let !(Just x, Left y) = e in body

===&gt; (FORCE)
    let v = case e of (Just x, Left y) -&gt; (x,y)
        (x,y) = v
    in v `seq` body

===&gt; (SPLIT)
    let v = case e of (Just x, Left y) -&gt; (x,y)
        x = case v of (x,y) -&gt; x
        y = case v of (x,y) -&gt; y
    in v `seq` body

===&gt; (inline seq, float x,y bindings inwards)
    let v = case e of (Just x, Left y) -&gt; (x,y)
    in case v of v -&gt; let x = case v of (x,y) -&gt; x
                          y = case v of (x,y) -&gt; y
                      in body

===&gt; (fluff up v's pattern; this is a standard Core optimisation)
    let v = case e of (Just x, Left y) -&gt; (x,y)
    in case v of v@(p,q) -&gt; let x = case v of (x,y) -&gt; x
                                y = case v of (x,y) -&gt; y
                            in body

===&gt; (case of known constructor)
    let v = case e of (Just x, Left y) -&gt; (x,y)
    in case v of v@(p,q) -&gt; let x = p
                                y = q
                            in body

===&gt; (inline x,y, v)
    case (case e of (Just x, Left y) -&gt; (x,y) of
        (p,q) -&gt; body[p/x, q/y]

===&gt; (case of case)
    case e of (Just x, Left y) -&gt; body[p/x, q/y]
</pre> <p>The final form is just what we want: a simple case expression.</p> <p>Here is a recursive case</p> <pre data-language="haskell">letrec xs :: [Int]  -- Recursive
        !xs = factorial y : xs
in body

===&gt; (FORCE)
    letrec xs = factorial y : xs in xs `seq` body

===&gt; (inline seq)
    letrec xs = factorial y : xs in case xs of xs -&gt; body

===&gt; (eliminate case of value)
    letrec xs = factorial y : xs in body
</pre> <p>and a polymorphic one:</p> <pre data-language="haskell">let f :: forall a. [a] -&gt; [a]    -- Polymorphic
    !f = fst (reverse, True)
in body

===&gt; (FORCE)
    let f = /\a. fst (reverse a, True) in f `seq` body
===&gt; (inline seq, inline f)
    case (/\a. fst (reverse a, True)) of f -&gt; body
</pre> <p>Notice that the <code>seq</code> is added only in the translation to Core If we did it in Haskell source, thus</p> <pre data-language="haskell">let f = ... in f `seq` body
</pre> <p>then <code>f</code>‘s polymorphic type would get instantiated, so the Core translation would be</p> <pre data-language="haskell">let f = ... in f Any `seq` body
</pre> <p>When overloading is involved, the results might be slightly counter intuitive:</p> <pre data-language="haskell">let f :: forall a. Eq a =&gt; a -&gt; [a] -&gt; Bool    -- Overloaded
    !f = fst (member, True)
in body

===&gt; (FORCE)
    let f = /\a \(d::Eq a). fst (member, True) in f `seq` body

===&gt; (inline seq, case of value)
    let f = /\a \(d::Eq a). fst (member, True) in body
</pre> <p>Note that the bang has no effect at all in this case</p>    <h1 id="id73">11.30. Assertions</h1> <p id="assertions">If you want to make use of assertions in your standard Haskell code, you could define a function like the following:</p> <pre data-language="haskell">assert :: Bool -&gt; a -&gt; a
assert False x = error "assertion failed!"
assert _     x = x
</pre> <p>which works, but gives you back a less than useful error message – an assertion failed, but which and where?</p> <p>One way out is to define an extended <code>assert</code> function which also takes a descriptive string to include in the error message and perhaps combine this with the use of a pre-processor which inserts the source location where <code>assert</code> was used.</p> <p>GHC offers a helping hand here, doing all of this for you. For every use of <code>assert</code> in the user’s source:</p> <pre data-language="haskell">kelvinToC :: Double -&gt; Double
kelvinToC k = assert (k &gt;= 0.0) (k-273.15)
</pre> <p>GHC will rewrite this to also include the source location where the assertion was made,</p> <pre data-language="haskell">assert pred val ==&gt; assertError "Main.hs|15" pred val
</pre> <p>The rewrite is only performed by the compiler when it spots applications of <code>Control.Exception.assert</code>, so you can still define and use your own versions of <code>assert</code>, should you so wish. If not, import <code>Control.Exception</code> to make use <code>assert</code> in your code.</p> <p id="index-26">GHC ignores assertions when optimisation is turned on with the <a class="reference internal" href="using-optimisation#ghc-flag--O"><code>-O</code></a> flag. That is, expressions of the form <code>assert pred e</code> will be rewritten to <code>e</code>. You can also disable assertions using the <a class="reference internal" href="using-optimisation#ghc-flag--fignore-asserts"><code>-fignore-asserts</code></a> option. The option <a class="reference internal" href="using-optimisation#ghc-flag--fignore-asserts"><code>-fno-ignore-asserts</code></a> allows enabling assertions even when optimisation is turned on.</p> <p>Assertion failures can be caught, see the documentation for the <a class="reference external" href="../libraries/base-4.13.0.0/control#t:Exception">Control.Exception</a> library for the details.</p>   <h1 id="id74">11.31. Static pointers</h1> <dl class="extension" id="static-pointers"> <dt id="extension-StaticPointers">
<code>StaticPointers</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10.1</td> </tr>  </table> <p>Allow use of static pointer syntax.</p> </dd>
</dl> <p>The language extension <a class="reference internal" href="#extension-StaticPointers"><code>StaticPointers</code></a> adds a new syntactic form <code>static e</code>, which stands for a reference to the closed expression ⟨e⟩. This reference is stable and portable, in the sense that it remains valid across different processes on possibly different machines. Thus, a process can create a reference and send it to another process that can resolve it to ⟨e⟩.</p> <p>With this extension turned on, <code>static</code> is no longer a valid identifier.</p> <p>Static pointers were first proposed in the paper <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf">Towards Haskell in the cloud</a>, Jeff Epstein, Andrew P. Black and Simon Peyton-Jones, Proceedings of the 4th ACM Symposium on Haskell, pp. 118-129, ACM, 2011.</p>  <h2 id="id75">11.31.1. Using static pointers</h2> <p id="using-static-pointers">Each reference is given a key which can be used to locate it at runtime with <a class="reference external" href="../libraries/base-4.13.0.0/ghc-staticptr#v:unsafeLookupStaticPtr">GHC.StaticPtr.unsafeLookupStaticPtr</a> which uses a global and immutable table called the Static Pointer Table. The compiler includes entries in this table for all static forms found in the linked modules. The value can be obtained from the reference via <a class="reference external" href="../libraries/base-4.13.0.0/ghc-staticptr#v:deRefStaticPtr">GHC.StaticPtr.deRefStaticPtr</a>.</p> <p>The body <code>e</code> of a <code>static e</code> expression must be a closed expression. Where we say an expression is <em>closed</em> when all of its free (type) variables are closed. And a variable is <em>closed</em> if it is let-bound to a <em>closed</em> expression and its type is <em>closed</em> as well. And a type is <em>closed</em> if it has no free variables.</p> <p>All of the following are permissible:</p> <pre data-language="haskell">inc :: Int -&gt; Int
inc x = x + 1

ref1 = static 1
ref2 = static inc
ref3 = static (inc 1)
ref4 = static ((\x -&gt; x + 1) (1 :: Int))
ref5 y = static (let x = 1 in x)
ref6 y = let x = 1 in static x
</pre> <p>While the following definitions are rejected:</p> <pre data-language="haskell">ref7 y = let x = y in static x    -- x is not closed
ref8 y = static (let x = 1 in y)  -- y is not let-bound
ref8 (y :: a) = let x = undefined :: a
                 in static x      -- x has a non-closed type
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">While modules loaded in GHCi with the <a class="reference internal" href="ghci#ghci-cmd-:load"><code>:load</code></a> command may use <a class="reference internal" href="#extension-StaticPointers"><code>StaticPointers</code></a> and <code>static</code> expressions, statements entered on the REPL may not. This is a limitation of GHCi; see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/12356">Issue #12356</a> for details.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The set of keys used for locating static pointers in the Static Pointer Table is not guaranteed to remain stable for different program binaries. Or in other words, only processes launched from the same program binary are guaranteed to use the same set of keys.</p> </div>   <h2 id="typechecking-static-pointers">11.31.2. Static semantics of static pointers</h2> <p id="static-semantics-of-static-pointers">Informally, if we have a closed expression</p> <pre data-language="haskell">e :: forall a_1 ... a_n . t
</pre> <p>the static form is of type</p> <pre data-language="haskell">static e :: (IsStatic p, Typeable a_1, ... , Typeable a_n) =&gt; p t
</pre> <p>A static form determines a value of type <code>StaticPtr t</code>, but just like <code>OverloadedLists</code> and <code>OverloadedStrings</code>, this literal expression is overloaded to allow lifting a <code>StaticPtr</code> into another type implicitly, via the <code>IsStatic</code> class:</p> <pre data-language="haskell">class IsStatic p where
    fromStaticPtr :: StaticPtr a -&gt; p a
</pre> <p>The only predefined instance is the obvious one that does nothing:</p> <pre data-language="haskell">instance IsStatic StaticPtr where
    fromStaticPtr sptr = sptr
</pre> <p>See <a class="reference external" href="../libraries/base-4.13.0.0/ghc-staticptr#t:IsStatic">GHC.StaticPtr.IsStatic</a>.</p> <p>Furthermore, type <code>t</code> is constrained to have a <code>Typeable</code> instance. The following are therefore illegal:</p> <pre data-language="haskell">static show                    -- No Typeable instance for (Show a =&gt; a -&gt; String)
static Control.Monad.ST.runST  -- No Typeable instance for ((forall s. ST s a) -&gt; a)
</pre> <p>That being said, with the appropriate use of wrapper datatypes, the above limitations induce no loss of generality:</p> <pre data-language="haskell">{-# LANGUAGE ConstraintKinds           #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE Rank2Types                #-}
{-# LANGUAGE StandaloneDeriving        #-}
{-# LANGUAGE StaticPointers            #-}

import Control.Monad.ST
import Data.Typeable
import GHC.StaticPtr

data Dict c = c =&gt; Dict

g1 :: Typeable a =&gt; StaticPtr (Dict (Show a) -&gt; a -&gt; String)
g1 = static (\Dict -&gt; show)

data Rank2Wrapper f = R2W (forall s. f s)
  deriving Typeable
newtype Flip f a s = Flip { unFlip :: f s a }
  deriving Typeable

g2 :: Typeable a =&gt; StaticPtr (Rank2Wrapper (Flip ST a) -&gt; a)
g2 = static (\(R2W f) -&gt; runST (unFlip f))
</pre>    <h1 id="id76">11.32. Pragmas</h1> <p id="pragmas">GHC supports several pragmas, or instructions to the compiler placed in the source code. Pragmas don’t normally affect the meaning of the program, but they might affect the efficiency of the generated code.</p> <p>Pragmas all take the form <code>{-# word ... #-}</code> where ⟨word⟩ indicates the type of pragma, and is followed optionally by information specific to that type of pragma. Case is ignored in ⟨word⟩. The various values for ⟨word⟩ that GHC understands are described in the following sections; any pragma encountered with an unrecognised ⟨word⟩ is ignored. The layout rule applies in pragmas, so the closing <code>#-}</code> should start in a column to the right of the opening <code>{-#</code>.</p> <p>Certain pragmas are <em>file-header pragmas</em>:</p> <ul class="simple"> <li>A file-header pragma must precede the <code>module</code> keyword in the file.</li> <li>There can be as many file-header pragmas as you please, and they can be preceded or followed by comments.</li> <li>File-header pragmas are read once only, before pre-processing the file (e.g. with cpp).</li> <li>The file-header pragmas are: <code>{-# LANGUAGE #-}</code>, <code>{-# OPTIONS_GHC #-}</code>, and <code>{-# INCLUDE #-}</code>.</li> </ul>  <h2 id="id77">11.32.1. <code>LANGUAGE</code> pragma</h2> <dl class="pragma" id="language-pragma"> <dt id="pragma-LANGUAGE">
<code>{-# LANGUAGE ⟨ext⟩, ⟨ext⟩, ... #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">file header</td> </tr>  </table> <p>Enable or disable a set of language extensions.</p> </dd>
</dl> <p>The <code>LANGUAGE</code> pragma allows language extensions to be enabled in a portable way. It is the intention that all Haskell compilers support the <code>LANGUAGE</code> pragma with the same syntax, although not all extensions are supported by all compilers, of course. The <code>LANGUAGE</code> pragma should be used instead of <code>OPTIONS_GHC</code>, if possible.</p> <p>For example, to enable the FFI and preprocessing with CPP:</p> <pre data-language="haskell">{-# LANGUAGE ForeignFunctionInterface, CPP #-}
</pre> <p><code>LANGUAGE</code> is a file-header pragma (see <a class="reference internal" href="#pragmas"><span class="std std-ref">Pragmas</span></a>).</p> <p>Every language extension can also be turned into a command-line flag by prefixing it with “<code>-X</code>”; for example <code>-XForeignFunctionInterface</code>. (Similarly, all “<code>-X</code>” flags can be written as <code>LANGUAGE</code> pragmas.)</p> <p>A list of all supported language extensions can be obtained by invoking <code>ghc --supported-extensions</code> (see <a class="reference internal" href="using#ghc-flag---supported-extensions"><code>--supported-extensions</code></a>).</p> <p>Any extension from the <code>Extension</code> type defined in <a class="reference external" href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Language-Haskell-Extension.html">Language.Haskell.Extension</a> may be used. GHC will report an error if any of the requested extensions are not supported.</p>   <h2 id="options-pragma">11.32.2. <code>OPTIONS_GHC</code> pragma</h2> <dl class="pragma" id="options-ghc-pragma"> <dt id="pragma-OPTIONS_GHC">
<code>{-# OPTIONS_GHC ⟨flags⟩ #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">file header</td> </tr>  </table> </dd>
</dl> <p>The <code>OPTIONS_GHC</code> pragma is used to specify additional options that are given to the compiler when compiling this source file. See <a class="reference internal" href="using#source-file-options"><span class="std std-ref">Command line options in source files</span></a> for details.</p> <p>Previous versions of GHC accepted <code>OPTIONS</code> rather than <code>OPTIONS_GHC</code>, but that is now deprecated.</p> <p><code>OPTIONS_GHC</code> is a file-header pragma (see <a class="reference internal" href="#pragmas"><span class="std std-ref">Pragmas</span></a>).</p>   <h2 id="id78">11.32.3. <code>INCLUDE</code> pragma</h2> <p id="include-pragma">The <code>INCLUDE</code> used to be necessary for specifying header files to be included when using the FFI and compiling via C. It is no longer required for GHC, but is accepted (and ignored) for compatibility with other compilers.</p>   <h2 id="warning-deprecated-pragma">11.32.4. <code>WARNING</code> and <code>DEPRECATED</code> pragmas</h2> <dl class="pragma" id="warning-and-deprecated-pragmas"> <dt id="pragma-WARNING">
<code>{-# WARNING #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">declaration</td> </tr>  </table> <p>The <code>WARNING</code> pragma allows you to attach an arbitrary warning to a particular function, class, or type.</p> </dd>
</dl> <dl class="pragma"> <dt id="pragma-DEPRECATED">
<code>{-# DEPRECATED #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">declaration</td> </tr>  </table> <p>A <code>DEPRECATED</code> pragma lets you specify that a particular function, class, or type is deprecated.</p> </dd>
</dl> <p>There are two ways of using these pragmas.</p> <ul> <li>
<p class="first">You can work on an entire module thus:</p> <pre data-language="haskell">module Wibble {-# DEPRECATED "Use Wobble instead" #-} where
  ...
</pre> <p>Or:</p> <pre data-language="haskell">module Wibble {-# WARNING "This is an unstable interface." #-} where
  ...
</pre> <p>When you compile any module that import <code>Wibble</code>, GHC will print the specified message.</p> </li> <li>
<p class="first">You can attach a warning to a function, class, type, or data constructor, with the following top-level declarations:</p> <pre data-language="haskell">{-# DEPRECATED f, C, T "Don't use these" #-}
{-# WARNING unsafePerformIO "This is unsafe; I hope you know what you're doing" #-}
</pre> <p>When you compile any module that imports and uses any of the specified entities, GHC will print the specified message.</p> <p>You can only attach to entities declared at top level in the module being compiled, and you can only use unqualified names in the list of entities. A capitalised name, such as <code>T</code> refers to <em>either</em> the type constructor <code>T</code> <em>or</em> the data constructor <code>T</code>, or both if both are in scope. If both are in scope, there is currently no way to specify one without the other (c.f. fixities <a class="reference internal" href="#infix-tycons"><span class="std std-ref">Infix type constructors, classes, and type variables</span></a>).</p> </li> </ul> <p>Also note that the argument to <code>DEPRECATED</code> and <code>WARNING</code> can also be a list of strings, in which case the strings will be presented on separate lines in the resulting warning message,</p> <pre data-language="haskell">{-# DEPRECATED foo, bar ["Don't use these", "Use gar instead"] #-}
</pre> <p>Warnings and deprecations are not reported for (a) uses within the defining module, (b) defining a method in a class instance, and (c) uses in an export list. The latter reduces spurious complaints within a library in which one module gathers together and re-exports the exports of several others.</p> <p>You can suppress the warnings with the flag <a class="reference internal" href="using-warnings#ghc-flag--Wwarnings-deprecations"><code>-Wno-warnings-deprecations</code></a>.</p>   <h2 id="id79">11.32.5. <code>MINIMAL</code> pragma</h2> <dl class="pragma" id="minimal-pragma"> <dt id="pragma-MINIMAL">
<code>{-# MINIMAL ⟨name⟩ | ⟨name⟩ , ... #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">in class body</td> </tr>  </table> <p>Define the methods needed for a minimal complete instance of a class.</p> </dd>
</dl> <p>The <code>MINIMAL</code> pragma is used to specify the minimal complete definition of a class, i.e. specify which methods must be implemented by all instances. If an instance does not satisfy the minimal complete definition, then a warning is generated. This can be useful when a class has methods with circular defaults. For example</p> <pre data-language="haskell">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
    (/=) :: a -&gt; a -&gt; Bool
    x == y = not (x /= y)
    x /= y = not (x == y)
    {-# MINIMAL (==) | (/=) #-}
</pre> <p>Without the <code>MINIMAL</code> pragma no warning would be generated for an instance that implements neither method.</p> <p>The syntax for minimal complete definition is:</p> <pre data-language="haskell">mindef ::= name
        |  '(' mindef ')'
        |  mindef '|' mindef
        |  mindef ',' mindef
</pre> <p>A vertical bar denotes disjunction, i.e. one of the two sides is required. A comma denotes conjunction, i.e. both sides are required. Conjunction binds stronger than disjunction.</p> <p>If no <code>MINIMAL</code> pragma is given in the class declaration, it is just as if a pragma <code>{-# MINIMAL op1, op2, ..., opn #-}</code> was given, where the <code>opi</code> are the methods that lack a default method in the class declaration (c.f. <a class="reference internal" href="using-warnings#ghc-flag--Wmissing-methods"><code>-Wmissing-methods</code></a>, <a class="reference internal" href="using-warnings#options-sanity"><span class="std std-ref">Warnings and sanity-checking</span></a>).</p> <p>This warning can be turned off with the flag <a class="reference internal" href="using-warnings#ghc-flag--Wmissing-methods"><code>-Wno-missing-methods</code></a>.</p>   <h2 id="inline-noinline-pragma">11.32.6. <code>INLINE</code> and <code>NOINLINE</code> pragmas</h2> <p id="inline-and-noinline-pragmas">These pragmas control the inlining of function definitions.</p>  <h3 id="id80">11.32.6.1. <code>INLINE</code> pragma</h3> <dl class="pragma" id="inline-pragma"> <dt id="pragma-INLINE">
<code>{-# INLINE ⟨name⟩ #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">top-level</td> </tr>  </table> <p>Force GHC to inline a value.</p> </dd>
</dl> <p>GHC (with <a class="reference internal" href="using-optimisation#ghc-flag--O"><code>-O</code></a>, as always) tries to inline (or “unfold”) functions/values that are “small enough,” thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won’t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see <a class="reference internal" href="using-optimisation#options-f"><span class="std std-ref">-f*: platform-independent flags</span></a>.</p> <p>Normally GHC will do a reasonable job of deciding by itself when it is a good idea to inline a function. However, sometimes you might want to override the default behaviour. For example, if you have a key function that is important to inline because it leads to further optimisations, but GHC judges it to be too big to inline.</p> <p>The sledgehammer you can bring to bear is the <code>INLINE</code> pragma, used thusly:</p> <pre data-language="haskell">key_function :: Int -&gt; String -&gt; (Bool, Double)
{-# INLINE key_function #-}
</pre> <p>The major effect of an <code>INLINE</code> pragma is to declare a function’s “cost” to be very low. The normal unfolding machinery will then be very keen to inline it. However, an <code>INLINE</code> pragma for a function “<code>f</code>” has a number of other effects:</p> <ul> <li>
<p class="first">While GHC is keen to inline the function, it does not do so blindly. For example, if you write</p> <pre data-language="haskell">map key_function xs
</pre> <p>there really isn’t any point in inlining <code>key_function</code> to get</p> <pre data-language="haskell">map (\x -&gt; body) xs
</pre> <p>In general, GHC only inlines the function if there is some reason (no matter how slight) to suppose that it is useful to do so.</p> </li> <li>
<p class="first">Moreover, GHC will only inline the function if it is <em>fully applied</em>, where “fully applied” means applied to as many arguments as appear (syntactically) on the LHS of the function definition. For example:</p> <pre data-language="haskell">comp1 :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
{-# INLINE comp1 #-}
comp1 f g = \x -&gt; f (g x)

comp2 :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
{-# INLINE comp2 #-}
comp2 f g x = f (g x)
</pre> <p>The two functions <code>comp1</code> and <code>comp2</code> have the same semantics, but <code>comp1</code> will be inlined when applied to <em>two</em> arguments, while <code>comp2</code> requires <em>three</em>. This might make a big difference if you say</p> <pre data-language="haskell">map (not `comp1` not) xs
</pre> <p>which will optimise better than the corresponding use of <code>comp2</code>.</p> </li> <li>
<p class="first">It is useful for GHC to optimise the definition of an INLINE function <code>f</code> just like any other non-<code>INLINE</code> function, in case the non-inlined version of <code>f</code> is ultimately called. But we don’t want to inline the <em>optimised</em> version of <code>f</code>; a major reason for <code>INLINE</code> pragmas is to expose functions in <code>f</code>‘s RHS that have rewrite rules, and it’s no good if those functions have been optimised away.</p> <p>So <em>GHC guarantees to inline precisely the code that you wrote</em>, no more and no less. It does this by capturing a copy of the definition of the function to use for inlining (we call this the “inline-RHS”), which it leaves untouched, while optimising the ordinarily RHS as usual. For externally-visible functions the inline-RHS (not the optimised RHS) is recorded in the interface file.</p> </li> <li>An <code>INLINE</code> function is not worker/wrappered by strictness analysis. It’s going to be inlined wholesale instead. </li> </ul> <p>GHC ensures that inlining cannot go on forever: every mutually-recursive group is cut by one or more <em>loop breakers</em> that is never inlined (see <a class="reference external" href="http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm">Secrets of the GHC inliner, JFP 12(4) July 2002</a>). GHC tries not to select a function with an <code>INLINE</code> pragma as a loop breaker, but when there is no choice even an INLINE function can be selected, in which case the <code>INLINE</code> pragma is ignored. For example, for a self-recursive function, the loop breaker can only be the function itself, so an <code>INLINE</code> pragma is always ignored.</p> <p>Syntactically, an <code>INLINE</code> pragma for a function can be put anywhere its type signature could be put.</p> <p><code>INLINE</code> pragmas are a particularly good idea for the <code>then</code>/<code>return</code> (or <code>bind</code>/<code>unit</code>) functions in a monad. For example, in GHC’s own <code>UniqueSupply</code> monad code, we have:</p> <pre data-language="haskell">{-# INLINE thenUs #-}
{-# INLINE returnUs #-}
</pre> <p>See also the <code>NOINLINE</code> (<a class="reference internal" href="#noinline-pragma"><span class="std std-ref">NOINLINE pragma</span></a>) and <code>INLINABLE</code> (<a class="reference internal" href="#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>) pragmas.</p>   <h3 id="id81">11.32.6.2. <code>INLINABLE</code> pragma</h3> <dl class="pragma" id="inlinable-pragma"> <dt id="pragma-INLINABLE">
<code>{-# INLINABLE ⟨name⟩ #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">top-level</td> </tr>  </table> <p>Suggest that the compiler always consider inlining <code>name</code>.</p> </dd>
</dl> <p>An <code>{-# INLINABLE f #-}</code> pragma on a function <code>f</code> has the following behaviour:</p> <ul class="simple"> <li>While <code>INLINE</code> says “please inline me”, the <code>INLINABLE</code> says “feel free to inline me; use your discretion”. In other words the choice is left to GHC, which uses the same rules as for pragma-free functions. Unlike <code>INLINE</code>, that decision is made at the <em>call site</em>, and will therefore be affected by the inlining threshold, optimisation level etc.</li> <li>Like <code>INLINE</code>, the <code>INLINABLE</code> pragma retains a copy of the original RHS for inlining purposes, and persists it in the interface file, regardless of the size of the RHS.</li> <li>One way to use <code>INLINABLE</code> is in conjunction with the special function <code>inline</code> (<a class="reference internal" href="#special-ids"><span class="std std-ref">Special built-in functions</span></a>). The call <code>inline f</code> tries very hard to inline <code>f</code>. To make sure that <code>f</code> can be inlined, it is a good idea to mark the definition of <code>f</code> as <code>INLINABLE</code>, so that GHC guarantees to expose an unfolding regardless of how big it is. Moreover, by annotating <code>f</code> as <code>INLINABLE</code>, you ensure that <code>f</code>‘s original RHS is inlined, rather than whatever random optimised version of <code>f</code> GHC’s optimiser has produced.</li> <li>The <code>INLINABLE</code> pragma also works with <code>SPECIALISE</code>: if you mark function <code>f</code> as <code>INLINABLE</code>, then you can subsequently <code>SPECIALISE</code> in another module (see <a class="reference internal" href="#specialize-pragma"><span class="std std-ref">SPECIALIZE pragma</span></a>).</li> <li>Unlike <code>INLINE</code>, it is OK to use an <code>INLINABLE</code> pragma on a recursive function. The principal reason do to so to allow later use of <code>SPECIALISE</code>
</li> </ul> <p>The alternative spelling <code>INLINEABLE</code> is also accepted by GHC.</p>   <h3 id="id82">11.32.6.3. <code>NOINLINE</code> pragma</h3> <dl class="pragma" id="noinline-pragma"> <dt id="pragma-NOINLINE">
<code>{-# NOINLINE ⟨name⟩ #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">top-level</td> </tr>  </table> <p>Instructs the compiler not to inline a value.</p> </dd>
</dl> <p>The <a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a> pragma does exactly what you’d expect: it stops the named function from being inlined by the compiler. You shouldn’t ever need to do this, unless you’re very cautious about code size.</p> <p><code>NOTINLINE</code> is a synonym for <code>NOINLINE</code> (<code>NOINLINE</code> is specified by Haskell 98 as the standard way to disable inlining, so it should be used if you want your code to be portable).</p>   <h3 id="conlike-pragma">11.32.6.4. <code>CONLIKE</code> modifier</h3> <dl class="pragma" id="conlike-modifier"> <dt id="pragma-CONLINE">
<code>{-# CONLINE #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">modifies <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> or <a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a> pragma</td> </tr>  </table> <p>Instructs GHC to consider a value to be especially cheap to inline.</p> </dd>
</dl> <p>An <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> or <a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a> pragma may have a <code>CONLIKE</code> modifier, which affects matching in <code>RULE</code>s (only). See <a class="reference internal" href="#conlike"><span class="std std-ref">How rules interact with CONLIKE pragmas</span></a>.</p>   <h3 id="id83">11.32.6.5. Phase control</h3> <p id="phase-control">Sometimes you want to control exactly when in GHC’s pipeline the <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> pragma is switched on. Inlining happens only during runs of the <em>simplifier</em>. Each run of the simplifier has a different <em>phase number</em>; the phase number decreases towards zero. If you use <a class="reference internal" href="debugging#ghc-flag--dverbose-core2core"><code>-dverbose-core2core</code></a> you will see the sequence of phase numbers for successive runs of the simplifier. In an <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> pragma you can optionally specify a phase number, thus:</p> <ul class="simple"> <li>“<code>INLINE[k] f</code>” means: do not inline <code>f</code> until phase <code>k</code>, but from phase <code>k</code> onwards be very keen to inline it.</li> <li>“<code>INLINE[~k] f</code>” means: be very keen to inline <code>f</code> until phase <code>k</code>, but from phase <code>k</code> onwards do not inline it.</li> <li>“<code>NOINLINE[k] f</code>” means: do not inline <code>f</code> until phase <code>k</code>, but from phase <code>k</code> onwards be willing to inline it (as if there was no pragma).</li> <li>“<code>NOINLINE[~k] f</code>” means: be willing to inline <code>f</code> until phase <code>k</code>, but from phase <code>k</code> onwards do not inline it.</li> </ul> <p>The same information is summarised here:</p> <pre data-language="none">                         -- Before phase 2     Phase 2 and later
{-# INLINE   [2]  f #-}  --      No                 Yes
{-# INLINE   [~2] f #-}  --      Yes                No
{-# NOINLINE [2]  f #-}  --      No                 Maybe
{-# NOINLINE [~2] f #-}  --      Maybe              No

{-# INLINE   f #-}       --      Yes                Yes
{-# NOINLINE f #-}       --      No                 No
</pre> <p>By “Maybe” we mean that the usual heuristic inlining rules apply (if the function body is small, or it is applied to interesting-looking arguments etc). Another way to understand the semantics is this:</p> <ul class="simple"> <li>For both <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> and <a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a>, the phase number says when inlining is allowed at all.</li> <li>The <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> pragma has the additional effect of making the function body look small, so that when inlining is allowed it is very likely to happen.</li> </ul> <p>The same phase-numbering control is available for <code>RULE</code>s (<a class="reference internal" href="#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>).</p>    <h2 id="id84">11.32.7. <code>LINE</code> pragma</h2> <dl class="pragma" id="line-pragma"> <dt id="pragma-LINE">
<code>{-# LINE ⟨lineno⟩ "⟨file⟩" #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">anywhere</td> </tr>  </table> <p>Generated by preprocessors to convey source line numbers of the original source.</p> </dd>
</dl> <p>This pragma is similar to C’s <code>#line</code> pragma, and is mainly for use in automatically generated Haskell code. It lets you specify the line number and filename of the original code; for example</p> <pre data-language="haskell">{-# LINE 42 "Foo.vhs" #-}
</pre> <p>if you’d generated the current file from something called <code>Foo.vhs</code> and this line corresponds to line 42 in the original. GHC will adjust its error messages to refer to the line/file named in the <code>LINE</code> pragma.</p> <p><code>LINE</code> pragmas generated from Template Haskell set the file and line position for the duration of the splice and are limited to the splice. Note that because Template Haskell splices abstract syntax, the file positions are not automatically advanced.</p>   <h2 id="id85">11.32.8. <code>COLUMN</code> pragma</h2> <p id="column-pragma">This is the analogue of the <code>LINE</code> pragma and is likewise intended for use in automatically generated Haskell code. It lets you specify the column number of the original code; for example</p> <pre data-language="haskell">foo = do
  {-# COLUMN 42 #-}pure ()
  pure ()
</pre> <p>This adjusts all column numbers immediately after the pragma to start at 42. The presence of this pragma only affects the quality of the diagnostics and does not change the syntax of the code itself.</p>   <h2 id="rules">11.32.9. <code>RULES</code> pragma</h2> <p id="rules-pragma">The <a class="reference internal" href="#pragma-RULES"><code>RULES</code></a> pragma lets you specify rewrite rules. It is described in <a class="reference internal" href="#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>.</p>   <h2 id="id86">11.32.10. <code>SPECIALIZE</code> pragma</h2> <dl class="pragma" id="specialize-pragma"> <dt id="pragma-SPECIALIZE">
<code>{-# SPECIALIZE ⟨name⟩ :: ⟨type⟩ #-}</code> </dt> <dd>
<p>Ask that GHC specialize a polymorphic value to a particular type.</p> </dd>
</dl> <p>(UK spelling also accepted.) For key overloaded functions, you can create extra versions (NB: at the cost of larger code) specialised to particular types. Thus, if you have an overloaded function:</p> <pre data-language="haskell">hammeredLookup :: Ord key =&gt; [(key, value)] -&gt; key -&gt; value
</pre> <p>If it is heavily used on lists with <code>Widget</code> keys, you could specialise it as follows:</p> <pre data-language="haskell">{-# SPECIALIZE hammeredLookup :: [(Widget, value)] -&gt; Widget -&gt; value #-}
</pre> <ul> <li>A <code>SPECIALIZE</code> pragma for a function can be put anywhere its type signature could be put. Moreover, you can also <code>SPECIALIZE</code> an <em>imported</em> function provided it was given an <code>INLINABLE</code> pragma at its definition site (<a class="reference internal" href="#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>). </li> <li>A <code>SPECIALIZE</code> has the effect of generating (a) a specialised version of the function and (b) a rewrite rule (see <a class="reference internal" href="#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>) that rewrites a call to the un-specialised function into a call to the specialised one. Moreover, given a <code>SPECIALIZE</code> pragma for a function <code>f</code>, GHC will automatically create specialisations for any type-class-overloaded functions called by <code>f</code>, if they are in the same module as the <code>SPECIALIZE</code> pragma, or if they are <code>INLINABLE</code>; and so on, transitively. </li> <li>
<p class="first">You can add phase control (<a class="reference internal" href="#phase-control"><span class="std std-ref">Phase control</span></a>) to the RULE generated by a <code>SPECIALIZE</code> pragma, just as you can if you write a <code>RULE</code> directly. For example:</p> <pre data-language="haskell">{-# SPECIALIZE [0] hammeredLookup :: [(Widget, value)] -&gt; Widget -&gt; value #-}
</pre> <p>generates a specialisation rule that only fires in Phase 0 (the final phase). If you do not specify any phase control in the <code>SPECIALIZE</code> pragma, the phase control is inherited from the inline pragma (if any) of the function. For example:</p> <pre data-language="haskell">foo :: Num a =&gt; a -&gt; a
foo = ...blah...
{-# NOINLINE [0] foo #-}
{-# SPECIALIZE foo :: Int -&gt; Int #-}
</pre> <p>The <code>NOINLINE</code> pragma tells GHC not to inline <code>foo</code> until Phase 0; and this property is inherited by the specialisation RULE, which will therefore only fire in Phase 0.</p> <p>The main reason for using phase control on specialisations is so that you can write optimisation RULES that fire early in the compilation pipeline, and only <em>then</em> specialise the calls to the function. If specialisation is done too early, the optimisation rules might fail to fire.</p> </li> <li>
<p class="first">The type in a <code>SPECIALIZE</code> pragma can be any type that is less polymorphic than the type of the original function. In concrete terms, if the original function is <code>f</code> then the pragma</p> <pre data-language="haskell">{-# SPECIALIZE f :: &lt;type&gt; #-}
</pre> <p>is valid if and only if the definition</p> <pre data-language="haskell">f_spec :: &lt;type&gt;
f_spec = f
</pre> <p>is valid. Here are some examples (where we only give the type signature for the original function, not its code):</p> <pre data-language="haskell">f :: Eq a =&gt; a -&gt; b -&gt; b
{-# SPECIALISE f :: Int -&gt; b -&gt; b #-}

g :: (Eq a, Ix b) =&gt; a -&gt; b -&gt; b
{-# SPECIALISE g :: (Eq a) =&gt; a -&gt; Int -&gt; Int #-}

h :: Eq a =&gt; a -&gt; a -&gt; a
{-# SPECIALISE h :: (Eq a) =&gt; [a] -&gt; [a] -&gt; [a] #-}
</pre> <p>The last of these examples will generate a RULE with a somewhat-complex left-hand side (try it yourself), so it might not fire very well. If you use this kind of specialisation, let us know how well it works.</p> </li> </ul>  <h3 id="id87">11.32.10.1. <code>SPECIALIZE INLINE</code>
</h3> <dl class="pragma" id="specialize-inline"> <dt id="pragma-SPECIALIZE">
<code>{-# SPECIALIZE INLINE ⟨name⟩ :: ⟨type⟩ #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">top-level</td> </tr>  </table> </dd>
</dl> <p>A <code>SPECIALIZE</code> pragma can optionally be followed with a <code>INLINE</code> or <code>NOINLINE</code> pragma, optionally followed by a phase, as described in <a class="reference internal" href="#inline-noinline-pragma"><span class="std std-ref">INLINE and NOINLINE pragmas</span></a>. The <code>INLINE</code> pragma affects the specialised version of the function (only), and applies even if the function is recursive. The motivating example is this:</p> <pre data-language="haskell">-- A GADT for arrays with type-indexed representation
data Arr e where
  ArrInt :: !Int -&gt; ByteArray# -&gt; Arr Int
  ArrPair :: !Int -&gt; Arr e1 -&gt; Arr e2 -&gt; Arr (e1, e2)

(!:) :: Arr e -&gt; Int -&gt; e
{-# SPECIALISE INLINE (!:) :: Arr Int -&gt; Int -&gt; Int #-}
{-# SPECIALISE INLINE (!:) :: Arr (a, b) -&gt; Int -&gt; (a, b) #-}
(ArrInt _ ba)     !: (I# i) = I# (indexIntArray# ba i)
(ArrPair _ a1 a2) !: i      = (a1 !: i, a2 !: i)
</pre> <p>Here, <code>(!:)</code> is a recursive function that indexes arrays of type <code>Arr e</code>. Consider a call to <code>(!:)</code> at type <code>(Int,Int)</code>. The second specialisation will fire, and the specialised function will be inlined. It has two calls to <code>(!:)</code>, both at type <code>Int</code>. Both these calls fire the first specialisation, whose body is also inlined. The result is a type-based unrolling of the indexing function.</p> <p>You can add explicit phase control (<a class="reference internal" href="#phase-control"><span class="std std-ref">Phase control</span></a>) to <code>SPECIALISE INLINE</code> pragma, just like on an <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a> pragma; if you do so, the same phase is used for the rewrite rule and the INLINE control of the specialised function.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">You can make GHC diverge by using <code>SPECIALISE INLINE</code> on an ordinarily-recursive function.</p> </div>   <h3 id="specialize-for-imported-functions">11.32.10.2. <code>SPECIALIZE</code> for imported functions</h3> <p>Generally, you can only give a <a class="reference internal" href="#pragma-SPECIALIZE"><code>SPECIALIZE</code></a> pragma for a function defined in the same module. However if a function <code>f</code> is given an <a class="reference internal" href="#pragma-INLINABLE"><code>INLINABLE</code></a> pragma at its definition site, then it can subsequently be specialised by importing modules (see <a class="reference internal" href="#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>). For example</p> <pre data-language="haskell">module Map( lookup, blah blah ) where
  lookup :: Ord key =&gt; [(key,a)] -&gt; key -&gt; Maybe a
  lookup = ...
  {-# INLINABLE lookup #-}

module Client where
  import Map( lookup )

  data T = T1 | T2 deriving( Eq, Ord )
  {-# SPECIALISE lookup :: [(T,a)] -&gt; T -&gt; Maybe a
</pre> <p>Here, <code>lookup</code> is declared <a class="reference internal" href="#pragma-INLINABLE"><code>INLINABLE</code></a>, but it cannot be specialised for type <code>T</code> at its definition site, because that type does not exist yet. Instead a client module can define <code>T</code> and then specialise <code>lookup</code> at that type.</p> <p>Moreover, every module that imports <code>Client</code> (or imports a module that imports <code>Client</code>, transitively) will “see”, and make use of, the specialised version of <code>lookup</code>. You don’t need to put a <a class="reference internal" href="#pragma-SPECIALIZE"><code>SPECIALIZE</code></a> pragma in every module.</p> <p>Moreover you often don’t even need the <a class="reference internal" href="#pragma-SPECIALIZE"><code>SPECIALIZE</code></a> pragma in the first place. When compiling a module <code>M</code>, GHC’s optimiser (when given the <a class="reference internal" href="using-optimisation#ghc-flag--O"><code>-O</code></a> flag) automatically considers each top-level overloaded function declared in <code>M</code>, and specialises it for the different types at which it is called in <code>M</code>. The optimiser <em>also</em> considers each <em>imported</em> <a class="reference internal" href="#pragma-INLINABLE"><code>INLINABLE</code></a> overloaded function, and specialises it for the different types at which it is called in <code>M</code>. So in our example, it would be enough for <code>lookup</code> to be called at type <code>T</code>:</p> <pre data-language="haskell">module Client where
  import Map( lookup )

  data T = T1 | T2 deriving( Eq, Ord )

  findT1 :: [(T,a)] -&gt; Maybe a
  findT1 m = lookup m T1   -- A call of lookup at type T
</pre> <p>However, sometimes there are no such calls, in which case the pragma can be useful.</p>    <h2 id="id88">11.32.11. <code>SPECIALIZE</code> instance pragma</h2> <dl class="pragma" id="specialize-instance-pragma"> <dt id="pragma-SPECIALIZE">
<code>{-# SPECIALIZE instance ⟨instance head⟩ #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">instance body</td> </tr>  </table> </dd>
</dl> <p>Same idea, except for instance declarations. For example:</p> <pre data-language="haskell">instance (Eq a) =&gt; Eq (Foo a) where {
   {-# SPECIALIZE instance Eq (Foo [(Int, Bar)]) #-}
   ... usual stuff ...
 }
</pre> <p>The pragma must occur inside the <code>where</code> part of the instance declaration.</p>   <h2 id="id89">11.32.12. <code>UNPACK</code> pragma</h2> <dl class="pragma" id="unpack-pragma"> <dt id="pragma-UNPACK">
<code>{-# UNPACK #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">data constructor field</td> </tr>  </table> <p>Instructs the compiler to unpack the contents of a constructor field into the constructor itself.</p> </dd>
</dl> <p>The <code>UNPACK</code> indicates to the compiler that it should unpack the contents of a constructor field into the constructor itself, removing a level of indirection. For example:</p> <pre data-language="haskell">data T = T {-# UNPACK #-} !Float
           {-# UNPACK #-} !Float
</pre> <p>will create a constructor <code>T</code> containing two unboxed floats. This may not always be an optimisation: if the <code>T</code> constructor is scrutinised and the floats passed to a non-strict function for example, they will have to be reboxed (this is done automatically by the compiler).</p> <p>Unpacking constructor fields should only be used in conjunction with <a class="reference internal" href="using-optimisation#ghc-flag--O"><code>-O</code></a> <a class="footnote-reference" href="#id91" id="id90">[1]</a>, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</p> <pre data-language="haskell">f :: T -&gt; Float
f (T f1 f2) = f1 + f2
</pre> <p>The compiler will avoid reboxing <code>f1</code> and <code>f2</code> by inlining <code>+</code> on floats, but only when <a class="reference internal" href="using-optimisation#ghc-flag--O"><code>-O</code></a> is on.</p> <p>Any single-constructor data is eligible for unpacking; for example</p> <pre data-language="haskell">data T = T {-# UNPACK #-} !(Int,Int)
</pre> <p>will store the two <code>Int</code>s directly in the <code>T</code> constructor, by flattening the pair. Multi-level unpacking is also supported:</p> <pre data-language="haskell">data T = T {-# UNPACK #-} !S
data S = S {-# UNPACK #-} !Int {-# UNPACK #-} !Int
</pre> <p>will store two unboxed <code>Int#</code>s directly in the <code>T</code> constructor. The unpacker can see through newtypes, too.</p> <p>See also the <a class="reference internal" href="using-optimisation#ghc-flag--funbox-strict-fields"><code>-funbox-strict-fields</code></a> flag, which essentially has the effect of adding <code>{-# UNPACK #-}</code> to every strict constructor field.</p> <table class="docutils footnote" frame="void" id="id91" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id90">[1]</a></td>
<td>In fact, <a class="reference internal" href="#pragma-UNPACK"><code>UNPACK</code></a> has no effect without <a class="reference internal" href="using-optimisation#ghc-flag--O"><code>-O</code></a>, for technical reasons (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/5252">Issue #5252</a>).</td>
</tr>  </table>   <h2 id="id92">11.32.13. <code>NOUNPACK</code> pragma</h2> <dl class="pragma" id="nounpack-pragma"> <dt id="pragma-NOUNPACK">
<code>{-# NOUNPACK #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">top-level</td> </tr>  </table> <p>Instructs the compiler not to unpack a constructor field.</p> </dd>
</dl> <p>The <code>NOUNPACK</code> pragma indicates to the compiler that it should not unpack the contents of a constructor field. Example:</p> <pre data-language="haskell">data T = T {-# NOUNPACK #-} !(Int,Int)
</pre> <p>Even with the flags <a class="reference internal" href="using-optimisation#ghc-flag--funbox-strict-fields"><code>-funbox-strict-fields</code></a> and <a class="reference internal" href="using-optimisation#ghc-flag--O"><code>-O</code></a>, the field of the constructor <code>T</code> is not unpacked.</p>   <h2 id="id93">11.32.14. <code>SOURCE</code> pragma</h2> <dl class="pragma" id="source-pragma"> <dt id="pragma-SOURCE">
<code>{-# SOURCE #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">after <code>import</code> statement</td> </tr>  </table> <p>Import a module by <code>hs-boot</code> file to break a module loop.</p> </dd>
</dl> <p>The <code>{-# SOURCE #-}</code> pragma is used only in <code>import</code> declarations, to break a module loop. It is described in detail in <a class="reference internal" href="separate_compilation#mutual-recursion"><span class="std std-ref">How to compile mutually recursive modules</span></a>.</p>   <h2 id="complete-pragma">11.32.15. <code>COMPLETE</code> pragmas</h2> <dl class="pragma" id="complete-pragmas"> <dt id="pragma-COMPLETE">
<code>{-# COMPLETE #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">at top level</td> </tr>  </table> <p>Specify the set of constructors or pattern synonyms which constitute a total match.</p> </dd>
</dl> <p>The <code>COMPLETE</code> pragma is used to inform the pattern match checker that a certain set of patterns is complete and that any function which matches on all the specified patterns is total.</p> <p>The most common usage of <code>COMPLETE</code> pragmas is with <a class="reference internal" href="#pattern-synonyms"><span class="std std-ref">Pattern synonyms</span></a>. On its own, the checker is very naive and assumes that any match involving a pattern synonym will fail. As a result, any pattern match on a pattern synonym is regarded as incomplete unless the user adds a catch-all case.</p> <p>For example, the data types <code>2 * A</code> and <code>A + A</code> are isomorphic but some computations are more naturally expressed in terms of one or the other. To get the best of both worlds, we can choose one as our implementation and then provide a set of pattern synonyms so that users can use the other representation if they desire. We can then specify a <code>COMPLETE</code> pragma in order to inform the pattern match checker that a function which matches on both <code>LeftChoice</code> and <code>RightChoice</code> is total.</p> <pre data-language="haskell">data Choice a = Choice Bool a

pattern LeftChoice :: a -&gt; Choice a
pattern LeftChoice a = Choice False a

pattern RightChoice :: a -&gt; Choice a
pattern RightChoice a = Choice True a

{-# COMPLETE LeftChoice, RightChoice #-}

foo :: Choice Int -&gt; Int
foo (LeftChoice n) = n * 2
foo (RightChoice n) = n - 2
</pre> <p><code>COMPLETE</code> pragmas are only used by the pattern match checker. If a function definition matches on all the constructors specified in the pragma then the compiler will produce no warning.</p> <p><code>COMPLETE</code> pragmas can contain any data constructors or pattern synonyms which are in scope, but must mention at least one data constructor or pattern synonym defined in the same module. <code>COMPLETE</code> pragmas may only appear at the top level of a module. Once defined, they are automatically imported and exported from modules. <code>COMPLETE</code> pragmas should be thought of as asserting a universal truth about a set of patterns and as a result, should not be used to silence context specific incomplete match warnings.</p> <p>When specifying a <code>COMPLETE</code> pragma, the result types of all patterns must be consistent with each other. This is a sanity check as it would be impossible to match on all the patterns if the types were inconsistent.</p> <p>The result type must also be unambiguous. Usually this can be inferred but when all the pattern synonyms in a group are polymorphic in the constructor the user must provide a type signature.</p> <pre data-language="haskell">class LL f where
  go :: f a -&gt; ()

instance LL [] where
  go _ = ()

pattern T :: LL f =&gt; f a
pattern T &lt;- (go -&gt; ())

{-# COMPLETE T :: [] #-}

-- No warning
foo :: [a] -&gt; Int
foo T = 5
</pre>   <h2 id="multiple-complete-pragmas">11.32.16. Disambiguating between multiple <code>COMPLETE</code> pragmas</h2> <p id="disambiguating-between-multiple-complete-pragmas">What should happen if there are multiple <code>COMPLETE</code> sets that apply to a single set of patterns? Consider this example:</p> <pre data-language="haskell">data T = MkT1 | MkT2 | MkT2Internal
{-# COMPLETE MkT1, MkT2 #-}
{-# COMPLETE MkT1, MkT2Internal #-}

f :: T -&gt; Bool
f MkT1 = True
f MkT2 = False
</pre> <p>Which <code>COMPLETE</code> pragma should be used when checking the coverage of the patterns in <code>f</code>? If we pick the <code>COMPLETE</code> set that covers <code>MkT1</code> and <code>MkT2</code>, then <code>f</code> is exhaustive, but if we pick the other <code>COMPLETE</code> set that covers <code>MkT1</code> and <code>MkT2Internal</code>, then <code>f</code> is <em>not</em> exhaustive, since it fails to match <code>MkT2Internal</code>. An intuitive way to solve this dilemma is to recognize that picking the former <code>COMPLETE</code> set produces the fewest number of uncovered pattern clauses, and thus is the better choice.</p> <p>GHC disambiguates between multiple <code>COMPLETE</code> sets based on this rationale. To make things more formal, when the pattern-match checker requests a set of constructors for some data type constructor <code>T</code>, the checker returns:</p> <ul class="simple"> <li>The original set of data constructors for <code>T</code>
</li> <li>Any <code>COMPLETE</code> sets of type <code>T</code>
</li> </ul> <p>GHC then checks for pattern coverage using each of these sets. If any of these sets passes the pattern coverage checker with no warnings, then we are done. If each set produces at least one warning, then GHC must pick one of the sets of warnings depending on how good the results are. The results are prioritized in this order:</p> <ol class="arabic simple"> <li>Fewest uncovered clauses</li> <li>Fewest redundant clauses</li> <li>Fewest inaccessible clauses</li> <li>Whether the match comes from the original set of data constructors or from a <code>COMPLETE</code> pragma (prioritizing the former over the latter)</li> </ol>   <h2 id="overlap-pragma">11.32.17. <code>OVERLAPPING</code>, <code>OVERLAPPABLE</code>, <code>OVERLAPS</code>, and <code>INCOHERENT</code> pragmas</h2> <dl class="pragma" id="overlapping-overlappable-overlaps-and-incoherent-pragmas"> <dt id="pragma-OVERLAPPING">
<code>{-# OVERLAPPING #-}</code> </dt> 
</dl> <dl class="pragma"> <dt id="pragma-OVERLAPPABLE">
<code>{-# OVERLAPPABLE #-}</code> </dt> 
</dl> <dl class="pragma"> <dt id="pragma-OVERLAPS">
<code>{-# OVERLAPS #-}</code> </dt> 
</dl> <dl class="pragma"> <dt id="pragma-INCOHERENT">
<code>{-# INCOHERENT #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">on instance head</td> </tr>  </table> </dd>
</dl> <p>The pragmas <code>OVERLAPPING</code>, <code>OVERLAPPABLE</code>, <code>OVERLAPS</code>, <code>INCOHERENT</code> are used to specify the overlap behavior for individual instances, as described in Section <a class="reference internal" href="#instance-overlap"><span class="std std-ref">Overlapping instances</span></a>. The pragmas are written immediately after the <code>instance</code> keyword, like this:</p> <pre data-language="haskell">instance {-# OVERLAPPING #-} C t where ...
</pre>    <h1 id="id94">11.33. Rewrite rules</h1> <dl class="pragma" id="rewrite-rules"> <dt id="pragma-RULES">
<code>{-# RULES "⟨name⟩" forall ⟨binder⟩ ... . ⟨expr⟩ = ⟨expr⟩ ... #-}</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Where:</th>
<td class="field-body">top-level</td> </tr>  </table> <p>Define a rewrite rule to be used to optimize a source program.</p> </dd>
</dl> <p>The programmer can specify rewrite rules as part of the source program (in a pragma). Here is an example:</p> <pre data-language="haskell">{-# RULES
      "map/map"    forall f g xs.  map f (map g xs) = map (f.g) xs
  #-}
</pre> <p>Use the debug flag <a class="reference internal" href="debugging#ghc-flag--ddump-simpl-stats"><code>-ddump-simpl-stats</code></a> to see what rules fired. If you need more information, then <a class="reference internal" href="debugging#ghc-flag--ddump-rule-firings"><code>-ddump-rule-firings</code></a> shows you each individual rule firing and <a class="reference internal" href="debugging#ghc-flag--ddump-rule-rewrites"><code>-ddump-rule-rewrites</code></a> also shows what the code looks like before and after the rewrite.</p> <dl class="ghc-flag"> <dt id="ghc-flag--fenable-rewrite-rules">
<code>-fenable-rewrite-rules</code> </dt> <dd>
<p>Allow the compiler to apply rewrite rules to the source program.</p> </dd>
</dl>  <h2 id="id95">11.33.1. Syntax</h2> <p>From a syntactic point of view:</p> <ul> <li>There may be zero or more rules in a <a class="reference internal" href="#pragma-RULES"><code>RULES</code></a> pragma, separated by semicolons (which may be generated by the layout rule). </li> <li>
<p class="first">The layout rule applies in a pragma. Currently no new indentation level is set, so if you put several rules in single <code>RULES</code> pragma and wish to use layout to separate them, you must lay out the starting in the same column as the enclosing definitions.</p> <pre data-language="haskell">{-# RULES
      "map/map"    forall f g xs.  map f (map g xs) = map (f.g) xs
      "map/append" forall f xs ys. map f (xs ++ ys) = map f xs ++ map f ys
  #-}
</pre> <p>Furthermore, the closing <code>#-}</code> should start in a column to the right of the opening <code>{-#</code>.</p> </li> <li>Each rule has a name, enclosed in double quotes. The name itself has no significance at all. It is only used when reporting how many times the rule fired. </li> <li>
<p class="first">A rule may optionally have a phase-control number (see <a class="reference internal" href="#phase-control"><span class="std std-ref">Phase control</span></a>), immediately after the name of the rule. Thus:</p> <pre data-language="haskell">{-# RULES
      "map/map" [2]  forall f g xs. map f (map g xs) = map (f.g) xs
  #-}
</pre> <p>The <code>[2]</code> means that the rule is active in Phase 2 and subsequent phases. The inverse notation <code>[~2]</code> is also accepted, meaning that the rule is active up to, but not including, Phase 2.</p> <p>Rules support the special phase-control notation <code>[~]</code>, which means the rule is never active. This feature supports plugins (see <a class="reference internal" href="extending_ghc#compiler-plugins"><span class="std std-ref">Compiler Plugins</span></a>), by making it possible to define a RULE that is never run by GHC, but is nevertheless parsed, typechecked etc, so that it is available to the plugin.</p> </li> <li>Each (term) variable mentioned in a rule must either be in scope (e.g. <code>map</code>), or bound by the <code>forall</code> (e.g. <code>f</code>, <code>g</code>, <code>xs</code>). The variables bound by the <code>forall</code> are called the <em>pattern</em> variables. They are separated by spaces, just like in a type <code>forall</code>. </li> <li>
<p class="first">A pattern variable may optionally have a type signature. If the type of the pattern variable is polymorphic, it <em>must</em> have a type signature. For example, here is the <code>foldr/build</code> rule:</p> <pre data-language="haskell">"fold/build"  forall k z (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
              foldr k z (build g) = g k z
</pre> <p>Since <code>g</code> has a polymorphic type, it must have a type signature.</p> </li> <li>
<p class="first">If <a class="reference internal" href="#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is enabled, type/kind variables can also be explicitly bound. For example:</p> <pre data-language="haskell">{-# RULES "id" forall a. forall (x :: a). id @a x = x #-}
</pre> <p>When a type-level explicit <code>forall</code> is present, each type/kind variable mentioned must now also be either in scope or bound by the <code>forall</code>. In particular, unlike some other places in Haskell, this means free kind variables will not be implicitly bound. For example:</p> <pre data-language="haskell">"this_is_bad" forall (c :: k). forall (x :: Proxy c) ...
"this_is_ok"  forall k (c :: k). forall (x :: Proxy c) ...
</pre> <p>When bound type/kind variables are needed, both foralls must always be included, though if no pattern variables are needed, the second can be left empty. For example:</p> <pre data-language="haskell">{-# RULES "map/id" forall a. forall. map (id @a) = id @[a] #-}
</pre> </li> <li>
<p class="first">The left hand side of a rule must consist of a top-level variable applied to arbitrary expressions. For example, this is <em>not</em> OK:</p> <pre data-language="haskell">"wrong1"   forall e1 e2.  case True of { True -&gt; e1; False -&gt; e2 } = e1
"wrong2"   forall f.      f True = True
"wrong3"   forall x.      Just x = Nothing
</pre> <p>In <code>"wrong1"</code>, the LHS is not an application; in <code>"wrong2"</code>, the LHS has a pattern variable in the head. In <code>"wrong3"</code>, the LHS consists of a <em>constructor</em>, rather than a <em>variable</em>, applied to an argument.</p> </li> <li>A rule does not need to be in the same module as (any of) the variables it mentions, though of course they need to be in scope. </li> <li>All rules are implicitly exported from the module, and are therefore in force in any module that imports the module that defined the rule, directly or indirectly. (That is, if A imports B, which imports C, then C’s rules are in force when compiling A.) The situation is very similar to that for instance declarations. </li> <li>Inside a <code>RULE</code> “<code>forall</code>” is treated as a keyword, regardless of any other flag settings. Furthermore, inside a RULE, the language extension <a class="reference internal" href="#extension-ScopedTypeVariables"><code>ScopedTypeVariables</code></a> is automatically enabled; see <a class="reference internal" href="#scoped-type-variables"><span class="std std-ref">Lexically scoped type variables</span></a>. </li> <li>Like other pragmas, <code>RULE</code> pragmas are always checked for scope errors, and are typechecked. Typechecking means that the LHS and RHS of a rule are typechecked, and must have the same type. However, rules are only <em>enabled</em> if the <a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code>-fenable-rewrite-rules</code></a> flag is on (see <a class="reference internal" href="#rule-semantics"><span class="std std-ref">Semantics</span></a>). </li> </ul>   <h2 id="rule-semantics">11.33.2. Semantics</h2> <p id="semantics">From a semantic point of view:</p> <ul> <li>Rules are enabled (that is, used during optimisation) by the <a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code>-fenable-rewrite-rules</code></a> flag. This flag is implied by <a class="reference internal" href="using-optimisation#ghc-flag--O"><code>-O</code></a>, and may be switched off (as usual) by <a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code>-fno-enable-rewrite-rules</code></a>. (NB: enabling <a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code>-fenable-rewrite-rules</code></a> without <a class="reference internal" href="using-optimisation#ghc-flag--O"><code>-O</code></a> may not do what you expect, though, because without <a class="reference internal" href="using-optimisation#ghc-flag--O"><code>-O</code></a> GHC ignores all optimisation information in interface files; see <a class="reference internal" href="using-optimisation#ghc-flag--fignore-interface-pragmas"><code>-fignore-interface-pragmas</code></a>). Note that <a class="reference internal" href="#ghc-flag--fenable-rewrite-rules"><code>-fenable-rewrite-rules</code></a> is an <em>optimisation</em> flag, and has no effect on parsing or typechecking. </li> <li>Rules are regarded as left-to-right rewrite rules. When GHC finds an expression that is a substitution instance of the LHS of a rule, it replaces the expression by the (appropriately-substituted) RHS. By “a substitution instance” we mean that the LHS can be made equal to the expression by substituting for the pattern variables. </li> <li>GHC makes absolutely no attempt to verify that the LHS and RHS of a rule have the same meaning. That is undecidable in general, and infeasible in most interesting cases. The responsibility is entirely the programmer’s! </li> <li>
<p class="first">GHC makes no attempt to make sure that the rules are confluent or terminating. For example:</p> <pre data-language="haskell">"loop"        forall x y.  f x y = f y x
</pre> <p>This rule will cause the compiler to go into an infinite loop.</p> </li> <li>If more than one rule matches a call, GHC will choose one arbitrarily to apply. </li> <li>
<p class="first">GHC currently uses a very simple, syntactic, matching algorithm for matching a rule LHS with an expression. It seeks a substitution which makes the LHS and expression syntactically equal modulo alpha conversion. The pattern (rule), but not the expression, is eta-expanded if necessary. (Eta-expanding the expression can lead to laziness bugs.) But not beta conversion (that’s called higher-order matching).</p> <p>Matching is carried out on GHC’s intermediate language, which includes type abstractions and applications. So a rule only matches if the types match too. See <a class="reference internal" href="#rule-spec"><span class="std std-ref">Specialisation</span></a> below.</p> </li> <li>
<p class="first">GHC keeps trying to apply the rules as it optimises the program. For example, consider:</p> <pre data-language="haskell">let s = map f
    t = map g
in
s (t xs)
</pre> <p>The expression <code>s (t xs)</code> does not match the rule <code>"map/map"</code>, but GHC will substitute for <code>s</code> and <code>t</code>, giving an expression which does match. If <code>s</code> or <code>t</code> was (a) used more than once, and (b) large or a redex, then it would not be substituted, and the rule would not fire.</p> </li> </ul>   <h2 id="rules-inline">11.33.3. How rules interact with <code>INLINE</code>/<code>NOINLINE</code> pragmas</h2> <p id="how-rules-interact-with-inline-noinline-pragmas">Ordinary inlining happens at the same time as rule rewriting, which may lead to unexpected results. Consider this (artificial) example</p> <pre data-language="haskell">f x = x
g y = f y
h z = g True

{-# RULES "f" f True = False #-}
</pre> <p>Since <code>f</code>‘s right-hand side is small, it is inlined into <code>g</code>, to give</p> <pre data-language="haskell">g y = y
</pre> <p>Now <code>g</code> is inlined into <code>h</code>, but <code>f</code>‘s <code>RULE</code> has no chance to fire. If instead GHC had first inlined <code>g</code> into <code>h</code> then there would have been a better chance that <code>f</code>‘s <code>RULE</code> might fire.</p> <p>The way to get predictable behaviour is to use a <a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a> pragma, or an INLINE[⟨phase⟩] pragma, on <code>f</code>, to ensure that it is not inlined until its RULEs have had a chance to fire. The warning flag <a class="reference internal" href="using-warnings#ghc-flag--Winline-rule-shadowing"><code>-Winline-rule-shadowing</code></a> (see <a class="reference internal" href="using-warnings#options-sanity"><span class="std std-ref">Warnings and sanity-checking</span></a>) warns about this situation.</p>   <h2 id="conlike">11.33.4. How rules interact with <code>CONLIKE</code> pragmas</h2> <p id="how-rules-interact-with-conlike-pragmas">GHC is very cautious about duplicating work. For example, consider</p> <pre data-language="haskell">f k z xs = let xs = build g
           in ...(foldr k z xs)...sum xs...
{-# RULES "foldr/build" forall k z g. foldr k z (build g) = g k z #-}
</pre> <p>Since <code>xs</code> is used twice, GHC does not fire the foldr/build rule. Rightly so, because it might take a lot of work to compute <code>xs</code>, which would be duplicated if the rule fired.</p> <p>Sometimes, however, this approach is over-cautious, and we <em>do</em> want the rule to fire, even though doing so would duplicate redex. There is no way that GHC can work out when this is a good idea, so we provide the <code>CONLIKE</code> pragma to declare it, thus:</p> <pre data-language="haskell">{-# INLINE CONLIKE [1] f #-}
f x = blah
</pre> <p><code>CONLIKE</code> is a modifier to an <code>INLINE</code> or <code>NOINLINE</code> pragma. It specifies that an application of <code>f</code> to one argument (in general, the number of arguments to the left of the <code>=</code> sign) should be considered cheap enough to duplicate, if such a duplication would make rule fire. (The name “CONLIKE” is short for “constructor-like”, because constructors certainly have such a property.) The <code>CONLIKE</code> pragma is a modifier to <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a>/<a class="reference internal" href="#pragma-NOINLINE"><code>NOINLINE</code></a> because it really only makes sense to match <code>f</code> on the LHS of a rule if you are sure that <code>f</code> is not going to be inlined before the rule has a chance to fire.</p>   <h2 id="rules-class-methods">11.33.5. How rules interact with class methods</h2> <p id="how-rules-interact-with-class-methods">Giving a RULE for a class method is a bad idea:</p> <pre data-language="haskell">class C a where
  op :: a -&gt; a -&gt; a

instance C Bool where
  op x y = ...rhs for op at Bool...

{-# RULES "f" op True y = False #-}
</pre> <p>In this example, <code>op</code> is not an ordinary top-level function; it is a class method. GHC rapidly rewrites any occurrences of <code>op</code>-used-at-type-Bool to a specialised function, say <code>opBool</code>, where</p> <pre data-language="haskell">opBool :: Bool -&gt; Bool -&gt; Bool
opBool x y = ..rhs for op at Bool...
</pre> <p>So the RULE never has a chance to fire, for just the same reasons as in <a class="reference internal" href="#rules-inline"><span class="std std-ref">How rules interact with INLINE/NOINLINE pragmas</span></a>.</p> <p>The solution is to define the instance-specific function yourself, with a pragma to prevent it being inlined too early, and give a RULE for it:</p> <pre data-language="haskell">instance C Bool where
  op = opBool

opBool :: Bool -&gt; Bool -&gt; Bool
{-# NOINLINE [1] opBool #-}
opBool x y = ..rhs for op at Bool...

{-# RULES "f" opBool True y = False #-}
</pre> <p>If you want a RULE that truly applies to the overloaded class method, the only way to do it is like this:</p> <pre data-language="haskell">class C a where
  op_c :: a -&gt; a -&gt; a

op :: C a =&gt; a -&gt; a -&gt; a
{-# NOINLINE [1] op #-}
op = op_c

{-# RULES "reassociate" op (op x y) z = op x (op y z) #-}
</pre> <p>Now the inlining of <code>op</code> is delayed until the rule has a chance to fire. The down-side is that instance declarations must define <code>op_c</code>, but all other uses should go via <code>op</code>.</p>   <h2 id="list-fusion">11.33.6. List fusion</h2> <p>The RULES mechanism is used to implement fusion (deforestation) of common list functions. If a “good consumer” consumes an intermediate list constructed by a “good producer”, the intermediate list should be eliminated entirely.</p> <p>The following are good producers:</p> <ul class="simple"> <li>List comprehensions</li> <li>Enumerations of <code>Int</code>, <code>Integer</code> and <code>Char</code> (e.g. <code>['a'..'z']</code>).</li> <li>Explicit lists (e.g. <code>[True, False]</code>)</li> <li>The cons constructor (e.g <code>3:4:[]</code>)</li> <li><code>++</code></li> <li><code>map</code></li> <li>
<code>take</code>, <code>filter</code>
</li> <li>
<code>iterate</code>, <code>repeat</code>
</li> <li>
<code>zip</code>, <code>zipWith</code>
</li> </ul> <p>The following are good consumers:</p> <ul class="simple"> <li>List comprehensions</li> <li>
<code>array</code> (on its second argument)</li> <li>
<code>++</code> (on its first argument)</li> <li><code>foldr</code></li> <li><code>map</code></li> <li>
<code>take</code>, <code>filter</code>
</li> <li><code>concat</code></li> <li>
<code>unzip</code>, <code>unzip2</code>, <code>unzip3</code>, <code>unzip4</code>
</li> <li>
<code>zip</code>, <code>zipWith</code> (but on one argument only; if both are good producers, <code>zip</code> will fuse with one but not the other)</li> <li><code>partition</code></li> <li><code>head</code></li> <li>
<code>and</code>, <code>or</code>, <code>any</code>, <code>all</code>
</li> <li><code>sequence_</code></li> <li><code>msum</code></li> </ul> <p>So, for example, the following should generate no intermediate lists:</p> <pre data-language="haskell">array (1,10) [(i,i*i) | i &lt;- map (+ 1) [0..9]]
</pre> <p>This list could readily be extended; if there are Prelude functions that you use a lot which are not included, please tell us.</p> <p>If you want to write your own good consumers or producers, look at the Prelude definitions of the above functions to see how to do so.</p>   <h2 id="rule-spec">11.33.7. Specialisation</h2> <p id="specialisation">Rewrite rules can be used to get the same effect as a feature present in earlier versions of GHC. For example, suppose that:</p> <pre data-language="haskell">genericLookup :: Ord a =&gt; Table a b   -&gt; a   -&gt; b
intLookup     ::          Table Int b -&gt; Int -&gt; b
</pre> <p>where <code>intLookup</code> is an implementation of <code>genericLookup</code> that works very fast for keys of type <code>Int</code>. You might wish to tell GHC to use <code>intLookup</code> instead of <code>genericLookup</code> whenever the latter was called with type <code>Table Int b -&gt; Int -&gt; b</code>. It used to be possible to write</p> <pre data-language="haskell">{-# SPECIALIZE genericLookup :: Table Int b -&gt; Int -&gt; b = intLookup #-}
</pre> <p>This feature is no longer in GHC, but rewrite rules let you do the same thing:</p> <pre data-language="haskell">{-# RULES "genericLookup/Int" genericLookup = intLookup #-}
</pre> <p>This slightly odd-looking rule instructs GHC to replace <code>genericLookup</code> by <code>intLookup</code> <em>whenever the types match</em>. What is more, this rule does not need to be in the same file as <code>genericLookup</code>, unlike the <code>SPECIALIZE</code> pragmas which currently do (so that they have an original definition available to specialise).</p> <p>It is <em>Your Responsibility</em> to make sure that <code>intLookup</code> really behaves as a specialised version of <code>genericLookup</code>!!!</p> <p>An example in which using <code>RULES</code> for specialisation will Win Big:</p> <pre data-language="haskell">toDouble :: Real a =&gt; a -&gt; Double
toDouble = fromRational . toRational

{-# RULES "toDouble/Int" toDouble = i2d #-}
i2d (I# i) = D# (int2Double# i) -- uses Glasgow prim-op directly
</pre> <p>The <code>i2d</code> function is virtually one machine instruction; the default conversion—via an intermediate <code>Rational</code>-is obscenely expensive by comparison.</p>   <h2 id="controlling-rules">11.33.8. Controlling what’s going on in rewrite rules</h2> <ul id="controlling-what-s-going-on-in-rewrite-rules"> <li>Use <a class="reference internal" href="debugging#ghc-flag--ddump-rules"><code>-ddump-rules</code></a> to see the rules that are defined <em>in this module</em>. This includes rules generated by the specialisation pass, but excludes rules imported from other modules. </li> <li>Use <a class="reference internal" href="debugging#ghc-flag--ddump-simpl-stats"><code>-ddump-simpl-stats</code></a> to see what rules are being fired. If you add <a class="reference internal" href="debugging#ghc-flag--dppr-debug"><code>-dppr-debug</code></a> you get a more detailed listing. </li> <li>Use <a class="reference internal" href="debugging#ghc-flag--ddump-rule-firings"><code>-ddump-rule-firings</code></a> or <a class="reference internal" href="debugging#ghc-flag--ddump-rule-rewrites"><code>-ddump-rule-rewrites</code></a> to see in great detail what rules are being fired. If you add <a class="reference internal" href="debugging#ghc-flag--dppr-debug"><code>-dppr-debug</code></a> you get a still more detailed listing. </li> <li>
<p class="first">The definition of (say) <code>build</code> in <code>GHC/Base.hs</code> looks like this:</p> <pre data-language="haskell">build   :: forall a. (forall b. (a -&gt; b -&gt; b) -&gt; b -&gt; b) -&gt; [a]
{-# INLINE build #-}
build g = g (:) []
</pre> <p>Notice the <a class="reference internal" href="#pragma-INLINE"><code>INLINE</code></a>! That prevents <code>(:)</code> from being inlined when compiling <code>PrelBase</code>, so that an importing module will “see” the <code>(:)</code>, and can match it on the LHS of a rule. <code>INLINE</code> prevents any inlining happening in the RHS of the <code>INLINE</code> thing. I regret the delicacy of this.</p> </li> <li>In <code>libraries/base/GHC/Base.hs</code> look at the rules for <code>map</code> to see how to write rules that will do fusion and yet give an efficient program even if fusion doesn’t happen. More rules in <code>GHC/List.hs</code>. </li> </ul>    <h1 id="special-ids">11.34. Special built-in functions</h1> <p id="special-built-in-functions">GHC has a few built-in functions with special behaviour. In particular:</p> <ul class="simple"> <li>
<a class="reference external" href="../libraries/base-4.13.0.0/ghc-exts#v:inline">GHC.Exts.inline</a> allows control over inlining on a per-call-site basis.</li> <li>
<a class="reference external" href="../libraries/base-4.13.0.0/ghc-exts#v:lazy">GHC.Exts.lazy</a> restrains the strictness analyser.</li> <li>
<a class="reference external" href="../libraries/base-4.13.0.0/ghc-exts#v:oneShot">GHC.Exts.oneShot</a> gives a hint to the compiler about how often a function is being called.</li> </ul>   <h1 id="id96">11.35. Generic classes</h1> <p id="generic-classes">GHC used to have an implementation of generic classes as defined in the paper “Derivable type classes”, Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp. 94-105. These have been removed and replaced by the more general <a class="reference external" href="#generic-programming">support for generic programming</a>.</p>   <h1 id="id97">11.36. Generic programming</h1> <p id="generic-programming">Using a combination of <a class="reference internal" href="#extension-DeriveGeneric"><code>DeriveGeneric</code></a>, <a class="reference internal" href="#extension-DefaultSignatures"><code>DefaultSignatures</code></a>, and <a class="reference internal" href="#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a>, you can easily do datatype-generic programming using the <a class="reference external" href="../libraries/base-4.13.0.0/ghc-generics">GHC.Generics</a> framework. This section gives a very brief overview of how to do it.</p> <p>Generic programming support in GHC allows defining classes with methods that do not need a user specification when instantiating: the method body is automatically derived by GHC. This is similar to what happens for standard classes such as <code>Read</code> and <code>Show</code>, for instance, but now for user-defined classes.</p>  <h2 id="deriving-representations">11.36.1. Deriving representations</h2> <p>The first thing we need is generic representations. The <code>GHC.Generics</code> module defines a couple of primitive types that are used to represent Haskell datatypes:</p> <pre data-language="haskell">-- | Unit: used for constructors without arguments
data U1 p = U1

-- | Constants, additional parameters and recursion of kind Type
newtype K1 i c p = K1 { unK1 :: c }

-- | Meta-information (constructor names, etc.)
newtype M1 i c f p = M1 { unM1 :: f p }

-- | Sums: encode choice between constructors
infixr 5 :+:
data (:+:) f g p = L1 (f p) | R1 (g p)

-- | Products: encode multiple arguments to constructors
infixr 6 :*:
data (:*:) f g p = f p :*: g p
</pre> <p>The <code>Generic</code> and <code>Generic1</code> classes mediate between user-defined datatypes and their internal representation as a sum-of-products:</p> <pre data-language="haskell">class Generic a where
  -- Encode the representation of a user datatype
  type Rep a :: Type -&gt; Type
  -- Convert from the datatype to its representation
  from  :: a -&gt; (Rep a) x
  -- Convert from the representation to the datatype
  to    :: (Rep a) x -&gt; a

class Generic1 (f :: k -&gt; Type) where
  type Rep1 f :: k -&gt; Type

  from1  :: f a -&gt; Rep1 f a
  to1    :: Rep1 f a -&gt; f a
</pre> <p><code>Generic1</code> is used for functions that can only be defined over type containers, such as <code>map</code>. Note that <code>Generic1</code> ranges over types of kind <code>Type -&gt; Type</code> by default, but if the <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a> extension is enabled, then it can range of types of kind <code>k -&gt; Type</code>, for any kind <code>k</code>.</p> <dl class="extension"> <dt id="extension-DeriveGeneric">
<code>DeriveGeneric</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.2.1</td> </tr>  </table> <p>Allow automatic deriving of instances for the <code>Generic</code> typeclass.</p> </dd>
</dl> <p>Instances of these classes can be derived by GHC with the <a class="reference internal" href="#extension-DeriveGeneric"><code>DeriveGeneric</code></a> extension, and are necessary to be able to define generic instances automatically.</p> <p>For example, a user-defined datatype of trees</p> <pre data-language="haskell">data UserTree a = Node a (UserTree a) (UserTree a) | Leaf
</pre> <p>in a <code>Main</code> module in a package named <code>foo</code> will get the following representation:</p> <pre data-language="haskell">instance Generic (UserTree a) where
  -- Representation type
  type Rep (UserTree a) =
    M1 D ('MetaData "UserTree" "Main" "package-name" 'False) (
          M1 C ('MetaCons "Node" 'PrefixI 'False) (
                M1 S ('MetaSel 'Nothing
                               'NoSourceUnpackedness
                               'NoSourceStrictness
                               'DecidedLazy)
                     (K1 R a)
            :*: M1 S ('MetaSel 'Nothing
                               'NoSourceUnpackedness
                               'NoSourceStrictness
                               'DecidedLazy)
                     (K1 R (UserTree a))
            :*: M1 S ('MetaSel 'Nothing
                               'NoSourceUnpackedness
                               'NoSourceStrictness
                               'DecidedLazy)
                     (K1 R (UserTree a)))
      :+: M1 C ('MetaCons "Leaf" 'PrefixI 'False) U1)

  -- Conversion functions
  from (Node x l r) = M1 (L1 (M1 (M1 (K1 x) :*: M1 (K1 l) :*: M1 (K1 r))))
  from Leaf         = M1 (R1 (M1 U1))
  to (M1 (L1 (M1 (M1 (K1 x) :*: M1 (K1 l) :*: M1 (K1 r))))) = Node x l r
  to (M1 (R1 (M1 U1)))                                      = Leaf
</pre> <p>This representation is generated automatically if a <code>deriving Generic</code> clause is attached to the datatype. <a class="reference external" href="#stand-alone-deriving">Standalone deriving</a> can also be used.</p>   <h2 id="writing-generic-functions">11.36.2. Writing generic functions</h2> <p>A generic function is defined by creating a class and giving instances for each of the representation types of <code>GHC.Generics</code>. As an example we show generic serialization:</p> <pre data-language="haskell">data Bin = O | I

class GSerialize f where
  gput :: f a -&gt; [Bin]

instance GSerialize U1 where
  gput U1 = []

instance (GSerialize a, GSerialize b) =&gt; GSerialize (a :*: b) where
  gput (x :*: y) = gput x ++ gput y

instance (GSerialize a, GSerialize b) =&gt; GSerialize (a :+: b) where
  gput (L1 x) = O : gput x
  gput (R1 x) = I : gput x

instance (GSerialize a) =&gt; GSerialize (M1 i c a) where
  gput (M1 x) = gput x

instance (Serialize a) =&gt; GSerialize (K1 i a) where
  gput (K1 x) = put x
</pre> <p>A caveat: this encoding strategy may not be reliable across different versions of GHC. When deriving a <code>Generic</code> instance is free to choose any nesting of <code>:+:</code> and <code>:*:</code> it chooses, so if GHC chooses <code>(a :+: b) :+: c</code>, then the encoding for <code>a</code> would be <code>[O, O]</code>, <code>b</code> would be <code>[O, I]</code>, and <code>c</code> would be <code>[I]</code>. However, if GHC chooses <code>a :+: (b :+: c)</code>, then the encoding for <code>a</code> would be <code>[O]</code>, <code>b</code> would be <code>[I, O]</code>, and <code>c</code> would be <code>[I, I]</code>. (In practice, the current implementation tries to produce a more-or-less balanced nesting of <code>:+:</code> and <code>:*:</code> so that the traversal of the structure of the datatype from the root to a particular component can be performed in logarithmic rather than linear time.)</p> <p>Typically this <code>GSerialize</code> class will not be exported, as it only makes sense to have instances for the representation types.</p>   <h2 id="unlifted-representation-types">11.36.3. Unlifted representation types</h2> <p>The data family <code>URec</code> is provided to enable generic programming over datatypes with certain unlifted arguments. There are six instances corresponding to common unlifted types:</p> <pre data-language="haskell">data family URec a p

data instance URec (Ptr ()) p = UAddr   { uAddr#   :: Addr#   }
data instance URec Char     p = UChar   { uChar#   :: Char#   }
data instance URec Double   p = UDouble { uDouble# :: Double# }
data instance URec Int      p = UInt    { uInt#    :: Int#    }
data instance URec Float    p = UFloat  { uFloat#  :: Float#  }
data instance URec Word     p = UWord   { uWord#   :: Word#   }
</pre> <p>Six type synonyms are provided for convenience:</p> <pre data-language="haskell">type UAddr   = URec (Ptr ())
type UChar   = URec Char
type UDouble = URec Double
type UFloat  = URec Float
type UInt    = URec Int
type UWord   = URec Word
</pre> <p>As an example, this data declaration:</p> <pre data-language="haskell">data IntHash = IntHash Int#
  deriving Generic
</pre> <p>results in the following <code>Generic</code> instance:</p> <pre data-language="haskell">instance 'Generic' IntHash where
  type 'Rep' IntHash =
    'D1' ('MetaData "IntHash" "Main" "package-name" 'False)
      ('C1' ('MetaCons "IntHash" 'PrefixI 'False)
        ('S1' ('MetaSel 'Nothing
                        'NoSourceUnpackedness
                        'NoSourceStrictness
                        'DecidedLazy)
              'UInt'))
</pre> <p>A user could provide, for example, a <code>GSerialize UInt</code> instance so that a <code>Serialize IntHash</code> instance could be easily defined in terms of <code>GSerialize</code>.</p>   <h2 id="generic-defaults">11.36.4. Generic defaults</h2> <p>The only thing left to do now is to define a “front-end” class, which is exposed to the user:</p> <pre data-language="haskell">class Serialize a where
  put :: a -&gt; [Bin]

  default put :: (Generic a, GSerialize (Rep a)) =&gt; a -&gt; [Bin]
  put = gput . from
</pre> <p>Here we use a <a class="reference external" href="#class-default-signatures">default signature</a> to specify that the user does not have to provide an implementation for <code>put</code>, as long as there is a <code>Generic</code> instance for the type to instantiate. For the <code>UserTree</code> type, for instance, the user can just write:</p> <pre data-language="haskell">instance (Serialize a) =&gt; Serialize (UserTree a)
</pre> <p>The default method for <code>put</code> is then used, corresponding to the generic implementation of serialization. If you are using <a class="reference internal" href="#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a>, the same instance is generated by simply attaching a <code>deriving Serialize</code> clause to the <code>UserTree</code> datatype declaration. For more examples of generic functions please refer to the <a class="reference external" href="http://hackage.haskell.org/package/generic-deriving">generic-deriving</a> package on Hackage.</p>   <h2 id="more-information">11.36.5. More information</h2> <p>For more details please refer to the <a class="reference external" href="http://www.haskell.org/haskellwiki/GHC.Generics">Haskell Wiki page</a> or the original paper <a class="reference internal" href="#generics2010" id="id98">[Generics2010]</a>.</p> <table class="docutils citation" frame="void" id="generics2010" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id98">[Generics2010]</a></td>
<td>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh. <a class="reference external" href="http://dreixel.net/research/pdf/gdmh.pdf">A generic deriving mechanism for Haskell</a>. Proceedings of the third ACM Haskell symposium on Haskell (Haskell‘2010), pp. 37-48, ACM, 2010.</td>
</tr>  </table>    <h1 id="id99">11.37. Roles</h1> <p id="roles">Using <a class="reference internal" href="#extension-GeneralizedNewtypeDeriving"><code>GeneralizedNewtypeDeriving</code></a> (<a class="reference internal" href="#newtype-deriving"><span class="std std-ref">Generalised derived instances for newtypes</span></a>), a programmer can take existing instances of classes and “lift” these into instances of that class for a newtype. However, this is not always safe. For example, consider the following:</p> <pre data-language="haskell">newtype Age = MkAge { unAge :: Int }

type family Inspect x
type instance Inspect Age = Int
type instance Inspect Int = Bool

class BadIdea a where
  bad :: a -&gt; Inspect a

instance BadIdea Int where
  bad = (&gt; 0)

deriving instance BadIdea Age    -- not allowed!
</pre> <p>If the derived instance were allowed, what would the type of its method <code>bad</code> be? It would seem to be <code>Age -&gt; Inspect Age</code>, which is equivalent to <code>Age -&gt; Int</code>, according to the type family <code>Inspect</code>. Yet, if we simply adapt the implementation from the instance for <code>Int</code>, the implementation for <code>bad</code> produces a <code>Bool</code>, and we have trouble.</p> <p>The way to identify such situations is to have <em>roles</em> assigned to type variables of datatypes, classes, and type synonyms.</p> <p>Roles as implemented in GHC are a from a simplified version of the work described in <a class="reference external" href="http://www.seas.upenn.edu/~sweirich/papers/popl163af-weirich.pdf">Generative type abstraction and type-level computation</a>, published at POPL 2011.</p>  <h2 id="id100">11.37.1. Nominal, Representational, and Phantom</h2> <p id="nominal-representational-and-phantom">The goal of the roles system is to track when two types have the same underlying representation. In the example above, <code>Age</code> and <code>Int</code> have the same representation. But, the corresponding instances of <code>BadIdea</code> would <em>not</em> have the same representation, because the types of the implementations of <code>bad</code> would be different.</p> <p>Suppose we have two uses of a type constructor, each applied to the same parameters except for one difference. (For example, <code>T Age Bool c</code> and <code>T Int Bool c</code> for some type <code>T</code>.) The role of a type parameter says what we need to know about the two differing type arguments in order to know that the two outer types have the same representation (in the example, what must be true about <code>Age</code> and <code>Int</code> in order to show that <code>T Age Bool c</code> has the same representation as <code>T Int Bool c</code>).</p> <p>GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If <code>T</code>‘s first parameter’s role is representational, then <code>T Age Bool c</code> and <code>T Int Bool c</code> would have the same representation, because <code>Age</code> and <code>Int</code> have the same representation.) If a type parameter has a phantom role, then we need no further information.</p> <p>Here are some examples:</p> <pre data-language="haskell">data Simple a = MkSimple a          -- a has role representational

type family F
type instance F Int = Bool
type instance F Age = Char

data Complex a = MkComplex (F a)    -- a has role nominal

data Phant a = MkPhant Bool         -- a has role phantom
</pre> <p>The type <code>Simple</code> has its parameter at role representational, which is generally the most common case. <code>Simple Age</code> would have the same representation as <code>Simple Int</code>. The type <code>Complex</code>, on the other hand, has its parameter at role nominal, because <code>Complex Age</code> and <code>Complex Int</code> are <em>not</em> the same. Lastly, <code>Phant Age</code> and <code>Phant Bool</code> have the same representation, even though <code>Age</code> and <code>Bool</code> are unrelated.</p>   <h2 id="id101">11.37.2. Role inference</h2> <p id="role-inference">What role should a given type parameter should have? GHC performs role inference to determine the correct role for every parameter. It starts with a few base facts: <code>(-&gt;)</code> has two representational parameters; <code>(~)</code> has two nominal parameters; all type families’ parameters are nominal; and all GADT-like parameters are nominal. Then, these facts are propagated to all places where these types are used. The default role for datatypes and synonyms is phantom; the default role for classes is nominal. Thus, for datatypes and synonyms, any parameters unused in the right-hand side (or used only in other types in phantom positions) will be phantom. Whenever a parameter is used in a representational position (that is, used as a type argument to a constructor whose corresponding variable is at role representational), we raise its role from phantom to representational. Similarly, when a parameter is used in a nominal position, its role is upgraded to nominal. We never downgrade a role from nominal to phantom or representational, or from representational to phantom. In this way, we infer the most-general role for each parameter.</p> <p>Classes have their roles default to nominal to promote coherence of class instances. If a <code>C Int</code> were stored in a datatype, it would be quite bad if that were somehow changed into a <code>C Age</code> somewhere, especially if another <code>C Age</code> had been declared!</p> <p>There is one particularly tricky case that should be explained:</p> <pre data-language="haskell">data Tricky a b = MkTricky (a b)
</pre> <p>What should <code>Tricky</code>‘s roles be? At first blush, it would seem that both <code>a</code> and <code>b</code> should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</p> <pre data-language="haskell">data Nom a = MkNom (F a)   -- type family F from example above
</pre> <p>Is <code>Tricky Nom Age</code> representationally equal to <code>Tricky Nom Int</code>? No! The former stores a <code>Char</code> and the latter stores a <code>Bool</code>. The solution to this is to require all parameters to type variables to have role nominal. Thus, GHC would infer role representational for <code>a</code> but role nominal for <code>b</code>.</p>   <h2 id="id102">11.37.3. Role annotations</h2> <dl class="extension" id="role-annotations"> <dt id="extension-RoleAnnotations">
<code>RoleAnnotations</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8.1</td> </tr>  </table> <p>Allow role annotation syntax.</p> </dd>
</dl> <p>Sometimes the programmer wants to constrain the inference process. For example, the base library contains the following definition:</p> <pre data-language="haskell">data Ptr a = Ptr Addr#
</pre> <p>The idea is that <code>a</code> should really be a representational parameter, but role inference assigns it to phantom. This makes some level of sense: a pointer to an <code>Int</code> really is representationally the same as a pointer to a <code>Bool</code>. But, that’s not at all how we want to use <code>Ptr</code>s! So, we want to be able to say</p> <pre data-language="haskell">type role Ptr representational
data Ptr a = Ptr Addr#
</pre> <p>The <code>type role</code> (enabled with <a class="reference internal" href="#extension-RoleAnnotations"><code>RoleAnnotations</code></a>) declaration forces the parameter <code>a</code> to be at role representational, not role phantom. GHC then checks the user-supplied roles to make sure they don’t break any promises. It would be bad, for example, if the user could make <code>BadIdea</code>‘s role be representational.</p> <p>As another example, we can consider a type <code>Set a</code> that represents a set of data, ordered according to <code>a</code>‘s <code>Ord</code> instance. While it would generally be type-safe to consider <code>a</code> to be at role representational, it is possible that a <code>newtype</code> and its base type have <em>different</em> orderings encoded in their respective <code>Ord</code> instances. This would lead to misbehavior at runtime. So, the author of the <code>Set</code> datatype would like its parameter to be at role nominal. This would be done with a declaration</p> <pre data-language="haskell">type role Set nominal
</pre> <p>Role annotations can also be used should a programmer wish to write a class with a representational (or phantom) role. However, as a class with non-nominal roles can quickly lead to class instance incoherence, it is necessary to also specify <a class="reference internal" href="#extension-IncoherentInstances"><code>IncoherentInstances</code></a> to allow non-nominal roles for classes.</p> <p>The other place where role annotations may be necessary are in <code>hs-boot</code> files (<a class="reference internal" href="separate_compilation#mutual-recursion"><span class="std std-ref">How to compile mutually recursive modules</span></a>), where the right-hand sides of definitions can be omitted. As usual, the types/classes declared in an <code>hs-boot</code> file must match up with the definitions in the <code>hs</code> file, including down to the roles. The default role for datatypes is representational in <code>hs-boot</code> files, corresponding to the common use case.</p> <p>Role annotations are allowed on data, newtype, and class declarations. A role annotation declaration starts with <code>type role</code> and is followed by one role listing for each parameter of the type. (This parameter count includes parameters implicitly specified by a kind signature in a GADT-style data or newtype declaration.) Each role listing is a role (<code>nominal</code>, <code>representational</code>, or <code>phantom</code>) or a <code>_</code>. Using a <code>_</code> says that GHC should infer that role. The role annotation may go anywhere in the same module as the datatype or class definition (much like a value-level type signature). Here are some examples:</p> <pre data-language="haskell">type role T1 _ phantom
data T1 a b = MkT1 a     -- b is not used; annotation is fine but unnecessary

type role T2 _ phantom
data T2 a b = MkT2 b     -- ERROR: b is used and cannot be phantom

type role T3 _ nominal
data T3 a b = MkT3 a     -- OK: nominal is higher than necessary, but safe

type role T4 nominal
data T4 a = MkT4 (a Int) -- OK, but nominal is higher than necessary

type role C representational _   -- OK, with -XIncoherentInstances
class C a b where ...    -- OK, b will get a nominal role

type role X nominal
type X a = ...           -- ERROR: role annotations not allowed for type synonyms
</pre>    <h1 id="id103">11.38. HasCallStack</h1> <p id="hascallstack"><code>GHC.Stack.HasCallStack</code> is a lightweight method of obtaining a partial call-stack at any point in the program.</p> <p>A function can request its call-site with the <code>HasCallStack</code> constraint and access it as a Haskell value by using <code>callStack</code>.</p> <p>One can then use functions from <code>GHC.Stack</code> to inspect or pretty print (as is done in <code>f</code> below) the call stack.</p>  <p>f :: HasCallStack =&gt; IO () f = putStrLn (prettyCallStack callStack)</p> <p>g :: HasCallStack =&gt; IO () g = f</p>  <p>Evaluating <code>f</code> directly shows a call stack with a single entry, while evaluating <code>g</code>, which also requests its call-site, shows two entries, one for each computation “annotated” with <code>HasCallStack</code>.</p> <pre data-language="none">ghci&gt; f
CallStack (from HasCallStack):
  f, called at &lt;interactive&gt;:19:1 in interactive:Ghci1
ghci&gt; g
CallStack (from HasCallStack):
  f, called at &lt;interactive&gt;:17:5 in main:Main
  g, called at &lt;interactive&gt;:20:1 in interactive:Ghci2
</pre> <p>The <code>error</code> function from the Prelude supports printing the call stack that led to the error in addition to the usual error message:</p> <pre data-language="none">ghci&gt; error "bad"
*** Exception: bad
CallStack (from HasCallStack):
  error, called at &lt;interactive&gt;:25:1 in interactive:Ghci5
</pre> <p>The call stack here consists of a single entry, pinpointing the source of the call to <code>error</code>. However, by annotating several computations with <code>HasCallStack</code>, figuring out the exact circumstances and sequences of calls that lead to a call to <code>error</code> becomes a lot easier, as demonstrated with the simple example below.</p> <pre data-language="haskell">f :: HasCallStack =&gt; IO ()
f = error "bad bad bad"

g :: HasCallStack =&gt; IO ()
g = f

h :: HasCallStack =&gt; IO ()
h = g
</pre> <pre data-language="none">ghci&gt; h
*** Exception: bad bad bad
CallStack (from HasCallStack):
  error, called at call-stack.hs:4:5 in main:Main
  f, called at call-stack.hs:7:5 in main:Main
  g, called at call-stack.hs:10:5 in main:Main
  h, called at &lt;interactive&gt;:28:1 in interactive:Ghci1
</pre> <p>The <code>CallStack</code> will only extend as far as the types allow it, for example</p> <pre data-language="haskell">myHead :: HasCallStack =&gt; [a] -&gt; a
myHead []     = errorWithCallStack "empty"
myHead (x:xs) = x

bad :: Int
bad = myHead []
</pre> <pre data-language="none">ghci&gt; bad
*** Exception: empty
CallStack (from HasCallStack):
  errorWithCallStack, called at Bad.hs:8:15 in main:Bad
  myHead, called at Bad.hs:12:7 in main:Bad
</pre> <p>includes the call-site of <code>errorWithCallStack</code> in <code>myHead</code>, and of <code>myHead</code> in <code>bad</code>, but not the call-site of <code>bad</code> at the GHCi prompt.</p> <p>GHC solves <code>HasCallStack</code> constraints in two steps:</p> <ol class="arabic simple"> <li>If there is a <code>CallStack</code> in scope – i.e. the enclosing definition has a <code>HasCallStack</code> constraint – GHC will push the new call-site onto the existing <code>CallStack</code>.</li> <li>Otherwise GHC will solve the <code>HasCallStack</code> constraint for the singleton <code>CallStack</code> containing just the current call-site.</li> </ol> <p>Importantly, GHC will <strong>never</strong> infer a <code>HasCallStack</code> constraint, you must request it explicitly.</p> <p><code>CallStack</code> is kept abstract, but GHC provides a function</p> <pre data-language="haskell">getCallStack :: CallStack -&gt; [(String, SrcLoc)]
</pre> <p>to access the individual call-sites in the stack. The <code>String</code> is the name of the function that was called, and the <code>SrcLoc</code> provides the package, module, and file name, as well as the line and column numbers.</p> <p><code>GHC.Stack</code> additionally exports a function <code>withFrozenCallStack</code> that allows users to freeze the current <code>CallStack</code>, preventing any future push operations from having an effect. This can be used by library authors to prevent <code>CallStack</code>s from exposing unnecessary implementation details. Consider the <code>myHead</code> example above, the <code>errorWithCallStack</code> line in the printed stack is not particularly enlightening, so we might choose to suppress it by freezing the <code>CallStack</code> that we pass to <code>errorWithCallStack</code>.</p> <pre data-language="haskell">myHead :: HasCallStack =&gt; [a] -&gt; a
myHead []     = withFrozenCallStack (errorWithCallStack "empty")
myHead (x:xs) = x
</pre> <pre data-language="none">ghci&gt; myHead []
*** Exception: empty
CallStack (from HasCallStack):
  myHead, called at Bad.hs:12:7 in main:Bad
</pre> <p><strong>NOTE</strong>: The intrepid user may notice that <code>HasCallStack</code> is just an alias for an implicit parameter <code>?callStack :: CallStack</code>. This is an implementation detail and <strong>should not</strong> be considered part of the <code>CallStack</code> API, we may decide to change the implementation in the future.</p>  <h2 id="compared-with-other-sources-of-stack-traces">11.38.1. Compared with other sources of stack traces</h2> <p><code>HasCallStack</code> does not interact with the RTS and does not require compilation with <code>-prof</code>. On the other hand, as the <code>CallStack</code> is built up explicitly via the <code>HasCallStack</code> constraints, it will generally not contain as much information as the simulated call-stacks maintained by the RTS.</p>   </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2002–2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/glasgow_exts.html" class="_attribution-link">https://downloads.haskell.org/~ghc/8.8.3/docs/html/users_guide/glasgow_exts.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
