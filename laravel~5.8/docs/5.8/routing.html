
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Routing - Laravel 5.8 - W3cubDocs</title>
  
  <meta name="description" content=" The most basic Laravel routes accept a URI and a Closure, providing a very simple and expressive method of defining routes&#58; ">
  <meta name="keywords" content="routing, laravel, laravel~5.8">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/laravel~5.8/docs/5.8/routing.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/laravel~5.8.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/laravel~5.8/" class="_nav-link" title="" style="margin-left:0;">Laravel 5.8</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _laravel">
				
				
<section class="docs_main">  <h1>Routing</h1> <ul> <li>
<a href="#basic-routing">Basic Routing</a> <ul> <li><a href="#redirect-routes">Redirect Routes</a></li> <li><a href="#view-routes">View Routes</a></li> </ul>
</li> <li>
<a href="#route-parameters">Route Parameters</a> <ul> <li><a href="#required-parameters">Required Parameters</a></li> <li><a href="#parameters-optional-parameters">Optional Parameters</a></li> <li><a href="#parameters-regular-expression-constraints">Regular Expression Constraints</a></li> </ul>
</li> <li><a href="#named-routes">Named Routes</a></li> <li>
<a href="#route-groups">Route Groups</a> <ul> <li><a href="#route-group-middleware">Middleware</a></li> <li><a href="#route-group-namespaces">Namespaces</a></li> <li><a href="#route-group-sub-domain-routing">Sub-Domain Routing</a></li> <li><a href="#route-group-prefixes">Route Prefixes</a></li> <li><a href="#route-group-name-prefixes">Route Name Prefixes</a></li> </ul>
</li> <li>
<a href="#route-model-binding">Route Model Binding</a> <ul> <li><a href="#implicit-binding">Implicit Binding</a></li> <li><a href="#explicit-binding">Explicit Binding</a></li> </ul>
</li> <li><a href="#fallback-routes">Fallback Routes</a></li> <li><a href="#rate-limiting">Rate Limiting</a></li> <li><a href="#form-method-spoofing">Form Method Spoofing</a></li> <li><a href="#accessing-the-current-route">Accessing The Current Route</a></li> </ul>  <h2 id="basic-routing">Basic Routing</h2> <p>The most basic Laravel routes accept a URI and a <code>Closure</code>, providing a very simple and expressive method of defining routes:</p> <pre data-language="php">Route::get('foo', function () {
    return 'Hello World';
});</pre> <h4>The Default Route Files</h4> <p>All Laravel routes are defined in your route files, which are located in the <code>routes</code> directory. These files are automatically loaded by the framework. The <code>routes/web.php</code> file defines routes that are for your web interface. These routes are assigned the <code>web</code> middleware group, which provides features like session state and CSRF protection. The routes in <code>routes/api.php</code> are stateless and are assigned the <code>api</code> middleware group.</p> <p>For most applications, you will begin by defining routes in your <code>routes/web.php</code> file. The routes defined in <code>routes/web.php</code> may be accessed by entering the defined route's URL in your browser. For example, you may access the following route by navigating to <code>http://your-app.test/user</code> in your browser:</p> <pre data-language="php">Route::get('/user', 'UserController@index');</pre> <p>Routes defined in the <code>routes/api.php</code> file are nested within a route group by the <code>RouteServiceProvider</code>. Within this group, the <code>/api</code> URI prefix is automatically applied so you do not need to manually apply it to every route in the file. You may modify the prefix and other route group options by modifying your <code>RouteServiceProvider</code> class.</p> <h4>Available Router Methods</h4> <p>The router allows you to register routes that respond to any HTTP verb:</p> <pre data-language="php">Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);</pre> <p>Sometimes you may need to register a route that responds to multiple HTTP verbs. You may do so using the <code>match</code> method. Or, you may even register a route that responds to all HTTP verbs using the <code>any</code> method:</p> <pre data-language="php">Route::match(['get', 'post'], '/', function () {
    //
});

Route::any('/', function () {
    //
});</pre> <h4>CSRF Protection</h4> <p>Any HTML forms pointing to <code>POST</code>, <code>PUT</code>, or <code>DELETE</code> routes that are defined in the <code>web</code> routes file should include a CSRF token field. Otherwise, the request will be rejected. You can read more about CSRF protection in the <a href="csrf">CSRF documentation</a>:</p> <pre data-language="php">&lt;form method="POST" action="/profile"&gt;
    @csrf
    ...
&lt;/form&gt;</pre>  <h3 id="redirect-routes">Redirect Routes</h3> <p>If you are defining a route that redirects to another URI, you may use the <code>Route::redirect</code> method. This method provides a convenient shortcut so that you do not have to define a full route or controller for performing a simple redirect:</p> <pre data-language="php">Route::redirect('/here', '/there');</pre> <p>By default, <code>Route::redirect</code> returns a <code>302</code> status code. You may customize the status code using the optional third parameter:</p> <pre data-language="php">Route::redirect('/here', '/there', 301);</pre> <p>You may use the <code>Route::permanentRedirect</code> method to return a <code>301</code> status code:</p> <pre data-language="php">Route::permanentRedirect('/here', '/there');</pre>  <h3 id="view-routes">View Routes</h3> <p>If your route only needs to return a view, you may use the <code>Route::view</code> method. Like the <code>redirect</code> method, this method provides a simple shortcut so that you do not have to define a full route or controller. The <code>view</code> method accepts a URI as its first argument and a view name as its second argument. In addition, you may provide an array of data to pass to the view as an optional third argument:</p> <pre data-language="php">Route::view('/welcome', 'welcome');

Route::view('/welcome', 'welcome', ['name' =&gt; 'Taylor']);</pre>  <h2 id="route-parameters">Route Parameters</h2>  <h3 id="required-parameters">Required Parameters</h3> <p>Sometimes you will need to capture segments of the URI within your route. For example, you may need to capture a user's ID from the URL. You may do so by defining route parameters:</p> <pre data-language="php">Route::get('user/{id}', function ($id) {
    return 'User '.$id;
});</pre> <p>You may define as many route parameters as required by your route:</p> <pre data-language="php">Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) {
    //
});</pre> <p>Route parameters are always encased within <code>{}</code> braces and should consist of alphabetic characters, and may not contain a <code>-</code> character. Instead of using the <code>-</code> character, use an underscore (<code>_</code>). Route parameters are injected into route callbacks / controllers based on their order - the names of the callback / controller arguments do not matter.</p>  <h3 id="parameters-optional-parameters">Optional Parameters</h3> <p>Occasionally you may need to specify a route parameter, but make the presence of that route parameter optional. You may do so by placing a <code>?</code> mark after the parameter name. Make sure to give the route's corresponding variable a default value:</p> <pre data-language="php">Route::get('user/{name?}', function ($name = null) {
    return $name;
});

Route::get('user/{name?}', function ($name = 'John') {
    return $name;
});</pre>  <h3 id="parameters-regular-expression-constraints">Regular Expression Constraints</h3> <p>You may constrain the format of your route parameters using the <code>where</code> method on a route instance. The <code>where</code> method accepts the name of the parameter and a regular expression defining how the parameter should be constrained:</p> <pre data-language="php">Route::get('user/{name}', function ($name) {
    //
})-&gt;where('name', '[A-Za-z]+');

Route::get('user/{id}', function ($id) {
    //
})-&gt;where('id', '[0-9]+');

Route::get('user/{id}/{name}', function ($id, $name) {
    //
})-&gt;where(['id' =&gt; '[0-9]+', 'name' =&gt; '[a-z]+']);</pre>  <h4 id="parameters-global-constraints">Global Constraints</h4> <p>If you would like a route parameter to always be constrained by a given regular expression, you may use the <code>pattern</code> method. You should define these patterns in the <code>boot</code> method of your <code>RouteServiceProvider</code>:</p> <pre data-language="php">/**
 * Define your route model bindings, pattern filters, etc.
 *
 * @return void
 */
public function boot()
{
    Route::pattern('id', '[0-9]+');

    parent::boot();
}</pre> <p>Once the pattern has been defined, it is automatically applied to all routes using that parameter name:</p> <pre data-language="php">Route::get('user/{id}', function ($id) {
    // Only executed if {id} is numeric...
});</pre>  <h4 id="parameters-encoded-forward-slashes">Encoded Forward Slashes</h4> <p>The Laravel routing component allows all characters except <code>/</code>. You must explicitly allow <code>/</code> to be part of your placeholder using a <code>where</code> condition regular expression:</p> <pre data-language="php">Route::get('search/{search}', function ($search) {
    return $search;
})-&gt;where('search', '.*');</pre> <blockquote> <p>Encoded forward slashes are only supported within the last route segment.</p> </blockquote>  <h2 id="named-routes">Named Routes</h2> <p>Named routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route by chaining the <code>name</code> method onto the route definition:</p> <pre data-language="php">Route::get('user/profile', function () {
    //
})-&gt;name('profile');</pre> <p>You may also specify route names for controller actions:</p> <pre data-language="php">Route::get('user/profile', 'UserProfileController@show')-&gt;name('profile');</pre> <h4>Generating URLs To Named Routes</h4> <p>Once you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via the global <code>route</code> function:</p> <pre data-language="php">// Generating URLs...
$url = route('profile');

// Generating Redirects...
return redirect()-&gt;route('profile');</pre> <p>If the named route defines parameters, you may pass the parameters as the second argument to the <code>route</code> function. The given parameters will automatically be inserted into the URL in their correct positions:</p> <pre data-language="php">Route::get('user/{id}/profile', function ($id) {
    //
})-&gt;name('profile');

$url = route('profile', ['id' =&gt; 1]);</pre> <h4>Inspecting The Current Route</h4> <p>If you would like to determine if the current request was routed to a given named route, you may use the <code>named</code> method on a Route instance. For example, you may check the current route name from a route middleware:</p> <pre data-language="php">/**
 * Handle an incoming request.
 *
 * @param  \Illuminate\Http\Request  $request
 * @param  \Closure  $next
 * @return mixed
 */
public function handle($request, Closure $next)
{
    if ($request-&gt;route()-&gt;named('profile')) {
        //
    }

    return $next($request);
}</pre>  <h2 id="route-groups">Route Groups</h2> <p>Route groups allow you to share route attributes, such as middleware or namespaces, across a large number of routes without needing to define those attributes on each individual route. Shared attributes are specified in an array format as the first parameter to the <code>Route::group</code> method.</p> <p>Nested groups attempt to intelligently "merge" attributes with their parent group. Middleware and <code>where</code> conditions are merged while names, namespaces, and prefixes are appended. Namespace delimiters and slashes in URI prefixes are automatically added where appropriate.</p>  <h3 id="route-group-middleware">Middleware</h3> <p>To assign middleware to all routes within a group, you may use the <code>middleware</code> method before defining the group. Middleware are executed in the order they are listed in the array:</p> <pre data-language="php">Route::middleware(['first', 'second'])-&gt;group(function () {
    Route::get('/', function () {
        // Uses first &amp; second Middleware
    });

    Route::get('user/profile', function () {
        // Uses first &amp; second Middleware
    });
});</pre>  <h3 id="route-group-namespaces">Namespaces</h3> <p>Another common use-case for route groups is assigning the same PHP namespace to a group of controllers using the <code>namespace</code> method:</p> <pre data-language="php">Route::namespace('Admin')-&gt;group(function () {
    // Controllers Within The "App\Http\Controllers\Admin" Namespace
});</pre> <p>Remember, by default, the <code>RouteServiceProvider</code> includes your route files within a namespace group, allowing you to register controller routes without specifying the full <code>App\Http\Controllers</code> namespace prefix. So, you only need to specify the portion of the namespace that comes after the base <code>App\Http\Controllers</code> namespace.</p>  <h3 id="route-group-sub-domain-routing">Sub-Domain Routing</h3> <p>Route groups may also be used to handle sub-domain routing. Sub-domains may be assigned route parameters just like route URIs, allowing you to capture a portion of the sub-domain for usage in your route or controller. The sub-domain may be specified by calling the <code>domain</code> method before defining the group:</p> <pre data-language="php">Route::domain('{account}.myapp.com')-&gt;group(function () {
    Route::get('user/{id}', function ($account, $id) {
        //
    });
});</pre> <blockquote> <p>In order to ensure your sub-domain routes are reachable, you should register sub-domain routes before registering root domain routes. This will prevent root domain routes from overwriting sub-domain routes which have the same URI path.</p> </blockquote>  <h3 id="route-group-prefixes">Route Prefixes</h3> <p>The <code>prefix</code> method may be used to prefix each route in the group with a given URI. For example, you may want to prefix all route URIs within the group with <code>admin</code>:</p> <pre data-language="php">Route::prefix('admin')-&gt;group(function () {
    Route::get('users', function () {
        // Matches The "/admin/users" URL
    });
});</pre>  <h3 id="route-group-name-prefixes">Route Name Prefixes</h3> <p>The <code>name</code> method may be used to prefix each route name in the group with a given string. For example, you may want to prefix all of the grouped route's names with <code>admin</code>. The given string is prefixed to the route name exactly as it is specified, so we will be sure to provide the trailing <code>.</code> character in the prefix:</p> <pre data-language="php">Route::name('admin.')-&gt;group(function () {
    Route::get('users', function () {
        // Route assigned name "admin.users"...
    })-&gt;name('users');
});</pre>  <h2 id="route-model-binding">Route Model Binding</h2> <p>When injecting a model ID to a route or controller action, you will often query to retrieve the model that corresponds to that ID. Laravel route model binding provides a convenient way to automatically inject the model instances directly into your routes. For example, instead of injecting a user's ID, you can inject the entire <code>User</code> model instance that matches the given ID.</p>  <h3 id="implicit-binding">Implicit Binding</h3> <p>Laravel automatically resolves Eloquent models defined in routes or controller actions whose type-hinted variable names match a route segment name. For example:</p> <pre data-language="php">Route::get('api/users/{user}', function (App\User $user) {
    return $user-&gt;email;
});</pre> <p>Since the <code>$user</code> variable is type-hinted as the <code>App\User</code> Eloquent model and the variable name matches the <code>{user}</code> URI segment, Laravel will automatically inject the model instance that has an ID matching the corresponding value from the request URI. If a matching model instance is not found in the database, a 404 HTTP response will automatically be generated.</p> <h4>Customizing The Key Name</h4> <p>If you would like model binding to use a database column other than <code>id</code> when retrieving a given model class, you may override the <code>getRouteKeyName</code> method on the Eloquent model:</p> <pre data-language="php">/**
 * Get the route key for the model.
 *
 * @return string
 */
public function getRouteKeyName()
{
    return 'slug';
}</pre>  <h3 id="explicit-binding">Explicit Binding</h3> <p>To register an explicit binding, use the router's <code>model</code> method to specify the class for a given parameter. You should define your explicit model bindings in the <code>boot</code> method of the <code>RouteServiceProvider</code> class:</p> <pre data-language="php">public function boot()
{
    parent::boot();

    Route::model('user', App\User::class);
}</pre> <p>Next, define a route that contains a <code>{user}</code> parameter:</p> <pre data-language="php">Route::get('profile/{user}', function (App\User $user) {
    //
});</pre> <p>Since we have bound all <code>{user}</code> parameters to the <code>App\User</code> model, a <code>User</code> instance will be injected into the route. So, for example, a request to <code>profile/1</code> will inject the <code>User</code> instance from the database which has an ID of <code>1</code>.</p> <p>If a matching model instance is not found in the database, a 404 HTTP response will be automatically generated.</p> <h4>Customizing The Resolution Logic</h4> <p>If you wish to use your own resolution logic, you may use the <code>Route::bind</code> method. The <code>Closure</code> you pass to the <code>bind</code> method will receive the value of the URI segment and should return the instance of the class that should be injected into the route:</p> <pre data-language="php">/**
 * Bootstrap any application services.
 *
 * @return void
 */
public function boot()
{
    parent::boot();

    Route::bind('user', function ($value) {
        return App\User::where('name', $value)-&gt;first() ?? abort(404);
    });
}</pre> <p>Alternatively, you may override the <code>resolveRouteBinding</code> method on your Eloquent model. This method will receive the value of the URI segment and should return the instance of the class that should be injected into the route:</p> <pre data-language="php">/**
 * Retrieve the model for a bound value.
 *
 * @param  mixed  $value
 * @return \Illuminate\Database\Eloquent\Model|null
 */
public function resolveRouteBinding($value)
{
    return $this-&gt;where('name', $value)-&gt;first() ?? abort(404);
}</pre>  <h2 id="fallback-routes">Fallback Routes</h2> <p>Using the <code>Route::fallback</code> method, you may define a route that will be executed when no other route matches the incoming request. Typically, unhandled requests will automatically render a "404" page via your application's exception handler. However, since you may define the <code>fallback</code> route within your <code>routes/web.php</code> file, all middleware in the <code>web</code> middleware group will apply to the route. You are free to add additional middleware to this route as needed:</p> <pre data-language="php">Route::fallback(function () {
    //
});</pre> <blockquote> <p>The fallback route should always be the last route registered by your application.</p> </blockquote>  <h2 id="rate-limiting">Rate Limiting</h2> <p>Laravel includes a <a href="middleware">middleware</a> to rate limit access to routes within your application. To get started, assign the <code>throttle</code> middleware to a route or a group of routes. The <code>throttle</code> middleware accepts two parameters that determine the maximum number of requests that can be made in a given number of minutes. For example, let's specify that an authenticated user may access the following group of routes 60 times per minute:</p> <pre data-language="php">Route::middleware('auth:api', 'throttle:60,1')-&gt;group(function () {
    Route::get('/user', function () {
        //
    });
});</pre> <h4>Dynamic Rate Limiting</h4> <p>You may specify a dynamic request maximum based on an attribute of the authenticated <code>User</code> model. For example, if your <code>User</code> model contains a <code>rate_limit</code> attribute, you may pass the name of the attribute to the <code>throttle</code> middleware so that it is used to calculate the maximum request count:</p> <pre data-language="php">Route::middleware('auth:api', 'throttle:rate_limit,1')-&gt;group(function () {
    Route::get('/user', function () {
        //
    });
});</pre>  <h2 id="form-method-spoofing">Form Method Spoofing</h2> <p>HTML forms do not support <code>PUT</code>, <code>PATCH</code> or <code>DELETE</code> actions. So, when defining <code>PUT</code>, <code>PATCH</code> or <code>DELETE</code> routes that are called from an HTML form, you will need to add a hidden <code>_method</code> field to the form. The value sent with the <code>_method</code> field will be used as the HTTP request method:</p> <pre data-language="php">&lt;form action="/foo/bar" method="POST"&gt;
    &lt;input type="hidden" name="_method" value="PUT"&gt;
    &lt;input type="hidden" name="_token" value="{{ csrf_token() }}"&gt;
&lt;/form&gt;</pre> <p>You may use the <code>@method</code> Blade directive to generate the <code>_method</code> input:</p> <pre data-language="php">&lt;form action="/foo/bar" method="POST"&gt;
    @method('PUT')
    @csrf
&lt;/form&gt;</pre>  <h2 id="accessing-the-current-route">Accessing The Current Route</h2> <p>You may use the <code>current</code>, <code>currentRouteName</code>, and <code>currentRouteAction</code> methods on the <code>Route</code> facade to access information about the route handling the incoming request:</p> <pre data-language="php">$route = Route::current();

$name = Route::currentRouteName();

$action = Route::currentRouteAction();</pre> <p>Refer to the API documentation for both the <a href="../../api/5.8/illuminate/routing/router">underlying class of the Route facade</a> and <a href="../../api/5.8/illuminate/routing/route">Route instance</a> to review all accessible methods.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    © Taylor Otwell<br>Licensed under the MIT License.<br>Laravel is a trademark of Taylor Otwell.<br>
    <a href="https://laravel.com/docs/5.8/routing" class="_attribution-link">https://laravel.com/docs/5.8/routing</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
