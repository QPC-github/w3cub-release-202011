
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Bundler&#58;&#58;Molinillo&#58;&#58;Resolver&#58;&#58;Resolution - Ruby 2.7 - W3cubDocs</title>
  
  <meta name="description" content=" A specific resolution from a given {Resolver} ">
  <meta name="keywords" content="class, bundler, molinillo, resolver, resolution, ruby, ruby~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ruby~2.7/bundler/molinillo/resolver/resolution.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/ruby~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.7/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="class-Bundler::Molinillo::Resolver::Resolution" class="class"> class Bundler::Molinillo::Resolver::Resolution </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../../../object">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes">
<a class="include" href="../delegates/resolutionstate">Bundler::Molinillo::Delegates::ResolutionState</a>, <a class="include" href="../delegates/specificationprovider">Bundler::Molinillo::Delegates::SpecificationProvider</a>
</dd>
</dl> <section class="description"> <p>A specific resolution from a given {Resolver}</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="Conflict">Conflict </dt>
<dd>
<p>A conflict that the resolution process encountered @attr [Object] requirement the requirement that immediately led to the conflict @attr [{<span>String,Nil=&gt;</span>}] requirements the requirements that caused the conflict @attr [Object, nil] existing the existing spec that was in conflict with</p> <pre>the {#possibility}</pre> <p>@attr [Object] possibility_set the set of specs that was unable to be</p> <pre>activated due to a conflict.</pre> <p>@attr [Object] locked_requirement the relevant locking requirement. @attr [Array&lt;Array&lt;Object&gt;&gt;] <a href="resolution#method-i-requirement_trees"><code>requirement_trees</code></a> the different requirement</p> <pre>trees that led to every requirement for the conflicting name.</pre> <p>@attr [{String=&gt;Object}] activated_by_name the already-activated specs. @attr [Object] underlying_error an error that has occurred during resolution, and</p> <pre>will be raised at the end of it if no resolution is found.</pre> </dd>
<dt id="PossibilitySet">PossibilitySet </dt>
<dd>
<p>A collection of possibility states that share the same dependencies @attr [Array] dependencies the dependencies for this set of possibilities @attr [Array] possibilities the possibilities</p> </dd>
<dt id="UnwindDetails">UnwindDetails </dt>
<dd>
<p>Details of the state to unwind to when a conflict occurs, and the cause of the unwind @attr [Integer] state_index the index of the state to unwind to @attr [Object] state_requirement the requirement of the state we're unwinding to @attr [Array] requirement_tree for the requirement we're relaxing @attr [Array] conflicting_requirements the requirements that combined to cause the conflict @attr [Array] <a href="resolution#method-i-requirement_trees"><code>requirement_trees</code></a> for the conflict @attr [Array] requirements_unwound_to_instead array of unwind requirements that were chosen over this unwind</p> </dd>
</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-base"> <span class="method-name">base</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>@return [DependencyGraph] the base dependency graph to which</p> <pre class="ruby" data-language="ruby">dependencies should be 'locked'
</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-iteration_rate"> <span class="method-name">iteration_rate</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>@return [Integer] the number of resolver iterations in between calls to</p> <pre>{#resolver_ui}'s {UI#indicate_progress} method</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-original_requested"> <span class="method-name">original_requested</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>@return [Array] the dependencies that were explicitly required</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-resolver_ui"> <span class="method-name">resolver_ui</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>@return [UI] the <a href="../ui"><code>UI</code></a> that knows how to communicate feedback about the</p> <pre class="ruby" data-language="ruby">resolution process back to the user
</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-specification_provider"> <span class="method-name">specification_provider</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>@return [SpecificationProvider] the provider that knows about</p> <pre>dependencies, requirements, specifications, versions, etc.</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-started_at"> <span class="method-name">started_at</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>@return [Time] the time at which resolution began</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-states"> <span class="method-name">states</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>@return [Array&lt;ResolutionState&gt;] the stack of states for the resolution</p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(specification_provider, resolver_ui, requested, base)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 152
def initialize(specification_provider, resolver_ui, requested, base)
  @specification_provider = specification_provider
  @resolver_ui = resolver_ui
  @original_requested = requested
  @base = base
  @states = []
  @iteration_counter = 0
  @parents_of = Hash.new { |h, k| h[k] = [] }
end</pre> </div> <p>Initializes a new resolution. @param [SpecificationProvider] <a href="resolution#attribute-i-specification_provider"><code>specification_provider</code></a></p> <pre>see {#specification_provider}</pre> <p>@param [UI] <a href="resolution#attribute-i-resolver_ui"><code>resolver_ui</code></a> see {#resolver_ui} @param [Array] requested see {#original_requested} @param [DependencyGraph] base see {#base}</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-resolve"> <span class="method-name">resolve</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="resolve-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 167
def resolve
  start_resolution

  while state
    break if !state.requirement &amp;&amp; state.requirements.empty?
    indicate_progress
    if state.respond_to?(:pop_possibility_state) # DependencyState
      debug(depth) { "Creating possibility state for #{requirement} (#{possibilities.count} remaining)" }
      state.pop_possibility_state.tap do |s|
        if s
          states.push(s)
          activated.tag(s)
        end
      end
    end
    process_topmost_state
  end

  resolve_activated_specs
ensure
  end_resolution
end</pre> </div> <p>Resolves the {#original_requested} dependencies into a full dependency</p> <pre class="ruby" data-language="ruby">graph
</pre> <p>@raise [ResolverError] if successful resolution is impossible @return [DependencyGraph] the dependency graph of successfully resolved</p> <pre class="ruby" data-language="ruby">dependencies
</pre>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-activate_new_spec"> <span class="method-name">activate_new_spec</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="activate_new_spec-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 725
def activate_new_spec
  conflicts.delete(name)
  debug(depth) { "Activated #{name} at #{possibility}" }
  activated.set_payload(name, possibility)
  require_nested_dependencies_for(possibility)
end</pre> </div> <p>Add the current {#possibility} to the dependency graph of the current {#state} @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attempt_to_activate"> <span class="method-name">attempt_to_activate</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="attempt_to_activate-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 668
def attempt_to_activate
  debug(depth) { 'Attempting to activate ' + possibility.to_s }
  existing_vertex = activated.vertex_named(name)
  if existing_vertex.payload
    debug(depth) { "Found existing spec (#{existing_vertex.payload})" }
    attempt_to_filter_existing_spec(existing_vertex)
  else
    latest = possibility.latest_version
    # use reject!(!satisfied) for 1.8.7 compatibility
    possibility.possibilities.reject! do |possibility|
      !requirement_satisfied_by?(requirement, activated, possibility)
    end
    if possibility.latest_version.nil?
      # ensure there's a possibility for better error messages
      possibility.possibilities &lt;&lt; latest if latest
      create_conflict
      unwind_for_conflict
    else
      activate_new_spec
    end
  end
end</pre> </div> <p>Attempts to activate the current {#possibility} @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attempt_to_filter_existing_spec"> <span class="method-name">attempt_to_filter_existing_spec</span><span class="method-args">(vertex)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="attempt_to_filter_existing_spec-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 693
def attempt_to_filter_existing_spec(vertex)
  filtered_set = filtered_possibility_set(vertex)
  if !filtered_set.possibilities.empty?
    activated.set_payload(name, filtered_set)
    new_requirements = requirements.dup
    push_state_for_requirements(new_requirements, false)
  else
    create_conflict
    debug(depth) { "Unsatisfied by existing spec (#{vertex.payload})" }
    unwind_for_conflict
  end
end</pre> </div> <p>Attempts to update the existing vertex's `PossibilitySet` with a filtered version @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-binding_requirement_in_set-3F"> <span class="method-name">binding_requirement_in_set?</span><span class="method-args">(requirement, possible_binding_requirements, possibilities)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="binding_requirement_in_set-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 565
def binding_requirement_in_set?(requirement, possible_binding_requirements, possibilities)
  possibilities.any? do |poss|
    possibility_satisfies_requirements?(poss, possible_binding_requirements - [requirement])
  end
end</pre> </div> <p>@param [Object] requirement we wish to check @param [Array] array of requirements @param [Array] array of possibilities the requirements will be used to filter @return [Boolean] whether or not the given requirement is required to filter</p> <pre>out all elements of the array of possibilities.</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-binding_requirements_for_conflict"> <span class="method-name">binding_requirements_for_conflict</span><span class="method-args">(conflict)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="binding_requirements_for_conflict-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 522
def binding_requirements_for_conflict(conflict)
  return [conflict.requirement] if conflict.possibility.nil?

  possible_binding_requirements = conflict.requirements.values.flatten(1).uniq

  # When there’s a `CircularDependency` error the conflicting requirement
  # (the one causing the circular) won’t be `conflict.requirement`
  # (which won’t be for the right state, because we won’t have created it,
  # because it’s circular).
  # We need to make sure we have that requirement in the conflict’s list,
  # otherwise we won’t be able to unwind properly, so we just return all
  # the requirements for the conflict.
  return possible_binding_requirements if conflict.underlying_error

  possibilities = search_for(conflict.requirement)

  # If all the requirements together don't filter out all possibilities,
  # then the only two requirements we need to consider are the initial one
  # (where the dependency's version was first chosen) and the last
  if binding_requirement_in_set?(nil, possible_binding_requirements, possibilities)
    return [conflict.requirement, requirement_for_existing_name(name_for(conflict.requirement))].compact
  end

  # Loop through the possible binding requirements, removing each one
  # that doesn't bind. Use a `reverse_each` as we want the earliest set of
  # binding requirements, and don't use `reject!` as we wish to refine the
  # array *on each iteration*.
  binding_requirements = possible_binding_requirements.dup
  possible_binding_requirements.reverse_each do |req|
    next if req == conflict.requirement
    unless binding_requirement_in_set?(req, binding_requirements, possibilities)
      binding_requirements -= [req]
    end
  end

  binding_requirements
end</pre> </div> <p>@param [Conflict] conflict @return [Array] minimal array of requirements that would cause the passed</p> <pre>conflict to occur.</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-build_details_for_unwind"> <span class="method-name">build_details_for_unwind</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="build_details_for_unwind-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 332
def build_details_for_unwind
  # Get the possible unwinds for the current conflict
  current_conflict = conflicts[name]
  binding_requirements = binding_requirements_for_conflict(current_conflict)
  unwind_details = unwind_options_for_requirements(binding_requirements)

  last_detail_for_current_unwind = unwind_details.sort.last
  current_detail = last_detail_for_current_unwind

  # Look for past conflicts that could be unwound to affect the
  # requirement tree for the current conflict
  relevant_unused_unwinds = unused_unwind_options.select do |alternative|
    intersecting_requirements =
      last_detail_for_current_unwind.all_requirements &amp;
      alternative.requirements_unwound_to_instead
    next if intersecting_requirements.empty?
    # Find the highest index unwind whilst looping through
    current_detail = alternative if alternative &gt; current_detail
    alternative
  end

  # Add the current unwind options to the `unused_unwind_options` array.
  # The "used" option will be filtered out during `unwind_for_conflict`.
  state.unused_unwind_options += unwind_details.reject { |detail| detail.state_index == -1 }

  # Update the requirements_unwound_to_instead on any relevant unused unwinds
  relevant_unused_unwinds.each { |d| d.requirements_unwound_to_instead &lt;&lt; current_detail.state_requirement }
  unwind_details.each { |d| d.requirements_unwound_to_instead &lt;&lt; current_detail.state_requirement }

  current_detail
end</pre> </div> <p>@return [UnwindDetails] Details of the nearest index to which we could unwind</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-conflict_fixing_possibilities-3F"> <span class="method-name">conflict_fixing_possibilities?</span><span class="method-args">(state, binding_requirements)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="conflict_fixing_possibilities-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 435
def conflict_fixing_possibilities?(state, binding_requirements)
  return false unless state

  state.possibilities.any? do |possibility_set|
    possibility_set.possibilities.any? do |poss|
      possibility_satisfies_requirements?(poss, binding_requirements)
    end
  end
end</pre> </div> <p>@param [DependencyState] state @param [Array] array of requirements @return [Boolean] whether or not the given state has any possibilities</p> <pre class="ruby" data-language="ruby">that could satisfy the given requirements
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_conflict"> <span class="method-name">create_conflict</span><span class="method-args">(underlying_error = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="create_conflict-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 597
def create_conflict(underlying_error = nil)
  vertex = activated.vertex_named(name)
  locked_requirement = locked_requirement_named(name)

  requirements = {}
  unless vertex.explicit_requirements.empty?
    requirements[name_for_explicit_dependency_source] = vertex.explicit_requirements
  end
  requirements[name_for_locking_dependency_source] = [locked_requirement] if locked_requirement
  vertex.incoming_edges.each do |edge|
    (requirements[edge.origin.payload.latest_version] ||= []).unshift(edge.requirement)
  end

  activated_by_name = {}
  activated.each { |v| activated_by_name[v.name] = v.payload.latest_version if v.payload }
  conflicts[name] = Conflict.new(
    requirement,
    requirements,
    vertex.payload &amp;&amp; vertex.payload.latest_version,
    possibility,
    locked_requirement,
    requirement_trees,
    activated_by_name,
    underlying_error
  )
end</pre> </div> <p>@return [Conflict] a {Conflict} that reflects the failure to activate</p> <pre>the {#possibility} in conjunction with the current {#state}</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-debug"> <span class="method-name">debug</span><span class="method-args">(depth = 0, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="debug-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 662
def debug(depth = 0, &amp;block)
  resolver_ui.debug(depth, &amp;block)
end</pre> </div> <p>Calls the {#resolver_ui}'s {UI#debug} method @param [Integer] depth the depth of the {#states} stack @param [Proc] block a block that yields a {#to_s} @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-end_resolution"> <span class="method-name">end_resolution</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="end_resolution-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 231
def end_resolution
  resolver_ui.after_resolution
  debug do
    "Finished resolution (#{@iteration_counter} steps) " \
    "(Took #{(ended_at = Time.now) - @started_at} seconds) (#{ended_at})"
  end
  debug { 'Unactivated: ' + Hash[activated.vertices.reject { |_n, v| v.payload }].keys.join(', ') } if state
  debug { 'Activated: ' + Hash[activated.vertices.select { |_n, v| v.payload }].keys.join(', ') } if state
end</pre> </div> <p>Ends the resolution process @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-filter_possibilities_after_unwind"> <span class="method-name">filter_possibilities_after_unwind</span><span class="method-args">(unwind_details)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="filter_possibilities_after_unwind-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 449
def filter_possibilities_after_unwind(unwind_details)
  return unless state &amp;&amp; !state.possibilities.empty?

  if unwind_details.unwinding_to_primary_requirement?
    filter_possibilities_for_primary_unwind(unwind_details)
  else
    filter_possibilities_for_parent_unwind(unwind_details)
  end
end</pre> </div> <p>Filter's a state's possibilities to remove any that would not fix the conflict we've just rewound from @param [UnwindDetails] details of the conflict just unwound from @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-filter_possibilities_for_parent_unwind"> <span class="method-name">filter_possibilities_for_parent_unwind</span><span class="method-args">(unwind_details)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="filter_possibilities_for_parent_unwind-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 496
def filter_possibilities_for_parent_unwind(unwind_details)
  unwinds_to_state = unused_unwind_options.select { |uw| uw.state_index == unwind_details.state_index }
  unwinds_to_state &lt;&lt; unwind_details

  primary_unwinds = unwinds_to_state.select(&amp;:unwinding_to_primary_requirement?).uniq
  parent_unwinds = unwinds_to_state.uniq - primary_unwinds

  allowed_possibility_sets = Compatibility.flat_map(primary_unwinds) do |unwind|
    states[unwind.state_index].possibilities.select do |possibility_set|
      possibility_set.possibilities.any? do |poss|
        possibility_satisfies_requirements?(poss, unwind.conflicting_requirements)
      end
    end
  end

  requirements_to_avoid = Compatibility.flat_map(parent_unwinds, &amp;:sub_dependencies_to_avoid)

  state.possibilities.reject! do |possibility_set|
    !allowed_possibility_sets.include?(possibility_set) &amp;&amp;
      (requirements_to_avoid - possibility_set.dependencies).empty?
  end
end</pre> </div> <p>Filter's a state's possibilities to remove any that would (eventually) create a requirement in the conflict we've just rewound from @param [UnwindDetails] details of the conflict just unwound from @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-filter_possibilities_for_primary_unwind"> <span class="method-name">filter_possibilities_for_primary_unwind</span><span class="method-args">(unwind_details)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="filter_possibilities_for_primary_unwind-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 463
def filter_possibilities_for_primary_unwind(unwind_details)
  unwinds_to_state = unused_unwind_options.select { |uw| uw.state_index == unwind_details.state_index }
  unwinds_to_state &lt;&lt; unwind_details
  unwind_requirement_sets = unwinds_to_state.map(&amp;:conflicting_requirements)

  state.possibilities.reject! do |possibility_set|
    possibility_set.possibilities.none? do |poss|
      unwind_requirement_sets.any? do |requirements|
        possibility_satisfies_requirements?(poss, requirements)
      end
    end
  end
end</pre> </div> <p>Filter's a state's possibilities to remove any that would not satisfy the requirements in the conflict we've just rewound from @param [UnwindDetails] details of the conflict just unwound from @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-filtered_possibility_set"> <span class="method-name">filtered_possibility_set</span><span class="method-args">(vertex)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="filtered_possibility_set-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 710
def filtered_possibility_set(vertex)
  PossibilitySet.new(vertex.payload.dependencies, vertex.payload.possibilities &amp; possibility.possibilities)
end</pre> </div> <p>Generates a filtered version of the existing vertex's `PossibilitySet` using the current state's `requirement` @param [Object] existing vertex @return [PossibilitySet] filtered possibility set</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-find_state_for"> <span class="method-name">find_state_for</span><span class="method-args">(requirement)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="find_state_for-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 590
def find_state_for(requirement)
  return nil unless requirement
  states.find { |i| requirement == i.requirement }
end</pre> </div> <p>@return [ResolutionState] the state whose `requirement` is the given</p> <pre>`requirement`.</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-group_possibilities"> <span class="method-name">group_possibilities</span><span class="method-args">(possibilities)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="group_possibilities-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 802
def group_possibilities(possibilities)
  possibility_sets = []
  current_possibility_set = nil

  possibilities.reverse_each do |possibility|
    dependencies = dependencies_for(possibility)
    if current_possibility_set &amp;&amp; current_possibility_set.dependencies == dependencies
      current_possibility_set.possibilities.unshift(possibility)
    else
      possibility_sets.unshift(PossibilitySet.new(dependencies, [possibility]))
      current_possibility_set = possibility_sets.first
    end
  end

  possibility_sets
end</pre> </div> <p>Build an array of PossibilitySets, with each element representing a group of dependency versions that all have the same sub-dependency version constraints and are contiguous. @param [Array] an array of possibilities @return [Array] an array of possibility sets</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-handle_missing_or_push_dependency_state"> <span class="method-name">handle_missing_or_push_dependency_state</span><span class="method-args">(state)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="handle_missing_or_push_dependency_state-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 827
def handle_missing_or_push_dependency_state(state)
  if state.requirement &amp;&amp; state.possibilities.empty? &amp;&amp; allow_missing?(state.requirement)
    state.activated.detach_vertex_named(state.name)
    push_state_for_requirements(state.requirements.dup, false, state.activated)
  else
    states.push(state).tap { activated.tag(state) }
  end
end</pre> </div> <p>Pushes a new {DependencyState}. If the {#specification_provider} says to {SpecificationProvider#allow_missing?} that particular requirement, and there are no possibilities for that requirement, then `state` is not pushed, and the vertex in {#activated} is removed, and we continue resolving the remaining requirements. @param [DependencyState] state @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-indicate_progress"> <span class="method-name">indicate_progress</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="indicate_progress-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 644
def indicate_progress
  @iteration_counter += 1
  @progress_rate ||= resolver_ui.progress_rate
  if iteration_rate.nil?
    if Time.now - started_at &gt;= @progress_rate
      self.iteration_rate = @iteration_counter
    end
  end

  if iteration_rate &amp;&amp; (@iteration_counter % iteration_rate) == 0
    resolver_ui.indicate_progress
  end
end</pre> </div> <p>Indicates progress roughly once every second @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-initial_state"> <span class="method-name">initial_state</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="initial_state-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 279
def initial_state
  graph = DependencyGraph.new.tap do |dg|
    original_requested.each do |requested|
      vertex = dg.add_vertex(name_for(requested), nil, true)
      vertex.explicit_requirements &lt;&lt; requested
    end
    dg.tag(:initial_state)
  end

  requirements = sort_dependencies(original_requested, graph, {})
  initial_requirement = requirements.shift
  DependencyState.new(
    initial_requirement &amp;&amp; name_for(initial_requirement),
    requirements,
    graph,
    initial_requirement,
    possibilities_for_requirement(initial_requirement, graph),
    0,
    {},
    []
  )
end</pre> </div> <p>Creates the initial state for the resolution, based upon the {#requested} dependencies @return [DependencyState] the initial state for the resolution</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-locked_requirement_named"> <span class="method-name">locked_requirement_named</span><span class="method-args">(requirement_name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="locked_requirement_named-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 717
def locked_requirement_named(requirement_name)
  vertex = base.vertex_named(requirement_name)
  vertex &amp;&amp; vertex.payload
end</pre> </div> <p>@param [String] requirement_name the spec name to search for @return [Object] the locked spec named `requirement_name`, if one</p> <pre>is found on {#base}</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-locked_requirement_possibility_set"> <span class="method-name">locked_requirement_possibility_set</span><span class="method-args">(requirement, activated = self.activated)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="locked_requirement_possibility_set-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 783
def locked_requirement_possibility_set(requirement, activated = self.activated)
  all_possibilities = search_for(requirement)
  locked_requirement = locked_requirement_named(name_for(requirement))

  # Longwinded way to build a possibilities array with either the locked
  # requirement or nothing in it. Required, since the API for
  # locked_requirement isn't guaranteed.
  locked_possibilities = all_possibilities.select do |possibility|
    requirement_satisfied_by?(locked_requirement, activated, possibility)
  end

  group_possibilities(locked_possibilities)
end</pre> </div> <p>@param [Object] the proposed requirement @return [Array] possibility set containing only the locked requirement, if any</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parent_of"> <span class="method-name">parent_of</span><span class="method-args">(requirement)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="parent_of-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 573
def parent_of(requirement)
  return unless requirement
  return unless index = @parents_of[requirement].last
  return unless parent_state = @states[index]
  parent_state.requirement
end</pre> </div> <p>@return [Object] the requirement that led to `requirement` being added</p> <pre>to the list of requirements.</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-possibilities_for_requirement"> <span class="method-name">possibilities_for_requirement</span><span class="method-args">(requirement, activated = self.activated)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="possibilities_for_requirement-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 772
def possibilities_for_requirement(requirement, activated = self.activated)
  return [] unless requirement
  if locked_requirement_named(name_for(requirement))
    return locked_requirement_possibility_set(requirement, activated)
  end

  group_possibilities(search_for(requirement))
end</pre> </div> <p>Checks a proposed requirement with any existing locked requirement before generating an array of possibilities for it. @param [Object] the proposed requirement @return [Array] possibilities</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-possibility"> <span class="method-name">possibility</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="possibility-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 266
def possibility
  possibilities.last
end</pre> </div> <p>@return [Object] the current possibility that the resolution is trying</p> <pre class="ruby" data-language="ruby">to activate
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-possibility_satisfies_requirements-3F"> <span class="method-name">possibility_satisfies_requirements?</span><span class="method-args">(possibility, requirements)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="possibility_satisfies_requirements-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 481
def possibility_satisfies_requirements?(possibility, requirements)
  name = name_for(possibility)

  activated.tag(:swap)
  activated.set_payload(name, possibility) if activated.vertex_named(name)
  satisfied = requirements.all? { |r| requirement_satisfied_by?(r, activated, possibility) }
  activated.rewind_to(:swap)

  satisfied
end</pre> </div> <p>@param [Object] possibility a single possibility @param [Array] requirements an array of requirements @return [Boolean] whether the possibility satisfies all of the</p> <pre class="ruby" data-language="ruby">given requirements
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-process_topmost_state"> <span class="method-name">process_topmost_state</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="process_topmost_state-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 252
def process_topmost_state
  if possibility
    attempt_to_activate
  else
    create_conflict
    unwind_for_conflict
  end
rescue CircularDependencyError =&gt; underlying_error
  create_conflict(underlying_error)
  unwind_for_conflict
end</pre> </div> <p>Processes the topmost available {RequirementState} on the stack @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-push_state_for_requirements"> <span class="method-name">push_state_for_requirements</span><span class="method-args">(new_requirements, requires_sort = true, new_activated = activated)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="push_state_for_requirements-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 753
def push_state_for_requirements(new_requirements, requires_sort = true, new_activated = activated)
  new_requirements = sort_dependencies(new_requirements.uniq, new_activated, conflicts) if requires_sort
  new_requirement = nil
  loop do
    new_requirement = new_requirements.shift
    break if new_requirement.nil? || states.none? { |s| s.requirement == new_requirement }
  end
  new_name = new_requirement ? name_for(new_requirement) : ''.freeze
  possibilities = possibilities_for_requirement(new_requirement)
  handle_missing_or_push_dependency_state DependencyState.new(
    new_name, new_requirements, new_activated,
    new_requirement, possibilities, depth, conflicts.dup, unused_unwind_options.dup
  )
end</pre> </div> <p>Pushes a new {DependencyState} that encapsulates both existing and new requirements @param [Array] new_requirements @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-raise_error_unless_state"> <span class="method-name">raise_error_unless_state</span><span class="method-args">(conflicts)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="raise_error_unless_state-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 324
def raise_error_unless_state(conflicts)
  return if state

  error = conflicts.values.map(&amp;:underlying_error).compact.first
  raise error || VersionConflict.new(conflicts, specification_provider)
end</pre> </div> <p>Raises a <a href="../versionconflict"><code>VersionConflict</code></a> error, or any underlying error, if there is no current state @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-require_nested_dependencies_for"> <span class="method-name">require_nested_dependencies_for</span><span class="method-args">(possibility_set)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="require_nested_dependencies_for-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 736
def require_nested_dependencies_for(possibility_set)
  nested_dependencies = dependencies_for(possibility_set.latest_version)
  debug(depth) { "Requiring nested dependencies (#{nested_dependencies.join(', ')})" }
  nested_dependencies.each do |d|
    activated.add_child_vertex(name_for(d), nil, [name_for(possibility_set.latest_version)], d)
    parent_index = states.size - 1
    parents = @parents_of[d]
    parents &lt;&lt; parent_index if parents.empty?
  end

  push_state_for_requirements(requirements + nested_dependencies, !nested_dependencies.empty?)
end</pre> </div> <p>Requires the dependencies that the recently activated spec has @param [Object] activated_possibility the <a href="resolution/possibilityset"><code>PossibilitySet</code></a> that has just been</p> <pre class="ruby" data-language="ruby">activated
</pre> <p>@return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-requirement_for_existing_name"> <span class="method-name">requirement_for_existing_name</span><span class="method-args">(name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="requirement_for_existing_name-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 582
def requirement_for_existing_name(name)
  return nil unless vertex = activated.vertex_named(name)
  return nil unless vertex.payload
  states.find { |s| s.name == name }.requirement
end</pre> </div> <p>@return [Object] the requirement that led to a version of a possibility</p> <pre>with the given name being activated.</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-requirement_tree_for"> <span class="method-name">requirement_tree_for</span><span class="method-args">(requirement)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="requirement_tree_for-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 633
def requirement_tree_for(requirement)
  tree = []
  while requirement
    tree.unshift(requirement)
    requirement = parent_of(requirement)
  end
  tree
end</pre> </div> <p>@return [Array&lt;Object&gt;] the list of requirements that led to</p> <pre>`requirement` being required.</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-requirement_trees"> <span class="method-name">requirement_trees</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="requirement_trees-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 626
def requirement_trees
  vertex = activated.vertex_named(name)
  vertex.requirements.map { |r| requirement_tree_for(r) }
end</pre> </div> <p>@return [Array&lt;Array&lt;Object&gt;&gt;] The different requirement</p> <pre>trees that led to every requirement for the current spec.</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-resolve_activated_specs"> <span class="method-name">resolve_activated_specs</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="resolve_activated_specs-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 216
def resolve_activated_specs
  activated.vertices.each do |_, vertex|
    next unless vertex.payload

    latest_version = vertex.payload.possibilities.reverse_each.find do |possibility|
      vertex.requirements.all? { |req| requirement_satisfied_by?(req, activated, possibility) }
    end

    activated.set_payload(vertex.name, latest_version)
  end
  activated.freeze
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-start_resolution"> <span class="method-name">start_resolution</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="start_resolution-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 207
def start_resolution
  @started_at = Time.now

  handle_missing_or_push_dependency_state(initial_state)

  debug { "Starting resolution (#{@started_at})\nUser-requested dependencies: #{original_requested}" }
  resolver_ui.before_resolution
end</pre> </div> <p>Sets up the resolution process @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-state"> <span class="method-name">state</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="state-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 272
def state
  states.last
end</pre> </div> <p>@return [RequirementState] the current state the resolution is</p> <pre class="ruby" data-language="ruby">operating upon
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-unwind_for_conflict"> <span class="method-name">unwind_for_conflict</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="unwind_for_conflict-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 304
def unwind_for_conflict
  details_for_unwind = build_details_for_unwind
  unwind_options = unused_unwind_options
  debug(depth) { "Unwinding for conflict: #{requirement} to #{details_for_unwind.state_index / 2}" }
  conflicts.tap do |c|
    sliced_states = states.slice!((details_for_unwind.state_index + 1)..-1)
    raise_error_unless_state(c)
    activated.rewind_to(sliced_states.first || :initial_state) if sliced_states
    state.conflicts = c
    state.unused_unwind_options = unwind_options
    filter_possibilities_after_unwind(details_for_unwind)
    index = states.size - 1
    @parents_of.each { |_, a| a.reject! { |i| i &gt;= index } }
    state.unused_unwind_options.reject! { |uw| uw.state_index &gt;= index }
  end
end</pre> </div> <p>Unwinds the states stack because a conflict has been encountered @return [void]</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-unwind_options_for_requirements"> <span class="method-name">unwind_options_for_requirements</span><span class="method-args">(binding_requirements)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="unwind_options_for_requirements-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/molinillo/lib/molinillo/resolution.rb, line 367
def unwind_options_for_requirements(binding_requirements)
  unwind_details = []

  trees = []
  binding_requirements.reverse_each do |r|
    partial_tree = [r]
    trees &lt;&lt; partial_tree
    unwind_details &lt;&lt; UnwindDetails.new(-1, nil, partial_tree, binding_requirements, trees, [])

    # If this requirement has alternative possibilities, check if any would
    # satisfy the other requirements that created this conflict
    requirement_state = find_state_for(r)
    if conflict_fixing_possibilities?(requirement_state, binding_requirements)
      unwind_details &lt;&lt; UnwindDetails.new(
        states.index(requirement_state),
        r,
        partial_tree,
        binding_requirements,
        trees,
        []
      )
    end

    # Next, look at the parent of this requirement, and check if the requirement
    # could have been avoided if an alternative PossibilitySet had been chosen
    parent_r = parent_of(r)
    next if parent_r.nil?
    partial_tree.unshift(parent_r)
    requirement_state = find_state_for(parent_r)
    if requirement_state.possibilities.any? { |set| !set.dependencies.include?(r) }
      unwind_details &lt;&lt; UnwindDetails.new(
        states.index(requirement_state),
        parent_r,
        partial_tree,
        binding_requirements,
        trees,
        []
      )
    end

    # Finally, look at the grandparent and up of this requirement, looking
    # for any possibilities that wouldn't create their parent requirement
    grandparent_r = parent_of(parent_r)
    until grandparent_r.nil?
      partial_tree.unshift(grandparent_r)
      requirement_state = find_state_for(grandparent_r)
      if requirement_state.possibilities.any? { |set| !set.dependencies.include?(parent_r) }
        unwind_details &lt;&lt; UnwindDetails.new(
          states.index(requirement_state),
          grandparent_r,
          partial_tree,
          binding_requirements,
          trees,
          []
        )
      end
      parent_r = grandparent_r
      grandparent_r = parent_of(parent_r)
    end
  end

  unwind_details
end</pre> </div> <p>@param [Array&lt;Object&gt;] array of requirements that combine to create a conflict @return [Array&lt;UnwindDetails&gt;] array of <a href="resolution/unwinddetails"><code>UnwindDetails</code></a> that have a chance</p> <pre class="ruby" data-language="ruby">of resolving the passed requirements
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2017 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
