
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Hash - Ruby 2.7 - W3cubDocs</title>
  
  <meta name="description" content="A Hash is a dictionary-like collection of unique keys and their values. Also called associative arrays, they are similar to Arrays, but where an &hellip;">
  <meta name="keywords" content="class, hash, ruby, ruby~2.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ruby~2.7/hash.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/ruby~2.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.7/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="class-Hash" class="class"> class Hash </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="enumerable">Enumerable</a></dd>
</dl> <section class="description"> <p>A <a href="hash"><code>Hash</code></a> is a dictionary-like collection of unique keys and their values. Also called associative arrays, they are similar to Arrays, but where an <a href="array"><code>Array</code></a> uses integers as its index, a <a href="hash"><code>Hash</code></a> allows you to use any object type.</p> <p>Hashes enumerate their values in the order that the corresponding keys were inserted.</p> <p>A <a href="hash"><code>Hash</code></a> can be easily created by using its implicit form:</p> <pre class="ruby" data-language="ruby">grades = { "Jane Doe" =&gt; 10, "Jim Doe" =&gt; 6 }
</pre> <p>Hashes allow an alternate syntax for keys that are symbols. Instead of</p> <pre class="ruby" data-language="ruby">options = { :font_size =&gt; 10, :font_family =&gt; "Arial" }
</pre> <p>You could write it as:</p> <pre class="ruby" data-language="ruby">options = { font_size: 10, font_family: "Arial" }
</pre> <p>Each named key is a symbol you can access in hash:</p> <pre class="ruby" data-language="ruby">options[:font_size]  # =&gt; 10
</pre> <p>A <a href="hash"><code>Hash</code></a> can also be created through its <a href="hash#method-c-new"><code>::new</code></a> method:</p> <pre class="ruby" data-language="ruby">grades = Hash.new
grades["Dorothy Doe"] = 9
</pre> <p>Hashes have a <em>default value</em> that is returned when accessing keys that do not exist in the hash. If no default is set <code>nil</code> is used. You can set the default value by sending it as an argument to <a href="hash#method-c-new"><code>Hash.new</code></a>:</p> <pre class="ruby" data-language="ruby">grades = Hash.new(0)
</pre> <p>Or by using the <a href="hash#method-i-default-3D"><code>default=</code></a> method:</p> <pre class="ruby" data-language="ruby">grades = {"Timmy Doe" =&gt; 8}
grades.default = 0
</pre> <p>Accessing a value in a <a href="hash"><code>Hash</code></a> requires using its key:</p> <pre class="ruby" data-language="ruby">puts grades["Jane Doe"] # =&gt; 0
</pre> <h3 id="class-Hash-label-Common+Uses">Common Uses</h3> <p>Hashes are an easy way to represent data structures, such as</p> <pre class="ruby" data-language="ruby">books         = {}
books[:matz]  = "The Ruby Programming Language"
books[:black] = "The Well-Grounded Rubyist"
</pre> <p>Hashes are also commonly used as a way to have named parameters in functions. Note that no brackets are used below. If a hash is the last argument on a method call, no braces are needed, thus creating a really clean interface:</p> <pre class="ruby" data-language="ruby">Person.create(name: "John Doe", age: 27)

def self.create(params)
  @name = params[:name]
  @age  = params[:age]
end
</pre> <h3 id="class-Hash-label-Hash+Keys">
<a href="hash"><code>Hash</code></a> Keys</h3> <p>Two objects refer to the same hash key when their <code>hash</code> value is identical and the two objects are <code>eql?</code> to each other.</p> <p>A user-defined class may be used as a hash key if the <code>hash</code> and <code>eql?</code> methods are overridden to provide meaningful behavior. By default, separate instances refer to separate hash keys.</p> <p>A typical implementation of <code>hash</code> is based on the object's data while <code>eql?</code> is usually aliased to the overridden <code>==</code> method:</p> <pre class="ruby" data-language="ruby">class Book
  attr_reader :author, :title

  def initialize(author, title)
    @author = author
    @title = title
  end

  def ==(other)
    self.class === other and
      other.author == @author and
      other.title == @title
  end

  alias eql? ==

  def hash
    @author.hash ^ @title.hash # XOR
  end
end

book1 = Book.new 'matz', 'Ruby in a Nutshell'
book2 = Book.new 'matz', 'Ruby in a Nutshell'

reviews = {}

reviews[book1] = 'Great reference!'
reviews[book2] = 'Nice and compact!'

reviews.length #=&gt; 1
</pre> <p>See also <a href="object#method-i-hash"><code>Object#hash</code></a> and <a href="object#method-i-eql-3F"><code>Object#eql?</code></a></p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-5B-5D"> <span class="method-callseq"> Hash[ key, value, ... ] → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> Hash[ [ [key, value], ... ] ] → new_hash </span> </div> <div class="method-heading"> <span class="method-callseq"> Hash[ object ] → new_hash </span> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_s_create(int argc, VALUE *argv, VALUE klass)
{
    VALUE hash, tmp;

    if (argc == 1) {
        tmp = rb_hash_s_try_convert(Qnil, argv[0]);
        if (!NIL_P(tmp)) {
            hash = hash_alloc(klass);
            if (RHASH_AR_TABLE_P(tmp)) {
                ar_copy(hash, tmp);
            }
            else {
                RHASH_ST_TABLE_SET(hash, st_copy(RHASH_ST_TABLE(tmp)));
            }
            return hash;
        }

        tmp = rb_check_array_type(argv[0]);
        if (!NIL_P(tmp)) {
            long i;

            hash = hash_alloc(klass);
            for (i = 0; i &lt; RARRAY_LEN(tmp); ++i) {
                VALUE e = RARRAY_AREF(tmp, i);
                VALUE v = rb_check_array_type(e);
                VALUE key, val = Qnil;

                if (NIL_P(v)) {
                    rb_raise(rb_eArgError, "wrong element type %s at %ld (expected array)",
                             rb_builtin_class_name(e), i);
                }
                switch (RARRAY_LEN(v)) {
                  default:
                    rb_raise(rb_eArgError, "invalid number of elements (%ld for 1..2)",
                             RARRAY_LEN(v));
                  case 2:
                    val = RARRAY_AREF(v, 1);
                  case 1:
                    key = RARRAY_AREF(v, 0);
                    rb_hash_aset(hash, key, val);
                }
            }
            return hash;
        }
    }
    if (argc % 2 != 0) {
        rb_raise(rb_eArgError, "odd number of arguments for Hash");
    }

    hash = hash_alloc(klass);
    rb_hash_bulk_insert(argc, argv, hash);
    hash_verify(hash);
    return hash;
}</pre> </div> <p>Creates a new hash populated with the given objects.</p> <p>Similar to the literal <code>{ <em>key</em> =&gt; <em>value</em>, ... }</code>. In the first form, keys and values occur in pairs, so there must be an even number of arguments.</p> <p>The second and third form take a single argument which is either an array of key-value pairs or an object convertible to a hash.</p> <pre class="ruby" data-language="ruby">Hash["a", 100, "b", 200]             #=&gt; {"a"=&gt;100, "b"=&gt;200}
Hash[ [ ["a", 100], ["b", 200] ] ]   #=&gt; {"a"=&gt;100, "b"=&gt;200}
Hash["a" =&gt; 100, "b" =&gt; 200]         #=&gt; {"a"=&gt;100, "b"=&gt;200}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> new(obj) → new_hash </span> </div> <div class="method-heading"> <span class="method-callseq"> new {|hash, key| block } → new_hash </span> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
rb_hash_initialize(int argc, VALUE *argv, VALUE hash)
{
    VALUE ifnone;

    rb_hash_modify(hash);
    if (rb_block_given_p()) {
        rb_check_arity(argc, 0, 0);
        ifnone = rb_block_proc();
        SET_PROC_DEFAULT(hash, ifnone);
    }
    else {
        rb_check_arity(argc, 0, 1);
        ifnone = argc == 0 ? Qnil : argv[0];
        RHASH_SET_IFNONE(hash, ifnone);
    }

    return hash;
}</pre> </div> <p>Returns a new, empty hash. If this hash is subsequently accessed by a key that doesn't correspond to a hash entry, the value returned depends on the style of <code>new</code> used to create the hash. In the first form, the access returns <code>nil</code>. If <em>obj</em> is specified, this single object will be used for all <em>default values</em>. If a block is specified, it will be called with the hash object and the key, and should return the default value. It is the block's responsibility to store the value in the hash if required.</p> <pre class="ruby" data-language="ruby">h = Hash.new("Go Fish")
h["a"] = 100
h["b"] = 200
h["a"]           #=&gt; 100
h["c"]           #=&gt; "Go Fish"
# The following alters the single default object
h["c"].upcase!   #=&gt; "GO FISH"
h["d"]           #=&gt; "GO FISH"
h.keys           #=&gt; ["a", "b"]

# While this creates a new default object each time
h = Hash.new { |hash, key| hash[key] = "Go Fish: #{key}" }
h["c"]           #=&gt; "Go Fish: c"
h["c"].upcase!   #=&gt; "GO FISH: C"
h["d"]           #=&gt; "Go Fish: d"
h.keys           #=&gt; ["c", "d"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-ruby2_keywords_hash"> <span class="method-callseq"> ruby2_keywords_hash(hash) → hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ruby2_keywords_hash-source"> <pre class="c" data-language="c">static VALUE
rb_hash_s_ruby2_keywords_hash(VALUE dummy, VALUE hash)
{
    Check_Type(hash, T_HASH);
    hash = rb_hash_dup(hash);
    RHASH(hash)-&gt;basic.flags |= RHASH_PASS_AS_KEYWORDS;
    return hash;
}</pre> </div> <p>Duplicates a given hash and adds a ruby2_keywords flag. This method is not for casual use; debugging, researching, and some truly necessary cases like deserialization of arguments.</p> <pre class="ruby" data-language="ruby">h = {k: 1}
h = Hash.ruby2_keywords_hash(h)
def foo(k: 42)
  k
end
foo(*[h]) #=&gt; 1 with neither a warning or an error
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-ruby2_keywords_hash-3F"> <span class="method-callseq"> ruby2_keywords_hash?(hash) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ruby2_keywords_hash-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_s_ruby2_keywords_hash_p(VALUE dummy, VALUE hash)
{
    Check_Type(hash, T_HASH);
    return (RHASH(hash)-&gt;basic.flags &amp; RHASH_PASS_AS_KEYWORDS) ? Qtrue : Qfalse;
}</pre> </div> <p>Checks if a given hash is flagged by <a href="module#method-i-ruby2_keywords"><code>Module#ruby2_keywords</code></a> (or <a href="proc#method-i-ruby2_keywords"><code>Proc#ruby2_keywords</code></a>). This method is not for casual use; debugging, researching, and some truly necessary cases like serialization of arguments.</p> <pre class="ruby" data-language="ruby">ruby2_keywords def foo(*args)
  Hash.ruby2_keywords_hash?(args.last)
end
foo(k: 1)   #=&gt; true
foo({k: 1}) #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-try_convert"> <span class="method-callseq"> try_convert(obj) → hash or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="try_convert-source"> <pre class="c" data-language="c">static VALUE
rb_hash_s_try_convert(VALUE dummy, VALUE hash)
{
    return rb_check_hash_type(hash);
}</pre> </div> <p>Try to convert <em>obj</em> into a hash, using <a href="hash#method-i-to_hash"><code>to_hash</code></a> method. Returns converted hash or nil if <em>obj</em> cannot be converted for any reason.</p> <pre class="ruby" data-language="ruby">Hash.try_convert({1=&gt;2})   # =&gt; {1=&gt;2}
Hash.try_convert("1=&gt;2")   # =&gt; nil
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-3C"> <span class="method-callseq"> hash &lt; other → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-source"> <pre class="c" data-language="c">static VALUE
rb_hash_lt(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &gt;= RHASH_SIZE(other)) return Qfalse;
    return hash_le(hash, other);
}</pre> </div> <p>Returns <code>true</code> if <em>hash</em> is subset of <em>other</em>.</p> <pre class="ruby" data-language="ruby">h1 = {a:1, b:2}
h2 = {a:1, b:2, c:3}
h1 &lt; h2    #=&gt; true
h2 &lt; h1    #=&gt; false
h1 &lt; h1    #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3D"> <span class="method-callseq"> hash &lt;= other → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_le(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &gt; RHASH_SIZE(other)) return Qfalse;
    return hash_le(hash, other);
}</pre> </div> <p>Returns <code>true</code> if <em>hash</em> is subset of <em>other</em> or equals to <em>other</em>.</p> <pre class="ruby" data-language="ruby">h1 = {a:1, b:2}
h2 = {a:1, b:2, c:3}
h1 &lt;= h2   #=&gt; true
h2 &lt;= h1   #=&gt; false
h1 &lt;= h1   #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> hsh == other_hash → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_equal(VALUE hash1, VALUE hash2)
{
    return hash_equal(hash1, hash2, FALSE);
}</pre> </div> <p>Equality—Two hashes are equal if they each contain the same number of keys and if each key-value pair is equal to (according to Object#==) the corresponding elements in the other hash.</p> <pre class="ruby" data-language="ruby">h1 = { "a" =&gt; 1, "c" =&gt; 2 }
h2 = { 7 =&gt; 35, "c" =&gt; 2, "a" =&gt; 1 }
h3 = { "a" =&gt; 1, "c" =&gt; 2, 7 =&gt; 35 }
h4 = { "a" =&gt; 1, "d" =&gt; 2, "f" =&gt; 35 }
h1 == h2   #=&gt; false
h2 == h3   #=&gt; true
h3 == h4   #=&gt; false
</pre> <p>The orders of each hashes are not compared.</p> <pre class="ruby" data-language="ruby">h1 = { "a" =&gt; 1, "c" =&gt; 2 }
h2 = { "c" =&gt; 2, "a" =&gt; 1 }
h1 == h2   #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3E"> <span class="method-callseq"> hash &gt; other → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3E-source"> <pre class="c" data-language="c">static VALUE
rb_hash_gt(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &lt;= RHASH_SIZE(other)) return Qfalse;
    return hash_le(other, hash);
}</pre> </div> <p>Returns <code>true</code> if <em>other</em> is subset of <em>hash</em>.</p> <pre class="ruby" data-language="ruby">h1 = {a:1, b:2}
h2 = {a:1, b:2, c:3}
h1 &gt; h2    #=&gt; false
h2 &gt; h1    #=&gt; true
h1 &gt; h1    #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3E-3D"> <span class="method-callseq"> hash &gt;= other → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="3E-3D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_ge(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &lt; RHASH_SIZE(other)) return Qfalse;
    return hash_le(other, hash);
}</pre> </div> <p>Returns <code>true</code> if <em>other</em> is subset of <em>hash</em> or equals to <em>hash</em>.</p> <pre class="ruby" data-language="ruby">h1 = {a:1, b:2}
h2 = {a:1, b:2, c:3}
h1 &gt;= h2   #=&gt; false
h2 &gt;= h1   #=&gt; true
h1 &gt;= h1   #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> hsh[key] → value </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">VALUE
rb_hash_aref(VALUE hash, VALUE key)
{
    st_data_t val;

    if (hash_stlike_lookup(hash, key, &amp;val)) {
        return (VALUE)val;
    }
    else {
        return rb_hash_default_value(hash, key);
    }
}</pre> </div> <p>Element Reference—Retrieves the <em>value</em> object corresponding to the <em>key</em> object. If not found, returns the default value (see <a href="hash#method-c-new"><code>Hash::new</code></a> for details).</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h["a"]   #=&gt; 100
h["c"]   #=&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-callseq"> hsh[key] = value → value </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="c" data-language="c">VALUE
rb_hash_aset(VALUE hash, VALUE key, VALUE val)
{
    int iter_lev = RHASH_ITER_LEV(hash);

    rb_hash_modify(hash);

    if (RHASH_TABLE_NULL_P(hash)) {
        if (iter_lev &gt; 0) no_new_key();
        ar_alloc_table(hash);
    }

    if (RHASH_TYPE(hash) == &amp;identhash || rb_obj_class(key) != rb_cString) {
        RHASH_UPDATE_ITER(hash, iter_lev, key, hash_aset, val);
    }
    else {
        RHASH_UPDATE_ITER(hash, iter_lev, key, hash_aset_str, val);
    }
    return val;
}</pre> </div> <h2 id="method-i-5B-5D-3D-label-Element+Assignment">Element Assignment</h2> <p>Associates the value given by <code>value</code> with the key given by <code>key</code>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h["a"] = 9
h["c"] = 4
h   #=&gt; {"a"=&gt;9, "b"=&gt;200, "c"=&gt;4}
h.store("d", 42) #=&gt; 42
h   #=&gt; {"a"=&gt;9, "b"=&gt;200, "c"=&gt;4, "d"=&gt;42}
</pre> <p><code>key</code> should not have its value changed while it is in use as a key (an <code>unfrozen String</code> passed as a key will be duplicated and frozen).</p> <pre class="ruby" data-language="ruby">a = "a"
b = "b".freeze
h = { a =&gt; 100, b =&gt; 200 }
h.key(100).equal? a #=&gt; false
h.key(200).equal? b #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-any-3F"> <span class="method-callseq"> any? [{ |(key, value)| block }] → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> any?(pattern) → true or false </span> </div> <div class="method-description">
<div class="method-source-code" id="any-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_any_p(int argc, VALUE *argv, VALUE hash)
{
    VALUE args[2];
    args[0] = Qfalse;

    rb_check_arity(argc, 0, 1);
    if (RHASH_EMPTY_P(hash)) return Qfalse;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        args[1] = argv[0];

        rb_hash_foreach(hash, any_p_i_pattern, (VALUE)args);
    }
    else {
        if (!rb_block_given_p()) {
            /* yields pairs, never false */
            return Qtrue;
        }
        if (rb_block_arity() &gt; 1)
            rb_hash_foreach(hash, any_p_i_fast, (VALUE)args);
        else
            rb_hash_foreach(hash, any_p_i, (VALUE)args);
    }
    return args[0];
}</pre> </div> <p>See also <a href="enumerable#method-i-any-3F"><code>Enumerable#any?</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-assoc"> <span class="method-callseq"> assoc(obj) → an_array or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="assoc-source"> <pre class="c" data-language="c">VALUE
rb_hash_assoc(VALUE hash, VALUE key)
{
    st_table *table;
    const struct st_hash_type *orighash;
    VALUE args[2];

    if (RHASH_EMPTY_P(hash)) return Qnil;

    ar_force_convert_table(hash, __FILE__, __LINE__);
    HASH_ASSERT(RHASH_ST_TABLE_P(hash));
    table = RHASH_ST_TABLE(hash);
    orighash = table-&gt;type;

    if (orighash != &amp;identhash) {
        VALUE value;
        struct reset_hash_type_arg ensure_arg;
        struct st_hash_type assochash;

        assochash.compare = assoc_cmp;
        assochash.hash = orighash-&gt;hash;
        table-&gt;type = &amp;assochash;
        args[0] = hash;
        args[1] = key;
        ensure_arg.hash = hash;
        ensure_arg.orighash = orighash;
        value = rb_ensure(lookup2_call, (VALUE)&amp;args, reset_hash_type, (VALUE)&amp;ensure_arg);
        if (value != Qundef) return rb_assoc_new(key, value);
    }

    args[0] = key;
    args[1] = Qnil;
    rb_hash_foreach(hash, assoc_i, (VALUE)args);
    return args[1];
}</pre> </div> <p>Searches through the hash comparing <em>obj</em> with the key using <code>==</code>. Returns the key-value pair (two elements array) or <code>nil</code> if no match is found. See <a href="array#method-i-assoc"><code>Array#assoc</code></a>.</p> <pre class="ruby" data-language="ruby">h = {"colors"  =&gt; ["red", "blue", "green"],
     "letters" =&gt; ["a", "b", "c" ]}
h.assoc("letters")  #=&gt; ["letters", ["a", "b", "c"]]
h.assoc("foo")      #=&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-clear"> <span class="method-callseq"> clear → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="clear-source"> <pre class="c" data-language="c">VALUE
rb_hash_clear(VALUE hash)
{
    rb_hash_modify_check(hash);

    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_hash_foreach(hash, clear_i, 0);
    }
    else if (RHASH_AR_TABLE_P(hash)) {
        ar_clear(hash);
    }
    else {
        st_clear(RHASH_ST_TABLE(hash));
    }

    return hash;
}</pre> </div> <p>Removes all key-value pairs from <em>hsh</em>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }   #=&gt; {"a"=&gt;100, "b"=&gt;200}
h.clear                          #=&gt; {}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-compact"> <span class="method-callseq"> compact → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="compact-source"> <pre class="c" data-language="c">static VALUE
rb_hash_compact(VALUE hash)
{
    VALUE result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(hash, set_if_not_nil, result);
    }
    return result;
}</pre> </div> <p>Returns a new hash with the nil values/key pairs removed</p> <pre class="ruby" data-language="ruby">h = { a: 1, b: false, c: nil }
h.compact     #=&gt; { a: 1, b: false }
h             #=&gt; { a: 1, b: false, c: nil }
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-compact-21"> <span class="method-callseq"> compact! → hsh or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="compact-21-source"> <pre class="c" data-language="c">static VALUE
rb_hash_compact_bang(VALUE hash)
{
    st_index_t n;
    rb_hash_modify_check(hash);
    n = RHASH_SIZE(hash);
    if (n) {
        rb_hash_foreach(hash, delete_if_nil, hash);
        if (n != RHASH_SIZE(hash))
            return hash;
    }
    return Qnil;
}</pre> </div> <p>Removes all nil values from the hash. Returns nil if no changes were made, otherwise returns the hash.</p> <pre class="ruby" data-language="ruby">h = { a: 1, b: false, c: nil }
h.compact!     #=&gt; { a: 1, b: false }
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-compare_by_identity"> <span class="method-callseq"> compare_by_identity → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="compare_by_identity-source"> <pre class="c" data-language="c">static VALUE
rb_hash_compare_by_id(VALUE hash)
{
    VALUE tmp;
    st_table *identtable;

    if (rb_hash_compare_by_id_p(hash)) return hash;

    rb_hash_modify_check(hash);
    ar_force_convert_table(hash, __FILE__, __LINE__);
    HASH_ASSERT(RHASH_ST_TABLE_P(hash));

    tmp = hash_alloc(0);
    identtable = rb_init_identtable_with_size(RHASH_SIZE(hash));
    RHASH_ST_TABLE_SET(tmp, identtable);
    rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);
    st_free_table(RHASH_ST_TABLE(hash));
    RHASH_ST_TABLE_SET(hash, identtable);
    RHASH_ST_CLEAR(tmp);
    rb_gc_force_recycle(tmp);

    return hash;
}</pre> </div> <p>Makes <em>hsh</em> compare its keys by their identity, i.e. it will consider exact same objects as same keys.</p> <pre class="ruby" data-language="ruby">h1 = { "a" =&gt; 100, "b" =&gt; 200, :c =&gt; "c" }
h1["a"]        #=&gt; 100
h1.compare_by_identity
h1.compare_by_identity? #=&gt; true
h1["a".dup]    #=&gt; nil  # different objects.
h1[:c]         #=&gt; "c"  # same symbols are all same.
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-compare_by_identity-3F"> <span class="method-callseq"> compare_by_identity? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="compare_by_identity-3F-source"> <pre class="c" data-language="c">MJIT_FUNC_EXPORTED VALUE
rb_hash_compare_by_id_p(VALUE hash)
{
    if (RHASH_ST_TABLE_P(hash) &amp;&amp; RHASH_ST_TABLE(hash)-&gt;type == &amp;identhash) {
        return Qtrue;
    }
    else {
        return Qfalse;
    }
}</pre> </div> <p>Returns <code>true</code> if <em>hsh</em> will compare its keys by their identity. Also see <a href="hash#method-i-compare_by_identity"><code>Hash#compare_by_identity</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-deconstruct_keys"> <span class="method-name">deconstruct_keys</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="deconstruct_keys-source"> <pre class="c" data-language="c">static VALUE
rb_hash_deconstruct_keys(VALUE hash, VALUE keys)
{
    return hash;
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-default"> <span class="method-callseq"> default(key=nil) → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default-source"> <pre class="c" data-language="c">static VALUE
rb_hash_default(int argc, VALUE *argv, VALUE hash)
{
    VALUE args[2], ifnone;

    rb_check_arity(argc, 0, 1);
    ifnone = RHASH_IFNONE(hash);
    if (FL_TEST(hash, RHASH_PROC_DEFAULT)) {
        if (argc == 0) return Qnil;
        args[0] = hash;
        args[1] = argv[0];
        return rb_funcallv(ifnone, id_yield, 2, args);
    }
    return ifnone;
}</pre> </div> <p>Returns the default value, the value that would be returned by <em><span>hsh</span></em> if <em>key</em> did not exist in <em>hsh</em>. See also <a href="hash#method-c-new"><code>Hash::new</code></a> and <a href="hash#method-i-default-3D"><code>Hash#default=</code></a>.</p> <pre class="ruby" data-language="ruby">h = Hash.new                            #=&gt; {}
h.default                               #=&gt; nil
h.default(2)                            #=&gt; nil

h = Hash.new("cat")                     #=&gt; {}
h.default                               #=&gt; "cat"
h.default(2)                            #=&gt; "cat"

h = Hash.new {|h,k| h[k] = k.to_i*10}   #=&gt; {}
h.default                               #=&gt; nil
h.default(2)                            #=&gt; 20
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-default-3D"> <span class="method-callseq"> default = obj → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default-3D-source"> <pre class="c" data-language="c">static VALUE
rb_hash_set_default(VALUE hash, VALUE ifnone)
{
    rb_hash_modify_check(hash);
    SET_DEFAULT(hash, ifnone);
    return ifnone;
}</pre> </div> <p>Sets the default value, the value returned for a key that does not exist in the hash. It is not possible to set the default to a <a href="proc"><code>Proc</code></a> that will be executed on each key lookup.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.default = "Go fish"
h["a"]     #=&gt; 100
h["z"]     #=&gt; "Go fish"
# This doesn't do what you might hope...
h.default = proc do |hash, key|
  hash[key] = key + key
end
h[2]       #=&gt; #&lt;Proc:0x401b3948@-:6&gt;
h["cat"]   #=&gt; #&lt;Proc:0x401b3948@-:6&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-default_proc"> <span class="method-callseq"> default_proc → anObject </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default_proc-source"> <pre class="c" data-language="c">static VALUE
rb_hash_default_proc(VALUE hash)
{
    if (FL_TEST(hash, RHASH_PROC_DEFAULT)) {
        return RHASH_IFNONE(hash);
    }
    return Qnil;
}</pre> </div> <p>If <a href="hash#method-c-new"><code>Hash::new</code></a> was invoked with a block, return that block, otherwise return <code>nil</code>.</p> <pre class="ruby" data-language="ruby">h = Hash.new {|h,k| h[k] = k*k }   #=&gt; {}
p = h.default_proc                 #=&gt; #&lt;Proc:0x401b3d08@-:1&gt;
a = []                             #=&gt; []
p.call(a, 2)
a                                  #=&gt; [nil, nil, 4]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-default_proc-3D"> <span class="method-callseq"> default_proc = proc_obj or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="default_proc-3D-source"> <pre class="c" data-language="c">VALUE
rb_hash_set_default_proc(VALUE hash, VALUE proc)
{
    VALUE b;

    rb_hash_modify_check(hash);
    if (NIL_P(proc)) {
        SET_DEFAULT(hash, proc);
        return proc;
    }
    b = rb_check_convert_type_with_id(proc, T_DATA, "Proc", idTo_proc);
    if (NIL_P(b) || !rb_obj_is_proc(b)) {
        rb_raise(rb_eTypeError,
                 "wrong default_proc type %s (expected Proc)",
                 rb_obj_classname(proc));
    }
    proc = b;
    SET_PROC_DEFAULT(hash, proc);
    return proc;
}</pre> </div> <p>Sets the default proc to be executed on each failed key lookup.</p> <pre class="ruby" data-language="ruby">h.default_proc = proc do |hash, key|
  hash[key] = key + key
end
h[2]       #=&gt; 4
h["cat"]   #=&gt; "catcat"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-delete"> <span class="method-callseq"> delete(key) → value </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> delete(key) {| key | block } → value </span> </div> <div class="method-description">
<div class="method-source-code" id="delete-source"> <pre class="c" data-language="c">static VALUE
rb_hash_delete_m(VALUE hash, VALUE key)
{
    VALUE val;

    rb_hash_modify_check(hash);
    val = rb_hash_delete_entry(hash, key);

    if (val != Qundef) {
        return val;
    }
    else {
        if (rb_block_given_p()) {
            return rb_yield(key);
        }
        else {
            return Qnil;
        }
    }
}</pre> </div> <p>Deletes the key-value pair and returns the value from <em>hsh</em> whose key is equal to <em>key</em>. If the key is not found, it returns <em>nil</em>. If the optional code block is given and the key is not found, pass in the key and return the result of <em>block</em>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.delete("a")                              #=&gt; 100
h.delete("z")                              #=&gt; nil
h.delete("z") { |el| "#{el} not found" }   #=&gt; "z not found"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-delete_if"> <span class="method-callseq"> delete_if {| key, value | block } → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> delete_if → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="delete_if-source"> <pre class="c" data-language="c">VALUE
rb_hash_delete_if(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_foreach(hash, delete_if_i, hash);
    }
    return hash;
}</pre> </div> <p>Deletes every key-value pair from <em>hsh</em> for which <em>block</em> evaluates to <code>true</code>.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300 }
h.delete_if {|key, value| key &gt;= "b" }   #=&gt; {"a"=&gt;100}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-dig"> <span class="method-callseq"> dig(key, ...) → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="dig-source"> <pre class="c" data-language="c">static VALUE
rb_hash_dig(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    self = rb_hash_aref(self, *argv);
    if (!--argc) return self;
    ++argv;
    return rb_obj_dig(argc, argv, self, Qnil);
}</pre> </div> <p>Extracts the nested value specified by the sequence of <em>key</em> objects by calling <code>dig</code> at each step, returning <code>nil</code> if any intermediate step is <code>nil</code>.</p> <pre class="ruby" data-language="ruby">h = { foo: {bar: {baz: 1}}}

h.dig(:foo, :bar, :baz)     #=&gt; 1
h.dig(:foo, :zot, :xyz)     #=&gt; nil

g = { foo: [10, 11, 12] }
g.dig(:foo, 1)              #=&gt; 11
g.dig(:foo, 1, 0)           #=&gt; TypeError: Integer does not have #dig method
g.dig(:foo, :bar)           #=&gt; TypeError: no implicit conversion of Symbol into Integer
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each {| key, value | block } → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_pair {| key, value | block } → hsh </span> </div> <div class="method-heading"> <span class="method-callseq"> each → an_enumerator </span> </div> <div class="method-heading"> <span class="method-callseq"> each_pair → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="c" data-language="c">static VALUE
rb_hash_each_pair(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    if (rb_block_arity() &gt; 1)
        rb_hash_foreach(hash, each_pair_i_fast, 0);
    else
        rb_hash_foreach(hash, each_pair_i, 0);
    return hash;
}</pre> </div> <p>Calls <em>block</em> once for each key in <em>hsh</em>, passing the key-value pair as parameters.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.each {|key, value| puts "#{key} is #{value}" }
</pre> <p><em>produces:</em></p> <pre class="ruby" data-language="ruby">a is 100
b is 200
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_key"> <span class="method-callseq"> each_key {| key | block } → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_key → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_key-source"> <pre class="c" data-language="c">static VALUE
rb_hash_each_key(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_foreach(hash, each_key_i, 0);
    return hash;
}</pre> </div> <p>Calls <em>block</em> once for each key in <em>hsh</em>, passing the key as a parameter.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.each_key {|key| puts key }
</pre> <p><em>produces:</em></p> <pre class="ruby" data-language="ruby">a
b
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_pair"> <span class="method-callseq"> each_pair {| key, value | block } → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_pair → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_pair-source"> <pre class="c" data-language="c">static VALUE
rb_hash_each_pair(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    if (rb_block_arity() &gt; 1)
        rb_hash_foreach(hash, each_pair_i_fast, 0);
    else
        rb_hash_foreach(hash, each_pair_i, 0);
    return hash;
}</pre> </div> <p>Calls <em>block</em> once for each key in <em>hsh</em>, passing the key-value pair as parameters.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.each {|key, value| puts "#{key} is #{value}" }
</pre> <p><em>produces:</em></p> <pre class="ruby" data-language="ruby">a is 100
b is 200
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each_value"> <span class="method-callseq"> each_value {| value | block } → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_value → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="each_value-source"> <pre class="c" data-language="c">static VALUE
rb_hash_each_value(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_foreach(hash, each_value_i, 0);
    return hash;
}</pre> </div> <p>Calls <em>block</em> once for each key in <em>hsh</em>, passing the value as a parameter.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.each_value {|value| puts value }
</pre> <p><em>produces:</em></p> <pre class="ruby" data-language="ruby">100
200
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-empty-3F"> <span class="method-callseq"> empty? → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="empty-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_empty_p(VALUE hash)
{
    return RHASH_EMPTY_P(hash) ? Qtrue : Qfalse;
}</pre> </div> <p>Returns <code>true</code> if <em>hsh</em> contains no key-value pairs.</p> <pre class="ruby" data-language="ruby">{}.empty?   #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-eql-3F"> <span class="method-callseq"> eql?(other) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="eql-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_eql(VALUE hash1, VALUE hash2)
{
    return hash_equal(hash1, hash2, TRUE);
}</pre> </div> <p>Returns <code>true</code> if <em>hash</em> and <em>other</em> are both hashes with the same content. The orders of each hashes are not compared.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fetch"> <span class="method-callseq"> fetch(key [, default] ) → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> fetch(key) {| key | block } → obj </span> </div> <div class="method-description">
<div class="method-source-code" id="fetch-source"> <pre class="c" data-language="c">static VALUE
rb_hash_fetch_m(int argc, VALUE *argv, VALUE hash)
{
    VALUE key;
    st_data_t val;
    long block_given;

    rb_check_arity(argc, 1, 2);
    key = argv[0];

    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
        rb_warn("block supersedes default value argument");
    }

    if (hash_stlike_lookup(hash, key, &amp;val)) {
        return (VALUE)val;
    }
    else {
        if (block_given) {
            return rb_yield(key);
        }
        else if (argc == 1) {
            VALUE desc = rb_protect(rb_inspect, key, 0);
            if (NIL_P(desc)) {
                desc = rb_any_to_s(key);
            }
            desc = rb_str_ellipsize(desc, 65);
            rb_key_err_raise(rb_sprintf("key not found: %"PRIsVALUE, desc), hash, key);
        }
        else {
            return argv[1];
        }
    }
}</pre> </div> <p>Returns a value from the hash for the given key. If the key can't be found, there are several options: With no other arguments, it will raise a <a href="keyerror"><code>KeyError</code></a> exception; if <em>default</em> is given, then that will be returned; if the optional code block is specified, then that will be run and its result returned.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.fetch("a")                            #=&gt; 100
h.fetch("z", "go fish")                 #=&gt; "go fish"
h.fetch("z") { |el| "go fish, #{el}"}   #=&gt; "go fish, z"
</pre> <p>The following example shows that an exception is raised if the key is not found and a default value is not supplied.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.fetch("z")
</pre> <p><em>produces:</em></p> <pre>prog.rb:2:in `fetch': key not found (KeyError)
 from prog.rb:2</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fetch_values"> <span class="method-callseq"> fetch_values(key, ...) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> fetch_values(key, ...) { |key| block } → array </span> </div> <div class="method-description">
<div class="method-source-code" id="fetch_values-source"> <pre class="c" data-language="c">VALUE
rb_hash_fetch_values(int argc, VALUE *argv, VALUE hash)
{
    VALUE result = rb_ary_new2(argc);
    long i;

    for (i=0; i&lt;argc; i++) {
        rb_ary_push(result, rb_hash_fetch(hash, argv[i]));
    }
    return result;
}</pre> </div> <p>Returns an array containing the values associated with the given keys but also raises <a href="keyerror"><code>KeyError</code></a> when one of keys can't be found. Also see <a href="hash#method-i-values_at"><code>Hash#values_at</code></a> and <a href="hash#method-i-fetch"><code>Hash#fetch</code></a>.</p> <pre class="ruby" data-language="ruby">h = { "cat" =&gt; "feline", "dog" =&gt; "canine", "cow" =&gt; "bovine" }

h.fetch_values("cow", "cat")                   #=&gt; ["bovine", "feline"]
h.fetch_values("cow", "bird")                  # raises KeyError
h.fetch_values("cow", "bird") { |k| k.upcase } #=&gt; ["bovine", "BIRD"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-filter"> <span class="method-callseq"> filter {|key, value| block} → a_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> filter → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="filter-source"> <pre class="c" data-language="c">VALUE
rb_hash_select(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(hash, select_i, result);
    }
    return result;
}</pre> </div> <p>Returns a new hash consisting of entries for which the block returns true.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300 }
h.select {|k,v| k &gt; "a"}  #=&gt; {"b" =&gt; 200, "c" =&gt; 300}
h.select {|k,v| v &lt; 200}  #=&gt; {"a" =&gt; 100}
</pre> <p><a href="hash#method-i-filter"><code>Hash#filter</code></a> is an alias for <a href="hash#method-i-select"><code>Hash#select</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-filter-21"> <span class="method-callseq"> filter! {| key, value | block } → hsh or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> filter! → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="filter-21-source"> <pre class="c" data-language="c">VALUE
rb_hash_select_bang(VALUE hash)
{
    st_index_t n;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    n = RHASH_SIZE(hash);
    if (!n) return Qnil;
    rb_hash_foreach(hash, keep_if_i, hash);
    if (n == RHASH_SIZE(hash)) return Qnil;
    return hash;
}</pre> </div> <p>Equivalent to <a href="hash#method-i-keep_if"><code>Hash#keep_if</code></a>, but returns <code>nil</code> if no changes were made.</p> <p><a href="hash#method-i-filter-21"><code>Hash#filter!</code></a> is an alias for <a href="hash#method-i-select-21"><code>Hash#select!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-flatten"> <span class="method-callseq"> flatten → an_array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> flatten(level) → an_array </span> </div> <div class="method-description">
<div class="method-source-code" id="flatten-source"> <pre class="c" data-language="c">static VALUE
rb_hash_flatten(int argc, VALUE *argv, VALUE hash)
{
    VALUE ary;

    rb_check_arity(argc, 0, 1);

    if (argc) {
        int level = NUM2INT(argv[0]);

        if (level == 0) return rb_hash_to_a(hash);

        ary = rb_ary_new_capa(RHASH_SIZE(hash) * 2);
        rb_hash_foreach(hash, flatten_i, ary);
        level--;

        if (level &gt; 0) {
            VALUE ary_flatten_level = INT2FIX(level);
            rb_funcallv(ary, id_flatten_bang, 1, &amp;ary_flatten_level);
        }
        else if (level &lt; 0) {
            /* flatten recursively */
            rb_funcallv(ary, id_flatten_bang, 0, 0);
        }
    }
    else {
        ary = rb_ary_new_capa(RHASH_SIZE(hash) * 2);
        rb_hash_foreach(hash, flatten_i, ary);
    }

    return ary;
}</pre> </div> <p>Returns a new array that is a one-dimensional flattening of this hash. That is, for every key or value that is an array, extract its elements into the new array. Unlike <a href="array#method-i-flatten"><code>Array#flatten</code></a>, this method does not flatten recursively by default. The optional <em>level</em> argument determines the level of recursion to flatten.</p> <pre class="ruby" data-language="ruby">a =  {1=&gt; "one", 2 =&gt; [2,"two"], 3 =&gt; "three"}
a.flatten    # =&gt; [1, "one", 2, [2, "two"], 3, "three"]
a.flatten(2) # =&gt; [1, "one", 2, 2, "two", 3, "three"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-has_key-3F"> <span class="method-callseq"> has_key?(key) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="has_key-3F-source"> <pre class="c" data-language="c">MJIT_FUNC_EXPORTED VALUE
rb_hash_has_key(VALUE hash, VALUE key)
{
    if (hash_stlike_lookup(hash, key, NULL)) {
        return Qtrue;
    }
    else {
        return Qfalse;
    }
}</pre> </div> <p>Returns <code>true</code> if the given key is present in <em>hsh</em>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.has_key?("a")   #=&gt; true
h.has_key?("z")   #=&gt; false
</pre> <p>Note that <a href="hash#method-i-include-3F"><code>include?</code></a> and <a href="hash#method-i-member-3F"><code>member?</code></a> do not test member equality using <code>==</code> as do other Enumerables.</p> <p>See also <a href="enumerable#method-i-include-3F"><code>Enumerable#include?</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-has_value-3F"> <span class="method-callseq"> has_value?(value) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="has_value-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_has_value(VALUE hash, VALUE val)
{
    VALUE data[2];

    data[0] = Qfalse;
    data[1] = val;
    rb_hash_foreach(hash, rb_hash_search_value, (VALUE)data);
    return data[0];
}</pre> </div> <p>Returns <code>true</code> if the given value is present for some key in <em>hsh</em>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.value?(100)   #=&gt; true
h.value?(999)   #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-hash"> <span class="method-callseq"> hash → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
rb_hash_hash(VALUE hash)
{
    st_index_t size = RHASH_SIZE(hash);
    st_index_t hval = rb_hash_start(size);
    hval = rb_hash_uint(hval, (st_index_t)rb_hash_hash);
    if (size) {
        rb_hash_foreach(hash, hash_i, (VALUE)&amp;hval);
    }
    hval = rb_hash_end(hval);
    return ST2FIX(hval);
}</pre> </div> <p>Compute a hash-code for this hash. Two hashes with the same content will have the same hash code (and will compare using <code>eql?</code>).</p> <p>See also <a href="object#method-i-hash"><code>Object#hash</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-include-3F"> <span class="method-callseq"> include?(key) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="include-3F-source"> <pre class="c" data-language="c">MJIT_FUNC_EXPORTED VALUE
rb_hash_has_key(VALUE hash, VALUE key)
{
    if (hash_stlike_lookup(hash, key, NULL)) {
        return Qtrue;
    }
    else {
        return Qfalse;
    }
}</pre> </div> <p>Returns <code>true</code> if the given key is present in <em>hsh</em>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.has_key?("a")   #=&gt; true
h.has_key?("z")   #=&gt; false
</pre> <p>Note that <a href="hash#method-i-include-3F"><code>include?</code></a> and <a href="hash#method-i-member-3F"><code>member?</code></a> do not test member equality using <code>==</code> as do other Enumerables.</p> <p>See also <a href="enumerable#method-i-include-3F"><code>Enumerable#include?</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-initialize_copy"> <span class="method-callseq"> replace(other_hash) → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="initialize_copy-source"> <pre class="c" data-language="c">static VALUE
rb_hash_replace(VALUE hash, VALUE hash2)
{
    rb_hash_modify_check(hash);
    if (hash == hash2) return hash;
    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_raise(rb_eRuntimeError, "can't replace hash during iteration");
    }
    hash2 = to_hash(hash2);

    COPY_DEFAULT(hash, hash2);

    if (RHASH_AR_TABLE_P(hash)) {
        if (RHASH_AR_TABLE_P(hash2)) {
            ar_clear(hash);
        }
        else {
            ar_free_and_clear_table(hash);
            RHASH_ST_TABLE_SET(hash, st_init_table_with_size(RHASH_TYPE(hash2), RHASH_SIZE(hash2)));
        }
    }
    else {
        if (RHASH_AR_TABLE_P(hash2)) {
            st_free_table(RHASH_ST_TABLE(hash));
            RHASH_ST_CLEAR(hash);
        }
        else {
            st_clear(RHASH_ST_TABLE(hash));
            RHASH_TBL_RAW(hash)-&gt;type = RHASH_ST_TABLE(hash2)-&gt;type;
        }
    }
    rb_hash_foreach(hash2, rb_hash_rehash_i, (VALUE)hash);

    rb_gc_writebarrier_remember(hash);

    return hash;
}</pre> </div> <p>Replaces the contents of <em>hsh</em> with the contents of <em>other_hash</em>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.replace({ "c" =&gt; 300, "d" =&gt; 400 })   #=&gt; {"c"=&gt;300, "d"=&gt;400}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> to_s → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> inspect → string </span> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
rb_hash_inspect(VALUE hash)
{
    if (RHASH_EMPTY_P(hash))
        return rb_usascii_str_new2("{}");
    return rb_exec_recursive(inspect_hash, hash, 0);
}</pre> </div> <p>Return the contents of this hash as a string.</p> <pre class="ruby" data-language="ruby">h = { "c" =&gt; 300, "a" =&gt; 100, "d" =&gt; 400, "c" =&gt; 300  }
h.to_s   #=&gt; "{\"c\"=&gt;300, \"a\"=&gt;100, \"d\"=&gt;400}"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash#method-i-to_s">to_s</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-invert"> <span class="method-callseq"> invert → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="invert-source"> <pre class="c" data-language="c">static VALUE
rb_hash_invert(VALUE hash)
{
    VALUE h = rb_hash_new_with_size(RHASH_SIZE(hash));

    rb_hash_foreach(hash, rb_hash_invert_i, h);
    return h;
}</pre> </div> <p>Returns a new hash created by using <em>hsh</em>'s values as keys, and the keys as values. If a key with the same value already exists in the <em>hsh</em>, then the last one defined will be used, the earlier value(s) will be discarded.</p> <pre class="ruby" data-language="ruby">h = { "n" =&gt; 100, "m" =&gt; 100, "y" =&gt; 300, "d" =&gt; 200, "a" =&gt; 0 }
h.invert   #=&gt; {0=&gt;"a", 100=&gt;"m", 200=&gt;"d", 300=&gt;"y"}
</pre> <p>If there is no key with the same value, <a href="hash#method-i-invert"><code>Hash#invert</code></a> is involutive.</p> <pre class="ruby" data-language="ruby">h = { a: 1, b: 3, c: 4 }
h.invert.invert == h #=&gt; true
</pre> <p>The condition, no key with the same value, can be tested by comparing the size of inverted hash.</p> <pre class="ruby" data-language="ruby"># no key with the same value
h = { a: 1, b: 3, c: 4 }
h.size == h.invert.size #=&gt; true

# two (or more) keys has the same value
h = { a: 1, b: 3, c: 1 }
h.size == h.invert.size #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-keep_if"> <span class="method-callseq"> keep_if {| key, value | block } → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> keep_if → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="keep_if-source"> <pre class="c" data-language="c">VALUE
rb_hash_keep_if(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_foreach(hash, keep_if_i, hash);
    }
    return hash;
}</pre> </div> <p>Deletes every key-value pair from <em>hsh</em> for which <em>block</em> evaluates to <code>false</code>.</p> <p>If no block is given, an enumerator is returned instead.</p> <p>See also <a href="hash#method-i-select-21"><code>Hash#select!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-key"> <span class="method-callseq"> key(value) → key </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="key-source"> <pre class="c" data-language="c">static VALUE
rb_hash_key(VALUE hash, VALUE value)
{
    VALUE args[2];

    args[0] = value;
    args[1] = Qnil;

    rb_hash_foreach(hash, key_i, (VALUE)args);

    return args[1];
}</pre> </div> <p>Returns the key of an occurrence of a given value. If the value is not found, returns <code>nil</code>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300, "d" =&gt; 300 }
h.key(200)   #=&gt; "b"
h.key(300)   #=&gt; "c"
h.key(999)   #=&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-key-3F"> <span class="method-callseq"> key?(key) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="key-3F-source"> <pre class="c" data-language="c">MJIT_FUNC_EXPORTED VALUE
rb_hash_has_key(VALUE hash, VALUE key)
{
    if (hash_stlike_lookup(hash, key, NULL)) {
        return Qtrue;
    }
    else {
        return Qfalse;
    }
}</pre> </div> <p>Returns <code>true</code> if the given key is present in <em>hsh</em>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.has_key?("a")   #=&gt; true
h.has_key?("z")   #=&gt; false
</pre> <p>Note that <a href="hash#method-i-include-3F"><code>include?</code></a> and <a href="hash#method-i-member-3F"><code>member?</code></a> do not test member equality using <code>==</code> as do other Enumerables.</p> <p>See also <a href="enumerable#method-i-include-3F"><code>Enumerable#include?</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-keys"> <span class="method-callseq"> keys → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="keys-source"> <pre class="c" data-language="c">MJIT_FUNC_EXPORTED VALUE
rb_hash_keys(VALUE hash)
{
    st_index_t size = RHASH_SIZE(hash);
    VALUE keys =  rb_ary_new_capa(size);

    if (size == 0) return keys;

    if (ST_DATA_COMPATIBLE_P(VALUE)) {
        RARRAY_PTR_USE_TRANSIENT(keys, ptr, {
            if (RHASH_AR_TABLE_P(hash)) {
                size = ar_keys(hash, ptr, size);
            }
            else {
                st_table *table = RHASH_ST_TABLE(hash);
                size = st_keys(table, ptr, size);
            }
        });
        rb_gc_writebarrier_remember(keys);
        rb_ary_set_len(keys, size);
    }
    else {
        rb_hash_foreach(hash, keys_i, keys);
    }

    return keys;
}</pre> </div> <p>Returns a new array populated with the keys from this hash. See also <a href="hash#method-i-values"><code>Hash#values</code></a>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300, "d" =&gt; 400 }
h.keys   #=&gt; ["a", "b", "c", "d"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-length"> <span class="method-callseq"> length → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="length-source"> <pre class="c" data-language="c">VALUE
rb_hash_size(VALUE hash)
{
    return INT2FIX(RHASH_SIZE(hash));
}</pre> </div> <p>Returns the number of key-value pairs in the hash.</p> <pre class="ruby" data-language="ruby">h = { "d" =&gt; 100, "a" =&gt; 200, "v" =&gt; 300, "e" =&gt; 400 }
h.size          #=&gt; 4
h.delete("a")   #=&gt; 200
h.size          #=&gt; 3
h.length        #=&gt; 3
</pre> <p><a href="hash#method-i-length"><code>Hash#length</code></a> is an alias for <a href="hash#method-i-size"><code>Hash#size</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-member-3F"> <span class="method-callseq"> member?(key) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="member-3F-source"> <pre class="c" data-language="c">MJIT_FUNC_EXPORTED VALUE
rb_hash_has_key(VALUE hash, VALUE key)
{
    if (hash_stlike_lookup(hash, key, NULL)) {
        return Qtrue;
    }
    else {
        return Qfalse;
    }
}</pre> </div> <p>Returns <code>true</code> if the given key is present in <em>hsh</em>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.has_key?("a")   #=&gt; true
h.has_key?("z")   #=&gt; false
</pre> <p>Note that <a href="hash#method-i-include-3F"><code>include?</code></a> and <a href="hash#method-i-member-3F"><code>member?</code></a> do not test member equality using <code>==</code> as do other Enumerables.</p> <p>See also <a href="enumerable#method-i-include-3F"><code>Enumerable#include?</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-merge"> <span class="method-callseq"> merge(other_hash1, other_hash2, ...) → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> merge(other_hash1, other_hash2, ...) {|key, oldval, newval| block} </span> </div> <div class="method-heading"> <span class="method-callseq"> → new_hash </span> </div> <div class="method-description">
<div class="method-source-code" id="merge-source"> <pre class="c" data-language="c">static VALUE
rb_hash_merge(int argc, VALUE *argv, VALUE self)
{
    return rb_hash_update(argc, argv, rb_hash_dup(self));
}</pre> </div> <p>Returns a new hash that combines the contents of the receiver and the contents of the given hashes.</p> <p>If no block is given, entries with duplicate keys are overwritten with the values from each <code>other_hash</code> successively, otherwise the value for each duplicate key is determined by calling the block with the key, its value in the receiver and its value in each <code>other_hash</code>.</p> <p>When called without any argument, returns a copy of the receiver.</p> <pre class="ruby" data-language="ruby">h1 = { "a" =&gt; 100, "b" =&gt; 200 }
h2 = { "b" =&gt; 246, "c" =&gt; 300 }
h3 = { "b" =&gt; 357, "d" =&gt; 400 }
h1.merge          #=&gt; {"a"=&gt;100, "b"=&gt;200}
h1.merge(h2)      #=&gt; {"a"=&gt;100, "b"=&gt;246, "c"=&gt;300}
h1.merge(h2, h3)  #=&gt; {"a"=&gt;100, "b"=&gt;357, "c"=&gt;300, "d"=&gt;400}
h1.merge(h2) {|key, oldval, newval| newval - oldval}
                  #=&gt; {"a"=&gt;100, "b"=&gt;46,  "c"=&gt;300}
h1.merge(h2, h3) {|key, oldval, newval| newval - oldval}
                  #=&gt; {"a"=&gt;100, "b"=&gt;311, "c"=&gt;300, "d"=&gt;400}
h1                #=&gt; {"a"=&gt;100, "b"=&gt;200}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-merge-21"> <span class="method-callseq"> merge!(other_hash1, other_hash2, ...) → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> merge!(other_hash1, other_hash2, ...) {|key, oldval, newval| block} </span> </div> <div class="method-description">
<div class="method-source-code" id="merge-21-source"> <pre class="c" data-language="c">static VALUE
rb_hash_update(int argc, VALUE *argv, VALUE self)
{
    int i;
    bool block_given = rb_block_given_p();

    rb_hash_modify(self);
    for (i = 0; i &lt; argc; i++){
       VALUE hash = to_hash(argv[i]);
       if (block_given) {
           rb_hash_foreach(hash, rb_hash_update_block_i, self);
       }
       else {
           rb_hash_foreach(hash, rb_hash_update_i, self);
       }
    }
    return self;
}</pre> </div> <p>Adds the contents of the given hashes to the receiver.</p> <p>If no block is given, entries with duplicate keys are overwritten with the values from each <code>other_hash</code> successively, otherwise the value for each duplicate key is determined by calling the block with the key, its value in the receiver and its value in each <code>other_hash</code>.</p> <pre class="ruby" data-language="ruby">h1 = { "a" =&gt; 100, "b" =&gt; 200 }
h1.merge!          #=&gt; {"a"=&gt;100, "b"=&gt;200}
h1                 #=&gt; {"a"=&gt;100, "b"=&gt;200}

h1 = { "a" =&gt; 100, "b" =&gt; 200 }
h2 = { "b" =&gt; 246, "c" =&gt; 300 }
h1.merge!(h2)      #=&gt; {"a"=&gt;100, "b"=&gt;246, "c"=&gt;300}
h1                 #=&gt; {"a"=&gt;100, "b"=&gt;246, "c"=&gt;300}

h1 = { "a" =&gt; 100, "b" =&gt; 200 }
h2 = { "b" =&gt; 246, "c" =&gt; 300 }
h3 = { "b" =&gt; 357, "d" =&gt; 400 }
h1.merge!(h2, h3)
                   #=&gt; {"a"=&gt;100, "b"=&gt;357, "c"=&gt;300, "d"=&gt;400}
h1                 #=&gt; {"a"=&gt;100, "b"=&gt;357, "c"=&gt;300, "d"=&gt;400}

h1 = { "a" =&gt; 100, "b" =&gt; 200 }
h2 = { "b" =&gt; 246, "c" =&gt; 300 }
h3 = { "b" =&gt; 357, "d" =&gt; 400 }
h1.merge!(h2, h3) {|key, v1, v2| v1 }
                   #=&gt; {"a"=&gt;100, "b"=&gt;200, "c"=&gt;300, "d"=&gt;400}
h1                 #=&gt; {"a"=&gt;100, "b"=&gt;200, "c"=&gt;300, "d"=&gt;400}
</pre> <p><a href="hash#method-i-update"><code>Hash#update</code></a> is an alias for <a href="hash#method-i-merge-21"><code>Hash#merge!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rassoc"> <span class="method-callseq"> rassoc(obj) → an_array or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rassoc-source"> <pre class="c" data-language="c">VALUE
rb_hash_rassoc(VALUE hash, VALUE obj)
{
    VALUE args[2];

    args[0] = obj;
    args[1] = Qnil;
    rb_hash_foreach(hash, rassoc_i, (VALUE)args);
    return args[1];
}</pre> </div> <p>Searches through the hash comparing <em>obj</em> with the value using <code>==</code>. Returns the first key-value pair (two-element array) that matches. See also <a href="array#method-i-rassoc"><code>Array#rassoc</code></a>.</p> <pre class="ruby" data-language="ruby">a = {1=&gt; "one", 2 =&gt; "two", 3 =&gt; "three", "ii" =&gt; "two"}
a.rassoc("two")    #=&gt; [2, "two"]
a.rassoc("four")   #=&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rehash"> <span class="method-callseq"> rehash → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rehash-source"> <pre class="c" data-language="c">VALUE
rb_hash_rehash(VALUE hash)
{
    VALUE tmp;
    st_table *tbl;

    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_raise(rb_eRuntimeError, "rehash during iteration");
    }
    rb_hash_modify_check(hash);
    if (RHASH_AR_TABLE_P(hash)) {
        tmp = hash_alloc(0);
        ar_alloc_table(tmp);
        rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);
        ar_free_and_clear_table(hash);
        ar_copy(hash, tmp);
        ar_free_and_clear_table(tmp);
    }
    else if (RHASH_ST_TABLE_P(hash)) {
        st_table *old_tab = RHASH_ST_TABLE(hash);
        tmp = hash_alloc(0);
        tbl = st_init_table_with_size(old_tab-&gt;type, old_tab-&gt;num_entries);
        RHASH_ST_TABLE_SET(tmp, tbl);
        rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);
        st_free_table(old_tab);
        RHASH_ST_TABLE_SET(hash, tbl);
        RHASH_ST_CLEAR(tmp);
    }
    hash_verify(hash);
    return hash;
}</pre> </div> <p>Rebuilds the hash based on the current hash values for each key. If values of key objects have changed since they were inserted, this method will reindex <em>hsh</em>. If <a href="hash#method-i-rehash"><code>Hash#rehash</code></a> is called while an iterator is traversing the hash, a <a href="runtimeerror"><code>RuntimeError</code></a> will be raised in the iterator.</p> <pre class="ruby" data-language="ruby">a = [ "a", "b" ]
c = [ "c", "d" ]
h = { a =&gt; 100, c =&gt; 300 }
h[a]       #=&gt; 100
a[0] = "z"
h[a]       #=&gt; nil
h.rehash   #=&gt; {["z", "b"]=&gt;100, ["c", "d"]=&gt;300}
h[a]       #=&gt; 100
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reject"> <span class="method-callseq"> reject {|key, value| block} → a_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reject → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="reject-source"> <pre class="c" data-language="c">VALUE
rb_hash_reject(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    if (RTEST(ruby_verbose)) {
        VALUE klass;
        if (HAS_EXTRA_STATES(hash, klass)) {
            rb_warn("extra states are no longer copied: %+"PRIsVALUE, hash);
        }
    }
    result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(hash, reject_i, result);
    }
    return result;
}</pre> </div> <p>Returns a new hash consisting of entries for which the block returns false.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300 }
h.reject {|k,v| k &lt; "b"}  #=&gt; {"b" =&gt; 200, "c" =&gt; 300}
h.reject {|k,v| v &gt; 100}  #=&gt; {"a" =&gt; 100}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-reject-21"> <span class="method-callseq"> reject! {| key, value | block } → hsh or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reject! → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="reject-21-source"> <pre class="c" data-language="c">VALUE
rb_hash_reject_bang(VALUE hash)
{
    st_index_t n;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify(hash);
    n = RHASH_SIZE(hash);
    if (!n) return Qnil;
    rb_hash_foreach(hash, delete_if_i, hash);
    if (n == RHASH_SIZE(hash)) return Qnil;
    return hash;
}</pre> </div> <p>Equivalent to <a href="hash#method-i-delete_if"><code>Hash#delete_if</code></a>, but returns <code>nil</code> if no changes were made.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-replace"> <span class="method-callseq"> replace(other_hash) → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="replace-source"> <pre class="c" data-language="c">static VALUE
rb_hash_replace(VALUE hash, VALUE hash2)
{
    rb_hash_modify_check(hash);
    if (hash == hash2) return hash;
    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_raise(rb_eRuntimeError, "can't replace hash during iteration");
    }
    hash2 = to_hash(hash2);

    COPY_DEFAULT(hash, hash2);

    if (RHASH_AR_TABLE_P(hash)) {
        if (RHASH_AR_TABLE_P(hash2)) {
            ar_clear(hash);
        }
        else {
            ar_free_and_clear_table(hash);
            RHASH_ST_TABLE_SET(hash, st_init_table_with_size(RHASH_TYPE(hash2), RHASH_SIZE(hash2)));
        }
    }
    else {
        if (RHASH_AR_TABLE_P(hash2)) {
            st_free_table(RHASH_ST_TABLE(hash));
            RHASH_ST_CLEAR(hash);
        }
        else {
            st_clear(RHASH_ST_TABLE(hash));
            RHASH_TBL_RAW(hash)-&gt;type = RHASH_ST_TABLE(hash2)-&gt;type;
        }
    }
    rb_hash_foreach(hash2, rb_hash_rehash_i, (VALUE)hash);

    rb_gc_writebarrier_remember(hash);

    return hash;
}</pre> </div> <p>Replaces the contents of <em>hsh</em> with the contents of <em>other_hash</em>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.replace({ "c" =&gt; 300, "d" =&gt; 400 })   #=&gt; {"c"=&gt;300, "d"=&gt;400}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-select"> <span class="method-callseq"> select {|key, value| block} → a_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> select → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="select-source"> <pre class="c" data-language="c">VALUE
rb_hash_select(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(hash, select_i, result);
    }
    return result;
}</pre> </div> <p>Returns a new hash consisting of entries for which the block returns true.</p> <p>If no block is given, an enumerator is returned instead.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300 }
h.select {|k,v| k &gt; "a"}  #=&gt; {"b" =&gt; 200, "c" =&gt; 300}
h.select {|k,v| v &lt; 200}  #=&gt; {"a" =&gt; 100}
</pre> <p><a href="hash#method-i-filter"><code>Hash#filter</code></a> is an alias for <a href="hash#method-i-select"><code>Hash#select</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-select-21"> <span class="method-callseq"> select! {| key, value | block } → hsh or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> select! → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="select-21-source"> <pre class="c" data-language="c">VALUE
rb_hash_select_bang(VALUE hash)
{
    st_index_t n;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    n = RHASH_SIZE(hash);
    if (!n) return Qnil;
    rb_hash_foreach(hash, keep_if_i, hash);
    if (n == RHASH_SIZE(hash)) return Qnil;
    return hash;
}</pre> </div> <p>Equivalent to <a href="hash#method-i-keep_if"><code>Hash#keep_if</code></a>, but returns <code>nil</code> if no changes were made.</p> <p><a href="hash#method-i-filter-21"><code>Hash#filter!</code></a> is an alias for <a href="hash#method-i-select-21"><code>Hash#select!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-shift"> <span class="method-callseq"> shift → anArray or obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="shift-source"> <pre class="c" data-language="c">static VALUE
rb_hash_shift(VALUE hash)
{
    struct shift_var var;

    rb_hash_modify_check(hash);
    if (RHASH_AR_TABLE_P(hash)) {
        var.key = Qundef;
        if (RHASH_ITER_LEV(hash) == 0) {
            if (ar_shift(hash, &amp;var.key, &amp;var.val)) {
                return rb_assoc_new(var.key, var.val);
            }
        }
        else {
            rb_hash_foreach(hash, shift_i_safe, (VALUE)&amp;var);
            if (var.key != Qundef) {
                rb_hash_delete_entry(hash, var.key);
                return rb_assoc_new(var.key, var.val);
            }
        }
    }
    if (RHASH_ST_TABLE_P(hash)) {
        var.key = Qundef;
        if (RHASH_ITER_LEV(hash) == 0) {
            if (st_shift(RHASH_ST_TABLE(hash), &amp;var.key, &amp;var.val)) {
                return rb_assoc_new(var.key, var.val);
            }
        }
        else {
            rb_hash_foreach(hash, shift_i_safe, (VALUE)&amp;var);
            if (var.key != Qundef) {
                rb_hash_delete_entry(hash, var.key);
                return rb_assoc_new(var.key, var.val);
            }
        }
    }
    return rb_hash_default_value(hash, Qnil);
}</pre> </div> <p>Removes a key-value pair from <em>hsh</em> and returns it as the two-item array <code>[</code> <em>key, value</em> <code>]</code>, or the hash's default value if the hash is empty.</p> <pre class="ruby" data-language="ruby">h = { 1 =&gt; "a", 2 =&gt; "b", 3 =&gt; "c" }
h.shift   #=&gt; [1, "a"]
h         #=&gt; {2=&gt;"b", 3=&gt;"c"}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">VALUE
rb_hash_size(VALUE hash)
{
    return INT2FIX(RHASH_SIZE(hash));
}</pre> </div> <p>Returns the number of key-value pairs in the hash.</p> <pre class="ruby" data-language="ruby">h = { "d" =&gt; 100, "a" =&gt; 200, "v" =&gt; 300, "e" =&gt; 400 }
h.size          #=&gt; 4
h.delete("a")   #=&gt; 200
h.size          #=&gt; 3
h.length        #=&gt; 3
</pre> <p><a href="hash#method-i-length"><code>Hash#length</code></a> is an alias for <a href="hash#method-i-size"><code>Hash#size</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-slice"> <span class="method-callseq"> slice(*keys) → a_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="slice-source"> <pre class="c" data-language="c">static VALUE
rb_hash_slice(int argc, VALUE *argv, VALUE hash)
{
    int i;
    VALUE key, value, result;

    if (argc == 0 || RHASH_EMPTY_P(hash)) {
        return rb_hash_new();
    }
    result = rb_hash_new_with_size(argc);

    for (i = 0; i &lt; argc; i++) {
        key = argv[i];
        value = rb_hash_lookup2(hash, key, Qundef);
        if (value != Qundef)
            rb_hash_aset(result, key, value);
    }

    return result;
}</pre> </div> <p>Returns a hash containing only the given keys and their values.</p> <pre class="ruby" data-language="ruby">h = { a: 100, b: 200, c: 300 }
h.slice(:a)           #=&gt; {:a=&gt;100}
h.slice(:b, :c, :d)   #=&gt; {:b=&gt;200, :c=&gt;300}
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-store"> <span class="method-callseq"> store(key, value) → value </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="store-source"> <pre class="c" data-language="c">VALUE
rb_hash_aset(VALUE hash, VALUE key, VALUE val)
{
    int iter_lev = RHASH_ITER_LEV(hash);

    rb_hash_modify(hash);

    if (RHASH_TABLE_NULL_P(hash)) {
        if (iter_lev &gt; 0) no_new_key();
        ar_alloc_table(hash);
    }

    if (RHASH_TYPE(hash) == &amp;identhash || rb_obj_class(key) != rb_cString) {
        RHASH_UPDATE_ITER(hash, iter_lev, key, hash_aset, val);
    }
    else {
        RHASH_UPDATE_ITER(hash, iter_lev, key, hash_aset_str, val);
    }
    return val;
}</pre> </div> <h2 id="method-i-store-label-Element+Assignment">Element Assignment</h2> <p>Associates the value given by <code>value</code> with the key given by <code>key</code>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h["a"] = 9
h["c"] = 4
h   #=&gt; {"a"=&gt;9, "b"=&gt;200, "c"=&gt;4}
h.store("d", 42) #=&gt; 42
h   #=&gt; {"a"=&gt;9, "b"=&gt;200, "c"=&gt;4, "d"=&gt;42}
</pre> <p><code>key</code> should not have its value changed while it is in use as a key (an <code>unfrozen String</code> passed as a key will be duplicated and frozen).</p> <pre class="ruby" data-language="ruby">a = "a"
b = "b".freeze
h = { a =&gt; 100, b =&gt; 200 }
h.key(100).equal? a #=&gt; false
h.key(200).equal? b #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_a"> <span class="method-callseq"> to_a → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
rb_hash_to_a(VALUE hash)
{
    VALUE ary;

    ary = rb_ary_new_capa(RHASH_SIZE(hash));
    rb_hash_foreach(hash, to_a_i, ary);

    return ary;
}</pre> </div> <p>Converts <em>hsh</em> to a nested array of <code>[</code> <em>key, value</em> <code>]</code> arrays.</p> <pre class="ruby" data-language="ruby">h = { "c" =&gt; 300, "a" =&gt; 100, "d" =&gt; 400, "c" =&gt; 300  }
h.to_a   #=&gt; [["c", 300], ["a", 100], ["d", 400]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_h"> <span class="method-callseq"> to_h → hsh or new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> to_h {|key, value| block } → new_hash </span> </div> <div class="method-description">
<div class="method-source-code" id="to_h-source"> <pre class="c" data-language="c">static VALUE
rb_hash_to_h(VALUE hash)
{
    if (rb_block_given_p()) {
        return rb_hash_to_h_block(hash);
    }
    if (rb_obj_class(hash) != rb_cHash) {
        const VALUE flags = RBASIC(hash)-&gt;flags;
        hash = hash_dup(hash, rb_cHash, flags &amp; RHASH_PROC_DEFAULT);
    }
    return hash;
}</pre> </div> <p>Returns <code>self</code>. If called on a subclass of <a href="hash"><code>Hash</code></a>, converts the receiver to a <a href="hash"><code>Hash</code></a> object.</p> <p>If a block is given, the results of the block on each pair of the receiver will be used as pairs.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_hash"> <span class="method-callseq"> to_hash → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_hash-source"> <pre class="c" data-language="c">static VALUE
rb_hash_to_hash(VALUE hash)
{
    return hash;
}</pre> </div> <p>Returns <code>self</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_proc"> <span class="method-callseq"> to_proc → proc </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="to_proc-source"> <pre class="c" data-language="c">static VALUE
rb_hash_to_proc(VALUE hash)
{
    return rb_func_proc_new(hash_proc_call, hash);
}</pre> </div> <p>Returns a <a href="proc"><code>Proc</code></a> which maps keys to values.</p> <pre class="ruby" data-language="ruby">h = {a:1, b:2}
hp = h.to_proc
hp.call(:a)          #=&gt; 1
hp.call(:b)          #=&gt; 2
hp.call(:c)          #=&gt; nil
[:a, :b, :c].map(&amp;h) #=&gt; [1, 2, nil]
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="hash#method-i-inspect">inspect</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-transform_keys"> <span class="method-callseq"> transform_keys {|key| block } → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="transform_keys-source"> <pre class="c" data-language="c">static VALUE
rb_hash_transform_keys(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(hash, transform_keys_i, result);
    }

    return result;
}</pre> </div> <p>Returns a new hash with the results of running the block once for every key. This method does not change the values.</p> <pre class="ruby" data-language="ruby">h = { a: 1, b: 2, c: 3 }
h.transform_keys {|k| k.to_s }  #=&gt; { "a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3 }
h.transform_keys(&amp;:to_s)        #=&gt; { "a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3 }
h.transform_keys.with_index {|k, i| "#{k}.#{i}" }
                                #=&gt; { "a.0" =&gt; 1, "b.1" =&gt; 2, "c.2" =&gt; 3 }
</pre> <p>If no block is given, an enumerator is returned instead.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-transform_keys-21"> <span class="method-callseq"> transform_keys! {|key| block } → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> transform_keys! → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="transform_keys-21-source"> <pre class="c" data-language="c">static VALUE
rb_hash_transform_keys_bang(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        long i;
        VALUE pairs = rb_hash_flatten(0, NULL, hash);
        rb_hash_clear(hash);
        for (i = 0; i &lt; RARRAY_LEN(pairs); i += 2) {
            VALUE key = RARRAY_AREF(pairs, i), new_key = rb_yield(key),
                  val = RARRAY_AREF(pairs, i+1);
            rb_hash_aset(hash, new_key, val);
        }
    }
    return hash;
}</pre> </div> <p>Invokes the given block once for each key in <em>hsh</em>, replacing it with the new key returned by the block, and then returns <em>hsh</em>. This method does not change the values.</p> <pre class="ruby" data-language="ruby">h = { a: 1, b: 2, c: 3 }
h.transform_keys! {|k| k.to_s }  #=&gt; { "a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3 }
h.transform_keys!(&amp;:to_sym)      #=&gt; { a: 1, b: 2, c: 3 }
h.transform_keys!.with_index {|k, i| "#{k}.#{i}" }
                                 #=&gt; { "a.0" =&gt; 1, "b.1" =&gt; 2, "c.2" =&gt; 3 }
</pre> <p>If no block is given, an enumerator is returned instead.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-transform_values"> <span class="method-callseq"> transform_values {|value| block } → new_hash </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> transform_values → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="transform_values-source"> <pre class="c" data-language="c">static VALUE
rb_hash_transform_values(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = hash_copy(hash_alloc(rb_cHash), hash);
    SET_DEFAULT(result, Qnil);

    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_stlike_foreach_with_replace(result, transform_values_foreach_func, transform_values_foreach_replace, result);
    }

    return result;
}</pre> </div> <p>Returns a new hash with the results of running the block once for every value. This method does not change the keys.</p> <pre class="ruby" data-language="ruby">h = { a: 1, b: 2, c: 3 }
h.transform_values {|v| v * v + 1 }  #=&gt; { a: 2, b: 5, c: 10 }
h.transform_values(&amp;:to_s)           #=&gt; { a: "1", b: "2", c: "3" }
h.transform_values.with_index {|v, i| "#{v}.#{i}" }
                                     #=&gt; { a: "1.0", b: "2.1", c: "3.2" }
</pre> <p>If no block is given, an enumerator is returned instead.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-transform_values-21"> <span class="method-callseq"> transform_values! {|value| block } → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> transform_values! → an_enumerator </span> </div> <div class="method-description">
<div class="method-source-code" id="transform_values-21-source"> <pre class="c" data-language="c">static VALUE
rb_hash_transform_values_bang(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);

    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_stlike_foreach_with_replace(hash, transform_values_foreach_func, transform_values_foreach_replace, hash);
    }

    return hash;
}</pre> </div> <p>Invokes the given block once for each value in <em>hsh</em>, replacing it with the new value returned by the block, and then returns <em>hsh</em>. This method does not change the keys.</p> <pre class="ruby" data-language="ruby">h = { a: 1, b: 2, c: 3 }
h.transform_values! {|v| v * v + 1 }  #=&gt; { a: 2, b: 5, c: 10 }
h.transform_values!(&amp;:to_s)           #=&gt; { a: "2", b: "5", c: "10" }
h.transform_values!.with_index {|v, i| "#{v}.#{i}" }
                                      #=&gt; { a: "2.0", b: "5.1", c: "10.2" }
</pre> <p>If no block is given, an enumerator is returned instead.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-update"> <span class="method-callseq"> update(other_hash1, other_hash2, ...) → hsh </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> update(other_hash1, other_hash2, ...) {|key, oldval, newval| block} </span> </div> <div class="method-description">
<div class="method-source-code" id="update-source"> <pre class="c" data-language="c">static VALUE
rb_hash_update(int argc, VALUE *argv, VALUE self)
{
    int i;
    bool block_given = rb_block_given_p();

    rb_hash_modify(self);
    for (i = 0; i &lt; argc; i++){
       VALUE hash = to_hash(argv[i]);
       if (block_given) {
           rb_hash_foreach(hash, rb_hash_update_block_i, self);
       }
       else {
           rb_hash_foreach(hash, rb_hash_update_i, self);
       }
    }
    return self;
}</pre> </div> <p>Adds the contents of the given hashes to the receiver.</p> <p>If no block is given, entries with duplicate keys are overwritten with the values from each <code>other_hash</code> successively, otherwise the value for each duplicate key is determined by calling the block with the key, its value in the receiver and its value in each <code>other_hash</code>.</p> <pre class="ruby" data-language="ruby">h1 = { "a" =&gt; 100, "b" =&gt; 200 }
h1.merge!          #=&gt; {"a"=&gt;100, "b"=&gt;200}
h1                 #=&gt; {"a"=&gt;100, "b"=&gt;200}

h1 = { "a" =&gt; 100, "b" =&gt; 200 }
h2 = { "b" =&gt; 246, "c" =&gt; 300 }
h1.merge!(h2)      #=&gt; {"a"=&gt;100, "b"=&gt;246, "c"=&gt;300}
h1                 #=&gt; {"a"=&gt;100, "b"=&gt;246, "c"=&gt;300}

h1 = { "a" =&gt; 100, "b" =&gt; 200 }
h2 = { "b" =&gt; 246, "c" =&gt; 300 }
h3 = { "b" =&gt; 357, "d" =&gt; 400 }
h1.merge!(h2, h3)
                   #=&gt; {"a"=&gt;100, "b"=&gt;357, "c"=&gt;300, "d"=&gt;400}
h1                 #=&gt; {"a"=&gt;100, "b"=&gt;357, "c"=&gt;300, "d"=&gt;400}

h1 = { "a" =&gt; 100, "b" =&gt; 200 }
h2 = { "b" =&gt; 246, "c" =&gt; 300 }
h3 = { "b" =&gt; 357, "d" =&gt; 400 }
h1.merge!(h2, h3) {|key, v1, v2| v1 }
                   #=&gt; {"a"=&gt;100, "b"=&gt;200, "c"=&gt;300, "d"=&gt;400}
h1                 #=&gt; {"a"=&gt;100, "b"=&gt;200, "c"=&gt;300, "d"=&gt;400}
</pre> <p><a href="hash#method-i-update"><code>Hash#update</code></a> is an alias for <a href="hash#method-i-merge-21"><code>Hash#merge!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-value-3F"> <span class="method-callseq"> value?(value) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="value-3F-source"> <pre class="c" data-language="c">static VALUE
rb_hash_has_value(VALUE hash, VALUE val)
{
    VALUE data[2];

    data[0] = Qfalse;
    data[1] = val;
    rb_hash_foreach(hash, rb_hash_search_value, (VALUE)data);
    return data[0];
}</pre> </div> <p>Returns <code>true</code> if the given value is present for some key in <em>hsh</em>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200 }
h.value?(100)   #=&gt; true
h.value?(999)   #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-values"> <span class="method-callseq"> values → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="values-source"> <pre class="c" data-language="c">VALUE
rb_hash_values(VALUE hash)
{
    VALUE values;
    st_index_t size = RHASH_SIZE(hash);

    values = rb_ary_new_capa(size);
    if (size == 0) return values;

    if (ST_DATA_COMPATIBLE_P(VALUE)) {
        if (RHASH_AR_TABLE_P(hash)) {
            rb_gc_writebarrier_remember(values);
            RARRAY_PTR_USE_TRANSIENT(values, ptr, {
                size = ar_values(hash, ptr, size);
            });
        }
        else if (RHASH_ST_TABLE_P(hash)) {
            st_table *table = RHASH_ST_TABLE(hash);
            rb_gc_writebarrier_remember(values);
            RARRAY_PTR_USE_TRANSIENT(values, ptr, {
                size = st_values(table, ptr, size);
            });
        }
        rb_ary_set_len(values, size);
    }
    else {
        rb_hash_foreach(hash, values_i, values);
    }

    return values;
}</pre> </div> <p>Returns a new array populated with the values from <em>hsh</em>. See also <a href="hash#method-i-keys"><code>Hash#keys</code></a>.</p> <pre class="ruby" data-language="ruby">h = { "a" =&gt; 100, "b" =&gt; 200, "c" =&gt; 300 }
h.values   #=&gt; [100, 200, 300]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-values_at"> <span class="method-callseq"> values_at(key, ...) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="values_at-source"> <pre class="c" data-language="c">VALUE
rb_hash_values_at(int argc, VALUE *argv, VALUE hash)
{
    VALUE result = rb_ary_new2(argc);
    long i;

    for (i=0; i&lt;argc; i++) {
        rb_ary_push(result, rb_hash_aref(hash, argv[i]));
    }
    return result;
}</pre> </div> <p>Return an array containing the values associated with the given keys. Also see <a href="hash#method-i-select"><code>Hash.select</code></a>.</p> <pre class="ruby" data-language="ruby">h = { "cat" =&gt; "feline", "dog" =&gt; "canine", "cow" =&gt; "bovine" }
h.values_at("cow", "cat")  #=&gt; ["bovine", "feline"]
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2017 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
