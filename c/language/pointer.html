
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Pointer Declaration - C - W3cubDocs</title>
  
  <meta name="description" content="Pointer is a type of an object that refers to a function or an object of another type, possibly adding qualifiers. Pointer may also refer to nothing &hellip;">
  <meta name="keywords" content="pointer, declaration, c">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/c/language/pointer.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/c.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/c/" class="_nav-link" title="" style="margin-left:0;">C</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _c">
				
				
<h1 id="firstHeading" class="firstHeading">Pointer declaration</h1>            <p>Pointer is a type of an object that refers to a function or an object of another type, possibly adding qualifiers. Pointer may also refer to nothing, which is indicated by the special null pointer value.</p>
<h3 id="Syntax">Syntax</h3> <p>In the <a href="declarations" title="c/language/declarations">declaration grammar</a> of a pointer declaration, the <i>type-specifier</i> sequence designates the pointed-to type (which may be function or object type and may be incomplete), and the <i>declarator</i> has the form:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>*</code> <span class="t-spar">qualifiers</span><span class="t-mark">(optional)</span> <span class="t-spar">declarator</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>where <span class="t-spar">declarator</span> may be the identifier that names the pointer being declared, including another pointer declarator (which would indicate a pointer to a pointer):</p>
<div class="c source-c"><pre data-language="c">float *p, **pp; // p is a pointer to float
                // pp is a pointer to a pointer to float
int (*fp)(int); // fp is a pointer to function with type int(int)</pre></div> <p>The <span class="t-spar">qualifiers</span> that appear between <code>*</code> and the identifier (or other nested declarator) qualify the type of the pointer that is being declared:</p>
<div class="c source-c"><pre data-language="c">int n;
const int * pc = &amp;n; // pc is a non-const pointer to a const int
// *pc = 2; // Error: n cannot be changed through p without a cast
pc = NULL; // OK: pc itself can be changed
 
int * const cp = &amp;n; // cp is a const pointer to a non-const int
*cp = 2; // OK to change n through cp
// cp = NULL; // Error: cp itself cannot be changed
 
int * const * pcp = &amp;cp; // non-const pointer to const pointer to non-const int</pre></div> <h3 id="Explanation">Explanation</h3> <p>Pointers are used for indirection, which is a ubiquitous programming technique; they can be used to implement pass-by-reference semantics, to access objects with dynamic <a href="storage_duration" title="c/language/storage duration">storage duration</a>, to implement "optional" types (using the null pointer value), aggregation relationship between structs, callbacks (using pointers to functions), generic interfaces (using pointers to void), and much more.</p>
<h4 id="Pointers_to_objects">Pointers to objects</h4> <p>A pointer to object can be initialized with the result of the <a href="operator_member_access" title="c/language/operator member access">address-of operator</a> applied to an expression of object type (which may be incomplete):</p>
<div class="c source-c"><pre data-language="c">int n;
int *np = &amp;n; // pointer to int
int *const *npp = &amp;np; // non-const pointer to const pointer to non-const int
 
int a[2];
int (*ap)[2] = &amp;a; // pointer to array of int
 
struct S { int n; } s = {1}
int* sp = &amp;s.n; // pointer to the int that is a member of s</pre></div> <p>Pointers may appear as operands to the <a href="operator_member_access#Dereference" title="c/language/operator member access">indirection operator</a> (unary <code>*</code>), which returns <a href="value_category" title="c/language/value category">the lvalue</a> identifying the pointed-to object:</p>
<div class="c source-c"><pre data-language="c">int n;
int* p = &amp;n;     // pointer p is pointing to n
*p = 7;         // stores 7 in n
printf("%d\n", *p); // lvalue-to-rvalue conversion reads the value from n</pre></div> <p>Pointers to objects of <a href="struct" title="c/language/struct">struct</a> and <a href="union" title="c/language/union">union</a> type may also appear as the left-hand operands of the <a href="operator_member_access" title="c/language/operator member access">member access through pointer</a> operator <code>-&gt;</code>.</p>
<p>Because of the <a href="array" title="c/language/array">array-to-pointer</a> implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:</p>
<div class="c source-c"><pre data-language="c">int a[2];
int *p = a; // pointer to a[0]
 
int b[3][3];
int (*row)[3] = b; // pointer to b[0]</pre></div> <p>Certain <a href="operator_arithmetic" title="c/language/operator arithmetic">addition, subtraction</a>, <a href="operator_assignment" title="c/language/operator assignment">compound assignment</a>, <a href="operator_incdec" title="c/language/operator incdec">increment, and decrement</a> operators are defined for pointers to elements of arrays.</p>
<p><a href="operator_comparison" title="c/language/operator comparison">Comparison operators</a> are defined for pointers to objects in some situations: two pointers that represent the same address compare equal, two null pointer values compare equal, pointers to elements of the same array compare the same as the array indexes of those elements, and pointers to struct members compare in order of declaration of those members.</p>
<p>Many implementations also provide <a href="https://en.wikipedia.org/wiki/Total_order#Strict_total_order" class="extiw" title="enwiki:Total order">strict total ordering</a> of pointers of random origin, e.g. if they are implemented as addresses within continuous ("flat") virtual address space.</p>
<h4 id="Pointers_to_functions">Pointers to functions</h4> <p>A pointer to function can be initialized with an address of a function. Because of the <a href="conversion" title="c/language/conversion">function-to-pointer</a> conversion, the address-of operator is optional:</p>
<div class="c source-c"><pre data-language="c">void f(int);
void (*pf1)(int) = &amp;f;
void (*pf2)(int) = f; // same as &amp;f</pre></div> <p>Unlike functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, passed to other functions as arguments, etc.</p>
<p>A pointer to function can be used on the left-hand side of the <a href="operator_other#Function_call" title="c/language/operator other">function call operator</a>; this invokes the pointed-to function:</p>
<div class="c source-c"><pre data-language="c">#include &lt;stdio.h&gt;
int f(int n)
{
    printf("%d\n", n);
    return n*n;
}
int main(void)
{
    int (*p)(int) = f;
    int x = p(7);
}</pre></div> <p>Dereferencing a function pointer yields the function designator for the pointed-to function:</p>
<div class="c source-c"><pre data-language="c">int f();
int (*p)() = f;    // pointer p is pointing to f
(*p)(); // function f invoked through the function designator
p();    // function f invoked directly through the pointer</pre></div> <p><a href="operator_comparison" title="c/language/operator comparison">Equality comparison operators</a> are defined for pointers to functions (they compare equal if pointing to the same function).</p>
<p>Because <a href="compatible_type#Compatible_types" title="c/language/type">compatibility of function types</a> ignores top-level qualifiers of the function parameters, pointers to functions whose parameters only differ in their top-level qualifiers are interchangeable:</p>
<div class="c source-c"><pre data-language="c">int f(int), fc(const int);
int (*pc)(const int) = f; // OK
int (*p)(int) = fc;       // OK
pc = p;                   // OK</pre></div> <h4 id="Pointers_to_void">Pointers to void</h4> <p>Pointer to object of any type can be <a href="conversion" title="c/language/conversion">implicitly converted</a> to pointer to <code>void</code> (optionally <a href="const" title="c/language/const">const</a> or <a href="volatile" title="c/language/volatile">volatile</a>-qualified), and vice versa:</p>
<div class="c source-c"><pre data-language="c">int n=1, *p=&amp;n;
void* pv = p; // int* to void*
int* p2 = pv; // void* to int*
printf("%d\n", *p2); // prints 1</pre></div> <p>Pointers to void are used to pass objects of unknown type, which is common in generic interfaces: <code><a href="../memory/malloc" title="c/memory/malloc">malloc</a></code> returns <code>void*</code>, <code><a href="../algorithm/qsort" title="c/algorithm/qsort">qsort</a></code> expects a user-provided callback that accepts two <code>const void*</code> arguments. <a rel="nofollow" class="external text" href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html">pthread_create</a> expects a user-provided callback that accepts and returns <code>void*</code>. In all cases, it is the caller's responsibility to convert the pointer to the correct type before use.</p>
<h3 id="Null_pointers">Null pointers</h3> <p>Pointers of every type have a special value known as <i>null pointer value</i> of that type. A pointer whose value is null does not point to an object or a function (dereferencing a null pointer is undefined behavior), and compares equal to all pointers of the same type whose value is also <i>null</i>.</p>
<p>To initialize a pointer to null or to assign the null value to an existing pointer, a null pointer constant (<code><a href="../types/null" title="c/types/NULL">NULL</a></code>, or any other integer constant with the value zero) may be used. <a href="initialization" title="c/language/initialization">static initialization</a> also initializes pointers to their null values.</p>
<p>Null pointers can indicate the absence of an object or can be used to indicate other types of error conditions. In general, a function that receives a pointer argument almost always needs to check if the value is null and handle that case differently (for example, <code><a href="../memory/free" title="c/memory/free">free</a></code> does nothing when a null pointer is passed).</p>
<h3 id="Notes">Notes</h3> <p>Although any pointer to object <a href="cast" title="c/language/cast">can be cast</a> to pointer to object of a different type, dereferencing a pointer to the type different from the declared type of the object is almost always undefined behavior. See <a href="object#Strict_aliasing" title="c/language/object">strict aliasing</a> for details.</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-c99">
<td> <p>It is possible to indicate to a function that accesses objects through pointers that those pointers do not alias. See <a href="restrict" title="c/language/restrict">restrict</a> for details.</p>
</td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <p>lvalue expressions of array type, when used in most contexts, undergo an <a href="conversion" title="c/language/conversion">implicit conversion</a> to the pointer to the first element of the array. See <a href="array#Array_to_pointer_conversion" title="c/language/array">array</a> for details.</p>
<div class="c source-c"><pre data-language="c">char *str = "abc"; // "abc" is a char[4] array, str is a pointer to 'a'</pre></div> <p>Pointers to char are often <a href="../string/byte" title="c/string/byte">used to represent strings</a>. To represent a valid byte string, a pointer must be pointing at a char that is an element of an array of char, and there must be a char with the value zero at some index greater or equal to the index of the element referenced by the pointer.</p>
<h3 id="References">References</h3>  <ul>
<li> C11 standard (ISO/IEC 9899:2011): </li>
<ul><li> 6.7.6.1 Pointer declarators (p: 130) </li></ul>
<li> C99 standard (ISO/IEC 9899:1999): </li>
<ul><li> 6.7.5.1 Pointer declarators (p: 115-116) </li></ul>
<li> C89/C90 standard (ISO/IEC 9899:1990): </li>
<ul><li> 3.5.4.1 Pointer declarators </li></ul>
</ul>         <h3 id="See_also">See also</h3>            <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/c/language/pointer" class="_attribution-link">http://en.cppreference.com/w/c/language/pointer</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
