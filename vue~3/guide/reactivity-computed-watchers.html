
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Reactivity&#58; Computed and Watch - Vue.js 3 - W3cubDocs</title>
  
  <meta name="description" content=" This section uses single-file component syntax for code examples ">
  <meta name="keywords" content="computed, and, watch, reactivity, vue, js, vue~3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/vue~3/guide/reactivity-computed-watchers.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/vue~3.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/vue~3/" class="_nav-link" title="" style="margin-left:0;">Vue.js 3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _vue">
				
				
<div class="theme-default-content content__default">
<h1 id="computed-and-watch"> Computed and Watch</h1> <blockquote><p>This section uses <a href="single-file-component">single-file component</a> syntax for code examples</p></blockquote> <h2 id="computed-values"> Computed values</h2> <p>Sometimes we need state that depends on other state - in Vue this is handled with component <a href="computed#computed-properties">computed properties</a>. To directly create a computed value, we can use the <code>computed</code> method: it takes a getter function and returns an immutable reactive <a href="reactivity-fundamentals#creating-standalone-reactive-values-as-refs">ref</a> object for the returned value from the getter.</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="js">const count = ref(1)
const plusOne = computed(() =&gt; count.value + 1)

console.log(plusOne.value) // 2

plusOne.value++ // error</pre> </div>
<p>Alternatively, it can take an object with <code>get</code> and <code>set</code> functions to create a writable ref object.</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="js">const count = ref(1)
const plusOne = computed({
  get: () =&gt; count.value + 1,
  set: val =&gt; {
    count.value = val - 1
  }
})

plusOne.value = 1
console.log(count.value) // 0</pre> </div>
<h2 id="watcheffect"> <code>watchEffect</code>
</h2> <p>To apply and <em>automatically re-apply</em> a side effect based on reactive state, we can use the <code>watchEffect</code> method. It runs a function immediately while reactively tracking its dependencies and re-runs it whenever the dependencies are changed.</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="js">const count = ref(0)

watchEffect(() =&gt; console.log(count.value))
// -&gt; logs 0

setTimeout(() =&gt; {
  count.value++
  // -&gt; logs 1
}, 100)</pre> </div>
<h3 id="stopping-the-watcher"> Stopping the Watcher</h3> <p>When <code>watchEffect</code> is called during a component's <a href="composition-api-setup">setup()</a> function or <a href="composition-api-lifecycle-hooks">lifecycle hooks</a>, the watcher is linked to the component's lifecycle and will be automatically stopped when the component is unmounted.</p> <p>In other cases, it returns a stop handle which can be called to explicitly stop the watcher:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="js">const stop = watchEffect(() =&gt; {
  /* ... */
})

// later
stop()</pre> </div>
<h3 id="side-effect-invalidation"> Side Effect Invalidation</h3> <p>Sometimes the watched effect function will perform asynchronous side effects that need to be cleaned up when it is invalidated (i.e state changed before the effects can be completed). The effect function receives an <code>onInvalidate</code> function that can be used to register an invalidation callback. This invalidation callback is called when:</p> <ul>
<li>the effect is about to re-run</li> <li>the watcher is stopped (i.e. when the component is unmounted if <code>watchEffect</code> is used inside <code>setup()</code> or lifecycle hooks)</li>
</ul> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="js">watchEffect(onInvalidate =&gt; {
  const token = performAsyncOperation(id.value)
  onInvalidate(() =&gt; {
    // id has changed or watcher is stopped.
    // invalidate previously pending async operation
    token.cancel()
  })
})</pre> </div>
<p>We are registering the invalidation callback via a passed-in function instead of returning it from the callback because the return value is important for async error handling. It is very common for the effect function to be an async function when performing data fetching:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="js">const data = ref(null)
watchEffect(async onInvalidate =&gt; {
  onInvalidate(() =&gt; {...}) // we register cleanup function before Promise resolves
  data.value = await fetchData(props.id)
})</pre> </div>
<p>An async function implicitly returns a Promise, but the cleanup function needs to be registered immediately before the Promise resolves. In addition, Vue relies on the returned Promise to automatically handle potential errors in the Promise chain.</p> <h3 id="effect-flush-timing"> Effect Flush Timing</h3> <p>Vue's reactivity system buffers invalidated effects and flushes them asynchronously to avoid unnecessary duplicate invocation when there are many state mutations happening in the same "tick". Internally, a component's <code>update</code> function is also a watched effect. When a user effect is queued, it is by default invoked <strong>before</strong> all component <code>update</code> effects:</p> <div class="language-html line-numbers-mode">
<pre class="language-html" data-language="html">&lt;template&gt;
  &lt;div&gt;{{ count }}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    setup() {
      const count = ref(0)

      watchEffect(() =&gt; {
        console.log(count.value)
      })

      return {
        count
      }
    }
  }
&lt;/script&gt;</pre> </div>
<p>In this example:</p> <ul>
<li>The count will be logged synchronously on initial run.</li> <li>When <code>count</code> is mutated, the callback will be called <strong>before</strong> the component has updated.</li>
</ul> <p>In cases where a watcher effect needs to be re-run <strong>after</strong> component updates, we can pass an additional <code>options</code> object with the <code>flush</code> option (default is <code>'pre'</code>):</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="js">// fire after component updates so you can access the updated DOM
// Note: this will also defer the initial run of the effect until the
// component's first render is finished.
watchEffect(
  () =&gt; {
    /* ... */
  },
  {
    flush: 'post'
  }
)</pre> </div>
<p>The <code>flush</code> option also accepts <code>'sync'</code>, which forces the effect to always trigger synchronously. This is however inefficient and should be rarely needed.</p> <h3 id="watcher-debugging"> Watcher Debugging</h3> <p>The <code>onTrack</code> and <code>onTrigger</code> options can be used to debug a watcher's behavior.</p> <ul>
<li>
<code>onTrack</code> will be called when a reactive property or ref is tracked as a dependency.</li> <li>
<code>onTrigger</code> will be called when the watcher callback is triggered by the mutation of a dependency.</li>
</ul> <p>Both callbacks will receive a debugger event which contains information on the dependency in question. It is recommended to place a <code>debugger</code> statement in these callbacks to interactively inspect the dependency:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="js">watchEffect(
  () =&gt; {
    /* side effect */
  },
  {
    onTrigger(e) {
      debugger
    }
  }
)</pre> </div>
<p><code>onTrack</code> and <code>onTrigger</code> only work in development mode.</p> <h2 id="watch"> <code>watch</code>
</h2> <p>The <code>watch</code> API is the exact equivalent of the component <a href="computed#watchers">watch</a> property. <code>watch</code> requires watching a specific data source and applies side effects in a separate callback function. It also is lazy by default - i.e. the callback is only called when the watched source has changed.</p> <ul><li>
<p>Compared to <a href="#watcheffect">watchEffect</a>, <code>watch</code> allows us to:</p> <ul>
<li>Perform the side effect lazily;</li> <li>Be more specific about what state should trigger the watcher to re-run;</li> <li>Access both the previous and current value of the watched state.</li>
</ul>
</li></ul> <h3 id="watching-a-single-source"> Watching a Single Source</h3> <p>A watcher data source can either be a getter function that returns a value, or directly a <code>ref</code>:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="js">// watching a getter
const state = reactive({ count: 0 })
watch(
  () =&gt; state.count,
  (count, prevCount) =&gt; {
    /* ... */
  }
)

// directly watching a ref
const count = ref(0)
watch(count, (count, prevCount) =&gt; {
  /* ... */
})</pre> </div>
<h3 id="watching-multiple-sources"> Watching Multiple Sources</h3> <p>A watcher can also watch multiple sources at the same time using an array:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="js">watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =&gt; {
  /* ... */
})</pre> </div>
<h3 id="shared-behavior-with-watcheffect"> Shared Behavior with <code>watchEffect</code>
</h3> <p><code>watch</code> shares behavior with <a href="#watcheffect"><code>watchEffect</code></a> in terms of <a href="#stopping-the-watcher">manual stoppage</a>, <a href="#side-effect-invalidation">side effect invalidation</a> (with <code>onInvalidate</code> passed to the callback as the 3rd argument instead), <a href="#effect-flush-timing">flush timing</a> and <a href="#watcher-debugging">debugging</a>.</p>
</div>  <div class="page-nav" style="text-align: center; margin-bottom: 1rem;"><p class="inner"><span class="prev" style="text-align: left; float: left;"> ← <a href="reactivity-fundamentals" class="prev">Reactivity Fundamentals</a></span> <span class="next" style="text-align: right; float: right;"><a href="composition-api-introduction">Introduction</a> → </span></p></div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2013–present Yuxi Evan You<br>Licensed under the MIT License.<br>
    <a href="https://v3.vuejs.org/guide/reactivity-computed-watchers.html" class="_attribution-link">https://v3.vuejs.org/guide/reactivity-computed-watchers.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
