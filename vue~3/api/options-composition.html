
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>8. Composition - Vue.js 3 - W3cubDocs</title>
  
  <meta name="description" content=" Type&#58; Array&#60;Object&#62; ">
  <meta name="keywords" content="composition, vue, js, vue~3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/vue~3/api/options-composition.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c2f2e7d1236e299f399a2d9bf4342fa70a8839fbe6eb79130546d6bf383b99636ffdf29c557090085d7c4ac34eeb5426851b42d2f4ec63cf218916cbd19aa876.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/vue~3.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/vue~3/" class="_nav-link" title="" style="margin-left:0;">Vue.js 3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _vue">
				
				
<div class="theme-default-content content__default">
<h1 id="composition"> Composition</h1> <h2 id="mixins"> mixins</h2> <ul>
<li><p><strong>Type:</strong> <code>Array&lt;Object&gt;</code></p></li> <li>
<p><strong>Details:</strong></p> <p>The <code>mixins</code> option accepts an array of mixin objects. These mixin objects can contain instance options like normal instance objects, and they will be merged against the eventual options using the certain option merging logic. For example, if your mixin contains a <code>created</code> hook and the component itself also has one, both functions will be called.</p> <p>Mixin hooks are called in the order they are provided, and called before the component's own hooks.</p> <div class="custom-block info">
<strong class="custom-block-title">INFO</strong><p>In Vue 2, mixins were the primary mechanism for creating reusable chunks of component logic. While mixins continue to be supported in Vue 3, the <a href="../guide/composition-api-introduction">Composition API</a> is now the preferred approach for code reuse between components.</p>
</div>
</li> <li>
<p><strong>Example:</strong></p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const mixin = {
  created() {
    console.log(1)
  }
}

createApp({
  created() {
    console.log(2)
  },
  mixins: [mixin]
})

// =&gt; 1
// =&gt; 2</pre> </div>
</li> <li><p><strong>See also:</strong> <a href="../guide/mixins">Mixins</a></p></li>
</ul> <h2 id="extends"> extends</h2> <ul>
<li><p><strong>Type:</strong> <code>Object</code></p></li> <li>
<p><strong>Details:</strong></p> <p>Allows one component to extend another, inheriting its component options.</p> <p>From an implementation perspective, <code>extends</code> is almost identical to <code>mixins</code>. The component specified by <code>extends</code> will be treated as though it were the first mixin.</p> <p>However, <code>extends</code> and <code>mixins</code> express different intents. The <code>mixins</code> option is primarily used to compose chunks of functionality, whereas <code>extends</code> is primarily concerned with inheritance.</p> <p>As with <code>mixins</code>, any options will be merged using the relevant merge strategy.</p>
</li> <li>
<p><strong>Example:</strong></p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const CompA = { ... }

const CompB = {
  extends: CompA,
  ...
}</pre> </div>
</li>
</ul> <h2 id="provide-inject"> provide / inject</h2> <ul>
<li>
<p><strong>Type:</strong></p> <ul>
<li>
<strong>provide:</strong> <code>Object | () =&gt; Object</code>
</li> <li>
<strong>inject:</strong> <code>Array&lt;string&gt; | { [key: string]: string | Symbol | Object }</code>
</li>
</ul>
</li> <li>
<p><strong>Details:</strong></p> <p>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React's <code>context</code> feature.</p> <p>The <code>provide</code> option should be an object or a function that returns an object. This object contains the properties that are available for injection into its descendants. You can use ES2015 Symbols as keys in this object, but only in environments that natively support <code>Symbol</code> and <code>Reflect.ownKeys</code>.</p> <p>The <code>inject</code> option should be either:</p> <ul>
<li>an array of strings, or</li> <li>an object where the keys are the local binding name and the value is either: <ul>
<li>the key (string or Symbol) to search for in available injections, or</li> <li>an object where: <ul>
<li>the <code>from</code> property is the key (string or Symbol) to search for in available injections, and</li> <li>the <code>default</code> property is used as fallback value</li>
</ul>
</li>
</ul>
</li>
</ul> <blockquote><p>Note: the <code>provide</code> and <code>inject</code> bindings are NOT reactive. This is intentional. However, if you pass down a reactive object, properties on that object do remain reactive.</p></blockquote>
</li> <li>
<p><strong>Example:</strong></p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">// parent component providing 'foo'
const Provider = {
  provide: {
    foo: 'bar'
  }
  // ...
}

// child component injecting 'foo'
const Child = {
  inject: ['foo'],
  created() {
    console.log(this.foo) // =&gt; "bar"
  }
  // ...
}</pre> </div>
<p>With ES2015 Symbols, function <code>provide</code> and object <code>inject</code>:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const s = Symbol()

const Provider = {
  provide() {
    return {
      [s]: 'foo'
    }
  }
}

const Child = {
  inject: { s }
  // ...
}</pre> </div>
<p>Using an injected value as the default for a prop:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const Child = {
  inject: ['foo'],
  props: {
    bar: {
      default() {
        return this.foo
      }
    }
  }
}</pre> </div>
<p>Using an injected value as data entry:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const Child = {
  inject: ['foo'],
  data() {
    return {
      bar: this.foo
    }
  }
}</pre> </div>
<p>Injections can be optional with default value:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const Child = {
  inject: {
    foo: { default: 'foo' }
  }
}</pre> </div>
<p>If it needs to be injected from a property with a different name, use <code>from</code> to denote the source property:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const Child = {
  inject: {
    foo: {
      from: 'bar',
      default: 'foo'
    }
  }
}</pre> </div>
<p>Similar to prop defaults, you need to use a factory function for non-primitive values:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const Child = {
  inject: {
    foo: {
      from: 'bar',
      default: () =&gt; [1, 2, 3]
    }
  }
}</pre> </div>
</li> <li><p><strong>See also:</strong> <a href="../guide/component-provide-inject">Provide / Inject</a></p></li>
</ul> <h2 id="setup"> setup</h2> <ul><li>
<strong>Type:</strong> <code>Function</code>
</li></ul> <p>The <code>setup</code> function is a new component option. It serves as the entry point for using the Composition API inside components.</p> <ul>
<li>
<p><strong>Invocation Timing</strong></p> <p><code>setup</code> is called right after the initial props resolution when a component instance is created. Lifecycle-wise, it is called before the <a href="options-lifecycle-hooks#beforecreate">beforeCreate</a> hook.</p>
</li> <li>
<p><strong>Usage with Templates</strong></p> <p>If <code>setup</code> returns an object, the properties on the object will be merged on to the render context for the component's template:</p> <div class="language-html line-numbers-mode">
<pre class="language-html" data-language="javascript">&lt;template&gt;
  &lt;div&gt;{{ count }} {{ object.foo }}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import { ref, reactive } from 'vue'

  export default {
    setup() {
      const count = ref(0)
      const object = reactive({ foo: 'bar' })

      // expose to template
      return {
        count,
        object
      }
    }
  }
&lt;/script&gt;</pre> </div>
<p>Note that <a href="refs-api#ref">refs</a> returned from <code>setup</code> are automatically unwrapped when accessed in the template so there's no need for <code>.value</code> in templates.</p>
</li> <li>
<p><strong>Usage with Render Functions / JSX</strong></p> <p><code>setup</code> can also return a render function, which can directly make use of reactive state declared in the same scope:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">import { h, ref, reactive } from 'vue'

export default {
  setup() {
    const count = ref(0)
    const object = reactive({ foo: 'bar' })

    return () =&gt; h('div', [count.value, object.foo])
  }
}</pre> </div>
</li> <li>
<p><strong>Arguments</strong></p> <p>The function receives the resolved props as its first argument:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">export default {
  props: {
    name: String
  },
  setup(props) {
    console.log(props.name)
  }
}</pre> </div>
<p>Note this <code>props</code> object is reactive - i.e. it is updated when new props are passed in, and can be observed and reacted upon using <code>watchEffect</code> or <code>watch</code>:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">export default {
  props: {
    name: String
  },
  setup(props) {
    watchEffect(() =&gt; {
      console.log(`name is: ` + props.name)
    })
  }
}</pre> </div>
<p>However, do NOT destructure the <code>props</code> object, as it will lose reactivity:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">export default {
  props: {
    name: String
  },
  setup({ name }) {
    watchEffect(() =&gt; {
      console.log(`name is: ` + name) // Will not be reactive!
    })
  }
}</pre> </div>
<p>The <code>props</code> object is immutable for userland code during development (will emit warning if user code attempts to mutate it).</p> <p>The second argument provides a context object which exposes various objects and functions that might be useful in <code>setup</code>:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const MyComponent = {
  setup(props, context) {
    context.attrs
    context.slots
    context.emit
    context.expose
  }
}</pre> </div>
<p><code>attrs</code>, <code>slots</code>, and <code>emit</code> are equivalent to the instance properties <a href="instance-properties#attrs"><code>$attrs</code></a>, <a href="instance-properties#slots"><code>$slots</code></a>, and <a href="instance-methods#emit"><code>$emit</code></a> respectively.</p> <p><code>attrs</code> and <code>slots</code> are proxies to the corresponding values on the internal component instance. This ensures they always expose the latest values even after updates so that we can destructure them without worrying about accessing a stale reference:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const MyComponent = {
  setup(props, { attrs }) {
    // a function that may get called at a later stage
    function onClick() {
      console.log(attrs.foo) // guaranteed to be the latest reference
    }
  }
}</pre> </div>
<p><code>expose</code>, added in Vue 3.2, is a function that allows specific properties to be exposed via the public component instance. By default, the public instance retrieved using refs, <code>$parent</code>, or <code>$root</code> is equivalent to the internal instance used by the template. Calling <code>expose</code> will create a separate public instance with the properties specified:</p> <div class="language-js line-numbers-mode">
<pre class="language-js" data-language="javascript">const MyComponent = {
  setup(props, { expose }) {
    const count = ref(0)
    const reset = () =&gt; count.value = 0
    const increment = () =&gt; count.value++

    // Only reset will be available externally, e.g. via $refs
    expose({
      reset
    })

    // Internally, the template has access to count and increment
    return { count, increment }
  }
}</pre> </div>
<p>There are a number of reasons for placing <code>props</code> as a separate first argument instead of including it in the context:</p> <ul>
<li><p>It's much more common for a component to use <code>props</code> than the other properties, and very often a component uses only <code>props</code>.</p></li> <li><p>Having <code>props</code> as a separate argument makes it easier to type it individually without messing up the types of other properties on the context. It also makes it possible to keep a consistent signature across <code>setup</code>, <code>render</code> and plain functional components with TSX support.</p></li>
</ul>
</li> <li><p><strong>See also:</strong> <a href="composition-api">Composition API</a></p></li>
</ul>
</div>   <div class="_attribution">
  <p class="_attribution-p">
    © 2013–present Yuxi Evan You<br>Licensed under the MIT License.<br>
    <a href="https://v3.vuejs.org/api/options-composition.html" class="_attribution-link">https://v3.vuejs.org/api/options-composition.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
