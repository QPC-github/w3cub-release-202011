
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Kernel - Elixir 1.11 - W3cubDocs</title>
  
  <meta name="description" content=" Kernel is Elixir&#39;s default environment. ">
  <meta name="keywords" content="kernel, summary, guards, functions, elixir, elixir~1.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/elixir~1.11/kernel.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/elixir~1.11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.11/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1> Kernel   </h1> <section id="moduledoc"> <p><a href="#content"><code class="inline">Kernel</code></a> is Elixir's default environment.</p>
<p>It mainly consists of:</p>
<ul>
<li>basic language primitives, such as arithmetic operators, spawning of processes, data type handling, and others</li>
<li>macros for control-flow and defining new functionality (modules, functions, and the like)</li>
<li>guard checks for augmenting pattern matching</li>
</ul>
<p>You can invoke <a href="#content"><code class="inline">Kernel</code></a> functions and macros anywhere in Elixir code without the use of the <code class="inline">Kernel.</code> prefix since they have all been automatically imported. For example, in IEx, you can call:</p>
<pre data-language="elixir">iex&gt; is_number(13)
true</pre>
<p>If you don't want to import a function or macro from <a href="#content"><code class="inline">Kernel</code></a>, use the <code class="inline">:except</code> option and then list the function/macro by arity:</p>
<pre data-language="elixir">import Kernel, except: [if: 2, unless: 2]</pre>
<p>See <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2"><code class="inline">Kernel.SpecialForms.import/2</code></a> for more information on importing.</p>
<p>Elixir also has special forms that are always imported and cannot be skipped. These are described in <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html"><code class="inline">Kernel.SpecialForms</code></a>.</p>
<h2 id="module-the-standard-library" class="section-heading">  The standard library </h2> <p><a href="#content"><code class="inline">Kernel</code></a> provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries).</p>
<h3 id="module-built-in-types" class="section-heading">  Built-in types </h3> <p>The following modules handle Elixir built-in data types:</p>
<ul>
<li>
<a href="https://hexdocs.pm/elixir/Atom.html"><code class="inline">Atom</code></a> - literal constants with a name (<code class="inline">true</code>, <code class="inline">false</code>, and <code class="inline">nil</code> are atoms)</li>
<li>
<a href="https://hexdocs.pm/elixir/Float.html"><code class="inline">Float</code></a> - numbers with floating point precision</li>
<li>
<a href="https://hexdocs.pm/elixir/Function.html"><code class="inline">Function</code></a> - a reference to code chunk, created with the <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#fn/1"><code class="inline">fn/1</code></a> special form</li>
<li>
<a href="https://hexdocs.pm/elixir/Integer.html"><code class="inline">Integer</code></a> - whole numbers (not fractions)</li>
<li>
<a href="https://hexdocs.pm/elixir/List.html"><code class="inline">List</code></a> - collections of a variable number of elements (linked lists)</li>
<li>
<a href="https://hexdocs.pm/elixir/Map.html"><code class="inline">Map</code></a> - collections of key-value pairs</li>
<li>
<a href="https://hexdocs.pm/elixir/Process.html"><code class="inline">Process</code></a> - light-weight threads of execution</li>
<li>
<a href="https://hexdocs.pm/elixir/Port.html"><code class="inline">Port</code></a> - mechanisms to interact with the external world</li>
<li>
<a href="https://hexdocs.pm/elixir/Tuple.html"><code class="inline">Tuple</code></a> - collections of a fixed number of elements</li>
</ul>
<p>There are two data types without an accompanying module:</p>
<ul>
<li>Bitstring - a sequence of bits, created with <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1"><code class="inline">Kernel.SpecialForms.&lt;&lt;&gt;&gt;/1</code></a>. When the number of bits is divisible by 8, they are called binaries and can be manipulated with Erlang's <code class="inline">:binary</code> module</li>
<li>Reference - a unique value in the runtime system, created with <a href="#make_ref/0"><code class="inline">make_ref/0</code></a>
</li>
</ul>
<h3 id="module-data-types" class="section-heading">  Data types </h3> <p>Elixir also provides other data types that are built on top of the types listed above. Some of them are:</p>
<ul>
<li>
<a href="https://hexdocs.pm/elixir/Date.html"><code class="inline">Date</code></a> - <code class="inline">year-month-day</code> structs in a given calendar</li>
<li>
<a href="https://hexdocs.pm/elixir/DateTime.html"><code class="inline">DateTime</code></a> - date and time with time zone in a given calendar</li>
<li>
<a href="https://hexdocs.pm/elixir/Exception.html"><code class="inline">Exception</code></a> - data raised from errors and unexpected scenarios</li>
<li>
<a href="https://hexdocs.pm/elixir/MapSet.html"><code class="inline">MapSet</code></a> - unordered collections of unique elements</li>
<li>
<a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a> - date and time without time zone in a given calendar</li>
<li>
<a href="https://hexdocs.pm/elixir/Keyword.html"><code class="inline">Keyword</code></a> - lists of two-element tuples, often representing optional values</li>
<li>
<a href="https://hexdocs.pm/elixir/Range.html"><code class="inline">Range</code></a> - inclusive ranges between two integers</li>
<li>
<a href="https://hexdocs.pm/elixir/Regex.html"><code class="inline">Regex</code></a> - regular expressions</li>
<li>
<a href="https://hexdocs.pm/elixir/String.html"><code class="inline">String</code></a> - UTF-8 encoded binaries representing characters</li>
<li>
<a href="https://hexdocs.pm/elixir/Time.html"><code class="inline">Time</code></a> - <code class="inline">hour:minute:second</code> structs in a given calendar</li>
<li>
<a href="https://hexdocs.pm/elixir/URI.html"><code class="inline">URI</code></a> - representation of URIs that identify resources</li>
<li>
<a href="https://hexdocs.pm/elixir/Version.html"><code class="inline">Version</code></a> - representation of versions and requirements</li>
</ul>
<h3 id="module-system-modules" class="section-heading">  System modules </h3> <p>Modules that interface with the underlying system, such as:</p>
<ul>
<li>
<a href="https://hexdocs.pm/elixir/IO.html"><code class="inline">IO</code></a> - handles input and output</li>
<li>
<a href="https://hexdocs.pm/elixir/File.html"><code class="inline">File</code></a> - interacts with the underlying file system</li>
<li>
<a href="https://hexdocs.pm/elixir/Path.html"><code class="inline">Path</code></a> - manipulates file system paths</li>
<li>
<a href="https://hexdocs.pm/elixir/System.html"><code class="inline">System</code></a> - reads and writes system information</li>
</ul>
<h3 id="module-protocols" class="section-heading">  Protocols </h3> <p>Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See <a href="https://hexdocs.pm/elixir/Protocol.html"><code class="inline">Protocol</code></a> for more information on protocols. Elixir provides the following protocols in the standard library:</p>
<ul>
<li>
<a href="https://hexdocs.pm/elixir/Collectable.html"><code class="inline">Collectable</code></a> - collects data into a data type</li>
<li>
<a href="https://hexdocs.pm/elixir/Enumerable.html"><code class="inline">Enumerable</code></a> - handles collections in Elixir. The <a href="https://hexdocs.pm/elixir/Enum.html"><code class="inline">Enum</code></a> module provides eager functions for working with collections, the <a href="https://hexdocs.pm/elixir/Stream.html"><code class="inline">Stream</code></a> module provides lazy functions</li>
<li>
<a href="https://hexdocs.pm/elixir/Inspect.html"><code class="inline">Inspect</code></a> - converts data types into their programming language representation</li>
<li>
<a href="https://hexdocs.pm/elixir/List.Chars.html"><code class="inline">List.Chars</code></a> - converts data types to their outside world representation as charlists (non-programming based)</li>
<li>
<a href="https://hexdocs.pm/elixir/String.Chars.html"><code class="inline">String.Chars</code></a> - converts data types to their outside world representation as strings (non-programming based)</li>
</ul>
<h3 id="module-process-based-and-application-centric-functionality" class="section-heading">  Process-based and application-centric functionality </h3> <p>The following modules build on top of processes to provide concurrency, fault-tolerance, and more.</p>
<ul>
<li>
<a href="https://hexdocs.pm/elixir/Agent.html"><code class="inline">Agent</code></a> - a process that encapsulates mutable state</li>
<li>
<a href="https://hexdocs.pm/elixir/Application.html"><code class="inline">Application</code></a> - functions for starting, stopping and configuring applications</li>
<li>
<a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a> - a generic client-server API</li>
<li>
<a href="https://hexdocs.pm/elixir/Registry.html"><code class="inline">Registry</code></a> - a key-value process-based storage</li>
<li>
<a href="https://hexdocs.pm/elixir/Supervisor.html"><code class="inline">Supervisor</code></a> - a process that is responsible for starting, supervising and shutting down other processes</li>
<li>
<a href="https://hexdocs.pm/elixir/Task.html"><code class="inline">Task</code></a> - a process that performs computations</li>
<li>
<a href="https://hexdocs.pm/elixir/Task.Supervisor.html"><code class="inline">Task.Supervisor</code></a> - a supervisor for managing tasks exclusively</li>
</ul>
<h3 id="module-supporting-documents" class="section-heading">  Supporting documents </h3> <p>Elixir documentation also includes supporting documents under the "Pages" section. Those are:</p>
<ul>
<li>
<a href="compatibility-and-deprecations">Compatibility and Deprecations</a> - lists compatibility between every Elixir version and Erlang/OTP, release schema; lists all deprecated functions, when they were deprecated and alternatives</li>
<li>
<a href="library-guidelines">Library Guidelines</a> - general guidelines, anti-patterns, and rules for those writing libraries</li>
<li>
<a href="naming-conventions">Naming Conventions</a> - naming conventions for Elixir code</li>
<li>
<a href="operators">Operators</a> - lists all Elixir operators and their precedences</li>
<li>
<a href="patterns-and-guards">Patterns and Guards</a> - an introduction to patterns, guards, and extensions</li>
<li>
<a href="syntax-reference">Syntax Reference</a> - the language syntax reference</li>
<li>
<a href="typespecs">Typespecs</a>- types and function specifications, including list of types</li>
<li>
<a href="unicode-syntax">Unicode Syntax</a> - outlines Elixir support for Unicode</li>
<li>
<a href="writing-documentation">Writing Documentation</a> - guidelines for writing documentation in Elixir</li>
</ul>
<h2 id="module-guards" class="section-heading">  Guards </h2> <p>This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the <code class="inline">when</code> operator. For example:</p>
<pre data-language="elixir">def drive(%User{age: age}) when age &gt;= 16 do
  ...
end</pre>
<p>The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with <code class="inline">and</code> and <code class="inline">or</code>. The whole guard is true if all guard expressions will evaluate to <code class="inline">true</code>. A more complete introduction to guards is available <a href="patterns-and-guards">in the "Patterns and Guards" page</a>.</p>
<h2 id="module-inlining" class="section-heading">  Inlining </h2> <p>Some of the functions described in this module are inlined by the Elixir compiler into their Erlang counterparts in the <a href="http://www.erlang.org/doc/man/erlang.html"><code class="inline">:erlang</code> module</a>. Those functions are called BIFs (built-in internal functions) in Erlang-land and they exhibit interesting properties, as some of them are allowed in guards and others are used for compiler optimizations.</p>
<p>Most of the inlined functions can be seen in effect when capturing the function:</p>
<pre data-language="elixir">iex&gt; &amp;Kernel.is_atom/1
&amp;:erlang.is_atom/1</pre>
<p>Those functions will be explicitly marked in their docs as "inlined by the compiler".</p>
<h2 id="module-truthy-and-falsy-values" class="section-heading">  Truthy and falsy values </h2> <p>Besides the booleans <code class="inline">true</code> and <code class="inline">false</code>, Elixir has the concept of a "truthy" or "falsy" value.</p>
<ul>
<li> a value is truthy when it is neither <code class="inline">false</code> nor <code class="inline">nil</code>
</li>
<li> a value is falsy when it is either <code class="inline">false</code> or <code class="inline">nil</code>
</li>
</ul>
<p>Elixir has functions, like <a href="#and/2"><code class="inline">and/2</code></a>, that <em>only</em> work with booleans, but also functions that work with these truthy/falsy values, like <a href="#&amp;&amp;/2"><code class="inline">&amp;&amp;/2</code></a> and <a href="#!/1"><code class="inline">!/1</code></a>.</p>
<h3 id="module-examples" class="section-heading">  Examples </h3> <p>We can check the truthiness of a value by using the <a href="#!/1"><code class="inline">!/1</code></a> function twice.</p>
<p>Truthy values:</p>
<pre data-language="elixir">iex&gt; !!true
true
iex&gt; !!5
true
iex&gt; !![1,2]
true
iex&gt; !!"foo"
true</pre>
<p>Falsy values (of which there are exactly two):</p>
<pre data-language="elixir">iex&gt; !!false
false
iex&gt; !!nil
false</pre> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Guards </h2>
<dl class="summary-guards summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#!=/2">left != right</a> </dt> <dd class="summary-synopsis"><p>Not equal to operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#!==/2">left !== right</a> </dt> <dd class="summary-synopsis"><p>Strictly not equal to operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#*/2">left * right</a> </dt> <dd class="summary-synopsis"><p>Arithmetic multiplication operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#+/1">+value</a> </dt> <dd class="summary-synopsis"><p>Arithmetic positive unary operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#+/2">left + right</a> </dt> <dd class="summary-synopsis"><p>Arithmetic addition operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#-/1">-value</a> </dt> <dd class="summary-synopsis"><p>Arithmetic negative unary operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#-/2">left - right</a> </dt> <dd class="summary-synopsis"><p>Arithmetic subtraction operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#//2">left / right</a> </dt> <dd class="summary-synopsis"><p>Arithmetic division operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%3C/2">left &lt; right</a> </dt> <dd class="summary-synopsis"><p>Less-than operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%3C=/2">left &lt;= right</a> </dt> <dd class="summary-synopsis"><p>Less-than or equal to operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#==/2">left == right</a> </dt> <dd class="summary-synopsis"><p>Equal to operator. Returns <code class="inline">true</code> if the two terms are equal.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#===/2">left === right</a> </dt> <dd class="summary-synopsis"><p>Strictly equal to operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%3E/2">left &gt; right</a> </dt> <dd class="summary-synopsis"><p>Greater-than operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%3E=/2">left &gt;= right</a> </dt> <dd class="summary-synopsis"><p>Greater-than or equal to operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#abs/1">abs(number)</a> </dt> <dd class="summary-synopsis"><p>Returns an integer or float which is the arithmetical absolute value of <code class="inline">number</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#and/2">left and right</a> </dt> <dd class="summary-synopsis"><p>Strictly boolean "and" operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#binary_part/3">binary_part(binary, start, length)</a> </dt> <dd class="summary-synopsis"><p>Extracts the part of the binary starting at <code class="inline">start</code> with length <code class="inline">length</code>. Binaries are zero-indexed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#bit_size/1">bit_size(bitstring)</a> </dt> <dd class="summary-synopsis"><p>Returns an integer which is the size in bits of <code class="inline">bitstring</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#byte_size/1">byte_size(bitstring)</a> </dt> <dd class="summary-synopsis"><p>Returns the number of bytes needed to contain <code class="inline">bitstring</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#ceil/1">ceil(number)</a> </dt> <dd class="summary-synopsis"><p>Returns the smallest integer greater than or equal to <code class="inline">number</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#div/2">div(dividend, divisor)</a> </dt> <dd class="summary-synopsis"><p>Performs an integer division.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#elem/2">elem(tuple, index)</a> </dt> <dd class="summary-synopsis"><p>Gets the element at the zero-based <code class="inline">index</code> in <code class="inline">tuple</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#floor/1">floor(number)</a> </dt> <dd class="summary-synopsis"><p>Returns the largest integer smaller than or equal to <code class="inline">number</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#hd/1">hd(list)</a> </dt> <dd class="summary-synopsis"><p>Returns the head of a list. Raises <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> if the list is empty.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#in/2">left in right</a> </dt> <dd class="summary-synopsis"><p>Membership operator. Checks if the element on the left-hand side is a member of the collection on the right-hand side.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_atom/1">is_atom(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is an atom; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_binary/1">is_binary(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a binary; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_bitstring/1">is_bitstring(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a bitstring (including a binary); otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_boolean/1">is_boolean(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is either the atom <code class="inline">true</code> or the atom <code class="inline">false</code> (i.e., a boolean); otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_exception/1">is_exception(term)</a> </dt> <dd class="summary-synopsis"><p>Returns true if <code class="inline">term</code> is an exception; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_exception/2">is_exception(term, name)</a> </dt> <dd class="summary-synopsis"><p>Returns true if <code class="inline">term</code> is an exception of <code class="inline">name</code>; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_float/1">is_float(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a floating-point number; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_function/1">is_function(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a function; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_function/2">is_function(term, arity)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a function that can be applied with <code class="inline">arity</code> number of arguments; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_integer/1">is_integer(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is an integer; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_list/1">is_list(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a list with zero or more elements; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_map/1">is_map(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a map; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_map_key/2">is_map_key(map, key)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">key</code> is a key in <code class="inline">map</code>; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_nil/1">is_nil(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is <code class="inline">nil</code>, <code class="inline">false</code> otherwise.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_number/1">is_number(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is either an integer or a floating-point number; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_pid/1">is_pid(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a PID (process identifier); otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_port/1">is_port(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a port identifier; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_reference/1">is_reference(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a reference; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_struct/1">is_struct(term)</a> </dt> <dd class="summary-synopsis"><p>Returns true if <code class="inline">term</code> is a struct; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_struct/2">is_struct(term, name)</a> </dt> <dd class="summary-synopsis"><p>Returns true if <code class="inline">term</code> is a struct of <code class="inline">name</code>; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#is_tuple/1">is_tuple(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a tuple; otherwise returns <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#length/1">length(list)</a> </dt> <dd class="summary-synopsis"><p>Returns the length of <code class="inline">list</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#map_size/1">map_size(map)</a> </dt> <dd class="summary-synopsis"><p>Returns the size of a map.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#node/0">node()</a> </dt> <dd class="summary-synopsis"><p>Returns an atom representing the name of the local node. If the node is not alive, <code class="inline">:nonode@nohost</code> is returned instead.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#node/1">node(arg)</a> </dt> <dd class="summary-synopsis"><p>Returns the node where the given argument is located. The argument can be a PID, a reference, or a port. If the local node is not alive, <code class="inline">:nonode@nohost</code> is returned.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#not/1">not(value)</a> </dt> <dd class="summary-synopsis"><p>Strictly boolean "not" operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#or/2">left or right</a> </dt> <dd class="summary-synopsis"><p>Strictly boolean "or" operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#rem/2">rem(dividend, divisor)</a> </dt> <dd class="summary-synopsis"><p>Computes the remainder of an integer division.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#round/1">round(number)</a> </dt> <dd class="summary-synopsis"><p>Rounds a number to the nearest integer.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#self/0">self()</a> </dt> <dd class="summary-synopsis"><p>Returns the PID (process identifier) of the calling process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#tl/1">tl(list)</a> </dt> <dd class="summary-synopsis"><p>Returns the tail of a list. Raises <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> if the list is empty.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#trunc/1">trunc(number)</a> </dt> <dd class="summary-synopsis"><p>Returns the integer part of <code class="inline">number</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#tuple_size/1">tuple_size(tuple)</a> </dt> <dd class="summary-synopsis"><p>Returns the size of a tuple.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#!/1">!value</a> </dt> <dd class="summary-synopsis"><p>Boolean "not" operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#&amp;&amp;/2">left &amp;&amp; right</a> </dt> <dd class="summary-synopsis"><p>Boolean "and" operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#++/2">left ++ right</a> </dt> <dd class="summary-synopsis"><p>List concatenation operator. Concatenates a proper list and a term, returning a list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#--/2">left -- right</a> </dt> <dd class="summary-synopsis"><p>List subtraction operator. Removes the first occurrence of an element on the left list for each element on the right.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#../2">first..last</a> </dt> <dd class="summary-synopsis"><p>Range creation operator. Returns a range with the specified <code class="inline">first</code> and <code class="inline">last</code> integers.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%3C%3E/2">left &lt;&gt; right</a> </dt> <dd class="summary-synopsis"><p>Binary concatenation operator. Concatenates two binaries.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#=~/2">left =~ right</a> </dt> <dd class="summary-synopsis"><p>Text-based match operator. Matches the term on the <code class="inline">left</code> against the regular expression or string on the <code class="inline">right</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#@/1">@expr</a> </dt> <dd class="summary-synopsis"><p>Module attribute unary operator. Reads and writes attributes in the current module.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%7C%3E/2">left |&gt; right</a> </dt> <dd class="summary-synopsis"><p>Pipe operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%7C%7C/2">left || right</a> </dt> <dd class="summary-synopsis"><p>Boolean "or" operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#alias!/1">alias!(alias)</a> </dt> <dd class="summary-synopsis"><p>When used inside quoting, marks that the given alias should not be hygienized. This means the alias will be expanded when the macro is expanded.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#apply/2">apply(fun, args)</a> </dt> <dd class="summary-synopsis"><p>Invokes the given anonymous function <code class="inline">fun</code> with the list of arguments <code class="inline">args</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#apply/3">apply(module, function_name, args)</a> </dt> <dd class="summary-synopsis"><p>Invokes the given function from <code class="inline">module</code> with the list of arguments <code class="inline">args</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#binding/1">binding(context \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns the binding for the given context as a keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#def/2">def(call, expr \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Defines a public function with the given name and body.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#defdelegate/2">defdelegate(funs, opts)</a> </dt> <dd class="summary-synopsis"><p>Defines a function that delegates to another module.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#defexception/1">defexception(fields)</a> </dt> <dd class="summary-synopsis"><p>Defines an exception.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#defguard/1">defguard(guard)</a> </dt> <dd class="summary-synopsis"><p>Generates a macro suitable for use in guard expressions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#defguardp/1">defguardp(guard)</a> </dt> <dd class="summary-synopsis"><p>Generates a private macro suitable for use in guard expressions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#defimpl/3">defimpl(name, opts, do_block \\ [])</a> </dt> <dd class="summary-synopsis"><p>Defines an implementation for the given protocol.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#defmacro/2">defmacro(call, expr \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Defines a public macro with the given name and body.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#defmacrop/2">defmacrop(call, expr \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Defines a private macro with the given name and body.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#defmodule/2">defmodule(alias, do_block)</a> </dt> <dd class="summary-synopsis"><p>Defines a module given by name with the given contents.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#defoverridable/1">defoverridable(keywords_or_behaviour)</a> </dt> <dd class="summary-synopsis"><p>Makes the given functions in the current module overridable.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#defp/2">defp(call, expr \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Defines a private function with the given name and body.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#defprotocol/2">defprotocol(name, do_block)</a> </dt> <dd class="summary-synopsis"><p>Defines a protocol.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#defstruct/1">defstruct(fields)</a> </dt> <dd class="summary-synopsis"><p>Defines a struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#destructure/2">destructure(left, right)</a> </dt> <dd class="summary-synopsis"><p>Destructures two lists, assigning each term in the right one to the matching term in the left one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#exit/1">exit(reason)</a> </dt> <dd class="summary-synopsis"><p>Stops the execution of the calling process with the given reason.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#function_exported?/3">function_exported?(module, function, arity)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">module</code> is loaded and contains a public <code class="inline">function</code> with the given <code class="inline">arity</code>, otherwise <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_and_update_in/2">get_and_update_in(path, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets a value and updates a nested data structure via the given <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_and_update_in/3">get_and_update_in(data, keys, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets a value and updates a nested structure.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_in/2">get_in(data, keys)</a> </dt> <dd class="summary-synopsis"><p>Gets a value from a nested structure.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#if/2">if(condition, clauses)</a> </dt> <dd class="summary-synopsis"><p>Provides an <a href="#if/2"><code class="inline">if/2</code></a> macro.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#inspect/2">inspect(term, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Inspects the given argument according to the <a href="https://hexdocs.pm/elixir/Inspect.html"><code class="inline">Inspect</code></a> protocol. The second argument is a keyword list with options to control inspection.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#macro_exported?/3">macro_exported?(module, macro, arity)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">module</code> is loaded and contains a public <code class="inline">macro</code> with the given <code class="inline">arity</code>, otherwise <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#make_ref/0">make_ref()</a> </dt> <dd class="summary-synopsis"><p>Returns an almost unique reference.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#match?/2">match?(pattern, expr)</a> </dt> <dd class="summary-synopsis"><p>A convenience macro that checks if the right side (an expression) matches the left side (a pattern).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#max/2">max(first, second)</a> </dt> <dd class="summary-synopsis"><p>Returns the biggest of the two given terms according to Erlang's term ordering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#min/2">min(first, second)</a> </dt> <dd class="summary-synopsis"><p>Returns the smallest of the two given terms according to Erlang's term ordering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pop_in/1">pop_in(path)</a> </dt> <dd class="summary-synopsis"><p>Pops a key from the nested structure via the given <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pop_in/2">pop_in(data, keys)</a> </dt> <dd class="summary-synopsis"><p>Pops a key from the given nested structure.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_elem/3">put_elem(tuple, index, value)</a> </dt> <dd class="summary-synopsis"><p>Puts <code class="inline">value</code> at the given zero-based <code class="inline">index</code> in <code class="inline">tuple</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_in/2">put_in(path, value)</a> </dt> <dd class="summary-synopsis"><p>Puts a value in a nested structure via the given <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_in/3">put_in(data, keys, value)</a> </dt> <dd class="summary-synopsis"><p>Puts a value in a nested structure.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#raise/1">raise(message)</a> </dt> <dd class="summary-synopsis"><p>Raises an exception.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#raise/2">raise(exception, attributes)</a> </dt> <dd class="summary-synopsis"><p>Raises an exception.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reraise/2">reraise(message, stacktrace)</a> </dt> <dd class="summary-synopsis"><p>Raises an exception preserving a previous stacktrace.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reraise/3">reraise(exception, attributes, stacktrace)</a> </dt> <dd class="summary-synopsis"><p>Raises an exception preserving a previous stacktrace.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send/2">send(dest, message)</a> </dt> <dd class="summary-synopsis"><p>Sends a message to the given <code class="inline">dest</code> and returns the message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_C/2">sigil_C(term, modifiers)</a> </dt> <dd class="summary-synopsis"><p>Handles the sigil <code class="inline">~C</code> for charlists.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_D/2">sigil_D(date_string, modifiers)</a> </dt> <dd class="summary-synopsis"><p>Handles the sigil <code class="inline">~D</code> for dates.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_N/2">sigil_N(naive_datetime_string, modifiers)</a> </dt> <dd class="summary-synopsis"><p>Handles the sigil <code class="inline">~N</code> for naive date times.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_R/2">sigil_R(term, modifiers)</a> </dt> <dd class="summary-synopsis"><p>Handles the sigil <code class="inline">~R</code> for regular expressions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_S/2">sigil_S(term, modifiers)</a> </dt> <dd class="summary-synopsis"><p>Handles the sigil <code class="inline">~S</code> for strings.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_T/2">sigil_T(time_string, modifiers)</a> </dt> <dd class="summary-synopsis"><p>Handles the sigil <code class="inline">~T</code> for times.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_U/2">sigil_U(datetime_string, modifiers)</a> </dt> <dd class="summary-synopsis"><p>Handles the sigil <code class="inline">~U</code> to create a UTC <a href="https://hexdocs.pm/elixir/DateTime.html"><code class="inline">DateTime</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_W/2">sigil_W(term, modifiers)</a> </dt> <dd class="summary-synopsis"><p>Handles the sigil <code class="inline">~W</code> for list of words.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_c/2">sigil_c(term, modifiers)</a> </dt> <dd class="summary-synopsis"><p>Handles the sigil <code class="inline">~c</code> for charlists.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_r/2">sigil_r(term, modifiers)</a> </dt> <dd class="summary-synopsis"><p>Handles the sigil <code class="inline">~r</code> for regular expressions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_s/2">sigil_s(term, modifiers)</a> </dt> <dd class="summary-synopsis"><p>Handles the sigil <code class="inline">~s</code> for strings.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_w/2">sigil_w(term, modifiers)</a> </dt> <dd class="summary-synopsis"><p>Handles the sigil <code class="inline">~w</code> for list of words.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#spawn/1">spawn(fun)</a> </dt> <dd class="summary-synopsis"><p>Spawns the given function and returns its PID.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#spawn/3">spawn(module, fun, args)</a> </dt> <dd class="summary-synopsis"><p>Spawns the given function <code class="inline">fun</code> from the given <code class="inline">module</code> passing it the given <code class="inline">args</code> and returns its PID.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#spawn_link/1">spawn_link(fun)</a> </dt> <dd class="summary-synopsis"><p>Spawns the given function, links it to the current process, and returns its PID.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#spawn_link/3">spawn_link(module, fun, args)</a> </dt> <dd class="summary-synopsis"><p>Spawns the given function <code class="inline">fun</code> from the given <code class="inline">module</code> passing it the given <code class="inline">args</code>, links it to the current process, and returns its PID.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#spawn_monitor/1">spawn_monitor(fun)</a> </dt> <dd class="summary-synopsis"><p>Spawns the given function, monitors it and returns its PID and monitoring reference.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#spawn_monitor/3">spawn_monitor(module, fun, args)</a> </dt> <dd class="summary-synopsis"><p>Spawns the given module and function passing the given args, monitors it and returns its PID and monitoring reference.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#struct/2">struct(struct, fields \\ [])</a> </dt> <dd class="summary-synopsis"><p>Creates and updates a struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#struct!/2">struct!(struct, fields \\ [])</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#struct/2"><code class="inline">struct/2</code></a> but checks for key validity.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#throw/1">throw(term)</a> </dt> <dd class="summary-synopsis"><p>A non-local return from a function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_charlist/1">to_charlist(term)</a> </dt> <dd class="summary-synopsis"><p>Converts the given term to a charlist according to the <a href="https://hexdocs.pm/elixir/List.Chars.html"><code class="inline">List.Chars</code></a> protocol.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_string/1">to_string(term)</a> </dt> <dd class="summary-synopsis"><p>Converts the argument to a string according to the <a href="https://hexdocs.pm/elixir/String.Chars.html"><code class="inline">String.Chars</code></a> protocol.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unless/2">unless(condition, clauses)</a> </dt> <dd class="summary-synopsis"><p>Provides an <code class="inline">unless</code> macro.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update_in/2">update_in(path, fun)</a> </dt> <dd class="summary-synopsis"><p>Updates a nested structure via the given <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update_in/3">update_in(data, keys, fun)</a> </dt> <dd class="summary-synopsis"><p>Updates a key in a nested structure.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#use/2">use(module, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Uses the given module in the current context.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#var!/2">var!(var, context \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Marks that the given variable should not be hygienized.</p></dd> </div> </dl> </section> <section id="guards" class="details-list"> <h1 class="section-heading">  Guards </h1> <div class="guards-list"> <section class="detail"> <h3 class="detail-header" id="!=/2">left != right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">term() != term() :: boolean()</pre> </div> <p>Not equal to operator.</p>
<p>Returns <code class="inline">true</code> if the two terms are not equal.</p>
<p>This operator considers 1 and 1.0 to be equal. For match comparison, use <a href="#!==/2"><code class="inline">!==/2</code></a> instead.</p>
<p>All terms in Elixir can be compared with each other.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="!=/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; 1 != 2
true

iex&gt; 1 != 1.0
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="!==/2">left !== right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">term() !== term() :: boolean()</pre> </div> <p>Strictly not equal to operator.</p>
<p>Returns <code class="inline">true</code> if the two terms are not exactly equal. See <a href="#===/2"><code class="inline">===/2</code></a> for a definition of what is considered "exactly equal".</p>
<p>All terms in Elixir can be compared with each other.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="!==/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; 1 !== 2
true

iex&gt; 1 !== 1.0
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="*/2">left * right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">integer() * integer() :: integer()</pre> <pre data-language="elixir">float() * float() :: float()</pre> <pre data-language="elixir">integer() * float() :: float()</pre> <pre data-language="elixir">float() * integer() :: float()</pre> </div> <p>Arithmetic multiplication operator.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="*/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; 1 * 2
2</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="+/1">+value</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">+integer() :: integer()</pre> <pre data-language="elixir">+float() :: float()</pre> </div> <p>Arithmetic positive unary operator.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="+/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; +1
1</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="+/2">left + right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">integer() + integer() :: integer()</pre> <pre data-language="elixir">float() + float() :: float()</pre> <pre data-language="elixir">integer() + float() :: float()</pre> <pre data-language="elixir">float() + integer() :: float()</pre> </div> <p>Arithmetic addition operator.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="+/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; 1 + 2
3</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="-/1">-value</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">-0 :: 0</pre> <pre data-language="elixir">-pos_integer() :: neg_integer()</pre> <pre data-language="elixir">-neg_integer() :: pos_integer()</pre> <pre data-language="elixir">-float() :: float()</pre> </div> <p>Arithmetic negative unary operator.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="-/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; -2
-2</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="-/2">left - right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">integer() - integer() :: integer()</pre> <pre data-language="elixir">float() - float() :: float()</pre> <pre data-language="elixir">integer() - float() :: float()</pre> <pre data-language="elixir">float() - integer() :: float()</pre> </div> <p>Arithmetic subtraction operator.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="-/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; 1 - 2
-1</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="//2">left / right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">number() / number() :: float()</pre> </div> <p>Arithmetic division operator.</p>
<p>The result is always a float. Use <a href="#div/2"><code class="inline">div/2</code></a> and <a href="#rem/2"><code class="inline">rem/2</code></a> if you want an integer division or the remainder.</p>
<p>Raises <a href="https://hexdocs.pm/elixir/ArithmeticError.html"><code class="inline">ArithmeticError</code></a> if <code class="inline">right</code> is 0 or 0.0.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="//2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">1 / 2
#=&gt; 0.5

-3.0 / 2.0
#=&gt; -1.5

5 / 1
#=&gt; 5.0

7 / 0
** (ArithmeticError) bad argument in arithmetic expression</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="%3C/2">left &lt; right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">term() &lt; term() :: boolean()</pre> </div> <p>Less-than operator.</p>
<p>Returns <code class="inline">true</code> if <code class="inline">left</code> is less than <code class="inline">right</code>.</p>
<p>All terms in Elixir can be compared with each other.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="%3C/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; 1 &lt; 2
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="%3C=/2">left &lt;= right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">term() &lt;= term() :: boolean()</pre> </div> <p>Less-than or equal to operator.</p>
<p>Returns <code class="inline">true</code> if <code class="inline">left</code> is less than or equal to <code class="inline">right</code>.</p>
<p>All terms in Elixir can be compared with each other.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="%3C=/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; 1 &lt;= 2
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="==/2">left == right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">term() == term() :: boolean()</pre> </div> <p>Equal to operator. Returns <code class="inline">true</code> if the two terms are equal.</p>
<p>This operator considers 1 and 1.0 to be equal. For stricter semantics, use <a href="#===/2"><code class="inline">===/2</code></a> instead.</p>
<p>All terms in Elixir can be compared with each other.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="==/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; 1 == 2
false

iex&gt; 1 == 1.0
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="===/2">left === right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">term() === term() :: boolean()</pre> </div> <p>Strictly equal to operator.</p>
<p>Returns <code class="inline">true</code> if the two terms are exactly equal.</p>
<p>The terms are only considered to be exactly equal if they have the same value and are of the same type. For example, <code class="inline">1 == 1.0</code> returns <code class="inline">true</code>, but since they are of different types, <code class="inline">1 === 1.0</code> returns <code class="inline">false</code>.</p>
<p>All terms in Elixir can be compared with each other.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="===/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; 1 === 2
false

iex&gt; 1 === 1.0
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="%3E/2">left &gt; right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">term() &gt; term() :: boolean()</pre> </div> <p>Greater-than operator.</p>
<p>Returns <code class="inline">true</code> if <code class="inline">left</code> is more than <code class="inline">right</code>.</p>
<p>All terms in Elixir can be compared with each other.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="%3E/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; 1 &gt; 2
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="%3E=/2">left &gt;= right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">term() &gt;= term() :: boolean()</pre> </div> <p>Greater-than or equal to operator.</p>
<p>Returns <code class="inline">true</code> if <code class="inline">left</code> is more than or equal to <code class="inline">right</code>.</p>
<p>All terms in Elixir can be compared with each other.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="%3E=/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; 1 &gt;= 2
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="abs/1">abs(number)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">abs(number()) :: number()</pre> </div> <p>Returns an integer or float which is the arithmetical absolute value of <code class="inline">number</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="abs/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; abs(-3.33)
3.33

iex&gt; abs(-3)
3</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="and/2">left and right</h3> <section class="docstring"> <p>Strictly boolean "and" operator.</p>
<p>If <code class="inline">left</code> is <code class="inline">false</code>, returns <code class="inline">false</code>; otherwise returns <code class="inline">right</code>.</p>
<p>Requires only the <code class="inline">left</code> operand to be a boolean since it short-circuits. If the <code class="inline">left</code> operand is not a boolean, an <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> exception is raised.</p>
<p>Allowed in guard tests.</p>
<h4 id="and/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; true and false
false

iex&gt; true and "yay!"
"yay!"

iex&gt; "yay!" and true
** (BadBooleanError) expected a boolean on left-side of "and", got: "yay!"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="binary_part/3">binary_part(binary, start, length)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">binary_part(binary(), non_neg_integer(), integer()) :: binary()</pre> </div> <p>Extracts the part of the binary starting at <code class="inline">start</code> with length <code class="inline">length</code>. Binaries are zero-indexed.</p>
<p>If <code class="inline">start</code> or <code class="inline">length</code> reference in any way outside the binary, an <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> exception is raised.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="binary_part/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; binary_part("foo", 1, 2)
"oo"</pre>
<p>A negative <code class="inline">length</code> can be used to extract bytes that come <em>before</em> the byte at <code class="inline">start</code>:</p>
<pre data-language="elixir">iex&gt; binary_part("Hello", 5, -3)
"llo"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="bit_size/1">bit_size(bitstring)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">bit_size(bitstring()) :: non_neg_integer()</pre> </div> <p>Returns an integer which is the size in bits of <code class="inline">bitstring</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="bit_size/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; bit_size(&lt;&lt;433::16, 3::3&gt;&gt;)
19

iex&gt; bit_size(&lt;&lt;1, 2, 3&gt;&gt;)
24</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="byte_size/1">byte_size(bitstring)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">byte_size(bitstring()) :: non_neg_integer()</pre> </div> <p>Returns the number of bytes needed to contain <code class="inline">bitstring</code>.</p>
<p>That is, if the number of bits in <code class="inline">bitstring</code> is not divisible by 8, the resulting number of bytes will be rounded up (by excess). This operation happens in constant time.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="byte_size/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; byte_size(&lt;&lt;433::16, 3::3&gt;&gt;)
3

iex&gt; byte_size(&lt;&lt;1, 2, 3&gt;&gt;)
3</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="ceil/1">ceil(number)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">ceil(number()) :: integer()</pre> </div> <p>Returns the smallest integer greater than or equal to <code class="inline">number</code>.</p>
<p>If you want to perform ceil operation on other decimal places, use <a href="https://hexdocs.pm/elixir/Float.html#ceil/2"><code class="inline">Float.ceil/2</code></a> instead.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="div/2">div(dividend, divisor)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">div(integer(), neg_integer() | pos_integer()) :: integer()</pre> </div> <p>Performs an integer division.</p>
<p>Raises an <a href="https://hexdocs.pm/elixir/ArithmeticError.html"><code class="inline">ArithmeticError</code></a> exception if one of the arguments is not an integer, or when the <code class="inline">divisor</code> is <code class="inline">0</code>.</p>
<p><a href="#div/2"><code class="inline">div/2</code></a> performs <em>truncated</em> integer division. This means that the result is always rounded towards zero.</p>
<p>If you want to perform floored integer division (rounding towards negative infinity), use <a href="https://hexdocs.pm/elixir/Integer.html#floor_div/2"><code class="inline">Integer.floor_div/2</code></a> instead.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="div/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">div(5, 2)
#=&gt; 2

div(6, -4)
#=&gt; -1

div(-99, 2)
#=&gt; -49

div(100, 0)
** (ArithmeticError) bad argument in arithmetic expression</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="elem/2">elem(tuple, index)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">elem(tuple(), non_neg_integer()) :: term()</pre> </div> <p>Gets the element at the zero-based <code class="inline">index</code> in <code class="inline">tuple</code>.</p>
<p>It raises <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> when index is negative or it is out of range of the tuple elements.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="elem/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">tuple = {:foo, :bar, 3}
elem(tuple, 1)
#=&gt; :bar

elem({}, 0)
** (ArgumentError) argument error

elem({:foo, :bar}, 2)
** (ArgumentError) argument error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="floor/1">floor(number)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">floor(number()) :: integer()</pre> </div> <p>Returns the largest integer smaller than or equal to <code class="inline">number</code>.</p>
<p>If you want to perform floor operation on other decimal places, use <a href="https://hexdocs.pm/elixir/Float.html#floor/2"><code class="inline">Float.floor/2</code></a> instead.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="hd/1">hd(list)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">hd(nonempty_maybe_improper_list(elem, any())) :: elem when elem: term()</pre> </div> <p>Returns the head of a list. Raises <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> if the list is empty.</p>
<p>It works with improper lists.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="hd/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">hd([1, 2, 3, 4])
#=&gt; 1

hd([])
** (ArgumentError) argument error

hd([1 | 2])
#=&gt; 1</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="in/2">left in right</h3> <section class="docstring"> <p>Membership operator. Checks if the element on the left-hand side is a member of the collection on the right-hand side.</p>
<h4 id="in/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; x = 1
iex&gt; x in [1, 2, 3]
true</pre>
<p>This operator (which is a macro) simply translates to a call to <a href="https://hexdocs.pm/elixir/Enum.html#member?/2"><code class="inline">Enum.member?/2</code></a>. The example above would translate to:</p>
<pre data-language="elixir">Enum.member?([1, 2, 3], x)</pre>
<p>Elixir also supports <code class="inline">left not in right</code>, which evaluates to <code class="inline">not(left in right)</code>:</p>
<pre data-language="elixir">iex&gt; x = 1
iex&gt; x not in [1, 2, 3]
false</pre>
<h4 id="in/2-guards" class="section-heading">  Guards </h4> <p>The <a href="#in/2"><code class="inline">in/2</code></a> operator (as well as <code class="inline">not in</code>) can be used in guard clauses as long as the right-hand side is a range or a list. In such cases, Elixir will expand the operator to a valid guard expression. For example:</p>
<pre data-language="elixir">when x in [1, 2, 3]</pre>
<p>translates to:</p>
<pre data-language="elixir">when x === 1 or x === 2 or x === 3</pre>
<p>When using ranges:</p>
<pre data-language="elixir">when x in 1..3</pre>
<p>translates to:</p>
<pre data-language="elixir">when is_integer(x) and x &gt;= 1 and x &lt;= 3</pre>
<p>Note that only integers can be considered inside a range by <code class="inline">in</code>.</p>
<h3 id="in/2-ast-considerations" class="section-heading">  AST considerations </h3> <p><code class="inline">left not in right</code> is parsed by the compiler into the AST:</p>
<pre data-language="elixir">{:not, _, [{:in, _, [left, right]}]}</pre>
<p>This is the same AST as <code class="inline">not(left in right)</code>.</p>
<p>Additionally, <a href="https://hexdocs.pm/elixir/Macro.html#to_string/2"><code class="inline">Macro.to_string/2</code></a> will translate all occurrences of this AST to <code class="inline">left not in right</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_atom/1">is_atom(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_atom(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is an atom; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_binary/1">is_binary(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_binary(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a binary; otherwise returns <code class="inline">false</code>.</p>
<p>A binary always contains a complete number of bytes.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="is_binary/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; is_binary("foo")
true
iex&gt; is_binary(&lt;&lt;1::3&gt;&gt;)
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_bitstring/1">is_bitstring(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_bitstring(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a bitstring (including a binary); otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="is_bitstring/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; is_bitstring("foo")
true
iex&gt; is_bitstring(&lt;&lt;1::3&gt;&gt;)
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_boolean/1">is_boolean(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_boolean(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is either the atom <code class="inline">true</code> or the atom <code class="inline">false</code> (i.e., a boolean); otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_exception/1">is_exception(term)</h3> <section class="docstring"> <p>Returns true if <code class="inline">term</code> is an exception; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests.</p>
<h4 id="is_exception/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; is_exception(%RuntimeError{})
true

iex&gt; is_exception(%{})
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_exception/2">is_exception(term, name)</h3> <section class="docstring"> <p>Returns true if <code class="inline">term</code> is an exception of <code class="inline">name</code>; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests.</p>
<h4 id="is_exception/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; is_exception(%RuntimeError{}, RuntimeError)
true

iex&gt; is_exception(%RuntimeError{}, Macro.Env)
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_float/1">is_float(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_float(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a floating-point number; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_function/1">is_function(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_function(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a function; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_function/2">is_function(term, arity)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_function(term(), non_neg_integer()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a function that can be applied with <code class="inline">arity</code> number of arguments; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="is_function/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; is_function(fn x -&gt; x * 2 end, 1)
true
iex&gt; is_function(fn x -&gt; x * 2 end, 2)
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_integer/1">is_integer(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_integer(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is an integer; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_list/1">is_list(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_list(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a list with zero or more elements; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_map/1">is_map(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_map(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a map; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_map_key/2">is_map_key(map, key)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_map_key(map(), term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">key</code> is a key in <code class="inline">map</code>; otherwise returns <code class="inline">false</code>.</p>
<p>It raises <a href="https://hexdocs.pm/elixir/BadMapError.html"><code class="inline">BadMapError</code></a> if the first element is not a map.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_nil/1">is_nil(term)</h3> <section class="docstring"> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is <code class="inline">nil</code>, <code class="inline">false</code> otherwise.</p>
<p>Allowed in guard clauses.</p>
<h4 id="is_nil/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; is_nil(1)
false

iex&gt; is_nil(nil)
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_number/1">is_number(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_number(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is either an integer or a floating-point number; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_pid/1">is_pid(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_pid(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a PID (process identifier); otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_port/1">is_port(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_port(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a port identifier; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_reference/1">is_reference(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_reference(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a reference; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_struct/1">is_struct(term)</h3> <section class="docstring"> <p>Returns true if <code class="inline">term</code> is a struct; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests.</p>
<h4 id="is_struct/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; is_struct(URI.parse("/"))
true

iex&gt; is_struct(%{})
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_struct/2">is_struct(term, name)</h3> <section class="docstring"> <p>Returns true if <code class="inline">term</code> is a struct of <code class="inline">name</code>; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests.</p>
<h4 id="is_struct/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; is_struct(URI.parse("/"), URI)
true

iex&gt; is_struct(URI.parse("/"), Macro.Env)
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="is_tuple/1">is_tuple(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">is_tuple(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a tuple; otherwise returns <code class="inline">false</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="length/1">length(list)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">length(list()) :: non_neg_integer()</pre> </div> <p>Returns the length of <code class="inline">list</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="length/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; length([1, 2, 3, 4, 5, 6, 7, 8, 9])
9</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="map_size/1">map_size(map)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">map_size(map()) :: non_neg_integer()</pre> </div> <p>Returns the size of a map.</p>
<p>The size of a map is the number of key-value pairs that the map contains.</p>
<p>This operation happens in constant time.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="map_size/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; map_size(%{a: "foo", b: "bar"})
2</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="node/0">node()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">node() :: node()</pre> </div> <p>Returns an atom representing the name of the local node. If the node is not alive, <code class="inline">:nonode@nohost</code> is returned instead.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="node/1">node(arg)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">node(pid() | reference() | port()) :: node()</pre> </div> <p>Returns the node where the given argument is located. The argument can be a PID, a reference, or a port. If the local node is not alive, <code class="inline">:nonode@nohost</code> is returned.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="not/1">not(value)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">not true :: false</pre> <pre data-language="elixir">not false :: true</pre> </div> <p>Strictly boolean "not" operator.</p>
<p><code class="inline">value</code> must be a boolean; if it's not, an <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> exception is raised.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="not/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; not false
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="or/2">left or right</h3> <section class="docstring"> <p>Strictly boolean "or" operator.</p>
<p>If <code class="inline">left</code> is <code class="inline">true</code>, returns <code class="inline">true</code>; otherwise returns <code class="inline">right</code>.</p>
<p>Requires only the <code class="inline">left</code> operand to be a boolean since it short-circuits. If the <code class="inline">left</code> operand is not a boolean, an <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> exception is raised.</p>
<p>Allowed in guard tests.</p>
<h4 id="or/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; true or false
true

iex&gt; false or 42
42

iex&gt; 42 or false
** (BadBooleanError) expected a boolean on left-side of "or", got: 42</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="rem/2">rem(dividend, divisor)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">rem(integer(), neg_integer() | pos_integer()) :: integer()</pre> </div> <p>Computes the remainder of an integer division.</p>
<p><a href="#rem/2"><code class="inline">rem/2</code></a> uses truncated division, which means that the result will always have the sign of the <code class="inline">dividend</code>.</p>
<p>Raises an <a href="https://hexdocs.pm/elixir/ArithmeticError.html"><code class="inline">ArithmeticError</code></a> exception if one of the arguments is not an integer, or when the <code class="inline">divisor</code> is <code class="inline">0</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="rem/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; rem(5, 2)
1
iex&gt; rem(6, -4)
2</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="round/1">round(number)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">round(number()) :: integer()</pre> </div> <p>Rounds a number to the nearest integer.</p>
<p>If the number is equidistant to the two nearest integers, rounds away from zero.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="round/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; round(5.6)
6

iex&gt; round(5.2)
5

iex&gt; round(-9.9)
-10

iex&gt; round(-9)
-9

iex&gt; round(2.5)
3

iex&gt; round(-2.5)
-3</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="self/0">self()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">self() :: pid()</pre> </div> <p>Returns the PID (process identifier) of the calling process.</p>
<p>Allowed in guard clauses. Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="tl/1">tl(list)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">tl(nonempty_maybe_improper_list(elem, tail)) ::
  maybe_improper_list(elem, tail) | tail
when elem: term(), tail: term()</pre> </div> <p>Returns the tail of a list. Raises <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> if the list is empty.</p>
<p>It works with improper lists.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="tl/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">tl([1, 2, 3, :go])
#=&gt; [2, 3, :go]

tl([])
** (ArgumentError) argument error

tl([:one])
#=&gt; []

tl([:a, :b | :c])
#=&gt; [:b | :c]

tl([:a | %{b: 1}])
#=&gt; %{b: 1}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="trunc/1">trunc(number)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">trunc(number()) :: integer()</pre> </div> <p>Returns the integer part of <code class="inline">number</code>.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="trunc/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; trunc(5.4)
5

iex&gt; trunc(-5.99)
-5

iex&gt; trunc(-5)
-5</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="tuple_size/1">tuple_size(tuple)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">tuple_size(tuple()) :: non_neg_integer()</pre> </div> <p>Returns the size of a tuple.</p>
<p>This operation happens in constant time.</p>
<p>Allowed in guard tests. Inlined by the compiler.</p>
<h4 id="tuple_size/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; tuple_size({:a, :b, :c})
3</pre> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="!/1">!value</h3> <section class="docstring"> <p>Boolean "not" operator.</p>
<p>Receives any value (not just booleans) and returns <code class="inline">true</code> if <code class="inline">value</code> is <code class="inline">false</code> or <code class="inline">nil</code>; returns <code class="inline">false</code> otherwise.</p>
<p>Not allowed in guard clauses.</p>
<h4 id="!/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; !Enum.empty?([])
false

iex&gt; !List.first([])
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="&amp;&amp;/2">left &amp;&amp; right</h3> <section class="docstring"> <p>Boolean "and" operator.</p>
<p>Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to a truthy value (neither <code class="inline">false</code> nor <code class="inline">nil</code>). Returns the first expression otherwise.</p>
<p>Not allowed in guard clauses.</p>
<h4 id="&amp;&amp;/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.empty?([]) &amp;&amp; Enum.empty?([])
true

iex&gt; List.first([]) &amp;&amp; true
nil

iex&gt; Enum.empty?([]) &amp;&amp; List.first([1])
1

iex&gt; false &amp;&amp; throw(:bad)
false</pre>
<p>Note that, unlike <a href="#and/2"><code class="inline">and/2</code></a>, this operator accepts any expression as the first argument, not only booleans.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="++/2">left ++ right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">list() ++ term() :: maybe_improper_list()</pre> </div> <p>List concatenation operator. Concatenates a proper list and a term, returning a list.</p>
<p>The complexity of <code class="inline">a ++ b</code> is proportional to <code class="inline">length(a)</code>, so avoid repeatedly appending to lists of arbitrary length, for example, <code class="inline">list ++ [element]</code>. Instead, consider prepending via <code class="inline">[element | rest]</code> and then reversing.</p>
<p>If the <code class="inline">right</code> operand is not a proper list, it returns an improper list. If the <code class="inline">left</code> operand is not a proper list, it raises <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a>.</p>
<p>Inlined by the compiler.</p>
<h4 id="++/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; [1] ++ [2, 3]
[1, 2, 3]

iex&gt; 'foo' ++ 'bar'
'foobar'

# returns an improper list
iex&gt; [1] ++ 2
[1 | 2]

# returns a proper list
iex&gt; [1] ++ [2]
[1, 2]

# improper list on the right will return an improper list
iex&gt; [1] ++ [2 | 3]
[1, 2 | 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="--/2">left -- right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">list() -- list() :: list()</pre> </div> <p>List subtraction operator. Removes the first occurrence of an element on the left list for each element on the right.</p>
<p>Before Erlang/OTP 22, the complexity of <code class="inline">a -- b</code> was proportional to <code class="inline">length(a) * length(b)</code>, meaning that it would be very slow if both <code class="inline">a</code> and <code class="inline">b</code> were long lists. In such cases, consider converting each list to a <a href="https://hexdocs.pm/elixir/MapSet.html"><code class="inline">MapSet</code></a> and using <a href="https://hexdocs.pm/elixir/MapSet.html#difference/2"><code class="inline">MapSet.difference/2</code></a>.</p>
<p>As of Erlang/OTP 22, this operation is significantly faster even if both lists are very long, and using <a href="#--/2"><code class="inline">--/2</code></a> is usually faster and uses less memory than using the <a href="https://hexdocs.pm/elixir/MapSet.html"><code class="inline">MapSet</code></a>-based alternative mentioned above. See also the <a href="https://erlang.org/doc/efficiency_guide/retired_myths.html">Erlang efficiency guide</a>.</p>
<p>Inlined by the compiler.</p>
<h4 id="--/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; [1, 2, 3] -- [1, 2]
[3]

iex&gt; [1, 2, 3, 2, 1] -- [1, 2, 2]
[3, 1]</pre>
<p>The <a href="#--/2"><code class="inline">--/2</code></a> operator is right associative, meaning:</p>
<pre data-language="elixir">iex&gt; [1, 2, 3] -- [2] -- [3]
[1, 3]</pre>
<p>As it is equivalent to:</p>
<pre data-language="elixir">iex&gt; [1, 2, 3] -- ([2] -- [3])
[1, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="../2">first..last</h3> <section class="docstring"> <p>Range creation operator. Returns a range with the specified <code class="inline">first</code> and <code class="inline">last</code> integers.</p>
<p>If last is larger than first, the range will be increasing from first to last. If first is larger than last, the range will be decreasing from first to last. If first is equal to last, the range will contain one element, which is the number itself.</p>
<h4 id="../2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; 0 in 1..3
false

iex&gt; 1 in 1..3
true

iex&gt; 2 in 1..3
true

iex&gt; 3 in 1..3
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="%3C%3E/2">left &lt;&gt; right</h3> <section class="docstring"> <p>Binary concatenation operator. Concatenates two binaries.</p>
<h4 id="%3C%3E/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; "foo" &lt;&gt; "bar"
"foobar"</pre>
<p>The <a href="#%3C%3E/2"><code class="inline">&lt;&gt;/2</code></a> operator can also be used in pattern matching (and guard clauses) as long as the left argument is a literal binary:</p>
<pre data-language="elixir">iex&gt; "foo" &lt;&gt; x = "foobar"
iex&gt; x
"bar"</pre>
<p><code class="inline">x &lt;&gt; "bar" = "foobar"</code> would have resulted in a <a href="https://hexdocs.pm/elixir/CompileError.html"><code class="inline">CompileError</code></a> exception.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="=~/2">left =~ right</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">String.t() =~ (String.t() | Regex.t()) :: boolean()</pre> </div> <p>Text-based match operator. Matches the term on the <code class="inline">left</code> against the regular expression or string on the <code class="inline">right</code>.</p>
<p>If <code class="inline">right</code> is a regular expression, returns <code class="inline">true</code> if <code class="inline">left</code> matches right.</p>
<p>If <code class="inline">right</code> is a string, returns <code class="inline">true</code> if <code class="inline">left</code> contains <code class="inline">right</code>.</p>
<h4 id="=~/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; "abcd" =~ ~r/c(d)/
true

iex&gt; "abcd" =~ ~r/e/
false

iex&gt; "abcd" =~ ~r//
true

iex&gt; "abcd" =~ "bc"
true

iex&gt; "abcd" =~ "ad"
false

iex&gt; "abcd" =~ "abcd"
true

iex&gt; "abcd" =~ ""
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="@/1">@expr</h3> <section class="docstring"> <p>Module attribute unary operator. Reads and writes attributes in the current module.</p>
<p>The canonical example for attributes is annotating that a module implements an OTP behaviour, such as <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a>:</p>
<pre data-language="elixir">defmodule MyServer do
  @behaviour GenServer
  # ... callbacks ...
end</pre>
<p>By default Elixir supports all the module attributes supported by Erlang, but custom attributes can be used as well:</p>
<pre data-language="elixir">defmodule MyServer do
  @my_data 13
  IO.inspect(@my_data)
  #=&gt; 13
end</pre>
<p>Unlike Erlang, such attributes are not stored in the module by default since it is common in Elixir to use custom attributes to store temporary data that will be available at compile-time. Custom attributes may be configured to behave closer to Erlang by using <a href="https://hexdocs.pm/elixir/Module.html#register_attribute/3"><code class="inline">Module.register_attribute/3</code></a>.</p>
<p>Finally, note that attributes can also be read inside functions:</p>
<pre data-language="elixir">defmodule MyServer do
  @my_data 11
  def first_data, do: @my_data
  @my_data 13
  def second_data, do: @my_data
end

MyServer.first_data()
#=&gt; 11

MyServer.second_data()
#=&gt; 13</pre>
<p>It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the <a href="https://hexdocs.pm/elixir/Module.html"><code class="inline">Module</code></a> module for other functions to manipulate module attributes.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="%7C%3E/2">left |&gt; right</h3> <section class="docstring"> <p>Pipe operator.</p>
<p>This operator introduces the expression on the left-hand side as the first argument to the function call on the right-hand side.</p>
<h4 id="%7C%3E/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; [1, [2], 3] |&gt; List.flatten()
[1, 2, 3]</pre>
<p>The example above is the same as calling <code class="inline">List.flatten([1, [2], 3])</code>.</p>
<p>The <code class="inline">|&gt;</code> operator is mostly useful when there is a desire to execute a series of operations resembling a pipeline:</p>
<pre data-language="elixir">iex&gt; [1, [2], 3] |&gt; List.flatten() |&gt; Enum.map(fn x -&gt; x * 2 end)
[2, 4, 6]</pre>
<p>In the example above, the list <code class="inline">[1, [2], 3]</code> is passed as the first argument to the <a href="https://hexdocs.pm/elixir/List.html#flatten/1"><code class="inline">List.flatten/1</code></a> function, then the flattened list is passed as the first argument to the <a href="https://hexdocs.pm/elixir/Enum.html#map/2"><code class="inline">Enum.map/2</code></a> function which doubles each element of the list.</p>
<p>In other words, the expression above simply translates to:</p>
<pre data-language="elixir">Enum.map(List.flatten([1, [2], 3]), fn x -&gt; x * 2 end)</pre>
<h4 id="%7C%3E/2-pitfalls" class="section-heading">  Pitfalls </h4> <p>There are two common pitfalls when using the pipe operator.</p>
<p>The first one is related to operator precedence. For example, the following expression:</p>
<pre data-language="elixir">String.graphemes "Hello" |&gt; Enum.reverse</pre>
<p>Translates to:</p>
<pre data-language="elixir">String.graphemes("Hello" |&gt; Enum.reverse())</pre>
<p>which results in an error as the <a href="https://hexdocs.pm/elixir/Enumerable.html"><code class="inline">Enumerable</code></a> protocol is not defined for binaries. Adding explicit parentheses resolves the ambiguity:</p>
<pre data-language="elixir">String.graphemes("Hello") |&gt; Enum.reverse()</pre>
<p>Or, even better:</p>
<pre data-language="elixir">"Hello" |&gt; String.graphemes() |&gt; Enum.reverse()</pre>
<p>The second pitfall is that the <code class="inline">|&gt;</code> operator works on calls. For example, when you write:</p>
<pre data-language="elixir">"Hello" |&gt; some_function()</pre>
<p>Elixir sees the right-hand side is a function call and pipes to it. This means that, if you want to pipe to an anonymous or captured function, it must also be explicitly called.</p>
<p>Given the anonymous function:</p>
<pre data-language="elixir">fun = fn x -&gt; IO.puts(x) end
fun.("Hello")</pre>
<p>This won't work as it will rather try to invoke the local function <code class="inline">fun</code>:</p>
<pre data-language="elixir">"Hello" |&gt; fun()</pre>
<p>This works:</p>
<pre data-language="elixir">"Hello" |&gt; fun.()</pre>
<p>As you can see, the <code class="inline">|&gt;</code> operator retains the same semantics as when the pipe is not used since both require the <code class="inline">fun.(...)</code> notation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="%7C%7C/2">left || right</h3> <section class="docstring"> <p>Boolean "or" operator.</p>
<p>Provides a short-circuit operator that evaluates and returns the second expression only if the first one does not evaluate to a truthy value (that is, it is either <code class="inline">nil</code> or <code class="inline">false</code>). Returns the first expression otherwise.</p>
<p>Not allowed in guard clauses.</p>
<h4 id="%7C%7C/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Enum.empty?([1]) || Enum.empty?([1])
false

iex&gt; List.first([]) || true
true

iex&gt; Enum.empty?([1]) || 1
1

iex&gt; Enum.empty?([]) || throw(:bad)
true</pre>
<p>Note that, unlike <a href="#or/2"><code class="inline">or/2</code></a>, this operator accepts any expression as the first argument, not only booleans.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="alias!/1">alias!(alias)</h3> <section class="docstring"> <p>When used inside quoting, marks that the given alias should not be hygienized. This means the alias will be expanded when the macro is expanded.</p>
<p>Check <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2"><code class="inline">Kernel.SpecialForms.quote/2</code></a> for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="apply/2">apply(fun, args)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">apply((... -&gt; any()), [any()]) :: any()</pre> </div> <p>Invokes the given anonymous function <code class="inline">fun</code> with the list of arguments <code class="inline">args</code>.</p>
<p>Inlined by the compiler.</p>
<h4 id="apply/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; apply(fn x -&gt; x * 2 end, [2])
4</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="apply/3">apply(module, function_name, args)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">apply(module(), function_name :: atom(), [any()]) :: any()</pre> </div> <p>Invokes the given function from <code class="inline">module</code> with the list of arguments <code class="inline">args</code>.</p>
<p><a href="#apply/3"><code class="inline">apply/3</code></a> is used to invoke functions where the module, function name or arguments are defined dynamically at runtime. For this reason, you can't invoke macros using <a href="#apply/3"><code class="inline">apply/3</code></a>, only functions.</p>
<p>Inlined by the compiler.</p>
<h4 id="apply/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; apply(Enum, :reverse, [[1, 2, 3]])
[3, 2, 1]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="binding/1">binding(context \\ nil)</h3> <section class="docstring"> <p>Returns the binding for the given context as a keyword list.</p>
<p>In the returned result, keys are variable names and values are the corresponding variable values.</p>
<p>If the given <code class="inline">context</code> is <code class="inline">nil</code> (by default it is), the binding for the current context is returned.</p>
<h4 id="binding/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; x = 1
iex&gt; binding()
[x: 1]
iex&gt; x = 2
iex&gt; binding()
[x: 2]

iex&gt; binding(:foo)
[]
iex&gt; var!(x, :foo) = 1
1
iex&gt; binding(:foo)
[x: 1]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="def/2">def(call, expr \\ nil)</h3> <section class="docstring"> <p>Defines a public function with the given name and body.</p>
<h4 id="def/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule Foo do
  def bar, do: :baz
end

Foo.bar()
#=&gt; :baz</pre>
<p>A function that expects arguments can be defined as follows:</p>
<pre data-language="elixir">defmodule Foo do
  def sum(a, b) do
    a + b
  end
end</pre>
<p>In the example above, a <code class="inline">sum/2</code> function is defined; this function receives two arguments and returns their sum.</p>
<h4 id="def/2-default-arguments" class="section-heading">  Default arguments </h4> <p><code class="inline">\\</code> is used to specify a default value for a parameter of a function. For example:</p>
<pre data-language="elixir">defmodule MyMath do
  def multiply_by(number, factor \\ 2) do
    number * factor
  end
end

MyMath.multiply_by(4, 3)
#=&gt; 12

MyMath.multiply_by(4)
#=&gt; 8</pre>
<p>The compiler translates this into multiple functions with different arities, here <code class="inline">MyMath.multiply_by/1</code> and <code class="inline">MyMath.multiply_by/2</code>, that represent cases when arguments for parameters with default values are passed or not passed.</p>
<p>When defining a function with default arguments as well as multiple explicitly declared clauses, you must write a function head that declares the defaults. For example:</p>
<pre data-language="elixir">defmodule MyString do
  def join(string1, string2 \\ nil, separator \\ " ")

  def join(string1, nil, _separator) do
    string1
  end

  def join(string1, string2, separator) do
    string1 &lt;&gt; separator &lt;&gt; string2
  end
end</pre>
<p>Note that <code class="inline">\\</code> can't be used with anonymous functions because they can only have a sole arity.</p>
<h4 id="def/2-function-and-variable-names" class="section-heading">  Function and variable names </h4> <p>Function and variable names have the following syntax: A <em>lowercase ASCII letter</em> or an <em>underscore</em>, followed by any number of <em>lowercase or uppercase ASCII letters</em>, <em>numbers</em>, or <em>underscores</em>. Optionally they can end in either an <em>exclamation mark</em> or a <em>question mark</em>.</p>
<p>For variables, any identifier starting with an underscore should indicate an unused variable. For example:</p>
<pre data-language="elixir">def foo(bar) do
  []
end
#=&gt; warning: variable bar is unused

def foo(_bar) do
  []
end
#=&gt; no warning

def foo(_bar) do
  _bar
end
#=&gt; warning: the underscored variable "_bar" is used after being set</pre>
<h4 id="def/2-rescue-catch-after-else" class="section-heading">  <code class="inline">rescue</code>/<code class="inline">catch</code>/<code class="inline">after</code>/<code class="inline">else</code> </h4> <p>Function bodies support <code class="inline">rescue</code>, <code class="inline">catch</code>, <code class="inline">after</code>, and <code class="inline">else</code> as <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#try/1"><code class="inline">Kernel.SpecialForms.try/1</code></a> does (known as "implicit try"). For example, the following two functions are equivalent:</p>
<pre data-language="elixir">def convert(number) do
  try do
    String.to_integer(number)
  rescue
    e in ArgumentError -&gt; {:error, e.message}
  end
end

def convert(number) do
  String.to_integer(number)
rescue
  e in ArgumentError -&gt; {:error, e.message}
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="defdelegate/2">defdelegate(funs, opts)</h3> <section class="docstring"> <p>Defines a function that delegates to another module.</p>
<p>Functions defined with <a href="#defdelegate/2"><code class="inline">defdelegate/2</code></a> are public and can be invoked from outside the module they're defined in, as if they were defined using <a href="#def/2"><code class="inline">def/2</code></a>. Therefore, <a href="#defdelegate/2"><code class="inline">defdelegate/2</code></a> is about extending the current module's public API. If what you want is to invoke a function defined in another module without using its full module name, then use <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2"><code class="inline">alias/2</code></a> to shorten the module name or use <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2"><code class="inline">import/2</code></a> to be able to invoke the function without the module name altogether.</p>
<p>Delegation only works with functions; delegating macros is not supported.</p>
<p>Check <a href="#def/2"><code class="inline">def/2</code></a> for rules on naming and default arguments.</p>
<h4 id="defdelegate/2-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:to</code> - the module to dispatch to.</p></li>
<li><p><code class="inline">:as</code> - the function to call on the target given in <code class="inline">:to</code>. This parameter is optional and defaults to the name being delegated (<code class="inline">funs</code>).</p></li>
</ul>
<h4 id="defdelegate/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule MyList do
  defdelegate reverse(list), to: Enum
  defdelegate other_reverse(list), to: Enum, as: :reverse
end

MyList.reverse([1, 2, 3])
#=&gt; [3, 2, 1]

MyList.other_reverse([1, 2, 3])
#=&gt; [3, 2, 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="defexception/1">defexception(fields)</h3> <section class="docstring"> <p>Defines an exception.</p>
<p>Exceptions are structs backed by a module that implements the <a href="https://hexdocs.pm/elixir/Exception.html"><code class="inline">Exception</code></a> behaviour. The <a href="https://hexdocs.pm/elixir/Exception.html"><code class="inline">Exception</code></a> behaviour requires two functions to be implemented:</p>
<ul>
<li><p><a href="https://hexdocs.pm/elixir/Exception.html#c:exception/1"><code class="inline">exception/1</code></a> - receives the arguments given to <a href="#raise/2"><code class="inline">raise/2</code></a> and returns the exception struct. The default implementation accepts either a set of keyword arguments that is merged into the struct or a string to be used as the exception's message.</p></li>
<li><p><a href="https://hexdocs.pm/elixir/Exception.html#c:message/1"><code class="inline">message/1</code></a> - receives the exception struct and must return its message. Most commonly exceptions have a message field which by default is accessed by this function. However, if an exception does not have a message field, this function must be explicitly implemented.</p></li>
</ul>
<p>Since exceptions are structs, the API supported by <a href="#defstruct/1"><code class="inline">defstruct/1</code></a> is also available in <a href="#defexception/1"><code class="inline">defexception/1</code></a>.</p>
<h4 id="defexception/1-raising-exceptions" class="section-heading">  Raising exceptions </h4> <p>The most common way to raise an exception is via <a href="#raise/2"><code class="inline">raise/2</code></a>:</p>
<pre data-language="elixir">defmodule MyAppError do
  defexception [:message]
end

value = [:hello]

raise MyAppError,
  message: "did not get what was expected, got: #{inspect(value)}"</pre>
<p>In many cases it is more convenient to pass the expected value to <a href="#raise/2"><code class="inline">raise/2</code></a> and generate the message in the <a href="https://hexdocs.pm/elixir/Exception.html#c:exception/1"><code class="inline">Exception.exception/1</code></a> callback:</p>
<pre data-language="elixir">defmodule MyAppError do
  defexception [:message]

  @impl true
  def exception(value) do
    msg = "did not get what was expected, got: #{inspect(value)}"
    %MyAppError{message: msg}
  end
end

raise MyAppError, value</pre>
<p>The example above shows the preferred strategy for customizing exception messages.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="defguard/1">defguard(guard)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">defguard(Macro.t()) :: Macro.t()</pre> </div> <p>Generates a macro suitable for use in guard expressions.</p>
<p>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a macro that can be used both inside or outside guards.</p>
<p>Note the convention in Elixir is to name functions/macros allowed in guards with the <code class="inline">is_</code> prefix, such as <a href="#is_list/1"><code class="inline">is_list/1</code></a>. If, however, the function/macro returns a boolean and is not allowed in guards, it should have no prefix and end with a question mark, such as <a href="https://hexdocs.pm/elixir/Keyword.html#keyword?/1"><code class="inline">Keyword.keyword?/1</code></a>.</p>
<h4 id="defguard/1-example" class="section-heading">  Example </h4> <pre data-language="elixir">defmodule Integer.Guards do
  defguard is_even(value) when is_integer(value) and rem(value, 2) == 0
end

defmodule Collatz do
  @moduledoc "Tools for working with the Collatz sequence."
  import Integer.Guards

  @doc "Determines the number of steps `n` takes to reach `1`."
  # If this function never converges, please let me know what `n` you used.
  def converge(n) when n &gt; 0, do: step(n, 0)

  defp step(1, step_count) do
    step_count
  end

  defp step(n, step_count) when is_even(n) do
    step(div(n, 2), step_count + 1)
  end

  defp step(n, step_count) do
    step(3 * n + 1, step_count + 1)
  end
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="defguardp/1">defguardp(guard)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">defguardp(Macro.t()) :: Macro.t()</pre> </div> <p>Generates a private macro suitable for use in guard expressions.</p>
<p>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a private macro that can be used both inside or outside guards in the current module.</p>
<p>Similar to <a href="#defmacrop/2"><code class="inline">defmacrop/2</code></a>, <a href="#defguardp/1"><code class="inline">defguardp/1</code></a> must be defined before its use in the current module.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="defimpl/3">defimpl(name, opts, do_block \\ [])</h3> <section class="docstring"> <p>Defines an implementation for the given protocol.</p>
<p>See the <a href="https://hexdocs.pm/elixir/Protocol.html"><code class="inline">Protocol</code></a> module for more information.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="defmacro/2">defmacro(call, expr \\ nil)</h3> <section class="docstring"> <p>Defines a public macro with the given name and body.</p>
<p>Macros must be defined before its usage.</p>
<p>Check <a href="#def/2"><code class="inline">def/2</code></a> for rules on naming and default arguments.</p>
<h4 id="defmacro/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule MyLogic do
  defmacro unless(expr, opts) do
    quote do
      if !unquote(expr), unquote(opts)
    end
  end
end

require MyLogic

MyLogic.unless false do
  IO.puts("It works")
end</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="defmacrop/2">defmacrop(call, expr \\ nil)</h3> <section class="docstring"> <p>Defines a private macro with the given name and body.</p>
<p>Private macros are only accessible from the same module in which they are defined.</p>
<p>Private macros must be defined before its usage.</p>
<p>Check <a href="#defmacro/2"><code class="inline">defmacro/2</code></a> for more information, and check <a href="#def/2"><code class="inline">def/2</code></a> for rules on naming and default arguments.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="defmodule/2">defmodule(alias, do_block)</h3> <section class="docstring"> <p>Defines a module given by name with the given contents.</p>
<p>This macro defines a module with the given <code class="inline">alias</code> as its name and with the given contents. It returns a tuple with four elements:</p>
<ul>
<li><code class="inline">:module</code></li>
<li>the module name</li>
<li>the binary contents of the module</li>
<li>the result of evaluating the contents block</li>
</ul>
<h4 id="defmodule/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule Number do
  def one, do: 1
  def two, do: 2
end
#=&gt; {:module, Number, &lt;&lt;70, 79, 82, ...&gt;&gt;, {:two, 0}}

Number.one()
#=&gt; 1

Number.two()
#=&gt; 2</pre>
<h4 id="defmodule/2-nesting" class="section-heading">  Nesting </h4> <p>Nesting a module inside another module affects the name of the nested module:</p>
<pre data-language="elixir">defmodule Foo do
  defmodule Bar do
  end
end</pre>
<p>In the example above, two modules - <code class="inline">Foo</code> and <code class="inline">Foo.Bar</code> - are created. When nesting, Elixir automatically creates an alias to the inner module, allowing the second module <code class="inline">Foo.Bar</code> to be accessed as <code class="inline">Bar</code> in the same lexical scope where it's defined (the <code class="inline">Foo</code> module). This only happens if the nested module is defined via an alias.</p>
<p>If the <code class="inline">Foo.Bar</code> module is moved somewhere else, the references to <code class="inline">Bar</code> in the <code class="inline">Foo</code> module need to be updated to the fully-qualified name (<code class="inline">Foo.Bar</code>) or an alias has to be explicitly set in the <code class="inline">Foo</code> module with the help of <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2"><code class="inline">Kernel.SpecialForms.alias/2</code></a>.</p>
<pre data-language="elixir">defmodule Foo.Bar do
  # code
end

defmodule Foo do
  alias Foo.Bar
  # code here can refer to "Foo.Bar" as just "Bar"
end</pre>
<h4 id="defmodule/2-dynamic-names" class="section-heading">  Dynamic names </h4> <p>Elixir module names can be dynamically generated. This is very useful when working with macros. For instance, one could write:</p>
<pre data-language="elixir">defmodule String.to_atom("Foo#{1}") do
  # contents ...
end</pre>
<p>Elixir will accept any module name as long as the expression passed as the first argument to <a href="#defmodule/2"><code class="inline">defmodule/2</code></a> evaluates to an atom. Note that, when a dynamic name is used, Elixir won't nest the name under the current module nor automatically set up an alias.</p>
<h4 id="defmodule/2-reserved-module-names" class="section-heading">  Reserved module names </h4> <p>If you attempt to define a module that already exists, you will get a warning saying that a module has been redefined.</p>
<p>There are some modules that Elixir does not currently implement but it may be implement in the future. Those modules are reserved and defining them will result in a compilation error:</p>
<pre data-language="elixir">defmodule Any do
  # code
end
** (CompileError) iex:1: module Any is reserved and cannot be defined</pre>
<p>Elixir reserves the following module names: <code class="inline">Elixir</code>, <code class="inline">Any</code>, <code class="inline">BitString</code>, <code class="inline">PID</code>, and <code class="inline">Reference</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="defoverridable/1">defoverridable(keywords_or_behaviour)</h3> <section class="docstring"> <p>Makes the given functions in the current module overridable.</p>
<p>An overridable function is lazily defined, allowing a developer to override it.</p>
<p>Macros cannot be overridden as functions and vice-versa.</p>
<h4 id="defoverridable/1-example" class="section-heading">  Example </h4> <pre data-language="elixir">defmodule DefaultMod do
  defmacro __using__(_opts) do
    quote do
      def test(x, y) do
        x + y
      end

      defoverridable test: 2
    end
  end
end

defmodule InheritMod do
  use DefaultMod

  def test(x, y) do
    x * y + super(x, y)
  end
end</pre>
<p>As seen as in the example above, <code class="inline">super</code> can be used to call the default implementation.</p>
<p>If <code class="inline">@behaviour</code> has been defined, <code class="inline">defoverridable</code> can also be called with a module as an argument. All implemented callbacks from the behaviour above the call to <code class="inline">defoverridable</code> will be marked as overridable.</p>
<h4 id="defoverridable/1-example-1" class="section-heading">  Example </h4> <pre data-language="elixir">defmodule Behaviour do
  @callback foo :: any
end

defmodule DefaultMod do
  defmacro __using__(_opts) do
    quote do
      @behaviour Behaviour

      def foo do
        "Override me"
      end

      defoverridable Behaviour
    end
  end
end

defmodule InheritMod do
  use DefaultMod

  def foo do
    "Overridden"
  end
end</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="defp/2">defp(call, expr \\ nil)</h3> <section class="docstring"> <p>Defines a private function with the given name and body.</p>
<p>Private functions are only accessible from within the module in which they are defined. Trying to access a private function from outside the module it's defined in results in an <a href="https://hexdocs.pm/elixir/UndefinedFunctionError.html"><code class="inline">UndefinedFunctionError</code></a> exception.</p>
<p>Check <a href="#def/2"><code class="inline">def/2</code></a> for more information.</p>
<h4 id="defp/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule Foo do
  def bar do
    sum(1, 2)
  end

  defp sum(a, b), do: a + b
end

Foo.bar()
#=&gt; 3

Foo.sum(1, 2)
** (UndefinedFunctionError) undefined function Foo.sum/2</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="defprotocol/2">defprotocol(name, do_block)</h3> <section class="docstring"> <p>Defines a protocol.</p>
<p>See the <a href="https://hexdocs.pm/elixir/Protocol.html"><code class="inline">Protocol</code></a> module for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="defstruct/1">defstruct(fields)</h3> <section class="docstring"> <p>Defines a struct.</p>
<p>A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions.</p>
<p>To define a struct, a developer must define both <code class="inline">__struct__/0</code> and <code class="inline">__struct__/1</code> functions. <a href="#defstruct/1"><code class="inline">defstruct/1</code></a> is a convenience macro which defines such functions with some conveniences.</p>
<p>For more information about structs, please check <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%25/2"><code class="inline">Kernel.SpecialForms.%/2</code></a>.</p>
<h4 id="defstruct/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule User do
  defstruct name: nil, age: nil
end</pre>
<p>Struct fields are evaluated at compile-time, which allows them to be dynamic. In the example below, <code class="inline">10 + 11</code> is evaluated at compile-time and the age field is stored with value <code class="inline">21</code>:</p>
<pre data-language="elixir">defmodule User do
  defstruct name: nil, age: 10 + 11
end</pre>
<p>The <code class="inline">fields</code> argument is usually a keyword list with field names as atom keys and default values as corresponding values. <a href="#defstruct/1"><code class="inline">defstruct/1</code></a> also supports a list of atoms as its argument: in that case, the atoms in the list will be used as the struct's field names and they will all default to <code class="inline">nil</code>.</p>
<pre data-language="elixir">defmodule Post do
  defstruct [:title, :content, :author]
end</pre>
<h4 id="defstruct/1-deriving" class="section-heading">  Deriving </h4> <p>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. For example, attempting to use a protocol with the <code class="inline">User</code> struct leads to an error:</p>
<pre data-language="elixir">john = %User{name: "John"}
MyProtocol.call(john)
** (Protocol.UndefinedError) protocol MyProtocol not implemented for %User{...}</pre>
<p><a href="#defstruct/1"><code class="inline">defstruct/1</code></a>, however, allows protocol implementations to be <em>derived</em>. This can be done by defining a <code class="inline">@derive</code> attribute as a list before invoking <a href="#defstruct/1"><code class="inline">defstruct/1</code></a>:</p>
<pre data-language="elixir">defmodule User do
  @derive [MyProtocol]
  defstruct name: nil, age: 10 + 11
end

MyProtocol.call(john) # it works!</pre>
<p>For each protocol in the <code class="inline">@derive</code> list, Elixir will assert the protocol has been implemented for <code class="inline">Any</code>. If the <code class="inline">Any</code> implementation defines a <code class="inline">__deriving__/3</code> callback, the callback will be invoked and it should define the implementation module. Otherwise an implementation that simply points to the <code class="inline">Any</code> implementation is automatically derived. For more information on the <code class="inline">__deriving__/3</code> callback, see <a href="https://hexdocs.pm/elixir/Protocol.html#derive/3"><code class="inline">Protocol.derive/3</code></a>.</p>
<h4 id="defstruct/1-enforcing-keys" class="section-heading">  Enforcing keys </h4> <p>When building a struct, Elixir will automatically guarantee all keys belongs to the struct:</p>
<pre data-language="elixir">%User{name: "john", unknown: :key}
** (KeyError) key :unknown not found in: %User{age: 21, name: nil}</pre>
<p>Elixir also allows developers to enforce certain keys must always be given when building the struct:</p>
<pre data-language="elixir">defmodule User do
  @enforce_keys [:name]
  defstruct name: nil, age: 10 + 11
end</pre>
<p>Now trying to build a struct without the name key will fail:</p>
<pre data-language="elixir">%User{age: 21}
** (ArgumentError) the following keys must also be given when building struct User: [:name]</pre>
<p>Keep in mind <code class="inline">@enforce_keys</code> is a simple compile-time guarantee to aid developers when building structs. It is not enforced on updates and it does not provide any sort of value-validation.</p>
<h4 id="defstruct/1-types" class="section-heading">  Types </h4> <p>It is recommended to define types for structs. By convention such type is called <code class="inline">t</code>. To define a struct inside a type, the struct literal syntax is used:</p>
<pre data-language="elixir">defmodule User do
  defstruct name: "John", age: 25
  @type t :: %__MODULE__{name: String.t(), age: non_neg_integer}
end</pre>
<p>It is recommended to only use the struct syntax when defining the struct's type. When referring to another struct it's better to use <code class="inline">User.t</code> instead of <code class="inline">%User{}</code>.</p>
<p>The types of the struct fields that are not included in <code class="inline">%User{}</code> default to <code class="inline">term()</code> (see <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types"><code class="inline">term/0</code></a>).</p>
<p>Structs whose internal structure is private to the local module (pattern matching them or directly accessing their fields should not be allowed) should use the <code class="inline">@opaque</code> attribute. Structs whose internal structure is public should use <code class="inline">@type</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="destructure/2">destructure(left, right)</h3> <section class="docstring"> <p>Destructures two lists, assigning each term in the right one to the matching term in the left one.</p>
<p>Unlike pattern matching via <code class="inline">=</code>, if the sizes of the left and right lists don't match, destructuring simply stops instead of raising an error.</p>
<h4 id="destructure/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; destructure([x, y, z], [1, 2, 3, 4, 5])
iex&gt; {x, y, z}
{1, 2, 3}</pre>
<p>In the example above, even though the right list has more entries than the left one, destructuring works fine. If the right list is smaller, the remaining elements are simply set to <code class="inline">nil</code>:</p>
<pre data-language="elixir">iex&gt; destructure([x, y, z], [1])
iex&gt; {x, y, z}
{1, nil, nil}</pre>
<p>The left-hand side supports any expression you would use on the left-hand side of a match:</p>
<pre data-language="elixir">x = 1
destructure([^x, y, z], [1, 2, 3])</pre>
<p>The example above will only work if <code class="inline">x</code> matches the first value in the right list. Otherwise, it will raise a <a href="https://hexdocs.pm/elixir/MatchError.html"><code class="inline">MatchError</code></a> (like the <code class="inline">=</code> operator would do).</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="exit/1">exit(reason)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">exit(term()) :: no_return()</pre> </div> <p>Stops the execution of the calling process with the given reason.</p>
<p>Since evaluating this function causes the process to terminate, it has no return value.</p>
<p>Inlined by the compiler.</p>
<h4 id="exit/1-examples" class="section-heading">  Examples </h4> <p>When a process reaches its end, by default it exits with reason <code class="inline">:normal</code>. You can also call <a href="#exit/1"><code class="inline">exit/1</code></a> explicitly if you want to terminate a process but not signal any failure:</p>
<pre data-language="elixir">exit(:normal)</pre>
<p>In case something goes wrong, you can also use <a href="#exit/1"><code class="inline">exit/1</code></a> with a different reason:</p>
<pre data-language="elixir">exit(:seems_bad)</pre>
<p>If the exit reason is not <code class="inline">:normal</code>, all the processes linked to the process that exited will crash (unless they are trapping exits).</p>
<h4 id="exit/1-otp-exits" class="section-heading">  OTP exits </h4> <p>Exits are used by the OTP to determine if a process exited abnormally or not. The following exits are considered "normal":</p>
<ul>
<li><code class="inline">exit(:normal)</code></li>
<li><code class="inline">exit(:shutdown)</code></li>
<li><code class="inline">exit({:shutdown, term})</code></li>
</ul>
<p>Exiting with any other reason is considered abnormal and treated as a crash. This means the default supervisor behaviour kicks in, error reports are emitted, and so forth.</p>
<p>This behaviour is relied on in many different places. For example, <a href="https://hexdocs.pm/ex_unit/ExUnit.html"><code class="inline">ExUnit</code></a> uses <code class="inline">exit(:shutdown)</code> when exiting the test process to signal linked processes, supervision trees and so on to politely shut down too.</p>
<h4 id="exit/1-cli-exits" class="section-heading">  CLI exits </h4> <p>Building on top of the exit signals mentioned above, if the process started by the command line exits with any of the three reasons above, its exit is considered normal and the Operating System process will exit with status 0.</p>
<p>It is, however, possible to customize the operating system exit signal by invoking:</p>
<pre data-language="elixir">exit({:shutdown, integer})</pre>
<p>This will cause the operating system process to exit with the status given by <code class="inline">integer</code> while signaling all linked Erlang processes to politely shut down.</p>
<p>Any other exit reason will cause the operating system process to exit with status <code class="inline">1</code> and linked Erlang processes to crash.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="function_exported?/3">function_exported?(module, function, arity)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">function_exported?(module(), atom(), arity()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">module</code> is loaded and contains a public <code class="inline">function</code> with the given <code class="inline">arity</code>, otherwise <code class="inline">false</code>.</p>
<p>Note that this function does not load the module in case it is not loaded. Check <a href="https://hexdocs.pm/elixir/Code.html#ensure_loaded/1"><code class="inline">Code.ensure_loaded/1</code></a> for more information.</p>
<p>Inlined by the compiler.</p>
<h4 id="function_exported?/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; function_exported?(Enum, :map, 2)
true

iex&gt; function_exported?(Enum, :map, 10)
false

iex&gt; function_exported?(List, :to_string, 1)
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_and_update_in/2">get_and_update_in(path, fun)</h3> <section class="docstring"> <p>Gets a value and updates a nested data structure via the given <code class="inline">path</code>.</p>
<p>This is similar to <a href="#get_and_update_in/3"><code class="inline">get_and_update_in/3</code></a>, except the path is extracted via a macro rather than passing a list. For example:</p>
<pre data-language="elixir">get_and_update_in(opts[:foo][:bar], &amp;{&amp;1, &amp;1 + 1})</pre>
<p>Is equivalent to:</p>
<pre data-language="elixir">get_and_update_in(opts, [:foo, :bar], &amp;{&amp;1, &amp;1 + 1})</pre>
<p>This also works with nested structs and the <code class="inline">struct.path.to.value</code> way to specify paths:</p>
<pre data-language="elixir">get_and_update_in(struct.foo.bar, &amp;{&amp;1, &amp;1 + 1})</pre>
<p>Note that in order for this macro to work, the complete path must always be visible by this macro. See the "Paths" section below.</p>
<h4 id="get_and_update_in/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; get_and_update_in(users["john"].age, &amp;{&amp;1, &amp;1 + 1})
{27, %{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}}</pre>
<h4 id="get_and_update_in/2-paths" class="section-heading">  Paths </h4> <p>A path may start with a variable, local or remote call, and must be followed by one or more:</p>
<ul>
<li><p><code class="inline">foo[bar]</code> - accesses the key <code class="inline">bar</code> in <code class="inline">foo</code>; in case <code class="inline">foo</code> is nil, <code class="inline">nil</code> is returned</p></li>
<li><p><code class="inline">foo.bar</code> - accesses a map/struct field; in case the field is not present, an error is raised</p></li>
</ul>
<p>Here are some valid paths:</p>
<pre data-language="elixir">users["john"][:age]
users["john"].age
User.all()["john"].age
all_users()["john"].age</pre>
<p>Here are some invalid ones:</p>
<pre data-language="elixir"># Does a remote call after the initial value
users["john"].do_something(arg1, arg2)

# Does not access any key or field
users</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_and_update_in/3">get_and_update_in(data, keys, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_and_update_in(
  structure :: Access.t(),
  keys,
  (term() -&gt; {get_value, update_value} | :pop)
) :: {get_value, structure :: Access.t()}
when keys: [any(), ...], update_value: term(), get_value: var</pre> </div> <p>Gets a value and updates a nested structure.</p>
<p><code class="inline">data</code> is a nested structure (that is, a map, keyword list, or struct that implements the <a href="https://hexdocs.pm/elixir/Access.html"><code class="inline">Access</code></a> behaviour).</p>
<p>The <code class="inline">fun</code> argument receives the value of <code class="inline">key</code> (or <code class="inline">nil</code> if <code class="inline">key</code> is not present) and must return one of the following values:</p>
<ul>
<li><p>a two-element tuple <code class="inline">{get_value, new_value}</code>. In this case, <code class="inline">get_value</code> is the retrieved value which can possibly be operated on before being returned. <code class="inline">new_value</code> is the new value to be stored under <code class="inline">key</code>.</p></li>
<li><p><code class="inline">:pop</code>, which implies that the current value under <code class="inline">key</code> should be removed from the structure and returned.</p></li>
</ul>
<p>This function uses the <a href="https://hexdocs.pm/elixir/Access.html"><code class="inline">Access</code></a> module to traverse the structures according to the given <code class="inline">keys</code>, unless the <code class="inline">key</code> is a function, which is detailed in a later section.</p>
<h4 id="get_and_update_in/3-examples" class="section-heading">  Examples </h4> <p>This function is useful when there is a need to retrieve the current value (or something calculated in function of the current value) and update it at the same time. For example, it could be used to read the current age of a user while increasing it by one in one pass:</p>
<pre data-language="elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; get_and_update_in(users, ["john", :age], &amp;{&amp;1, &amp;1 + 1})
{27, %{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}}</pre>
<h4 id="get_and_update_in/3-functions-as-keys" class="section-heading">  Functions as keys </h4> <p>If a key is a function, the function will be invoked passing three arguments:</p>
<ul>
<li>the operation (<code class="inline">:get_and_update</code>)</li>
<li>the data to be accessed</li>
<li>a function to be invoked next</li>
</ul>
<p>This means <a href="#get_and_update_in/3"><code class="inline">get_and_update_in/3</code></a> can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.</p>
<p>When one of the keys is a function, the function is invoked. In the example below, we use a function to get and increment all ages inside a list:</p>
<pre data-language="elixir">iex&gt; users = [%{name: "john", age: 27}, %{name: "meg", age: 23}]
iex&gt; all = fn :get_and_update, data, next -&gt;
...&gt;   data |&gt; Enum.map(next) |&gt; Enum.unzip()
...&gt; end
iex&gt; get_and_update_in(users, [all, :age], &amp;{&amp;1, &amp;1 + 1})
{[27, 23], [%{name: "john", age: 28}, %{name: "meg", age: 24}]}</pre>
<p>If the previous value before invoking the function is <code class="inline">nil</code>, the function <em>will</em> receive <code class="inline">nil</code> as a value and must handle it accordingly (be it by failing or providing a sane default).</p>
<p>The <a href="https://hexdocs.pm/elixir/Access.html"><code class="inline">Access</code></a> module ships with many convenience accessor functions, like the <code class="inline">all</code> anonymous function defined above. See <a href="https://hexdocs.pm/elixir/Access.html#all/0"><code class="inline">Access.all/0</code></a>, <a href="https://hexdocs.pm/elixir/Access.html#key/2"><code class="inline">Access.key/2</code></a>, and others as examples.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_in/2">get_in(data, keys)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">get_in(Access.t(), [term(), ...]) :: term()</pre> </div> <p>Gets a value from a nested structure.</p>
<p>Uses the <a href="https://hexdocs.pm/elixir/Access.html"><code class="inline">Access</code></a> module to traverse the structures according to the given <code class="inline">keys</code>, unless the <code class="inline">key</code> is a function, which is detailed in a later section.</p>
<h4 id="get_in/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; get_in(users, ["john", :age])
27</pre>
<p>In case any of the keys returns <code class="inline">nil</code>, <code class="inline">nil</code> will be returned:</p>
<pre data-language="elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; get_in(users, ["unknown", :age])
nil</pre>
<h4 id="get_in/2-functions-as-keys" class="section-heading">  Functions as keys </h4> <p>If a key is a function, the function will be invoked passing three arguments:</p>
<ul>
<li>the operation (<code class="inline">:get</code>)</li>
<li>the data to be accessed</li>
<li>a function to be invoked next</li>
</ul>
<p>This means <a href="#get_in/2"><code class="inline">get_in/2</code></a> can be extended to provide custom lookups. In the example below, we use a function to get all the maps inside a list:</p>
<pre data-language="elixir">iex&gt; users = [%{name: "john", age: 27}, %{name: "meg", age: 23}]
iex&gt; all = fn :get, data, next -&gt; Enum.map(data, next) end
iex&gt; get_in(users, [all, :age])
[27, 23]</pre>
<p>If the previous value before invoking the function is <code class="inline">nil</code>, the function <em>will</em> receive <code class="inline">nil</code> as a value and must handle it accordingly.</p>
<p>The <a href="https://hexdocs.pm/elixir/Access.html"><code class="inline">Access</code></a> module ships with many convenience accessor functions, like the <code class="inline">all</code> anonymous function defined above. See <a href="https://hexdocs.pm/elixir/Access.html#all/0"><code class="inline">Access.all/0</code></a>, <a href="https://hexdocs.pm/elixir/Access.html#key/2"><code class="inline">Access.key/2</code></a>, and others as examples.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="if/2">if(condition, clauses)</h3> <section class="docstring"> <p>Provides an <a href="#if/2"><code class="inline">if/2</code></a> macro.</p>
<p>This macro expects the first argument to be a condition and the second argument to be a keyword list.</p>
<h4 id="if/2-one-liner-examples" class="section-heading">  One-liner examples </h4> <pre data-language="elixir">if(foo, do: bar)</pre>
<p>In the example above, <code class="inline">bar</code> will be returned if <code class="inline">foo</code> evaluates to a truthy value (neither <code class="inline">false</code> nor <code class="inline">nil</code>). Otherwise, <code class="inline">nil</code> will be returned.</p>
<p>An <code class="inline">else</code> option can be given to specify the opposite:</p>
<pre data-language="elixir">if(foo, do: bar, else: baz)</pre>
<h4 id="if/2-blocks-examples" class="section-heading">  Blocks examples </h4> <p>It's also possible to pass a block to the <a href="#if/2"><code class="inline">if/2</code></a> macro. The first example above would be translated to:</p>
<pre data-language="elixir">if foo do
  bar
end</pre>
<p>Note that <code class="inline">do/end</code> become delimiters. The second example would translate to:</p>
<pre data-language="elixir">if foo do
  bar
else
  baz
end</pre>
<p>In order to compare more than two clauses, the <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#cond/1"><code class="inline">cond/1</code></a> macro has to be used.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="inspect/2">inspect(term, opts \\ [])</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">inspect(Inspect.t(), keyword()) :: String.t()</pre> </div> <p>Inspects the given argument according to the <a href="https://hexdocs.pm/elixir/Inspect.html"><code class="inline">Inspect</code></a> protocol. The second argument is a keyword list with options to control inspection.</p>
<h4 id="inspect/2-options" class="section-heading">  Options </h4> <p><a href="#inspect/2"><code class="inline">inspect/2</code></a> accepts a list of options that are internally translated to an <a href="https://hexdocs.pm/elixir/Inspect.Opts.html"><code class="inline">Inspect.Opts</code></a> struct. Check the docs for <a href="https://hexdocs.pm/elixir/Inspect.Opts.html"><code class="inline">Inspect.Opts</code></a> to see the supported options.</p>
<h4 id="inspect/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; inspect(:foo)
":foo"

iex&gt; inspect([1, 2, 3, 4, 5], limit: 3)
"[1, 2, 3, ...]"

iex&gt; inspect([1, 2, 3], pretty: true, width: 0)
"[1,\n 2,\n 3]"

iex&gt; inspect("olá" &lt;&gt; &lt;&lt;0&gt;&gt;)
"&lt;&lt;111, 108, 195, 161, 0&gt;&gt;"

iex&gt; inspect("olá" &lt;&gt; &lt;&lt;0&gt;&gt;, binaries: :as_strings)
"\"olá\\0\""

iex&gt; inspect("olá", binaries: :as_binaries)
"&lt;&lt;111, 108, 195, 161&gt;&gt;"

iex&gt; inspect('bar')
"'bar'"

iex&gt; inspect([0 | 'bar'])
"[0, 98, 97, 114]"

iex&gt; inspect(100, base: :octal)
"0o144"

iex&gt; inspect(100, base: :hex)
"0x64"</pre>
<p>Note that the <a href="https://hexdocs.pm/elixir/Inspect.html"><code class="inline">Inspect</code></a> protocol does not necessarily return a valid representation of an Elixir term. In such cases, the inspected result must start with <code class="inline">#</code>. For example, inspecting a function will return:</p>
<pre data-language="elixir">inspect(fn a, b -&gt; a + b end)
#=&gt; #Function&lt;...&gt;</pre>
<p>The <a href="https://hexdocs.pm/elixir/Inspect.html"><code class="inline">Inspect</code></a> protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. See the "Deriving" section of the documentation of the <a href="https://hexdocs.pm/elixir/Inspect.html"><code class="inline">Inspect</code></a> protocol for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="macro_exported?/3">macro_exported?(module, macro, arity)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">macro_exported?(module(), atom(), arity()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">module</code> is loaded and contains a public <code class="inline">macro</code> with the given <code class="inline">arity</code>, otherwise <code class="inline">false</code>.</p>
<p>Note that this function does not load the module in case it is not loaded. Check <a href="https://hexdocs.pm/elixir/Code.html#ensure_loaded/1"><code class="inline">Code.ensure_loaded/1</code></a> for more information.</p>
<p>If <code class="inline">module</code> is an Erlang module (as opposed to an Elixir module), this function always returns <code class="inline">false</code>.</p>
<h4 id="macro_exported?/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; macro_exported?(Kernel, :use, 2)
true

iex&gt; macro_exported?(:erlang, :abs, 1)
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="make_ref/0">make_ref()</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">make_ref() :: reference()</pre> </div> <p>Returns an almost unique reference.</p>
<p>The returned reference will re-occur after approximately 2^82 calls; therefore it is unique enough for practical purposes.</p>
<p>Inlined by the compiler.</p>
<h4 id="make_ref/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">make_ref()
#=&gt; #Reference&lt;0.0.0.135&gt;</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="match?/2">match?(pattern, expr)</h3> <section class="docstring"> <p>A convenience macro that checks if the right side (an expression) matches the left side (a pattern).</p>
<h4 id="match?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; match?(1, 1)
true

iex&gt; match?({1, _}, {1, 2})
true

iex&gt; map = %{a: 1, b: 2}
iex&gt; match?(%{a: _}, map)
true

iex&gt; a = 1
iex&gt; match?(^a, 1)
true</pre>
<p><a href="#match?/2"><code class="inline">match?/2</code></a> is very useful when filtering or finding a value in an enumerable:</p>
<pre data-language="elixir">iex&gt; list = [a: 1, b: 2, a: 3]
iex&gt; Enum.filter(list, &amp;match?({:a, _}, &amp;1))
[a: 1, a: 3]</pre>
<p>Guard clauses can also be given to the match:</p>
<pre data-language="elixir">iex&gt; list = [a: 1, b: 2, a: 3]
iex&gt; Enum.filter(list, &amp;match?({:a, x} when x &lt; 2, &amp;1))
[a: 1]</pre>
<p>However, variables assigned in the match will not be available outside of the function call (unlike regular pattern matching with the <code class="inline">=</code> operator):</p>
<pre data-language="elixir">iex&gt; match?(_x, 1)
true
iex&gt; binding()
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="max/2">max(first, second)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">max(first, second) :: first | second when first: term(), second: term()</pre> </div> <p>Returns the biggest of the two given terms according to Erlang's term ordering.</p>
<p>If the terms compare equal, the first one is returned.</p>
<p>Inlined by the compiler.</p>
<h4 id="max/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; max(1, 2)
2
iex&gt; max(:a, :b)
:b</pre>
<p>Using Erlang's term ordering means that comparisons are structural and not semantic. For example, when comparing dates:</p>
<pre data-language="elixir">iex&gt; max(~D[2017-03-31], ~D[2017-04-01])
~D[2017-03-31]</pre>
<p>In the example above, <a href="#max/2"><code class="inline">max/2</code></a> returned March 31st instead of April 1st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as <a href="https://hexdocs.pm/elixir/Date.html#compare/2"><code class="inline">Date.compare/2</code></a> that perform semantic comparison.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="min/2">min(first, second)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">min(first, second) :: first | second when first: term(), second: term()</pre> </div> <p>Returns the smallest of the two given terms according to Erlang's term ordering.</p>
<p>If the terms compare equal, the first one is returned.</p>
<p>Inlined by the compiler.</p>
<h4 id="min/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; min(1, 2)
1
iex&gt; min("foo", "bar")
"bar"</pre>
<p>Using Erlang's term ordering means that comparisons are structural and not semantic. For example, when comparing dates:</p>
<pre data-language="elixir">iex&gt; min(~D[2017-03-31], ~D[2017-04-01])
~D[2017-04-01]</pre>
<p>In the example above, <a href="#min/2"><code class="inline">min/2</code></a> returned April 1st instead of March 31st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as <a href="https://hexdocs.pm/elixir/Date.html#compare/2"><code class="inline">Date.compare/2</code></a> that perform semantic comparison.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="pop_in/1">pop_in(path)</h3> <section class="docstring"> <p>Pops a key from the nested structure via the given <code class="inline">path</code>.</p>
<p>This is similar to <a href="#pop_in/2"><code class="inline">pop_in/2</code></a>, except the path is extracted via a macro rather than passing a list. For example:</p>
<pre data-language="elixir">pop_in(opts[:foo][:bar])</pre>
<p>Is equivalent to:</p>
<pre data-language="elixir">pop_in(opts, [:foo, :bar])</pre>
<p>Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check <a href="#get_and_update_in/2"><code class="inline">get_and_update_in/2</code></a> docs.</p>
<h4 id="pop_in/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; pop_in(users["john"][:age])
{27, %{"john" =&gt; %{}, "meg" =&gt; %{age: 23}}}

iex&gt; users = %{john: %{age: 27}, meg: %{age: 23}}
iex&gt; pop_in(users.john[:age])
{27, %{john: %{}, meg: %{age: 23}}}</pre>
<p>In case any entry returns <code class="inline">nil</code>, its key will be removed and the deletion will be considered a success.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="pop_in/2">pop_in(data, keys)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">pop_in(data, [Access.get_and_update_fun(term(), data) | term(), ...]) ::
  {term(), data}
when data: Access.container()</pre> </div> <p>Pops a key from the given nested structure.</p>
<p>Uses the <a href="https://hexdocs.pm/elixir/Access.html"><code class="inline">Access</code></a> protocol to traverse the structures according to the given <code class="inline">keys</code>, unless the <code class="inline">key</code> is a function. If the key is a function, it will be invoked as specified in <a href="#get_and_update_in/3"><code class="inline">get_and_update_in/3</code></a>.</p>
<h4 id="pop_in/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; pop_in(users, ["john", :age])
{27, %{"john" =&gt; %{}, "meg" =&gt; %{age: 23}}}</pre>
<p>In case any entry returns <code class="inline">nil</code>, its key will be removed and the deletion will be considered a success.</p>
<pre data-language="elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; pop_in(users, ["jane", :age])
{nil, %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_elem/3">put_elem(tuple, index, value)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put_elem(tuple(), non_neg_integer(), term()) :: tuple()</pre> </div> <p>Puts <code class="inline">value</code> at the given zero-based <code class="inline">index</code> in <code class="inline">tuple</code>.</p>
<p>Inlined by the compiler.</p>
<h4 id="put_elem/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; tuple = {:foo, :bar, 3}
iex&gt; put_elem(tuple, 0, :baz)
{:baz, :bar, 3}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_in/2">put_in(path, value)</h3> <section class="docstring"> <p>Puts a value in a nested structure via the given <code class="inline">path</code>.</p>
<p>This is similar to <a href="#put_in/3"><code class="inline">put_in/3</code></a>, except the path is extracted via a macro rather than passing a list. For example:</p>
<pre data-language="elixir">put_in(opts[:foo][:bar], :baz)</pre>
<p>Is equivalent to:</p>
<pre data-language="elixir">put_in(opts, [:foo, :bar], :baz)</pre>
<p>This also works with nested structs and the <code class="inline">struct.path.to.value</code> way to specify paths:</p>
<pre data-language="elixir">put_in(struct.foo.bar, :baz)</pre>
<p>Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check <a href="#get_and_update_in/2"><code class="inline">get_and_update_in/2</code></a> docs.</p>
<h4 id="put_in/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; put_in(users["john"][:age], 28)
%{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}

iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; put_in(users["john"].age, 28)
%{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_in/3">put_in(data, keys, value)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">put_in(Access.t(), [term(), ...], term()) :: Access.t()</pre> </div> <p>Puts a value in a nested structure.</p>
<p>Uses the <a href="https://hexdocs.pm/elixir/Access.html"><code class="inline">Access</code></a> module to traverse the structures according to the given <code class="inline">keys</code>, unless the <code class="inline">key</code> is a function. If the key is a function, it will be invoked as specified in <a href="#get_and_update_in/3"><code class="inline">get_and_update_in/3</code></a>.</p>
<h4 id="put_in/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; put_in(users, ["john", :age], 28)
%{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}</pre>
<p>In case any of the entries in the middle returns <code class="inline">nil</code>, an error will be raised when trying to access it next.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="raise/1">raise(message)</h3> <section class="docstring"> <p>Raises an exception.</p>
<p>If the argument <code class="inline">msg</code> is a binary, it raises a <a href="https://hexdocs.pm/elixir/RuntimeError.html"><code class="inline">RuntimeError</code></a> exception using the given argument as message.</p>
<p>If <code class="inline">msg</code> is an atom, it just calls <a href="#raise/2"><code class="inline">raise/2</code></a> with the atom as the first argument and <code class="inline">[]</code> as the second argument.</p>
<p>If <code class="inline">msg</code> is an exception struct, it is raised as is.</p>
<p>If <code class="inline">msg</code> is anything else, <code class="inline">raise</code> will fail with an <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> exception.</p>
<h4 id="raise/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; raise "oops"
** (RuntimeError) oops

try do
  1 + :foo
rescue
  x in [ArithmeticError] -&gt;
    IO.puts("that was expected")
    raise x
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="raise/2">raise(exception, attributes)</h3> <section class="docstring"> <p>Raises an exception.</p>
<p>Calls the <code class="inline">exception/1</code> function on the given argument (which has to be a module name like <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> or <a href="https://hexdocs.pm/elixir/RuntimeError.html"><code class="inline">RuntimeError</code></a>) passing <code class="inline">attrs</code> as the attributes in order to retrieve the exception struct.</p>
<p>Any module that contains a call to the <a href="#defexception/1"><code class="inline">defexception/1</code></a> macro automatically implements the <a href="https://hexdocs.pm/elixir/Exception.html#c:exception/1"><code class="inline">Exception.exception/1</code></a> callback expected by <a href="#raise/2"><code class="inline">raise/2</code></a>. For more information, see <a href="#defexception/1"><code class="inline">defexception/1</code></a>.</p>
<h4 id="raise/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; raise(ArgumentError, "Sample")
** (ArgumentError) Sample</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reraise/2">reraise(message, stacktrace)</h3> <section class="docstring"> <p>Raises an exception preserving a previous stacktrace.</p>
<p>Works like <a href="#raise/1"><code class="inline">raise/1</code></a> but does not generate a new stacktrace.</p>
<p>Note that <code class="inline">__STACKTRACE__</code> can be used inside catch/rescue to retrieve the current stacktrace.</p>
<h4 id="reraise/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">try do
  raise "oops"
rescue
  exception -&gt;
    reraise exception, __STACKTRACE__
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reraise/3">reraise(exception, attributes, stacktrace)</h3> <section class="docstring"> <p>Raises an exception preserving a previous stacktrace.</p>
<p><a href="#reraise/3"><code class="inline">reraise/3</code></a> works like <a href="#reraise/2"><code class="inline">reraise/2</code></a>, except it passes arguments to the <code class="inline">exception/1</code> function as explained in <a href="#raise/2"><code class="inline">raise/2</code></a>.</p>
<h4 id="reraise/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">try do
  raise "oops"
rescue
  exception -&gt;
    reraise WrapperError, [exception: exception], __STACKTRACE__
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="send/2">send(dest, message)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">send(dest :: Process.dest(), message) :: message when message: any()</pre> </div> <p>Sends a message to the given <code class="inline">dest</code> and returns the message.</p>
<p><code class="inline">dest</code> may be a remote or local PID, a local port, a locally registered name, or a tuple in the form of <code class="inline">{registered_name, node}</code> for a registered name at another node.</p>
<p>Inlined by the compiler.</p>
<h4 id="send/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; send(self(), :hello)
:hello</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_C/2">sigil_C(term, modifiers)</h3> <section class="docstring"> <p>Handles the sigil <code class="inline">~C</code> for charlists.</p>
<p>It returns a charlist without interpolations and without escape characters, except for the escaping of the closing sigil character itself.</p>
<h4 id="sigil_C/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; ~C(foo)
'foo'

iex&gt; ~C(f#{o}o)
'f\#{o}o'</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_D/2">sigil_D(date_string, modifiers)</h3> <section class="docstring"> <p>Handles the sigil <code class="inline">~D</code> for dates.</p>
<p>By default, this sigil uses the built-in <a href="https://hexdocs.pm/elixir/Calendar.ISO.html"><code class="inline">Calendar.ISO</code></a>, which requires dates to be written in the ISO8601 format:</p>
<pre data-language="elixir">~D[yyyy-mm-dd]</pre>
<p>such as:</p>
<pre data-language="elixir">~D[2015-01-13]</pre>
<p>If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name:</p>
<pre data-language="elixir">~D[SOME-REPRESENTATION My.Alternative.Calendar]</pre>
<p>The lower case <code class="inline">~d</code> variant does not exist as interpolation and escape characters are not useful for date sigils.</p>
<p>More information on dates can be found in the <a href="https://hexdocs.pm/elixir/Date.html"><code class="inline">Date</code></a> module.</p>
<h4 id="sigil_D/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; ~D[2015-01-13]
~D[2015-01-13]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_N/2">sigil_N(naive_datetime_string, modifiers)</h3> <section class="docstring"> <p>Handles the sigil <code class="inline">~N</code> for naive date times.</p>
<p>By default, this sigil uses the built-in <a href="https://hexdocs.pm/elixir/Calendar.ISO.html"><code class="inline">Calendar.ISO</code></a>, which requires naive date times to be written in the ISO8601 format:</p>
<pre data-language="elixir">~N[yyyy-mm-dd hh:mm:ss]
~N[yyyy-mm-dd hh:mm:ss.ssssss]
~N[yyyy-mm-ddThh:mm:ss.ssssss]</pre>
<p>such as:</p>
<pre data-language="elixir">~N[2015-01-13 13:00:07]
~N[2015-01-13T13:00:07.123]</pre>
<p>If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name:</p>
<pre data-language="elixir">~N[SOME-REPRESENTATION My.Alternative.Calendar]</pre>
<p>The lower case <code class="inline">~n</code> variant does not exist as interpolation and escape characters are not useful for date time sigils.</p>
<p>More information on naive date times can be found in the <a href="https://hexdocs.pm/elixir/NaiveDateTime.html"><code class="inline">NaiveDateTime</code></a> module.</p>
<h4 id="sigil_N/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; ~N[2015-01-13 13:00:07]
~N[2015-01-13 13:00:07]
iex&gt; ~N[2015-01-13T13:00:07.001]
~N[2015-01-13 13:00:07.001]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_R/2">sigil_R(term, modifiers)</h3> <section class="docstring"> <p>Handles the sigil <code class="inline">~R</code> for regular expressions.</p>
<p>It returns a regular expression pattern without interpolations and without escape characters. Note it still supports escape of Regex tokens (such as escaping <code class="inline">+</code> or <code class="inline">?</code>) and it also requires you to escape the closing sigil character itself if it appears on the Regex.</p>
<p>More information on regexes can be found in the <a href="https://hexdocs.pm/elixir/Regex.html"><code class="inline">Regex</code></a> module.</p>
<h4 id="sigil_R/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Regex.match?(~R(f#{1,3}o), "f#o")
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_S/2">sigil_S(term, modifiers)</h3> <section class="docstring"> <p>Handles the sigil <code class="inline">~S</code> for strings.</p>
<p>It returns a string without interpolations and without escape characters, except for the escaping of the closing sigil character itself.</p>
<h4 id="sigil_S/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; ~S(foo)
"foo"
iex&gt; ~S(f#{o}o)
"f\#{o}o"
iex&gt; ~S(\o/)
"\\o/"</pre>
<p>However, if you want to re-use the sigil character itself on the string, you need to escape it:</p>
<pre data-language="elixir">iex&gt; ~S((\))
"()"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_T/2">sigil_T(time_string, modifiers)</h3> <section class="docstring"> <p>Handles the sigil <code class="inline">~T</code> for times.</p>
<p>By default, this sigil uses the built-in <a href="https://hexdocs.pm/elixir/Calendar.ISO.html"><code class="inline">Calendar.ISO</code></a>, which requires times to be written in the ISO8601 format:</p>
<pre data-language="elixir">~T[hh:mm:ss]
~T[hh:mm:ss.ssssss]</pre>
<p>such as:</p>
<pre data-language="elixir">~T[13:00:07]
~T[13:00:07.123]</pre>
<p>If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name:</p>
<pre data-language="elixir">~T[SOME-REPRESENTATION My.Alternative.Calendar]</pre>
<p>The lower case <code class="inline">~t</code> variant does not exist as interpolation and escape characters are not useful for time sigils.</p>
<p>More information on times can be found in the <a href="https://hexdocs.pm/elixir/Time.html"><code class="inline">Time</code></a> module.</p>
<h4 id="sigil_T/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; ~T[13:00:07]
~T[13:00:07]
iex&gt; ~T[13:00:07.001]
~T[13:00:07.001]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_U/2">sigil_U(datetime_string, modifiers)</h3> <section class="docstring"> <p>Handles the sigil <code class="inline">~U</code> to create a UTC <a href="https://hexdocs.pm/elixir/DateTime.html"><code class="inline">DateTime</code></a>.</p>
<p>By default, this sigil uses the built-in <a href="https://hexdocs.pm/elixir/Calendar.ISO.html"><code class="inline">Calendar.ISO</code></a>, which requires UTC date times to be written in the ISO8601 format:</p>
<pre data-language="elixir">~U[yyyy-mm-dd hh:mm:ssZ]
~U[yyyy-mm-dd hh:mm:ss.ssssssZ]
~U[yyyy-mm-ddThh:mm:ss.ssssss+00:00]</pre>
<p>such as:</p>
<pre data-language="elixir">~U[2015-01-13 13:00:07Z]
~U[2015-01-13T13:00:07.123+00:00]</pre>
<p>If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name:</p>
<pre data-language="elixir">~U[SOME-REPRESENTATION My.Alternative.Calendar]</pre>
<p>The given <code class="inline">datetime_string</code> must include "Z" or "00:00" offset which marks it as UTC, otherwise an error is raised.</p>
<p>The lower case <code class="inline">~u</code> variant does not exist as interpolation and escape characters are not useful for date time sigils.</p>
<p>More information on date times can be found in the <a href="https://hexdocs.pm/elixir/DateTime.html"><code class="inline">DateTime</code></a> module.</p>
<h4 id="sigil_U/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; ~U[2015-01-13 13:00:07Z]
~U[2015-01-13 13:00:07Z]
iex&gt; ~U[2015-01-13T13:00:07.001+00:00]
~U[2015-01-13 13:00:07.001Z]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_W/2">sigil_W(term, modifiers)</h3> <section class="docstring"> <p>Handles the sigil <code class="inline">~W</code> for list of words.</p>
<p>It returns a list of "words" split by whitespace without interpolations and without escape characters, except for the escaping of the closing sigil character itself.</p>
<h4 id="sigil_W/2-modifiers" class="section-heading">  Modifiers </h4> <ul>
<li>
<code class="inline">s</code>: words in the list are strings (default)</li>
<li>
<code class="inline">a</code>: words in the list are atoms</li>
<li>
<code class="inline">c</code>: words in the list are charlists</li>
</ul>
<h4 id="sigil_W/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; ~W(foo #{bar} baz)
["foo", "\#{bar}", "baz"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_c/2">sigil_c(term, modifiers)</h3> <section class="docstring"> <p>Handles the sigil <code class="inline">~c</code> for charlists.</p>
<p>It returns a charlist as if it was a single quoted string, unescaping characters and replacing interpolations.</p>
<h4 id="sigil_c/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; ~c(foo)
'foo'

iex&gt; ~c(f#{:o}o)
'foo'

iex&gt; ~c(f\#{:o}o)
'f\#{:o}o'</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_r/2">sigil_r(term, modifiers)</h3> <section class="docstring"> <p>Handles the sigil <code class="inline">~r</code> for regular expressions.</p>
<p>It returns a regular expression pattern, unescaping characters and replacing interpolations.</p>
<p>More information on regular expressions can be found in the <a href="https://hexdocs.pm/elixir/Regex.html"><code class="inline">Regex</code></a> module.</p>
<h4 id="sigil_r/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Regex.match?(~r(foo), "foo")
true

iex&gt; Regex.match?(~r/abc/, "abc")
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_s/2">sigil_s(term, modifiers)</h3> <section class="docstring"> <p>Handles the sigil <code class="inline">~s</code> for strings.</p>
<p>It returns a string as if it was a double quoted string, unescaping characters and replacing interpolations.</p>
<h4 id="sigil_s/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; ~s(foo)
"foo"

iex&gt; ~s(f#{:o}o)
"foo"

iex&gt; ~s(f\#{:o}o)
"f\#{:o}o"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_w/2">sigil_w(term, modifiers)</h3> <section class="docstring"> <p>Handles the sigil <code class="inline">~w</code> for list of words.</p>
<p>It returns a list of "words" split by whitespace. Character unescaping and interpolation happens for each word.</p>
<h4 id="sigil_w/2-modifiers" class="section-heading">  Modifiers </h4> <ul>
<li>
<code class="inline">s</code>: words in the list are strings (default)</li>
<li>
<code class="inline">a</code>: words in the list are atoms</li>
<li>
<code class="inline">c</code>: words in the list are charlists</li>
</ul>
<h4 id="sigil_w/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; ~w(foo #{:bar} baz)
["foo", "bar", "baz"]

iex&gt; ~w(foo #{" bar baz "})
["foo", "bar", "baz"]

iex&gt; ~w(--source test/enum_test.exs)
["--source", "test/enum_test.exs"]

iex&gt; ~w(foo bar baz)a
[:foo, :bar, :baz]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="spawn/1">spawn(fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">spawn((() -&gt; any())) :: pid()</pre> </div> <p>Spawns the given function and returns its PID.</p>
<p>Typically developers do not use the <code class="inline">spawn</code> functions, instead they use abstractions such as <a href="https://hexdocs.pm/elixir/Task.html"><code class="inline">Task</code></a>, <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a> and <a href="https://hexdocs.pm/elixir/Agent.html"><code class="inline">Agent</code></a>, built on top of <code class="inline">spawn</code>, that spawns processes with more conveniences in terms of introspection and debugging.</p>
<p>Check the <a href="https://hexdocs.pm/elixir/Process.html"><code class="inline">Process</code></a> module for more process-related functions.</p>
<p>The anonymous function receives 0 arguments, and may return any value.</p>
<p>Inlined by the compiler.</p>
<h4 id="spawn/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">current = self()
child = spawn(fn -&gt; send(current, {self(), 1 + 2}) end)

receive do
  {^child, 3} -&gt; IO.puts("Received 3 back")
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="spawn/3">spawn(module, fun, args)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">spawn(module(), atom(), list()) :: pid()</pre> </div> <p>Spawns the given function <code class="inline">fun</code> from the given <code class="inline">module</code> passing it the given <code class="inline">args</code> and returns its PID.</p>
<p>Typically developers do not use the <code class="inline">spawn</code> functions, instead they use abstractions such as <a href="https://hexdocs.pm/elixir/Task.html"><code class="inline">Task</code></a>, <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a> and <a href="https://hexdocs.pm/elixir/Agent.html"><code class="inline">Agent</code></a>, built on top of <code class="inline">spawn</code>, that spawns processes with more conveniences in terms of introspection and debugging.</p>
<p>Check the <a href="https://hexdocs.pm/elixir/Process.html"><code class="inline">Process</code></a> module for more process-related functions.</p>
<p>Inlined by the compiler.</p>
<h4 id="spawn/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">spawn(SomeModule, :function, [1, 2, 3])</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="spawn_link/1">spawn_link(fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">spawn_link((() -&gt; any())) :: pid()</pre> </div> <p>Spawns the given function, links it to the current process, and returns its PID.</p>
<p>Typically developers do not use the <code class="inline">spawn</code> functions, instead they use abstractions such as <a href="https://hexdocs.pm/elixir/Task.html"><code class="inline">Task</code></a>, <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a> and <a href="https://hexdocs.pm/elixir/Agent.html"><code class="inline">Agent</code></a>, built on top of <code class="inline">spawn</code>, that spawns processes with more conveniences in terms of introspection and debugging.</p>
<p>Check the <a href="https://hexdocs.pm/elixir/Process.html"><code class="inline">Process</code></a> module for more process-related functions. For more information on linking, check <a href="https://hexdocs.pm/elixir/Process.html#link/1"><code class="inline">Process.link/1</code></a>.</p>
<p>The anonymous function receives 0 arguments, and may return any value.</p>
<p>Inlined by the compiler.</p>
<h4 id="spawn_link/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">current = self()
child = spawn_link(fn -&gt; send(current, {self(), 1 + 2}) end)

receive do
  {^child, 3} -&gt; IO.puts("Received 3 back")
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="spawn_link/3">spawn_link(module, fun, args)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">spawn_link(module(), atom(), list()) :: pid()</pre> </div> <p>Spawns the given function <code class="inline">fun</code> from the given <code class="inline">module</code> passing it the given <code class="inline">args</code>, links it to the current process, and returns its PID.</p>
<p>Typically developers do not use the <code class="inline">spawn</code> functions, instead they use abstractions such as <a href="https://hexdocs.pm/elixir/Task.html"><code class="inline">Task</code></a>, <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a> and <a href="https://hexdocs.pm/elixir/Agent.html"><code class="inline">Agent</code></a>, built on top of <code class="inline">spawn</code>, that spawns processes with more conveniences in terms of introspection and debugging.</p>
<p>Check the <a href="https://hexdocs.pm/elixir/Process.html"><code class="inline">Process</code></a> module for more process-related functions. For more information on linking, check <a href="https://hexdocs.pm/elixir/Process.html#link/1"><code class="inline">Process.link/1</code></a>.</p>
<p>Inlined by the compiler.</p>
<h4 id="spawn_link/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">spawn_link(SomeModule, :function, [1, 2, 3])</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="spawn_monitor/1">spawn_monitor(fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">spawn_monitor((() -&gt; any())) :: {pid(), reference()}</pre> </div> <p>Spawns the given function, monitors it and returns its PID and monitoring reference.</p>
<p>Typically developers do not use the <code class="inline">spawn</code> functions, instead they use abstractions such as <a href="https://hexdocs.pm/elixir/Task.html"><code class="inline">Task</code></a>, <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a> and <a href="https://hexdocs.pm/elixir/Agent.html"><code class="inline">Agent</code></a>, built on top of <code class="inline">spawn</code>, that spawns processes with more conveniences in terms of introspection and debugging.</p>
<p>Check the <a href="https://hexdocs.pm/elixir/Process.html"><code class="inline">Process</code></a> module for more process-related functions.</p>
<p>The anonymous function receives 0 arguments, and may return any value.</p>
<p>Inlined by the compiler.</p>
<h4 id="spawn_monitor/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">current = self()
spawn_monitor(fn -&gt; send(current, {self(), 1 + 2}) end)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="spawn_monitor/3">spawn_monitor(module, fun, args)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">spawn_monitor(module(), atom(), list()) :: {pid(), reference()}</pre> </div> <p>Spawns the given module and function passing the given args, monitors it and returns its PID and monitoring reference.</p>
<p>Typically developers do not use the <code class="inline">spawn</code> functions, instead they use abstractions such as <a href="https://hexdocs.pm/elixir/Task.html"><code class="inline">Task</code></a>, <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a> and <a href="https://hexdocs.pm/elixir/Agent.html"><code class="inline">Agent</code></a>, built on top of <code class="inline">spawn</code>, that spawns processes with more conveniences in terms of introspection and debugging.</p>
<p>Check the <a href="https://hexdocs.pm/elixir/Process.html"><code class="inline">Process</code></a> module for more process-related functions.</p>
<p>Inlined by the compiler.</p>
<h4 id="spawn_monitor/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">spawn_monitor(SomeModule, :function, [1, 2, 3])</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="struct/2">struct(struct, fields \\ [])</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">struct(module() | struct(), Enum.t()) :: struct()</pre> </div> <p>Creates and updates a struct.</p>
<p>The <code class="inline">struct</code> argument may be an atom (which defines <code class="inline">defstruct</code>) or a <code class="inline">struct</code> itself. The second argument is any <a href="https://hexdocs.pm/elixir/Enumerable.html"><code class="inline">Enumerable</code></a> that emits two-element tuples (key-value pairs) during enumeration.</p>
<p>Keys in the <a href="https://hexdocs.pm/elixir/Enumerable.html"><code class="inline">Enumerable</code></a> that don't exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct. If keys in the <a href="https://hexdocs.pm/elixir/Enumerable.html"><code class="inline">Enumerable</code></a> are duplicated, the last entry will be taken (same behaviour as <a href="https://hexdocs.pm/elixir/Map.html#new/1"><code class="inline">Map.new/1</code></a>).</p>
<p>This function is useful for dynamically creating and updating structs, as well as for converting maps to structs; in the latter case, just inserting the appropriate <code class="inline">:__struct__</code> field into the map may not be enough and <a href="#struct/2"><code class="inline">struct/2</code></a> should be used instead.</p>
<h4 id="struct/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule User do
  defstruct name: "john"
end

struct(User)
#=&gt; %User{name: "john"}

opts = [name: "meg"]
user = struct(User, opts)
#=&gt; %User{name: "meg"}

struct(user, unknown: "value")
#=&gt; %User{name: "meg"}

struct(User, %{name: "meg"})
#=&gt; %User{name: "meg"}

# String keys are ignored
struct(User, %{"name" =&gt; "meg"})
#=&gt; %User{name: "john"}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="struct!/2">struct!(struct, fields \\ [])</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">struct!(module() | struct(), Enum.t()) :: struct()</pre> </div> <p>Similar to <a href="#struct/2"><code class="inline">struct/2</code></a> but checks for key validity.</p>
<p>The function <a href="#struct!/2"><code class="inline">struct!/2</code></a> emulates the compile time behaviour of structs. This means that:</p>
<ul>
<li><p>when building a struct, as in <code class="inline">struct!(SomeStruct, key: :value)</code>, it is equivalent to <code class="inline">%SomeStruct{key: :value}</code> and therefore this function will check if every given key-value belongs to the struct. If the struct is enforcing any key via <code class="inline">@enforce_keys</code>, those will be enforced as well;</p></li>
<li><p>when updating a struct, as in <code class="inline">struct!(%SomeStruct{}, key: :value)</code>, it is equivalent to <code class="inline">%SomeStruct{struct | key: :value}</code> and therefore this function will check if every given key-value belongs to the struct. However, updating structs does not enforce keys, as keys are enforced only when building;</p></li>
</ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="throw/1">throw(term)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">throw(term()) :: no_return()</pre> </div> <p>A non-local return from a function.</p>
<p>Check <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#try/1"><code class="inline">Kernel.SpecialForms.try/1</code></a> for more information.</p>
<p>Inlined by the compiler.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_charlist/1">to_charlist(term)</h3> <section class="docstring"> <p>Converts the given term to a charlist according to the <a href="https://hexdocs.pm/elixir/List.Chars.html"><code class="inline">List.Chars</code></a> protocol.</p>
<h4 id="to_charlist/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; to_charlist(:foo)
'foo'</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_string/1">to_string(term)</h3> <section class="docstring"> <p>Converts the argument to a string according to the <a href="https://hexdocs.pm/elixir/String.Chars.html"><code class="inline">String.Chars</code></a> protocol.</p>
<p>This is the function invoked when there is string interpolation.</p>
<h4 id="to_string/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; to_string(:foo)
"foo"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="unless/2">unless(condition, clauses)</h3> <section class="docstring"> <p>Provides an <code class="inline">unless</code> macro.</p>
<p>This macro evaluates and returns the <code class="inline">do</code> block passed in as the second argument if <code class="inline">condition</code> evaluates to a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>). Otherwise, it returns the value of the <code class="inline">else</code> block if present or <code class="inline">nil</code> if not.</p>
<p>See also <a href="#if/2"><code class="inline">if/2</code></a>.</p>
<h4 id="unless/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; unless(Enum.empty?([]), do: "Hello")
nil

iex&gt; unless(Enum.empty?([1, 2, 3]), do: "Hello")
"Hello"

iex&gt; unless Enum.sum([2, 2]) == 5 do
...&gt;   "Math still works"
...&gt; else
...&gt;   "Math is broken"
...&gt; end
"Math still works"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="update_in/2">update_in(path, fun)</h3> <section class="docstring"> <p>Updates a nested structure via the given <code class="inline">path</code>.</p>
<p>This is similar to <a href="#update_in/3"><code class="inline">update_in/3</code></a>, except the path is extracted via a macro rather than passing a list. For example:</p>
<pre data-language="elixir">update_in(opts[:foo][:bar], &amp;(&amp;1 + 1))</pre>
<p>Is equivalent to:</p>
<pre data-language="elixir">update_in(opts, [:foo, :bar], &amp;(&amp;1 + 1))</pre>
<p>This also works with nested structs and the <code class="inline">struct.path.to.value</code> way to specify paths:</p>
<pre data-language="elixir">update_in(struct.foo.bar, &amp;(&amp;1 + 1))</pre>
<p>Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check <a href="#get_and_update_in/2"><code class="inline">get_and_update_in/2</code></a> docs.</p>
<h4 id="update_in/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; update_in(users["john"][:age], &amp;(&amp;1 + 1))
%{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}

iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; update_in(users["john"].age, &amp;(&amp;1 + 1))
%{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="update_in/3">update_in(data, keys, fun)</h3> <section class="docstring"> <h4>Specs</h4> <div class="specs"> <pre data-language="elixir">update_in(Access.t(), [term(), ...], (term() -&gt; term())) :: Access.t()</pre> </div> <p>Updates a key in a nested structure.</p>
<p>Uses the <a href="https://hexdocs.pm/elixir/Access.html"><code class="inline">Access</code></a> module to traverse the structures according to the given <code class="inline">keys</code>, unless the <code class="inline">key</code> is a function. If the key is a function, it will be invoked as specified in <a href="#get_and_update_in/3"><code class="inline">get_and_update_in/3</code></a>.</p>
<p><code class="inline">data</code> is a nested structure (that is, a map, keyword list, or struct that implements the <a href="https://hexdocs.pm/elixir/Access.html"><code class="inline">Access</code></a> behaviour). The <code class="inline">fun</code> argument receives the value of <code class="inline">key</code> (or <code class="inline">nil</code> if <code class="inline">key</code> is not present) and the result replaces the value in the structure.</p>
<h4 id="update_in/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; users = %{"john" =&gt; %{age: 27}, "meg" =&gt; %{age: 23}}
iex&gt; update_in(users, ["john", :age], &amp;(&amp;1 + 1))
%{"john" =&gt; %{age: 28}, "meg" =&gt; %{age: 23}}</pre>
<p>In case any of the entries in the middle returns <code class="inline">nil</code>, an error will be raised when trying to access it next.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="use/2">use(module, opts \\ [])</h3> <section class="docstring"> <p>Uses the given module in the current context.</p>
<p>When calling:</p>
<pre data-language="elixir">use MyModule, some: :options</pre>
<p>the <code class="inline">__using__/1</code> macro from the <code class="inline">MyModule</code> module is invoked with the second argument passed to <code class="inline">use</code> as its argument. Since <code class="inline">__using__/1</code> is a macro, all the usual macro rules apply, and its return value should be quoted code that is then inserted where <a href="#use/2"><code class="inline">use/2</code></a> is called.</p>
<h4 id="use/2-examples" class="section-heading">  Examples </h4> <p>For example, to write test cases using the <a href="https://hexdocs.pm/ex_unit/ExUnit.html"><code class="inline">ExUnit</code></a> framework provided with Elixir, a developer should <code class="inline">use</code> the <a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html"><code class="inline">ExUnit.Case</code></a> module:</p>
<pre data-language="elixir">defmodule AssertionTest do
  use ExUnit.Case, async: true

  test "always pass" do
    assert true
  end
end</pre>
<p>In this example, Elixir will call the <code class="inline">__using__/1</code> macro in the <a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html"><code class="inline">ExUnit.Case</code></a> module with the keyword list <code class="inline">[async: true]</code> as its argument.</p>
<p>In other words, <a href="#use/2"><code class="inline">use/2</code></a> translates to:</p>
<pre data-language="elixir">defmodule AssertionTest do
  require ExUnit.Case
  ExUnit.Case.__using__(async: true)

  test "always pass" do
    assert true
  end
end</pre>
<p>where <a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html"><code class="inline">ExUnit.Case</code></a> defines the <code class="inline">__using__/1</code> macro:</p>
<pre data-language="elixir">defmodule ExUnit.Case do
  defmacro __using__(opts) do
    # do something with opts
    quote do
      # return some code to inject in the caller
    end
  end
end</pre>
<h4 id="use/2-best-practices" class="section-heading">  Best practices </h4> <p><code class="inline">__using__/1</code> is typically used when there is a need to set some state (via module attributes) or callbacks (like <code class="inline">@before_compile</code>, see the documentation for <a href="https://hexdocs.pm/elixir/Module.html"><code class="inline">Module</code></a> for more information) into the caller.</p>
<p><code class="inline">__using__/1</code> may also be used to alias, require, or import functionality from different modules:</p>
<pre data-language="elixir">defmodule MyModule do
  defmacro __using__(_opts) do
    quote do
      import MyModule.Foo
      import MyModule.Bar
      import MyModule.Baz

      alias MyModule.Repo
    end
  end
end</pre>
<p>However, do not provide <code class="inline">__using__/1</code> if all it does is to import, alias or require the module itself. For example, avoid this:</p>
<pre data-language="elixir">defmodule MyModule do
  defmacro __using__(_opts) do
    quote do
      import MyModule
    end
  end
end</pre>
<p>In such cases, developers should instead import or alias the module directly, so that they can customize those as they wish, without the indirection behind <a href="#use/2"><code class="inline">use/2</code></a>.</p>
<p>Finally, developers should also avoid defining functions inside the <code class="inline">__using__/1</code> callback, unless those functions are the default implementation of a previously defined <code class="inline">@callback</code> or are functions meant to be overridden (see <a href="#defoverridable/1"><code class="inline">defoverridable/1</code></a>). Even in these cases, defining functions should be seen as a "last resort".</p>
<p>In case you want to provide some existing functionality to the user module, please define it in a module which will be imported accordingly; for example, <a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html"><code class="inline">ExUnit.Case</code></a> doesn't define the <code class="inline">test/3</code> macro in the module that calls <code class="inline">use ExUnit.Case</code>, but it defines <a href="https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3"><code class="inline">ExUnit.Case.test/3</code></a> and just imports that into the caller when used.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="var!/2">var!(var, context \\ nil)</h3> <section class="docstring"> <p>Marks that the given variable should not be hygienized.</p>
<p>This macro expects a variable and it is typically invoked inside <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2"><code class="inline">Kernel.SpecialForms.quote/2</code></a> to mark that a variable should not be hygienized. See <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2"><code class="inline">Kernel.SpecialForms.quote/2</code></a> for more information.</p>
<h4 id="var!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Kernel.var!(example) = 1
1
iex&gt; Kernel.var!(example)
1</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.11.2/Kernel.html" class="_attribution-link">https://hexdocs.pm/elixir/1.11.2/Kernel.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
