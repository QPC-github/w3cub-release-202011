
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Typespecs and Behaviours - Elixir 1.11 - W3cubDocs</title>
  
  <meta name="description" content="Elixir is a dynamically typed language, so all types in Elixir are checked at runtime. Nonetheless, Elixir comes with typespecs, which are a &hellip;">
  <meta name="keywords" content="typespecs, and, behaviours, elixir, elixir~1.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/elixir~1.11/typespecs-and-behaviours.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/elixir~1.11.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.11/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<div class="getting-started-title"> <small>Getting Started</small> <h1>Typespecs and behaviours</h1> </div>  <h2 id="types-and-specs">Types and specs</h2> <p>Elixir is a dynamically typed language, so all types in Elixir are checked at runtime. Nonetheless, Elixir comes with <strong>typespecs</strong>, which are a notation used for:</p> <ol> <li>declaring typed function signatures (also called specifications);</li> <li>declaring custom types.</li> </ol> <h3 id="function-specifications">Function specifications</h3> <p>Elixir provides many <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">built-in types</a>, such as <code class="language-plaintext highlighter-rouge">integer</code> or <code class="language-plaintext highlighter-rouge">pid</code>, that can be used to document function signatures. For example, the <code class="language-plaintext highlighter-rouge">round/1</code> function, which rounds a number to its nearest integer. As you can see <a href="https://hexdocs.pm/elixir/Kernel.html#round/1">in its documentation</a>, <code class="language-plaintext highlighter-rouge">round/1</code>’s typed signature is written as:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">round(number()) :: integer()
</pre></div> <p>The syntax is to put the function and its input on the left side of the <code class="language-plaintext highlighter-rouge">::</code> and the return value’s type on the right side. Be aware that types <em>may</em> omit parentheses.</p> <p>In code, function specs are written with the <code class="language-plaintext highlighter-rouge">@spec</code> attribute, typically placed immediately before the function definition. Specs can describe both public and private functions. The function name and the number of arguments used in the <code class="language-plaintext highlighter-rouge">@spec</code> attribute must match the function it describes.</p> <p>Elixir supports compound types as well. For example, a list of integers has type <code class="language-plaintext highlighter-rouge">[integer]</code>, or maps that define keys and types (see the example below).</p> <p>You can see all the built-in types provided by Elixir <a href="https://hexdocs.pm/elixir/typespecs.html">in the typespecs docs</a>.</p> <h3 id="defining-custom-types">Defining custom types</h3> <p>Defining custom types can help communicate the intention of your code and increase its readability. Custom types can be defined within modules via the <code class="language-plaintext highlighter-rouge">@type</code> attribute.</p> <p>A simple example of a custom type implementation is to provide a more descriptive alias of an existing type. For example, defining <code class="language-plaintext highlighter-rouge">year</code> as a type makes your function specs more descriptive than if they had simply used <code class="language-plaintext highlighter-rouge">integer</code>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Person do
   @typedoc """
   A 4 digit year, e.g. 1984
   """
   @type year :: integer
   
   @spec current_age(year) :: integer
   def current_age(year_of_birth), do: # implementation
end
</pre></div> <p>The <code class="language-plaintext highlighter-rouge">@typedoc</code> attribute, similar to the <code class="language-plaintext highlighter-rouge">@doc</code> and <code class="language-plaintext highlighter-rouge">@moduledoc</code> attributes, is used to document custom types.</p> <p>You may define compound custom types, e.g. maps:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">@type error_map :: %{
   message: String.t,
   line_number: integer
}
</pre></div> <p><a href="structs">Structs</a> offer similar functionality.</p> <p>Let’s look at another example to understand how to define more complex types. Say we have a <code class="language-plaintext highlighter-rouge">LousyCalculator</code> module, which performs the usual arithmetic operations (sum, product, and so on) but, instead of returning numbers, it returns tuples with the result of an operation as the first element and a random remark as the second element.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule LousyCalculator do
  @spec add(number, number) :: {number, String.t}
  def add(x, y), do: {x + y, "You need a calculator to do that?!"}

  @spec multiply(number, number) :: {number, String.t}
  def multiply(x, y), do: {x * y, "Jeez, come on!"}
end
</pre></div> <p>Tuples are a compound type and each tuple is identified by the types inside it (in this case, a number and a string). To understand why <code class="language-plaintext highlighter-rouge">String.t</code> is not written as <code class="language-plaintext highlighter-rouge">string</code>, have another look at the <a href="https://hexdocs.pm/elixir/typespecs.html#the-string-type">typespecs docs</a>.</p> <p>Defining function specs this way works, but we end up repeating the type <code class="language-plaintext highlighter-rouge">{number, String.t}</code> over and over. We can use the <code class="language-plaintext highlighter-rouge">@type</code> attribute to declare our own custom type and cut down on the repetition.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule LousyCalculator do
  @typedoc """
  Just a number followed by a string.
  """
  @type number_with_remark :: {number, String.t}

  @spec add(number, number) :: number_with_remark
  def add(x, y), do: {x + y, "You need a calculator to do that?"}

  @spec multiply(number, number) :: number_with_remark
  def multiply(x, y), do: {x * y, "It is like addition on steroids."}
end
</pre></div> <p>Custom types defined through <code class="language-plaintext highlighter-rouge">@type</code> are exported and are available outside the module they’re defined in:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule QuietCalculator do
  @spec add(number, number) :: number
  def add(x, y), do: make_quiet(LousyCalculator.add(x, y))

  @spec make_quiet(LousyCalculator.number_with_remark) :: number
  defp make_quiet({num, _remark}), do: num
end
</pre></div> <p>If you want to keep a custom type private, you can use the <code class="language-plaintext highlighter-rouge">@typep</code> attribute instead of <code class="language-plaintext highlighter-rouge">@type</code>. The visibility also affects whether or not documentation will be generated by tools like <a href="https://hexdocs.pm/ex_doc/readme.html">ExDoc</a>, Elixir’s documentation generator.</p> <h3 id="static-code-analysis">Static code analysis</h3> <p>Typespecs are not only useful to developers as additional documentation. The Erlang tool <a href="http://www.erlang.org/doc/man/dialyzer.html">Dialyzer</a>, for example, uses typespecs in order to perform static analysis of code. That’s why, in the <code class="language-plaintext highlighter-rouge">QuietCalculator</code> example, we wrote a spec for the <code class="language-plaintext highlighter-rouge">make_quiet/1</code> function even though it was defined as a private function.</p> <h2 id="behaviours">Behaviours</h2> <p>Many modules share the same public API. Take a look at <a href="https://github.com/elixir-lang/plug">Plug</a>, which, as its description states, is a <strong>specification</strong> for composable modules in web applications. Each <em>plug</em> is a module which <strong>has to</strong> implement at least two public functions: <code class="language-plaintext highlighter-rouge">init/1</code> and <code class="language-plaintext highlighter-rouge">call/2</code>.</p> <p>Behaviours provide a way to:</p> <ul> <li>define a set of functions that have to be implemented by a module;</li> <li>ensure that a module implements all the functions in that set.</li> </ul> <p>If you have to, you can think of behaviours like interfaces in object oriented languages like Java: a set of function signatures that a module has to implement.</p> <h3 id="defining-behaviours">Defining behaviours</h3> <p>Say we want to implement a bunch of parsers, each parsing structured data: for example, a JSON parser and a MessagePack parser. Each of these two parsers will <em>behave</em> the same way: both will provide a <code class="language-plaintext highlighter-rouge">parse/1</code> function and an <code class="language-plaintext highlighter-rouge">extensions/0</code> function. The <code class="language-plaintext highlighter-rouge">parse/1</code> function will return an Elixir representation of the structured data, while the <code class="language-plaintext highlighter-rouge">extensions/0</code> function will return a list of file extensions that can be used for each type of data (e.g., <code class="language-plaintext highlighter-rouge">.json</code> for JSON files).</p> <p>We can create a <code class="language-plaintext highlighter-rouge">Parser</code> behaviour:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Parser do
  @callback parse(String.t) :: {:ok, term} | {:error, String.t}
  @callback extensions() :: [String.t]
end
</pre></div> <p>Modules adopting the <code class="language-plaintext highlighter-rouge">Parser</code> behaviour will have to implement all the functions defined with the <code class="language-plaintext highlighter-rouge">@callback</code> attribute. As you can see, <code class="language-plaintext highlighter-rouge">@callback</code> expects a function name but also a function specification like the ones used with the <code class="language-plaintext highlighter-rouge">@spec</code> attribute we saw above. Also note that the <code class="language-plaintext highlighter-rouge">term</code> type is used to represent the parsed value. In Elixir, the <code class="language-plaintext highlighter-rouge">term</code> type is a shortcut to represent any type.</p> <h3 id="adopting-behaviours">Adopting behaviours</h3> <p>Adopting a behaviour is straightforward:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule JSONParser do
  @behaviour Parser

  @impl Parser
  def parse(str), do: {:ok, "some json " &lt;&gt; str} # ... parse JSON
  
  @impl Parser
  def extensions, do: ["json"]
end
</pre></div> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule YAMLParser do
  @behaviour Parser

  @impl Parser
  def parse(str), do: {:ok, "some yaml " &lt;&gt; str} # ... parse YAML
  
  @impl Parser
  def extensions, do: ["yml"]
end
</pre></div> <p>If a module adopting a given behaviour doesn’t implement one of the callbacks required by that behaviour, a compile-time warning will be generated.</p> <p>Furthermore, with <code class="language-plaintext highlighter-rouge">@impl</code> you can also make sure that you are implementing the <strong>correct</strong> callbacks from the given behaviour in an explicit manner. For example, the following parser implements both <code class="language-plaintext highlighter-rouge">parse</code> and <code class="language-plaintext highlighter-rouge">extensions</code>, however thanks to a typo, <code class="language-plaintext highlighter-rouge">BADParser</code> is implementing <code class="language-plaintext highlighter-rouge">parse/0</code> instead of <code class="language-plaintext highlighter-rouge">parse/1</code>.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule BADParser do
  @behaviour Parser

  @impl Parser
  def parse, do: {:ok, "something bad"}
  
  @impl Parser
  def extensions, do: ["bad"]
end
</pre></div> <p>This code generates a warning letting you know that you are mistakenly implementing <code class="language-plaintext highlighter-rouge">parse/0</code> instead of <code class="language-plaintext highlighter-rouge">parse/1</code>. You can read more about <code class="language-plaintext highlighter-rouge">@impl</code> in the <a href="https://hexdocs.pm/elixir/master/Module.html#module-impl">module documentation</a>.</p> <h3 id="dynamic-dispatch">Dynamic dispatch</h3> <p>Behaviours are frequently used with dynamic dispatching. For example, we could add a <code class="language-plaintext highlighter-rouge">parse!</code> function to the <code class="language-plaintext highlighter-rouge">Parser</code> module that dispatches to the given implementation and returns the <code class="language-plaintext highlighter-rouge">:ok</code> result or raises in cases of <code class="language-plaintext highlighter-rouge">:error</code>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Parser do
  @callback parse(String.t) :: {:ok, term} | {:error, String.t}
  @callback extensions() :: [String.t]

  def parse!(implementation, contents) do
    case implementation.parse(contents) do
      {:ok, data} -&gt; data
      {:error, error} -&gt; raise ArgumentError, "parsing error: #{error}"
    end
  end
end
</pre></div> <p>Note you don’t need to define a behaviour in order to dynamically dispatch on a module, but those features often go hand in hand.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://elixir-lang.org/getting-started/typespecs-and-behaviours.html" class="_attribution-link">https://elixir-lang.org/getting-started/typespecs-and-behaviours.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
