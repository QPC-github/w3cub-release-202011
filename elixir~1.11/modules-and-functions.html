
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Modules and Functions - Elixir 1.11 - W3cubDocs</title>
  
  <meta name="description" content=" In Elixir we group several functions into modules. We’ve already used many different modules in the previous chapters such as the String module&#58; ">
  <meta name="keywords" content="modules, and, functions, elixir, elixir~1.11">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/elixir~1.11/modules-and-functions.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/elixir~1.11.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.11/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.11</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<div class="getting-started-title"> <small>Getting Started</small> <h1>Modules and functions</h1> </div>  <p>In Elixir we group several functions into modules. We’ve already used many different modules in the previous chapters such as <a href="https://hexdocs.pm/elixir/String.html">the <code class="language-plaintext highlighter-rouge">String</code> module</a>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; String.length("hello")
5
</pre></div> <p>In order to create our own modules in Elixir, we use the <code class="language-plaintext highlighter-rouge">defmodule</code> macro. We use the <code class="language-plaintext highlighter-rouge">def</code> macro to define functions in that module:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; defmodule Math do
...&gt;   def sum(a, b) do
...&gt;     a + b
...&gt;   end
...&gt; end

iex&gt; Math.sum(1, 2)
3
</pre></div> <p>In the following sections, our examples are going to get longer in size, and it can be tricky to type them all in the shell. It’s about time for us to learn how to compile Elixir code and also how to run Elixir scripts.</p> <h2 id="compilation">Compilation</h2> <p>Most of the time it is convenient to write modules into files so they can be compiled and reused. Let’s assume we have a file named <code class="language-plaintext highlighter-rouge">math.ex</code> with the following contents:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Math do
  def sum(a, b) do
    a + b
  end
end
</pre></div> <p>This file can be compiled using <code class="language-plaintext highlighter-rouge">elixirc</code>:</p> <div class="language-console highlighter-rouge"><pre class="highlight" data-language="">$ elixirc math.ex
</pre></div> <p>This will generate a file named <code class="language-plaintext highlighter-rouge">Elixir.Math.beam</code> containing the bytecode for the defined module. If we start <code class="language-plaintext highlighter-rouge">iex</code> again, our module definition will be available (provided that <code class="language-plaintext highlighter-rouge">iex</code> is started in the same directory the bytecode file is in):</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; Math.sum(1, 2)
3
</pre></div> <p>Elixir projects are usually organized into three directories:</p> <ul> <li>ebin - contains the compiled bytecode</li> <li>lib - contains elixir code (usually <code class="language-plaintext highlighter-rouge">.ex</code> files)</li> <li>test - contains tests (usually <code class="language-plaintext highlighter-rouge">.exs</code> files)</li> </ul> <p>When working on actual projects, the build tool called <code class="language-plaintext highlighter-rouge">mix</code> will be responsible for compiling and setting up the proper paths for you. For learning purposes, Elixir also supports a scripted mode which is more flexible and does not generate any compiled artifacts.</p> <h2 id="scripted-mode">Scripted mode</h2> <p>In addition to the Elixir file extension <code class="language-plaintext highlighter-rouge">.ex</code>, Elixir also supports <code class="language-plaintext highlighter-rouge">.exs</code> files for scripting. Elixir treats both files exactly the same way, the only difference is in intention. <code class="language-plaintext highlighter-rouge">.ex</code> files are meant to be compiled while <code class="language-plaintext highlighter-rouge">.exs</code> files are used for scripting. When executed, both extensions compile and load their modules into memory, although only <code class="language-plaintext highlighter-rouge">.ex</code> files write their bytecode to disk in the format of <code class="language-plaintext highlighter-rouge">.beam</code> files.</p> <p>For instance, we can create a file called <code class="language-plaintext highlighter-rouge">math.exs</code>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Math do
  def sum(a, b) do
    a + b
  end
end

IO.puts Math.sum(1, 2)
</pre></div> <p>And execute it as:</p> <div class="language-console highlighter-rouge"><pre class="highlight" data-language="">$ elixir math.exs
</pre></div> <p>The file will be compiled in memory and executed, printing “3” as the result. No bytecode file will be created. In the following examples, we recommend you write your code into script files and execute them as shown above.</p> <h2 id="named-functions">Named functions</h2> <p>Inside a module, we can define functions with <code class="language-plaintext highlighter-rouge">def/2</code> and private functions with <code class="language-plaintext highlighter-rouge">defp/2</code>. A function defined with <code class="language-plaintext highlighter-rouge">def/2</code> can be invoked from other modules while a private function can only be invoked locally.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Math do
  def sum(a, b) do
    do_sum(a, b)
  end

  defp do_sum(a, b) do
    a + b
  end
end

IO.puts Math.sum(1, 2)    #=&gt; 3
IO.puts Math.do_sum(1, 2) #=&gt; ** (UndefinedFunctionError)
</pre></div> <p>Function declarations also support guards and multiple clauses. If a function has several clauses, Elixir will try each clause until it finds one that matches. Here is an implementation of a function that checks if the given number is zero or not:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Math do
  def zero?(0) do
    true
  end

  def zero?(x) when is_integer(x) do
    false
  end
end

IO.puts Math.zero?(0)         #=&gt; true
IO.puts Math.zero?(1)         #=&gt; false
IO.puts Math.zero?([1, 2, 3]) #=&gt; ** (FunctionClauseError)
IO.puts Math.zero?(0.0)       #=&gt; ** (FunctionClauseError)
</pre></div> <p><em>The trailing question mark in <code class="language-plaintext highlighter-rouge">zero?</code> means that this function returns a boolean; see <a href="https://hexdocs.pm/elixir/master/naming-conventions.html#trailing-question-mark-foo">Naming Conventions</a>.</em></p> <p>Giving an argument that does not match any of the clauses raises an error.</p> <p>Similar to constructs like <code class="language-plaintext highlighter-rouge">if</code>, named functions support both <code class="language-plaintext highlighter-rouge">do:</code> and <code class="language-plaintext highlighter-rouge">do</code>/<code class="language-plaintext highlighter-rouge">end</code> block syntax, as <a href="case-cond-and-if#doend-blocks">we learned <code class="language-plaintext highlighter-rouge">do</code>/<code class="language-plaintext highlighter-rouge">end</code> is a convenient syntax for the keyword list format</a>. For example, we can edit <code class="language-plaintext highlighter-rouge">math.exs</code> to look like this:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Math do
  def zero?(0), do: true
  def zero?(x) when is_integer(x), do: false
end
</pre></div> <p>And it will provide the same behaviour. You may use <code class="language-plaintext highlighter-rouge">do:</code> for one-liners but always use <code class="language-plaintext highlighter-rouge">do</code>/<code class="language-plaintext highlighter-rouge">end</code> for functions spanning multiple lines.</p> <h2 id="function-capturing">Function capturing</h2> <p>Throughout this tutorial, we have been using the notation <code class="language-plaintext highlighter-rouge">name/arity</code> to refer to functions. It happens that this notation can actually be used to retrieve a named function as a function type. Start <code class="language-plaintext highlighter-rouge">iex</code>, running the <code class="language-plaintext highlighter-rouge">math.exs</code> file defined above:</p> <div class="language-console highlighter-rouge"><pre class="highlight" data-language="">$ iex math.exs
</pre></div> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; Math.zero?(0)
true
iex&gt; fun = &amp;Math.zero?/1
&amp;Math.zero?/1
iex&gt; is_function(fun)
true
iex&gt; fun.(0)
true
</pre></div> <p>Remember Elixir makes a distinction between anonymous functions and named functions, where the former must be invoked with a dot (<code class="language-plaintext highlighter-rouge">.</code>) between the variable name and parentheses. The capture operator bridges this gap by allowing named functions to be assigned to variables and passed as arguments in the same way we assign, invoke and pass anonymous functions.</p> <p>Local or imported functions, like <code class="language-plaintext highlighter-rouge">is_function/1</code>, can be captured without the module:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; &amp;is_function/1
&amp;:erlang.is_function/1
iex&gt; (&amp;is_function/1).(fun)
true
</pre></div> <p>Note the capture syntax can also be used as a shortcut for creating functions:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; fun = &amp;(&amp;1 + 1)
#Function&lt;6.71889879/1 in :erl_eval.expr/5&gt;
iex&gt; fun.(1)
2

iex&gt; fun2 = &amp;"Good #{&amp;1}"
#Function&lt;6.127694169/1 in :erl_eval.expr/5&gt;
iex)&gt; fun2.("morning")
"Good morning"
</pre></div> <p>The <code class="language-plaintext highlighter-rouge">&amp;1</code> represents the first argument passed into the function. <code class="language-plaintext highlighter-rouge">&amp;(&amp;1 + 1)</code> above is exactly the same as <code class="language-plaintext highlighter-rouge">fn x -&gt; x + 1 end</code>. The syntax above is useful for short function definitions.</p> <p>If you want to capture a function from a module, you can do <code class="language-plaintext highlighter-rouge">&amp;Module.function()</code>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; fun = &amp;List.flatten(&amp;1, &amp;2)
&amp;List.flatten/2
iex&gt; fun.([1, [[2], 3]], [4, 5])
[1, 2, 3, 4, 5]
</pre></div> <p><code class="language-plaintext highlighter-rouge">&amp;List.flatten(&amp;1, &amp;2)</code> is the same as writing <code class="language-plaintext highlighter-rouge">fn(list, tail) -&gt; List.flatten(list, tail) end</code> which in this case is equivalent to <code class="language-plaintext highlighter-rouge">&amp;List.flatten/2</code>. You can read more about the capture operator <code class="language-plaintext highlighter-rouge">&amp;</code> in <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#&amp;/1">the <code class="language-plaintext highlighter-rouge">Kernel.SpecialForms</code> documentation</a>.</p> <h2 id="default-arguments">Default arguments</h2> <p>Named functions in Elixir also support default arguments:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Concat do
  def join(a, b, sep \\ " ") do
    a &lt;&gt; sep &lt;&gt; b
  end
end

IO.puts Concat.join("Hello", "world")      #=&gt; Hello world
IO.puts Concat.join("Hello", "world", "_") #=&gt; Hello_world
</pre></div> <p>Any expression is allowed to serve as a default value, but it won’t be evaluated during the function definition. Every time the function is invoked and any of its default values have to be used, the expression for that default value will be evaluated:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule DefaultTest do
  def dowork(x \\ "hello") do
    x
  end
end
</pre></div> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; DefaultTest.dowork
"hello"
iex&gt; DefaultTest.dowork 123
123
iex&gt; DefaultTest.dowork
"hello"
</pre></div> <p>If a function with default values has multiple clauses, it is required to create a function head (without an actual body) for declaring defaults:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Concat do
  # A function head declaring defaults
  def join(a, b \\ nil, sep \\ " ")

  def join(a, b, _sep) when is_nil(b) do
    a
  end

  def join(a, b, sep) do
    a &lt;&gt; sep &lt;&gt; b
  end
end

IO.puts Concat.join("Hello", "world")      #=&gt; Hello world
IO.puts Concat.join("Hello", "world", "_") #=&gt; Hello_world
IO.puts Concat.join("Hello")               #=&gt; Hello
</pre></div> <p><em>The leading underscore in <code class="language-plaintext highlighter-rouge">_sep</code> means that the variable will be ignored in this function; see <a href="https://hexdocs.pm/elixir/master/naming-conventions.html#underscore-_foo">Naming Conventions</a>.</em></p> <p>When using default values, one must be careful to avoid overlapping function definitions. Consider the following example:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Concat do
  def join(a, b) do
    IO.puts "***First join"
    a &lt;&gt; b
  end

  def join(a, b, sep \\ " ") do
    IO.puts "***Second join"
    a &lt;&gt; sep &lt;&gt; b
  end
end
</pre></div> <p>If we save the code above in a file named “concat.ex” and compile it, Elixir will emit the following warning:</p> <div class="language-plaintext highlighter-rouge"><pre class="highlight" data-language="">warning: this clause cannot match because a previous clause at line 2 always matches
</pre></div> <p>The compiler is telling us that invoking the <code class="language-plaintext highlighter-rouge">join</code> function with two arguments will always choose the first definition of <code class="language-plaintext highlighter-rouge">join</code> whereas the second one will only be invoked when three arguments are passed:</p> <div class="language-console highlighter-rouge"><pre class="highlight" data-language="">$ iex concat.ex
</pre></div> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; Concat.join "Hello", "world"
***First join
"Helloworld"
</pre></div> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; Concat.join "Hello", "world", "_"
***Second join
"Hello_world"
</pre></div> <p>This finishes our short introduction to modules. In the next chapters, we will learn how to use named functions for recursion, explore Elixir lexical directives that can be used for importing functions from other modules and discuss module attributes.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://elixir-lang.org/getting-started/modules-and-functions" class="_attribution-link">https://elixir-lang.org/getting-started/modules-and-functions</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
