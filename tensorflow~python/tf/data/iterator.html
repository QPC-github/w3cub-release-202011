
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>tf.data.Iterator - TensorFlow Python - W3cubDocs</title>
  
  <meta name="description" content=" Defined in tensorflow&#47;python&#47;data&#47;ops&#47;iterator_ops.py. ">
  <meta name="keywords" content="tf, data, iterator, tensorflow, python, tensorflow~python">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow~python/tf/data/iterator.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/tensorflow~python.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~python/" class="_nav-link" title="" style="margin-left:0;">TensorFlow Python</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<h1 itemprop="name" class="devsite-page-title"> tf.data.Iterator </h1>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.data.Iterator"> <meta itemprop="path" content="r1.8"> <meta itemprop="property" content="initializer"> <meta itemprop="property" content="output_classes"> <meta itemprop="property" content="output_shapes"> <meta itemprop="property" content="output_types"> <meta itemprop="property" content="__init__"> <meta itemprop="property" content="from_string_handle"> <meta itemprop="property" content="from_structure"> <meta itemprop="property" content="get_next"> <meta itemprop="property" content="make_initializer"> <meta itemprop="property" content="string_handle"> </div> <h2 id="class_iterator">Class <code>Iterator</code>
</h2> <p>Defined in <a href="https://www.github.com/tensorflow/tensorflow/blob/r1.8/tensorflow/python/data/ops/iterator_ops.py"><code>tensorflow/python/data/ops/iterator_ops.py</code></a>.</p> <p>See the guide: <a href="https://www.tensorflow.org/api_guides/python/input_dataset#Iterating_over_datasets">Dataset Input Pipeline &gt; Iterating over datasets</a></p> <p>Represents the state of iterating through a <code>Dataset</code>.</p> <h2 id="properties">Properties</h2> <h3 id="initializer"><code>initializer</code></h3> <p>A <a href="../operation"><code>tf.Operation</code></a> that should be run to initialize this iterator.</p> <h4 id="returns">Returns:</h4> <p>A <a href="../operation"><code>tf.Operation</code></a> that should be run to initialize this iterator</p> <h4 id="raises">Raises:</h4> <ul> <li>
<b><code>ValueError</code></b>: If this iterator initializes itself automatically.</li> </ul> <h3 id="output_classes"><code>output_classes</code></h3> <p>Returns the class of each component of an element of this iterator.</p> <p>The expected values are <a href="../tensor"><code>tf.Tensor</code></a> and <a href="../sparsetensor"><code>tf.SparseTensor</code></a>.</p> <h4 id="returns_1">Returns:</h4> <p>A nested structure of Python <code>type</code> objects corresponding to each component of an element of this dataset.</p> <h3 id="output_shapes"><code>output_shapes</code></h3> <p>Returns the shape of each component of an element of this iterator.</p> <h4 id="returns_2">Returns:</h4> <p>A nested structure of <a href="../tensorshape"><code>tf.TensorShape</code></a> objects corresponding to each component of an element of this dataset.</p> <h3 id="output_types"><code>output_types</code></h3> <p>Returns the type of each component of an element of this iterator.</p> <h4 id="returns_3">Returns:</h4> <p>A nested structure of <a href="../dtype"><code>tf.DType</code></a> objects corresponding to each component of an element of this dataset.</p> <h2 id="methods">Methods</h2> <h3 id="__init__"><code>__init__</code></h3> <pre class="prettyprint lang-python" data-language="python">__init__(
    iterator_resource,
    initializer,
    output_types,
    output_shapes,
    output_classes
)
</pre> <p>Creates a new iterator from the given iterator resource.</p> <blockquote class="note">
<strong>Note:</strong><span> Most users will not call this initializer directly, and will instead use <code>Dataset.make_initializable_iterator()</code> or <code>Dataset.make_one_shot_iterator()</code>.</span>
</blockquote> <h4 id="args">Args:</h4> <ul> <li>
<b><code>iterator_resource</code></b>: A <a href="../resource"><code>tf.resource</code></a> scalar <a href="../tensor"><code>tf.Tensor</code></a> representing the iterator.</li> <li>
<b><code>initializer</code></b>: A <a href="../operation"><code>tf.Operation</code></a> that should be run to initialize this iterator.</li> <li>
<b><code>output_types</code></b>: A nested structure of <a href="../dtype"><code>tf.DType</code></a> objects corresponding to each component of an element of this dataset.</li> <li>
<b><code>output_shapes</code></b>: A nested structure of <a href="../tensorshape"><code>tf.TensorShape</code></a> objects corresponding to each component of an element of this dataset.</li> <li>
<b><code>output_classes</code></b>: A nested structure of Python <code>type</code> object corresponding to each component of an element of this iterator.</li> </ul> <h3 id="from_string_handle"><code>from_string_handle</code></h3> <pre class="prettyprint lang-python" data-language="python">@staticmethod
from_string_handle(
    string_handle,
    output_types,
    output_shapes=None,
    output_classes=None
)
</pre> <p>Creates a new, uninitialized <code>Iterator</code> based on the given handle.</p> <p>This method allows you to define a "feedable" iterator where you can choose between concrete iterators by feeding a value in a <a href="../interactivesession#run"><code>tf.Session.run</code></a> call. In that case, <code>string_handle</code> would a <a href="../placeholder"><code>tf.placeholder</code></a>, and you would feed it with the value of <a href="iterator#string_handle"><code>tf.data.Iterator.string_handle</code></a> in each step.</p> <p>For example, if you had two iterators that marked the current position in a training dataset and a test dataset, you could choose which to use in each step as follows:</p> <pre class="prettyprint lang-python" data-language="python">train_iterator = tf.data.Dataset(...).make_one_shot_iterator()
train_iterator_handle = sess.run(train_iterator.string_handle())

test_iterator = tf.data.Dataset(...).make_one_shot_iterator()
test_iterator_handle = sess.run(test_iterator.string_handle())

handle = tf.placeholder(tf.string, shape=[])
iterator = tf.data.Iterator.from_string_handle(
    handle, train_iterator.output_types)

next_element = iterator.get_next()
loss = f(next_element)

train_loss = sess.run(loss, feed_dict={handle: train_iterator_handle})
test_loss = sess.run(loss, feed_dict={handle: test_iterator_handle})
</pre> <h4 id="args_1">Args:</h4> <ul> <li>
<b><code>string_handle</code></b>: A scalar <a href="../tensor"><code>tf.Tensor</code></a> of type <a href="../string"><code>tf.string</code></a> that evaluates to a handle produced by the <code>Iterator.string_handle()</code> method.</li> <li>
<b><code>output_types</code></b>: A nested structure of <a href="../dtype"><code>tf.DType</code></a> objects corresponding to each component of an element of this dataset.</li> <li>
<b><code>output_shapes</code></b>: (Optional.) A nested structure of <a href="../tensorshape"><code>tf.TensorShape</code></a> objects corresponding to each component of an element of this dataset. If omitted, each component will have an unconstrainted shape.</li> <li>
<b><code>output_classes</code></b>: (Optional.) A nested structure of Python <code>type</code> objects corresponding to each component of an element of this iterator. If omitted, each component is assumed to be of type <a href="../tensor"><code>tf.Tensor</code></a>.</li> </ul> <h4 id="returns_4">Returns:</h4> <p>An <code>Iterator</code>.</p> <h3 id="from_structure"><code>from_structure</code></h3> <pre class="prettyprint lang-python" data-language="python">@staticmethod
from_structure(
    output_types,
    output_shapes=None,
    shared_name=None,
    output_classes=None
)
</pre> <p>Creates a new, uninitialized <code>Iterator</code> with the given structure.</p> <p>This iterator-constructing method can be used to create an iterator that is reusable with many different datasets.</p> <p>The returned iterator is not bound to a particular dataset, and it has no <code>initializer</code>. To initialize the iterator, run the operation returned by <code>Iterator.make_initializer(dataset)</code>.</p> <p>The following is an example</p> <pre class="prettyprint lang-python" data-language="python">iterator = Iterator.from_structure(tf.int64, tf.TensorShape([]))

dataset_range = Dataset.range(10)
range_initializer = iterator.make_initializer(dataset_range)

dataset_evens = dataset_range.filter(lambda x: x % 2 == 0)
evens_initializer = iterator.make_initializer(dataset_evens)

# Define a model based on the iterator; in this example, the model_fn
# is expected to take scalar tf.int64 Tensors as input (see
# the definition of 'iterator' above).
prediction, loss = model_fn(iterator.get_next())

# Train for `num_epochs`, where for each epoch, we first iterate over
# dataset_range, and then iterate over dataset_evens.
for _ in range(num_epochs):
  # Initialize the iterator to `dataset_range`
  sess.run(range_initializer)
  while True:
    try:
      pred, loss_val = sess.run([prediction, loss])
    except tf.errors.OutOfRangeError:
      break

  # Initialize the iterator to `dataset_evens`
  sess.run(evens_initializer)
  while True:
    try:
      pred, loss_val = sess.run([prediction, loss])
    except tf.errors.OutOfRangeError:
      break
</pre> <h4 id="args_2">Args:</h4> <ul> <li>
<b><code>output_types</code></b>: A nested structure of <a href="../dtype"><code>tf.DType</code></a> objects corresponding to each component of an element of this dataset.</li> <li>
<b><code>output_shapes</code></b>: (Optional.) A nested structure of <a href="../tensorshape"><code>tf.TensorShape</code></a> objects corresponding to each component of an element of this dataset. If omitted, each component will have an unconstrainted shape.</li> <li>
<b><code>shared_name</code></b>: (Optional.) If non-empty, this iterator will be shared under the given name across multiple sessions that share the same devices (e.g. when using a remote server).</li> <li>
<b><code>output_classes</code></b>: (Optional.) A nested structure of Python <code>type</code> objects corresponding to each component of an element of this iterator. If omitted, each component is assumed to be of type <a href="../tensor"><code>tf.Tensor</code></a>.</li> </ul> <h4 id="returns_5">Returns:</h4> <p>An <code>Iterator</code>.</p> <h4 id="raises_1">Raises:</h4> <ul> <li>
<b><code>TypeError</code></b>: If the structures of <code>output_shapes</code> and <code>output_types</code> are not the same.</li> </ul> <h3 id="get_next"><code>get_next</code></h3> <pre class="prettyprint lang-python" data-language="python">get_next(name=None)
</pre> <p>Returns a nested structure of <a href="../tensor"><code>tf.Tensor</code></a>s representing the next element.</p> <p>In graph mode, you should typically call this method <em>once</em> and use its result as the input to another computation. A typical loop will then call <a href="../interactivesession#run"><code>tf.Session.run</code></a> on the result of that computation. The loop will terminate when the <code>Iterator.get_next()</code> operation raises <a href="../errors/outofrangeerror"><code>tf.errors.OutOfRangeError</code></a>. The following skeleton shows how to use this method when building a training loop:</p> <pre class="prettyprint lang-python" data-language="python">dataset = ...  # A &lt;a href="../../tf/data/Dataset"&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; object.
iterator = dataset.make_initializable_iterator()
next_element = iterator.get_next()

# Build a TensorFlow graph that does something with each element.
loss = model_function(next_element)
optimizer = ...  # A &lt;a href="../../tf/train/Optimizer"&gt;&lt;code&gt;tf.train.Optimizer&lt;/code&gt;&lt;/a&gt; object.
train_op = optimizer.minimize(loss)

with tf.Session() as sess:
  try:
    while True:
      sess.run(train_op)
  except tf.errors.OutOfRangeError:
    pass
</pre> <p>NOTE: It is legitimate to call <code>Iterator.get_next()</code> multiple times, e.g. when you are distributing different elements to multiple devices in a single step. However, a common pitfall arises when users call <code>Iterator.get_next()</code> in each iteration of their training loop. <code>Iterator.get_next()</code> adds ops to the graph, and executing each op allocates resources (including threads); as a consequence, invoking it in every iteration of a training loop causes slowdown and eventual resource exhaustion. To guard against this outcome, we log a warning when the number of uses crosses a fixed threshold of suspiciousness.</p> <h4 id="args_3">Args:</h4> <ul> <li>
<b><code>name</code></b>: (Optional.) A name for the created operation.</li> </ul> <h4 id="returns_6">Returns:</h4> <p>A nested structure of <a href="../tensor"><code>tf.Tensor</code></a> objects.</p> <h3 id="make_initializer"><code>make_initializer</code></h3> <pre class="prettyprint lang-python" data-language="python">make_initializer(
    dataset,
    name=None
)
</pre> <p>Returns a <a href="../operation"><code>tf.Operation</code></a> that initializes this iterator on <code>dataset</code>.</p> <h4 id="args_4">Args:</h4> <ul> <li>
<b><code>dataset</code></b>: A <code>Dataset</code> with compatible structure to this iterator.</li> <li>
<b><code>name</code></b>: (Optional.) A name for the created operation.</li> </ul> <h4 id="returns_7">Returns:</h4> <p>A <a href="../operation"><code>tf.Operation</code></a> that can be run to initialize this iterator on the given <code>dataset</code>.</p> <h4 id="raises_2">Raises:</h4> <ul> <li>
<b><code>TypeError</code></b>: If <code>dataset</code> and this iterator do not have a compatible element structure.</li> </ul> <h3 id="string_handle"><code>string_handle</code></h3> <pre class="prettyprint lang-python" data-language="python">string_handle(name=None)
</pre> <p>Returns a string-valued <a href="../tensor"><code>tf.Tensor</code></a> that represents this iterator.</p> <h4 id="args_5">Args:</h4> <ul> <li>
<b><code>name</code></b>: (Optional.) A name for the created operation.</li> </ul> <h4 id="returns_8">Returns:</h4> <p>A scalar <a href="../tensor"><code>tf.Tensor</code></a> of type <a href="../string"><code>tf.string</code></a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2018 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/data/Iterator" class="_attribution-link">https://www.tensorflow.org/api_docs/python/tf/data/Iterator</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
