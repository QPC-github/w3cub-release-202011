
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>contrib.training.batch_sequences_with_states - TensorFlow Python - W3cubDocs</title>
  
  <meta name="description" content=" Defined in tensorflow&#47;contrib&#47;training&#47;python&#47;training&#47;sequence_queueing_state_saver.py. ">
  <meta name="keywords" content="tf, contrib, training, batch, sequences, with, states, tensorflow, python, tensorflow~python">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow~python/tf/contrib/training/batch_sequences_with_states.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/tensorflow~python.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~python/" class="_nav-link" title="" style="margin-left:0;">TensorFlow Python</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<h1 itemprop="name" class="devsite-page-title"> tf.contrib.training.batch_sequences_with_states </h1>     <div itemscope itemtype="http://developers.google.com/ReferenceObject"> <meta itemprop="name" content="tf.contrib.training.batch_sequences_with_states"> <meta itemprop="path" content="r1.8"> </div> <pre class="prettyprint lang-python" data-language="python">tf.contrib.training.batch_sequences_with_states(
    input_key,
    input_sequences,
    input_context,
    input_length,
    initial_states,
    num_unroll,
    batch_size,
    num_threads=3,
    capacity=1000,
    allow_small_batch=True,
    pad=True,
    make_keys_unique=False,
    make_keys_unique_seed=None,
    name=None
)
</pre> <p>Defined in <a href="https://www.github.com/tensorflow/tensorflow/blob/r1.8/tensorflow/contrib/training/python/training/sequence_queueing_state_saver.py"><code>tensorflow/contrib/training/python/training/sequence_queueing_state_saver.py</code></a>.</p> <p>See the guide: <a href="https://www.tensorflow.org/api_guides/python/contrib.training#Splitting_sequence_inputs_into_minibatches_with_state_saving">Training (contrib) &gt; Splitting sequence inputs into minibatches with state saving</a></p> <p>Creates batches of segments of sequential input.</p> <p>This method creates a <code>SequenceQueueingStateSaver</code> (SQSS) and adds it to the queuerunners. It returns a <code>NextQueuedSequenceBatch</code>.</p> <p>It accepts one example at a time identified by a unique <code>input_key</code>. <code>input_sequence</code> is a dict with values that are tensors with time as first dimension. This time dimension must be the same across those tensors of an example. It can vary across examples. Although it always has to be a multiple of <code>num_unroll</code>. Hence, padding may be necessary and it is turned on by default by <code>pad=True</code>.</p> <p><code>input_length</code> is a Tensor scalar or an int recording the time dimension prior to padding. It should be between 0 and the time dimension. One reason we want to keep track of it is so that we can take it into consideration when computing the loss. If <code>pad=True</code> then <code>input_length</code> can be <code>None</code> and will be inferred.</p> <p>This methods segments <code>input_sequence</code> into segments of length <code>num_unroll</code>. It batches input sequences from <code>batch_size</code> many examples. These mini-batches are available through the <code>sequence</code> property of the output. Moreover, for each entry in the batch we can access its original <code>input_key</code> in <code>key</code> and its input length in <code>total_length</code>. <code>length</code> records within this segment how many non-padded time steps there are.</p> <p>Static features of an example that do not vary across time can be part of the <code>input_context</code>, a dict with Tensor values. This method copies the context for each segment and makes it available in the <code>context</code> of the output.</p> <p>This method can maintain and update a state for each example. It accepts some initial_states as a dict with Tensor values. The first mini-batch an example is contained has initial_states as entry of the <code>state</code>. If save_state is called then the next segment will have the updated entry of the <code>state</code>. See <code>NextQueuedSequenceBatch</code> for a complete list of properties and methods.</p> <p>Example usage:</p> <pre class="prettyprint lang-python" data-language="python">batch_size = 32
num_unroll = 20
num_enqueue_threads = 3
lstm_size = 8
cell = tf.contrib.rnn.BasicLSTMCell(num_units=lstm_size)

key, sequences, context = my_parser(raw_data)
initial_state_values = tf.zeros((state_size,), dtype=tf.float32)
initial_states = {"lstm_state": initial_state_values}
batch = tf.batch_sequences_with_states(
    input_key=key,
    input_sequences=sequences,
    input_context=context,
    input_length=tf.shape(sequences["input"])[0],
    initial_states=initial_states,
    num_unroll=num_unroll,
    batch_size=batch_size,
    num_threads=num_enqueue_threads,
    capacity=batch_size * num_enqueue_threads * 2)

inputs = batch.sequences["input"]
context_label = batch.context["label"]

inputs_by_time = tf.split(value=inputs, num_or_size_splits=num_unroll, axis=1)
assert len(inputs_by_time) == num_unroll

lstm_output, _ = tf.contrib.rnn.static_state_saving_rnn(
  cell,
  inputs_by_time,
  state_saver=batch,
  state_name="lstm_state")

# Start a prefetcher in the background
sess = tf.Session()

tf.train.start_queue_runners(sess=session)

while True:
  # Step through batches, perform training or inference...
  session.run([lstm_output])
</pre> <h4 id="args">Args:</h4> <ul> <li> <p><b><code>input_key</code></b>: A string scalar <code>Tensor</code>, the <strong>unique</strong> key for the given input example. This is used to keep track of the split minibatch elements of this input. Batched keys of the current iteration are made accessible via the <code>key</code> property. The shape of <code>input_key</code> (scalar) must be fully specified. Consider setting <code>make_keys_unique</code> to True when iterating over the same input multiple times.</p> <p><strong>Note</strong>: if <code>make_keys_unique=False</code> then <code>input_key</code>s must be unique. * <b><code>input_sequences</code></b>: A dict mapping string names to <code>Tensor</code> values. The values must all have matching first dimension, called <code>value_length</code>. They may vary from input to input. The remainder of the shape (other than the first dimension) must be fully specified. The <code>SequenceQueueingStateSaver</code> will split these tensors along this first dimension into minibatch elements of dimension <code>num_unrolled</code>. Batched and segmented sequences of the current iteration are made accessible via the <code>sequences</code> property.</p> <p><strong>Note</strong>: if <code>pad=False</code>, then <code>value_length</code> must always be a multiple of <code>num_unroll</code>. * <b><code>input_context</code></b>: A dict mapping string names to <code>Tensor</code> values. The values are treated as "global" across all time splits of the given input example, and will be copied across for all minibatch elements accordingly. Batched and copied context of the current iteration are made accessible via the <code>context</code> property.</p> <p><strong>Note</strong>: All input_context values must have fully defined shapes. <em> <b><code>input_length</code></b>: None or an int32 scalar <code>Tensor</code>, the length of the sequence prior to padding. If <code>input_length=None</code> and <code>pad=True</code> then the length will be inferred and will be equal to <code>value_length</code>. If <code>pad=False</code> then <code>input_length</code> cannot be <code>None</code>: <code>input_length</code> must be specified. Its shape of <code>input_length</code> (scalar) must be fully specified. Its value may be at most <code>value_length</code> for any given input (see above for the definition of <code>value_length</code>). Batched and total lengths of the current iteration are made accessible via the <code>length</code> and <code>total_length</code> properties. </em> <b><code>initial_states</code></b>: A dict mapping string state names to multi-dimensional values (e.g. constants or tensors). This input defines the set of states that will be kept track of during computing iterations, and which can be accessed via the <code>state</code> and <code>save_state</code> methods.</p> <p><strong>Note</strong>: All initial_state values must have fully defined shapes. <em> <b><code>num_unroll</code></b>: Python integer, how many time steps to unroll at a time. The input sequences of length k are then split into k / num_unroll many segments. </em> <b><code>batch_size</code></b>: int or int32 scalar <code>Tensor</code>, how large minibatches should be when accessing the <code>state()</code> method and <code>context</code>, <code>sequences</code>, etc, properties. <em> <b><code>num_threads</code></b>: The int number of threads enqueuing input examples into a queue. </em> <b><code>capacity</code></b>: The max capacity of the queue in number of examples. Needs to be at least <code>batch_size</code>. Defaults to 1000. When iterating over the same input example multiple times reusing their keys the <code>capacity</code> must be smaller than the number of examples. <em> <b><code>allow_small_batch</code></b>: If true, the queue will return smaller batches when there aren't enough input examples to fill a whole batch and the end of the input has been reached. </em> <b><code>pad</code></b>: If <code>True</code>, <code>input_sequences</code> will be padded to multiple of <code>num_unroll</code>. In that case <code>input_length</code> may be <code>None</code> and is assumed to be the length of first dimension of values in <code>input_sequences</code> (i.e. <code>value_length</code>). <em> <b><code>make_keys_unique</code></b>: Whether to append a random integer to the <code>input_key</code> in an effort to make it unique. The seed can be set via <code>make_keys_unique_seed</code>. </em> <b><code>make_keys_unique_seed</code></b>: If <code>make_keys_unique=True</code> this fixes the seed with which a random postfix is generated. * <b><code>name</code></b>: An op name string (optional).</p> </li> </ul> <h4 id="returns">Returns:</h4> <p>A NextQueuedSequenceBatch with segmented and batched inputs and their states.</p> <h4 id="raises">Raises:</h4> <ul> <li>
<b><code>TypeError</code></b>: if any of the inputs is not an expected type.</li> <li>
<b><code>ValueError</code></b>: if any of the input values is inconsistent, e.g. if not enough shape information is available from inputs to build the state saver.</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2018 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/python/tf/contrib/training/batch_sequences_with_states" class="_attribution-link">https://www.tensorflow.org/api_docs/python/tf/contrib/training/batch_sequences_with_states</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
