
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Neural Network - TensorFlow Python - W3cubDocs</title>
  
  <meta name="description" content="The activation ops provide different types of nonlinearities for use in neural networks. These include smooth nonlinearities (sigmoid, tanh, elu, &hellip;">
  <meta name="keywords" content="neural, network, tensorflow, python, tensorflow~python">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow~python/nn.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/tensorflow~python.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~python/" class="_nav-link" title="" style="margin-left:0;">TensorFlow Python</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<h1 itemprop="name" class="devsite-page-title"> Neural Network </h1>     <blockquote class="note">
<strong>Note:</strong><span> Functions taking <code>Tensor</code> arguments can also take anything accepted by <a href="https://www.tensorflow.org/api_docs/python/tf/convert_to_tensor"><code>tf.convert_to_tensor</code></a>.</span>
</blockquote> <h2 id="Activation_Functions">Activation Functions</h2> <p>The activation ops provide different types of nonlinearities for use in neural networks. These include smooth nonlinearities (<code>sigmoid</code>, <code>tanh</code>, <code>elu</code>, <code>selu</code>, <code>softplus</code>, and <code>softsign</code>), continuous but not everywhere differentiable functions (<code>relu</code>, <code>relu6</code>, <code>crelu</code> and <code>relu_x</code>), and random regularization (<code>dropout</code>).</p> <p>All activation ops apply componentwise, and produce a tensor of the same shape as the input tensor.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/relu"><code>tf.nn.relu</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/relu6"><code>tf.nn.relu6</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/crelu"><code>tf.nn.crelu</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/elu"><code>tf.nn.elu</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/selu"><code>tf.nn.selu</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/softplus"><code>tf.nn.softplus</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/softsign"><code>tf.nn.softsign</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/dropout"><code>tf.nn.dropout</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/bias_add"><code>tf.nn.bias_add</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/sigmoid"><code>tf.sigmoid</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/tanh"><code>tf.tanh</code></a></li> </ul> <h2 id="Convolution">Convolution</h2> <p>The convolution ops sweep a 2-D filter over a batch of images, applying the filter to each window of each image of the appropriate size. The different ops trade off between generic vs. specific filters:</p> <ul> <li>
<code>conv2d</code>: Arbitrary filters that can mix channels together.</li> <li>
<code>depthwise_conv2d</code>: Filters that operate on each channel independently.</li> <li>
<code>separable_conv2d</code>: A depthwise spatial filter followed by a pointwise filter.</li> </ul> <p>Note that although these ops are called "convolution", they are strictly speaking "cross-correlation" since the filter is combined with an input window without reversing the filter. For details, see <a href="https://en.wikipedia.org/wiki/Cross-correlation#Properties">the properties of cross-correlation</a>.</p> <p>The filter is applied to image patches of the same size as the filter and strided according to the <code>strides</code> argument. <code>strides = [1, 1, 1, 1]</code> applies the filter to a patch at every offset, <code>strides = [1, 2, 2, 1]</code> applies the filter to every other image patch in each dimension, etc.</p> <p>Ignoring channels for the moment, assume that the 4-D <code>input</code> has shape <code>[batch, in_height, in_width, ...]</code> and the 4-D <code>filter</code> has shape <code>[filter_height, filter_width, ...]</code>. The spatial semantics of the convolution ops depend on the padding scheme chosen: <code>'SAME'</code> or <code>'VALID'</code>. Note that the padding values are always zero.</p> <p>First, consider the <code>'SAME'</code> padding scheme. A detailed explanation of the reasoning behind it is given in <a href="#Notes_on_SAME_Convolution_Padding">these notes</a>. Here, we summarize the mechanics of this padding scheme. When using <code>'SAME'</code>, the output height and width are computed as:</p> <pre class="prettyprint notranslate" translate="no" data-language="python">out_height = ceil(float(in_height) / float(strides[1]))
out_width  = ceil(float(in_width) / float(strides[2]))
</pre> <p>The total padding applied along the height and width is computed as:</p> <pre class="prettyprint notranslate" translate="no" data-language="python">if (in_height % strides[1] == 0):
  pad_along_height = max(filter_height - strides[1], 0)
else:
  pad_along_height = max(filter_height - (in_height % strides[1]), 0)
if (in_width % strides[2] == 0):
  pad_along_width = max(filter_width - strides[2], 0)
else:
  pad_along_width = max(filter_width - (in_width % strides[2]), 0)
</pre> <p>Finally, the padding on the top, bottom, left and right are:</p> <pre class="prettyprint notranslate" translate="no" data-language="python">pad_top = pad_along_height // 2
pad_bottom = pad_along_height - pad_top
pad_left = pad_along_width // 2
pad_right = pad_along_width - pad_left
</pre> <p>Note that the division by 2 means that there might be cases when the padding on both sides (top vs bottom, right vs left) are off by one. In this case, the bottom and right sides always get the one additional padded pixel. For example, when <code>pad_along_height</code> is 5, we pad 2 pixels at the top and 3 pixels at the bottom. Note that this is different from existing libraries such as cuDNN and Caffe, which explicitly specify the number of padded pixels and always pad the same number of pixels on both sides.</p> <p>For the <code>'VALID'</code> scheme, the output height and width are computed as:</p> <pre class="prettyprint notranslate" translate="no" data-language="python">out_height = ceil(float(in_height - filter_height + 1) / float(strides[1]))
out_width  = ceil(float(in_width - filter_width + 1) / float(strides[2]))
</pre> <p>and no padding is used.</p> <p>Given the output size and the padding, the output can be computed as</p> <div> $$ output[b, i, j, :] = sum_{d_i, d_j} input[b, strides[1] * i + d_i - pad_{top},\ strides[2] * j + d_j - pad_{left}, ...] * filter[d_i, d_j,\ ...]$$</div> <p>where any value outside the original input image region are considered zero ( i.e. we pad zero values around the border of the image).</p> <p>Since <code>input</code> is 4-D, each <code>input[b, i, j, :]</code> is a vector. For <code>conv2d</code>, these vectors are multiplied by the <code>filter[di, dj, :, :]</code> matrices to produce new vectors. For <code>depthwise_conv_2d</code>, each scalar component <code>input[b, i, j, k]</code> is multiplied by a vector <code>filter[di, dj, k]</code>, and all the vectors are concatenated.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/convolution"><code>tf.nn.convolution</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d"><code>tf.nn.conv2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d"><code>tf.nn.depthwise_conv2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d_native"><code>tf.nn.depthwise_conv2d_native</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d"><code>tf.nn.separable_conv2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d"><code>tf.nn.atrous_conv2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d_transpose"><code>tf.nn.atrous_conv2d_transpose</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d_transpose"><code>tf.nn.conv2d_transpose</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv1d"><code>tf.nn.conv1d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv3d"><code>tf.nn.conv3d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv3d_transpose"><code>tf.nn.conv3d_transpose</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d_backprop_filter"><code>tf.nn.conv2d_backprop_filter</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d_backprop_input"><code>tf.nn.conv2d_backprop_input</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv3d_backprop_filter_v2"><code>tf.nn.conv3d_backprop_filter_v2</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d_native_backprop_filter"><code>tf.nn.depthwise_conv2d_native_backprop_filter</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d_native_backprop_input"><code>tf.nn.depthwise_conv2d_native_backprop_input</code></a></li> </ul> <h2 id="Pooling">Pooling</h2> <p>The pooling ops sweep a rectangular window over the input tensor, computing a reduction operation for each window (average, max, or max with argmax). Each pooling op uses rectangular windows of size <code>ksize</code> separated by offset <code>strides</code>. For example, if <code>strides</code> is all ones every window is used, if <code>strides</code> is all twos every other window is used in each dimension, etc.</p> <p>In detail, the output is</p> <pre class="prettyprint notranslate" translate="no" data-language="python">output[i] = reduce(value[strides * i:strides * i + ksize])
</pre> <p>where the indices also take into consideration the padding values. Please refer to the <code>Convolution</code> section for details about the padding calculation.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/avg_pool"><code>tf.nn.avg_pool</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/max_pool"><code>tf.nn.max_pool</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/max_pool_with_argmax"><code>tf.nn.max_pool_with_argmax</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/avg_pool3d"><code>tf.nn.avg_pool3d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/max_pool3d"><code>tf.nn.max_pool3d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/fractional_avg_pool"><code>tf.nn.fractional_avg_pool</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/fractional_max_pool"><code>tf.nn.fractional_max_pool</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/pool"><code>tf.nn.pool</code></a></li> </ul> <h2 id="Morphological_filtering">Morphological filtering</h2> <p>Morphological operators are non-linear filters used in image processing.</p> <p><a href="https://en.wikipedia.org/wiki/Dilation_(morphology)">Greyscale morphological dilation </a> is the max-sum counterpart of standard sum-product convolution:</p> <div> $$ output[b, y, x, c] = max_{dy, dx} input[b, strides[1] * y + rates[1] * dy, strides[2] * x + rates[2] * dx, c] + filter[dy, dx, c]$$</div> <p>The <code>filter</code> is usually called structuring function. Max-pooling is a special case of greyscale morphological dilation when the filter assumes all-zero values (a.k.a. flat structuring function).</p> <p><a href="https://en.wikipedia.org/wiki/Erosion_(morphology)">Greyscale morphological erosion </a> is the min-sum counterpart of standard sum-product convolution:</p> <div> $$ output[b, y, x, c] = min_{dy, dx} input[b, strides[1] * y - rates[1] * dy, strides[2] * x - rates[2] * dx, c] - filter[dy, dx, c]$$</div> <p>Dilation and erosion are dual to each other. The dilation of the input signal <code>f</code> by the structuring signal <code>g</code> is equal to the negation of the erosion of <code>-f</code> by the reflected <code>g</code>, and vice versa.</p> <p>Striding and padding is carried out in exactly the same way as in standard convolution. Please refer to the <code>Convolution</code> section for details.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/dilation2d"><code>tf.nn.dilation2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/erosion2d"><code>tf.nn.erosion2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/with_space_to_batch"><code>tf.nn.with_space_to_batch</code></a></li> </ul> <h2 id="Normalization">Normalization</h2> <p>Normalization is useful to prevent neurons from saturating when inputs may have varying scale, and to aid generalization.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/l2_normalize"><code>tf.nn.l2_normalize</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/local_response_normalization"><code>tf.nn.local_response_normalization</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/sufficient_statistics"><code>tf.nn.sufficient_statistics</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/normalize_moments"><code>tf.nn.normalize_moments</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/moments"><code>tf.nn.moments</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/weighted_moments"><code>tf.nn.weighted_moments</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/fused_batch_norm"><code>tf.nn.fused_batch_norm</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/batch_normalization"><code>tf.nn.batch_normalization</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/batch_norm_with_global_normalization"><code>tf.nn.batch_norm_with_global_normalization</code></a></li> </ul> <h2 id="Losses">Losses</h2> <p>The loss ops measure error between two tensors, or between a tensor and zero. These can be used for measuring accuracy of a network in a regression task or for regularization purposes (weight decay).</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/l2_loss"><code>tf.nn.l2_loss</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/log_poisson_loss"><code>tf.nn.log_poisson_loss</code></a></li> </ul> <h2 id="Classification">Classification</h2> <p>TensorFlow provides several operations that help you perform classification.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/sigmoid_cross_entropy_with_logits"><code>tf.nn.sigmoid_cross_entropy_with_logits</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/softmax"><code>tf.nn.softmax</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/log_softmax"><code>tf.nn.log_softmax</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/softmax_cross_entropy_with_logits"><code>tf.nn.softmax_cross_entropy_with_logits</code></a></li> <li>
<a href="https://www.tensorflow.org/api_docs/python/tf/nn/softmax_cross_entropy_with_logits_v2"><code>tf.nn.softmax_cross_entropy_with_logits_v2</code></a> - identical to the base version, except it allows gradient propagation into the labels.</li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/sparse_softmax_cross_entropy_with_logits"><code>tf.nn.sparse_softmax_cross_entropy_with_logits</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/weighted_cross_entropy_with_logits"><code>tf.nn.weighted_cross_entropy_with_logits</code></a></li> </ul> <h2 id="Embeddings">Embeddings</h2> <p>TensorFlow provides library support for looking up values in embedding tensors.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/embedding_lookup"><code>tf.nn.embedding_lookup</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/embedding_lookup_sparse"><code>tf.nn.embedding_lookup_sparse</code></a></li> </ul> <h2 id="Recurrent_Neural_Networks">Recurrent Neural Networks</h2> <p>TensorFlow provides a number of methods for constructing Recurrent Neural Networks. Most accept an <code>RNNCell</code>-subclassed object (see the documentation for <a href="https://www.tensorflow.org/api_docs/python/tf/contrib/rnn"><code>tf.contrib.rnn</code></a>).</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/dynamic_rnn"><code>tf.nn.dynamic_rnn</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/bidirectional_dynamic_rnn"><code>tf.nn.bidirectional_dynamic_rnn</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/raw_rnn"><code>tf.nn.raw_rnn</code></a></li> </ul> <h2 id="Connectionist_Temporal_Classification_CTC_">Connectionist Temporal Classification (CTC)</h2> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/ctc_loss"><code>tf.nn.ctc_loss</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/ctc_greedy_decoder"><code>tf.nn.ctc_greedy_decoder</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/ctc_beam_search_decoder"><code>tf.nn.ctc_beam_search_decoder</code></a></li> </ul> <h2 id="Evaluation">Evaluation</h2> <p>The evaluation ops are useful for measuring the performance of a network. They are typically used at evaluation time.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/top_k"><code>tf.nn.top_k</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/in_top_k"><code>tf.nn.in_top_k</code></a></li> </ul> <h2 id="Candidate_Sampling">Candidate Sampling</h2> <p>Do you want to train a multiclass or multilabel model with thousands or millions of output classes (for example, a language model with a large vocabulary)? Training with a full Softmax is slow in this case, since all of the classes are evaluated for every training example. Candidate Sampling training algorithms can speed up your step times by only considering a small randomly-chosen subset of contrastive classes (called candidates) for each batch of training examples.</p> <p>See our <a href="https://www.tensorflow.org/extras/candidate_sampling.pdf">Candidate Sampling Algorithms Reference</a></p> <h3 id="sampled_loss_functions">Sampled Loss Functions</h3> <p>TensorFlow provides the following sampled loss functions for faster training.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/nce_loss"><code>tf.nn.nce_loss</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/sampled_softmax_loss"><code>tf.nn.sampled_softmax_loss</code></a></li> </ul> <h3 id="candidate_samplers">Candidate Samplers</h3> <p>TensorFlow provides the following samplers for randomly sampling candidate classes when using one of the sampled loss functions above.</p> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/uniform_candidate_sampler"><code>tf.nn.uniform_candidate_sampler</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/log_uniform_candidate_sampler"><code>tf.nn.log_uniform_candidate_sampler</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/learned_unigram_candidate_sampler"><code>tf.nn.learned_unigram_candidate_sampler</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/fixed_unigram_candidate_sampler"><code>tf.nn.fixed_unigram_candidate_sampler</code></a></li> </ul> <h3 id="miscellaneous_candidate_sampling_utilities">Miscellaneous candidate sampling utilities</h3> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/compute_accidental_hits"><code>tf.nn.compute_accidental_hits</code></a></li> </ul> <h3 id="quantization_ops">Quantization ops</h3> <ul> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/quantized_conv2d"><code>tf.nn.quantized_conv2d</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/quantized_relu_x"><code>tf.nn.quantized_relu_x</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/quantized_max_pool"><code>tf.nn.quantized_max_pool</code></a></li> <li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/quantized_avg_pool"><code>tf.nn.quantized_avg_pool</code></a></li> </ul> <h2 id="Notes_on_SAME_Convolution_Padding">Notes on SAME Convolution Padding</h2> <p>In these notes, we provide more background on the use of the <code>'SAME'</code> padding scheme for convolution operations.</p> <p>Tensorflow uses the smallest possible padding to achieve the desired output size. To understand what is done, consider the \(1\)-dimensional case. Denote \(n_i\) and \(n_o\) the input and output sizes, respectively, and denote the kernel size \(k\) and stride \(s\). As discussed in the <a href="#Convolution">Convolution section</a>, for <code>'SAME'</code>, \(n_o = \left \lceil{\frac{n_i}{s}}\right \rceil\).</p> <p>To achieve a desired output size \(n_o\), we need to pad the input such that the output size after a <code>'VALID'</code> convolution is \(n_o\). In other words, we need to have padding \(p_i\) such that:</p> <p>\begin{equation} \left \lceil{\frac{n_i + p_i - k + 1}{s}}\right \rceil = n_o \label{eq:tf_pad_1} \end{equation}</p> <p>What is the smallest \(p_i\) that we could possibly use? In general, \(\left \lceil{\frac{x}{a}}\right \rceil = b\) (with \(a &gt; 0\)) means that \(b-1 &lt; \frac{x}{a} \leq b\), and the smallest integer \(x\) we can choose to satisfy this is \(x = a\cdot (b-1) + 1\). The same applies to our problem; we need \(p_i\) such that:</p> <p>\begin{equation} n_i + p_i - k + 1 = s\cdot (n_o - 1) + 1 \label{eq:tf_pad_2} \end{equation}</p> <p>which leads to:</p> <p>\begin{equation} p_i = s\cdot (n_o - 1) + k - n_i \label{eq:tf_pad_3} \end{equation}</p> <p>Note that this might lead to negative \(p_i\), since in some cases we might already have more input samples than we actually need. Thus,</p> <p>\begin{equation} p_i = max(s\cdot (n_o - 1) + k - n_i, 0) \label{eq:tf_pad_4} \end{equation}</p> <p>Remember that, for <code>'SAME'</code> padding, \(n_o = \left \lceil{\frac{n_i}{s}}\right \rceil\), as mentioned above. We need to analyze in detail two cases:</p> <ul> <li>\(n_i \text{ mod } s = 0\)</li> </ul> <p>In this simple case, \(n_o = \frac{n_i}{s}\), and the expression for \(p_i\) becomes:</p> <p>\begin{equation} p_i = max(k - s, 0) \label{eq:tf_pad_5} \end{equation}</p> <ul> <li>\(n_i \text{ mod } s \neq 0\)</li> </ul> <p>This case is more involved to parse. First, we write:</p> <p>\begin{equation} n_i = s\cdot\left \lceil{\frac{n_i}{s}}\right \rceil - s \left(\left \lceil{\frac{n_i}{s}}\right \rceil - \left \lfloor{\frac{n_i}{s}}\right \rfloor\right) + (n_i \text{ mod } s) \label{eq:tf_pad_6} \end{equation}</p> <p>For the case where \((n_i \text{ mod } s) \neq 0\), we have \(\left \lceil{\frac{n_i}{s}}\right \rceil -\left \lfloor{\frac{n_i}{s}}\right \rfloor = 1\), leading to:</p> <p>\begin{equation} n_i = s\cdot\left \lceil{\frac{n_i}{s}}\right \rceil - s + (n_i \text{ mod } s) \label{eq:tf_pad_7} \end{equation}</p> <p>We can use this expression to substitute \(n_o = \left \lceil{\frac{n_i}{s}}\right \rceil\) and get:</p> <div> $$\begin{align} p_i &amp;= max\left(s\cdot \left(\frac{n_i + s - (n_i \text{ mod } s)}{s} - 1\right) + k - n_i, 0\right) \nonumber\\ &amp;= max(n_i + s - (n_i \text{ mod } s) - s + k - n_i,0) \nonumber \\ &amp;= max(k - (n_i \text{ mod } s),0) \label{eq:tf_pad_8} \end{align}$$</div> <h3 id="final_expression">Final expression</h3> <p>Putting all together, the total padding used by tensorflow's convolution with <code>'SAME'</code> mode is:</p> <div> $$\begin{align} p_i = \begin{cases} max(k - s, 0), &amp; \text{if $(n_i \text{ mod } s) = 0$} \\ max(k - (n_i \text{ mod } s),0), &amp; \text{if $(n_i \text{ mod } s) \neq 0$} \end{cases} \label{eq:tf_pad_9} \end{align}$$</div> <p>This expression is exactly equal to the ones presented for <code>pad_along_height</code> and <code>pad_along_width</code> in the <a href="#Convolution">Convolution section</a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2018 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_guides/python/nn" class="_attribution-link">https://www.tensorflow.org/api_guides/python/nn</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
