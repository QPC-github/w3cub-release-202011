
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>6.4. Functions - Rust - W3cubDocs</title>
  
  <meta name="description" content=" Syntax Function &#58; FunctionQualifiers fn IDENTIFIER Generics? ( FunctionParameters? ) FunctionReturnType? WhereClause? BlockExpression ">
  <meta name="keywords" content="functions, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rust/reference/items/functions.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rust">
				
				
<h1>Functions</h1> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>Function</em> :<br> <em>FunctionQualifiers</em> <code>fn</code> <a href="../identifiers">IDENTIFIER</a> <a href="generics"><em>Generics</em></a><sup>?</sup><br> <code>(</code> <em>FunctionParameters</em><sup>?</sup> <code>)</code><br> <em>FunctionReturnType</em><sup>?</sup> <a href="generics#where-clauses"><em>WhereClause</em></a><sup>?</sup><br> <a href="../expressions/block-expr"><em>BlockExpression</em></a></p> <p><em>FunctionQualifiers</em> :<br> <em>AsyncConstQualifiers</em><sup>?</sup> <code>unsafe</code><sup>?</sup> (<code>extern</code> <em>Abi</em><sup>?</sup>)<sup>?</sup></p> <p><em>AsyncConstQualifiers</em> :<br> <code>async</code> | <code>const</code></p> <p><em>Abi</em> :<br> <a href="../tokens#string-literals">STRING_LITERAL</a> | <a href="../tokens#raw-string-literals">RAW_STRING_LITERAL</a></p> <p><em>FunctionParameters</em> :<br> <em>FunctionParam</em> (<code>,</code> <em>FunctionParam</em>)<sup>*</sup> <code>,</code><sup>?</sup></p> <p><em>FunctionParam</em> :<br> <a href="../attributes"><em>OuterAttribute</em></a><sup>*</sup> <a href="../patterns"><em>Pattern</em></a> <code>:</code> <a href="../types#type-expressions"><em>Type</em></a></p> <p><em>FunctionReturnType</em> :<br> <code>-&gt;</code> <a href="../types#type-expressions"><em>Type</em></a></p> </blockquote> <p>A <em>function</em> consists of a <a href="../expressions/block-expr">block</a>, along with a name and a set of parameters. Other than a name, all these are optional. Functions are declared with the keyword <code>fn</code>. Functions may declare a set of <em>input</em> <a href="../variables"><em>variables</em></a> as parameters, through which the caller passes arguments into the function, and the <em>output</em> <a href="../types#type-expressions"><em>type</em></a> of the value the function will return to its caller on completion.</p> <p>When referred to, a <em>function</em> yields a first-class <em>value</em> of the corresponding zero-sized <a href="../types/function-item"><em>function item type</em></a>, which when called evaluates to a direct call to the function.</p> <p>For example, this is a simple function:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
fn answer_to_life_the_universe_and_everything() -&gt; i32 {
    return 42;
}
}
</pre> <p>As with <code>let</code> bindings, function arguments are irrefutable <a href="../patterns">patterns</a>, so any pattern that is valid in a let binding is also valid as an argument:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
fn first((value, _): (i32, i32)) -&gt; i32 { value }
}
</pre> <p>The block of a function is conceptually wrapped in a block that binds the argument patterns and then <code>return</code>s the value of the function's block. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.</p> <p>For example, the function above behaves as if it was written as:</p>  <pre data-language="rust">// argument_0 is the actual first argument passed from the caller
let (value, _) = argument_0;
return {
    value
};
</pre> <h2>Generic functions</h2> <p>A <em>generic function</em> allows one or more <em>parameterized types</em> to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
// foo is generic over A and B

fn foo&lt;A, B&gt;(x: A, y: B) {
}
}
</pre> <p>Inside the function signature and body, the name of the type parameter can be used as a type name. <a href="traits">Trait</a> bounds can be specified for type parameters to allow methods with that trait to be called on values of that type. This is specified using the <code>where</code> syntax:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
use std::fmt::Debug;
fn foo&lt;T&gt;(x: T) where T: Debug {
}
}
</pre> <p>When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the <code>foo</code> function here:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
use std::fmt::Debug;

fn foo&lt;T&gt;(x: &amp;[T]) where T: Debug {
    // details elided
}

foo(&amp;[1, 2]);
}
</pre> <p>will instantiate type parameter <code>T</code> with <code>i32</code>.</p> <p>The type parameters can also be explicitly supplied in a trailing <a href="../paths">path</a> component after the function name. This might be necessary if there is not sufficient context to determine the type parameters. For example, <code>mem::size_of::&lt;u32&gt;() == 4</code>.</p> <h2>Extern function qualifier</h2> <p>The <code>extern</code> function qualifier allows providing function <em>definitions</em> that can be called with a particular ABI:</p>  <pre data-language="rust">extern "ABI" fn foo() { /* ... */ }
</pre> <p>These are often used in combination with <a href="external-blocks">external block</a> items which provide function <em>declarations</em> that can be used to call functions without providing their <em>definition</em>:</p>  <pre data-language="rust">extern "ABI" {
  fn foo(); /* no body */
}
unsafe { foo() }
</pre> <p>When <code>"extern" Abi?*</code> is omitted from <code>FunctionQualifiers</code> in function items, the ABI <code>"Rust"</code> is assigned. For example:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
fn foo() {}
}
</pre> <p>is equivalent to:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
extern "Rust" fn foo() {}
}
</pre> <p>Functions in Rust can be called by foreign code, and using an ABI that differs from Rust allows, for example, to provide functions that can be called from other programming languages like C:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
// Declares a function with the "C" ABI
extern "C" fn new_i32() -&gt; i32 { 0 }

// Declares a function with the "stdcall" ABI
#[cfg(target_arch = "x86_64")]
extern "stdcall" fn new_i32_stdcall() -&gt; i32 { 0 }
}
</pre> <p>Just as with <a href="external-blocks">external block</a>, when the <code>extern</code> keyword is used and the <code>"ABI</code> is omitted, the ABI used defaults to <code>"C"</code>. That is, this:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
extern fn new_i32() -&gt; i32 { 0 }
let fptr: extern fn() -&gt; i32 = new_i32;
}
</pre> <p>is equivalent to:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
extern "C" fn new_i32() -&gt; i32 { 0 }
let fptr: extern "C" fn() -&gt; i32 = new_i32;
}
</pre> <p>Functions with an ABI that differs from <code>"Rust"</code> do not support unwinding in the exact same way that Rust does. Therefore, unwinding past the end of functions with such ABIs causes the process to abort.</p> <blockquote> <p><strong>Note</strong>: The LLVM backend of the <code>rustc</code> implementation aborts the process by executing an illegal instruction.</p> </blockquote> <h2>Const functions</h2> <p>Functions qualified with the <code>const</code> keyword are const functions, as are <a href="structs">tuple struct</a> and <a href="enumerations">tuple variant</a> constructors. <em>Const functions</em> can be called from within <a href="../const_eval#const-context">const context</a>s. When called from a const context, the function is interpreted by the compiler at compile time. The interpretation happens in the environment of the compilation target and not the host. So <code>usize</code> is <code>32</code> bits if you are compiling against a <code>32</code> bit system, irrelevant of whether you are building on a <code>64</code> bit or a <code>32</code> bit system.</p> <p>If a const function is called outside a <a href="../const_eval#const-context">const context</a>, it is indistinguishable from any other function. You can freely do anything with a const function that you can do with a regular function.</p> <p>Const functions have various restrictions to make sure that they can be evaluated at compile-time. It is, for example, not possible to write a random number generator as a const function. Calling a const function at compile-time will always yield the same result as calling it at runtime, even when called multiple times. There's one exception to this rule: if you are doing complex floating point operations in extreme situations, then you might get (very slightly) different results. It is advisable to not make array lengths and enum discriminants depend on floating point computations.</p> <p>Exhaustive list of permitted structures in const functions:</p> <blockquote> <p><strong>Note</strong>: this list is more restrictive than what you can write in regular constants</p> </blockquote> <ul> <li> <p>Type parameters where the parameters only have any <a href="../trait-bounds">trait bounds</a> of the following kind:</p> <ul> <li>lifetimes</li> <li>
<code>Sized</code> or <a href="../trait-bounds#sized"><code>?Sized</code></a>
</li> </ul> <p>This means that <code>&lt;T: 'a + ?Sized&gt;</code>, <code>&lt;T: 'b + Sized&gt;</code>, and <code>&lt;T&gt;</code> are all permitted.</p> <p>This rule also applies to type parameters of impl blocks that contain const methods.</p> <p>This does not apply to tuple struct and tuple variant constructors.</p> </li> <li> <p>Arithmetic and comparison operators on integers</p> </li> <li> <p>All boolean operators except for <code>&amp;&amp;</code> and <code>||</code> which are banned since they are short-circuiting.</p> </li> <li> <p>Any kind of aggregate constructor (array, <code>struct</code>, <code>enum</code>, tuple, ...)</p> </li> <li> <p>Calls to other <em>safe</em> const functions (whether by function call or method call)</p> </li> <li> <p>Index expressions on arrays and slices</p> </li> <li> <p>Field accesses on structs and tuples</p> </li> <li> <p>Reading from constants (but not statics, not even taking a reference to a static)</p> </li> <li> <p><code>&amp;</code> and <code>*</code> (only dereferencing of references, not raw pointers)</p> </li> <li> <p>Casts except for raw pointer to integer casts</p> </li> <li> <p><code>unsafe</code> blocks and <code>const unsafe fn</code> are allowed, but the body/block may only do the following unsafe operations:</p> <ul> <li>calls to const unsafe functions</li> </ul> </li> </ul> <h2>Async functions</h2> <p>Functions may be qualified as async, and this can also be combined with the <code>unsafe</code> qualifier:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
async fn regular_example() { }
async unsafe fn unsafe_example() { }
}
</pre> <p>Async functions do no work when called: instead, they capture their arguments into a future. When polled, that future will execute the function's body.</p> <p>An async function is roughly equivalent to a function that returns <a href="../types/impl-trait"><code>impl Future</code></a> and with an <a href="../expressions/block-expr#async-blocks"><code>async move</code> block</a> as its body:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
// Source
async fn example(x: &amp;str) -&gt; usize {
    x.len()
}
}
</pre> <p>is roughly equivalent to:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
use std::future::Future;
// Desugared
fn example&lt;'a&gt;(x: &amp;'a str) -&gt; impl Future&lt;Output = usize&gt; + 'a {
    async move { x.len() }
}
}
</pre> <p>The actual desugaring is more complex:</p> <ul> <li>The return type in the desugaring is assumed to capture all lifetime parameters from the <code>async fn</code> declaration. This can be seen in the desugared example above, which explicitly outlives, and hence captures, <code>'a</code>.</li> <li>The <a href="../expressions/block-expr#async-blocks"><code>async move</code> block</a> in the body captures all function parameters, including those that are unused or bound to a <code>_</code> pattern. This ensures that function parameters are dropped in the same order as they would be if the function were not async, except that the drop occurs when the returned future has been fully awaited.</li> </ul> <p>For more information on the effect of async, see <a href="../expressions/block-expr#async-blocks"><code>async</code> blocks</a>.</p> <blockquote> <p><strong>Edition differences</strong>: Async functions are only available beginning with Rust 2018.</p> </blockquote> <h3>Combining <code id="combining-async-and-unsafe">async</code> and <code>unsafe</code>
</h3> <p>It is legal to declare a function that is both async and unsafe. The resulting function is unsafe to call and (like any async function) returns a future. This future is just an ordinary future and thus an <code>unsafe</code> context is not required to "await" it:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
// Returns a future that, when awaited, dereferences `x`.
//
// Soundness condition: `x` must be safe to dereference until
// the resulting future is complete.
async unsafe fn unsafe_example(x: *const i32) -&gt; i32 {
  *x
}

async fn safe_example() {
    // An `unsafe` block is required to invoke the function initially:
    let p = 22;
    let future = unsafe { unsafe_example(&amp;p) };

    // But no `unsafe` block required here. This will
    // read the value of `p`:
    let q = future.await;
}
}
</pre> <p>Note that this behavior is a consequence of the desugaring to a function that returns an <code>impl Future</code> -- in this case, the function we desugar to is an <code>unsafe</code> function, but the return value remains the same.</p> <p>Unsafe is used on an async function in precisely the same way that it is used on other functions: it indicates that the function imposes some additional obligations on its caller to ensure soundness. As in any other unsafe function, these conditions may extend beyond the initial call itself -- in the snippet above, for example, the <code>unsafe_example</code> function took a pointer <code>x</code> as argument, and then (when awaited) dereferenced that pointer. This implies that <code>x</code> would have to be valid until the future is finished executing, and it is the callers responsibility to ensure that.</p> <h2>Attributes on functions</h2> <p><a href="../attributes">Outer attributes</a> are allowed on functions. <a href="../attributes">Inner attributes</a> are allowed directly after the <code>{</code> inside its <a href="../expressions/block-expr">block</a>.</p> <p>This example shows an inner attribute on a function. The function will only be available while running tests.</p> <pre>fn test_only() {
    #![test]
}
</pre> <blockquote> <p>Note: Except for lints, it is idiomatic to only use outer attributes on function items.</p> </blockquote> <p>The attributes that have meaning on a function are <a href="../conditional-compilation#the-cfg-attribute"><code>cfg</code></a>, <a href="../conditional-compilation#the-cfg_attr-attribute"><code>cfg_attr</code></a>, <a href="../attributes/diagnostics#the-deprecated-attribute"><code>deprecated</code></a>, <a href="https://doc.rust-lang.org/rustdoc/the-doc-attribute.html"><code>doc</code></a>, <a href="../abi#the-export_name-attribute"><code>export_name</code></a>, <a href="../abi#the-link_section-attribute"><code>link_section</code></a>, <a href="../abi#the-no_mangle-attribute"><code>no_mangle</code></a>, <a href="../attributes/diagnostics#lint-check-attributes">the lint check attributes</a>, <a href="../attributes/diagnostics#the-must_use-attribute"><code>must_use</code></a>, <a href="../procedural-macros">the procedural macro attributes</a>, <a href="../attributes/testing">the testing attributes</a>, and <a href="../attributes/codegen#optimization-hints">the optimization hint attributes</a>. Functions also accept attributes macros.</p> <h2>Attributes on function parameters</h2> <p><a href="../attributes">Outer attributes</a> are allowed on function parameters and the permitted <a href="../attributes#built-in-attributes-index">built-in attributes</a> are restricted to <code>cfg</code>, <code>cfg_attr</code>, <code>allow</code>, <code>warn</code>, <code>deny</code>, and <code>forbid</code>.</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
fn len(
    #[cfg(windows)] slice: &amp;[u16],
    #[cfg(not(windows))] slice: &amp;[u8],
) -&gt; usize {
    slice.len()
}
}
</pre> <p>Inert helper attributes used by procedural macro attributes applied to items are also allowed but be careful to not include these inert attributes in your final <code>TokenStream</code>.</p> <p>For example, the following code defines an inert <code>some_inert_attribute</code> attribute that is not formally defined anywhere and the <code>some_proc_macro_attribute</code> procedural macro is responsible for detecting its presence and removing it from the output token stream.</p>  <pre data-language="rust">#[some_proc_macro_attribute]
fn foo_oof(#[some_inert_attribute] arg: u8) {
}
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/items/functions.html" class="_attribution-link">https://doc.rust-lang.org/reference/items/functions.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
