
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>8.2. Expressions - Rust - W3cubDocs</title>
  
  <meta name="description" content=" Syntax Expression &#58; ExpressionWithoutBlock | ExpressionWithBlock ">
  <meta name="keywords" content="expressions, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rust/reference/expressions.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/rust.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rust">
				
				
<h1>Expressions</h1> <blockquote> <p><strong><sup>Syntax</sup></strong><br> <em>Expression</em> :<br> <em>ExpressionWithoutBlock</em><br> | <em>ExpressionWithBlock</em></p> <p><em>ExpressionWithoutBlock</em> :<br> <a href="attributes"><em>OuterAttribute</em></a><sup>*</sup><a href="#expression-attributes">†</a><br> (<br> <a href="expressions/literal-expr"><em>LiteralExpression</em></a><br> | <a href="expressions/path-expr"><em>PathExpression</em></a><br> | <a href="expressions/operator-expr"><em>OperatorExpression</em></a><br> | <a href="expressions/grouped-expr"><em>GroupedExpression</em></a><br> | <a href="expressions/array-expr"><em>ArrayExpression</em></a><br> | <a href="expressions/await-expr"><em>AwaitExpression</em></a><br> | <a href="expressions/array-expr#array-and-slice-indexing-expressions"><em>IndexExpression</em></a><br> | <a href="expressions/tuple-expr"><em>TupleExpression</em></a><br> | <a href="expressions/tuple-expr#tuple-indexing-expressions"><em>TupleIndexingExpression</em></a><br> | <a href="expressions/struct-expr"><em>StructExpression</em></a><br> | <a href="expressions/enum-variant-expr"><em>EnumerationVariantExpression</em></a><br> | <a href="expressions/call-expr"><em>CallExpression</em></a><br> | <a href="expressions/method-call-expr"><em>MethodCallExpression</em></a><br> | <a href="expressions/field-expr"><em>FieldExpression</em></a><br> | <a href="expressions/closure-expr"><em>ClosureExpression</em></a><br> | <a href="expressions/loop-expr#continue-expressions"><em>ContinueExpression</em></a><br> | <a href="expressions/loop-expr#break-expressions"><em>BreakExpression</em></a><br> | <a href="expressions/range-expr"><em>RangeExpression</em></a><br> | <a href="expressions/return-expr"><em>ReturnExpression</em></a><br> | <a href="macros#macro-invocation"><em>MacroInvocation</em></a><br> )</p> <p><em>ExpressionWithBlock</em> :<br> <a href="attributes"><em>OuterAttribute</em></a><sup>*</sup><a href="#expression-attributes">†</a><br> (<br> <a href="expressions/block-expr"><em>BlockExpression</em></a><br> | <a href="expressions/block-expr#async-blocks"><em>AsyncBlockExpression</em></a><br> | <a href="expressions/block-expr#unsafe-blocks"><em>UnsafeBlockExpression</em></a><br> | <a href="expressions/loop-expr"><em>LoopExpression</em></a><br> | <a href="expressions/if-expr#if-expressions"><em>IfExpression</em></a><br> | <a href="expressions/if-expr#if-let-expressions"><em>IfLetExpression</em></a><br> | <a href="expressions/match-expr"><em>MatchExpression</em></a><br> )</p> </blockquote> <p>An expression may have two roles: it always produces a <em>value</em>, and it may have <em>effects</em> (otherwise known as "side effects"). An expression <em>evaluates to</em> a value, and has effects during <em>evaluation</em>. Many expressions contain sub-expressions (operands). The meaning of each kind of expression dictates several things:</p> <ul> <li>Whether or not to evaluate the sub-expressions when evaluating the expression</li> <li>The order in which to evaluate the sub-expressions</li> <li>How to combine the sub-expressions' values to obtain the value of the expression</li> </ul> <p>In this way, the structure of expressions dictates the structure of execution. Blocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.</p> <h2>Expression precedence</h2> <p>The precedence of Rust operators and expressions is ordered as follows, going from strong to weak. Binary Operators at the same precedence level are grouped in the order given by their associativity.</p> <table>
<thead><tr>
<th>Operator/Expression</th>
<th>Associativity</th>
</tr></thead>
<tbody> <tr>
<td>Paths</td>
<td></td>
</tr> <tr>
<td>Method calls</td>
<td></td>
</tr> <tr>
<td>Field expressions</td>
<td>left to right</td>
</tr> <tr>
<td>Function calls, array indexing</td>
<td></td>
</tr> <tr>
<td><code>?</code></td>
<td></td>
</tr> <tr>
<td>Unary <code>-</code> <code>*</code> <code>!</code> <code>&amp;</code> <code>&amp;mut</code>
</td>
<td></td>
</tr> <tr>
<td><code>as</code></td>
<td>left to right</td>
</tr> <tr>
<td>
<code>*</code> <code>/</code> <code>%</code>
</td>
<td>left to right</td>
</tr> <tr>
<td>
<code>+</code> <code>-</code>
</td>
<td>left to right</td>
</tr> <tr>
<td>
<code>&lt;&lt;</code> <code>&gt;&gt;</code>
</td>
<td>left to right</td>
</tr> <tr>
<td><code>&amp;</code></td>
<td>left to right</td>
</tr> <tr>
<td><code>^</code></td>
<td>left to right</td>
</tr> <tr>
<td><code>|</code></td>
<td>left to right</td>
</tr> <tr>
<td>
<code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code>
</td>
<td>Require parentheses</td>
</tr> <tr>
<td><code>&amp;&amp;</code></td>
<td>left to right</td>
</tr> <tr>
<td><code>||</code></td>
<td>left to right</td>
</tr> <tr>
<td>
<code>..</code> <code>..=</code>
</td>
<td>Require parentheses</td>
</tr> <tr>
<td>
<code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <br> <code>&amp;=</code> <code>|=</code> <code>^=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code>
</td>
<td>right to left</td>
</tr> <tr>
<td>
<code>return</code> <code>break</code> closures</td>
<td></td>
</tr> </tbody>
</table> <h2>Place Expressions and Value Expressions</h2> <p>Expressions are divided into two main categories: place expressions and value expressions. Likewise within each expression, sub-expressions may occur in either place context or value context. The evaluation of an expression depends both on its own category and the context it occurs within.</p> <p>A <em>place expression</em> is an expression that represents a memory location. These expressions are <a href="expressions/path-expr">paths</a> which refer to local variables, <a href="items/static-items">static variables</a>, <a href="expressions/operator-expr#the-dereference-operator">dereferences</a> (<code>*expr</code>), <a href="expressions/array-expr#array-and-slice-indexing-expressions">array indexing</a> expressions (<code>expr[expr]</code>), <a href="expressions/field-expr">field</a> references (<code>expr.f</code>) and parenthesized place expressions. All other expressions are value expressions.</p> <p>A <em>value expression</em> is an expression that represents an actual value.</p> <p>The following contexts are <em>place expression</em> contexts:</p> <ul> <li>The left operand of an <a href="expressions/operator-expr#assignment-expressions">assignment</a> or <a href="expressions/operator-expr#compound-assignment-expressions">compound assignment</a> expression.</li> <li>The operand of a unary <a href="expressions/operator-expr#borrow-operators">borrow</a> or <a href="expressions/operator-expr#the-dereference-operator">dereference</a> operator.</li> <li>The operand of a field expression.</li> <li>The indexed operand of an array indexing expression.</li> <li>The operand of any <a href="#implicit-borrows">implicit borrow</a>.</li> <li>The initializer of a <a href="statements#let-statements">let statement</a>.</li> <li>The <a href="glossary#scrutinee">scrutinee</a> of an <a href="expressions/if-expr#if-let-expressions"><code>if let</code></a>, <a href="expressions/match-expr"><code>match</code></a>, or <a href="expressions/loop-expr#predicate-pattern-loops"><code>while let</code></a> expression.</li> <li>The base of a <a href="expressions/struct-expr#functional-update-syntax">functional update</a> struct expression.</li> </ul> <blockquote> <p>Note: Historically, place expressions were called <em>lvalues</em> and value expressions were called <em>rvalues</em>.</p> </blockquote> <h3>Moved and copied types</h3> <p>When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held <em>in</em> that memory location. If the type of that value implements <a href="special-types-and-traits#copy"><code>Copy</code></a>, then the value will be copied. In the remaining situations if that type is <a href="special-types-and-traits#sized"><code>Sized</code></a>, then it may be possible to move the value. Only the following place expressions may be moved out of:</p> <ul> <li>
<a href="variables">Variables</a> which are not currently borrowed.</li> <li>
<a href="#temporaries">Temporary values</a>.</li> <li>
<a href="expressions/field-expr">Fields</a> of a place expression which can be moved out of and doesn't implement <a href="special-types-and-traits#drop"><code>Drop</code></a>.</li> <li>The result of <a href="expressions/operator-expr#the-dereference-operator">dereferencing</a> an expression with type <a href="../std/boxed/struct.box"><code>Box&lt;T&gt;</code></a> and that can also be moved out of.</li> </ul> <p>Moving out of a place expression that evaluates to a local variable, the location is deinitialized and cannot be read from again until it is reinitialized. In all other cases, trying to use a place expression in a value expression context is an error.</p> <h3>Mutability</h3> <p>For a place expression to be <a href="expressions/operator-expr#assignment-expressions">assigned</a> to, mutably <a href="expressions/operator-expr#borrow-operators">borrowed</a>, <a href="#implicit-borrows">implicitly mutably borrowed</a>, or bound to a pattern containing <code>ref mut</code> it must be <em>mutable</em>. We call these <em>mutable place expressions</em>. In contrast, other place expressions are called <em>immutable place expressions</em>.</p> <p>The following expressions can be mutable place expression contexts:</p> <ul> <li>Mutable <a href="variables">variables</a>, which are not currently borrowed.</li> <li>
<a href="items/static-items#mutable-statics">Mutable <code>static</code> items</a>.</li> <li>
<a href="#temporaries">Temporary values</a>.</li> <li>
<a href="expressions/field-expr">Fields</a>, this evaluates the subexpression in a mutable place expression context.</li> <li>
<a href="expressions/operator-expr#the-dereference-operator">Dereferences</a> of a <code>*mut T</code> pointer.</li> <li>Dereference of a variable, or field of a variable, with type <code>&amp;mut T</code>. Note: This is an exception to the requirement of the next rule.</li> <li>Dereferences of a type that implements <code>DerefMut</code>, this then requires that the value being dereferenced is evaluated is a mutable place expression context.</li> <li>
<a href="expressions/array-expr#array-and-slice-indexing-expressions">Array indexing</a> of a type that implements <code>IndexMut</code>, this then evaluates the value being indexed, but not the index, in mutable place expression context.</li> </ul> <h3>Temporaries</h3> <p>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if <a href="destructors#constant-promotion">promoted</a> to a <code>static</code>. The <a href="destructors#drop-scopes">drop scope</a> of the temporary is usually the end of the enclosing statement.</p> <h3>Implicit Borrows</h3> <p>Certain expressions will treat an expression as a place expression by implicitly borrowing it. For example, it is possible to compare two unsized <a href="types/slice">slices</a> for equality directly, because the <code>==</code> operator implicitly borrows it's operands:</p> <pre data-language="rust">
#![allow(unused)]
fn main() {
let c = [1, 2, 3];
let d = vec![1, 2, 3];
let a: &amp;[i32];
let b: &amp;[i32];
a = &amp;c;
b = &amp;d;
// ...
*a == *b;
// Equivalent form:
::std::cmp::PartialEq::eq(&amp;*a, &amp;*b);
}
</pre> <p>Implicit borrows may be taken in the following expressions:</p> <ul> <li>Left operand in <a href="expressions/method-call-expr">method-call</a> expressions.</li> <li>Left operand in <a href="expressions/field-expr">field</a> expressions.</li> <li>Left operand in <a href="expressions/call-expr">call expressions</a>.</li> <li>Left operand in <a href="expressions/array-expr#array-and-slice-indexing-expressions">array indexing</a> expressions.</li> <li>Operand of the <a href="expressions/operator-expr#the-dereference-operator">dereference operator</a> (<code>*</code>).</li> <li>Operands of <a href="expressions/operator-expr#comparison-operators">comparison</a>.</li> <li>Left operands of the <a href="expressions/operator-expr#compound-assignment-expressions">compound assignment</a>.</li> </ul> <h2>Overloading Traits</h2> <p>Many of the following operators and expressions can also be overloaded for other types using traits in <code>std::ops</code> or <code>std::cmp</code>. These traits also exist in <code>core::ops</code> and <code>core::cmp</code> with the same names.</p> <h2>Expression Attributes</h2> <p><a href="attributes">Outer attributes</a> before an expression are allowed only in a few specific cases:</p> <ul> <li>Before an expression used as a <a href="statements">statement</a>.</li> <li>Elements of <a href="expressions/array-expr">array expressions</a>, <a href="expressions/tuple-expr">tuple expressions</a>, <a href="expressions/call-expr">call expressions</a>, and tuple-style <a href="expressions/struct-expr">struct</a> and <a href="expressions/enum-variant-expr">enum variant</a> expressions. </li> <li>The tail expression of <a href="expressions/block-expr">block expressions</a>.</li> </ul>  <p>They are never allowed before:</p> <ul> <li>
<a href="expressions/range-expr">Range</a> expressions.</li> <li>Binary operator expressions (<a href="expressions/operator-expr#arithmetic-and-logical-binary-operators"><em>ArithmeticOrLogicalExpression</em></a>, <a href="expressions/operator-expr#comparison-operators"><em>ComparisonExpression</em></a>, <a href="expressions/operator-expr#lazy-boolean-operators"><em>LazyBooleanExpression</em></a>, <a href="expressions/operator-expr#type-cast-expressions"><em>TypeCastExpression</em></a>, <a href="expressions/operator-expr#assignment-expressions"><em>AssignmentExpression</em></a>, <a href="expressions/operator-expr#compound-assignment-expressions"><em>CompoundAssignmentExpression</em></a>).</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/expressions.html" class="_attribution-link">https://doc.rust-lang.org/reference/expressions.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
