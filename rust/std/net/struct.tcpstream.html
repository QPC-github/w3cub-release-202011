
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std&#58;&#58;net&#58;&#58;TcpStream - Rust - W3cubDocs</title>
  
  <meta name="description" content=" A TCP stream between a local and a remote socket. ">
  <meta name="keywords" content="struct, std, net, tcpstream, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rust/std/net/struct.tcpstream.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rust">
				
				
<h1 class="fqn">Struct std::net::TcpStream</h1>
<pre class="rust struct" data-language="rust">pub struct TcpStream(_);</pre>
<p>A TCP stream between a local and a remote socket.</p> <p>After creating a <code>TcpStream</code> by either <a href="struct.tcpstream#method.connect"><code>connect</code></a>ing to a remote host or <a href="struct.tcplistener#method.accept"><code>accept</code></a>ing a connection on a <a href="struct.tcplistener" title="`TcpListener`"><code>TcpListener</code></a>, data can be transmitted by <a href="../io/trait.read">reading</a> and <a href="../io/trait.write">writing</a> to it.</p> <p>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the <a href="struct.tcpstream#method.shutdown"><code>shutdown</code></a> method.</p> <p>The Transmission Control Protocol is specified in <a href="https://tools.ietf.org/html/rfc793">IETF RFC 793</a>.</p> <h2 id="examples" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::io::prelude::*;
use std::net::TcpStream;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let mut stream = TcpStream::connect("127.0.0.1:34254")?;

    stream.write(&amp;[1])?;
    stream.read(&amp;mut [0; 128])?;
    Ok(())
} // the stream is closed here</pre></div> <h2 id="implementations" class="small-section-header">Implementations</h2>
<h3 id="impl" class="impl">
<code class="in-band">impl <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#95-543" title="goto source code">[src]</a>
</h3>
<h4 id="method.connect" class="method">
<code>pub fn <a href="#method.connect" class="fnname">connect</a>&lt;A: <a class="trait" href="trait.tosocketaddrs" title="trait std::net::ToSocketAddrs">ToSocketAddrs</a>&gt;(addr: A) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#138-140" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Opens a TCP connection to a remote host.</p> <p><code>addr</code> is an address of the remote host. Anything which implements <a href="trait.tosocketaddrs" title="`ToSocketAddrs`"><code>ToSocketAddrs</code></a> trait can be supplied for the address; see this trait documentation for concrete examples.</p> <p>If <code>addr</code> yields multiple addresses, <code>connect</code> will be attempted with each of the addresses until a connection is successful. If none of the addresses result in a successful connection, the error returned from the last connection attempt (the last address) is returned.</p> <h2 id="examples-1" class="section-header">Examples</h2> <p>Open a TCP connection to <code>127.0.0.1:8080</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::TcpStream;

if let Ok(stream) = TcpStream::connect("127.0.0.1:8080") {
    println!("Connected to the server!");
} else {
    println!("Couldn't connect to server...");
}</pre></div> <p>Open a TCP connection to <code>127.0.0.1:8080</code>. If the connection fails, open a TCP connection to <code>127.0.0.1:8081</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::{SocketAddr, TcpStream};

let addrs = [
    SocketAddr::from(([127, 0, 0, 1], 8080)),
    SocketAddr::from(([127, 0, 0, 1], 8081)),
];
if let Ok(stream) = TcpStream::connect(&amp;addrs[..]) {
    println!("Connected to the server!");
} else {
    println!("Couldn't connect to server...");
}</pre></div> </div>
<h4 id="method.connect_timeout" class="method">
<code>pub fn <a href="#method.connect_timeout" class="fnname">connect_timeout</a>(<br>    addr: &amp;<a class="enum" href="enum.socketaddr" title="enum std::net::SocketAddr">SocketAddr</a>, <br>    timeout: <a class="struct" href="../time/struct.duration" title="struct std::time::Duration">Duration</a><br>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#154-156" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span>
</h4>
<div class="docblock">
<p>Opens a TCP connection to a remote host with a timeout.</p> <p>Unlike <code>connect</code>, <code>connect_timeout</code> takes a single <a href="enum.socketaddr" title="`SocketAddr`"><code>SocketAddr</code></a> since timeout must be applied to individual addresses.</p> <p>It is an error to pass a zero <code>Duration</code> to this function.</p> <p>Unlike other methods on <code>TcpStream</code>, this does not correspond to a single system call. It instead calls <code>connect</code> in nonblocking mode and then uses an OS-specific mechanism to await the completion of the connection request.</p> </div>
<h4 id="method.peer_addr" class="method">
<code>pub fn <a href="#method.peer_addr" class="fnname">peer_addr</a>(&amp;self) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="enum" href="enum.socketaddr" title="enum std::net::SocketAddr">SocketAddr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#171-173" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns the socket address of the remote peer of this TCP connection.</p> <h2 id="examples-2" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, TcpStream};

let stream = TcpStream::connect("127.0.0.1:8080")
                       .expect("Couldn't connect to the server...");
assert_eq!(stream.peer_addr().unwrap(),
           SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080)));</pre></div> </div>
<h4 id="method.local_addr" class="method">
<code>pub fn <a href="#method.local_addr" class="fnname">local_addr</a>(&amp;self) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="enum" href="enum.socketaddr" title="enum std::net::SocketAddr">SocketAddr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#188-190" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns the socket address of the local half of this TCP connection.</p> <h2 id="examples-3" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::{IpAddr, Ipv4Addr, TcpStream};

let stream = TcpStream::connect("127.0.0.1:8080")
                       .expect("Couldn't connect to the server...");
assert_eq!(stream.local_addr().unwrap().ip(),
           IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));</pre></div> </div>
<h4 id="method.shutdown" class="method">
<code>pub fn <a href="#method.shutdown" class="fnname">shutdown</a>(&amp;self, how: <a class="enum" href="enum.shutdown" title="enum std::net::Shutdown">Shutdown</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#215-217" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Shuts down the read, write, or both halves of this connection.</p> <p>This function will cause all pending and future I/O on the specified portions to return immediately with an appropriate value (see the documentation of <a href="enum.shutdown" title="`Shutdown`"><code>Shutdown</code></a>).</p> <h2 id="platform-specific-behavior" class="section-header">Platform-specific behavior</h2> <p>Calling this function multiple times may result in different behavior, depending on the operating system. On Linux, the second call will return <code>Ok(())</code>, but on macOS, it will return <code>ErrorKind::NotConnected</code>. This may change in the future.</p> <h2 id="examples-4" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::{Shutdown, TcpStream};

let stream = TcpStream::connect("127.0.0.1:8080")
                       .expect("Couldn't connect to the server...");
stream.shutdown(Shutdown::Both).expect("shutdown call failed");</pre></div> </div>
<h4 id="method.try_clone" class="method">
<code>pub fn <a href="#method.try_clone" class="fnname">try_clone</a>(&amp;self) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#236-238" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Creates a new independently owned handle to the underlying socket.</p> <p>The returned <code>TcpStream</code> is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</p> <h2 id="examples-5" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::TcpStream;

let stream = TcpStream::connect("127.0.0.1:8080")
                       .expect("Couldn't connect to the server...");
let stream_clone = stream.try_clone().expect("clone failed...");</pre></div> </div>
<h4 id="method.set_read_timeout" class="method">
<code>pub fn <a href="#method.set_read_timeout" class="fnname">set_read_timeout</a>(&amp;self, dur: <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="struct" href="../time/struct.duration" title="struct std::time::Duration">Duration</a>&gt;) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#280-282" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span>
</h4>
<div class="docblock">
<p>Sets the read timeout to the timeout specified.</p> <p>If the value specified is <a href="../option/enum.option#variant.None" title="`None`"><code>None</code></a>, then <a href="../io/trait.read#tymethod.read"><code>read</code></a> calls will block indefinitely. An <a href="../result/enum.result#variant.Err" title="`Err`"><code>Err</code></a> is returned if the zero <a href="../time/struct.duration" title="`Duration`"><code>Duration</code></a> is passed to this method.</p> <h2 id="platform-specific-behavior-1" class="section-header">Platform-specific behavior</h2> <p>Platforms may return a different error code whenever a read times out as a result of setting this option. For example Unix typically returns an error of the kind <a href="../io/enum.errorkind#variant.WouldBlock"><code>WouldBlock</code></a>, but Windows may return <a href="../io/enum.errorkind#variant.TimedOut"><code>TimedOut</code></a>.</p> <h2 id="examples-6" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::TcpStream;

let stream = TcpStream::connect("127.0.0.1:8080")
                       .expect("Couldn't connect to the server...");
stream.set_read_timeout(None).expect("set_read_timeout call failed");</pre></div> <p>An <a href="../result/enum.result#variant.Err" title="`Err`"><code>Err</code></a> is returned if the zero <a href="../time/struct.duration" title="`Duration`"><code>Duration</code></a> is passed to this method:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::io;
use std::net::TcpStream;
use std::time::Duration;

let stream = TcpStream::connect("127.0.0.1:8080").unwrap();
let result = stream.set_read_timeout(Some(Duration::new(0, 0)));
let err = result.unwrap_err();
assert_eq!(err.kind(), io::ErrorKind::InvalidInput)</pre></div> </div>
<h4 id="method.set_write_timeout" class="method">
<code>pub fn <a href="#method.set_write_timeout" class="fnname">set_write_timeout</a>(&amp;self, dur: <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="struct" href="../time/struct.duration" title="struct std::time::Duration">Duration</a>&gt;) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#324-326" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span>
</h4>
<div class="docblock">
<p>Sets the write timeout to the timeout specified.</p> <p>If the value specified is <a href="../option/enum.option#variant.None" title="`None`"><code>None</code></a>, then <a href="../io/trait.write#tymethod.write"><code>write</code></a> calls will block indefinitely. An <a href="../result/enum.result#variant.Err" title="`Err`"><code>Err</code></a> is returned if the zero <a href="../time/struct.duration" title="`Duration`"><code>Duration</code></a> is passed to this method.</p> <h2 id="platform-specific-behavior-2" class="section-header">Platform-specific behavior</h2> <p>Platforms may return a different error code whenever a write times out as a result of setting this option. For example Unix typically returns an error of the kind <a href="../io/enum.errorkind#variant.WouldBlock"><code>WouldBlock</code></a>, but Windows may return <a href="../io/enum.errorkind#variant.TimedOut"><code>TimedOut</code></a>.</p> <h2 id="examples-7" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::TcpStream;

let stream = TcpStream::connect("127.0.0.1:8080")
                       .expect("Couldn't connect to the server...");
stream.set_write_timeout(None).expect("set_write_timeout call failed");</pre></div> <p>An <a href="../result/enum.result#variant.Err" title="`Err`"><code>Err</code></a> is returned if the zero <a href="../time/struct.duration" title="`Duration`"><code>Duration</code></a> is passed to this method:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::io;
use std::net::TcpStream;
use std::time::Duration;

let stream = TcpStream::connect("127.0.0.1:8080").unwrap();
let result = stream.set_write_timeout(Some(Duration::new(0, 0)));
let err = result.unwrap_err();
assert_eq!(err.kind(), io::ErrorKind::InvalidInput)</pre></div> </div>
<h4 id="method.read_timeout" class="method">
<code>pub fn <a href="#method.read_timeout" class="fnname">read_timeout</a>(&amp;self) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="struct" href="../time/struct.duration" title="struct std::time::Duration">Duration</a>&gt;&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#349-351" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span>
</h4>
<div class="docblock">
<p>Returns the read timeout of this socket.</p> <p>If the timeout is <a href="../option/enum.option#variant.None" title="`None`"><code>None</code></a>, then <a href="../io/trait.read#tymethod.read"><code>read</code></a> calls will block indefinitely.</p> <h2 id="platform-specific-behavior-3" class="section-header">Platform-specific behavior</h2> <p>Some platforms do not provide access to the current timeout.</p> <h2 id="examples-8" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::TcpStream;

let stream = TcpStream::connect("127.0.0.1:8080")
                       .expect("Couldn't connect to the server...");
stream.set_read_timeout(None).expect("set_read_timeout call failed");
assert_eq!(stream.read_timeout().unwrap(), None);</pre></div> </div>
<h4 id="method.write_timeout" class="method">
<code>pub fn <a href="#method.write_timeout" class="fnname">write_timeout</a>(&amp;self) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="struct" href="../time/struct.duration" title="struct std::time::Duration">Duration</a>&gt;&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#374-376" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span>
</h4>
<div class="docblock">
<p>Returns the write timeout of this socket.</p> <p>If the timeout is <a href="../option/enum.option#variant.None" title="`None`"><code>None</code></a>, then <a href="../io/trait.write#tymethod.write"><code>write</code></a> calls will block indefinitely.</p> <h2 id="platform-specific-behavior-4" class="section-header">Platform-specific behavior</h2> <p>Some platforms do not provide access to the current timeout.</p> <h2 id="examples-9" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::TcpStream;

let stream = TcpStream::connect("127.0.0.1:8080")
                       .expect("Couldn't connect to the server...");
stream.set_write_timeout(None).expect("set_write_timeout call failed");
assert_eq!(stream.write_timeout().unwrap(), None);</pre></div> </div>
<h4 id="method.peek" class="method">
<code>pub fn <a href="#method.peek" class="fnname">peek</a>(&amp;self, buf: <a class="primitive" href="../primitive.slice">&amp;mut [</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#396-398" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.18.0">1.18.0</span>
</h4>
<div class="docblock">
<p>Receives data on the socket from the remote address to which it is connected, without removing that data from the queue. On success, returns the number of bytes peeked.</p> <p>Successive calls return the same data. This is accomplished by passing <code>MSG_PEEK</code> as a flag to the underlying <code>recv</code> system call.</p> <h2 id="examples-10" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::TcpStream;

let stream = TcpStream::connect("127.0.0.1:8000")
                       .expect("couldn't bind to address");
let mut buf = [0; 10];
let len = stream.peek(&amp;mut buf).expect("peek failed");</pre></div> </div>
<h4 id="method.set_nodelay" class="method">
<code>pub fn <a href="#method.set_nodelay" class="fnname">set_nodelay</a>(&amp;self, nodelay: <a class="primitive" href="../primitive.bool">bool</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#418-420" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span>
</h4>
<div class="docblock">
<p>Sets the value of the <code>TCP_NODELAY</code> option on this socket.</p> <p>If set, this option disables the Nagle algorithm. This means that segments are always sent as soon as possible, even if there is only a small amount of data. When not set, data is buffered until there is a sufficient amount to send out, thereby avoiding the frequent sending of small packets.</p> <h2 id="examples-11" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::TcpStream;

let stream = TcpStream::connect("127.0.0.1:8080")
                       .expect("Couldn't connect to the server...");
stream.set_nodelay(true).expect("set_nodelay call failed");</pre></div> </div>
<h4 id="method.nodelay" class="method">
<code>pub fn <a href="#method.nodelay" class="fnname">nodelay</a>(&amp;self) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.bool">bool</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#437-439" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span>
</h4>
<div class="docblock">
<p>Gets the value of the <code>TCP_NODELAY</code> option on this socket.</p> <p>For more information about this option, see <a href="struct.tcpstream#method.set_nodelay" title="`TcpStream::set_nodelay`"><code>TcpStream::set_nodelay</code></a>.</p> <h2 id="examples-12" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::TcpStream;

let stream = TcpStream::connect("127.0.0.1:8080")
                       .expect("Couldn't connect to the server...");
stream.set_nodelay(true).expect("set_nodelay call failed");
assert_eq!(stream.nodelay().unwrap_or(false), true);</pre></div> </div>
<h4 id="method.set_ttl" class="method">
<code>pub fn <a href="#method.set_ttl" class="fnname">set_ttl</a>(&amp;self, ttl: <a class="primitive" href="../primitive.u32">u32</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#456-458" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span>
</h4>
<div class="docblock">
<p>Sets the value for the <code>IP_TTL</code> option on this socket.</p> <p>This value sets the time-to-live field that is used in every packet sent from this socket.</p> <h2 id="examples-13" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::TcpStream;

let stream = TcpStream::connect("127.0.0.1:8080")
                       .expect("Couldn't connect to the server...");
stream.set_ttl(100).expect("set_ttl call failed");</pre></div> </div>
<h4 id="method.ttl" class="method">
<code>pub fn <a href="#method.ttl" class="fnname">ttl</a>(&amp;self) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.u32">u32</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#475-477" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span>
</h4>
<div class="docblock">
<p>Gets the value of the <code>IP_TTL</code> option for this socket.</p> <p>For more information about this option, see <a href="struct.tcpstream#method.set_ttl" title="`TcpStream::set_ttl`"><code>TcpStream::set_ttl</code></a>.</p> <h2 id="examples-14" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::TcpStream;

let stream = TcpStream::connect("127.0.0.1:8080")
                       .expect("Couldn't connect to the server...");
stream.set_ttl(100).expect("set_ttl call failed");
assert_eq!(stream.ttl().unwrap_or(0), 100);</pre></div> </div>
<h4 id="method.take_error" class="method">
<code>pub fn <a href="#method.take_error" class="fnname">take_error</a>(&amp;self) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="struct" href="../io/struct.error" title="struct std::io::Error">Error</a>&gt;&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#495-497" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span>
</h4>
<div class="docblock">
<p>Gets the value of the <code>SO_ERROR</code> option on this socket.</p> <p>This will retrieve the stored error in the underlying socket, clearing the field in the process. This can be useful for checking errors between calls.</p> <h2 id="examples-15" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::net::TcpStream;

let stream = TcpStream::connect("127.0.0.1:8080")
                       .expect("Couldn't connect to the server...");
stream.take_error().expect("No error was expected...");</pre></div> </div>
<h4 id="method.set_nonblocking" class="method">
<code>pub fn <a href="#method.set_nonblocking" class="fnname">set_nonblocking</a>(&amp;self, nonblocking: <a class="primitive" href="../primitive.bool">bool</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#540-542" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span>
</h4>
<div class="docblock">
<p>Moves this TCP stream into or out of nonblocking mode.</p> <p>This will result in <code>read</code>, <code>write</code>, <code>recv</code> and <code>send</code> operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, <code>Ok</code> is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind <a href="../io/enum.errorkind#variant.WouldBlock" title="`io::ErrorKind::WouldBlock`"><code>io::ErrorKind::WouldBlock</code></a> is returned.</p> <p>On Unix platforms, calling this method corresponds to calling <code>fcntl</code> <code>FIONBIO</code>. On Windows calling this method corresponds to calling <code>ioctlsocket</code> <code>FIONBIO</code>.</p> <h2 id="examples-16" class="section-header">Examples</h2> <p>Reading bytes from a TCP stream in non-blocking mode:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::io::{self, Read};
use std::net::TcpStream;

let mut stream = TcpStream::connect("127.0.0.1:7878")
    .expect("Couldn't connect to the server...");
stream.set_nonblocking(true).expect("set_nonblocking call failed");

let mut buf = vec![];
loop {
    match stream.read_to_end(&amp;mut buf) {
        Ok(_) =&gt; break,
        Err(ref e) if e.kind() == io::ErrorKind::WouldBlock =&gt; {
            // wait until network socket is ready, typically implemented
            // via platform-specific APIs such as epoll or IOCP
            wait_for_fd();
        }
        Err(e) =&gt; panic!("encountered IO error: {}", e),
    };
};
println!("bytes: {:?}", buf);</pre></div> </div>
<h2 id="trait-implementations" class="small-section-header">Trait Implementations</h2>
<div id="trait-implementations-list">
<h3 id="impl-AsRawFd" class="impl">
<code class="in-band">impl <a class="trait" href="../os/unix/io/trait.asrawfd" title="trait std::os::unix::io::AsRawFd">AsRawFd</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/sys/unix/ext/net.rs.html#700-704" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.as_raw_fd" class="method hidden">
<code>fn <a href="../os/unix/io/trait.asrawfd#tymethod.as_raw_fd" class="fnname">as_raw_fd</a>(&amp;self) -&gt; <a class="type" href="../os/unix/io/type.rawfd" title="type std::os::unix::io::RawFd">RawFd</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/sys/unix/ext/net.rs.html#701-703" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab portability">This is supported on Unix only.</span></div>
<div class="docblock hidden">
<p>Extracts the raw file descriptor. <a href="../os/unix/io/trait.asrawfd#tymethod.as_raw_fd">Read more</a></p> </div>
</div>
<h3 id="impl-AsRawSocket" class="impl">
<code class="in-band">impl <a class="trait" href="../os/windows/io/trait.asrawsocket" title="trait std::os::windows::io::AsRawSocket">AsRawSocket</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/sys/windows/ext/io.rs.html#161-165" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.as_raw_socket" class="method hidden">
<code>fn <a href="../os/windows/io/trait.asrawsocket#tymethod.as_raw_socket" class="fnname">as_raw_socket</a>(&amp;self) -&gt; <a class="type" href="../os/windows/io/type.rawsocket" title="type std::os::windows::io::RawSocket">RawSocket</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/sys/windows/ext/io.rs.html#162-164" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab portability">This is supported on Windows only.</span></div>
<div class="docblock hidden">
<p>Extracts the underlying raw socket from this object.</p> </div>
</div>
<h3 id="impl-Debug" class="impl">
<code class="in-band">impl <a class="trait" href="../fmt/trait.debug" title="trait std::fmt::Debug">Debug</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#645-649" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.fmt" class="method hidden">
<code>fn <a href="../fmt/trait.debug#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../fmt/struct.formatter" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="../fmt/type.result" title="type std::fmt::Result">Result</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#646-648" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Formats the value using the given formatter. <a href="../fmt/trait.debug#tymethod.fmt">Read more</a></p> </div>
</div>
<h3 id="impl-FromRawFd" class="impl">
<code class="in-band">impl <a class="trait" href="../os/unix/io/trait.fromrawfd" title="trait std::os::unix::io::FromRawFd">FromRawFd</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/sys/unix/ext/net.rs.html#721-726" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from_raw_fd" class="method hidden">
<code>unsafe fn <a href="../os/unix/io/trait.fromrawfd#tymethod.from_raw_fd" class="fnname">from_raw_fd</a>(fd: <a class="type" href="../os/unix/io/type.rawfd" title="type std::os::unix::io::RawFd">RawFd</a>) -&gt; <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for TcpStream</h3>
<pre class="content">impl Read for TcpStream
impl&lt;'_&gt; Read for &amp;'_ TcpStream
impl Write for TcpStream
impl&lt;'_&gt; Write for &amp;'_ TcpStream
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/sys/unix/ext/net.rs.html#722-725" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab portability">This is supported on Unix only.</span></div>
<div class="docblock hidden">
<p>Constructs a new instance of <code>Self</code> from the given raw file descriptor. <a href="../os/unix/io/trait.fromrawfd#tymethod.from_raw_fd">Read more</a></p> </div>
</div>
<h3 id="impl-FromRawSocket" class="impl">
<code class="in-band">impl <a class="trait" href="../os/windows/io/trait.fromrawsocket" title="trait std::os::windows::io::FromRawSocket">FromRawSocket</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/sys/windows/ext/io.rs.html#180-185" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from_raw_socket" class="method hidden">
<code>unsafe fn <a href="../os/windows/io/trait.fromrawsocket#tymethod.from_raw_socket" class="fnname">from_raw_socket</a>(sock: <a class="type" href="../os/windows/io/type.rawsocket" title="type std::os::windows::io::RawSocket">RawSocket</a>) -&gt; <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for TcpStream</h3>
<pre class="content">impl Read for TcpStream
impl&lt;'_&gt; Read for &amp;'_ TcpStream
impl Write for TcpStream
impl&lt;'_&gt; Write for &amp;'_ TcpStream
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/sys/windows/ext/io.rs.html#181-184" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab portability">This is supported on Windows only.</span></div>
<div class="docblock hidden">
<p>Creates a new I/O object from the given raw socket. <a href="../os/windows/io/trait.fromrawsocket#tymethod.from_raw_socket">Read more</a></p> </div>
</div>
<h3 id="impl-IntoRawFd" class="impl">
<code class="in-band">impl <a class="trait" href="../os/unix/io/trait.intorawfd" title="trait std::os::unix::io::IntoRawFd">IntoRawFd</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/sys/unix/ext/net.rs.html#745-749" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span>
</h3>
<div class="impl-items">
<h4 id="method.into_raw_fd" class="method hidden">
<code>fn <a href="../os/unix/io/trait.intorawfd#tymethod.into_raw_fd" class="fnname">into_raw_fd</a>(self) -&gt; <a class="type" href="../os/unix/io/type.rawfd" title="type std::os::unix::io::RawFd">RawFd</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/sys/unix/ext/net.rs.html#746-748" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab portability">This is supported on Unix only.</span></div>
<div class="docblock hidden">
<p>Consumes this object, returning the raw underlying file descriptor. <a href="../os/unix/io/trait.intorawfd#tymethod.into_raw_fd">Read more</a></p> </div>
</div>
<h3 id="impl-IntoRawSocket" class="impl">
<code class="in-band">impl <a class="trait" href="../os/windows/io/trait.intorawsocket" title="trait std::os::windows::io::IntoRawSocket">IntoRawSocket</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/sys/windows/ext/io.rs.html#202-206" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span>
</h3>
<div class="impl-items">
<h4 id="method.into_raw_socket" class="method hidden">
<code>fn <a href="../os/windows/io/trait.intorawsocket#tymethod.into_raw_socket" class="fnname">into_raw_socket</a>(self) -&gt; <a class="type" href="../os/windows/io/type.rawsocket" title="type std::os::windows::io::RawSocket">RawSocket</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/sys/windows/ext/io.rs.html#203-205" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab portability">This is supported on Windows only.</span></div>
<div class="docblock hidden">
<p>Consumes this object, returning the raw underlying socket. <a href="../os/windows/io/trait.intorawsocket#tymethod.into_raw_socket">Read more</a></p> </div>
</div>
<h3 id="impl-Read" class="impl">
<code class="in-band">impl <a class="trait" href="../io/trait.read" title="trait std::io::Read">Read</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#546-565" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.read" class="method hidden">
<code>fn <a href="../io/trait.read#tymethod.read" class="fnname">read</a>(&amp;mut self, buf: <a class="primitive" href="../primitive.slice">&amp;mut [</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#547-549" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Pull some bytes from this source into the specified buffer, returning how many bytes were read. <a href="../io/trait.read#tymethod.read">Read more</a></p> </div>
<h4 id="method.read_vectored" class="method hidden">
<code>fn <a href="../io/trait.read#method.read_vectored" class="fnname">read_vectored</a>(&amp;mut self, bufs: <a class="primitive" href="../primitive.slice">&amp;mut [</a><a class="struct" href="../io/struct.ioslicemut" title="struct std::io::IoSliceMut">IoSliceMut</a>&lt;'_&gt;<a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#551-553" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Like <code>read</code>, except that it reads into a slice of buffers. <a href="../io/trait.read#method.read_vectored">Read more</a></p> </div>
<h4 id="method.is_read_vectored" class="method hidden">
<code>fn <a href="../io/trait.read#method.is_read_vectored" class="fnname">is_read_vectored</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#556-558" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (can_vector #69941)</span></div>
<div class="docblock hidden">
<p>Determines if this <code>Read</code>er has an efficient <code>read_vectored</code> implementation. <a href="../io/trait.read#method.is_read_vectored">Read more</a></p> </div>
<h4 id="method.initializer" class="method hidden">
<code>unsafe fn <a href="../io/trait.read#method.initializer" class="fnname">initializer</a>(&amp;self) -&gt; <a class="struct" href="../io/struct.initializer" title="struct std::io::Initializer">Initializer</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#561-564" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (read_initializer #42788)</span></div>
<div class="docblock hidden">
<p>Determines if this <code>Read</code>er can work with buffers of uninitialized memory. <a href="../io/trait.read#method.initializer">Read more</a></p> </div>
<h4 id="method.read_to_end" class="method hidden">
<code>fn <a href="../io/trait.read#method.read_to_end" class="fnname">read_to_end</a>(&amp;mut self, buf: &amp;mut <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#660-662" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Read all bytes until EOF in this source, placing them into <code>buf</code>. <a href="../io/trait.read#method.read_to_end">Read more</a></p> </div>
<h4 id="method.read_to_string" class="method hidden">
<code>fn <a href="../io/trait.read#method.read_to_string" class="fnname">read_to_string</a>(&amp;mut self, buf: &amp;mut <a class="struct" href="../string/struct.string" title="struct std::string::String">String</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#703-714" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Read all bytes until EOF in this source, appending them to <code>buf</code>. <a href="../io/trait.read#method.read_to_string">Read more</a></p> </div>
<h4 id="method.read_exact" class="method hidden">
<code>fn <a href="../io/trait.read#method.read_exact" class="fnname">read_exact</a>(&amp;mut self, buf: <a class="primitive" href="../primitive.slice">&amp;mut [</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#767-784" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span>
</h4>
<div class="docblock hidden">
<p>Read the exact number of bytes required to fill <code>buf</code>. <a href="../io/trait.read#method.read_exact">Read more</a></p> </div>
<h4 id="method.by_ref" class="method hidden">
<code>fn <a href="../io/trait.read#method.by_ref" class="fnname">by_ref</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.reference">&amp;mut </a>Self<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#821-826" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a "by reference" adaptor for this instance of <code>Read</code>. <a href="../io/trait.read#method.by_ref">Read more</a></p> </div>
<h4 id="method.bytes" class="method hidden">
<code>fn <a href="../io/trait.read#method.bytes" class="fnname">bytes</a>(self) -&gt; <a class="struct" href="../io/struct.bytes" title="struct std::io::Bytes">Bytes</a>&lt;Self&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Bytes&lt;R&gt;</h3>
<pre class="content">impl&lt;R: Read&gt; Iterator for Bytes&lt;R&gt;
    type Item = Result&lt;u8&gt;;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#858-863" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Transforms this <code>Read</code> instance to an <a href="../iter/trait.iterator" title="`Iterator`"><code>Iterator</code></a> over its bytes. <a href="../io/trait.read#method.bytes">Read more</a></p> </div>
<h4 id="method.chain" class="method hidden">
<code>fn <a href="../io/trait.read#method.chain" class="fnname">chain</a>&lt;R: <a class="trait" href="../io/trait.read" title="trait std::io::Read">Read</a>&gt;(self, next: R) -&gt; <a class="struct" href="../io/struct.chain" title="struct std::io::Chain">Chain</a>&lt;Self, R&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Chain&lt;T, U&gt;</h3>
<pre class="content">impl&lt;T: Read, U: Read&gt; Read for Chain&lt;T, U&gt;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#896-901" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates an adaptor which will chain this stream with another. <a href="../io/trait.read#method.chain">Read more</a></p> </div>
<h4 id="method.take" class="method hidden">
<code>fn <a href="../io/trait.read#method.take" class="fnname">take</a>(self, limit: <a class="primitive" href="../primitive.u64">u64</a>) -&gt; <a class="struct" href="../io/struct.take" title="struct std::io::Take">Take</a>&lt;Self&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Take&lt;T&gt;</h3>
<pre class="content">impl&lt;T: Read&gt; Read for Take&lt;T&gt;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#935-940" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates an adaptor which will read at most <code>limit</code> bytes from it. <a href="../io/trait.read#method.take">Read more</a></p> </div>
</div>
<h3 id="impl-Read-1" class="impl">
<code class="in-band">impl&lt;'_&gt; <a class="trait" href="../io/trait.read" title="trait std::io::Read">Read</a> for &amp;'_ <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#586-605" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.read-1" class="method hidden">
<code>fn <a href="../io/trait.read#tymethod.read" class="fnname">read</a>(&amp;mut self, buf: <a class="primitive" href="../primitive.slice">&amp;mut [</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#587-589" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Pull some bytes from this source into the specified buffer, returning how many bytes were read. <a href="../io/trait.read#tymethod.read">Read more</a></p> </div>
<h4 id="method.read_vectored-1" class="method hidden">
<code>fn <a href="../io/trait.read#method.read_vectored" class="fnname">read_vectored</a>(&amp;mut self, bufs: <a class="primitive" href="../primitive.slice">&amp;mut [</a><a class="struct" href="../io/struct.ioslicemut" title="struct std::io::IoSliceMut">IoSliceMut</a>&lt;'_&gt;<a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#591-593" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Like <code>read</code>, except that it reads into a slice of buffers. <a href="../io/trait.read#method.read_vectored">Read more</a></p> </div>
<h4 id="method.is_read_vectored-1" class="method hidden">
<code>fn <a href="../io/trait.read#method.is_read_vectored" class="fnname">is_read_vectored</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#596-598" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (can_vector #69941)</span></div>
<div class="docblock hidden">
<p>Determines if this <code>Read</code>er has an efficient <code>read_vectored</code> implementation. <a href="../io/trait.read#method.is_read_vectored">Read more</a></p> </div>
<h4 id="method.initializer-1" class="method hidden">
<code>unsafe fn <a href="../io/trait.read#method.initializer" class="fnname">initializer</a>(&amp;self) -&gt; <a class="struct" href="../io/struct.initializer" title="struct std::io::Initializer">Initializer</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#601-604" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (read_initializer #42788)</span></div>
<div class="docblock hidden">
<p>Determines if this <code>Read</code>er can work with buffers of uninitialized memory. <a href="../io/trait.read#method.initializer">Read more</a></p> </div>
<h4 id="method.read_to_end-1" class="method hidden">
<code>fn <a href="../io/trait.read#method.read_to_end" class="fnname">read_to_end</a>(&amp;mut self, buf: &amp;mut <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#660-662" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Read all bytes until EOF in this source, placing them into <code>buf</code>. <a href="../io/trait.read#method.read_to_end">Read more</a></p> </div>
<h4 id="method.read_to_string-1" class="method hidden">
<code>fn <a href="../io/trait.read#method.read_to_string" class="fnname">read_to_string</a>(&amp;mut self, buf: &amp;mut <a class="struct" href="../string/struct.string" title="struct std::string::String">String</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#703-714" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Read all bytes until EOF in this source, appending them to <code>buf</code>. <a href="../io/trait.read#method.read_to_string">Read more</a></p> </div>
<h4 id="method.read_exact-1" class="method hidden">
<code>fn <a href="../io/trait.read#method.read_exact" class="fnname">read_exact</a>(&amp;mut self, buf: <a class="primitive" href="../primitive.slice">&amp;mut [</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#767-784" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span>
</h4>
<div class="docblock hidden">
<p>Read the exact number of bytes required to fill <code>buf</code>. <a href="../io/trait.read#method.read_exact">Read more</a></p> </div>
<h4 id="method.by_ref-1" class="method hidden">
<code>fn <a href="../io/trait.read#method.by_ref" class="fnname">by_ref</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.reference">&amp;mut </a>Self<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#821-826" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a "by reference" adaptor for this instance of <code>Read</code>. <a href="../io/trait.read#method.by_ref">Read more</a></p> </div>
<h4 id="method.bytes-1" class="method hidden">
<code>fn <a href="../io/trait.read#method.bytes" class="fnname">bytes</a>(self) -&gt; <a class="struct" href="../io/struct.bytes" title="struct std::io::Bytes">Bytes</a>&lt;Self&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Bytes&lt;R&gt;</h3>
<pre class="content">impl&lt;R: Read&gt; Iterator for Bytes&lt;R&gt;
    type Item = Result&lt;u8&gt;;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#858-863" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Transforms this <code>Read</code> instance to an <a href="../iter/trait.iterator" title="`Iterator`"><code>Iterator</code></a> over its bytes. <a href="../io/trait.read#method.bytes">Read more</a></p> </div>
<h4 id="method.chain-1" class="method hidden">
<code>fn <a href="../io/trait.read#method.chain" class="fnname">chain</a>&lt;R: <a class="trait" href="../io/trait.read" title="trait std::io::Read">Read</a>&gt;(self, next: R) -&gt; <a class="struct" href="../io/struct.chain" title="struct std::io::Chain">Chain</a>&lt;Self, R&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Chain&lt;T, U&gt;</h3>
<pre class="content">impl&lt;T: Read, U: Read&gt; Read for Chain&lt;T, U&gt;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#896-901" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates an adaptor which will chain this stream with another. <a href="../io/trait.read#method.chain">Read more</a></p> </div>
<h4 id="method.take-1" class="method hidden">
<code>fn <a href="../io/trait.read#method.take" class="fnname">take</a>(self, limit: <a class="primitive" href="../primitive.u64">u64</a>) -&gt; <a class="struct" href="../io/struct.take" title="struct std::io::Take">Take</a>&lt;Self&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Take&lt;T&gt;</h3>
<pre class="content">impl&lt;T: Read&gt; Read for Take&lt;T&gt;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#935-940" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates an adaptor which will read at most <code>limit</code> bytes from it. <a href="../io/trait.read#method.take">Read more</a></p> </div>
</div>
<h3 id="impl-Write" class="impl">
<code class="in-band">impl <a class="trait" href="../io/trait.write" title="trait std::io::Write">Write</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#567-584" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.write" class="method hidden">
<code>fn <a href="../io/trait.write#tymethod.write" class="fnname">write</a>(&amp;mut self, buf: <a class="primitive" href="../primitive.slice">&amp;[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#568-570" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Write a buffer into this writer, returning how many bytes were written. <a href="../io/trait.write#tymethod.write">Read more</a></p> </div>
<h4 id="method.write_vectored" class="method hidden">
<code>fn <a href="../io/trait.write#method.write_vectored" class="fnname">write_vectored</a>(&amp;mut self, bufs: <a class="primitive" href="../primitive.slice">&amp;[</a><a class="struct" href="../io/struct.ioslice" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;<a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#572-574" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Like [<code>write</code>], except that it writes from a slice of buffers. <a href="../io/trait.write#method.write_vectored">Read more</a></p> </div>
<h4 id="method.is_write_vectored" class="method hidden">
<code>fn <a href="../io/trait.write#method.is_write_vectored" class="fnname">is_write_vectored</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#577-579" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (can_vector #69941)</span></div>
<div class="docblock hidden">
<p>Determines if this <code>Write</code>er has an efficient [<code>write_vectored</code>] implementation. <a href="../io/trait.write#method.is_write_vectored">Read more</a></p> </div>
<h4 id="method.flush" class="method hidden">
<code>fn <a href="../io/trait.write#tymethod.flush" class="fnname">flush</a>(&amp;mut self) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#581-583" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Flush this output stream, ensuring that all intermediately buffered contents reach their destination. <a href="../io/trait.write#tymethod.flush">Read more</a></p> </div>
<h4 id="method.write_all" class="method hidden">
<code>fn <a href="../io/trait.write#method.write_all" class="fnname">write_all</a>(&amp;mut self, buf: <a class="primitive" href="../primitive.slice">&amp;[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1378-1390" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Attempts to write an entire buffer into this writer. <a href="../io/trait.write#method.write_all">Read more</a></p> </div>
<h4 id="method.write_all_vectored" class="method hidden">
<code>fn <a href="../io/trait.write#method.write_all_vectored" class="fnname">write_all_vectored</a>(&amp;mut self, bufs: <a class="primitive" href="../primitive.slice">&amp;mut [</a><a class="struct" href="../io/struct.ioslice" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;<a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1440-1455" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (write_all_vectored #70436)</span></div>
<div class="docblock hidden">
<p>Attempts to write multiple buffers into this writer. <a href="../io/trait.write#method.write_all_vectored">Read more</a></p> </div>
<h4 id="method.write_fmt" class="method hidden">
<code>fn <a href="../io/trait.write#method.write_fmt" class="fnname">write_fmt</a>(&amp;mut self, fmt: <a class="struct" href="../fmt/struct.arguments" title="struct std::fmt::Arguments">Arguments</a>&lt;'_&gt;) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1493-1525" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Writes a formatted string into this writer, returning any error encountered. <a href="../io/trait.write#method.write_fmt">Read more</a></p> </div>
<h4 id="method.by_ref-2" class="method hidden">
<code>fn <a href="../io/trait.write#method.by_ref" class="fnname">by_ref</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.reference">&amp;mut </a>Self<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1549-1554" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a "by reference" adaptor for this instance of <code>Write</code>. <a href="../io/trait.write#method.by_ref">Read more</a></p> </div>
</div>
<h3 id="impl-Write-1" class="impl">
<code class="in-band">impl&lt;'_&gt; <a class="trait" href="../io/trait.write" title="trait std::io::Write">Write</a> for &amp;'_ <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#607-624" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.write-1" class="method hidden">
<code>fn <a href="../io/trait.write#tymethod.write" class="fnname">write</a>(&amp;mut self, buf: <a class="primitive" href="../primitive.slice">&amp;[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#608-610" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Write a buffer into this writer, returning how many bytes were written. <a href="../io/trait.write#tymethod.write">Read more</a></p> </div>
<h4 id="method.write_vectored-1" class="method hidden">
<code>fn <a href="../io/trait.write#method.write_vectored" class="fnname">write_vectored</a>(&amp;mut self, bufs: <a class="primitive" href="../primitive.slice">&amp;[</a><a class="struct" href="../io/struct.ioslice" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;<a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#612-614" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Like [<code>write</code>], except that it writes from a slice of buffers. <a href="../io/trait.write#method.write_vectored">Read more</a></p> </div>
<h4 id="method.is_write_vectored-1" class="method hidden">
<code>fn <a href="../io/trait.write#method.is_write_vectored" class="fnname">is_write_vectored</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#617-619" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (can_vector #69941)</span></div>
<div class="docblock hidden">
<p>Determines if this <code>Write</code>er has an efficient [<code>write_vectored</code>] implementation. <a href="../io/trait.write#method.is_write_vectored">Read more</a></p> </div>
<h4 id="method.flush-1" class="method hidden">
<code>fn <a href="../io/trait.write#tymethod.flush" class="fnname">flush</a>(&amp;mut self) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/tcp.rs.html#621-623" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Flush this output stream, ensuring that all intermediately buffered contents reach their destination. <a href="../io/trait.write#tymethod.flush">Read more</a></p> </div>
<h4 id="method.write_all-1" class="method hidden">
<code>fn <a href="../io/trait.write#method.write_all" class="fnname">write_all</a>(&amp;mut self, buf: <a class="primitive" href="../primitive.slice">&amp;[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1378-1390" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Attempts to write an entire buffer into this writer. <a href="../io/trait.write#method.write_all">Read more</a></p> </div>
<h4 id="method.write_all_vectored-1" class="method hidden">
<code>fn <a href="../io/trait.write#method.write_all_vectored" class="fnname">write_all_vectored</a>(&amp;mut self, bufs: <a class="primitive" href="../primitive.slice">&amp;mut [</a><a class="struct" href="../io/struct.ioslice" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;<a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1440-1455" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (write_all_vectored #70436)</span></div>
<div class="docblock hidden">
<p>Attempts to write multiple buffers into this writer. <a href="../io/trait.write#method.write_all_vectored">Read more</a></p> </div>
<h4 id="method.write_fmt-1" class="method hidden">
<code>fn <a href="../io/trait.write#method.write_fmt" class="fnname">write_fmt</a>(&amp;mut self, fmt: <a class="struct" href="../fmt/struct.arguments" title="struct std::fmt::Arguments">Arguments</a>&lt;'_&gt;) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1493-1525" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Writes a formatted string into this writer, returning any error encountered. <a href="../io/trait.write#method.write_fmt">Read more</a></p> </div>
<h4 id="method.by_ref-3" class="method hidden">
<code>fn <a href="../io/trait.write#method.by_ref" class="fnname">by_ref</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.reference">&amp;mut </a>Self<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1549-1554" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a "by reference" adaptor for this instance of <code>Write</code>. <a href="../io/trait.write#method.by_ref">Read more</a></p> </div>
</div>
</div>
<h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations</h2>
<div id="synthetic-implementations-list">
<h3 id="impl-RefUnwindSafe" class="impl"><code class="in-band">impl <a class="trait" href="../panic/trait.refunwindsafe" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code></h3>

<h3 id="impl-Send" class="impl"><code class="in-band">impl <a class="trait" href="../marker/trait.send" title="trait std::marker::Send">Send</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code></h3>

<h3 id="impl-Sync" class="impl"><code class="in-band">impl <a class="trait" href="../marker/trait.sync" title="trait std::marker::Sync">Sync</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code></h3>

<h3 id="impl-Unpin" class="impl"><code class="in-band">impl <a class="trait" href="../marker/trait.unpin" title="trait std::marker::Unpin">Unpin</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code></h3>

<h3 id="impl-UnwindSafe" class="impl"><code class="in-band">impl <a class="trait" href="../panic/trait.unwindsafe" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.tcpstream" title="struct std::net::TcpStream">TcpStream</a></code></h3>

</div>
<h2 id="blanket-implementations" class="small-section-header">Blanket Implementations</h2>
<div id="blanket-implementations-list">
<h3 id="impl-Any" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../any/trait.any" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>    T: 'static + ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#108-112" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.type_id" class="method hidden">
<code>fn <a href="../any/trait.any#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="../any/struct.typeid" title="struct std::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#109-111" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Gets the <code>TypeId</code> of <code>self</code>. <a href="../any/trait.any#tymethod.type_id">Read more</a></p> </div>
</div>
<h3 id="impl-Borrow%3CT%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.borrow" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>    T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#210-214" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.borrow" class="method hidden">
<code>fn <a href="../borrow/trait.borrow#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.reference">&amp;</a>T<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#211-213" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Immutably borrows from an owned value. <a href="../borrow/trait.borrow#tymethod.borrow">Read more</a></p> </div>
</div>
<h3 id="impl-BorrowMut%3CT%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.borrowmut" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>    T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217-221" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.borrow_mut" class="method hidden">
<code>fn <a href="../borrow/trait.borrowmut#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.reference">&amp;mut </a>T<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#218-220" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Mutably borrows from an owned value. <a href="../borrow/trait.borrowmut#tymethod.borrow_mut">Read more</a></p> </div>
</div>
<h3 id="impl-From%3CT%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;T&gt; for T</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#570-574" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.from" class="method hidden">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#571-573" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-Into%3CU%3E" class="impl">
<code class="in-band">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.into" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>    U: <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#559-566" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.into" class="method hidden">
<code>fn <a href="../convert/trait.into#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#563-565" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-TryFrom%3CU%3E" class="impl">
<code class="in-band">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>    U: <a class="trait" href="../convert/trait.into" title="trait std::convert::Into">Into</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#607-616" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Error" class="type"><code>type <a href="../convert/trait.tryfrom#associatedtype.Error" class="type">Error</a> = <a class="enum" href="../convert/enum.infallible" title="enum std::convert::Infallible">Infallible</a></code></h4>
<div class="docblock">
<p>The type returned in the event of a conversion error.</p> </div>
<h4 id="method.try_from" class="method hidden">
<code>fn <a href="../convert/trait.tryfrom#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="../convert/trait.tryfrom#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#613-615" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-TryInto%3CU%3E" class="impl">
<code class="in-band">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.tryinto" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>    U: <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#593-602" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Error-1" class="type"><code>type <a href="../convert/trait.tryinto#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../convert/trait.tryfrom#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></code></h4>
<div class="docblock">
<p>The type returned in the event of a conversion error.</p> </div>
<h4 id="method.try_into" class="method hidden">
<code>fn <a href="../convert/trait.tryinto#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../convert/trait.tryfrom#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#599-601" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html" class="_attribution-link">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
