
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Std&#58;&#58;slice - Rust - W3cubDocs</title>
  
  <meta name="description" content="A dynamically-sized view into a contiguous sequence, [T]. Contiguous here means that elements are laid out so that every element is the same &hellip;">
  <meta name="keywords" content="primitive, type, slice, std, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rust/std/primitive.slice.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/rust.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rust">
				
				
<h1 class="fqn">Primitive Type slice</h1>
<p>A dynamically-sized view into a contiguous sequence, <code>[T]</code>. Contiguous here means that elements are laid out so that every element is the same distance from its neighbors.</p> <p><em><a href="slice/index">See also the <code>std::slice</code> module</a>.</em></p> <p>Slices are a view into a block of memory represented as a pointer and a length.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// slicing a Vec
let vec = vec![1, 2, 3];
let int_slice = &amp;vec[..];
// coercing an array to a slice
let str_slice: &amp;[&amp;str] = &amp;["one", "two", "three"];</pre></div> <p>Slices are either mutable or shared. The shared slice type is <code>&amp;[T]</code>, while the mutable slice type is <code>&amp;mut [T]</code>, where <code>T</code> represents the element type. For example, you can mutate the block of memory that a mutable slice points to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut x = [1, 2, 3];
let x = &amp;mut x[..]; // Take a full slice of `x`.
x[1] = 7;
assert_eq!(x, &amp;[1, 7, 3]);</pre></div> <p>As slices store the length of the sequence they refer to, they have twice the size of pointers to <a href="marker/trait.sized"><code>Sized</code></a> types. Also see the reference on <a href="../reference/dynamically-sized-types">dynamically sized types</a>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let pointer_size = std::mem::size_of::&lt;&amp;u8&gt;();
assert_eq!(2 * pointer_size, std::mem::size_of::&lt;&amp;[u8]&gt;());
assert_eq!(2 * pointer_size, std::mem::size_of::&lt;*const [u8]&gt;());
assert_eq!(2 * pointer_size, std::mem::size_of::&lt;Box&lt;[u8]&gt;&gt;());
assert_eq!(2 * pointer_size, std::mem::size_of::&lt;Rc&lt;[u8]&gt;&gt;());</pre></div> <h2 id="implementations" class="small-section-header">Implementations</h2>
<h3 id="impl" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#56-2959" title="goto source code">[src]</a>
</h3>
<h4 id="method.len" class="method">
<code>pub const fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="primitive.usize">usize</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#71-75" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns the number of elements in the slice.</p> <h2 id="examples" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let a = [1, 2, 3];
assert_eq!(a.len(), 3);</pre></div> </div>
<h4 id="method.is_empty" class="method">
<code>pub const fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#88-90" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns <code>true</code> if the slice has a length of 0.</p> <h2 id="examples-1" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let a = [1, 2, 3];
assert!(!a.is_empty());</pre></div> </div>
<h4 id="method.first" class="method">
<code>pub fn <a href="#method.first" class="fnname">first</a>(&amp;self) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference">&amp;</a>T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#105-107" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns the first element of the slice, or <code>None</code> if it is empty.</p> <h2 id="examples-2" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = [10, 40, 30];
assert_eq!(Some(&amp;10), v.first());

let w: &amp;[i32] = &amp;[];
assert_eq!(None, w.first());</pre></div> </div>
<h4 id="method.first_mut" class="method">
<code>pub fn <a href="#method.first_mut" class="fnname">first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference">&amp;mut </a>T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#123-125" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns a mutable pointer to the first element of the slice, or <code>None</code> if it is empty.</p> <h2 id="examples-3" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;mut [0, 1, 2];

if let Some(first) = x.first_mut() {
    *first = 5;
}
assert_eq!(x, &amp;[5, 1, 2]);</pre></div> </div>
<h4 id="method.split_first" class="method">
<code>pub fn <a href="#method.split_first" class="fnname">split_first</a>(&amp;self) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.reference">&amp;</a>T, <a class="primitive" href="primitive.slice">&amp;[T]</a><a class="primitive" href="primitive.tuple">)</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#141-143" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</h4>
<div class="docblock">
<p>Returns the first and all the rest of the elements of the slice, or <code>None</code> if it is empty.</p> <h2 id="examples-4" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;[0, 1, 2];

if let Some((first, elements)) = x.split_first() {
    assert_eq!(first, &amp;0);
    assert_eq!(elements, &amp;[1, 2]);
}</pre></div> </div>
<h4 id="method.split_first_mut" class="method">
<code>pub fn <a href="#method.split_first_mut" class="fnname">split_first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.reference">&amp;mut </a>T, <a class="primitive" href="primitive.slice">&amp;mut [T]</a><a class="primitive" href="primitive.tuple">)</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#161-163" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</h4>
<div class="docblock">
<p>Returns the first and all the rest of the elements of the slice, or <code>None</code> if it is empty.</p> <h2 id="examples-5" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;mut [0, 1, 2];

if let Some((first, elements)) = x.split_first_mut() {
    *first = 3;
    elements[0] = 4;
    elements[1] = 5;
}
assert_eq!(x, &amp;[3, 4, 5]);</pre></div> </div>
<h4 id="method.split_last" class="method">
<code>pub fn <a href="#method.split_last" class="fnname">split_last</a>(&amp;self) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.reference">&amp;</a>T, <a class="primitive" href="primitive.slice">&amp;[T]</a><a class="primitive" href="primitive.tuple">)</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#179-181" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</h4>
<div class="docblock">
<p>Returns the last and all the rest of the elements of the slice, or <code>None</code> if it is empty.</p> <h2 id="examples-6" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;[0, 1, 2];

if let Some((last, elements)) = x.split_last() {
    assert_eq!(last, &amp;2);
    assert_eq!(elements, &amp;[0, 1]);
}</pre></div> </div>
<h4 id="method.split_last_mut" class="method">
<code>pub fn <a href="#method.split_last_mut" class="fnname">split_last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.reference">&amp;mut </a>T, <a class="primitive" href="primitive.slice">&amp;mut [T]</a><a class="primitive" href="primitive.tuple">)</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#199-201" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</h4>
<div class="docblock">
<p>Returns the last and all the rest of the elements of the slice, or <code>None</code> if it is empty.</p> <h2 id="examples-7" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;mut [0, 1, 2];

if let Some((last, elements)) = x.split_last_mut() {
    *last = 3;
    elements[0] = 4;
    elements[1] = 5;
}
assert_eq!(x, &amp;[4, 5, 3]);</pre></div> </div>
<h4 id="method.last" class="method">
<code>pub fn <a href="#method.last" class="fnname">last</a>(&amp;self) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference">&amp;</a>T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#216-218" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns the last element of the slice, or <code>None</code> if it is empty.</p> <h2 id="examples-8" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = [10, 40, 30];
assert_eq!(Some(&amp;30), v.last());

let w: &amp;[i32] = &amp;[];
assert_eq!(None, w.last());</pre></div> </div>
<h4 id="method.last_mut" class="method">
<code>pub fn <a href="#method.last_mut" class="fnname">last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference">&amp;mut </a>T&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#234-236" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns a mutable pointer to the last item in the slice.</p> <h2 id="examples-9" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;mut [0, 1, 2];

if let Some(last) = x.last_mut() {
    *last = 10;
}
assert_eq!(x, &amp;[0, 1, 10]);</pre></div> </div>
<h4 id="method.get" class="method">
<code>pub fn <a href="#method.get" class="fnname">get</a>&lt;I&gt;(&amp;self, index: I) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;&amp;&lt;I as <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;&gt;::<a class="type" href="slice/trait.sliceindex#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt; <span class="where fmt-newline">where<br>    I: <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#257-262" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns a reference to an element or subslice depending on the type of index.</p> <ul> <li>If given a position, returns a reference to the element at that position or <code>None</code> if out of bounds.</li> <li>If given a range, returns the subslice corresponding to that range, or <code>None</code> if out of bounds.</li> </ul> <h2 id="examples-10" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = [10, 40, 30];
assert_eq!(Some(&amp;40), v.get(1));
assert_eq!(Some(&amp;[10, 40][..]), v.get(0..2));
assert_eq!(None, v.get(3));
assert_eq!(None, v.get(0..4));</pre></div> </div>
<h4 id="method.get_mut" class="method">
<code>pub fn <a href="#method.get_mut" class="fnname">get_mut</a>&lt;I&gt;(<br>    &amp;mut self, <br>    index: I<br>) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;I as <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;&gt;::<a class="type" href="slice/trait.sliceindex#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt; <span class="where fmt-newline">where<br>    I: <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#281-286" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns a mutable reference to an element or subslice depending on the type of index (see <a href="#method.get"><code>get</code></a>) or <code>None</code> if the index is out of bounds.</p> <h2 id="examples-11" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;mut [0, 1, 2];

if let Some(elem) = x.get_mut(1) {
    *elem = 42;
}
assert_eq!(x, &amp;[0, 42, 2]);</pre></div> </div>
<h4 id="method.get_unchecked" class="method">
<code>pub unsafe fn <a href="#method.get_unchecked" class="fnname">get_unchecked</a>&lt;I&gt;(<br>    &amp;self, <br>    index: I<br>) -&gt; &amp;&lt;I as <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;&gt;::<a class="type" href="slice/trait.sliceindex#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>    I: <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#310-318" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns a reference to an element or subslice, without doing bounds checking.</p> <p>This is generally not recommended, use with caution! Calling this method with an out-of-bounds index is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. For a safe alternative see <a href="#method.get"><code>get</code></a>.</p> <h2 id="examples-12" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;[1, 2, 4];

unsafe {
    assert_eq!(x.get_unchecked(1), &amp;2);
}</pre></div> </div>
<h4 id="method.get_unchecked_mut" class="method">
<code>pub unsafe fn <a href="#method.get_unchecked_mut" class="fnname">get_unchecked_mut</a>&lt;I&gt;(<br>    &amp;mut self, <br>    index: I<br>) -&gt; &amp;mut &lt;I as <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;&gt;::<a class="type" href="slice/trait.sliceindex#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>    I: <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#344-352" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns a mutable reference to an element or subslice, without doing bounds checking.</p> <p>This is generally not recommended, use with caution! Calling this method with an out-of-bounds index is <em><a href="../reference/behavior-considered-undefined">undefined behavior</a></em> even if the resulting reference is not used. For a safe alternative see <a href="#method.get_mut"><code>get_mut</code></a>.</p> <h2 id="examples-13" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;mut [1, 2, 4];

unsafe {
    let elem = x.get_unchecked_mut(1);
    *elem = 13;
}
assert_eq!(x, &amp;[1, 13, 4]);</pre></div> </div>
<h4 id="method.as_ptr" class="method">
<code>pub const fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="primitive.pointer">*const T</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#383-385" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns a raw pointer to the slice's buffer.</p> <p>The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.</p> <p>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an <code>UnsafeCell</code>) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use <a href="#method.as_mut_ptr"><code>as_mut_ptr</code></a>.</p> <p>Modifying the container referenced by this slice may cause its buffer to be reallocated, which would also make any pointers to it invalid.</p> <h2 id="examples-14" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;[1, 2, 4];
let x_ptr = x.as_ptr();

unsafe {
    for i in 0..x.len() {
        assert_eq!(x.get_unchecked(i), &amp;*x_ptr.add(i));
    }
}</pre></div> </div>
<h4 id="method.as_mut_ptr" class="method">
<code>pub fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.pointer">*mut T</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#410-412" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an unsafe mutable pointer to the slice's buffer.</p> <p>The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.</p> <p>Modifying the container referenced by this slice may cause its buffer to be reallocated, which would also make any pointers to it invalid.</p> <h2 id="examples-15" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;mut [1, 2, 4];
let x_ptr = x.as_mut_ptr();

unsafe {
    for i in 0..x.len() {
        *x_ptr.add(i) += 2;
    }
}
assert_eq!(x, &amp;[3, 4, 6]);</pre></div> </div>
<h4 id="method.as_ptr_range" class="method">
<code>pub fn <a href="#method.as_ptr_range" class="fnname">as_ptr_range</a>(&amp;self) -&gt; <a class="struct" href="ops/struct.range" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.pointer">*const T</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Range&lt;A&gt;</h3>
<pre class="content">impl&lt;A&gt; Iterator for Range&lt;A&gt; where
    A: Step, 
    type Item = A;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#446-467" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_ptr_range #65807)</span></div>
<div class="docblock">
<p>Returns the two raw pointers spanning the slice.</p> <p>The returned range is half-open, which means that the end pointer points <em>one past</em> the last element of the slice. This way, an empty slice is represented by two equal pointers, and the difference between the two pointers represents the size of the slice.</p> <p>See <a href="#method.as_ptr"><code>as_ptr</code></a> for warnings on using these pointers. The end pointer requires extra caution, as it does not point to a valid element in the slice.</p> <p>This function is useful for interacting with foreign interfaces which use two pointers to refer to a range of elements in memory, as is common in C++.</p> <p>It can also be useful to check if a pointer to an element refers to an element of this slice:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_ptr_range)]

let a = [1, 2, 3];
let x = &amp;a[1] as *const _;
let y = &amp;5 as *const _;

assert!(a.as_ptr_range().contains(&amp;x));
assert!(!a.as_ptr_range().contains(&amp;y));</pre></div> </div>
<h4 id="method.as_mut_ptr_range" class="method">
<code>pub fn <a href="#method.as_mut_ptr_range" class="fnname">as_mut_ptr_range</a>(&amp;mut self) -&gt; <a class="struct" href="ops/struct.range" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.pointer">*mut T</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Range&lt;A&gt;</h3>
<pre class="content">impl&lt;A&gt; Iterator for Range&lt;A&gt; where
    A: Step, 
    type Item = A;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#487-492" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_ptr_range #65807)</span></div>
<div class="docblock">
<p>Returns the two unsafe mutable pointers spanning the slice.</p> <p>The returned range is half-open, which means that the end pointer points <em>one past</em> the last element of the slice. This way, an empty slice is represented by two equal pointers, and the difference between the two pointers represents the size of the slice.</p> <p>See <a href="#method.as_mut_ptr"><code>as_mut_ptr</code></a> for warnings on using these pointers. The end pointer requires extra caution, as it does not point to a valid element in the slice.</p> <p>This function is useful for interacting with foreign interfaces which use two pointers to refer to a range of elements in memory, as is common in C++.</p> </div>
<h4 id="method.swap" class="method">
<code>pub fn <a href="#method.swap" class="fnname">swap</a>(&amp;mut self, a: <a class="primitive" href="primitive.usize">usize</a>, b: <a class="primitive" href="primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#514-526" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Swaps two elements in the slice.</p> <h2 id="arguments" class="section-header">Arguments</h2> <ul> <li>a - The index of the first element</li> <li>b - The index of the second element</li> </ul> <h2 id="panics" class="section-header">Panics</h2> <p>Panics if <code>a</code> or <code>b</code> are out of bounds.</p> <h2 id="examples-16" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = ["a", "b", "c", "d"];
v.swap(1, 3);
assert!(v == ["a", "d", "c", "b"]);</pre></div> </div>
<h4 id="method.reverse" class="method">
<code>pub fn <a href="#method.reverse" class="fnname">reverse</a>(&amp;mut self)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#539-636" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Reverses the order of elements in the slice, in place.</p> <h2 id="examples-17" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = [1, 2, 3];
v.reverse();
assert!(v == [3, 2, 1]);</pre></div> </div>
<h4 id="method.iter" class="method">
<code>pub fn <a href="#method.iter" class="fnname">iter</a>(&amp;self) -&gt; <a class="struct" href="slice/struct.iter" title="struct std::slice::Iter">Iter</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Iter&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt;
    type Item = &amp;'a T;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#653-682" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator over the slice.</p> <h2 id="examples-18" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;[1, 2, 4];
let mut iterator = x.iter();

assert_eq!(iterator.next(), Some(&amp;1));
assert_eq!(iterator.next(), Some(&amp;2));
assert_eq!(iterator.next(), Some(&amp;4));
assert_eq!(iterator.next(), None);</pre></div> </div>
<h4 id="method.iter_mut" class="method">
<code>pub fn <a href="#method.iter_mut" class="fnname">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="slice/struct.itermut" title="struct std::slice::IterMut">IterMut</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for IterMut&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt;
    type Item = &amp;'a mut T;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#697-726" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator that allows modifying each value.</p> <h2 id="examples-19" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = &amp;mut [1, 2, 4];
for elem in x.iter_mut() {
    *elem += 2;
}
assert_eq!(x, &amp;[3, 4, 6]);</pre></div> </div>
<h4 id="method.windows" class="method">
<code>pub fn <a href="#method.windows" class="fnname">windows</a>(&amp;self, size: <a class="primitive" href="primitive.usize">usize</a>) -&gt; <a class="struct" href="slice/struct.windows" title="struct std::slice::Windows">Windows</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Windows&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for Windows&lt;'a, T&gt;
    type Item = &amp;'a [T];
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#756-759" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator over all contiguous windows of length <code>size</code>. The windows overlap. If the slice is shorter than <code>size</code>, the iterator returns no values.</p> <h2 id="panics-1" class="section-header">Panics</h2> <p>Panics if <code>size</code> is 0.</p> <h2 id="examples-20" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let slice = ['r', 'u', 's', 't'];
let mut iter = slice.windows(2);
assert_eq!(iter.next().unwrap(), &amp;['r', 'u']);
assert_eq!(iter.next().unwrap(), &amp;['u', 's']);
assert_eq!(iter.next().unwrap(), &amp;['s', 't']);
assert!(iter.next().is_none());</pre></div> <p>If the slice is shorter than <code>size</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let slice = ['f', 'o', 'o'];
let mut iter = slice.windows(4);
assert!(iter.next().is_none());</pre></div> </div>
<h4 id="method.chunks" class="method">
<code>pub fn <a href="#method.chunks" class="fnname">chunks</a>(&amp;self, chunk_size: <a class="primitive" href="primitive.usize">usize</a>) -&gt; <a class="struct" href="slice/struct.chunks" title="struct std::slice::Chunks">Chunks</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Chunks&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for Chunks&lt;'a, T&gt;
    type Item = &amp;'a [T];
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#790-793" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the beginning of the slice.</p> <p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not divide the length of the slice, then the last chunk will not have length <code>chunk_size</code>.</p> <p>See <a href="#method.chunks_exact"><code>chunks_exact</code></a> for a variant of this iterator that returns chunks of always exactly <code>chunk_size</code> elements, and <a href="#method.rchunks"><code>rchunks</code></a> for the same iterator but starting at the end of the slice.</p> <h2 id="panics-2" class="section-header">Panics</h2> <p>Panics if <code>chunk_size</code> is 0.</p> <h2 id="examples-21" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.chunks(2);
assert_eq!(iter.next().unwrap(), &amp;['l', 'o']);
assert_eq!(iter.next().unwrap(), &amp;['r', 'e']);
assert_eq!(iter.next().unwrap(), &amp;['m']);
assert!(iter.next().is_none());</pre></div> </div>
<h4 id="method.chunks_mut" class="method">
<code>pub fn <a href="#method.chunks_mut" class="fnname">chunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="primitive.usize">usize</a>) -&gt; <a class="struct" href="slice/struct.chunksmut" title="struct std::slice::ChunksMut">ChunksMut</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for ChunksMut&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for ChunksMut&lt;'a, T&gt;
    type Item = &amp;'a mut [T];
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#828-831" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the beginning of the slice.</p> <p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does not divide the length of the slice, then the last chunk will not have length <code>chunk_size</code>.</p> <p>See <a href="#method.chunks_exact_mut"><code>chunks_exact_mut</code></a> for a variant of this iterator that returns chunks of always exactly <code>chunk_size</code> elements, and <a href="#method.rchunks_mut"><code>rchunks_mut</code></a> for the same iterator but starting at the end of the slice.</p> <h2 id="panics-3" class="section-header">Panics</h2> <p>Panics if <code>chunk_size</code> is 0.</p> <h2 id="examples-22" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = &amp;mut [0, 0, 0, 0, 0];
let mut count = 1;

for chunk in v.chunks_mut(2) {
    for elem in chunk.iter_mut() {
        *elem += count;
    }
    count += 1;
}
assert_eq!(v, &amp;[1, 1, 2, 2, 3]);</pre></div> </div>
<h4 id="method.chunks_exact" class="method">
<code>pub fn <a href="#method.chunks_exact" class="fnname">chunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="primitive.usize">usize</a>) -&gt; <a class="struct" href="slice/struct.chunksexact" title="struct std::slice::ChunksExact">ChunksExact</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for ChunksExact&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for ChunksExact&lt;'a, T&gt;
    type Item = &amp;'a [T];
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#865-871" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.31.0">1.31.0</span>
</h4>
<div class="docblock">
<p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the beginning of the slice.</p> <p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not divide the length of the slice, then the last up to <code>chunk_size-1</code> elements will be omitted and can be retrieved from the <code>remainder</code> function of the iterator.</p> <p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can often optimize the resulting code better than in the case of <a href="#method.chunks"><code>chunks</code></a>.</p> <p>See <a href="#method.chunks"><code>chunks</code></a> for a variant of this iterator that also returns the remainder as a smaller chunk, and <a href="#method.rchunks_exact"><code>rchunks_exact</code></a> for the same iterator but starting at the end of the slice.</p> <h2 id="panics-4" class="section-header">Panics</h2> <p>Panics if <code>chunk_size</code> is 0.</p> <h2 id="examples-23" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.chunks_exact(2);
assert_eq!(iter.next().unwrap(), &amp;['l', 'o']);
assert_eq!(iter.next().unwrap(), &amp;['r', 'e']);
assert!(iter.next().is_none());
assert_eq!(iter.remainder(), &amp;['m']);</pre></div> </div>
<h4 id="method.chunks_exact_mut" class="method">
<code>pub fn <a href="#method.chunks_exact_mut" class="fnname">chunks_exact_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="primitive.usize">usize</a>) -&gt; <a class="struct" href="slice/struct.chunksexactmut" title="struct std::slice::ChunksExactMut">ChunksExactMut</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for ChunksExactMut&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for ChunksExactMut&lt;'a, T&gt;
    type Item = &amp;'a mut [T];
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#910-916" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.31.0">1.31.0</span>
</h4>
<div class="docblock">
<p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the beginning of the slice.</p> <p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does not divide the length of the slice, then the last up to <code>chunk_size-1</code> elements will be omitted and can be retrieved from the <code>into_remainder</code> function of the iterator.</p> <p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can often optimize the resulting code better than in the case of <a href="#method.chunks_mut"><code>chunks_mut</code></a>.</p> <p>See <a href="#method.chunks_mut"><code>chunks_mut</code></a> for a variant of this iterator that also returns the remainder as a smaller chunk, and <a href="#method.rchunks_exact_mut"><code>rchunks_exact_mut</code></a> for the same iterator but starting at the end of the slice.</p> <h2 id="panics-5" class="section-header">Panics</h2> <p>Panics if <code>chunk_size</code> is 0.</p> <h2 id="examples-24" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = &amp;mut [0, 0, 0, 0, 0];
let mut count = 1;

for chunk in v.chunks_exact_mut(2) {
    for elem in chunk.iter_mut() {
        *elem += count;
    }
    count += 1;
}
assert_eq!(v, &amp;[1, 1, 2, 2, 0]);</pre></div> </div>
<h4 id="method.array_chunks" class="method">
<code>pub fn <a href="#method.array_chunks" class="fnname">array_chunks</a>&lt;const N: <a class="primitive" href="primitive.usize">usize</a>&gt;(&amp;self) -&gt; <a class="struct" href="slice/struct.arraychunks" title="struct std::slice::ArrayChunks">ArrayChunks</a>&lt;'_, T, N&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for ArrayChunks&lt;'a, T, N&gt;</h3>
<pre class="content">impl&lt;'a, T, const N: usize&gt; Iterator for ArrayChunks&lt;'a, T, N&gt;
    type Item = &amp;'a [T; N];
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#947-955" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (array_chunks #74985)</span></div>
<div class="docblock">
<p>Returns an iterator over <code>N</code> elements of the slice at a time, starting at the beginning of the slice.</p> <p>The chunks are slices and do not overlap. If <code>N</code> does not divide the length of the slice, then the last up to <code>N-1</code> elements will be omitted and can be retrieved from the <code>remainder</code> function of the iterator.</p> <p>This method is the const generic equivalent of <a href="#method.chunks_exact"><code>chunks_exact</code></a>.</p> <h2 id="panics-6" class="section-header">Panics</h2> <p>Panics if <code>N</code> is 0. This check will most probably get changed to a compile time error before this method gets stabilized.</p> <h2 id="examples-25" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(array_chunks)]
let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.array_chunks();
assert_eq!(iter.next().unwrap(), &amp;['l', 'o']);
assert_eq!(iter.next().unwrap(), &amp;['r', 'e']);
assert!(iter.next().is_none());
assert_eq!(iter.remainder(), &amp;['m']);</pre></div> </div>
<h4 id="method.rchunks" class="method">
<code>pub fn <a href="#method.rchunks" class="fnname">rchunks</a>(&amp;self, chunk_size: <a class="primitive" href="primitive.usize">usize</a>) -&gt; <a class="struct" href="slice/struct.rchunks" title="struct std::slice::RChunks">RChunks</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for RChunks&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for RChunks&lt;'a, T&gt;
    type Item = &amp;'a [T];
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#986-989" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.31.0">1.31.0</span>
</h4>
<div class="docblock">
<p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the end of the slice.</p> <p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not divide the length of the slice, then the last chunk will not have length <code>chunk_size</code>.</p> <p>See <a href="#method.rchunks_exact"><code>rchunks_exact</code></a> for a variant of this iterator that returns chunks of always exactly <code>chunk_size</code> elements, and <a href="#method.chunks"><code>chunks</code></a> for the same iterator but starting at the beginning of the slice.</p> <h2 id="panics-7" class="section-header">Panics</h2> <p>Panics if <code>chunk_size</code> is 0.</p> <h2 id="examples-26" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.rchunks(2);
assert_eq!(iter.next().unwrap(), &amp;['e', 'm']);
assert_eq!(iter.next().unwrap(), &amp;['o', 'r']);
assert_eq!(iter.next().unwrap(), &amp;['l']);
assert!(iter.next().is_none());</pre></div> </div>
<h4 id="method.rchunks_mut" class="method">
<code>pub fn <a href="#method.rchunks_mut" class="fnname">rchunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="primitive.usize">usize</a>) -&gt; <a class="struct" href="slice/struct.rchunksmut" title="struct std::slice::RChunksMut">RChunksMut</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for RChunksMut&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for RChunksMut&lt;'a, T&gt;
    type Item = &amp;'a mut [T];
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1024-1027" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.31.0">1.31.0</span>
</h4>
<div class="docblock">
<p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the end of the slice.</p> <p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does not divide the length of the slice, then the last chunk will not have length <code>chunk_size</code>.</p> <p>See <a href="#method.rchunks_exact_mut"><code>rchunks_exact_mut</code></a> for a variant of this iterator that returns chunks of always exactly <code>chunk_size</code> elements, and <a href="#method.chunks_mut"><code>chunks_mut</code></a> for the same iterator but starting at the beginning of the slice.</p> <h2 id="panics-8" class="section-header">Panics</h2> <p>Panics if <code>chunk_size</code> is 0.</p> <h2 id="examples-27" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = &amp;mut [0, 0, 0, 0, 0];
let mut count = 1;

for chunk in v.rchunks_mut(2) {
    for elem in chunk.iter_mut() {
        *elem += count;
    }
    count += 1;
}
assert_eq!(v, &amp;[3, 2, 2, 1, 1]);</pre></div> </div>
<h4 id="method.rchunks_exact" class="method">
<code>pub fn <a href="#method.rchunks_exact" class="fnname">rchunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="primitive.usize">usize</a>) -&gt; <a class="struct" href="slice/struct.rchunksexact" title="struct std::slice::RChunksExact">RChunksExact</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for RChunksExact&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for RChunksExact&lt;'a, T&gt;
    type Item = &amp;'a [T];
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1063-1068" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.31.0">1.31.0</span>
</h4>
<div class="docblock">
<p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the end of the slice.</p> <p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not divide the length of the slice, then the last up to <code>chunk_size-1</code> elements will be omitted and can be retrieved from the <code>remainder</code> function of the iterator.</p> <p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can often optimize the resulting code better than in the case of <a href="#method.chunks"><code>chunks</code></a>.</p> <p>See <a href="#method.rchunks"><code>rchunks</code></a> for a variant of this iterator that also returns the remainder as a smaller chunk, and <a href="#method.chunks_exact"><code>chunks_exact</code></a> for the same iterator but starting at the beginning of the slice.</p> <h2 id="panics-9" class="section-header">Panics</h2> <p>Panics if <code>chunk_size</code> is 0.</p> <h2 id="examples-28" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.rchunks_exact(2);
assert_eq!(iter.next().unwrap(), &amp;['e', 'm']);
assert_eq!(iter.next().unwrap(), &amp;['o', 'r']);
assert!(iter.next().is_none());
assert_eq!(iter.remainder(), &amp;['l']);</pre></div> </div>
<h4 id="method.rchunks_exact_mut" class="method">
<code>pub fn <a href="#method.rchunks_exact_mut" class="fnname">rchunks_exact_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="primitive.usize">usize</a>) -&gt; <a class="struct" href="slice/struct.rchunksexactmut" title="struct std::slice::RChunksExactMut">RChunksExactMut</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for RChunksExactMut&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for RChunksExactMut&lt;'a, T&gt;
    type Item = &amp;'a mut [T];
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1108-1113" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.31.0">1.31.0</span>
</h4>
<div class="docblock">
<p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the end of the slice.</p> <p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does not divide the length of the slice, then the last up to <code>chunk_size-1</code> elements will be omitted and can be retrieved from the <code>into_remainder</code> function of the iterator.</p> <p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can often optimize the resulting code better than in the case of <a href="#method.chunks_mut"><code>chunks_mut</code></a>.</p> <p>See <a href="#method.rchunks_mut"><code>rchunks_mut</code></a> for a variant of this iterator that also returns the remainder as a smaller chunk, and <a href="#method.chunks_exact_mut"><code>chunks_exact_mut</code></a> for the same iterator but starting at the beginning of the slice.</p> <h2 id="panics-10" class="section-header">Panics</h2> <p>Panics if <code>chunk_size</code> is 0.</p> <h2 id="examples-29" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = &amp;mut [0, 0, 0, 0, 0];
let mut count = 1;

for chunk in v.rchunks_exact_mut(2) {
    for elem in chunk.iter_mut() {
        *elem += count;
    }
    count += 1;
}
assert_eq!(v, &amp;[0, 2, 2, 1, 1]);</pre></div> </div>
<h4 id="method.split_at" class="method">
<code>pub fn <a href="#method.split_at" class="fnname">split_at</a>(&amp;self, mid: <a class="primitive" href="primitive.usize">usize</a>) -&gt; <a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.slice">&amp;[T]</a>, <a class="primitive" href="primitive.slice">&amp;[T]</a><a class="primitive" href="primitive.tuple">)</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1150-1152" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Divides one slice into two at an index.</p> <p>The first will contain all indices from <code>[0, mid)</code> (excluding the index <code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p> <h2 id="panics-11" class="section-header">Panics</h2> <p>Panics if <code>mid &gt; len</code>.</p> <h2 id="examples-30" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = [1, 2, 3, 4, 5, 6];

{
   let (left, right) = v.split_at(0);
   assert!(left == []);
   assert!(right == [1, 2, 3, 4, 5, 6]);
}

{
    let (left, right) = v.split_at(2);
    assert!(left == [1, 2]);
    assert!(right == [3, 4, 5, 6]);
}

{
    let (left, right) = v.split_at(6);
    assert!(left == [1, 2, 3, 4, 5, 6]);
    assert!(right == []);
}</pre></div> </div>
<h4 id="method.split_at_mut" class="method">
<code>pub fn <a href="#method.split_at_mut" class="fnname">split_at_mut</a>(&amp;mut self, mid: <a class="primitive" href="primitive.usize">usize</a>) -&gt; <a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.slice">&amp;mut [T]</a>, <a class="primitive" href="primitive.slice">&amp;mut [T]</a><a class="primitive" href="primitive.tuple">)</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1180-1191" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Divides one mutable slice into two at an index.</p> <p>The first will contain all indices from <code>[0, mid)</code> (excluding the index <code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p> <h2 id="panics-12" class="section-header">Panics</h2> <p>Panics if <code>mid &gt; len</code>.</p> <h2 id="examples-31" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = [1, 0, 3, 0, 5, 6];
// scoped to restrict the lifetime of the borrows
{
    let (left, right) = v.split_at_mut(2);
    assert!(left == [1, 0]);
    assert!(right == [3, 0, 5, 6]);
    left[1] = 2;
    right[1] = 4;
}
assert!(v == [1, 2, 3, 4, 5, 6]);</pre></div> </div>
<h4 id="method.split" class="method">
<code>pub fn <a href="#method.split" class="fnname">split</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="slice/struct.split" title="struct std::slice::Split">Split</a>&lt;'_, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Split&lt;'a, T, P&gt;</h3>
<pre class="content">impl&lt;'a, T, P&gt; Iterator for Split&lt;'a, T, P&gt; where
    P: FnMut(&amp;T) -&gt; bool, 
    type Item = &amp;'a [T];
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="primitive.bool">bool</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1235-1240" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator over subslices separated by elements that match <code>pred</code>. The matched element is not contained in the subslices.</p> <h2 id="examples-32" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let slice = [10, 40, 33, 20];
let mut iter = slice.split(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &amp;[10, 40]);
assert_eq!(iter.next().unwrap(), &amp;[20]);
assert!(iter.next().is_none());</pre></div> <p>If the first element is matched, an empty slice will be the first item returned by the iterator. Similarly, if the last element in the slice is matched, an empty slice will be the last item returned by the iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let slice = [10, 40, 33];
let mut iter = slice.split(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &amp;[10, 40]);
assert_eq!(iter.next().unwrap(), &amp;[]);
assert!(iter.next().is_none());</pre></div> <p>If two matched elements are directly adjacent, an empty slice will be present between them:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let slice = [10, 6, 33, 20];
let mut iter = slice.split(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &amp;[10]);
assert_eq!(iter.next().unwrap(), &amp;[]);
assert_eq!(iter.next().unwrap(), &amp;[20]);
assert!(iter.next().is_none());</pre></div> </div>
<h4 id="method.split_mut" class="method">
<code>pub fn <a href="#method.split_mut" class="fnname">split_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="slice/struct.splitmut" title="struct std::slice::SplitMut">SplitMut</a>&lt;'_, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for SplitMut&lt;'a, T, P&gt;</h3>
<pre class="content">impl&lt;'a, T, P&gt; Iterator for SplitMut&lt;'a, T, P&gt; where
    P: FnMut(&amp;T) -&gt; bool, 
    type Item = &amp;'a mut [T];
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="primitive.bool">bool</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1257-1262" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator over mutable subslices separated by elements that match <code>pred</code>. The matched element is not contained in the subslices.</p> <h2 id="examples-33" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = [10, 40, 30, 20, 60, 50];

for group in v.split_mut(|num| *num % 3 == 0) {
    group[0] = 1;
}
assert_eq!(v, [1, 40, 30, 1, 60, 1]);</pre></div> </div>
<h4 id="method.split_inclusive" class="method">
<code>pub fn <a href="#method.split_inclusive" class="fnname">split_inclusive</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="https://doc.rust-lang.org/core/slice/struct.SplitInclusive.html" title="struct core::slice::SplitInclusive">SplitInclusive</a>&lt;'_, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for SplitInclusive&lt;'a, T, P&gt;</h3>
<pre class="content">impl&lt;'a, T, P&gt; Iterator for SplitInclusive&lt;'a, T, P&gt; where
    P: FnMut(&amp;T) -&gt; bool, 
    type Item = &amp;'a [T];
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="primitive.bool">bool</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1295-1300" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (split_inclusive #72360)</span></div>
<div class="docblock">
<p>Returns an iterator over subslices separated by elements that match <code>pred</code>. The matched element is contained in the end of the previous subslice as a terminator.</p> <h2 id="examples-34" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(split_inclusive)]
let slice = [10, 40, 33, 20];
let mut iter = slice.split_inclusive(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &amp;[10, 40, 33]);
assert_eq!(iter.next().unwrap(), &amp;[20]);
assert!(iter.next().is_none());</pre></div> <p>If the last element of the slice is matched, that element will be considered the terminator of the preceding slice. That slice will be the last item returned by the iterator.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(split_inclusive)]
let slice = [3, 10, 40, 33];
let mut iter = slice.split_inclusive(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &amp;[3]);
assert_eq!(iter.next().unwrap(), &amp;[10, 40, 33]);
assert!(iter.next().is_none());</pre></div> </div>
<h4 id="method.split_inclusive_mut" class="method">
<code>pub fn <a href="#method.split_inclusive_mut" class="fnname">split_inclusive_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="https://doc.rust-lang.org/core/slice/struct.SplitInclusiveMut.html" title="struct core::slice::SplitInclusiveMut">SplitInclusiveMut</a>&lt;'_, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for SplitInclusiveMut&lt;'a, T, P&gt;</h3>
<pre class="content">impl&lt;'a, T, P&gt; Iterator for SplitInclusiveMut&lt;'a, T, P&gt; where
    P: FnMut(&amp;T) -&gt; bool, 
    type Item = &amp;'a mut [T];
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="primitive.bool">bool</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1320-1325" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (split_inclusive #72360)</span></div>
<div class="docblock">
<p>Returns an iterator over mutable subslices separated by elements that match <code>pred</code>. The matched element is contained in the previous subslice as a terminator.</p> <h2 id="examples-35" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(split_inclusive)]
let mut v = [10, 40, 30, 20, 60, 50];

for group in v.split_inclusive_mut(|num| *num % 3 == 0) {
    let terminator_idx = group.len()-1;
    group[terminator_idx] = 1;
}
assert_eq!(v, [10, 40, 1, 20, 1, 1]);</pre></div> </div>
<h4 id="method.rsplit" class="method">
<code>pub fn <a href="#method.rsplit" class="fnname">rsplit</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="slice/struct.rsplit" title="struct std::slice::RSplit">RSplit</a>&lt;'_, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for RSplit&lt;'a, T, P&gt;</h3>
<pre class="content">impl&lt;'a, T, P&gt; Iterator for RSplit&lt;'a, T, P&gt; where
    P: FnMut(&amp;T) -&gt; bool, 
    type Item = &amp;'a [T];
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="primitive.bool">bool</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1356-1361" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span>
</h4>
<div class="docblock">
<p>Returns an iterator over subslices separated by elements that match <code>pred</code>, starting at the end of the slice and working backwards. The matched element is not contained in the subslices.</p> <h2 id="examples-36" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let slice = [11, 22, 33, 0, 44, 55];
let mut iter = slice.rsplit(|num| *num == 0);

assert_eq!(iter.next().unwrap(), &amp;[44, 55]);
assert_eq!(iter.next().unwrap(), &amp;[11, 22, 33]);
assert_eq!(iter.next(), None);</pre></div> <p>As with <code>split()</code>, if the first or last element is matched, an empty slice will be the first (or last) item returned by the iterator.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = &amp;[0, 1, 1, 2, 3, 5, 8];
let mut it = v.rsplit(|n| *n % 2 == 0);
assert_eq!(it.next().unwrap(), &amp;[]);
assert_eq!(it.next().unwrap(), &amp;[3, 5]);
assert_eq!(it.next().unwrap(), &amp;[1, 1]);
assert_eq!(it.next().unwrap(), &amp;[]);
assert_eq!(it.next(), None);</pre></div> </div>
<h4 id="method.rsplit_mut" class="method">
<code>pub fn <a href="#method.rsplit_mut" class="fnname">rsplit_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="slice/struct.rsplitmut" title="struct std::slice::RSplitMut">RSplitMut</a>&lt;'_, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for RSplitMut&lt;'a, T, P&gt;</h3>
<pre class="content">impl&lt;'a, T, P&gt; Iterator for RSplitMut&lt;'a, T, P&gt; where
    P: FnMut(&amp;T) -&gt; bool, 
    type Item = &amp;'a mut [T];
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="primitive.bool">bool</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1382-1387" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span>
</h4>
<div class="docblock">
<p>Returns an iterator over mutable subslices separated by elements that match <code>pred</code>, starting at the end of the slice and working backwards. The matched element is not contained in the subslices.</p> <h2 id="examples-37" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = [100, 400, 300, 200, 600, 500];

let mut count = 0;
for group in v.rsplit_mut(|num| *num % 3 == 0) {
    count += 1;
    group[0] = count;
}
assert_eq!(v, [3, 400, 300, 2, 600, 1]);</pre></div> </div>
<h4 id="method.splitn" class="method">
<code>pub fn <a href="#method.splitn" class="fnname">splitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="primitive.usize">usize</a>, pred: F) -&gt; <a class="struct" href="slice/struct.splitn" title="struct std::slice::SplitN">SplitN</a>&lt;'_, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for SplitN&lt;'a, T, P&gt;</h3>
<pre class="content">impl&lt;'a, T, P&gt; Iterator for SplitN&lt;'a, T, P&gt; where
    P: FnMut(&amp;T) -&gt; bool, 
    type Item = &amp;'a [T];
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="primitive.bool">bool</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1410-1415" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator over subslices separated by elements that match <code>pred</code>, limited to returning at most <code>n</code> items. The matched element is not contained in the subslices.</p> <p>The last element returned, if any, will contain the remainder of the slice.</p> <h2 id="examples-38" class="section-header">Examples</h2> <p>Print the slice split once by numbers divisible by 3 (i.e., <code>[10, 40]</code>, <code>[20, 60, 50]</code>):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = [10, 40, 30, 20, 60, 50];

for group in v.splitn(2, |num| *num % 3 == 0) {
    println!("{:?}", group);
}</pre></div> </div>
<h4 id="method.splitn_mut" class="method">
<code>pub fn <a href="#method.splitn_mut" class="fnname">splitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="primitive.usize">usize</a>, pred: F) -&gt; <a class="struct" href="slice/struct.splitnmut" title="struct std::slice::SplitNMut">SplitNMut</a>&lt;'_, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for SplitNMut&lt;'a, T, P&gt;</h3>
<pre class="content">impl&lt;'a, T, P&gt; Iterator for SplitNMut&lt;'a, T, P&gt; where
    P: FnMut(&amp;T) -&gt; bool, 
    type Item = &amp;'a mut [T];
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="primitive.bool">bool</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1436-1441" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator over subslices separated by elements that match <code>pred</code>, limited to returning at most <code>n</code> items. The matched element is not contained in the subslices.</p> <p>The last element returned, if any, will contain the remainder of the slice.</p> <h2 id="examples-39" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = [10, 40, 30, 20, 60, 50];

for group in v.splitn_mut(2, |num| *num % 3 == 0) {
    group[0] = 1;
}
assert_eq!(v, [1, 40, 30, 1, 60, 50]);</pre></div> </div>
<h4 id="method.rsplitn" class="method">
<code>pub fn <a href="#method.rsplitn" class="fnname">rsplitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="primitive.usize">usize</a>, pred: F) -&gt; <a class="struct" href="slice/struct.rsplitn" title="struct std::slice::RSplitN">RSplitN</a>&lt;'_, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for RSplitN&lt;'a, T, P&gt;</h3>
<pre class="content">impl&lt;'a, T, P&gt; Iterator for RSplitN&lt;'a, T, P&gt; where
    P: FnMut(&amp;T) -&gt; bool, 
    type Item = &amp;'a [T];
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="primitive.bool">bool</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1465-1470" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator over subslices separated by elements that match <code>pred</code> limited to returning at most <code>n</code> items. This starts at the end of the slice and works backwards. The matched element is not contained in the subslices.</p> <p>The last element returned, if any, will contain the remainder of the slice.</p> <h2 id="examples-40" class="section-header">Examples</h2> <p>Print the slice split once, starting from the end, by numbers divisible by 3 (i.e., <code>[50]</code>, <code>[10, 40, 30, 20]</code>):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = [10, 40, 30, 20, 60, 50];

for group in v.rsplitn(2, |num| *num % 3 == 0) {
    println!("{:?}", group);
}</pre></div> </div>
<h4 id="method.rsplitn_mut" class="method">
<code>pub fn <a href="#method.rsplitn_mut" class="fnname">rsplitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="primitive.usize">usize</a>, pred: F) -&gt; <a class="struct" href="slice/struct.rsplitnmut" title="struct std::slice::RSplitNMut">RSplitNMut</a>&lt;'_, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for RSplitNMut&lt;'a, T, P&gt;</h3>
<pre class="content">impl&lt;'a, T, P&gt; Iterator for RSplitNMut&lt;'a, T, P&gt; where
    P: FnMut(&amp;T) -&gt; bool, 
    type Item = &amp;'a mut [T];
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="primitive.bool">bool</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1492-1497" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator over subslices separated by elements that match <code>pred</code> limited to returning at most <code>n</code> items. This starts at the end of the slice and works backwards. The matched element is not contained in the subslices.</p> <p>The last element returned, if any, will contain the remainder of the slice.</p> <h2 id="examples-41" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = [10, 40, 30, 20, 60, 50];

for group in s.rsplitn_mut(2, |num| *num % 3 == 0) {
    group[0] = 1;
}
assert_eq!(s, [1, 40, 30, 20, 60, 1]);</pre></div> </div>
<h4 id="method.contains" class="method">
<code>pub fn <a href="#method.contains" class="fnname">contains</a>(&amp;self, x: <a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="primitive.bool">bool</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1518-1523" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns <code>true</code> if the slice contains an element with the given value.</p> <h2 id="examples-42" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = [10, 40, 30];
assert!(v.contains(&amp;30));
assert!(!v.contains(&amp;50));</pre></div> <p>If you do not have an <code>&amp;T</code>, but just an <code>&amp;U</code> such that <code>T: Borrow&lt;U&gt;</code> (e.g. <code>String: Borrow&lt;str&gt;</code>), you can use <code>iter().any</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = [String::from("hello"), String::from("world")]; // slice of `String`
assert!(v.iter().any(|e| e == "hello")); // search with `&amp;str`
assert!(!v.iter().any(|e| e == "hi"));</pre></div> </div>
<h4 id="method.starts_with" class="method">
<code>pub fn <a href="#method.starts_with" class="fnname">starts_with</a>(&amp;self, needle: <a class="primitive" href="primitive.slice">&amp;[T]</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1546-1552" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns <code>true</code> if <code>needle</code> is a prefix of the slice.</p> <h2 id="examples-43" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = [10, 40, 30];
assert!(v.starts_with(&amp;[10]));
assert!(v.starts_with(&amp;[10, 40]));
assert!(!v.starts_with(&amp;[50]));
assert!(!v.starts_with(&amp;[10, 50]));</pre></div> <p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = &amp;[10, 40, 30];
assert!(v.starts_with(&amp;[]));
let v: &amp;[u8] = &amp;[];
assert!(v.starts_with(&amp;[]));</pre></div> </div>
<h4 id="method.ends_with" class="method">
<code>pub fn <a href="#method.ends_with" class="fnname">ends_with</a>(&amp;self, needle: <a class="primitive" href="primitive.slice">&amp;[T]</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1575-1581" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns <code>true</code> if <code>needle</code> is a suffix of the slice.</p> <h2 id="examples-44" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = [10, 40, 30];
assert!(v.ends_with(&amp;[30]));
assert!(v.ends_with(&amp;[40, 30]));
assert!(!v.ends_with(&amp;[50]));
assert!(!v.ends_with(&amp;[50, 30]));</pre></div> <p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = &amp;[10, 40, 30];
assert!(v.ends_with(&amp;[]));
let v: &amp;[u8] = &amp;[];
assert!(v.ends_with(&amp;[]));</pre></div> </div>
<h4 id="method.strip_prefix" class="method">
<code><span class="docblock attributes">#[must_use = "returns the subslice without modifying the original"]</span>pub fn <a href="#method.strip_prefix" class="fnname">strip_prefix</a>(&amp;self, prefix: <a class="primitive" href="primitive.slice">&amp;[T]</a>) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.slice">&amp;[T]</a>&gt; <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1600-1612" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_strip #73413)</span></div>
<div class="docblock">
<p>Returns a subslice with the prefix removed.</p> <p>This method returns <a href="option/enum.option#variant.None" title="`None`"><code>None</code></a> if slice does not start with <code>prefix</code>. Also it returns the original slice if <code>prefix</code> is an empty slice.</p> <h2 id="examples-45" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_strip)]
let v = &amp;[10, 40, 30];
assert_eq!(v.strip_prefix(&amp;[10]), Some(&amp;[40, 30][..]));
assert_eq!(v.strip_prefix(&amp;[10, 40]), Some(&amp;[30][..]));
assert_eq!(v.strip_prefix(&amp;[50]), None);
assert_eq!(v.strip_prefix(&amp;[10, 50]), None);</pre></div> </div>
<h4 id="method.strip_suffix" class="method">
<code><span class="docblock attributes">#[must_use = "returns the subslice without modifying the original"]</span>pub fn <a href="#method.strip_suffix" class="fnname">strip_suffix</a>(&amp;self, suffix: <a class="primitive" href="primitive.slice">&amp;[T]</a>) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.slice">&amp;[T]</a>&gt; <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1631-1643" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_strip #73413)</span></div>
<div class="docblock">
<p>Returns a subslice with the suffix removed.</p> <p>This method returns <a href="option/enum.option#variant.None" title="`None`"><code>None</code></a> if slice does not end with <code>suffix</code>. Also it returns the original slice if <code>suffix</code> is an empty slice</p> <h2 id="examples-46" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_strip)]
let v = &amp;[10, 40, 30];
assert_eq!(v.strip_suffix(&amp;[30]), Some(&amp;[10, 40][..]));
assert_eq!(v.strip_suffix(&amp;[40, 30]), Some(&amp;[10][..]));
assert_eq!(v.strip_suffix(&amp;[50]), None);
assert_eq!(v.strip_suffix(&amp;[50, 30]), None);</pre></div> </div>
<h4 id="method.binary_search" class="method">
<code>pub fn <a href="#method.binary_search" class="fnname">binary_search</a>(&amp;self, x: <a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="enum" href="result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.usize">usize</a>, <a class="primitive" href="primitive.usize">usize</a>&gt; <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1680-1685" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Binary searches this sorted slice for a given element.</p> <p>If the value is found then <a href="result/enum.result#variant.Ok" title="`Result::Ok`"><code>Result::Ok</code></a> is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then <a href="result/enum.result#variant.Err" title="`Result::Err`"><code>Result::Err</code></a> is returned, containing the index where a matching element could be inserted while maintaining sorted order.</p> <h2 id="examples-47" class="section-header">Examples</h2> <p>Looks up a series of four elements. The first is found, with a uniquely determined position; the second and third are not found; the fourth could match any position in <code>[1, 4]</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];

assert_eq!(s.binary_search(&amp;13),  Ok(9));
assert_eq!(s.binary_search(&amp;4),   Err(7));
assert_eq!(s.binary_search(&amp;100), Err(13));
let r = s.binary_search(&amp;1);
assert!(match r { Ok(1..=4) =&gt; true, _ =&gt; false, });</pre></div> <p>If you want to insert an item to a sorted vector, while maintaining sort order:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
let num = 42;
let idx = s.binary_search(&amp;num).unwrap_or_else(|x| x);
s.insert(idx, num);
assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);</pre></div> </div>
<h4 id="method.binary_search_by" class="method">
<code>pub fn <a href="#method.binary_search_by" class="fnname">binary_search_by</a>&lt;'a, F&gt;(&amp;'a self, f: F) -&gt; <a class="enum" href="result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.usize">usize</a>, <a class="primitive" href="primitive.usize">usize</a>&gt; <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;'a </a>T) -&gt; <a class="enum" href="cmp/enum.ordering" title="enum std::cmp::Ordering">Ordering</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1721-1744" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Binary searches this sorted slice with a comparator function.</p> <p>The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code that indicates whether its argument is <code>Less</code>, <code>Equal</code> or <code>Greater</code> the desired target.</p> <p>If the value is found then <a href="result/enum.result#variant.Ok" title="`Result::Ok`"><code>Result::Ok</code></a> is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then <a href="result/enum.result#variant.Err" title="`Result::Err`"><code>Result::Err</code></a> is returned, containing the index where a matching element could be inserted while maintaining sorted order.</p> <h2 id="examples-48" class="section-header">Examples</h2> <p>Looks up a series of four elements. The first is found, with a uniquely determined position; the second and third are not found; the fourth could match any position in <code>[1, 4]</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];

let seek = 13;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&amp;seek)), Ok(9));
let seek = 4;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&amp;seek)), Err(7));
let seek = 100;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&amp;seek)), Err(13));
let seek = 1;
let r = s.binary_search_by(|probe| probe.cmp(&amp;seek));
assert!(match r { Ok(1..=4) =&gt; true, _ =&gt; false, });</pre></div> </div>
<h4 id="method.binary_search_by_key" class="method">
<code>pub fn <a href="#method.binary_search_by_key" class="fnname">binary_search_by_key</a>&lt;'a, B, F&gt;(<br>    &amp;'a self, <br>    b: <a class="primitive" href="primitive.reference">&amp;</a>B, <br>    f: F<br>) -&gt; <a class="enum" href="result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.usize">usize</a>, <a class="primitive" href="primitive.usize">usize</a>&gt; <span class="where fmt-newline">where<br>    B: <a class="trait" href="cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>,<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;'a </a>T) -&gt; B, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1779-1785" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.10.0">1.10.0</span>
</h4>
<div class="docblock">
<p>Binary searches this sorted slice with a key extraction function.</p> <p>Assumes that the slice is sorted by the key, for instance with <a href="#method.sort_by_key"><code>sort_by_key</code></a> using the same key extraction function.</p> <p>If the value is found then <a href="result/enum.result#variant.Ok" title="`Result::Ok`"><code>Result::Ok</code></a> is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then <a href="result/enum.result#variant.Err" title="`Result::Err`"><code>Result::Err</code></a> is returned, containing the index where a matching element could be inserted while maintaining sorted order.</p> <h2 id="examples-49" class="section-header">Examples</h2> <p>Looks up a series of four elements in a slice of pairs sorted by their second elements. The first is found, with a uniquely determined position; the second and third are not found; the fourth could match any position in <code>[1, 4]</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),
         (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),
         (1, 21), (2, 34), (4, 55)];

assert_eq!(s.binary_search_by_key(&amp;13, |&amp;(a,b)| b),  Ok(9));
assert_eq!(s.binary_search_by_key(&amp;4, |&amp;(a,b)| b),   Err(7));
assert_eq!(s.binary_search_by_key(&amp;100, |&amp;(a,b)| b), Err(13));
let r = s.binary_search_by_key(&amp;1, |&amp;(a,b)| b);
assert!(match r { Ok(1..=4) =&gt; true, _ =&gt; false, });</pre></div> </div>
<h4 id="method.sort_unstable" class="method">
<code>pub fn <a href="#method.sort_unstable" class="fnname">sort_unstable</a>(&amp;mut self) <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1815-1820" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span>
</h4>
<div class="docblock">
<p>Sorts the slice, but may not preserve the order of equal elements.</p> <p>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and <em>O</em>(<em>n</em> * log(<em>n</em>)) worst-case.</p> <h2 id="current-implementation" class="section-header">Current implementation</h2> <p>The current algorithm is based on <a href="https://github.com/orlp/pdqsort">pattern-defeating quicksort</a> by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.</p> <p>It is typically faster than stable sorting, except in a few special cases, e.g., when the slice consists of several concatenated sorted sequences.</p> <h2 id="examples-50" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = [-5, 4, 1, -3, 2];

v.sort_unstable();
assert!(v == [-5, -3, 1, 2, 4]);</pre></div> </div>
<h4 id="method.sort_unstable_by" class="method">
<code>pub fn <a href="#method.sort_unstable_by" class="fnname">sort_unstable_by</a>&lt;F&gt;(&amp;mut self, compare: F) <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T, <a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="enum" href="cmp/enum.ordering" title="enum std::cmp::Ordering">Ordering</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1870-1875" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span>
</h4>
<div class="docblock">
<p>Sorts the slice with a comparator function, but may not preserve the order of equal elements.</p> <p>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and <em>O</em>(<em>n</em> * log(<em>n</em>)) worst-case.</p> <p>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all a, b and c):</p> <ul> <li>total and antisymmetric: exactly one of a &lt; b, a == b or a &gt; b is true; and</li> <li>transitive, a &lt; b and b &lt; c implies a &lt; c. The same must hold for both == and &gt;.</li> </ul> <p>For example, while <a href="primitive.f64" title="`f64`"><code>f64</code></a> doesn't implement <a href="cmp/trait.ord" title="`Ord`"><code>Ord</code></a> because <code>NaN != NaN</code>, we can use <code>partial_cmp</code> as our sort function when we know the slice doesn't contain a <code>NaN</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut floats = [5f64, 4.0, 1.0, 3.0, 2.0];
floats.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());
assert_eq!(floats, [1.0, 2.0, 3.0, 4.0, 5.0]);</pre></div> <h2 id="current-implementation-1" class="section-header">Current implementation</h2> <p>The current algorithm is based on <a href="https://github.com/orlp/pdqsort">pattern-defeating quicksort</a> by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.</p> <p>It is typically faster than stable sorting, except in a few special cases, e.g., when the slice consists of several concatenated sorted sequences.</p> <h2 id="examples-51" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = [5, 4, 1, 3, 2];
v.sort_unstable_by(|a, b| a.cmp(b));
assert!(v == [1, 2, 3, 4, 5]);

// reverse sorting
v.sort_unstable_by(|a, b| b.cmp(a));
assert!(v == [5, 4, 3, 2, 1]);</pre></div> </div>
<h4 id="method.sort_unstable_by_key" class="method">
<code>pub fn <a href="#method.sort_unstable_by_key" class="fnname">sort_unstable_by_key</a>&lt;K, F&gt;(&amp;mut self, f: F) <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; K,<br>    K: <a class="trait" href="cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1908-1914" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span>
</h4>
<div class="docblock">
<p>Sorts the slice with a key extraction function, but may not preserve the order of equal elements.</p> <p>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and <em>O</em>(m * <em>n</em> * log(<em>n</em>)) worst-case, where the key function is <em>O</em>(<em>m</em>).</p> <h2 id="current-implementation-2" class="section-header">Current implementation</h2> <p>The current algorithm is based on <a href="https://github.com/orlp/pdqsort">pattern-defeating quicksort</a> by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.</p> <p>Due to its key calling strategy, <a href="#method.sort_unstable_by_key"><code>sort_unstable_by_key</code></a> is likely to be slower than <a href="#method.sort_by_cached_key"><code>sort_by_cached_key</code></a> in cases where the key function is expensive.</p> <h2 id="examples-52" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = [-5i32, 4, 1, -3, 2];

v.sort_unstable_by_key(|k| k.abs());
assert!(v == [1, 2, -3, 4, -5]);</pre></div> </div>
<h4 id="method.partition_at_index" class="method">
<code>pub fn <a href="#method.partition_at_index" class="fnname">partition_at_index</a>(<br>    &amp;mut self, <br>    index: <a class="primitive" href="primitive.usize">usize</a><br>) -&gt; <a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.slice">&amp;mut [T]</a>, <a class="primitive" href="primitive.reference">&amp;mut </a>T, <a class="primitive" href="primitive.slice">&amp;mut [T]</a><a class="primitive" href="primitive.tuple">)</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#1956-1962" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_partition_at_index #55300)</span></div>
<div class="docblock">
<p>Reorder the slice such that the element at <code>index</code> is at its final sorted position.</p> <p>This reordering has the additional property that any value at position <code>i &lt; index</code> will be less than or equal to any value at a position <code>j &gt; index</code>. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position <code>index</code>), in-place (i.e. does not allocate), and <em>O</em>(<em>n</em>) worst-case. This function is also/ known as "kth element" in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</p> <h2 id="current-implementation-3" class="section-header">Current implementation</h2> <p>The current algorithm is based on the quickselect portion of the same quicksort algorithm used for <a href="#method.sort_unstable"><code>sort_unstable</code></a>.</p> <h2 id="panics-13" class="section-header">Panics</h2> <p>Panics when <code>index &gt;= len()</code>, meaning it always panics on empty slices.</p> <h2 id="examples-53" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_partition_at_index)]

let mut v = [-5i32, 4, 1, -3, 2];

// Find the median
v.partition_at_index(2);

// We are only guaranteed the slice will be one of the following, based on the way we sort
// about the specified index.
assert!(v == [-3, -5, 1, 2, 4] ||
        v == [-5, -3, 1, 2, 4] ||
        v == [-3, -5, 1, 4, 2] ||
        v == [-5, -3, 1, 4, 2]);</pre></div> </div>
<h4 id="method.partition_at_index_by" class="method">
<code>pub fn <a href="#method.partition_at_index_by" class="fnname">partition_at_index_by</a>&lt;F&gt;(<br>    &amp;mut self, <br>    index: <a class="primitive" href="primitive.usize">usize</a>, <br>    compare: F<br>) -&gt; <a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.slice">&amp;mut [T]</a>, <a class="primitive" href="primitive.reference">&amp;mut </a>T, <a class="primitive" href="primitive.slice">&amp;mut [T]</a><a class="primitive" href="primitive.tuple">)</a> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T, <a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="enum" href="cmp/enum.ordering" title="enum std::cmp::Ordering">Ordering</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2006-2016" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_partition_at_index #55300)</span></div>
<div class="docblock">
<p>Reorder the slice with a comparator function such that the element at <code>index</code> is at its final sorted position.</p> <p>This reordering has the additional property that any value at position <code>i &lt; index</code> will be less than or equal to any value at a position <code>j &gt; index</code> using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position <code>index</code>), in-place (i.e. does not allocate), and <em>O</em>(<em>n</em>) worst-case. This function is also known as "kth element" in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</p> <h2 id="current-implementation-4" class="section-header">Current implementation</h2> <p>The current algorithm is based on the quickselect portion of the same quicksort algorithm used for <a href="#method.sort_unstable"><code>sort_unstable</code></a>.</p> <h2 id="panics-14" class="section-header">Panics</h2> <p>Panics when <code>index &gt;= len()</code>, meaning it always panics on empty slices.</p> <h2 id="examples-54" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_partition_at_index)]

let mut v = [-5i32, 4, 1, -3, 2];

// Find the median as if the slice were sorted in descending order.
v.partition_at_index_by(2, |a, b| b.cmp(a));

// We are only guaranteed the slice will be one of the following, based on the way we sort
// about the specified index.
assert!(v == [2, 4, 1, -5, -3] ||
        v == [2, 4, 1, -3, -5] ||
        v == [4, 2, 1, -5, -3] ||
        v == [4, 2, 1, -3, -5]);</pre></div> </div>
<h4 id="method.partition_at_index_by_key" class="method">
<code>pub fn <a href="#method.partition_at_index_by_key" class="fnname">partition_at_index_by_key</a>&lt;K, F&gt;(<br>    &amp;mut self, <br>    index: <a class="primitive" href="primitive.usize">usize</a>, <br>    f: F<br>) -&gt; <a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.slice">&amp;mut [T]</a>, <a class="primitive" href="primitive.reference">&amp;mut </a>T, <a class="primitive" href="primitive.slice">&amp;mut [T]</a><a class="primitive" href="primitive.tuple">)</a> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; K,<br>    K: <a class="trait" href="cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2060-2071" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_partition_at_index #55300)</span></div>
<div class="docblock">
<p>Reorder the slice with a key extraction function such that the element at <code>index</code> is at its final sorted position.</p> <p>This reordering has the additional property that any value at position <code>i &lt; index</code> will be less than or equal to any value at a position <code>j &gt; index</code> using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position <code>index</code>), in-place (i.e. does not allocate), and <em>O</em>(<em>n</em>) worst-case. This function is also known as "kth element" in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</p> <h2 id="current-implementation-5" class="section-header">Current implementation</h2> <p>The current algorithm is based on the quickselect portion of the same quicksort algorithm used for <a href="#method.sort_unstable"><code>sort_unstable</code></a>.</p> <h2 id="panics-15" class="section-header">Panics</h2> <p>Panics when <code>index &gt;= len()</code>, meaning it always panics on empty slices.</p> <h2 id="examples-55" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_partition_at_index)]

let mut v = [-5i32, 4, 1, -3, 2];

// Return the median as if the array were sorted according to absolute value.
v.partition_at_index_by_key(2, |a| a.abs());

// We are only guaranteed the slice will be one of the following, based on the way we sort
// about the specified index.
assert!(v == [1, 2, -3, 4, -5] ||
        v == [1, 2, -3, -5, 4] ||
        v == [2, 1, -3, 4, -5] ||
        v == [2, 1, -3, -5, 4]);</pre></div> </div>
<h4 id="method.partition_dedup" class="method">
<code>pub fn <a href="#method.partition_dedup" class="fnname">partition_dedup</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.slice">&amp;mut [T]</a>, <a class="primitive" href="primitive.slice">&amp;mut [T]</a><a class="primitive" href="primitive.tuple">)</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2095-2100" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_partition_dedup #54279)</span></div>
<div class="docblock">
<p>Moves all consecutive repeated elements to the end of the slice according to the <a href="cmp/trait.partialeq" title="`PartialEq`"><code>PartialEq</code></a> trait implementation.</p> <p>Returns two slices. The first contains no consecutive repeated elements. The second contains all the duplicates in no specified order.</p> <p>If the slice is sorted, the first returned slice contains no duplicates.</p> <h2 id="examples-56" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_partition_dedup)]

let mut slice = [1, 2, 2, 3, 3, 2, 1, 1];

let (dedup, duplicates) = slice.partition_dedup();

assert_eq!(dedup, [1, 2, 3, 2, 1]);
assert_eq!(duplicates, [2, 3, 1]);</pre></div> </div>
<h4 id="method.partition_dedup_by" class="method">
<code>pub fn <a href="#method.partition_dedup_by" class="fnname">partition_dedup_by</a>&lt;F&gt;(&amp;mut self, same_bucket: F) -&gt; <a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.slice">&amp;mut [T]</a>, <a class="primitive" href="primitive.slice">&amp;mut [T]</a><a class="primitive" href="primitive.tuple">)</a> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;mut </a>T, <a class="primitive" href="primitive.reference">&amp;mut </a>T) -&gt; <a class="primitive" href="primitive.bool">bool</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2129-2231" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_partition_dedup #54279)</span></div>
<div class="docblock">
<p>Moves all but the first of consecutive elements to the end of the slice satisfying a given equality relation.</p> <p>Returns two slices. The first contains no consecutive repeated elements. The second contains all the duplicates in no specified order.</p> <p>The <code>same_bucket</code> function is passed references to two elements from the slice and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if <code>same_bucket(a, b)</code> returns <code>true</code>, <code>a</code> is moved at the end of the slice.</p> <p>If the slice is sorted, the first returned slice contains no duplicates.</p> <h2 id="examples-57" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_partition_dedup)]

let mut slice = ["foo", "Foo", "BAZ", "Bar", "bar", "baz", "BAZ"];

let (dedup, duplicates) = slice.partition_dedup_by(|a, b| a.eq_ignore_ascii_case(b));

assert_eq!(dedup, ["foo", "BAZ", "Bar", "baz"]);
assert_eq!(duplicates, ["bar", "Foo", "BAZ"]);</pre></div> </div>
<h4 id="method.partition_dedup_by_key" class="method">
<code>pub fn <a href="#method.partition_dedup_by_key" class="fnname">partition_dedup_by_key</a>&lt;K, F&gt;(&amp;mut self, key: F) -&gt; <a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.slice">&amp;mut [T]</a>, <a class="primitive" href="primitive.slice">&amp;mut [T]</a><a class="primitive" href="primitive.tuple">)</a> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;mut </a>T) -&gt; K,<br>    K: <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;K&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2255-2261" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_partition_dedup #54279)</span></div>
<div class="docblock">
<p>Moves all but the first of consecutive elements to the end of the slice that resolve to the same key.</p> <p>Returns two slices. The first contains no consecutive repeated elements. The second contains all the duplicates in no specified order.</p> <p>If the slice is sorted, the first returned slice contains no duplicates.</p> <h2 id="examples-58" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_partition_dedup)]

let mut slice = [10, 20, 21, 30, 30, 20, 11, 13];

let (dedup, duplicates) = slice.partition_dedup_by_key(|i| *i / 10);

assert_eq!(dedup, [10, 20, 30, 20, 11]);
assert_eq!(duplicates, [21, 30, 13]);</pre></div> </div>
<h4 id="method.rotate_left" class="method">
<code>pub fn <a href="#method.rotate_left" class="fnname">rotate_left</a>(&amp;mut self, mid: <a class="primitive" href="primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2294-2304" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span>
</h4>
<div class="docblock">
<p>Rotates the slice in-place such that the first <code>mid</code> elements of the slice move to the end while the last <code>self.len() - mid</code> elements move to the front. After calling <code>rotate_left</code>, the element previously at index <code>mid</code> will become the first element in the slice.</p> <h2 id="panics-16" class="section-header">Panics</h2> <p>This function will panic if <code>mid</code> is greater than the length of the slice. Note that <code>mid == self.len()</code> does <em>not</em> panic and is a no-op rotation.</p> <h2 id="complexity" class="section-header">Complexity</h2> <p>Takes linear (in <code>self.len()</code>) time.</p> <h2 id="examples-59" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];
a.rotate_left(2);
assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);</pre></div> <p>Rotating a subslice:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];
a[1..5].rotate_left(1);
assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);</pre></div> </div>
<h4 id="method.rotate_right" class="method">
<code>pub fn <a href="#method.rotate_right" class="fnname">rotate_right</a>(&amp;mut self, k: <a class="primitive" href="primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2337-2347" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span>
</h4>
<div class="docblock">
<p>Rotates the slice in-place such that the first <code>self.len() - k</code> elements of the slice move to the end while the last <code>k</code> elements move to the front. After calling <code>rotate_right</code>, the element previously at index <code>self.len() - k</code> will become the first element in the slice.</p> <h2 id="panics-17" class="section-header">Panics</h2> <p>This function will panic if <code>k</code> is greater than the length of the slice. Note that <code>k == self.len()</code> does <em>not</em> panic and is a no-op rotation.</p> <h2 id="complexity-1" class="section-header">Complexity</h2> <p>Takes linear (in <code>self.len()</code>) time.</p> <h2 id="examples-60" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];
a.rotate_right(2);
assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);</pre></div> <p>Rotate a subslice:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];
a[1..5].rotate_right(1);
assert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);</pre></div> </div>
<h4 id="method.fill" class="method">
<code>pub fn <a href="#method.fill" class="fnname">fill</a>(&amp;mut self, value: T) <span class="where fmt-newline">where<br>    T: <a class="trait" href="clone/trait.clone" title="trait std::clone::Clone">Clone</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2361-2372" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_fill #70758)</span></div>
<div class="docblock">
<p>Fills <code>self</code> with elements by cloning <code>value</code>.</p> <h2 id="examples-61" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(slice_fill)]

let mut buf = vec![0; 10];
buf.fill(1);
assert_eq!(buf, vec![1; 10]);</pre></div> </div>
<h4 id="method.clone_from_slice" class="method">
<code>pub fn <a href="#method.clone_from_slice" class="fnname">clone_from_slice</a>(&amp;mut self, src: <a class="primitive" href="primitive.slice">&amp;[T]</a>) <span class="where fmt-newline">where<br>    T: <a class="trait" href="clone/trait.clone" title="trait std::clone::Clone">Clone</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2430-2443" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.7.0">1.7.0</span>
</h4>
<div class="docblock">
<p>Copies the elements from <code>src</code> into <code>self</code>.</p> <p>The length of <code>src</code> must be the same as <code>self</code>.</p> <p>If <code>T</code> implements <code>Copy</code>, it can be more performant to use <a href="#method.copy_from_slice"><code>copy_from_slice</code></a>.</p> <h2 id="panics-18" class="section-header">Panics</h2> <p>This function will panic if the two slices have different lengths.</p> <h2 id="examples-62" class="section-header">Examples</h2> <p>Cloning two elements from a slice into another:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let src = [1, 2, 3, 4];
let mut dst = [0, 0];

// Because the slices have to be the same length,
// we slice the source slice from four elements
// to two. It will panic if we don't do this.
dst.clone_from_slice(&amp;src[2..]);

assert_eq!(src, [1, 2, 3, 4]);
assert_eq!(dst, [3, 4]);</pre></div> <p>Rust enforces that there can only be one mutable reference with no immutable references to a particular piece of data in a particular scope. Because of this, attempting to use <code>clone_from_slice</code> on a single slice will result in a compile failure:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut slice = [1, 2, 3, 4, 5];

slice[..2].clone_from_slice(&amp;slice[3..]); // compile fail!</pre></div> <p>To work around this, we can use <a href="#method.split_at_mut"><code>split_at_mut</code></a> to create two distinct sub-slices from a slice:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut slice = [1, 2, 3, 4, 5];

{
    let (left, right) = slice.split_at_mut(2);
    left.clone_from_slice(&amp;right[1..]);
}

assert_eq!(slice, [4, 5, 3, 4, 5]);</pre></div> </div>
<h4 id="method.copy_from_slice" class="method">
<code>pub fn <a href="#method.copy_from_slice" class="fnname">copy_from_slice</a>(&amp;mut self, src: <a class="primitive" href="primitive.slice">&amp;[T]</a>) <span class="where fmt-newline">where<br>    T: <a class="trait" href="marker/trait.copy" title="trait std::marker::Copy">Copy</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2500-2526" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span>
</h4>
<div class="docblock">
<p>Copies all elements from <code>src</code> into <code>self</code>, using a memcpy.</p> <p>The length of <code>src</code> must be the same as <code>self</code>.</p> <p>If <code>T</code> does not implement <code>Copy</code>, use <a href="#method.clone_from_slice"><code>clone_from_slice</code></a>.</p> <h2 id="panics-19" class="section-header">Panics</h2> <p>This function will panic if the two slices have different lengths.</p> <h2 id="examples-63" class="section-header">Examples</h2> <p>Copying two elements from a slice into another:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let src = [1, 2, 3, 4];
let mut dst = [0, 0];

// Because the slices have to be the same length,
// we slice the source slice from four elements
// to two. It will panic if we don't do this.
dst.copy_from_slice(&amp;src[2..]);

assert_eq!(src, [1, 2, 3, 4]);
assert_eq!(dst, [3, 4]);</pre></div> <p>Rust enforces that there can only be one mutable reference with no immutable references to a particular piece of data in a particular scope. Because of this, attempting to use <code>copy_from_slice</code> on a single slice will result in a compile failure:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut slice = [1, 2, 3, 4, 5];

slice[..2].copy_from_slice(&amp;slice[3..]); // compile fail!</pre></div> <p>To work around this, we can use <a href="#method.split_at_mut"><code>split_at_mut</code></a> to create two distinct sub-slices from a slice:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut slice = [1, 2, 3, 4, 5];

{
    let (left, right) = slice.split_at_mut(2);
    left.copy_from_slice(&amp;right[1..]);
}

assert_eq!(slice, [4, 5, 3, 4, 5]);</pre></div> </div>
<h4 id="method.copy_within" class="method">
<code>pub fn <a href="#method.copy_within" class="fnname">copy_within</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="primitive.usize">usize</a>) <span class="where fmt-newline">where<br>    R: <a class="trait" href="ops/trait.rangebounds" title="trait std::ops::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="primitive.usize">usize</a>&gt;,<br>    T: <a class="trait" href="marker/trait.copy" title="trait std::marker::Copy">Copy</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2554-2581" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.37.0">1.37.0</span>
</h4>
<div class="docblock">
<p>Copies elements from one part of the slice to another part of itself, using a memmove.</p> <p><code>src</code> is the range within <code>self</code> to copy from. <code>dest</code> is the starting index of the range within <code>self</code> to copy to, which will have the same length as <code>src</code>. The two ranges may overlap. The ends of the two ranges must be less than or equal to <code>self.len()</code>.</p> <h2 id="panics-20" class="section-header">Panics</h2> <p>This function will panic if either range exceeds the end of the slice, or if the end of <code>src</code> is before the start.</p> <h2 id="examples-64" class="section-header">Examples</h2> <p>Copying four bytes within a slice:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut bytes = *b"Hello, World!";

bytes.copy_within(1..5, 8);

assert_eq!(&amp;bytes, b"Hello, Wello!");</pre></div> </div>
<h4 id="method.swap_with_slice" class="method">
<code>pub fn <a href="#method.swap_with_slice" class="fnname">swap_with_slice</a>(&amp;mut self, other: <a class="primitive" href="primitive.slice">&amp;mut [T]</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2631-2639" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span>
</h4>
<div class="docblock">
<p>Swaps all elements in <code>self</code> with those in <code>other</code>.</p> <p>The length of <code>other</code> must be the same as <code>self</code>.</p> <h2 id="panics-21" class="section-header">Panics</h2> <p>This function will panic if the two slices have different lengths.</p> <h2 id="example" class="section-header">Example</h2> <p>Swapping two elements across slices:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut slice1 = [0, 0];
let mut slice2 = [1, 2, 3, 4];

slice1.swap_with_slice(&amp;mut slice2[2..]);

assert_eq!(slice1, [3, 4]);
assert_eq!(slice2, [1, 2, 0, 0]);</pre></div> <p>Rust enforces that there can only be one mutable reference to a particular piece of data in a particular scope. Because of this, attempting to use <code>swap_with_slice</code> on a single slice will result in a compile failure:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let mut slice = [1, 2, 3, 4, 5];
slice[..2].swap_with_slice(&amp;mut slice[3..]); // compile fail!</pre></div> <p>To work around this, we can use <a href="#method.split_at_mut"><code>split_at_mut</code></a> to create two distinct mutable sub-slices from a slice:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut slice = [1, 2, 3, 4, 5];

{
    let (left, right) = slice.split_at_mut(2);
    left.swap_with_slice(&amp;mut right[1..]);
}

assert_eq!(slice, [4, 5, 3, 1, 2]);</pre></div> </div>
<h4 id="method.align_to" class="method">
<code>pub unsafe fn <a href="#method.align_to" class="fnname">align_to</a>&lt;U&gt;(&amp;self) -&gt; <a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.slice">&amp;[T]</a>, <a class="primitive" href="primitive.slice">&amp;[U]</a>, <a class="primitive" href="primitive.slice">&amp;[T]</a><a class="primitive" href="primitive.tuple">)</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2740-2767" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span>
</h4>
<div class="docblock">
<p>Transmute the slice to a slice of another type, ensuring alignment of the types is maintained.</p> <p>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method may make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness. It is permissible for all of the input data to be returned as the prefix or suffix slice.</p> <p>This method has no purpose when either input element <code>T</code> or output element <code>U</code> are zero-sized and will return the original slice without splitting anything.</p> <h2 id="safety" class="section-header">Safety</h2> <p>This method is essentially a <code>transmute</code> with respect to the elements in the returned middle slice, so all the usual caveats pertaining to <code>transmute::&lt;T, U&gt;</code> also apply here.</p> <h2 id="examples-65" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
unsafe {
    let bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];
    let (prefix, shorts, suffix) = bytes.align_to::&lt;u16&gt;();
    // less_efficient_algorithm_for_bytes(prefix);
    // more_efficient_algorithm_for_aligned_shorts(shorts);
    // less_efficient_algorithm_for_bytes(suffix);
}</pre></div> </div>
<h4 id="method.align_to_mut" class="method">
<code>pub unsafe fn <a href="#method.align_to_mut" class="fnname">align_to_mut</a>&lt;U&gt;(&amp;mut self) -&gt; <a class="primitive" href="primitive.tuple">(</a><a class="primitive" href="primitive.slice">&amp;mut [T]</a>, <a class="primitive" href="primitive.slice">&amp;mut [U]</a>, <a class="primitive" href="primitive.slice">&amp;mut [T]</a><a class="primitive" href="primitive.tuple">)</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2800-2835" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span>
</h4>
<div class="docblock">
<p>Transmute the slice to a slice of another type, ensuring alignment of the types is maintained.</p> <p>This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix slice. The method may make the middle slice the greatest length possible for a given type and input slice, but only your algorithm's performance should depend on that, not its correctness. It is permissible for all of the input data to be returned as the prefix or suffix slice.</p> <p>This method has no purpose when either input element <code>T</code> or output element <code>U</code> are zero-sized and will return the original slice without splitting anything.</p> <h2 id="safety-1" class="section-header">Safety</h2> <p>This method is essentially a <code>transmute</code> with respect to the elements in the returned middle slice, so all the usual caveats pertaining to <code>transmute::&lt;T, U&gt;</code> also apply here.</p> <h2 id="examples-66" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
unsafe {
    let mut bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];
    let (prefix, shorts, suffix) = bytes.align_to_mut::&lt;u16&gt;();
    // less_efficient_algorithm_for_bytes(prefix);
    // more_efficient_algorithm_for_aligned_shorts(shorts);
    // less_efficient_algorithm_for_bytes(suffix);
}</pre></div> </div>
<h4 id="method.is_sorted" class="method">
<code>pub fn <a href="#method.is_sorted" class="fnname">is_sorted</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool">bool</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.partialord" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2860-2865" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (is_sorted #53485)new API </span></div>
<div class="docblock">
<p>Checks if the elements of this slice are sorted.</p> <p>That is, for each element <code>a</code> and its following element <code>b</code>, <code>a &lt;= b</code> must hold. If the slice yields exactly zero or one element, <code>true</code> is returned.</p> <p>Note that if <code>Self::Item</code> is only <code>PartialOrd</code>, but not <code>Ord</code>, the above definition implies that this function returns <code>false</code> if any two consecutive items are not comparable.</p> <h2 id="examples-67" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(is_sorted)]
let empty: [i32; 0] = [];

assert!([1, 2, 2, 9].is_sorted());
assert!(![1, 3, 2, 4].is_sorted());
assert!([0].is_sorted());
assert!(empty.is_sorted());
assert!(![0.0, 1.0, f32::NAN].is_sorted());</pre></div> </div>
<h4 id="method.is_sorted_by" class="method">
<code>pub fn <a href="#method.is_sorted_by" class="fnname">is_sorted_by</a>&lt;F&gt;(&amp;self, compare: F) -&gt; <a class="primitive" href="primitive.bool">bool</a> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T, <a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.ordering" title="enum std::cmp::Ordering">Ordering</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2875-2880" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (is_sorted #53485)new API </span></div>
<div class="docblock">
<p>Checks if the elements of this slice are sorted using the given comparator function.</p> <p>Instead of using <code>PartialOrd::partial_cmp</code>, this function uses the given <code>compare</code> function to determine the ordering of two elements. Apart from that, it's equivalent to <a href="#method.is_sorted"><code>is_sorted</code></a>; see its documentation for more information.</p> </div>
<h4 id="method.is_sorted_by_key" class="method">
<code>pub fn <a href="#method.is_sorted_by_key" class="fnname">is_sorted_by_key</a>&lt;F, K&gt;(&amp;self, f: F) -&gt; <a class="primitive" href="primitive.bool">bool</a> <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; K,<br>    K: <a class="trait" href="cmp/trait.partialord" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;K&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2900-2906" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (is_sorted #53485)new API </span></div>
<div class="docblock">
<p>Checks if the elements of this slice are sorted using the given key extraction function.</p> <p>Instead of comparing the slice's elements directly, this function compares the keys of the elements, as determined by <code>f</code>. Apart from that, it's equivalent to <a href="#method.is_sorted"><code>is_sorted</code></a>; see its documentation for more information.</p> <h2 id="examples-68" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(is_sorted)]

assert!(["c", "bb", "aaa"].is_sorted_by_key(|s| s.len()));
assert!(![-2i32, -1, 0, 3].is_sorted_by_key(|n| n.abs()));</pre></div> </div>
<h4 id="method.partition_point" class="method">
<code>pub fn <a href="#method.partition_point" class="fnname">partition_point</a>&lt;P&gt;(&amp;self, pred: P) -&gt; <a class="primitive" href="primitive.usize">usize</a> <span class="where fmt-newline">where<br>    P: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="primitive" href="primitive.bool">bool</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2933-2958" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (partition_point #73831)new API </span></div>
<div class="docblock">
<p>Returns the index of the partition point according to the given predicate (the index of the first element of the second partition).</p> <p>The slice is assumed to be partitioned according to the given predicate. This means that all elements for which the predicate returns true are at the start of the slice and all elements for which the predicate returns false are at the end. For example, [7, 15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0 (all odd numbers are at the start, all even at the end).</p> <p>If this slice is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary search.</p> <h2 id="examples-69" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(partition_point)]

let v = [1, 2, 3, 3, 5, 6, 7];
let i = v.partition_point(|&amp;x| x &lt; 5);

assert_eq!(i, 4);
assert!(v[..i].iter().all(|&amp;x| x &lt; 5));
assert!(v[i..].iter().all(|&amp;x| !(x &lt; 5)));</pre></div> </div>
<h3 id="impl-1" class="impl">
<code class="in-band">impl <a class="primitive" href="primitive.slice">[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2963-3014" title="goto source code">[src]</a>
</h3>
<h4 id="method.is_ascii" class="method">
<code>pub fn <a href="#method.is_ascii" class="fnname">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2967-2969" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span>
</h4>
<div class="docblock">
<p>Checks if all bytes in this slice are within the ASCII range.</p> </div>
<h4 id="method.eq_ignore_ascii_case" class="method">
<code>pub fn <a href="#method.eq_ignore_ascii_case" class="fnname">eq_ignore_ascii_case</a>(&amp;self, other: <a class="primitive" href="primitive.slice">&amp;[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2977-2979" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span>
</h4>
<div class="docblock">
<p>Checks that two slices are an ASCII case-insensitive match.</p> <p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>, but without allocating and copying temporaries.</p> </div>
<h4 id="method.make_ascii_uppercase" class="method">
<code>pub fn <a href="#method.make_ascii_uppercase" class="fnname">make_ascii_uppercase</a>(&amp;mut self)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#2992-2996" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span>
</h4>
<div class="docblock">
<p>Converts this slice to its ASCII upper case equivalent in-place.</p> <p>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</p> <p>To return a new uppercased value without modifying the existing one, use <a href="#method.to_ascii_uppercase"><code>to_ascii_uppercase</code></a>.</p> </div>
<h4 id="method.make_ascii_lowercase" class="method">
<code>pub fn <a href="#method.make_ascii_lowercase" class="fnname">make_ascii_lowercase</a>(&amp;mut self)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#3009-3013" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span>
</h4>
<div class="docblock">
<p>Converts this slice to its ASCII lower case equivalent in-place.</p> <p>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</p> <p>To return a new lowercased value without modifying the existing one, use <a href="#method.to_ascii_lowercase"><code>to_ascii_lowercase</code></a>.</p> </div>
<h3 id="impl-2" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#163-546" title="goto source code">[src]</a>
</h3>
<h4 id="method.sort" class="method">
<code>pub fn <a href="#method.sort" class="fnname">sort</a>(&amp;mut self) <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#192-197" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Sorts the slice.</p> <p>This sort is stable (i.e., does not reorder equal elements) and <code>O(n * log(n))</code> worst-case.</p> <p>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See <a href="#method.sort_unstable"><code>sort_unstable</code></a>.</p> <h2 id="current-implementation-6" class="section-header">Current implementation</h2> <p>The current algorithm is an adaptive, iterative merge sort inspired by <a href="https://en.wikipedia.org/wiki/Timsort">timsort</a>. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.</p> <p>Also, it allocates temporary storage half the size of <code>self</code>, but for short slices a non-allocating insertion sort is used instead.</p> <h2 id="examples-70" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = [-5, 4, 1, -3, 2];

v.sort();
assert!(v == [-5, -3, 1, 2, 4]);</pre></div> </div>
<h4 id="method.sort_by" class="method">
<code>pub fn <a href="#method.sort_by" class="fnname">sort_by</a>&lt;F&gt;(&amp;mut self, compare: F) <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T, <a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="enum" href="cmp/enum.ordering" title="enum std::cmp::Ordering">Ordering</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#246-251" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Sorts the slice with a comparator function.</p> <p>This sort is stable (i.e., does not reorder equal elements) and <code>O(n * log(n))</code> worst-case.</p> <p>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all <code>a</code>, <code>b</code> and <code>c</code>):</p> <ul> <li>total and antisymmetric: exactly one of <code>a &lt; b</code>, <code>a == b</code> or <code>a &gt; b</code> is true, and</li> <li>transitive, <code>a &lt; b</code> and <code>b &lt; c</code> implies <code>a &lt; c</code>. The same must hold for both <code>==</code> and <code>&gt;</code>.</li> </ul> <p>For example, while <a href="primitive.f64" title="`f64`"><code>f64</code></a> doesn't implement <a href="cmp/trait.ord" title="`Ord`"><code>Ord</code></a> because <code>NaN != NaN</code>, we can use <code>partial_cmp</code> as our sort function when we know the slice doesn't contain a <code>NaN</code>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut floats = [5f64, 4.0, 1.0, 3.0, 2.0];
floats.sort_by(|a, b| a.partial_cmp(b).unwrap());
assert_eq!(floats, [1.0, 2.0, 3.0, 4.0, 5.0]);</pre></div> <p>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See <a href="#method.sort_unstable_by"><code>sort_unstable_by</code></a>.</p> <h2 id="current-implementation-7" class="section-header">Current implementation</h2> <p>The current algorithm is an adaptive, iterative merge sort inspired by <a href="https://en.wikipedia.org/wiki/Timsort">timsort</a>. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.</p> <p>Also, it allocates temporary storage half the size of <code>self</code>, but for short slices a non-allocating insertion sort is used instead.</p> <h2 id="examples-71" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = [5, 4, 1, 3, 2];
v.sort_by(|a, b| a.cmp(b));
assert!(v == [1, 2, 3, 4, 5]);

// reverse sorting
v.sort_by(|a, b| b.cmp(a));
assert!(v == [5, 4, 3, 2, 1]);</pre></div> </div>
<h4 id="method.sort_by_key" class="method">
<code>pub fn <a href="#method.sort_by_key" class="fnname">sort_by_key</a>&lt;K, F&gt;(&amp;mut self, f: F) <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; K,<br>    K: <a class="trait" href="cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#286-292" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.7.0">1.7.0</span>
</h4>
<div class="docblock">
<p>Sorts the slice with a key extraction function.</p> <p>This sort is stable (i.e., does not reorder equal elements) and <code>O(m * n * log(n))</code> worst-case, where the key function is <code>O(m)</code>.</p> <p>For expensive key functions (e.g. functions that are not simple property accesses or basic operations), <a href="#method.sort_by_cached_key"><code>sort_by_cached_key</code></a> is likely to be significantly faster, as it does not recompute element keys.</p> <p>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See <a href="#method.sort_unstable_by_key"><code>sort_unstable_by_key</code></a>.</p> <h2 id="current-implementation-8" class="section-header">Current implementation</h2> <p>The current algorithm is an adaptive, iterative merge sort inspired by <a href="https://en.wikipedia.org/wiki/Timsort">timsort</a>. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.</p> <p>Also, it allocates temporary storage half the size of <code>self</code>, but for short slices a non-allocating insertion sort is used instead.</p> <h2 id="examples-72" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = [-5i32, 4, 1, -3, 2];

v.sort_by_key(|k| k.abs());
assert!(v == [1, 2, -3, 4, -5]);</pre></div> </div>
<h4 id="method.sort_by_cached_key" class="method">
<code>pub fn <a href="#method.sort_by_cached_key" class="fnname">sort_by_cached_key</a>&lt;K, F&gt;(&amp;mut self, f: F) <span class="where fmt-newline">where<br>    F: <a class="trait" href="ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; K,<br>    K: <a class="trait" href="cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#328-372" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span>
</h4>
<div class="docblock">
<p>Sorts the slice with a key extraction function.</p> <p>During sorting, the key function is called only once per element.</p> <p>This sort is stable (i.e., does not reorder equal elements) and <code>O(m * n + n * log(n))</code> worst-case, where the key function is <code>O(m)</code>.</p> <p>For simple key functions (e.g., functions that are property accesses or basic operations), <a href="#method.sort_by_key"><code>sort_by_key</code></a> is likely to be faster.</p> <h2 id="current-implementation-9" class="section-header">Current implementation</h2> <p>The current algorithm is based on <a href="https://github.com/orlp/pdqsort">pattern-defeating quicksort</a> by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.</p> <p>In the worst case, the algorithm allocates temporary storage in a <code>Vec&lt;(K, usize)&gt;</code> the length of the slice.</p> <h2 id="examples-73" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = [-5i32, 4, 32, -3, 2];

v.sort_by_cached_key(|k| k.to_string());
assert!(v == [-3, -5, 2, 32, 4]);</pre></div> </div>
<h4 id="method.to_vec" class="method">
<code>pub fn <a href="#method.to_vec" class="fnname">to_vec</a>(&amp;self) -&gt; <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    T: <a class="trait" href="clone/trait.clone" title="trait std::clone::Clone">Clone</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#386-392" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Copies <code>self</code> into a new <code>Vec</code>.</p> <h2 id="examples-74" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = [10, 40, 30];
let x = s.to_vec();
// Here, `s` and `x` can be modified independently.</pre></div> </div>
<h4 id="method.into_vec" class="method">
<code>pub fn <a href="#method.into_vec" class="fnname">into_vec</a>(self: <a class="struct" href="boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;) -&gt; <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#410-413" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts <code>self</code> into a vector without clones or allocation.</p> <p>The resulting vector can be converted back into a box via <code>Vec&lt;T&gt;</code>'s <code>into_boxed_slice</code> method.</p> <h2 id="examples-75" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s: Box&lt;[i32]&gt; = Box::new([10, 40, 30]);
let x = s.into_vec();
// `s` cannot be used anymore because it has been converted into `x`.

assert_eq!(x, vec![10, 40, 30]);</pre></div> </div>
<h4 id="method.repeat" class="method">
<code>pub fn <a href="#method.repeat" class="fnname">repeat</a>(&amp;self, n: <a class="primitive" href="primitive.usize">usize</a>) -&gt; <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    T: <a class="trait" href="marker/trait.copy" title="trait std::marker::Copy">Copy</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#436-492" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.40.0">1.40.0</span>
</h4>
<div class="docblock">
<p>Creates a vector by repeating a slice <code>n</code> times.</p> <h2 id="panics-22" class="section-header">Panics</h2> <p>This function will panic if the capacity would overflow.</p> <h2 id="examples-76" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);</pre></div> <p>A panic upon overflow:</p> <div class="information">ⓘThis example panics</div>
<div class="example-wrap"><pre class="rust rust-example-rendered should_panic" data-language="rust">
// this will panic at runtime
b"0123456789abcdef".repeat(usize::MAX);</pre></div> </div>
<h4 id="method.concat" class="method">
<code>pub fn <a href="#method.concat" class="fnname">concat</a>&lt;Item&gt;(&amp;self) -&gt; &lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> as <a class="trait" href="slice/trait.concat" title="trait std::slice::Concat">Concat</a>&lt;Item&gt;&gt;::<a class="type" href="slice/trait.concat#associatedtype.Output" title="type std::slice::Concat::Output">Output</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ [u8]</h3>
<pre class="content">impl&lt;'_&gt; Read for &amp;'_ [u8]
impl&lt;'_&gt; Write for &amp;'_ mut [u8]
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Item: ?<a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>,<br>    <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>: <a class="trait" href="slice/trait.concat" title="trait std::slice::Concat">Concat</a>&lt;Item&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#503-508" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Flattens a slice of <code>T</code> into a single value <code>Self::Output</code>.</p> <h2 id="examples-77" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!(["hello", "world"].concat(), "helloworld");
assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);</pre></div> </div>
<h4 id="method.join" class="method">
<code>pub fn <a href="#method.join" class="fnname">join</a>&lt;Separator&gt;(<br>    &amp;self, <br>    sep: Separator<br>) -&gt; &lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> as <a class="trait" href="slice/trait.join" title="trait std::slice::Join">Join</a>&lt;Separator&gt;&gt;::<a class="type" href="slice/trait.join#associatedtype.Output" title="type std::slice::Join::Output">Output</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ [u8]</h3>
<pre class="content">impl&lt;'_&gt; Read for &amp;'_ [u8]
impl&lt;'_&gt; Write for &amp;'_ mut [u8]
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>: <a class="trait" href="slice/trait.join" title="trait std::slice::Join">Join</a>&lt;Separator&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#521-526" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span>
</h4>
<div class="docblock">
<p>Flattens a slice of <code>T</code> into a single value <code>Self::Output</code>, placing a given separator between each.</p> <h2 id="examples-78" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!(["hello", "world"].join(" "), "hello world");
assert_eq!([[1, 2], [3, 4]].join(&amp;0), [1, 2, 0, 3, 4]);
assert_eq!([[1, 2], [3, 4]].join(&amp;[0, 0][..]), [1, 2, 0, 0, 3, 4]);</pre></div> </div>
<h4 id="method.connect" class="method">
<code>pub fn <a href="#method.connect" class="fnname">connect</a>&lt;Separator&gt;(<br>    &amp;self, <br>    sep: Separator<br>) -&gt; &lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> as <a class="trait" href="slice/trait.join" title="trait std::slice::Join">Join</a>&lt;Separator&gt;&gt;::<a class="type" href="slice/trait.join#associatedtype.Output" title="type std::slice::Join::Output">Output</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ [u8]</h3>
<pre class="content">impl&lt;'_&gt; Read for &amp;'_ [u8]
impl&lt;'_&gt; Write for &amp;'_ mut [u8]
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>: <a class="trait" href="slice/trait.join" title="trait std::slice::Join">Join</a>&lt;Separator&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#540-545" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab deprecated">👎 Deprecated since 1.3.0: renamed to join </span></div>
<div class="docblock">
<p>Flattens a slice of <code>T</code> into a single value <code>Self::Output</code>, placing a given separator between each.</p> <h2 id="examples-79" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!(["hello", "world"].connect(" "), "hello world");
assert_eq!([[1, 2], [3, 4]].connect(&amp;0), [1, 2, 0, 3, 4]);</pre></div> </div>
<h3 id="impl-3" class="impl">
<code class="in-band">impl <a class="primitive" href="primitive.slice">[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#550-584" title="goto source code">[src]</a>
</h3>
<h4 id="method.to_ascii_uppercase" class="method">
<code>pub fn <a href="#method.to_ascii_uppercase" class="fnname">to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="primitive.u8">u8</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#562-566" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span>
</h4>
<div class="docblock">
<p>Returns a vector containing a copy of this slice where each byte is mapped to its ASCII upper case equivalent.</p> <p>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</p> <p>To uppercase the value in-place, use <a href="primitive.u8#method.make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p> </div>
<h4 id="method.to_ascii_lowercase" class="method">
<code>pub fn <a href="#method.to_ascii_lowercase" class="fnname">to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="primitive.u8">u8</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#579-583" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span>
</h4>
<div class="docblock">
<p>Returns a vector containing a copy of this slice where each byte is mapped to its ASCII lower case equivalent.</p> <p>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</p> <p>To lowercase the value in-place, use <a href="primitive.u8#method.make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p> </div>
<h2 id="trait-implementations" class="small-section-header">Trait Implementations</h2>
<div id="trait-implementations-list">
<h3 id="impl-AsMut%3C%5BT%5D%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="convert/trait.asmut" title="trait std::convert::AsMut">AsMut</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt; for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#630-634" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.as_mut" class="method hidden">
<code>fn <a href="convert/trait.asmut#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.slice">&amp;mut [T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ [u8]</h3>
<pre class="content">impl&lt;'_&gt; Read for &amp;'_ [u8]
impl&lt;'_&gt; Write for &amp;'_ mut [u8]
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#631-633" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-AsRef%3C%5BT%5D%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="convert/trait.asref" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt; for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#623-627" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.as_ref" class="method hidden">
<code>fn <a href="convert/trait.asref#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; <a class="primitive" href="primitive.slice">&amp;[T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ [u8]</h3>
<pre class="content">impl&lt;'_&gt; Read for &amp;'_ [u8]
impl&lt;'_&gt; Write for &amp;'_ mut [u8]
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#624-626" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-AsciiExt" class="impl">
<code class="in-band">impl <a class="trait" href="ascii/trait.asciiext" title="trait std::ascii::AsciiExt">AsciiExt</a> for <a class="primitive" href="primitive.slice">[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#198-202" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Owned-1" class="type"><code>type <a href="ascii/trait.asciiext#associatedtype.Owned" class="type">Owned</a> = <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="primitive.u8">u8</a>&gt;</code></h4>
<div class="stability"><span class="stab deprecated">👎 Deprecated since 1.26.0: use inherent methods instead </span></div>
<div class="docblock">
<p>Container type for copied ASCII characters.</p> </div>
<h4 id="method.is_ascii-1" class="method hidden">
<code>fn <a href="ascii/trait.asciiext#tymethod.is_ascii" class="fnname">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#149-151" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab deprecated">👎 Deprecated since 1.26.0: use inherent methods instead </span></div>
<div class="docblock hidden">
<p>Checks if the value is within the ASCII range. <a href="ascii/trait.asciiext#tymethod.is_ascii">Read more</a></p> </div>
<h4 id="method.to_ascii_uppercase-1" class="method hidden">
<code>fn <a href="ascii/trait.asciiext#tymethod.to_ascii_uppercase" class="fnname">to_ascii_uppercase</a>(&amp;self) -&gt; Self::<a class="type" href="ascii/trait.asciiext#associatedtype.Owned" title="type std::ascii::AsciiExt::Owned">Owned</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#154-156" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab deprecated">👎 Deprecated since 1.26.0: use inherent methods instead </span></div>
<div class="docblock hidden">
<p>Makes a copy of the value in its ASCII upper case equivalent. <a href="ascii/trait.asciiext#tymethod.to_ascii_uppercase">Read more</a></p> </div>
<h4 id="method.to_ascii_lowercase-1" class="method hidden">
<code>fn <a href="ascii/trait.asciiext#tymethod.to_ascii_lowercase" class="fnname">to_ascii_lowercase</a>(&amp;self) -&gt; Self::<a class="type" href="ascii/trait.asciiext#associatedtype.Owned" title="type std::ascii::AsciiExt::Owned">Owned</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#159-161" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab deprecated">👎 Deprecated since 1.26.0: use inherent methods instead </span></div>
<div class="docblock hidden">
<p>Makes a copy of the value in its ASCII lower case equivalent. <a href="ascii/trait.asciiext#tymethod.to_ascii_lowercase">Read more</a></p> </div>
<h4 id="method.eq_ignore_ascii_case-1" class="method hidden">
<code>fn <a href="ascii/trait.asciiext#tymethod.eq_ignore_ascii_case" class="fnname">eq_ignore_ascii_case</a>(&amp;self, o: <a class="primitive" href="primitive.reference">&amp;</a>Self) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#164-166" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab deprecated">👎 Deprecated since 1.26.0: use inherent methods instead </span></div>
<div class="docblock hidden">
<p>Checks that two values are an ASCII case-insensitive match. <a href="ascii/trait.asciiext#tymethod.eq_ignore_ascii_case">Read more</a></p> </div>
<h4 id="method.make_ascii_uppercase-1" class="method hidden">
<code>fn <a href="ascii/trait.asciiext#tymethod.make_ascii_uppercase" class="fnname">make_ascii_uppercase</a>(&amp;mut self)</code><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#169-171" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab deprecated">👎 Deprecated since 1.26.0: use inherent methods instead </span></div>
<div class="docblock hidden">
<p>Converts this type to its ASCII upper case equivalent in-place. <a href="ascii/trait.asciiext#tymethod.make_ascii_uppercase">Read more</a></p> </div>
<h4 id="method.make_ascii_lowercase-1" class="method hidden">
<code>fn <a href="ascii/trait.asciiext#tymethod.make_ascii_lowercase" class="fnname">make_ascii_lowercase</a>(&amp;mut self)</code><a class="srclink" href="https://doc.rust-lang.org/src/std/ascii.rs.html#174-176" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab deprecated">👎 Deprecated since 1.26.0: use inherent methods instead </span></div>
<div class="docblock hidden">
<p>Converts this type to its ASCII lower case equivalent in-place. <a href="ascii/trait.asciiext#tymethod.make_ascii_lowercase">Read more</a></p> </div>
</div>
<h3 id="impl-BufRead" class="impl">
<code class="in-band">impl&lt;'_&gt; <a class="trait" href="io/trait.bufread" title="trait std::io::BufRead">BufRead</a> for <a class="primitive" href="primitive.slice">&amp;'_ [</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#303-313" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.fill_buf" class="method hidden">
<code>fn <a href="io/trait.bufread#tymethod.fill_buf" class="fnname">fill_buf</a>(&amp;mut self) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.slice">&amp;[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#305-307" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Returns the contents of the internal buffer, filling it with more data from the inner reader if it is empty. <a href="io/trait.bufread#tymethod.fill_buf">Read more</a></p> </div>
<h4 id="method.consume" class="method hidden">
<code>fn <a href="io/trait.bufread#tymethod.consume" class="fnname">consume</a>(&amp;mut self, amt: <a class="primitive" href="primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#310-312" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Tells this buffer that <code>amt</code> bytes have been consumed from the buffer, so they should no longer be returned in calls to <code>read</code>. <a href="io/trait.bufread#tymethod.consume">Read more</a></p> </div>
<h4 id="method.read_until" class="method hidden">
<code>fn <a href="io/trait.bufread#method.read_until" class="fnname">read_until</a>(&amp;mut self, byte: <a class="primitive" href="primitive.u8">u8</a>, buf: &amp;mut <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="primitive.u8">u8</a>&gt;) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1901-1903" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Read all bytes into <code>buf</code> until the delimiter <code>byte</code> or EOF is reached. <a href="io/trait.bufread#method.read_until">Read more</a></p> </div>
<h4 id="method.read_line" class="method hidden">
<code>fn <a href="io/trait.bufread#method.read_line" class="fnname">read_line</a>(&amp;mut self, buf: &amp;mut <a class="struct" href="string/struct.string" title="struct std::string::String">String</a>) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1964-1969" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Read all bytes until a newline (the <code>0xA</code> byte) is reached, and append them to the provided buffer. <a href="io/trait.bufread#method.read_line">Read more</a></p> </div>
<h4 id="method.split-1" class="method hidden">
<code>fn <a href="io/trait.bufread#method.split" class="fnname">split</a>(self, byte: <a class="primitive" href="primitive.u8">u8</a>) -&gt; <a class="struct" href="io/struct.split" title="struct std::io::Split">Split</a>&lt;Self&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Split&lt;B&gt;</h3>
<pre class="content">impl&lt;B: BufRead&gt; Iterator for Split&lt;B&gt;
    type Item = Result&lt;Vec&lt;u8&gt;&gt;;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#2003-2008" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Returns an iterator over the contents of this reader split on the byte <code>byte</code>. <a href="io/trait.bufread#method.split">Read more</a></p> </div>
<h4 id="method.lines" class="method hidden">
<code>fn <a href="io/trait.bufread#method.lines" class="fnname">lines</a>(self) -&gt; <a class="struct" href="io/struct.lines" title="struct std::io::Lines">Lines</a>&lt;Self&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Lines&lt;B&gt;</h3>
<pre class="content">impl&lt;B: BufRead&gt; Iterator for Lines&lt;B&gt;
    type Item = Result&lt;String&gt;;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#2040-2045" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Returns an iterator over the lines of this reader. <a href="io/trait.bufread#method.lines">Read more</a></p> </div>
</div>
<h3 id="impl-Concat%3CT%3E" class="impl">
<code class="in-band">impl&lt;T, V&gt; <a class="trait" href="slice/trait.concat" title="trait std::slice::Concat">Concat</a>&lt;T&gt; for <a class="primitive" href="primitive.slice">[</a>V<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="clone/trait.clone" title="trait std::clone::Clone">Clone</a>,<br>    V: <a class="trait" href="borrow/trait.borrow" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#643-654" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Output-4" class="type"><code>type <a href="slice/trait.concat#associatedtype.Output" class="type">Output</a> = <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;</code></h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_concat_trait #27747)</span></div>
<div class="docblock">
<p>The resulting type after concatenation</p> </div>
<h4 id="method.concat-1" class="method hidden">
<code>fn <a href="slice/trait.concat#tymethod.concat" class="fnname">concat</a>(slice: <a class="primitive" href="primitive.slice">&amp;[V]</a>) -&gt; <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#646-653" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_concat_trait #27747)</span></div>
<div class="docblock hidden">
<p>Implementation of <code>[T]::concat</code></p> </div>
</div>
<h3 id="impl-Concat%3Cstr%3E" class="impl">
<code class="in-band">impl&lt;S&gt; <a class="trait" href="slice/trait.concat" title="trait std::slice::Concat">Concat</a>&lt;<a class="primitive" href="primitive.str">str</a>&gt; for <a class="primitive" href="primitive.slice">[</a>S<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    S: <a class="trait" href="borrow/trait.borrow" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="primitive.str">str</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#76-82" title="goto source code">[src]</a>
</h3>
<div class="docblock">
<p>Note: <code>str</code> in <code>Concat&lt;str&gt;</code> is not meaningful here. This type parameter of the trait only exists to enable another impl.</p> </div>
<div class="impl-items">
<h4 id="associatedtype.Output-5" class="type"><code>type <a href="slice/trait.concat#associatedtype.Output" class="type">Output</a> = <a class="struct" href="string/struct.string" title="struct std::string::String">String</a></code></h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_concat_trait #27747)</span></div>
<div class="docblock">
<p>The resulting type after concatenation</p> </div>
<h4 id="method.concat-2" class="method hidden">
<code>fn <a href="slice/trait.concat#tymethod.concat" class="fnname">concat</a>(slice: <a class="primitive" href="primitive.slice">&amp;[S]</a>) -&gt; <a class="struct" href="string/struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#79-81" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_concat_trait #27747)</span></div>
<div class="docblock hidden">
<p>Implementation of <code>[T]::concat</code></p> </div>
</div>
<h3 id="impl-Debug" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="fmt/trait.debug" title="trait std::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="fmt/trait.debug" title="trait std::fmt::Debug">Debug</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2173-2177" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.fmt" class="method hidden">
<code>fn <a href="fmt/trait.debug#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.formatter" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit">()</a>, <a class="struct" href="fmt/struct.error" title="struct std::fmt::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#2174-2176" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Formats the value using the given formatter. <a href="fmt/trait.debug#tymethod.fmt">Read more</a></p> </div>
</div>
<h3 id="impl-Default" class="impl">
<code class="in-band">impl&lt;'_, T&gt; <a class="trait" href="default/trait.default" title="trait std::default::Default">Default</a> for <a class="primitive" href="primitive.slice">&amp;'_ mut [T]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#3570-3575" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</h3>
<div class="impl-items">
<h4 id="method.default" class="method">
<code>fn <a href="default/trait.default#tymethod.default" class="fnname">default</a>() -&gt; <a class="primitive" href="primitive.slice">&amp;'_ mut [T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ [u8]</h3>
<pre class="content">impl&lt;'_&gt; Read for &amp;'_ [u8]
impl&lt;'_&gt; Write for &amp;'_ mut [u8]
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#3572-3574" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Creates a mutable empty slice.</p> </div>
</div>
<h3 id="impl-Default-1" class="impl">
<code class="in-band">impl&lt;'_, T&gt; <a class="trait" href="default/trait.default" title="trait std::default::Default">Default</a> for <a class="primitive" href="primitive.slice">&amp;'_ [T]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#3562-3567" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.default-1" class="method">
<code>fn <a href="default/trait.default#tymethod.default" class="fnname">default</a>() -&gt; <a class="primitive" href="primitive.slice">&amp;'_ [T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ [u8]</h3>
<pre class="content">impl&lt;'_&gt; Read for &amp;'_ [u8]
impl&lt;'_&gt; Write for &amp;'_ mut [u8]
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#3564-3566" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Creates an empty slice.</p> </div>
</div>
<h3 id="impl-Eq" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.eq" title="trait std::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.eq" title="trait std::cmp::Eq">Eq</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#6546" title="goto source code">[src]</a>
</h3>

<h3 id="impl-Hash" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="hash/trait.hash" title="trait std::hash::Hash">Hash</a> for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="hash/trait.hash" title="trait std::hash::Hash">Hash</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#667-672" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.hash" class="method hidden">
<code>fn <a href="hash/trait.hash#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="primitive.reference">&amp;mut </a>H) <span class="where fmt-newline">where<br>    H: <a class="trait" href="hash/trait.hasher" title="trait std::hash::Hasher">Hasher</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#668-671" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Feeds this value into the given [<code>Hasher</code>]. <a href="hash/trait.hash#tymethod.hash">Read more</a></p> </div>
<h4 id="method.hash_slice" class="method hidden">
<code>fn <a href="hash/trait.hash#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="primitive.slice">&amp;[Self]</a>, state: <a class="primitive" href="primitive.reference">&amp;mut </a>H) <span class="where fmt-newline">where<br>    H: <a class="trait" href="hash/trait.hasher" title="trait std::hash::Hasher">Hasher</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#192-199" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span>
</h4>
<div class="docblock hidden">
<p>Feeds a slice of this type into the given [<code>Hasher</code>]. <a href="hash/trait.hash#method.hash_slice">Read more</a></p> </div>
</div>
<h3 id="impl-Index%3CI%3E" class="impl">
<code class="in-band">impl&lt;T, I&gt; <a class="trait" href="ops/trait.index" title="trait std::ops::Index">Index</a>&lt;I&gt; for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    I: <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#3115-3125" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Output" class="type"><code>type <a href="ops/trait.index#associatedtype.Output" class="type">Output</a> = &lt;I as <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;&gt;::<a class="type" href="slice/trait.sliceindex#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></code></h4>
<div class="docblock">
<p>The returned type after indexing.</p> </div>
<h4 id="method.index" class="method hidden">
<code>fn <a href="ops/trait.index#tymethod.index" class="fnname">index</a>(&amp;self, index: I) -&gt; &amp;&lt;I as <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;&gt;::<a class="type" href="slice/trait.sliceindex#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#3122-3124" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-IndexMut%3CI%3E" class="impl">
<code class="in-band">impl&lt;T, I&gt; <a class="trait" href="ops/trait.indexmut" title="trait std::ops::IndexMut">IndexMut</a>&lt;I&gt; for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    I: <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#3128-3136" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.index_mut" class="method hidden">
<code>fn <a href="ops/trait.indexmut#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: I) -&gt; &amp;mut &lt;I as <a class="trait" href="slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;&gt;::<a class="type" href="slice/trait.sliceindex#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#3133-3135" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the mutable indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-IntoIterator" class="impl">
<code class="in-band">impl&lt;'a, T&gt; <a class="trait" href="iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a> for <a class="primitive" href="primitive.slice">&amp;'a [T]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#3582-3589" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Item" class="type"><code>type <a href="iter/trait.intoiterator#associatedtype.Item" class="type">Item</a> = <a class="primitive" href="primitive.reference">&amp;'a </a>T</code></h4>
<div class="docblock">
<p>The type of the elements being iterated over.</p> </div>
<h4 id="associatedtype.IntoIter" class="type"><code>type <a href="iter/trait.intoiterator#associatedtype.IntoIter" class="type">IntoIter</a> = <a class="struct" href="slice/struct.iter" title="struct std::slice::Iter">Iter</a>&lt;'a, T&gt;</code></h4>
<div class="docblock">
<p>Which kind of iterator are we turning this into?</p> </div>
<h4 id="method.into_iter" class="method hidden">
<code>fn <a href="iter/trait.intoiterator#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; <a class="struct" href="slice/struct.iter" title="struct std::slice::Iter">Iter</a>&lt;'a, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Iter&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt;
    type Item = &amp;'a T;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#3586-3588" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates an iterator from a value. <a href="iter/trait.intoiterator#tymethod.into_iter">Read more</a></p> </div>
</div>
<h3 id="impl-IntoIterator-1" class="impl">
<code class="in-band">impl&lt;'a, T&gt; <a class="trait" href="iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a> for <a class="primitive" href="primitive.slice">&amp;'a mut [T]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#3592-3599" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Item-1" class="type"><code>type <a href="iter/trait.intoiterator#associatedtype.Item" class="type">Item</a> = <a class="primitive" href="primitive.reference">&amp;'a mut </a>T</code></h4>
<div class="docblock">
<p>The type of the elements being iterated over.</p> </div>
<h4 id="associatedtype.IntoIter-1" class="type"><code>type <a href="iter/trait.intoiterator#associatedtype.IntoIter" class="type">IntoIter</a> = <a class="struct" href="slice/struct.itermut" title="struct std::slice::IterMut">IterMut</a>&lt;'a, T&gt;</code></h4>
<div class="docblock">
<p>Which kind of iterator are we turning this into?</p> </div>
<h4 id="method.into_iter-1" class="method hidden">
<code>fn <a href="iter/trait.intoiterator#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; <a class="struct" href="slice/struct.itermut" title="struct std::slice::IterMut">IterMut</a>&lt;'a, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for IterMut&lt;'a, T&gt;</h3>
<pre class="content">impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt;
    type Item = &amp;'a mut T;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#3596-3598" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates an iterator from a value. <a href="iter/trait.intoiterator#tymethod.into_iter">Read more</a></p> </div>
</div>
<h3 id="impl-Join%3C%26%27_%20%5BT%5D%3E" class="impl">
<code class="in-band">impl&lt;'_, T, V&gt; <a class="trait" href="slice/trait.join" title="trait std::slice::Join">Join</a>&lt;<a class="primitive" href="primitive.slice">&amp;'_ [T]</a>&gt; for <a class="primitive" href="primitive.slice">[</a>V<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="clone/trait.clone" title="trait std::clone::Clone">Clone</a>,<br>    V: <a class="trait" href="borrow/trait.borrow" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#679-699" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Output-2" class="type"><code>type <a href="slice/trait.join#associatedtype.Output" class="type">Output</a> = <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;</code></h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_concat_trait #27747)</span></div>
<div class="docblock">
<p>The resulting type after concatenation</p> </div>
<h4 id="method.join-2" class="method hidden">
<code>fn <a href="slice/trait.join#tymethod.join" class="fnname">join</a>(slice: <a class="primitive" href="primitive.slice">&amp;[V]</a>, sep: <a class="primitive" href="primitive.slice">&amp;[T]</a>) -&gt; <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#682-698" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_concat_trait #27747)</span></div>
<div class="docblock hidden">
<p>Implementation of <code>[T]::join</code></p> </div>
</div>
<h3 id="impl-Join%3C%26%27_%20T%3E" class="impl">
<code class="in-band">impl&lt;'_, T, V&gt; <a class="trait" href="slice/trait.join" title="trait std::slice::Join">Join</a>&lt;<a class="primitive" href="primitive.reference">&amp;'_ </a>T&gt; for <a class="primitive" href="primitive.slice">[</a>V<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="clone/trait.clone" title="trait std::clone::Clone">Clone</a>,<br>    V: <a class="trait" href="borrow/trait.borrow" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#657-676" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Output-3" class="type"><code>type <a href="slice/trait.join#associatedtype.Output" class="type">Output</a> = <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;</code></h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_concat_trait #27747)</span></div>
<div class="docblock">
<p>The resulting type after concatenation</p> </div>
<h4 id="method.join-3" class="method hidden">
<code>fn <a href="slice/trait.join#tymethod.join" class="fnname">join</a>(slice: <a class="primitive" href="primitive.slice">&amp;[V]</a>, sep: <a class="primitive" href="primitive.reference">&amp;</a>T) -&gt; <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#660-675" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_concat_trait #27747)</span></div>
<div class="docblock hidden">
<p>Implementation of <code>[T]::join</code></p> </div>
</div>
<h3 id="impl-Join%3C%26%27_%20str%3E" class="impl">
<code class="in-band">impl&lt;'_, S&gt; <a class="trait" href="slice/trait.join" title="trait std::slice::Join">Join</a>&lt;&amp;'_ <a class="primitive" href="primitive.str">str</a>&gt; for <a class="primitive" href="primitive.slice">[</a>S<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    S: <a class="trait" href="borrow/trait.borrow" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="primitive.str">str</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#85-91" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Output-1" class="type"><code>type <a href="slice/trait.join#associatedtype.Output" class="type">Output</a> = <a class="struct" href="string/struct.string" title="struct std::string::String">String</a></code></h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_concat_trait #27747)</span></div>
<div class="docblock">
<p>The resulting type after concatenation</p> </div>
<h4 id="method.join-1" class="method hidden">
<code>fn <a href="slice/trait.join#tymethod.join" class="fnname">join</a>(slice: <a class="primitive" href="primitive.slice">&amp;[S]</a>, sep: &amp;<a class="primitive" href="primitive.str">str</a>) -&gt; <a class="struct" href="string/struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#88-90" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (slice_concat_trait #27747)</span></div>
<div class="docblock hidden">
<p>Implementation of <code>[T]::join</code></p> </div>
</div>
<h3 id="impl-Ord" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.ord" title="trait std::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.ord" title="trait std::cmp::Ord">Ord</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#6550-6554" title="goto source code">[src]</a>
</h3>
<div class="docblock">
<p>Implements comparison of vectors lexicographically.</p> </div>
<div class="impl-items">
<h4 id="method.cmp" class="method hidden">
<code>fn <a href="cmp/trait.ord#tymethod.cmp" class="fnname">cmp</a>(&amp;self, other: <a class="primitive" href="primitive.slice">&amp;[T]</a>) -&gt; <a class="enum" href="cmp/enum.ordering" title="enum std::cmp::Ordering">Ordering</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#6551-6553" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method returns an [<code>Ordering</code>] between <code>self</code> and <code>other</code>. <a href="cmp/trait.ord#tymethod.cmp">Read more</a></p> </div>
<h4 id="method.max" class="method hidden">
<code>fn <a href="cmp/trait.ord#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self</code><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#593-598" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span>
</h4>
<div class="docblock hidden">
<p>Compares and returns the maximum of two values. <a href="cmp/trait.ord#method.max">Read more</a></p> </div>
<h4 id="method.min" class="method hidden">
<code>fn <a href="cmp/trait.ord#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self</code><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#613-618" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span>
</h4>
<div class="docblock hidden">
<p>Compares and returns the minimum of two values. <a href="cmp/trait.ord#method.min">Read more</a></p> </div>
<h4 id="method.clamp" class="method hidden">
<code>fn <a href="cmp/trait.ord#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self</code><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#640-652" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (clamp #44095)</span></div>
<div class="docblock hidden">
<p>Restrict a value to a certain interval. <a href="cmp/trait.ord#method.clamp">Read more</a></p> </div>
</div>
<h3 id="impl-PartialEq%3C%5BA%3B%20N%5D%3E" class="impl">
<code class="in-band">impl&lt;A, B, const N: <a class="primitive" href="primitive.usize">usize</a>&gt; <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.array">[</a>A<a class="primitive" href="primitive.array">; N]</a>&gt; for <a class="primitive" href="primitive.slice">[</a>B<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    B: <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/array/mod.rs.html#228-240" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.eq" class="method hidden">
<code>fn <a href="cmp/trait.partialeq#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.array">[</a>A<a class="primitive" href="primitive.array">; N]</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/array/mod.rs.html#233-235" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne" class="method hidden">
<code>fn <a href="cmp/trait.partialeq#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.array">[</a>A<a class="primitive" href="primitive.array">; N]</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/array/mod.rs.html#237-239" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<h3 id="impl-PartialEq%3C%5BA%3B%20N%5D%3E-1" class="impl">
<code class="in-band">impl&lt;'b, A, B, const N: <a class="primitive" href="primitive.usize">usize</a>&gt; <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.array">[</a>A<a class="primitive" href="primitive.array">; N]</a>&gt; for <a class="primitive" href="primitive.slice">&amp;'b [B]</a> <span class="where fmt-newline">where<br>    B: <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/array/mod.rs.html#258-270" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.eq-1" class="method hidden">
<code>fn <a href="cmp/trait.partialeq#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.array">[</a>A<a class="primitive" href="primitive.array">; N]</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/array/mod.rs.html#263-265" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-1" class="method hidden">
<code>fn <a href="cmp/trait.partialeq#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.array">[</a>A<a class="primitive" href="primitive.array">; N]</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/array/mod.rs.html#267-269" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<h3 id="impl-PartialEq%3C%5BA%3B%20N%5D%3E-2" class="impl">
<code class="in-band">impl&lt;'b, A, B, const N: <a class="primitive" href="primitive.usize">usize</a>&gt; <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.array">[</a>A<a class="primitive" href="primitive.array">; N]</a>&gt; for <a class="primitive" href="primitive.slice">&amp;'b mut [B]</a> <span class="where fmt-newline">where<br>    B: <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/array/mod.rs.html#288-300" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.eq-2" class="method hidden">
<code>fn <a href="cmp/trait.partialeq#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.array">[</a>A<a class="primitive" href="primitive.array">; N]</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/array/mod.rs.html#293-295" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-2" class="method hidden">
<code>fn <a href="cmp/trait.partialeq#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.array">[</a>A<a class="primitive" href="primitive.array">; N]</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/array/mod.rs.html#297-299" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<h3 id="impl-PartialEq%3C%5BB%5D%3E" class="impl">
<code class="in-band">impl&lt;A, B&gt; <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.slice">[</a>B<a class="primitive" href="primitive.slice">]</a>&gt; for <a class="primitive" href="primitive.slice">[</a>A<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    A: <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;B&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#6532-6543" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.eq-3" class="method hidden">
<code>fn <a href="cmp/trait.partialeq#tymethod.eq" class="fnname">eq</a>(&amp;self, other: <a class="primitive" href="primitive.slice">&amp;[B]</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#6536-6538" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-3" class="method hidden">
<code>fn <a href="cmp/trait.partialeq#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="primitive.slice">&amp;[B]</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#6540-6542" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<h3 id="impl-PartialEq%3CVec%3CB%3E%3E" class="impl">
<code class="in-band">impl&lt;'_, A, B&gt; <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;B&gt;&gt; for <a class="primitive" href="primitive.slice">&amp;'_ mut [A]</a> <span class="where fmt-newline">where<br>    A: <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;B&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/vec.rs.html#2385-2394" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.46.0">1.46.0</span>
</h3>
<div class="impl-items">
<h4 id="method.eq-4" class="method hidden">
<code>fn <a href="cmp/trait.partialeq#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;B&gt;) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/vec.rs.html#2391" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-4" class="method hidden">
<code>fn <a href="cmp/trait.partialeq#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;B&gt;) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/vec.rs.html#2393" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<h3 id="impl-PartialEq%3CVec%3CB%3E%3E-1" class="impl">
<code class="in-band">impl&lt;'_, A, B&gt; <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;B&gt;&gt; for <a class="primitive" href="primitive.slice">&amp;'_ [A]</a> <span class="where fmt-newline">where<br>    A: <a class="trait" href="cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;B&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/vec.rs.html#2385-2394" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.46.0">1.46.0</span>
</h3>
<div class="impl-items">
<h4 id="method.eq-5" class="method hidden">
<code>fn <a href="cmp/trait.partialeq#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;B&gt;) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/vec.rs.html#2391" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-5" class="method hidden">
<code>fn <a href="cmp/trait.partialeq#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;B&gt;) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/vec.rs.html#2393" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<h3 id="impl-PartialOrd%3C%5BT%5D%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.partialord" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a>&gt; for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="cmp/trait.partialord" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#6558-6562" title="goto source code">[src]</a>
</h3>
<div class="docblock">
<p>Implements comparison of vectors lexicographically.</p> </div>
<div class="impl-items">
<h4 id="method.partial_cmp" class="method hidden">
<code>fn <a href="cmp/trait.partialord#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: <a class="primitive" href="primitive.slice">&amp;[T]</a>) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.ordering" title="enum std::cmp::Ordering">Ordering</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#6559-6561" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.partialord#tymethod.partial_cmp">Read more</a></p> </div>
<h4 id="method.lt" class="method hidden">
<code>fn <a href="cmp/trait.partialord#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="primitive.reference">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#835-837" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.partialord#method.lt">Read more</a></p> </div>
<h4 id="method.le" class="method hidden">
<code>fn <a href="cmp/trait.partialord#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="primitive.reference">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#854-856" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="cmp/trait.partialord#method.le">Read more</a></p> </div>
<h4 id="method.gt" class="method hidden">
<code>fn <a href="cmp/trait.partialord#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="primitive.reference">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#872-874" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.partialord#method.gt">Read more</a></p> </div>
<h4 id="method.ge" class="method hidden">
<code>fn <a href="cmp/trait.partialord#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="primitive.reference">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#891-893" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="cmp/trait.partialord#method.ge">Read more</a></p> </div>
</div>
<h3 id="impl-Pattern%3C%27a%3E" class="impl">
<code class="in-band">impl&lt;'a, 'b&gt; <a class="trait" href="str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt; for <a class="primitive" href="primitive.slice">&amp;'b [</a><a class="primitive" href="primitive.char">char</a><a class="primitive" href="primitive.slice">]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#783-785" title="goto source code">[src]</a>
</h3>
<div class="docblock">
<p>Searches for chars that are equal to any of the <a href="primitive.char" title="`char`"><code>char</code></a>s in the slice.</p> <h2 id="examples-80" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("Hello world".find(&amp;['l', 'l'] as &amp;[_]), Some(2));
assert_eq!("Hello world".find(&amp;['l', 'l'][..]), Some(2));</pre></div> </div>
<div class="impl-items">
<h4 id="associatedtype.Searcher" class="type"><code>type <a href="str/pattern/trait.pattern#associatedtype.Searcher" class="type">Searcher</a> = <a class="struct" href="str/pattern/struct.charslicesearcher" title="struct std::str::pattern::CharSliceSearcher">CharSliceSearcher</a>&lt;'a, 'b&gt;</code></h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock">
<p>Associated searcher for this pattern</p> </div>
<h4 id="method.into_searcher" class="method hidden">
<code>fn <a href="str/pattern/trait.pattern#tymethod.into_searcher" class="fnname">into_searcher</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str">str</a>) -&gt; <a class="struct" href="str/pattern/struct.charslicesearcher" title="struct std::str::pattern::CharSliceSearcher">CharSliceSearcher</a>&lt;'a, 'b&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#683-685" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock hidden">
<p>Constructs the associated searcher from <code>self</code> and the <code>haystack</code> to search in. <a href="str/pattern/trait.pattern#tymethod.into_searcher">Read more</a></p> </div>
<h4 id="method.is_contained_in" class="method hidden">
<code>fn <a href="str/pattern/trait.pattern#method.is_contained_in" class="fnname">is_contained_in</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str">str</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#688-690" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock hidden">
<p>Checks whether the pattern matches anywhere in the haystack</p> </div>
<h4 id="method.is_prefix_of" class="method hidden">
<code>fn <a href="str/pattern/trait.pattern#method.is_prefix_of" class="fnname">is_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str">str</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#693-695" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock hidden">
<p>Checks whether the pattern matches at the front of the haystack</p> </div>
<h4 id="method.strip_prefix_of" class="method hidden">
<code>fn <a href="str/pattern/trait.pattern#method.strip_prefix_of" class="fnname">strip_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str">str</a>) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#698-700" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock hidden">
<p>Removes the pattern from the front of haystack, if it matches.</p> </div>
<h4 id="method.is_suffix_of" class="method hidden">
<code>fn <a href="str/pattern/trait.pattern#method.is_suffix_of" class="fnname">is_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str">str</a>) -&gt; <a class="primitive" href="primitive.bool">bool</a> <span class="where fmt-newline">where<br>    <a class="struct" href="str/pattern/struct.charslicesearcher" title="struct std::str::pattern::CharSliceSearcher">CharSliceSearcher</a>&lt;'a, 'b&gt;: <a class="trait" href="str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#703-708" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock hidden">
<p>Checks whether the pattern matches at the back of the haystack</p> </div>
<h4 id="method.strip_suffix_of" class="method hidden">
<code>fn <a href="str/pattern/trait.pattern#method.strip_suffix_of" class="fnname">strip_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str">str</a>) -&gt; <a class="enum" href="option/enum.option" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str">str</a>&gt; <span class="where fmt-newline">where<br>    <a class="struct" href="str/pattern/struct.charslicesearcher" title="struct std::str::pattern::CharSliceSearcher">CharSliceSearcher</a>&lt;'a, 'b&gt;: <a class="trait" href="str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/pattern.rs.html#711-716" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock hidden">
<p>Removes the pattern from the back of haystack, if it matches.</p> </div>
</div>
<h3 id="impl-Read" class="impl">
<code class="in-band">impl&lt;'_&gt; <a class="trait" href="io/trait.read" title="trait std::io::Read">Read</a> for <a class="primitive" href="primitive.slice">&amp;'_ [</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#231-300" title="goto source code">[src]</a>
</h3>
<div class="docblock">
<p>Read is implemented for <code>&amp;[u8]</code> by copying from the slice.</p> <p>Note that reading updates the slice to point to the yet unread part. The slice will be empty when EOF is reached.</p> </div>
<div class="impl-items">
<h4 id="method.read" class="method hidden">
<code>fn <a href="io/trait.read#tymethod.read" class="fnname">read</a>(&amp;mut self, buf: <a class="primitive" href="primitive.slice">&amp;mut [</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a>) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#233-248" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Pull some bytes from this source into the specified buffer, returning how many bytes were read. <a href="io/trait.read#tymethod.read">Read more</a></p> </div>
<h4 id="method.read_vectored" class="method hidden">
<code>fn <a href="io/trait.read#method.read_vectored" class="fnname">read_vectored</a>(&amp;mut self, bufs: <a class="primitive" href="primitive.slice">&amp;mut [</a><a class="struct" href="io/struct.ioslicemut" title="struct std::io::IoSliceMut">IoSliceMut</a>&lt;'_&gt;<a class="primitive" href="primitive.slice">]</a>) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#251-261" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Like <code>read</code>, except that it reads into a slice of buffers. <a href="io/trait.read#method.read_vectored">Read more</a></p> </div>
<h4 id="method.is_read_vectored" class="method hidden">
<code>fn <a href="io/trait.read#method.is_read_vectored" class="fnname">is_read_vectored</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#264-266" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (can_vector #69941)</span></div>
<div class="docblock hidden">
<p>Determines if this <code>Read</code>er has an efficient <code>read_vectored</code> implementation. <a href="io/trait.read#method.is_read_vectored">Read more</a></p> </div>
<h4 id="method.initializer" class="method hidden">
<code>unsafe fn <a href="io/trait.read#method.initializer" class="fnname">initializer</a>(&amp;self) -&gt; <a class="struct" href="io/struct.initializer" title="struct std::io::Initializer">Initializer</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#269-271" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (read_initializer #42788)</span></div>
<div class="docblock hidden">
<p>Determines if this <code>Read</code>er can work with buffers of uninitialized memory. <a href="io/trait.read#method.initializer">Read more</a></p> </div>
<h4 id="method.read_exact" class="method hidden">
<code>fn <a href="io/trait.read#method.read_exact" class="fnname">read_exact</a>(&amp;mut self, buf: <a class="primitive" href="primitive.slice">&amp;mut [</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a>) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#274-291" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Read the exact number of bytes required to fill <code>buf</code>. <a href="io/trait.read#method.read_exact">Read more</a></p> </div>
<h4 id="method.read_to_end" class="method hidden">
<code>fn <a href="io/trait.read#method.read_to_end" class="fnname">read_to_end</a>(&amp;mut self, buf: &amp;mut <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="primitive.u8">u8</a>&gt;) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#294-299" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Read all bytes until EOF in this source, placing them into <code>buf</code>. <a href="io/trait.read#method.read_to_end">Read more</a></p> </div>
<h4 id="method.read_to_string" class="method hidden">
<code>fn <a href="io/trait.read#method.read_to_string" class="fnname">read_to_string</a>(&amp;mut self, buf: &amp;mut <a class="struct" href="string/struct.string" title="struct std::string::String">String</a>) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#703-714" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Read all bytes until EOF in this source, appending them to <code>buf</code>. <a href="io/trait.read#method.read_to_string">Read more</a></p> </div>
<h4 id="method.by_ref" class="method hidden">
<code>fn <a href="io/trait.read#method.by_ref" class="fnname">by_ref</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference">&amp;mut </a>Self<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#821-826" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a "by reference" adaptor for this instance of <code>Read</code>. <a href="io/trait.read#method.by_ref">Read more</a></p> </div>
<h4 id="method.bytes" class="method hidden">
<code>fn <a href="io/trait.read#method.bytes" class="fnname">bytes</a>(self) -&gt; <a class="struct" href="io/struct.bytes" title="struct std::io::Bytes">Bytes</a>&lt;Self&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Bytes&lt;R&gt;</h3>
<pre class="content">impl&lt;R: Read&gt; Iterator for Bytes&lt;R&gt;
    type Item = Result&lt;u8&gt;;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#858-863" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Transforms this <code>Read</code> instance to an <a href="iter/trait.iterator" title="`Iterator`"><code>Iterator</code></a> over its bytes. <a href="io/trait.read#method.bytes">Read more</a></p> </div>
<h4 id="method.chain" class="method hidden">
<code>fn <a href="io/trait.read#method.chain" class="fnname">chain</a>&lt;R: <a class="trait" href="io/trait.read" title="trait std::io::Read">Read</a>&gt;(self, next: R) -&gt; <a class="struct" href="io/struct.chain" title="struct std::io::Chain">Chain</a>&lt;Self, R&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Chain&lt;T, U&gt;</h3>
<pre class="content">impl&lt;T: Read, U: Read&gt; Read for Chain&lt;T, U&gt;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#896-901" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates an adaptor which will chain this stream with another. <a href="io/trait.read#method.chain">Read more</a></p> </div>
<h4 id="method.take" class="method hidden">
<code>fn <a href="io/trait.read#method.take" class="fnname">take</a>(self, limit: <a class="primitive" href="primitive.u64">u64</a>) -&gt; <a class="struct" href="io/struct.take" title="struct std::io::Take">Take</a>&lt;Self&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Take&lt;T&gt;</h3>
<pre class="content">impl&lt;T: Read&gt; Read for Take&lt;T&gt;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#935-940" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates an adaptor which will read at most <code>limit</code> bytes from it. <a href="io/trait.read#method.take">Read more</a></p> </div>
</div>
<h3 id="impl-ToOwned" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.toowned" title="trait std::borrow::ToOwned">ToOwned</a> for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="clone/trait.clone" title="trait std::clone::Clone">Clone</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#720-744" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Owned" class="type"><code>type <a href="borrow/trait.toowned#associatedtype.Owned" class="type">Owned</a> = <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;</code></h4>
<div class="docblock">
<p>The resulting type after obtaining ownership.</p> </div>
<h4 id="method.to_owned" class="method hidden">
<code>fn <a href="borrow/trait.toowned#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#723-725" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.toowned#tymethod.to_owned">Read more</a></p> </div>
<h4 id="method.clone_into" class="method hidden">
<code>fn <a href="borrow/trait.toowned#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: &amp;mut <a class="struct" href="vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;T&gt;)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/slice.rs.html#732-743" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (toowned_clone_into #41263)recently added </span></div>
<div class="docblock hidden">
<p>Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.toowned#method.clone_into">Read more</a></p> </div>
</div>
<h3 id="impl-ToSocketAddrs" class="impl">
<code class="in-band">impl&lt;'a&gt; <a class="trait" href="net/trait.tosocketaddrs" title="trait std::net::ToSocketAddrs">ToSocketAddrs</a> for <a class="primitive" href="primitive.slice">&amp;'a [</a><a class="enum" href="net/enum.socketaddr" title="enum std::net::SocketAddr">SocketAddr</a><a class="primitive" href="primitive.slice">]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/addr.rs.html#971-977" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Iter" class="type"><code>type <a href="net/trait.tosocketaddrs#associatedtype.Iter" class="type">Iter</a> = <a class="struct" href="iter/struct.cloned" title="struct std::iter::Cloned">Cloned</a>&lt;<a class="struct" href="slice/struct.iter" title="struct std::slice::Iter">Iter</a>&lt;'a, <a class="enum" href="net/enum.socketaddr" title="enum std::net::SocketAddr">SocketAddr</a>&gt;&gt;</code></h4>
<div class="docblock">
<p>Returned iterator over socket addresses which this type may correspond to. <a href="net/trait.tosocketaddrs#associatedtype.Iter">Read more</a></p> </div>
<h4 id="method.to_socket_addrs" class="method hidden">
<code>fn <a href="net/trait.tosocketaddrs#tymethod.to_socket_addrs" class="fnname">to_socket_addrs</a>(&amp;self) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;Self::<a class="type" href="net/trait.tosocketaddrs#associatedtype.Iter" title="type std::net::ToSocketAddrs::Iter">Iter</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/addr.rs.html#974-976" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Converts this object to an iterator of resolved <code>SocketAddr</code>s. <a href="net/trait.tosocketaddrs#tymethod.to_socket_addrs">Read more</a></p> </div>
</div>
<h3 id="impl-Write" class="impl">
<code class="in-band">impl&lt;'_&gt; <a class="trait" href="io/trait.write" title="trait std::io::Write">Write</a> for <a class="primitive" href="primitive.slice">&amp;'_ mut [</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#321-362" title="goto source code">[src]</a>
</h3>
<div class="docblock">
<p>Write is implemented for <code>&amp;mut [u8]</code> by copying into the slice, overwriting its data.</p> <p>Note that writing updates the slice to point to the yet unwritten part. The slice will be empty when it has been completely overwritten.</p> </div>
<div class="impl-items">
<h4 id="method.write" class="method hidden">
<code>fn <a href="io/trait.write#tymethod.write" class="fnname">write</a>(&amp;mut self, data: <a class="primitive" href="primitive.slice">&amp;[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a>) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#323-329" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Write a buffer into this writer, returning how many bytes were written. <a href="io/trait.write#tymethod.write">Read more</a></p> </div>
<h4 id="method.write_vectored" class="method hidden">
<code>fn <a href="io/trait.write#method.write_vectored" class="fnname">write_vectored</a>(&amp;mut self, bufs: <a class="primitive" href="primitive.slice">&amp;[</a><a class="struct" href="io/struct.ioslice" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;<a class="primitive" href="primitive.slice">]</a>) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.usize">usize</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#332-342" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Like [<code>write</code>], except that it writes from a slice of buffers. <a href="io/trait.write#method.write_vectored">Read more</a></p> </div>
<h4 id="method.is_write_vectored" class="method hidden">
<code>fn <a href="io/trait.write#method.is_write_vectored" class="fnname">is_write_vectored</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#345-347" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (can_vector #69941)</span></div>
<div class="docblock hidden">
<p>Determines if this <code>Write</code>er has an efficient [<code>write_vectored</code>] implementation. <a href="io/trait.write#method.is_write_vectored">Read more</a></p> </div>
<h4 id="method.write_all" class="method hidden">
<code>fn <a href="io/trait.write#method.write_all" class="fnname">write_all</a>(&amp;mut self, data: <a class="primitive" href="primitive.slice">&amp;[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a>) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#350-356" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Attempts to write an entire buffer into this writer. <a href="io/trait.write#method.write_all">Read more</a></p> </div>
<h4 id="method.flush" class="method hidden">
<code>fn <a href="io/trait.write#tymethod.flush" class="fnname">flush</a>(&amp;mut self) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/impls.rs.html#359-361" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Flush this output stream, ensuring that all intermediately buffered contents reach their destination. <a href="io/trait.write#tymethod.flush">Read more</a></p> </div>
<h4 id="method.write_all_vectored" class="method hidden">
<code>fn <a href="io/trait.write#method.write_all_vectored" class="fnname">write_all_vectored</a>(&amp;mut self, bufs: <a class="primitive" href="primitive.slice">&amp;mut [</a><a class="struct" href="io/struct.ioslice" title="struct std::io::IoSlice">IoSlice</a>&lt;'_&gt;<a class="primitive" href="primitive.slice">]</a>) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1440-1455" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (write_all_vectored #70436)</span></div>
<div class="docblock hidden">
<p>Attempts to write multiple buffers into this writer. <a href="io/trait.write#method.write_all_vectored">Read more</a></p> </div>
<h4 id="method.write_fmt" class="method hidden">
<code>fn <a href="io/trait.write#method.write_fmt" class="fnname">write_fmt</a>(&amp;mut self, fmt: <a class="struct" href="fmt/struct.arguments" title="struct std::fmt::Arguments">Arguments</a>&lt;'_&gt;) -&gt; <a class="type" href="io/type.result" title="type std::io::Result">Result</a>&lt;<a class="primitive" href="primitive.unit">()</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1493-1525" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Writes a formatted string into this writer, returning any error encountered. <a href="io/trait.write#method.write_fmt">Read more</a></p> </div>
<h4 id="method.by_ref-1" class="method hidden">
<code>fn <a href="io/trait.write#method.by_ref" class="fnname">by_ref</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference">&amp;mut </a>Self<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    Self: <a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/io/mod.rs.html#1549-1554" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a "by reference" adaptor for this instance of <code>Write</code>. <a href="io/trait.write#method.by_ref">Read more</a></p> </div>
</div>
</div>
<h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations</h2>
<div id="synthetic-implementations-list">
<h3 id="impl-RefUnwindSafe" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="panic/trait.refunwindsafe" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="panic/trait.refunwindsafe" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>, </span></code></h3>

<h3 id="impl-RefUnwindSafe-1" class="impl"><code class="in-band">impl <a class="trait" href="panic/trait.refunwindsafe" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.slice">[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></code></h3>

<h3 id="impl-Send" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="marker/trait.send" title="trait std::marker::Send">Send</a> for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="marker/trait.send" title="trait std::marker::Send">Send</a>, </span></code></h3>

<h3 id="impl-Send-1" class="impl"><code class="in-band">impl <a class="trait" href="marker/trait.send" title="trait std::marker::Send">Send</a> for <a class="primitive" href="primitive.slice">[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></code></h3>

<h3 id="impl-Sync" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="marker/trait.sync" title="trait std::marker::Sync">Sync</a> for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="marker/trait.sync" title="trait std::marker::Sync">Sync</a>, </span></code></h3>

<h3 id="impl-Sync-1" class="impl"><code class="in-band">impl <a class="trait" href="marker/trait.sync" title="trait std::marker::Sync">Sync</a> for <a class="primitive" href="primitive.slice">[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></code></h3>

<h3 id="impl-Unpin" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="marker/trait.unpin" title="trait std::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="marker/trait.unpin" title="trait std::marker::Unpin">Unpin</a>, </span></code></h3>

<h3 id="impl-Unpin-1" class="impl"><code class="in-band">impl <a class="trait" href="marker/trait.unpin" title="trait std::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.slice">[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></code></h3>

<h3 id="impl-UnwindSafe" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="panic/trait.unwindsafe" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.slice">[</a>T<a class="primitive" href="primitive.slice">]</a> <span class="where fmt-newline">where<br>    T: <a class="trait" href="panic/trait.unwindsafe" title="trait std::panic::UnwindSafe">UnwindSafe</a>, </span></code></h3>

<h3 id="impl-UnwindSafe-1" class="impl"><code class="in-band">impl <a class="trait" href="panic/trait.unwindsafe" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.slice">[</a><a class="primitive" href="primitive.u8">u8</a><a class="primitive" href="primitive.slice">]</a></code></h3>

</div>
<h2 id="blanket-implementations" class="small-section-header">Blanket Implementations</h2>
<div id="blanket-implementations-list">
<h3 id="impl-Any" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="any/trait.any" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>    T: 'static + ?<a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#108-112" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.type_id" class="method hidden">
<code>fn <a href="any/trait.any#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.typeid" title="struct std::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#109-111" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.any#tymethod.type_id">Read more</a></p> </div>
</div>
<h3 id="impl-Any-1" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="any/trait.any" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>    T: 'static + ?<a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#108-112" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.type_id-1" class="method hidden">
<code>fn <a href="any/trait.any#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.typeid" title="struct std::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#109-111" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.any#tymethod.type_id">Read more</a></p> </div>
</div>
<h3 id="impl-Borrow%3CT%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.borrow" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>    T: ?<a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#210-214" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.borrow" class="method hidden">
<code>fn <a href="borrow/trait.borrow#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference">&amp;</a>T<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#211-213" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Immutably borrows from an owned value. <a href="borrow/trait.borrow#tymethod.borrow">Read more</a></p> </div>
</div>
<h3 id="impl-Borrow%3CT%3E-1" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.borrow" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>    T: ?<a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#210-214" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.borrow-1" class="method hidden">
<code>fn <a href="borrow/trait.borrow#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference">&amp;</a>T<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#211-213" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Immutably borrows from an owned value. <a href="borrow/trait.borrow#tymethod.borrow">Read more</a></p> </div>
</div>
<h3 id="impl-BorrowMut%3CT%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.borrowmut" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>    T: ?<a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217-221" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.borrow_mut" class="method hidden">
<code>fn <a href="borrow/trait.borrowmut#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference">&amp;mut </a>T<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#218-220" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Mutably borrows from an owned value. <a href="borrow/trait.borrowmut#tymethod.borrow_mut">Read more</a></p> </div>
</div>
<h3 id="impl-BorrowMut%3CT%3E-1" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.borrowmut" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>    T: ?<a class="trait" href="marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217-221" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.borrow_mut-1" class="method hidden">
<code>fn <a href="borrow/trait.borrowmut#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference">&amp;mut </a>T<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#218-220" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Mutably borrows from an owned value. <a href="borrow/trait.borrowmut#tymethod.borrow_mut">Read more</a></p> </div>
</div>
<h3 id="impl-ToOwned-1" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.toowned" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>    T: <a class="trait" href="clone/trait.clone" title="trait std::clone::Clone">Clone</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#80-92" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Owned-2" class="type"><code>type <a href="borrow/trait.toowned#associatedtype.Owned" class="type">Owned</a> = T</code></h4>
<div class="docblock">
<p>The resulting type after obtaining ownership.</p> </div>
<h4 id="method.to_owned-1" class="method hidden">
<code>fn <a href="borrow/trait.toowned#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#85-87" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.toowned#tymethod.to_owned">Read more</a></p> </div>
<h4 id="method.clone_into-1" class="method hidden">
<code>fn <a href="borrow/trait.toowned#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference">&amp;mut </a>T)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#89-91" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (toowned_clone_into #41263)recently added </span></div>
<div class="docblock hidden">
<p>Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.toowned#method.clone_into">Read more</a></p> </div>
</div>
<h3 id="impl-ToOwned-2" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.toowned" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>    T: <a class="trait" href="clone/trait.clone" title="trait std::clone::Clone">Clone</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#80-92" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Owned-3" class="type"><code>type <a href="borrow/trait.toowned#associatedtype.Owned" class="type">Owned</a> = T</code></h4>
<div class="docblock">
<p>The resulting type after obtaining ownership.</p> </div>
<h4 id="method.to_owned-2" class="method hidden">
<code>fn <a href="borrow/trait.toowned#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#85-87" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.toowned#tymethod.to_owned">Read more</a></p> </div>
<h4 id="method.clone_into-2" class="method hidden">
<code>fn <a href="borrow/trait.toowned#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference">&amp;mut </a>T)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#89-91" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (toowned_clone_into #41263)recently added </span></div>
<div class="docblock hidden">
<p>Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.toowned#method.clone_into">Read more</a></p> </div>
</div>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/primitive.slice.html" class="_attribution-link">https://doc.rust-lang.org/std/primitive.slice.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
