
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std&#58;&#58;alloc&#58;&#58;AllocRef - Rust - W3cubDocs</title>
  
  <meta name="description" content=" An implementation of AllocRef can allocate, grow, shrink, and deallocate arbitrary blocks of data described via Layout. ">
  <meta name="keywords" content="trait, std, alloc, allocref, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rust/std/alloc/trait.allocref.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rust">
				
				
<h1 class="fqn">Trait std::alloc::AllocRef</h1>
<pre class="rust trait" data-language="rust">pub unsafe trait AllocRef {
    fn alloc(&amp;mut self, layout: Layout) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocErr&gt;;
    unsafe fn dealloc(&amp;mut self, ptr: NonNull&lt;u8&gt;, layout: Layout);

    fn alloc_zeroed(Â Â Â Â Â Â Â Â &amp;mut self, Â Â Â Â Â Â Â Â layout: LayoutÂ Â Â Â ) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocErr&gt; { ... }
    unsafe fn grow(Â Â Â Â Â Â Â Â &amp;mut self, Â Â Â Â Â Â Â Â ptr: NonNull&lt;u8&gt;, Â Â Â Â Â Â Â Â layout: Layout, Â Â Â Â Â Â Â Â new_size: usizeÂ Â Â Â ) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocErr&gt; { ... }
    unsafe fn grow_zeroed(Â Â Â Â Â Â Â Â &amp;mut self, Â Â Â Â Â Â Â Â ptr: NonNull&lt;u8&gt;, Â Â Â Â Â Â Â Â layout: Layout, Â Â Â Â Â Â Â Â new_size: usizeÂ Â Â Â ) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocErr&gt; { ... }
    unsafe fn shrink(Â Â Â Â Â Â Â Â &amp;mut self, Â Â Â Â Â Â Â Â ptr: NonNull&lt;u8&gt;, Â Â Â Â Â Â Â Â layout: Layout, Â Â Â Â Â Â Â Â new_size: usizeÂ Â Â Â ) -&gt; Result&lt;NonNull&lt;[u8]&gt;, AllocErr&gt; { ... }
    fn by_ref(&amp;mut self) -&gt; &amp;mut Selfâ“˜Notable traits for &amp;'_ mut Fimpl&lt;'_, F&gt; Future for &amp;'_ mut F whereÂ Â Â Â F: Unpin + Future + ?Sized,Â     type Output = &lt;F as Future&gt;::Output;impl&lt;'_, I&gt; Iterator for &amp;'_ mut I whereÂ Â Â Â I: Iterator + ?Sized,Â     type Item = &lt;I as Iterator&gt;::Item;impl&lt;R:Â Read + ?Sized, '_&gt; Read for &amp;'_ mut Rimpl&lt;W:Â Write + ?Sized, '_&gt; Write for &amp;'_ mut W { ... }
}</pre>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<p>An implementation of <code>AllocRef</code> can allocate, grow, shrink, and deallocate arbitrary blocks of data described via <a href="struct.layout" title="`Layout`"><code>Layout</code></a>.</p> <p><code>AllocRef</code> is designed to be implemented on ZSTs, references, or smart pointers because having an allocator like <code>MyAlloc([u8; N])</code> cannot be moved, without updating the pointers to the allocated memory.</p> <p>Unlike <a href="trait.globalalloc" title="`GlobalAlloc`"><code>GlobalAlloc</code></a>, zero-sized allocations are allowed in <code>AllocRef</code>. If an underlying allocator does not support this (like jemalloc) or return a null pointer (such as <code>libc::malloc</code>), this must be caught by the implementation.</p> <h3 id="currently-allocated-memory" class="section-header">Currently allocated memory</h3> <p>Some of the methods require that a memory block be <em>currently allocated</em> via an allocator. This means that:</p> <ul> <li> <p>the starting address for that memory block was previously returned by <a href="trait.allocref#tymethod.alloc"><code>alloc</code></a>, <a href="trait.allocref#method.grow"><code>grow</code></a>, or <a href="trait.allocref#method.shrink"><code>shrink</code></a>, and</p> </li> <li> <p>the memory block has not been subsequently deallocated, where blocks are either deallocated directly by being passed to <a href="trait.allocref#tymethod.dealloc"><code>dealloc</code></a> or were changed by being passed to <a href="trait.allocref#method.grow"><code>grow</code></a> or <a href="trait.allocref#method.shrink"><code>shrink</code></a> that returns <code>Ok</code>. If <code>grow</code> or <code>shrink</code> have returned <code>Err</code>, the passed pointer remains valid.</p> </li> </ul> <h3 id="memory-fitting" class="section-header">Memory fitting</h3> <p>Some of the methods require that a layout <em>fit</em> a memory block. What it means for a layout to "fit" a memory block means (or equivalently, for a memory block to "fit" a layout) is that the following conditions must hold:</p> <ul> <li> <p>The block must be allocated with the same alignment as <a href="struct.layout#method.align"><code>layout.align()</code></a>, and</p> </li> <li> <p>The provided <a href="struct.layout#method.size"><code>layout.size()</code></a> must fall in the range <code>min ..= max</code>, where:</p> <ul> <li>
<code>min</code> is the size of the layout most recently used to allocate the block, and</li> <li>
<code>max</code> is the latest actual size returned from <a href="trait.allocref#tymethod.alloc"><code>alloc</code></a>, <a href="trait.allocref#method.grow"><code>grow</code></a>, or <a href="trait.allocref#method.shrink"><code>shrink</code></a>.</li> </ul> </li> </ul> <h2 id="safety" class="section-header">Safety</h2> <ul> <li> <p>Memory blocks returned from an allocator must point to valid memory and retain their validity until the instance and all of its clones are dropped,</p> </li> <li> <p>cloning or moving the allocator must not invalidate memory blocks returned from this allocator. A cloned allocator must behave like the same allocator, and</p> </li> <li> <p>any pointer to a memory block which is <a href="#currently-allocated-memory"><em>currently allocated</em></a> may be passed to any other method of the allocator.</p> </li> </ul>  <h2 id="required-methods" class="small-section-header">Required methods</h2>
<div class="methods">
<h3 id="tymethod.alloc" class="method"><code>fn <a href="#tymethod.alloc" class="fnname">alloc</a>(&amp;mut self, layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<div class="docblock">
<p>Attempts to allocate a block of memory.</p> <p>On success, returns a [<code>NonNull&lt;[u8]&gt;</code>] meeting the size and alignment guarantees of <code>layout</code>.</p> <p>The returned block may have a larger size than specified by <code>layout.size()</code>, and may or may not have its contents initialized.</p> <p>[<code>NonNull&lt;[u8]&gt;</code>]: NonNull</p> <h2 id="errors" class="section-header">Errors</h2> <p>Returning <code>Err</code> indicates that either memory is exhausted or <code>layout</code> does not meet allocator's size or alignment constraints.</p> <p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</p> <p>Clients wishing to abort computation in response to an allocation error are encouraged to call the <a href="https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p> </div>
<h3 id="tymethod.dealloc" class="method"><code>unsafe fn <a href="#tymethod.dealloc" class="fnname">dealloc</a>(&amp;mut self, ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>)</code></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<div class="docblock">
<p>Deallocates the memory referenced by <code>ptr</code>.</p> <h2 id="safety-1" class="section-header">Safety</h2> <ul> <li>
<code>ptr</code> must denote a block of memory <a href="#currently-allocated-memory"><em>currently allocated</em></a> via this allocator, and</li> <li>
<code>layout</code> must <a href="#memory-fitting"><em>fit</em></a> that block of memory.</li> </ul> </div>
</div>
<span class="loading-content">Loading content...</span> <h2 id="provided-methods" class="small-section-header">Provided methods</h2>
<div class="methods">
<h3 id="method.alloc_zeroed" class="method"><code>fn <a href="#method.alloc_zeroed" class="fnname">alloc_zeroed</a>(&amp;mut self, layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<div class="docblock">
<p>Behaves like <code>alloc</code>, but also ensures that the returned memory is zero-initialized.</p> <h2 id="errors-1" class="section-header">Errors</h2> <p>Returning <code>Err</code> indicates that either memory is exhausted or <code>layout</code> does not meet allocator's size or alignment constraints.</p> <p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</p> <p>Clients wishing to abort computation in response to an allocation error are encouraged to call the <a href="https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p> </div>
<h3 id="method.grow" class="method"><code>unsafe fn <a href="#method.grow" class="fnname">grow</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, <br>Â Â Â Â layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>, <br>Â Â Â Â new_size: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<div class="docblock">
<p>Attempts to extend the memory block.</p> <p>Returns a new [<code>NonNull&lt;[u8]&gt;</code>] containing a pointer and the actual size of the allocated memory. The pointer is suitable for holding data described by a new layout with <code>layout</code>â€™s alignment and a size given by <code>new_size</code>. To accomplish this, the allocator may extend the allocation referenced by <code>ptr</code> to fit the new layout.</p> <p>If this returns <code>Ok</code>, then ownership of the memory block referenced by <code>ptr</code> has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable unless it was transferred back to the caller again via the return value of this method.</p> <p>If this method returns <code>Err</code>, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</p> <p>[<code>NonNull&lt;[u8]&gt;</code>]: NonNull</p> <h2 id="safety-2" class="section-header">Safety</h2> <ul> <li>
<code>ptr</code> must denote a block of memory <a href="#currently-allocated-memory"><em>currently allocated</em></a> via this allocator,</li> <li>
<code>layout</code> must <a href="#memory-fitting"><em>fit</em></a> that block of memory (The <code>new_size</code> argument need not fit it.),</li> <li>
<code>new_size</code> must be greater than or equal to <code>layout.size()</code>, and</li> <li>
<code>new_size</code>, when rounded up to the nearest multiple of <code>layout.align()</code>, must not overflow (i.e., the rounded value must be less than or equal to <code>usize::MAX</code>).</li> </ul> <h2 id="errors-2" class="section-header">Errors</h2> <p>Returns <code>Err</code> if the new layout does not meet the allocator's size and alignment constraints of the allocator, or if growing otherwise fails.</p> <p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</p> <p>Clients wishing to abort computation in response to an allocation error are encouraged to call the <a href="https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p> </div>
<h3 id="method.grow_zeroed" class="method"><code>unsafe fn <a href="#method.grow_zeroed" class="fnname">grow_zeroed</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, <br>Â Â Â Â layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>, <br>Â Â Â Â new_size: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<div class="docblock">
<p>Behaves like <code>grow</code>, but also ensures that the new contents are set to zero before being returned.</p> <p>The memory block will contain the following contents after a successful call to <code>grow_zeroed</code>:</p> <ul> <li>Bytes <code>0..layout.size()</code> are preserved from the original allocation.</li> <li>Bytes <code>layout.size()..old_size</code> will either be preserved or zeroed, depending on the allocator implementation. <code>old_size</code> refers to the size of the memory block prior to the <code>grow_zeroed</code> call, which may be larger than the size that was originally requested when it was allocated.</li> <li>Bytes <code>old_size..new_size</code> are zeroed. <code>new_size</code> refers to the size of the memory block returned by the <code>grow</code> call.</li> </ul> <h2 id="safety-3" class="section-header">Safety</h2> <ul> <li>
<code>ptr</code> must denote a block of memory <a href="#currently-allocated-memory"><em>currently allocated</em></a> via this allocator,</li> <li>
<code>layout</code> must <a href="#memory-fitting"><em>fit</em></a> that block of memory (The <code>new_size</code> argument need not fit it.),</li> <li>
<code>new_size</code> must be greater than or equal to <code>layout.size()</code>, and</li> <li>
<code>new_size</code>, when rounded up to the nearest multiple of <code>layout.align()</code>, must not overflow (i.e., the rounded value must be less than or equal to <code>usize::MAX</code>).</li> </ul> <h2 id="errors-3" class="section-header">Errors</h2> <p>Returns <code>Err</code> if the new layout does not meet the allocator's size and alignment constraints of the allocator, or if growing otherwise fails.</p> <p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</p> <p>Clients wishing to abort computation in response to an allocation error are encouraged to call the <a href="https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p> </div>
<h3 id="method.shrink" class="method"><code>unsafe fn <a href="#method.shrink" class="fnname">shrink</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, <br>Â Â Â Â layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>, <br>Â Â Â Â new_size: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<div class="docblock">
<p>Attempts to shrink the memory block.</p> <p>Returns a new [<code>NonNull&lt;[u8]&gt;</code>] containing a pointer and the actual size of the allocated memory. The pointer is suitable for holding data described by a new layout with <code>layout</code>â€™s alignment and a size given by <code>new_size</code>. To accomplish this, the allocator may shrink the allocation referenced by <code>ptr</code> to fit the new layout.</p> <p>If this returns <code>Ok</code>, then ownership of the memory block referenced by <code>ptr</code> has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable unless it was transferred back to the caller again via the return value of this method.</p> <p>If this method returns <code>Err</code>, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</p> <p>[<code>NonNull&lt;[u8]&gt;</code>]: NonNull</p> <h2 id="safety-4" class="section-header">Safety</h2> <ul> <li>
<code>ptr</code> must denote a block of memory <a href="#currently-allocated-memory"><em>currently allocated</em></a> via this allocator,</li> <li>
<code>layout</code> must <a href="#memory-fitting"><em>fit</em></a> that block of memory (The <code>new_size</code> argument need not fit it.), and</li> <li>
<code>new_size</code> must be smaller than or equal to <code>layout.size()</code>.</li> </ul> <h2 id="errors-4" class="section-header">Errors</h2> <p>Returns <code>Err</code> if the new layout does not meet the allocator's size and alignment constraints of the allocator, or if shrinking otherwise fails.</p> <p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</p> <p>Clients wishing to abort computation in response to an allocation error are encouraged to call the <a href="https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html"><code>handle_alloc_error</code></a> function, rather than directly invoking <code>panic!</code> or similar.</p> </div>
<h3 id="method.by_ref" class="method"><code>fn <a href="#method.by_ref" class="fnname">by_ref</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.reference">&amp;mut </a>Self<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
Â Â Â Â F: Unpin + Future + ?Sized,Â 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
Â Â Â Â I: Iterator + ?Sized,Â 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R:Â Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W:Â Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span></code></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<div class="docblock">
<p>Creates a "by reference" adaptor for this instance of <code>AllocRef</code>.</p> <p>The returned adaptor also implements <code>AllocRef</code> and will simply borrow this.</p> </div>
</div>
<span class="loading-content">Loading content...</span> <h2 id="implementors" class="small-section-header">Implementors</h2>
<div class="item-list" id="implementors-list">
<h3 id="impl-AllocRef" class="impl">
<code class="in-band">impl AllocRef for <a class="struct" href="struct.global" title="struct std::alloc::Global">Global</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/alloc.rs.html#200-272" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.alloc" class="method hidden">
<code>fn <a href="#method.alloc" class="fnname">alloc</a>(&amp;mut self, layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/alloc.rs.html#202-204" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.alloc_zeroed-1" class="method hidden">
<code>fn <a href="#method.alloc_zeroed-1" class="fnname">alloc_zeroed</a>(&amp;mut self, layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/alloc.rs.html#207-209" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.dealloc" class="method hidden">
<code>unsafe fn <a href="#method.dealloc" class="fnname">dealloc</a>(&amp;mut self, ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/alloc.rs.html#212-218" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.grow-1" class="method hidden">
<code>unsafe fn <a href="#method.grow-1" class="fnname">grow</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, <br>Â Â Â Â layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>, <br>Â Â Â Â new_size: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/alloc.rs.html#221-229" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.grow_zeroed-1" class="method hidden">
<code>unsafe fn <a href="#method.grow_zeroed-1" class="fnname">grow_zeroed</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, <br>Â Â Â Â layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>, <br>Â Â Â Â new_size: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/alloc.rs.html#232-240" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.shrink-1" class="method hidden">
<code>unsafe fn <a href="#method.shrink-1" class="fnname">shrink</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, <br>Â Â Â Â layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>, <br>Â Â Â Â new_size: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/alloc.rs.html#243-271" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
</div>
<h3 id="impl-AllocRef-1" class="impl">
<code class="in-band">impl AllocRef for <a class="struct" href="struct.system" title="struct std::alloc::System">System</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/alloc.rs.html#194-266" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.alloc-1" class="method hidden">
<code>fn <a href="#method.alloc-1" class="fnname">alloc</a>(&amp;mut self, layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/alloc.rs.html#196-198" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.alloc_zeroed-2" class="method hidden">
<code>fn <a href="#method.alloc_zeroed-2" class="fnname">alloc_zeroed</a>(&amp;mut self, layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/alloc.rs.html#201-203" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.dealloc-1" class="method hidden">
<code>unsafe fn <a href="#method.dealloc-1" class="fnname">dealloc</a>(&amp;mut self, ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/std/alloc.rs.html#206-212" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.grow-2" class="method hidden">
<code>unsafe fn <a href="#method.grow-2" class="fnname">grow</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, <br>Â Â Â Â layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>, <br>Â Â Â Â new_size: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/alloc.rs.html#215-223" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.grow_zeroed-2" class="method hidden">
<code>unsafe fn <a href="#method.grow_zeroed-2" class="fnname">grow_zeroed</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, <br>Â Â Â Â layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>, <br>Â Â Â Â new_size: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/alloc.rs.html#226-234" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.shrink-2" class="method hidden">
<code>unsafe fn <a href="#method.shrink-2" class="fnname">shrink</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, <br>Â Â Â Â layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>, <br>Â Â Â Â new_size: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/alloc.rs.html#237-265" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
</div>
<h3 id="impl-AllocRef-2" class="impl">
<code class="in-band">impl&lt;'_, A&gt; AllocRef for <a class="primitive" href="../primitive.reference">&amp;'_ mut </a>A <span class="where fmt-newline">where<br>Â Â Â Â A: <a class="trait" href="trait.allocref" title="trait std::alloc::AllocRef">AllocRef</a> + ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>,Â </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/alloc/mod.rs.html#364-416" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.alloc-2" class="method hidden">
<code>fn <a href="#method.alloc-2" class="fnname">alloc</a>(&amp;mut self, layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/alloc/mod.rs.html#369-371" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.alloc_zeroed-3" class="method hidden">
<code>fn <a href="#method.alloc_zeroed-3" class="fnname">alloc_zeroed</a>(&amp;mut self, layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/alloc/mod.rs.html#374-376" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.dealloc-2" class="method hidden">
<code>unsafe fn <a href="#method.dealloc-2" class="fnname">dealloc</a>(&amp;mut self, ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/alloc/mod.rs.html#379-382" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.grow-3" class="method hidden">
<code>unsafe fn <a href="#method.grow-3" class="fnname">grow</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, <br>Â Â Â Â layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>, <br>Â Â Â Â new_size: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/alloc/mod.rs.html#385-393" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.grow_zeroed-3" class="method hidden">
<code>unsafe fn <a href="#method.grow_zeroed-3" class="fnname">grow_zeroed</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, <br>Â Â Â Â layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>, <br>Â Â Â Â new_size: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/alloc/mod.rs.html#396-404" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
<h4 id="method.shrink-3" class="method hidden">
<code>unsafe fn <a href="#method.shrink-3" class="fnname">shrink</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;, <br>Â Â Â Â layout: <a class="struct" href="struct.layout" title="struct std::alloc::Layout">Layout</a>, <br>Â Â Â Â new_size: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../ptr/struct.nonnull" title="struct std::ptr::NonNull">NonNull</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt;, <a class="struct" href="struct.allocerr" title="struct std::alloc::AllocErr">AllocErr</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/alloc/mod.rs.html#407-415" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)</span></div>
</div>
</div>
<span class="loading-content">Loading content...</span><div class="_attribution">
  <p class="_attribution-p">
    Â© 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/alloc/trait.AllocRef.html" class="_attribution-link">https://doc.rust-lang.org/std/alloc/trait.AllocRef.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
