
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Std&#58;&#58;collections - Rust - W3cubDocs</title>
  
  <meta name="description" content=" Collection types. ">
  <meta name="keywords" content="module, std, collections, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rust/std/collections/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rust">
				
				
<h1 class="fqn">Module std::collections</h1>
<p>Collection types.</p> <p>Rust's standard collection library provides efficient implementations of the most common general purpose programming data structures. By using the standard implementations, it should be possible for two libraries to communicate without significant data conversion.</p> <p>To get this out of the way: you should probably just use <a href="../vec/struct.vec" title="`Vec`"><code>Vec</code></a> or <a href="struct.hashmap" title="`HashMap`"><code>HashMap</code></a>. These two collections cover most use cases for generic data storage and processing. They are exceptionally good at doing what they do. All the other collections in the standard library have specific use cases where they are the optimal choice, but these cases are borderline <em>niche</em> in comparison. Even when <code>Vec</code> and <code>HashMap</code> are technically suboptimal, they're probably a good enough choice to get started.</p> <p>Rust's collections can be grouped into four major categories:</p> <ul> <li>Sequences: <a href="../vec/struct.vec" title="`Vec`"><code>Vec</code></a>, <a href="struct.vecdeque" title="`VecDeque`"><code>VecDeque</code></a>, <a href="struct.linkedlist" title="`LinkedList`"><code>LinkedList</code></a>
</li> <li>Maps: <a href="struct.hashmap" title="`HashMap`"><code>HashMap</code></a>, <a href="struct.btreemap" title="`BTreeMap`"><code>BTreeMap</code></a>
</li> <li>Sets: <a href="struct.hashset" title="`HashSet`"><code>HashSet</code></a>, <a href="struct.btreeset" title="`BTreeSet`"><code>BTreeSet</code></a>
</li> <li>Misc: <a href="struct.binaryheap" title="`BinaryHeap`"><code>BinaryHeap</code></a>
</li> </ul> <h2 id="when-should-you-use-which-collection" class="section-header">When Should You Use Which Collection?</h2> <p>These are fairly high-level and quick break-downs of when each collection should be considered. Detailed discussions of strengths and weaknesses of individual collections can be found on their own documentation pages.</p> <h3 id="use-a-vec-when" class="section-header">Use a <code>Vec</code> when:</h3> <ul> <li>You want to collect items up to be processed or sent elsewhere later, and don't care about any properties of the actual values being stored.</li> <li>You want a sequence of elements in a particular order, and will only be appending to (or near) the end.</li> <li>You want a stack.</li> <li>You want a resizable array.</li> <li>You want a heap-allocated array.</li> </ul> <h3 id="use-a-vecdeque-when" class="section-header">Use a <code>VecDeque</code> when:</h3> <ul> <li>You want a <a href="../vec/struct.vec" title="`Vec`"><code>Vec</code></a> that supports efficient insertion at both ends of the sequence.</li> <li>You want a queue.</li> <li>You want a double-ended queue (deque).</li> </ul> <h3 id="use-a-linkedlist-when" class="section-header">Use a <code>LinkedList</code> when:</h3> <ul> <li>You want a <a href="../vec/struct.vec" title="`Vec`"><code>Vec</code></a> or <a href="struct.vecdeque" title="`VecDeque`"><code>VecDeque</code></a> of unknown size, and can't tolerate amortization.</li> <li>You want to efficiently split and append lists.</li> <li>You are <em>absolutely</em> certain you <em>really</em>, <em>truly</em>, want a doubly linked list.</li> </ul> <h3 id="use-a-hashmap-when" class="section-header">Use a <code>HashMap</code> when:</h3> <ul> <li>You want to associate arbitrary keys with an arbitrary value.</li> <li>You want a cache.</li> <li>You want a map, with no extra functionality.</li> </ul> <h3 id="use-a-btreemap-when" class="section-header">Use a <code>BTreeMap</code> when:</h3> <ul> <li>You want a map sorted by its keys.</li> <li>You want to be able to get a range of entries on-demand.</li> <li>You're interested in what the smallest or largest key-value pair is.</li> <li>You want to find the largest or smallest key that is smaller or larger than something.</li> </ul> <h3 id="use-the-set-variant-of-any-of-these-maps-when" class="section-header">Use the <code>Set</code> variant of any of these <code>Map</code>s when:</h3> <ul> <li>You just want to remember which keys you've seen.</li> <li>There is no meaningful value to associate with your keys.</li> <li>You just want a set.</li> </ul> <h3 id="use-a-binaryheap-when" class="section-header">Use a <code>BinaryHeap</code> when:</h3> <ul> <li>You want to store a bunch of elements, but only ever want to process the "biggest" or "most important" one at any given time.</li> <li>You want a priority queue.</li> </ul> <h2 id="performance" class="section-header">Performance</h2> <p>Choosing the right collection for the job requires an understanding of what each collection is good at. Here we briefly summarize the performance of different collections for certain important operations. For further details, see each type's documentation, and note that the names of actual methods may differ from the tables below on certain collections.</p> <p>Throughout the documentation, we will follow a few conventions. For all operations, the collection's size is denoted by n. If another collection is involved in the operation, it contains m elements. Operations which have an <em>amortized</em> cost are suffixed with a <code>*</code>. Operations with an <em>expected</em> cost are suffixed with a <code>~</code>.</p> <p>All amortized costs are for the potential need to resize when capacity is exhausted. If a resize occurs it will take <em>O</em>(<em>n</em>) time. Our collections never automatically shrink, so removal operations aren't amortized. Over a sufficiently large series of operations, the average cost per operation will deterministically equal the given cost.</p> <p>Only <a href="struct.hashmap" title="`HashMap`"><code>HashMap</code></a> has expected costs, due to the probabilistic nature of hashing. It is theoretically possible, though very unlikely, for <a href="struct.hashmap" title="`HashMap`"><code>HashMap</code></a> to experience worse performance.</p> <h3 id="sequences" class="section-header">Sequences</h3>
<table>
<thead><tr>
<th></th>
<th>get(i)</th>
<th>insert(i)</th>
<th>remove(i)</th>
<th>append</th>
<th>split_off(i)</th>
</tr></thead>
<tbody> <tr>
<td><a href="../vec/struct.vec" title="`Vec`"><code>Vec</code></a></td>
<td>O(1)</td>
<td>O(n-i)*</td>
<td>O(n-i)</td>
<td>O(m)*</td>
<td>O(n-i)</td>
</tr> <tr>
<td><a href="struct.vecdeque" title="`VecDeque`"><code>VecDeque</code></a></td>
<td>O(1)</td>
<td>O(min(i, n-i))*</td>
<td>O(min(i, n-i))</td>
<td>O(m)*</td>
<td>O(min(i, n-i))</td>
</tr> <tr>
<td><a href="struct.linkedlist" title="`LinkedList`"><code>LinkedList</code></a></td>
<td>O(min(i, n-i))</td>
<td>O(min(i, n-i))</td>
<td>O(min(i, n-i))</td>
<td>O(1)</td>
<td>O(min(i, n-i))</td>
</tr> </tbody>
</table> <p>Note that where ties occur, <a href="../vec/struct.vec" title="`Vec`"><code>Vec</code></a> is generally going to be faster than <a href="struct.vecdeque" title="`VecDeque`"><code>VecDeque</code></a>, and <a href="struct.vecdeque" title="`VecDeque`"><code>VecDeque</code></a> is generally going to be faster than <a href="struct.linkedlist" title="`LinkedList`"><code>LinkedList</code></a>.</p> <h3 id="maps" class="section-header">Maps</h3> <p>For Sets, all operations have the cost of the equivalent Map operation.</p> <table>
<thead><tr>
<th></th>
<th>get</th>
<th>insert</th>
<th>remove</th>
<th>predecessor</th>
<th>append</th>
</tr></thead>
<tbody> <tr>
<td><a href="struct.hashmap" title="`HashMap`"><code>HashMap</code></a></td>
<td>O(1)~</td>
<td>O(1)~*</td>
<td>O(1)~</td>
<td>N/A</td>
<td>N/A</td>
</tr> <tr>
<td><a href="struct.btreemap" title="`BTreeMap`"><code>BTreeMap</code></a></td>
<td>O(log(n))</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
<td>O(n+m)</td>
</tr> </tbody>
</table> <h2 id="correct-and-efficient-usage-of-collections" class="section-header">Correct and Efficient Usage of Collections</h2> <p>Of course, knowing which collection is the right one for the job doesn't instantly permit you to use it correctly. Here are some quick tips for efficient and correct usage of the standard collections in general. If you're interested in how to use a specific collection in particular, consult its documentation for detailed discussion and code examples.</p> <h3 id="capacity-management" class="section-header">Capacity Management</h3> <p>Many collections provide several constructors and methods that refer to "capacity". These collections are generally built on top of an array. Optimally, this array would be exactly the right size to fit only the elements stored in the collection, but for the collection to do this would be very inefficient. If the backing array was exactly the right size at all times, then every time an element is inserted, the collection would have to grow the array to fit it. Due to the way memory is allocated and managed on most computers, this would almost surely require allocating an entirely new array and copying every single element from the old one into the new one. Hopefully you can see that this wouldn't be very efficient to do on every operation.</p> <p>Most collections therefore use an <em>amortized</em> allocation strategy. They generally let themselves have a fair amount of unoccupied space so that they only have to grow on occasion. When they do grow, they allocate a substantially larger array to move the elements into so that it will take a while for another grow to be required. While this strategy is great in general, it would be even better if the collection <em>never</em> had to resize its backing array. Unfortunately, the collection itself doesn't have enough information to do this itself. Therefore, it is up to us programmers to give it hints.</p> <p>Any <code>with_capacity</code> constructor will instruct the collection to allocate enough space for the specified number of elements. Ideally this will be for exactly that many elements, but some implementation details may prevent this. See collection-specific documentation for details. In general, use <code>with_capacity</code> when you know exactly how many elements will be inserted, or at least have a reasonable upper-bound on that number.</p> <p>When anticipating a large influx of elements, the <code>reserve</code> family of methods can be used to hint to the collection how much room it should make for the coming items. As with <code>with_capacity</code>, the precise behavior of these methods will be specific to the collection of interest.</p> <p>For optimal performance, collections will generally avoid shrinking themselves. If you believe that a collection will not soon contain any more elements, or just really need the memory, the <code>shrink_to_fit</code> method prompts the collection to shrink the backing array to the minimum size capable of holding its elements.</p> <p>Finally, if ever you're interested in what the actual capacity of the collection is, most collections provide a <code>capacity</code> method to query this information on demand. This can be useful for debugging purposes, or for use with the <code>reserve</code> methods.</p> <h3 id="iterators" class="section-header">Iterators</h3> <p>Iterators are a powerful and robust mechanism used throughout Rust's standard libraries. Iterators provide a sequence of values in a generic, safe, efficient and convenient way. The contents of an iterator are usually <em>lazily</em> evaluated, so that only the values that are actually needed are ever actually produced, and no allocation need be done to temporarily store them. Iterators are primarily consumed using a <code>for</code> loop, although many functions also take iterators where a collection or sequence of values is desired.</p> <p>All of the standard collections provide several iterators for performing bulk manipulation of their contents. The three primary iterators almost every collection should provide are <code>iter</code>, <code>iter_mut</code>, and <code>into_iter</code>. Some of these are not provided on collections where it would be unsound or unreasonable to provide them.</p> <p><code>iter</code> provides an iterator of immutable references to all the contents of a collection in the most "natural" order. For sequence collections like <a href="../vec/struct.vec" title="`Vec`"><code>Vec</code></a>, this means the items will be yielded in increasing order of index starting at 0. For ordered collections like <a href="struct.btreemap" title="`BTreeMap`"><code>BTreeMap</code></a>, this means that the items will be yielded in sorted order. For unordered collections like <a href="struct.hashmap" title="`HashMap`"><code>HashMap</code></a>, the items will be yielded in whatever order the internal representation made most convenient. This is great for reading through all the contents of the collection.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let vec = vec![1, 2, 3, 4];
for x in vec.iter() {
   println!("vec contained {}", x);
}</pre></div> <p><code>iter_mut</code> provides an iterator of <em>mutable</em> references in the same order as <code>iter</code>. This is great for mutating all the contents of the collection.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut vec = vec![1, 2, 3, 4];
for x in vec.iter_mut() {
   *x += 1;
}</pre></div> <p><code>into_iter</code> transforms the actual collection into an iterator over its contents by-value. This is great when the collection itself is no longer needed, and the values are needed elsewhere. Using <code>extend</code> with <code>into_iter</code> is the main way that contents of one collection are moved into another. <code>extend</code> automatically calls <code>into_iter</code>, and takes any <code>T: </code><a href="../iter/trait.intoiterator"><code>IntoIterator</code></a>. Calling <code>collect</code> on an iterator itself is also a great way to convert one collection into another. Both of these methods should internally use the capacity management tools discussed in the previous section to do this as efficiently as possible.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut vec1 = vec![1, 2, 3, 4];
let vec2 = vec![10, 20, 30, 40];
vec1.extend(vec2);</pre></div> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::VecDeque;

let vec = vec![1, 2, 3, 4];
let buf: VecDeque&lt;_&gt; = vec.into_iter().collect();</pre></div> <p>Iterators also provide a series of <em>adapter</em> methods for performing common threads to sequences. Among the adapters are functional favorites like <code>map</code>, <code>fold</code>, <code>skip</code> and <code>take</code>. Of particular interest to collections is the <code>rev</code> adapter, that reverses any iterator that supports this operation. Most collections provide reversible iterators as the way to iterate over them in reverse order.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let vec = vec![1, 2, 3, 4];
for x in vec.iter().rev() {
   println!("vec contained {}", x);
}</pre></div> <p>Several other collection methods also return iterators to yield a sequence of results but avoid allocating an entire collection to store the result in. This provides maximum flexibility as <code>collect</code> or <code>extend</code> can be called to "pipe" the sequence into any collection if desired. Otherwise, the sequence can be looped over with a <code>for</code> loop. The iterator can also be discarded after partial use, preventing the computation of the unused items.</p> <h3 id="entries" class="section-header">Entries</h3> <p>The <code>entry</code> API is intended to provide an efficient mechanism for manipulating the contents of a map conditionally on the presence of a key or not. The primary motivating use case for this is to provide efficient accumulator maps. For instance, if one wishes to maintain a count of the number of times each key has been seen, they will have to perform some conditional logic on whether this is the first time the key has been seen or not. Normally, this would require a <code>find</code> followed by an <code>insert</code>, effectively duplicating the search effort on each insertion.</p> <p>When a user calls <code>map.entry(&amp;key)</code>, the map will search for the key and then yield a variant of the <code>Entry</code> enum.</p> <p>If a <code>Vacant(entry)</code> is yielded, then the key <em>was not</em> found. In this case the only valid operation is to <code>insert</code> a value into the entry. When this is done, the vacant entry is consumed and converted into a mutable reference to the value that was inserted. This allows for further manipulation of the value beyond the lifetime of the search itself. This is useful if complex logic needs to be performed on the value regardless of whether the value was just inserted.</p> <p>If an <code>Occupied(entry)</code> is yielded, then the key <em>was</em> found. In this case, the user has several options: they can <code>get</code>, <code>insert</code> or <code>remove</code> the value of the occupied entry. Additionally, they can convert the occupied entry into a mutable reference to its value, providing symmetry to the vacant <code>insert</code> case.</p> <h3 id="examples" class="section-header">Examples</h3> <p>Here are the two primary ways in which <code>entry</code> is used. First, a simple example where the logic performed on the values is trivial.</p> <h4 id="counting-the-number-of-times-each-character-in-a-string-occurs" class="section-header">Counting the number of times each character in a string occurs</h4> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::btree_map::BTreeMap;

let mut count = BTreeMap::new();
let message = "she sells sea shells by the sea shore";

for c in message.chars() {
    *count.entry(c).or_insert(0) += 1;
}

assert_eq!(count.get(&amp;'s'), Some(&amp;8));

println!("Number of occurrences of each character");
for (char, count) in &amp;count {
    println!("{}: {}", char, count);
}</pre></div> <p>When the logic to be performed on the value is more complex, we may simply use the <code>entry</code> API to ensure that the value is initialized and perform the logic afterwards.</p> <h4 id="tracking-the-inebriation-of-customers-at-a-bar" class="section-header">Tracking the inebriation of customers at a bar</h4> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::collections::btree_map::BTreeMap;

// A client of the bar. They have a blood alcohol level.
struct Person { blood_alcohol: f32 }

// All the orders made to the bar, by client ID.
let orders = vec![1, 2, 1, 2, 3, 4, 1, 2, 2, 3, 4, 1, 1, 1];

// Our clients.
let mut blood_alcohol = BTreeMap::new();

for id in orders {
    // If this is the first time we've seen this customer, initialize them
    // with no blood alcohol. Otherwise, just retrieve them.
    let person = blood_alcohol.entry(id).or_insert(Person { blood_alcohol: 0.0 });

    // Reduce their blood alcohol level. It takes time to order and drink a beer!
    person.blood_alcohol *= 0.9;

    // Check if they're sober enough to have another beer.
    if person.blood_alcohol &gt; 0.3 {
        // Too drunk... for now.
        println!("Sorry {}, I have to cut you off", id);
    } else {
        // Have another!
        person.blood_alcohol += 0.1;
    }
}</pre></div> <h2 id="insert-and-complex-keys" class="section-header">Insert and complex keys</h2> <p>If we have a more complex key, calls to <code>insert</code> will not update the value of the key. For example:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::cmp::Ordering;
use std::collections::BTreeMap;
use std::hash::{Hash, Hasher};

#[derive(Debug)]
struct Foo {
    a: u32,
    b: &amp;'static str,
}

// we will compare `Foo`s by their `a` value only.
impl PartialEq for Foo {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool { self.a == other.a }
}

impl Eq for Foo {}

// we will hash `Foo`s by their `a` value only.
impl Hash for Foo {
    fn hash&lt;H: Hasher&gt;(&amp;self, h: &amp;mut H) { self.a.hash(h); }
}

impl PartialOrd for Foo {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; { self.a.partial_cmp(&amp;other.a) }
}

impl Ord for Foo {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering { self.a.cmp(&amp;other.a) }
}

let mut map = BTreeMap::new();
map.insert(Foo { a: 1, b: "baz" }, 99);

// We already have a Foo with an a of 1, so this will be updating the value.
map.insert(Foo { a: 1, b: "xyz" }, 100);

// The value has been updated...
assert_eq!(map.values().next().unwrap(), &amp;100);

// ...but the key hasn't changed. b is still "baz", not "xyz".
assert_eq!(map.keys().next().unwrap().b, "baz");</pre></div> <h3 id="modules" class="section-header">Modules</h3> <table>
<tr class="module-item">
<td><a class="mod" href="binary_heap/index" title="std::collections::binary_heap mod">binary_heap</a></td>
<td class="docblock-short">
<p>A priority queue implemented with a binary heap.</p> </td>
</tr>
<tr class="module-item">
<td><a class="mod" href="btree_map/index" title="std::collections::btree_map mod">btree_map</a></td>
<td class="docblock-short">
<p>A map based on a B-Tree.</p> </td>
</tr>
<tr class="module-item">
<td><a class="mod" href="btree_set/index" title="std::collections::btree_set mod">btree_set</a></td>
<td class="docblock-short">
<p>A set based on a B-Tree.</p> </td>
</tr>
<tr class="module-item">
<td><a class="mod" href="hash_map/index" title="std::collections::hash_map mod">hash_map</a></td>
<td class="docblock-short">
<p>A hash map implemented with quadratic probing and SIMD lookup.</p> </td>
</tr>
<tr class="module-item">
<td><a class="mod" href="hash_set/index" title="std::collections::hash_set mod">hash_set</a></td>
<td class="docblock-short">
<p>A hash set implemented as a <code>HashMap</code> where the value is <code>()</code>.</p> </td>
</tr>
<tr class="module-item">
<td><a class="mod" href="linked_list/index" title="std::collections::linked_list mod">linked_list</a></td>
<td class="docblock-short">
<p>A doubly-linked list with owned nodes.</p> </td>
</tr>
<tr class="module-item">
<td><a class="mod" href="vec_deque/index" title="std::collections::vec_deque mod">vec_deque</a></td>
<td class="docblock-short">
<p>A double-ended queue implemented with a growable ring buffer.</p> </td>
</tr>
</table>
<h3 id="structs" class="section-header">Structs</h3> <table>
<tr class="module-item">
<td><a class="struct" href="struct.btreemap" title="std::collections::BTreeMap struct">BTreeMap</a></td>
<td class="docblock-short">
<p>A map based on a B-Tree.</p> </td>
</tr>
<tr class="module-item">
<td><a class="struct" href="struct.btreeset" title="std::collections::BTreeSet struct">BTreeSet</a></td>
<td class="docblock-short">
<p>A set based on a B-Tree.</p> </td>
</tr>
<tr class="module-item">
<td><a class="struct" href="struct.binaryheap" title="std::collections::BinaryHeap struct">BinaryHeap</a></td>
<td class="docblock-short">
<p>A priority queue implemented with a binary heap.</p> </td>
</tr>
<tr class="module-item">
<td><a class="struct" href="struct.hashmap" title="std::collections::HashMap struct">HashMap</a></td>
<td class="docblock-short">
<p>A hash map implemented with quadratic probing and SIMD lookup.</p> </td>
</tr>
<tr class="module-item">
<td><a class="struct" href="struct.hashset" title="std::collections::HashSet struct">HashSet</a></td>
<td class="docblock-short">
<p>A hash set implemented as a <code>HashMap</code> where the value is <code>()</code>.</p> </td>
</tr>
<tr class="module-item">
<td><a class="struct" href="struct.linkedlist" title="std::collections::LinkedList struct">LinkedList</a></td>
<td class="docblock-short">
<p>A doubly-linked list with owned nodes.</p> </td>
</tr>
<tr class="module-item">
<td><a class="struct" href="struct.vecdeque" title="std::collections::VecDeque struct">VecDeque</a></td>
<td class="docblock-short">
<p>A double-ended queue implemented with a growable ring buffer.</p> </td>
</tr>
</table>
<h3 id="enums" class="section-header">Enums</h3> <table><tr class="unstable module-item">
<td><a class="enum" href="enum.tryreserveerror" title="std::collections::TryReserveError enum">TryReserveError</a></td>
<td class="docblock-short">
<span class="stab unstable">Experimental</span><p>The error type for <code>try_reserve</code> methods.</p> </td>
</tr></table>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/collections/index.html" class="_attribution-link">https://doc.rust-lang.org/std/collections/index.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
