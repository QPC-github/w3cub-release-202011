
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>std&#58;&#58;string&#58;&#58;String - Rust - W3cubDocs</title>
  
  <meta name="description" content=" A UTF-8 encoded, growable string. ">
  <meta name="keywords" content="struct, std, string, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/rust/std/string/struct.string.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/rust.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rust">
				
				
<h1 class="fqn">Struct std::string::String</h1>
<pre class="rust struct" data-language="rust">pub struct String { /* fields omitted */ }</pre>
<p>A UTF-8 encoded, growable string.</p> <p>The <code>String</code> type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive <a href="../primitive.str"><code>str</code></a>.</p> <h2 id="examples" class="section-header">Examples</h2> <p>You can create a <code>String</code> from <a href="../primitive.str">a literal string</a> with <a href="../convert/trait.from#tymethod.from"><code>String::from</code></a>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let hello = String::from("Hello, world!");</pre></div> <p>You can append a <a href="../primitive.char" title="`char`"><code>char</code></a> to a <code>String</code> with the <a href="struct.string#method.push"><code>push</code></a> method, and append a <a href="../primitive.str"><code>&amp;str</code></a> with the <a href="struct.string#method.push_str"><code>push_str</code></a> method:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut hello = String::from("Hello, ");

hello.push('w');
hello.push_str("orld!");</pre></div> <p>If you have a vector of UTF-8 bytes, you can create a <code>String</code> from it with the <a href="struct.string#method.from_utf8"><code>from_utf8</code></a> method:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// some bytes, in a vector
let sparkle_heart = vec![240, 159, 146, 150];

// We know these bytes are valid, so we'll use `unwrap()`.
let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();

assert_eq!("💖", sparkle_heart);</pre></div> <h2 id="utf-8" class="section-header">UTF-8</h2> <p><code>String</code>s are always valid UTF-8. This has a few implications, the first of which is that if you need a non-UTF-8 string, consider <a href="../ffi/struct.osstring"><code>OsString</code></a>. It is similar, but without the UTF-8 constraint. The second implication is that you cannot index into a <code>String</code>:</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
let s = "hello";

println!("The first letter of s is {}", s[0]); // ERROR!!!</pre></div> <p>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The <a href="../primitive.str#method.bytes"><code>bytes</code></a> and <a href="../primitive.str#method.chars"><code>chars</code></a> methods return iterators over the first two, respectively.</p> <h2 id="deref" class="section-header">Deref</h2> <p><code>String</code>s implement <a href="../ops/trait.deref"><code>Deref</code></a><code>&lt;Target=str&gt;</code>, and so inherit all of <a href="../primitive.str"><code>str</code></a>'s methods. In addition, this means that you can pass a <code>String</code> to a function which takes a <a href="../primitive.str"><code>&amp;str</code></a> by using an ampersand (<code>&amp;</code>):</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
fn takes_str(s: &amp;str) { }

let s = String::from("Hello");

takes_str(&amp;s);</pre></div> <p>This will create a <a href="../primitive.str"><code>&amp;str</code></a> from the <code>String</code> and pass it in. This conversion is very inexpensive, and so generally, functions will accept <a href="../primitive.str"><code>&amp;str</code></a>s as arguments unless they need a <code>String</code> for some specific reason.</p> <p>In certain cases Rust doesn't have enough information to make this conversion, known as <a href="../ops/trait.deref"><code>Deref</code></a> coercion. In the following example a string slice <a href="../primitive.str"><code>&amp;'a str</code></a> implements the trait <code>TraitExample</code>, and the function <code>example_func</code> takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn't have the means to do. For that reason, the following example will not compile.</p> <div class="information">ⓘThis example deliberately fails to compile</div>
<div class="example-wrap"><pre class="rust rust-example-rendered compile_fail" data-language="rust">
trait TraitExample {}

impl&lt;'a&gt; TraitExample for &amp;'a str {}

fn example_func&lt;A: TraitExample&gt;(example_arg: A) {}

let example_string = String::from("example_string");
example_func(&amp;example_string);</pre></div> <p>There are two options that would work instead. The first would be to change the line <code>example_func(&amp;example_string);</code> to <code>example_func(example_string.as_str());</code>, using the method <a href="struct.string#method.as_str"><code>as_str()</code></a> to explicitly extract the string slice containing the string. The second way changes <code>example_func(&amp;example_string);</code> to <code>example_func(&amp;*example_string);</code>. In this case we are dereferencing a <code>String</code> to a <a href="../primitive.str"><code>str</code></a>, then referencing the <a href="../primitive.str"><code>str</code></a> back to <a href="../primitive.str"><code>&amp;str</code></a>. The second way is more idiomatic, however both work to do the conversion explicitly rather than relying on the implicit conversion.</p> <h2 id="representation" class="section-header">Representation</h2> <p>A <code>String</code> is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer <code>String</code> uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.</p> <p>This buffer is always stored on the heap.</p> <p>You can look at these with the <a href="../primitive.str#method.as_ptr"><code>as_ptr</code></a>, <a href="struct.string#method.len"><code>len</code></a>, and <a href="struct.string#method.capacity"><code>capacity</code></a> methods:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::mem;

let story = String::from("Once upon a time...");

// Prevent automatically dropping the String's data
let mut story = mem::ManuallyDrop::new(story);

let ptr = story.as_mut_ptr();
let len = story.len();
let capacity = story.capacity();

// story has nineteen bytes
assert_eq!(19, len);

// We can re-build a String out of ptr, len, and capacity. This is all
// unsafe because we are responsible for making sure the components are
// valid:
let s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;

assert_eq!(String::from("Once upon a time..."), s);</pre></div> <p>If a <code>String</code> has enough capacity, adding elements to it will not re-allocate. For example, consider this program:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::new();

println!("{}", s.capacity());

for _ in 0..5 {
    s.push_str("hello");
    println!("{}", s.capacity());
}</pre></div> <p>This will output the following:</p> <pre>0
5
10
20
20
40
</pre> <p>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the <a href="struct.string#method.with_capacity"><code>with_capacity</code></a> method to allocate the correct capacity initially:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::with_capacity(25);

println!("{}", s.capacity());

for _ in 0..5 {
    s.push_str("hello");
    println!("{}", s.capacity());
}</pre></div> <p>We end up with a different output:</p> <pre>25
25
25
25
25
25
</pre> <p>Here, there's no need to allocate more memory inside the loop.</p> <h2 id="implementations" class="small-section-header">Implementations</h2>
<h3 id="impl" class="impl">
<code class="in-band">impl <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#342-1596" title="goto source code">[src]</a>
</h3>
<h4 id="method.new" class="method">
<code>pub const fn <a href="#method.new" class="fnname">new</a>() -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#364-366" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Creates a new empty <code>String</code>.</p> <p>Given that the <code>String</code> is empty, this will not allocate any initial buffer. While that means that this initial operation is very inexpensive, it may cause excessive allocation later when you add data. If you have an idea of how much data the <code>String</code> will hold, consider the <a href="struct.string#method.with_capacity"><code>with_capacity</code></a> method to prevent excessive re-allocation.</p> <h2 id="examples-1" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = String::new();</pre></div> </div>
<h4 id="method.with_capacity" class="method">
<code>pub fn <a href="#method.with_capacity" class="fnname">with_capacity</a>(capacity: <a class="primitive" href="../primitive.usize">usize</a>) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#407-409" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Creates a new empty <code>String</code> with a particular capacity.</p> <p><code>String</code>s have an internal buffer to hold their data. The capacity is the length of that buffer, and can be queried with the <a href="struct.string#method.capacity"><code>capacity</code></a> method. This method creates an empty <code>String</code>, but one with an initial buffer that can hold <code>capacity</code> bytes. This is useful when you may be appending a bunch of data to the <code>String</code>, reducing the number of reallocations it needs to do.</p> <p>If the given capacity is <code>0</code>, no allocation will occur, and this method is identical to the <a href="struct.string#method.new"><code>new</code></a> method.</p> <h2 id="examples-2" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::with_capacity(10);

// The String contains no chars, even though it has capacity for more
assert_eq!(s.len(), 0);

// These are all done without reallocating...
let cap = s.capacity();
for _ in 0..10 {
    s.push('a');
}

assert_eq!(s.capacity(), cap);

// ...but this may make the string reallocate
s.push('a');</pre></div> </div>
<h4 id="method.from_utf8" class="method">
<code>pub fn <a href="#method.from_utf8" class="fnname">from_utf8</a>(vec: <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>, <a class="struct" href="struct.fromutf8error" title="struct std::string::FromUtf8Error">FromUtf8Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#479-484" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts a vector of bytes to a <code>String</code>.</p> <p>A string (<a href="struct.string" title="`String`"><code>String</code></a>) is made of bytes (<a href="../primitive.u8" title="`u8`"><code>u8</code></a>), and a vector of bytes (<a href="../vec/struct.vec"><code>Vec&lt;u8&gt;</code></a>) is made of bytes, so this function converts between the two. Not all byte slices are valid <code>String</code>s, however: <code>String</code> requires that it is valid UTF-8. <code>from_utf8()</code> checks to ensure that the bytes are valid UTF-8, and then does the conversion.</p> <p>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, <a href="struct.string#method.from_utf8_unchecked"><code>from_utf8_unchecked</code></a>, which has the same behavior but skips the check.</p> <p>This method will take care to not copy the vector, for efficiency's sake.</p> <p>If you need a <a href="../primitive.str"><code>&amp;str</code></a> instead of a <code>String</code>, consider <a href="../str/fn.from_utf8" title="`str::from_utf8`"><code>str::from_utf8</code></a>.</p> <p>The inverse of this method is <a href="struct.string#method.into_bytes"><code>into_bytes</code></a>.</p> <h2 id="errors" class="section-header">Errors</h2> <p>Returns <a href="../result/enum.result#variant.Err" title="`Err`"><code>Err</code></a> if the slice is not UTF-8 with a description as to why the provided bytes are not UTF-8. The vector you moved in is also included.</p> <h2 id="examples-3" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// some bytes, in a vector
let sparkle_heart = vec![240, 159, 146, 150];

// We know these bytes are valid, so we'll use `unwrap()`.
let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();

assert_eq!("💖", sparkle_heart);</pre></div> <p>Incorrect bytes:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// some invalid bytes, in a vector
let sparkle_heart = vec![0, 159, 146, 150];

assert!(String::from_utf8(sparkle_heart).is_err());</pre></div> <p>See the docs for <a href="struct.fromutf8error" title="`FromUtf8Error`"><code>FromUtf8Error</code></a> for more details on what you can do with this error.</p> </div>
<h4 id="method.from_utf8_lossy" class="method">
<code>pub fn <a href="#method.from_utf8_lossy" class="fnname">from_utf8_lossy</a>(v: <a class="primitive" href="../primitive.slice">&amp;[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'_, <a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#536-566" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts a slice of bytes to a string, including invalid characters.</p> <p>Strings are made of bytes (<a href="../primitive.u8" title="`u8`"><code>u8</code></a>), and a slice of bytes (<a href="../primitive.slice"><code>&amp;[u8]</code></a>) is made of bytes, so this function converts between the two. Not all byte slices are valid strings, however: strings are required to be valid UTF-8. During this conversion, <code>from_utf8_lossy()</code> will replace any invalid UTF-8 sequences with <a href="../char/constant.replacement_character"><code>U+FFFD REPLACEMENT CHARACTER</code></a>, which looks like this: �</p> <p>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the conversion, there is an unsafe version of this function, <a href="struct.string#method.from_utf8_unchecked"><code>from_utf8_unchecked</code></a>, which has the same behavior but skips the checks.</p> <p>This function returns a <a href="../borrow/enum.cow"><code>Cow&lt;'a, str&gt;</code></a>. If our byte slice is invalid UTF-8, then we need to insert the replacement characters, which will change the size of the string, and hence, require a <code>String</code>. But if it's already valid UTF-8, we don't need a new allocation. This return type allows us to handle both cases.</p> <h2 id="examples-4" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// some bytes, in a vector
let sparkle_heart = vec![240, 159, 146, 150];

let sparkle_heart = String::from_utf8_lossy(&amp;sparkle_heart);

assert_eq!("💖", sparkle_heart);</pre></div> <p>Incorrect bytes:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// some invalid bytes
let input = b"Hello \xF0\x90\x80World";
let output = String::from_utf8_lossy(input);

assert_eq!("Hello �World", output);</pre></div> </div>
<h4 id="method.from_utf16" class="method">
<code>pub fn <a href="#method.from_utf16" class="fnname">from_utf16</a>(v: <a class="primitive" href="../primitive.slice">&amp;[</a><a class="primitive" href="../primitive.u16">u16</a><a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>, <a class="struct" href="struct.fromutf16error" title="struct std::string::FromUtf16Error">FromUtf16Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#588-600" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Decode a UTF-16 encoded vector <code>v</code> into a <code>String</code>, returning <a href="../result/enum.result#variant.Err" title="`Err`"><code>Err</code></a> if <code>v</code> contains any invalid data.</p> <h2 id="examples-5" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// 𝄞music
let v = &amp;[0xD834, 0xDD1E, 0x006d, 0x0075,
          0x0073, 0x0069, 0x0063];
assert_eq!(String::from("𝄞music"),
           String::from_utf16(v).unwrap());

// 𝄞mu&lt;invalid&gt;ic
let v = &amp;[0xD834, 0xDD1E, 0x006d, 0x0075,
          0xD800, 0x0069, 0x0063];
assert!(String::from_utf16(v).is_err());</pre></div> </div>
<h4 id="method.from_utf16_lossy" class="method">
<code>pub fn <a href="#method.from_utf16_lossy" class="fnname">from_utf16_lossy</a>(v: <a class="primitive" href="../primitive.slice">&amp;[</a><a class="primitive" href="../primitive.u16">u16</a><a class="primitive" href="../primitive.slice">]</a>) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#628-630" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Decode a UTF-16 encoded slice <code>v</code> into a <code>String</code>, replacing invalid data with <a href="../char/constant.replacement_character">the replacement character (<code>U+FFFD</code>)</a>.</p> <p>Unlike <a href="struct.string#method.from_utf8_lossy"><code>from_utf8_lossy</code></a> which returns a <a href="../borrow/enum.cow"><code>Cow&lt;'a, str&gt;</code></a>, <code>from_utf16_lossy</code> returns a <code>String</code> since the UTF-16 to UTF-8 conversion requires a memory allocation.</p> <h2 id="examples-6" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// 𝄞mus&lt;invalid&gt;ic&lt;invalid&gt;
let v = &amp;[0xD834, 0xDD1E, 0x006d, 0x0075,
          0x0073, 0xDD1E, 0x0069, 0x0063,
          0xD834];

assert_eq!(String::from("𝄞mus\u{FFFD}ic\u{FFFD}"),
           String::from_utf16_lossy(v));</pre></div> </div>
<h4 id="method.into_raw_parts" class="method">
<code>pub fn <a href="#method.into_raw_parts" class="fnname">into_raw_parts</a>(self) -&gt; <a class="primitive" href="../primitive.tuple">(</a><a class="primitive" href="../primitive.pointer">*mut </a><a class="primitive" href="../primitive.u8">u8</a>, <a class="primitive" href="../primitive.usize">usize</a>, <a class="primitive" href="../primitive.usize">usize</a><a class="primitive" href="../primitive.tuple">)</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#659-661" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (vec_into_raw_parts #65816)new API </span></div>
<div class="docblock">
<p>Decomposes a <code>String</code> into its raw components.</p> <p>Returns the raw pointer to the underlying data, the length of the string (in bytes), and the allocated capacity of the data (in bytes). These are the same arguments in the same order as the arguments to <a href="struct.string#method.from_raw_parts"><code>from_raw_parts</code></a>.</p> <p>After calling this function, the caller is responsible for the memory previously managed by the <code>String</code>. The only way to do this is to convert the raw pointer, length, and capacity back into a <code>String</code> with the <a href="struct.string#method.from_raw_parts"><code>from_raw_parts</code></a> function, allowing the destructor to perform the cleanup.</p> <h2 id="examples-7" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(vec_into_raw_parts)]
let s = String::from("hello");

let (ptr, len, cap) = s.into_raw_parts();

let rebuilt = unsafe { String::from_raw_parts(ptr, len, cap) };
assert_eq!(rebuilt, "hello");</pre></div> </div>
<h4 id="method.from_raw_parts" class="method">
<code>pub unsafe fn <a href="#method.from_raw_parts" class="fnname">from_raw_parts</a>(<br>    buf: <a class="primitive" href="../primitive.pointer">*mut </a><a class="primitive" href="../primitive.u8">u8</a>, <br>    length: <a class="primitive" href="../primitive.usize">usize</a>, <br>    capacity: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#710-712" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Creates a new <code>String</code> from a length, capacity, and pointer.</p> <h2 id="safety" class="section-header">Safety</h2> <p>This is highly unsafe, due to the number of invariants that aren't checked:</p> <ul> <li>The memory at <code>buf</code> needs to have been previously allocated by the same allocator the standard library uses, with a required alignment of exactly 1.</li> <li>
<code>length</code> needs to be less than or equal to <code>capacity</code>.</li> <li>
<code>capacity</code> needs to be the correct value.</li> <li>The first <code>length</code> bytes at <code>buf</code> need to be valid UTF-8.</li> </ul> <p>Violating these may cause problems like corrupting the allocator's internal data structures.</p> <p>The ownership of <code>buf</code> is effectively transferred to the <code>String</code> which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</p> <h2 id="examples-8" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::mem;

unsafe {
    let s = String::from("hello");

    // Prevent automatically dropping the String's data
    let mut s = mem::ManuallyDrop::new(s);

    let ptr = s.as_mut_ptr();
    let len = s.len();
    let capacity = s.capacity();

    let s = String::from_raw_parts(ptr, len, capacity);

    assert_eq!(String::from("hello"), s);
}</pre></div> </div>
<h4 id="method.from_utf8_unchecked" class="method">
<code>pub unsafe fn <a href="#method.from_utf8_unchecked" class="fnname">from_utf8_unchecked</a>(bytes: <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#744-746" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts a vector of bytes to a <code>String</code> without checking that the string contains valid UTF-8.</p> <p>See the safe version, <a href="struct.string#method.from_utf8"><code>from_utf8</code></a>, for more details.</p> <h2 id="safety-1" class="section-header">Safety</h2> <p>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, it may cause memory unsafety issues with future users of the <code>String</code>, as the rest of the standard library assumes that <code>String</code>s are valid UTF-8.</p> <h2 id="examples-9" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
// some bytes, in a vector
let sparkle_heart = vec![240, 159, 146, 150];

let sparkle_heart = unsafe {
    String::from_utf8_unchecked(sparkle_heart)
};

assert_eq!("💖", sparkle_heart);</pre></div> </div>
<h4 id="method.into_bytes" class="method">
<code>pub fn <a href="#method.into_bytes" class="fnname">into_bytes</a>(self) -&gt; <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#764-766" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts a <code>String</code> into a byte vector.</p> <p>This consumes the <code>String</code>, so we do not need to copy its contents.</p> <h2 id="examples-10" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = String::from("hello");
let bytes = s.into_bytes();

assert_eq!(&amp;[104, 101, 108, 108, 111][..], &amp;bytes[..]);</pre></div> </div>
<h4 id="method.as_str" class="method">
<code>pub fn <a href="#method.as_str" class="fnname">as_str</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#781-783" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.7.0">1.7.0</span>
</h4>
<div class="docblock">
<p>Extracts a string slice containing the entire <code>String</code>.</p> <h2 id="examples-11" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = String::from("foo");

assert_eq!("foo", s.as_str());</pre></div> </div>
<h4 id="method.as_mut_str" class="method">
<code>pub fn <a href="#method.as_mut_str" class="fnname">as_mut_str</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#801-803" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.7.0">1.7.0</span>
</h4>
<div class="docblock">
<p>Converts a <code>String</code> into a mutable string slice.</p> <h2 id="examples-12" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("foobar");
let s_mut_str = s.as_mut_str();

s_mut_str.make_ascii_uppercase();

assert_eq!("FOOBAR", s_mut_str);</pre></div> </div>
<h4 id="method.push_str" class="method">
<code>pub fn <a href="#method.push_str" class="fnname">push_str</a>(&amp;mut self, string: &amp;<a class="primitive" href="../primitive.str">str</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#820-822" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Appends a given string slice onto the end of this <code>String</code>.</p> <h2 id="examples-13" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("foo");

s.push_str("bar");

assert_eq!("foobar", s);</pre></div> </div>
<h4 id="method.capacity" class="method">
<code>pub fn <a href="#method.capacity" class="fnname">capacity</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.usize">usize</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#837-839" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns this <code>String</code>'s capacity, in bytes.</p> <h2 id="examples-14" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = String::with_capacity(10);

assert!(s.capacity() &gt;= 10);</pre></div> </div>
<h4 id="method.reserve" class="method">
<code>pub fn <a href="#method.reserve" class="fnname">reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#887-889" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Ensures that this <code>String</code>'s capacity is at least <code>additional</code> bytes larger than its length.</p> <p>The capacity may be increased by more than <code>additional</code> bytes if it chooses, to prevent frequent reallocations.</p> <p>If you do not want this "at least" behavior, see the <a href="struct.string#method.reserve_exact"><code>reserve_exact</code></a> method.</p> <h2 id="panics" class="section-header">Panics</h2> <p>Panics if the new capacity overflows <a href="../primitive.usize" title="`usize`"><code>usize</code></a>.</p> <h2 id="examples-15" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::new();

s.reserve(10);

assert!(s.capacity() &gt;= 10);</pre></div> <p>This may not actually increase the capacity:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::with_capacity(10);
s.push('a');
s.push('b');

// s now has a length of 2 and a capacity of 10
assert_eq!(2, s.len());
assert_eq!(10, s.capacity());

// Since we already have an extra 8 capacity, calling this...
s.reserve(8);

// ... doesn't actually increase.
assert_eq!(10, s.capacity());</pre></div> </div>
<h4 id="method.reserve_exact" class="method">
<code>pub fn <a href="#method.reserve_exact" class="fnname">reserve_exact</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#934-936" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Ensures that this <code>String</code>'s capacity is <code>additional</code> bytes larger than its length.</p> <p>Consider using the <a href="struct.string#method.reserve"><code>reserve</code></a> method unless you absolutely know better than the allocator.</p> <h2 id="panics-1" class="section-header">Panics</h2> <p>Panics if the new capacity overflows <code>usize</code>.</p> <h2 id="examples-16" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::new();

s.reserve_exact(10);

assert!(s.capacity() &gt;= 10);</pre></div> <p>This may not actually increase the capacity:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::with_capacity(10);
s.push('a');
s.push('b');

// s now has a length of 2 and a capacity of 10
assert_eq!(2, s.len());
assert_eq!(10, s.capacity());

// Since we already have an extra 8 capacity, calling this...
s.reserve_exact(8);

// ... doesn't actually increase.
assert_eq!(10, s.capacity());</pre></div> </div>
<h4 id="method.try_reserve" class="method">
<code>pub fn <a href="#method.try_reserve" class="fnname">try_reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize">usize</a>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>, <a class="enum" href="../collections/enum.tryreserveerror" title="enum std::collections::TryReserveError">TryReserveError</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#969-971" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (try_reserve #48043)new API </span></div>
<div class="docblock">
<p>Tries to reserve capacity for at least <code>additional</code> more elements to be inserted in the given <code>String</code>. The collection may reserve more space to avoid frequent reallocations. After calling <code>reserve</code>, capacity will be greater than or equal to <code>self.len() + additional</code>. Does nothing if capacity is already sufficient.</p> <h2 id="errors-1" class="section-header">Errors</h2> <p>If the capacity overflows, or the allocator reports a failure, then an error is returned.</p> <h2 id="examples-17" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(try_reserve)]
use std::collections::TryReserveError;

fn process_data(data: &amp;str) -&gt; Result&lt;String, TryReserveError&gt; {
    let mut output = String::new();

    // Pre-reserve the memory, exiting if we can't
    output.try_reserve(data.len())?;

    // Now we know this can't OOM in the middle of our complex work
    output.push_str(data);

    Ok(output)
}</pre></div> </div>
<h4 id="method.try_reserve_exact" class="method">
<code>pub fn <a href="#method.try_reserve_exact" class="fnname">try_reserve_exact</a>(<br>    &amp;mut self, <br>    additional: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>, <a class="enum" href="../collections/enum.tryreserveerror" title="enum std::collections::TryReserveError">TryReserveError</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1007-1009" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (try_reserve #48043)new API </span></div>
<div class="docblock">
<p>Tries to reserves the minimum capacity for exactly <code>additional</code> more elements to be inserted in the given <code>String</code>. After calling <code>reserve_exact</code>, capacity will be greater than or equal to <code>self.len() + additional</code>. Does nothing if the capacity is already sufficient.</p> <p>Note that the allocator may give the collection more space than it requests. Therefore, capacity can not be relied upon to be precisely minimal. Prefer <code>reserve</code> if future insertions are expected.</p> <h2 id="errors-2" class="section-header">Errors</h2> <p>If the capacity overflows, or the allocator reports a failure, then an error is returned.</p> <h2 id="examples-18" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(try_reserve)]
use std::collections::TryReserveError;

fn process_data(data: &amp;str) -&gt; Result&lt;String, TryReserveError&gt; {
    let mut output = String::new();

    // Pre-reserve the memory, exiting if we can't
    output.try_reserve(data.len())?;

    // Now we know this can't OOM in the middle of our complex work
    output.push_str(data);

    Ok(output)
}</pre></div> </div>
<h4 id="method.shrink_to_fit" class="method">
<code>pub fn <a href="#method.shrink_to_fit" class="fnname">shrink_to_fit</a>(&amp;mut self)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1028-1030" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Shrinks the capacity of this <code>String</code> to match its length.</p> <h2 id="examples-19" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("foo");

s.reserve(100);
assert!(s.capacity() &gt;= 100);

s.shrink_to_fit();
assert_eq!(3, s.capacity());</pre></div> </div>
<h4 id="method.shrink_to" class="method">
<code>pub fn <a href="#method.shrink_to" class="fnname">shrink_to</a>(&amp;mut self, min_capacity: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1056-1058" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (shrink_to #56431)new API </span></div>
<div class="docblock">
<p>Shrinks the capacity of this <code>String</code> with a lower bound.</p> <p>The capacity will remain at least as large as both the length and the supplied value.</p> <p>Panics if the current capacity is smaller than the supplied minimum capacity.</p> <h2 id="examples-20" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(shrink_to)]
let mut s = String::from("foo");

s.reserve(100);
assert!(s.capacity() &gt;= 100);

s.shrink_to(10);
assert!(s.capacity() &gt;= 10);
s.shrink_to(0);
assert!(s.capacity() &gt;= 3);</pre></div> </div>
<h4 id="method.push" class="method">
<code>pub fn <a href="#method.push" class="fnname">push</a>(&amp;mut self, ch: <a class="primitive" href="../primitive.char">char</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1077-1082" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Appends the given <a href="../primitive.char" title="`char`"><code>char</code></a> to the end of this <code>String</code>.</p> <h2 id="examples-21" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("abc");

s.push('1');
s.push('2');
s.push('3');

assert_eq!("abc123", s);</pre></div> </div>
<h4 id="method.as_bytes" class="method">
<code>pub fn <a href="#method.as_bytes" class="fnname">as_bytes</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.slice">&amp;[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ [u8]</h3>
<pre class="content">impl&lt;'_&gt; Read for &amp;'_ [u8]
impl&lt;'_&gt; Write for &amp;'_ mut [u8]
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1101-1103" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns a byte slice of this <code>String</code>'s contents.</p> <p>The inverse of this method is <a href="struct.string#method.from_utf8"><code>from_utf8</code></a>.</p> <h2 id="examples-22" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = String::from("hello");

assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes());</pre></div> </div>
<h4 id="method.truncate" class="method">
<code>pub fn <a href="#method.truncate" class="fnname">truncate</a>(&amp;mut self, new_len: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1130-1135" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Shortens this <code>String</code> to the specified length.</p> <p>If <code>new_len</code> is greater than the string's current length, this has no effect.</p> <p>Note that this method has no effect on the allocated capacity of the string</p> <h2 id="panics-2" class="section-header">Panics</h2> <p>Panics if <code>new_len</code> does not lie on a <a href="../primitive.char" title="`char`"><code>char</code></a> boundary.</p> <h2 id="examples-23" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("hello");

s.truncate(2);

assert_eq!("he", s);</pre></div> </div>
<h4 id="method.pop" class="method">
<code>pub fn <a href="#method.pop" class="fnname">pop</a>(&amp;mut self) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="../primitive.char">char</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1156-1163" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Removes the last character from the string buffer and returns it.</p> <p>Returns <a href="../option/enum.option#variant.None" title="`None`"><code>None</code></a> if this <code>String</code> is empty.</p> <h2 id="examples-24" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("foo");

assert_eq!(s.pop(), Some('o'));
assert_eq!(s.pop(), Some('o'));
assert_eq!(s.pop(), Some('f'));

assert_eq!(s.pop(), None);</pre></div> </div>
<h4 id="method.remove" class="method">
<code>pub fn <a href="#method.remove" class="fnname">remove</a>(&amp;mut self, idx: <a class="primitive" href="../primitive.usize">usize</a>) -&gt; <a class="primitive" href="../primitive.char">char</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1188-1201" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Removes a <a href="../primitive.char" title="`char`"><code>char</code></a> from this <code>String</code> at a byte position and returns it.</p> <p>This is an <em>O</em>(<em>n</em>) operation, as it requires copying every element in the buffer.</p> <h2 id="panics-3" class="section-header">Panics</h2> <p>Panics if <code>idx</code> is larger than or equal to the <code>String</code>'s length, or if it does not lie on a <a href="../primitive.char" title="`char`"><code>char</code></a> boundary.</p> <h2 id="examples-25" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("foo");

assert_eq!(s.remove(0), 'f');
assert_eq!(s.remove(1), 'o');
assert_eq!(s.remove(0), 'o');</pre></div> </div>
<h4 id="method.retain" class="method">
<code>pub fn <a href="#method.retain" class="fnname">retain</a>&lt;F&gt;(&amp;mut self, f: F) <span class="where fmt-newline">where<br>    F: <a class="trait" href="../ops/trait.fnmut" title="trait std::ops::FnMut">FnMut</a>(<a class="primitive" href="../primitive.char">char</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1230-1263" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span>
</h4>
<div class="docblock">
<p>Retains only the characters specified by the predicate.</p> <p>In other words, remove all characters <code>c</code> such that <code>f(c)</code> returns <code>false</code>. This method operates in place, visiting each character exactly once in the original order, and preserves the order of the retained characters.</p> <h2 id="examples-26" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("f_o_ob_ar");

s.retain(|c| c != '_');

assert_eq!(s, "foobar");</pre></div> <p>The exact order may be useful for tracking external state, like an index.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("abcde");
let keep = [false, true, true, false, true];
let mut i = 0;
s.retain(|_| (keep[i], i += 1).0);
assert_eq!(s, "bce");</pre></div> </div>
<h4 id="method.insert" class="method">
<code>pub fn <a href="#method.insert" class="fnname">insert</a>(&amp;mut self, idx: <a class="primitive" href="../primitive.usize">usize</a>, ch: <a class="primitive" href="../primitive.char">char</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1290-1298" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Inserts a character into this <code>String</code> at a byte position.</p> <p>This is an <em>O</em>(<em>n</em>) operation as it requires copying every element in the buffer.</p> <h2 id="panics-4" class="section-header">Panics</h2> <p>Panics if <code>idx</code> is larger than the <code>String</code>'s length, or if it does not lie on a <a href="../primitive.char" title="`char`"><code>char</code></a> boundary.</p> <h2 id="examples-27" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::with_capacity(3);

s.insert(0, 'f');
s.insert(1, 'o');
s.insert(2, 'o');

assert_eq!("foo", s);</pre></div> </div>
<h4 id="method.insert_str" class="method">
<code>pub fn <a href="#method.insert_str" class="fnname">insert_str</a>(&amp;mut self, idx: <a class="primitive" href="../primitive.usize">usize</a>, string: &amp;<a class="primitive" href="../primitive.str">str</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1335-1341" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span>
</h4>
<div class="docblock">
<p>Inserts a string slice into this <code>String</code> at a byte position.</p> <p>This is an <em>O</em>(<em>n</em>) operation as it requires copying every element in the buffer.</p> <h2 id="panics-5" class="section-header">Panics</h2> <p>Panics if <code>idx</code> is larger than the <code>String</code>'s length, or if it does not lie on a <a href="../primitive.char" title="`char`"><code>char</code></a> boundary.</p> <h2 id="examples-28" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("bar");

s.insert_str(0, "foo");

assert_eq!("foobar", s);</pre></div> </div>
<h4 id="method.as_mut_vec" class="method">
<code>pub unsafe fn <a href="#method.as_mut_vec" class="fnname">as_mut_vec</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1369-1371" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns a mutable reference to the contents of this <code>String</code>.</p> <h2 id="safety-2" class="section-header">Safety</h2> <p>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, it may cause memory unsafety issues with future users of the <code>String</code>, as the rest of the standard library assumes that <code>String</code>s are valid UTF-8.</p> <h2 id="examples-29" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("hello");

unsafe {
    let vec = s.as_mut_vec();
    assert_eq!(&amp;[104, 101, 108, 108, 111][..], &amp;vec[..]);

    vec.reverse();
}
assert_eq!(s, "olleh");</pre></div> </div>
<h4 id="method.len" class="method">
<code>pub fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.usize">usize</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1391-1393" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns the length of this <code>String</code>, in bytes, not <a href="../primitive.char" title="`char`"><code>char</code></a>s or graphemes. In other words, it may not be what a human considers the length of the string.</p> <h2 id="examples-30" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let a = String::from("foo");
assert_eq!(a.len(), 3);

let fancy_f = String::from("ƒoo");
assert_eq!(fancy_f.len(), 4);
assert_eq!(fancy_f.chars().count(), 3);</pre></div> </div>
<h4 id="method.is_empty" class="method">
<code>pub fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1410-1412" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns <code>true</code> if this <code>String</code> has a length of zero, and <code>false</code> otherwise.</p> <h2 id="examples-31" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = String::new();
assert!(v.is_empty());

v.push('a');
assert!(!v.is_empty());</pre></div> </div>
<h4 id="method.split_off" class="method">
<code><span class="docblock attributes">#[must_use = "use `.truncate()` if you don't need the other half"]</span>pub fn <a href="#method.split_off" class="fnname">split_off</a>(&amp;mut self, at: <a class="primitive" href="../primitive.usize">usize</a>) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1440-1444" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span>
</h4>
<div class="docblock">
<p>Splits the string into two at the given index.</p> <p>Returns a newly allocated <code>String</code>. <code>self</code> contains bytes <code>[0, at)</code>, and the returned <code>String</code> contains bytes <code>[at, len)</code>. <code>at</code> must be on the boundary of a UTF-8 code point.</p> <p>Note that the capacity of <code>self</code> does not change.</p> <h2 id="panics-6" class="section-header">Panics</h2> <p>Panics if <code>at</code> is not on a <code>UTF-8</code> code point boundary, or if it is beyond the last code point of the string.</p> <h2 id="examples-32" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut hello = String::from("Hello, World!");
let world = hello.split_off(7);
assert_eq!(hello, "Hello, ");
assert_eq!(world, "World!");</pre></div> </div>
<h4 id="method.clear" class="method">
<code>pub fn <a href="#method.clear" class="fnname">clear</a>(&amp;mut self)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1466-1468" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Truncates this <code>String</code>, removing all contents.</p> <p>While this means the <code>String</code> will have a length of zero, it does not touch its capacity.</p> <h2 id="examples-33" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("foo");

s.clear();

assert!(s.is_empty());
assert_eq!(0, s.len());
assert_eq!(3, s.capacity());</pre></div> </div>
<h4 id="method.drain" class="method">
<code>pub fn <a href="#method.drain" class="fnname">drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; <a class="struct" href="struct.drain" title="struct std::string::Drain">Drain</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Drain&lt;'_&gt;</h3>
<pre class="content">impl&lt;'_&gt; Iterator for Drain&lt;'_&gt;
    type Item = char;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    R: <a class="trait" href="../ops/trait.rangebounds" title="trait std::ops::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1499-1528" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span>
</h4>
<div class="docblock">
<p>Creates a draining iterator that removes the specified range in the <code>String</code> and yields the removed <code>chars</code>.</p> <p>Note: The element range is removed even if the iterator is not consumed until the end.</p> <h2 id="panics-7" class="section-header">Panics</h2> <p>Panics if the starting point or end point do not lie on a <a href="../primitive.char" title="`char`"><code>char</code></a> boundary, or if they're out of bounds.</p> <h2 id="examples-34" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("α is alpha, β is beta");
let beta_offset = s.find('β').unwrap_or(s.len());

// Remove the range up until the β from the string
let t: String = s.drain(..beta_offset).collect();
assert_eq!(t, "α is alpha, ");
assert_eq!(s, "β is beta");

// A full range clears the string
s.drain(..);
assert_eq!(s, "");</pre></div> </div>
<h4 id="method.replace_range" class="method">
<code>pub fn <a href="#method.replace_range" class="fnname">replace_range</a>&lt;R&gt;(&amp;mut self, range: R, replace_with: &amp;<a class="primitive" href="../primitive.str">str</a>) <span class="where fmt-newline">where<br>    R: <a class="trait" href="../ops/trait.rangebounds" title="trait std::ops::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1552-1573" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span>
</h4>
<div class="docblock">
<p>Removes the specified range in the string, and replaces it with the given string. The given string doesn't need to be the same length as the range.</p> <h2 id="panics-8" class="section-header">Panics</h2> <p>Panics if the starting point or end point do not lie on a <a href="../primitive.char" title="`char`"><code>char</code></a> boundary, or if they're out of bounds.</p> <h2 id="examples-35" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("α is alpha, β is beta");
let beta_offset = s.find('β').unwrap_or(s.len());

// Replace the range up until the β from the string
s.replace_range(..beta_offset, "Α is capital alpha; ");
assert_eq!(s, "Α is capital alpha; β is beta");</pre></div> </div>
<h4 id="method.into_boxed_str" class="method">
<code>pub fn <a href="#method.into_boxed_str" class="fnname">into_boxed_str</a>(self) -&gt; <a class="struct" href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Box&lt;F&gt;</h3>
<pre class="content">impl&lt;F&gt; Future for Box&lt;F&gt; where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;I&gt; Iterator for Box&lt;I&gt; where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized&gt; Read for Box&lt;R&gt;
impl&lt;W: Write + ?Sized&gt; Write for Box&lt;W&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1592-1595" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span>
</h4>
<div class="docblock">
<p>Converts this <code>String</code> into a <a href="../boxed/struct.box" title="`Box`"><code>Box</code></a><code>&lt;</code><a href="../primitive.str"><code>str</code></a><code>&gt;</code>.</p> <p>This will drop any excess capacity.</p> <h2 id="examples-36" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = String::from("hello");

let b = s.into_boxed_str();</pre></div> </div>
<h2 id="deref-methods" class="small-section-header">Methods from Deref&lt;Target = str&gt;</h2>
<h4 id="method.len-1" class="method">
<code>pub const fn <a href="#method.len-1" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.usize">usize</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2291-2293" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns the length of <code>self</code>.</p> <p>This length is in bytes, not <a href="../primitive.char"><code>char</code></a>s or graphemes. In other words, it may not be what a human considers the length of the string.</p> <h2 id="examples-37" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let len = "foo".len();
assert_eq!(3, len);

assert_eq!("ƒoo".len(), 4); // fancy f!
assert_eq!("ƒoo".chars().count(), 3);</pre></div> </div>
<h4 id="method.is_empty-1" class="method">
<code>pub const fn <a href="#method.is_empty-1" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2311-2313" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p> <h2 id="examples-38" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "";
assert!(s.is_empty());

let s = "not empty";
assert!(!s.is_empty());</pre></div> </div>
<h4 id="method.is_char_boundary" class="method">
<code>pub fn <a href="#method.is_char_boundary" class="fnname">is_char_boundary</a>(&amp;self, index: <a class="primitive" href="../primitive.usize">usize</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2340-2352" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span>
</h4>
<div class="docblock">
<p>Checks that <code>index</code>-th byte is the first byte in a UTF-8 code point sequence or the end of the string.</p> <p>The start and end of the string (when <code>index == self.len()</code>) are considered to be boundaries.</p> <p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p> <h2 id="examples-39" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";
assert!(s.is_char_boundary(0));
// start of `老`
assert!(s.is_char_boundary(6));
assert!(s.is_char_boundary(s.len()));

// second byte of `ö`
assert!(!s.is_char_boundary(2));

// third byte of `老`
assert!(!s.is_char_boundary(8));</pre></div> </div>
<h4 id="method.as_bytes-1" class="method">
<code>pub const fn <a href="#method.as_bytes-1" class="fnname">as_bytes</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.slice">&amp;[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ [u8]</h3>
<pre class="content">impl&lt;'_&gt; Read for &amp;'_ [u8]
impl&lt;'_&gt; Write for &amp;'_ mut [u8]
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2370-2373" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts a string slice to a byte slice. To convert the byte slice back into a string slice, use the <a href="../str/fn.from_utf8" title="`from_utf8`"><code>from_utf8</code></a> function.</p> <h2 id="examples-40" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let bytes = "bors".as_bytes();
assert_eq!(b"bors", bytes);</pre></div> </div>
<h4 id="method.as_bytes_mut" class="method">
<code>pub unsafe fn <a href="#method.as_bytes_mut" class="fnname">as_bytes_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.slice">&amp;mut [</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ [u8]</h3>
<pre class="content">impl&lt;'_&gt; Read for &amp;'_ [u8]
impl&lt;'_&gt; Write for &amp;'_ mut [u8]
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2413-2419" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span>
</h4>
<div class="docblock">
<p>Converts a mutable string slice to a mutable byte slice.</p> <h2 id="safety-3" class="section-header">Safety</h2> <p>The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying <code>str</code> is used.</p> <p>Use of a <code>str</code> whose contents are not valid UTF-8 is undefined behavior.</p> <h2 id="examples-41" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("Hello");
let bytes = unsafe { s.as_bytes_mut() };

assert_eq!(b"Hello", bytes);</pre></div> <p>Mutability:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("🗻∈🌏");

unsafe {
    let bytes = s.as_bytes_mut();

    bytes[0] = 0xF0;
    bytes[1] = 0x9F;
    bytes[2] = 0x8D;
    bytes[3] = 0x94;
}

assert_eq!("🍔∈🌏", s);</pre></div> </div>
<h4 id="method.as_ptr" class="method">
<code>pub const fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.pointer">*const </a><a class="primitive" href="../primitive.u8">u8</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2443-2445" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts a string slice to a raw pointer.</p> <p>As string slices are a slice of bytes, the raw pointer points to a <a href="../primitive.u8" title="`u8`"><code>u8</code></a>. This pointer will be pointing to the first byte of the string slice.</p> <p>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use <a href="../primitive.str#method.as_mut_ptr"><code>as_mut_ptr</code></a>.</p> <h2 id="examples-42" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Hello";
let ptr = s.as_ptr();</pre></div> </div>
<h4 id="method.as_mut_ptr" class="method">
<code>pub fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.pointer">*mut </a><a class="primitive" href="../primitive.u8">u8</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2457-2459" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span>
</h4>
<div class="docblock">
<p>Converts a mutable string slice to a raw pointer.</p> <p>As string slices are a slice of bytes, the raw pointer points to a <a href="../primitive.u8" title="`u8`"><code>u8</code></a>. This pointer will be pointing to the first byte of the string slice.</p> <p>It is your responsibility to make sure that the string slice only gets modified in a way that it remains valid UTF-8.</p> </div>
<h4 id="method.get" class="method">
<code>pub fn <a href="#method.get" class="fnname">get</a>&lt;I&gt;(&amp;self, i: I) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;&amp;&lt;I as <a class="trait" href="../slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;&gt;::<a class="type" href="../slice/trait.sliceindex#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt; <span class="where fmt-newline">where<br>    I: <a class="trait" href="../slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2482-2484" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span>
</h4>
<div class="docblock">
<p>Returns a subslice of <code>str</code>.</p> <p>This is the non-panicking alternative to indexing the <code>str</code>. Returns <a href="../option/enum.option#variant.None" title="`None`"><code>None</code></a> whenever equivalent indexing operation would panic.</p> <h2 id="examples-43" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = String::from("🗻∈🌏");

assert_eq!(Some("🗻"), v.get(0..4));

// indices not on UTF-8 sequence boundaries
assert!(v.get(1..).is_none());
assert!(v.get(..8).is_none());

// out of bounds
assert!(v.get(..42).is_none());</pre></div> </div>
<h4 id="method.get_mut" class="method">
<code>pub fn <a href="#method.get_mut" class="fnname">get_mut</a>&lt;I&gt;(<br>    &amp;mut self, <br>    i: I<br>) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;I as <a class="trait" href="../slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;&gt;::<a class="type" href="../slice/trait.sliceindex#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt; <span class="where fmt-newline">where<br>    I: <a class="trait" href="../slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2514-2516" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span>
</h4>
<div class="docblock">
<p>Returns a mutable subslice of <code>str</code>.</p> <p>This is the non-panicking alternative to indexing the <code>str</code>. Returns <a href="../option/enum.option#variant.None" title="`None`"><code>None</code></a> whenever equivalent indexing operation would panic.</p> <h2 id="examples-44" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = String::from("hello");
// correct length
assert!(v.get_mut(0..5).is_some());
// out of bounds
assert!(v.get_mut(..42).is_none());
assert_eq!(Some("he"), v.get_mut(0..2).map(|v| &amp;*v));

assert_eq!("hello", v);
{
    let s = v.get_mut(0..2);
    let s = s.map(|s| {
        s.make_ascii_uppercase();
        &amp;*s
    });
    assert_eq!(Some("HE"), s);
}
assert_eq!("HEllo", v);</pre></div> </div>
<h4 id="method.get_unchecked" class="method">
<code>pub unsafe fn <a href="#method.get_unchecked" class="fnname">get_unchecked</a>&lt;I&gt;(&amp;self, i: I) -&gt; &amp;&lt;I as <a class="trait" href="../slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;&gt;::<a class="type" href="../slice/trait.sliceindex#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>    I: <a class="trait" href="../slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2546-2551" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span>
</h4>
<div class="docblock">
<p>Returns an unchecked subslice of <code>str</code>.</p> <p>This is the unchecked alternative to indexing the <code>str</code>.</p> <h2 id="safety-4" class="section-header">Safety</h2> <p>Callers of this function are responsible that these preconditions are satisfied:</p> <ul> <li>The starting index must not exceed the ending index;</li> <li>Indexes must be within bounds of the original slice;</li> <li>Indexes must lie on UTF-8 sequence boundaries.</li> </ul> <p>Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the <code>str</code> type.</p> <h2 id="examples-45" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v = "🗻∈🌏";
unsafe {
    assert_eq!("🗻", v.get_unchecked(0..4));
    assert_eq!("∈", v.get_unchecked(4..7));
    assert_eq!("🌏", v.get_unchecked(7..11));
}</pre></div> </div>
<h4 id="method.get_unchecked_mut" class="method">
<code>pub unsafe fn <a href="#method.get_unchecked_mut" class="fnname">get_unchecked_mut</a>&lt;I&gt;(<br>    &amp;mut self, <br>    i: I<br>) -&gt; &amp;mut &lt;I as <a class="trait" href="../slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;&gt;::<a class="type" href="../slice/trait.sliceindex#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>    I: <a class="trait" href="../slice/trait.sliceindex" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2581-2586" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span>
</h4>
<div class="docblock">
<p>Returns a mutable, unchecked subslice of <code>str</code>.</p> <p>This is the unchecked alternative to indexing the <code>str</code>.</p> <h2 id="safety-5" class="section-header">Safety</h2> <p>Callers of this function are responsible that these preconditions are satisfied:</p> <ul> <li>The starting index must not exceed the ending index;</li> <li>Indexes must be within bounds of the original slice;</li> <li>Indexes must lie on UTF-8 sequence boundaries.</li> </ul> <p>Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the <code>str</code> type.</p> <h2 id="examples-46" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut v = String::from("🗻∈🌏");
unsafe {
    assert_eq!("🗻", v.get_unchecked_mut(0..4));
    assert_eq!("∈", v.get_unchecked_mut(4..7));
    assert_eq!("🌏", v.get_unchecked_mut(7..11));
}</pre></div> </div>
<h4 id="method.slice_unchecked" class="method">
<code>pub unsafe fn <a href="#method.slice_unchecked" class="fnname">slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="../primitive.usize">usize</a>, end: <a class="primitive" href="../primitive.usize">usize</a>) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2633-2638" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab deprecated">👎 Deprecated since 1.29.0: use get_unchecked(begin..end) instead </span></div>
<div class="docblock">
<p>Creates a string slice from another string slice, bypassing safety checks.</p> <p>This is generally not recommended, use with caution! For a safe alternative see <a href="../primitive.str" title="`str`"><code>str</code></a> and <a href="../ops/trait.index"><code>Index</code></a>.</p> <p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but excluding <code>end</code>.</p> <p>To get a mutable string slice instead, see the <a href="../primitive.str#method.slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p> <h2 id="safety-6" class="section-header">Safety</h2> <p>Callers of this function are responsible that three preconditions are satisfied:</p> <ul> <li>
<code>begin</code> must not exceed <code>end</code>.</li> <li>
<code>begin</code> and <code>end</code> must be byte positions within the string slice.</li> <li>
<code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li> </ul> <h2 id="examples-47" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";

unsafe {
    assert_eq!("Löwe 老虎 Léopard", s.slice_unchecked(0, 21));
}

let s = "Hello, world!";

unsafe {
    assert_eq!("world", s.slice_unchecked(7, 12));
}</pre></div> </div>
<h4 id="method.slice_mut_unchecked" class="method">
<code>pub unsafe fn <a href="#method.slice_mut_unchecked" class="fnname">slice_mut_unchecked</a>(<br>    &amp;mut self, <br>    begin: <a class="primitive" href="../primitive.usize">usize</a>, <br>    end: <a class="primitive" href="../primitive.usize">usize</a><br>) -&gt; &amp;mut <a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2666-2671" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</h4>
<div class="stability"><span class="stab deprecated">👎 Deprecated since 1.29.0: use get_unchecked_mut(begin..end) instead </span></div>
<div class="docblock">
<p>Creates a string slice from another string slice, bypassing safety checks. This is generally not recommended, use with caution! For a safe alternative see <a href="../primitive.str" title="`str`"><code>str</code></a> and <a href="../ops/trait.indexmut"><code>IndexMut</code></a>.</p> <p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but excluding <code>end</code>.</p> <p>To get an immutable string slice instead, see the <a href="../primitive.str#method.slice_unchecked"><code>slice_unchecked</code></a> method.</p> <h2 id="safety-7" class="section-header">Safety</h2> <p>Callers of this function are responsible that three preconditions are satisfied:</p> <ul> <li>
<code>begin</code> must not exceed <code>end</code>.</li> <li>
<code>begin</code> and <code>end</code> must be byte positions within the string slice.</li> <li>
<code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li> </ul> </div>
<h4 id="method.split_at" class="method">
<code>pub fn <a href="#method.split_at" class="fnname">split_at</a>(&amp;self, mid: <a class="primitive" href="../primitive.usize">usize</a>) -&gt; <a class="primitive" href="../primitive.tuple">(</a>&amp;<a class="primitive" href="../primitive.str">str</a>, &amp;<a class="primitive" href="../primitive.str">str</a><a class="primitive" href="../primitive.tuple">)</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2705-2713" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span>
</h4>
<div class="docblock">
<p>Divide one string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get mutable string slices instead, see the <a href="../primitive.str#method.split_at_mut"><code>split_at_mut</code></a> method.</p> <h2 id="panics-9" class="section-header">Panics</h2> <p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice.</p> <h2 id="examples-48" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Per Martin-Löf";

let (first, last) = s.split_at(3);

assert_eq!("Per", first);
assert_eq!(" Martin-Löf", last);</pre></div> </div>
<h4 id="method.split_at_mut" class="method">
<code>pub fn <a href="#method.split_at_mut" class="fnname">split_at_mut</a>(&amp;mut self, mid: <a class="primitive" href="../primitive.usize">usize</a>) -&gt; <a class="primitive" href="../primitive.tuple">(</a>&amp;mut <a class="primitive" href="../primitive.str">str</a>, &amp;mut <a class="primitive" href="../primitive.str">str</a><a class="primitive" href="../primitive.tuple">)</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2748-2763" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span>
</h4>
<div class="docblock">
<p>Divide one mutable string slice into two at an index.</p> <p>The argument, <code>mid</code>, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</p> <p>The two slices returned go from the start of the string slice to <code>mid</code>, and from <code>mid</code> to the end of the string slice.</p> <p>To get immutable string slices instead, see the <a href="../primitive.str#method.split_at"><code>split_at</code></a> method.</p> <h2 id="panics-10" class="section-header">Panics</h2> <p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice.</p> <h2 id="examples-49" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = "Per Martin-Löf".to_string();
{
    let (first, last) = s.split_at_mut(3);
    first.make_ascii_uppercase();
    assert_eq!("PER", first);
    assert_eq!(" Martin-Löf", last);
}
assert_eq!("PER Martin-Löf", s);</pre></div> </div>
<h4 id="method.chars" class="method">
<code>pub fn <a href="#method.chars" class="fnname">chars</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.chars" title="struct std::str::Chars">Chars</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Chars&lt;'a&gt;</h3>
<pre class="content">impl&lt;'a&gt; Iterator for Chars&lt;'a&gt;
    type Item = char;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2814-2816" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator over the <a href="../primitive.char"><code>char</code></a>s of a string slice.</p> <p>As a string slice consists of valid UTF-8, we can iterate through a string slice by <a href="../primitive.char"><code>char</code></a>. This method returns such an iterator.</p> <p>It's important to remember that <a href="../primitive.char"><code>char</code></a> represents a Unicode Scalar Value, and may not match your idea of what a 'character' is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rust's standard library, check crates.io instead.</p> <h2 id="examples-50" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let word = "goodbye";

let count = word.chars().count();
assert_eq!(7, count);

let mut chars = word.chars();

assert_eq!(Some('g'), chars.next());
assert_eq!(Some('o'), chars.next());
assert_eq!(Some('o'), chars.next());
assert_eq!(Some('d'), chars.next());
assert_eq!(Some('b'), chars.next());
assert_eq!(Some('y'), chars.next());
assert_eq!(Some('e'), chars.next());

assert_eq!(None, chars.next());</pre></div> <p>Remember, <a href="../primitive.char"><code>char</code></a>s may not match your intuition about characters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let y = "y̆";

let mut chars = y.chars();

assert_eq!(Some('y'), chars.next()); // not 'y̆'
assert_eq!(Some('\u{0306}'), chars.next());

assert_eq!(None, chars.next());</pre></div> </div>
<h4 id="method.char_indices" class="method">
<code>pub fn <a href="#method.char_indices" class="fnname">char_indices</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.charindices" title="struct std::str::CharIndices">CharIndices</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for CharIndices&lt;'a&gt;</h3>
<pre class="content">impl&lt;'a&gt; Iterator for CharIndices&lt;'a&gt;
    type Item = (usize, char);
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2871-2873" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns an iterator over the <a href="../primitive.char"><code>char</code></a>s of a string slice, and their positions.</p> <p>As a string slice consists of valid UTF-8, we can iterate through a string slice by <a href="../primitive.char"><code>char</code></a>. This method returns an iterator of both these <a href="../primitive.char"><code>char</code></a>s, as well as their byte positions.</p> <p>The iterator yields tuples. The position is first, the <a href="../primitive.char"><code>char</code></a> is second.</p> <h2 id="examples-51" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let word = "goodbye";

let count = word.char_indices().count();
assert_eq!(7, count);

let mut char_indices = word.char_indices();

assert_eq!(Some((0, 'g')), char_indices.next());
assert_eq!(Some((1, 'o')), char_indices.next());
assert_eq!(Some((2, 'o')), char_indices.next());
assert_eq!(Some((3, 'd')), char_indices.next());
assert_eq!(Some((4, 'b')), char_indices.next());
assert_eq!(Some((5, 'y')), char_indices.next());
assert_eq!(Some((6, 'e')), char_indices.next());

assert_eq!(None, char_indices.next());</pre></div> <p>Remember, <a href="../primitive.char"><code>char</code></a>s may not match your intuition about characters:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let yes = "y̆es";

let mut char_indices = yes.char_indices();

assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y̆')
assert_eq!(Some((1, '\u{0306}')), char_indices.next());

// note the 3 here - the last character took up two bytes
assert_eq!(Some((3, 'e')), char_indices.next());
assert_eq!(Some((4, 's')), char_indices.next());

assert_eq!(None, char_indices.next());</pre></div> </div>
<h4 id="method.bytes" class="method">
<code>pub fn <a href="#method.bytes" class="fnname">bytes</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.bytes" title="struct std::str::Bytes">Bytes</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Bytes&lt;'_&gt;</h3>
<pre class="content">impl&lt;'_&gt; Iterator for Bytes&lt;'_&gt;
    type Item = u8;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2896-2898" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>An iterator over the bytes of a string slice.</p> <p>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</p> <h2 id="examples-52" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut bytes = "bors".bytes();

assert_eq!(Some(b'b'), bytes.next());
assert_eq!(Some(b'o'), bytes.next());
assert_eq!(Some(b'r'), bytes.next());
assert_eq!(Some(b's'), bytes.next());

assert_eq!(None, bytes.next());</pre></div> </div>
<h4 id="method.split_whitespace" class="method">
<code>pub fn <a href="#method.split_whitespace" class="fnname">split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.splitwhitespace" title="struct std::str::SplitWhitespace">SplitWhitespace</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for SplitWhitespace&lt;'a&gt;</h3>
<pre class="content">impl&lt;'a&gt; Iterator for SplitWhitespace&lt;'a&gt;
    type Item = &amp;'a str;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2939-2941" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span>
</h4>
<div class="docblock">
<p>Splits a string slice by whitespace.</p> <p>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace instead, use <a href="../primitive.str#method.split_ascii_whitespace"><code>split_ascii_whitespace</code></a>.</p> <h2 id="examples-53" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut iter = "A few words".split_whitespace();

assert_eq!(Some("A"), iter.next());
assert_eq!(Some("few"), iter.next());
assert_eq!(Some("words"), iter.next());

assert_eq!(None, iter.next());</pre></div> <p>All kinds of whitespace are considered:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut iter = " Mary   had\ta\u{2009}little  \n\t lamb".split_whitespace();
assert_eq!(Some("Mary"), iter.next());
assert_eq!(Some("had"), iter.next());
assert_eq!(Some("a"), iter.next());
assert_eq!(Some("little"), iter.next());
assert_eq!(Some("lamb"), iter.next());

assert_eq!(None, iter.next());</pre></div> </div>
<h4 id="method.split_ascii_whitespace" class="method">
<code>pub fn <a href="#method.split_ascii_whitespace" class="fnname">split_ascii_whitespace</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.splitasciiwhitespace" title="struct std::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for SplitAsciiWhitespace&lt;'a&gt;</h3>
<pre class="content">impl&lt;'a&gt; Iterator for SplitAsciiWhitespace&lt;'a&gt;
    type Item = &amp;'a str;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#2980-2984" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span>
</h4>
<div class="docblock">
<p>Splits a string slice by ASCII whitespace.</p> <p>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace.</p> <p>To split by Unicode <code>Whitespace</code> instead, use <a href="../primitive.str#method.split_whitespace"><code>split_whitespace</code></a>.</p> <h2 id="examples-54" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut iter = "A few words".split_ascii_whitespace();

assert_eq!(Some("A"), iter.next());
assert_eq!(Some("few"), iter.next());
assert_eq!(Some("words"), iter.next());

assert_eq!(None, iter.next());</pre></div> <p>All kinds of ASCII whitespace are considered:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut iter = " Mary   had\ta little  \n\t lamb".split_ascii_whitespace();
assert_eq!(Some("Mary"), iter.next());
assert_eq!(Some("had"), iter.next());
assert_eq!(Some("a"), iter.next());
assert_eq!(Some("little"), iter.next());
assert_eq!(Some("lamb"), iter.next());

assert_eq!(None, iter.next());</pre></div> </div>
<h4 id="method.lines" class="method">
<code>pub fn <a href="#method.lines" class="fnname">lines</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.lines" title="struct std::str::Lines">Lines</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Lines&lt;'a&gt;</h3>
<pre class="content">impl&lt;'a&gt; Iterator for Lines&lt;'a&gt;
    type Item = &amp;'a str;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3024-3026" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>An iterator over the lines of a string, as string slices.</p> <p>Lines are ended with either a newline (<code>\n</code>) or a carriage return with a line feed (<code>\r\n</code>).</p> <p>The final line ending is optional.</p> <h2 id="examples-55" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let text = "foo\r\nbar\n\nbaz\n";
let mut lines = text.lines();

assert_eq!(Some("foo"), lines.next());
assert_eq!(Some("bar"), lines.next());
assert_eq!(Some(""), lines.next());
assert_eq!(Some("baz"), lines.next());

assert_eq!(None, lines.next());</pre></div> <p>The final line ending isn't required:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let text = "foo\nbar\n\r\nbaz";
let mut lines = text.lines();

assert_eq!(Some("foo"), lines.next());
assert_eq!(Some("bar"), lines.next());
assert_eq!(Some(""), lines.next());
assert_eq!(Some("baz"), lines.next());

assert_eq!(None, lines.next());</pre></div> </div>
<h4 id="method.lines_any" class="method">
<code>pub fn <a href="#method.lines_any" class="fnname">lines_any</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.linesany" title="struct std::str::LinesAny">LinesAny</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for LinesAny&lt;'a&gt;</h3>
<pre class="content">impl&lt;'a&gt; Iterator for LinesAny&lt;'a&gt;
    type Item = &amp;'a str;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3033-3035" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab deprecated">👎 Deprecated since 1.4.0: use lines() instead now </span></div>
<div class="docblock">
<p>An iterator over the lines of a string.</p> </div>
<h4 id="method.encode_utf16" class="method">
<code>pub fn <a href="#method.encode_utf16" class="fnname">encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.encodeutf16" title="struct std::str::EncodeUtf16">EncodeUtf16</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for EncodeUtf16&lt;'a&gt;</h3>
<pre class="content">impl&lt;'a&gt; Iterator for EncodeUtf16&lt;'a&gt;
    type Item = u16;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3052-3054" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span>
</h4>
<div class="docblock">
<p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p> <h2 id="examples-56" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let text = "Zażółć gęślą jaźń";

let utf8_len = text.len();
let utf16_len = text.encode_utf16().count();

assert!(utf16_len &lt;= utf8_len);</pre></div> </div>
<h4 id="method.contains" class="method">
<code>pub fn <a href="#method.contains" class="fnname">contains</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="../primitive.bool">bool</a> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3079-3081" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a sub-slice of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="examples-57" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let bananas = "bananas";

assert!(bananas.contains("nana"));
assert!(!bananas.contains("apples"));</pre></div> </div>
<h4 id="method.starts_with" class="method">
<code>pub fn <a href="#method.starts_with" class="fnname">starts_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="../primitive.bool">bool</a> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3105-3107" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a prefix of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="examples-58" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let bananas = "bananas";

assert!(bananas.starts_with("bana"));
assert!(!bananas.starts_with("nana"));</pre></div> </div>
<h4 id="method.ends_with" class="method">
<code>pub fn <a href="#method.ends_with" class="fnname">ends_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="../primitive.bool">bool</a> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>    &lt;P as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3131-3136" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns <code>true</code> if the given pattern matches a suffix of this string slice.</p> <p>Returns <code>false</code> if it does not.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="examples-59" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let bananas = "bananas";

assert!(bananas.ends_with("anas"));
assert!(!bananas.ends_with("nana"));</pre></div> </div>
<h4 id="method.find" class="method">
<code>pub fn <a href="#method.find" class="fnname">find</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt; <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3182-3184" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns the byte index of the first character of this string slice that matches the pattern.</p> <p>Returns <a href="../option/enum.option#variant.None" title="`None`"><code>None</code></a> if the pattern doesn't match.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="examples-60" class="section-header">Examples</h2> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard Gepardi";

assert_eq!(s.find('L'), Some(0));
assert_eq!(s.find('é'), Some(14));
assert_eq!(s.find("pard"), Some(17));</pre></div> <p>More complex patterns using point-free style and closures:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";

assert_eq!(s.find(char::is_whitespace), Some(5));
assert_eq!(s.find(char::is_lowercase), Some(1));
assert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));
assert_eq!(s.find(|c: char| (c &lt; 'o') &amp;&amp; (c &gt; 'a')), Some(4));</pre></div> <p>Not finding the pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";
let x: &amp;[_] = &amp;['1', '2'];

assert_eq!(s.find(x), None);</pre></div> </div>
<h4 id="method.rfind" class="method">
<code>pub fn <a href="#method.rfind" class="fnname">rfind</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt; <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>    &lt;P as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3228-3233" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns the byte index for the first character of the rightmost match of the pattern in this string slice.</p> <p>Returns <a href="../option/enum.option#variant.None" title="`None`"><code>None</code></a> if the pattern doesn't match.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="examples-61" class="section-header">Examples</h2> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard Gepardi";

assert_eq!(s.rfind('L'), Some(13));
assert_eq!(s.rfind('é'), Some(14));
assert_eq!(s.rfind("pard"), Some(24));</pre></div> <p>More complex patterns with closures:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";

assert_eq!(s.rfind(char::is_whitespace), Some(12));
assert_eq!(s.rfind(char::is_lowercase), Some(20));</pre></div> <p>Not finding the pattern:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Löwe 老虎 Léopard";
let x: &amp;[_] = &amp;['1', '2'];

assert_eq!(s.rfind(x), None);</pre></div> </div>
<h4 id="method.split" class="method">
<code>pub fn <a href="#method.split" class="fnname">split</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.split" title="struct std::str::Split">Split</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Split&lt;'a, P&gt;</h3>
<pre class="content">impl&lt;'a, P&gt; Iterator for Split&lt;'a, P&gt; where
    P: Pattern&lt;'a&gt;, 
    type Item = &amp;'a str;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3343-3351" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>An iterator over substrings of this string slice, separated by characters matched by a pattern.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="iterator-behavior" class="section-header">Iterator behavior</h2> <p>The returned iterator will be a <a href="../iter/trait.doubleendediterator" title="`DoubleEndedIterator`"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="../primitive.char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="../primitive.str#method.rsplit"><code>rsplit</code></a> method can be used.</p> <h2 id="examples-62" class="section-header">Examples</h2> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".split(' ').collect();
assert_eq!(v, ["Mary", "had", "a", "little", "lamb"]);

let v: Vec&lt;&amp;str&gt; = "".split('X').collect();
assert_eq!(v, [""]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".split('X').collect();
assert_eq!(v, ["lion", "", "tiger", "leopard"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".split("::").collect();
assert_eq!(v, ["lion", "tiger", "leopard"]);

let v: Vec&lt;&amp;str&gt; = "abc1def2ghi".split(char::is_numeric).collect();
assert_eq!(v, ["abc", "def", "ghi"]);

let v: Vec&lt;&amp;str&gt; = "lionXtigerXleopard".split(char::is_uppercase).collect();
assert_eq!(v, ["lion", "tiger", "leopard"]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abc1defXghi".split(|c| c == '1' || c == 'X').collect();
assert_eq!(v, ["abc", "def", "ghi"]);</pre></div> <p>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = "||||a||b|c".to_string();
let d: Vec&lt;_&gt; = x.split('|').collect();

assert_eq!(d, &amp;["", "", "", "", "a", "", "b", "c"]);</pre></div> <p>Contiguous separators are separated by the empty string.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = "(///)".to_string();
let d: Vec&lt;_&gt; = x.split('/').collect();

assert_eq!(d, &amp;["(", "", "", ")"]);</pre></div> <p>Separators at the start or end of a string are neighbored by empty strings.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let d: Vec&lt;_&gt; = "010".split("0").collect();
assert_eq!(d, &amp;["", "1", ""]);</pre></div> <p>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let f: Vec&lt;_&gt; = "rust".split("").collect();
assert_eq!(f, &amp;["", "r", "u", "s", "t", ""]);</pre></div> <p>Contiguous separators can lead to possibly surprising behavior when whitespace is used as the separator. This code is correct:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let x = "    a  b c".to_string();
let d: Vec&lt;_&gt; = x.split(' ').collect();

assert_eq!(d, &amp;["", "", "", "", "a", "", "b", "c"]);</pre></div> <p>It does <em>not</em> give you:</p> <div class="information">ⓘThis example is not tested</div>
<div class="example-wrap"><pre class="rust rust-example-rendered ignore" data-language="rust">
assert_eq!(d, &amp;["a", "b", "c"]);</pre></div> <p>Use <a href="../primitive.str#method.split_whitespace"><code>split_whitespace</code></a> for this behavior.</p> </div>
<h4 id="method.split_inclusive" class="method">
<code>pub fn <a href="#method.split_inclusive" class="fnname">split_inclusive</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/core/str/struct.SplitInclusive.html" title="struct core::str::SplitInclusive">SplitInclusive</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for SplitInclusive&lt;'a, P&gt;</h3>
<pre class="content">impl&lt;'a, P&gt; Iterator for SplitInclusive&lt;'a, P&gt; where
    P: Pattern&lt;'a&gt;, 
    type Item = &amp;'a str;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3385-3393" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (split_inclusive #72360)</span></div>
<div class="docblock">
<p>An iterator over substrings of this string slice, separated by characters matched by a pattern. Differs from the iterator produced by <code>split</code> in that <code>split_inclusive</code> leaves the matched part as the terminator of the substring.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="examples-63" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(split_inclusive)]
let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb\nlittle lamb\nlittle lamb."
    .split_inclusive('\n').collect();
assert_eq!(v, ["Mary had a little lamb\n", "little lamb\n", "little lamb."]);</pre></div> <p>If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(split_inclusive)]
let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb\nlittle lamb\nlittle lamb.\n"
    .split_inclusive('\n').collect();
assert_eq!(v, ["Mary had a little lamb\n", "little lamb\n", "little lamb.\n"]);</pre></div> </div>
<h4 id="method.rsplit" class="method">
<code>pub fn <a href="#method.rsplit" class="fnname">rsplit</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.rsplit" title="struct std::str::RSplit">RSplit</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for RSplit&lt;'a, P&gt;</h3>
<pre class="content">impl&lt;'a, P&gt; Iterator for RSplit&lt;'a, P&gt; where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;, 
    type Item = &amp;'a str;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>    &lt;P as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3440-3445" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>An iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="iterator-behavior-1" class="section-header">Iterator behavior</h2> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="../iter/trait.doubleendediterator" title="`DoubleEndedIterator`"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="../primitive.str#method.split"><code>split</code></a> method can be used.</p> <h2 id="examples-64" class="section-header">Examples</h2> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".rsplit(' ').collect();
assert_eq!(v, ["lamb", "little", "a", "had", "Mary"]);

let v: Vec&lt;&amp;str&gt; = "".rsplit('X').collect();
assert_eq!(v, [""]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".rsplit('X').collect();
assert_eq!(v, ["leopard", "tiger", "", "lion"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".rsplit("::").collect();
assert_eq!(v, ["leopard", "tiger", "lion"]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abc1defXghi".rsplit(|c| c == '1' || c == 'X').collect();
assert_eq!(v, ["ghi", "def", "abc"]);</pre></div> </div>
<h4 id="method.split_terminator" class="method">
<code>pub fn <a href="#method.split_terminator" class="fnname">split_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.splitterminator" title="struct std::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for SplitTerminator&lt;'a, P&gt;</h3>
<pre class="content">impl&lt;'a, P&gt; Iterator for SplitTerminator&lt;'a, P&gt; where
    P: Pattern&lt;'a&gt;, 
    type Item = &amp;'a str;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3488-3490" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>An iterator over substrings of the given string slice, separated by characters matched by a pattern.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <p>Equivalent to <a href="../primitive.str#method.split"><code>split</code></a>, except that the trailing substring is skipped if empty.</p> <p>This method can be used for string data that is <em>terminated</em>, rather than <em>separated</em> by a pattern.</p> <h2 id="iterator-behavior-2" class="section-header">Iterator behavior</h2> <p>The returned iterator will be a <a href="../iter/trait.doubleendediterator" title="`DoubleEndedIterator`"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="../primitive.char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="../primitive.str#method.rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p> <h2 id="examples-65" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "A.B.".split_terminator('.').collect();
assert_eq!(v, ["A", "B"]);

let v: Vec&lt;&amp;str&gt; = "A..B..".split_terminator(".").collect();
assert_eq!(v, ["A", "", "B", ""]);</pre></div> </div>
<h4 id="method.rsplit_terminator" class="method">
<code>pub fn <a href="#method.rsplit_terminator" class="fnname">rsplit_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.rsplitterminator" title="struct std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for RSplitTerminator&lt;'a, P&gt;</h3>
<pre class="content">impl&lt;'a, P&gt; Iterator for RSplitTerminator&lt;'a, P&gt; where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;, 
    type Item = &amp;'a str;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>    &lt;P as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3531-3536" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>An iterator over substrings of <code>self</code>, separated by characters matched by a pattern and yielded in reverse order.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <p>Equivalent to <a href="../primitive.str#method.split"><code>split</code></a>, except that the trailing substring is skipped if empty.</p> <p>This method can be used for string data that is <em>terminated</em>, rather than <em>separated</em> by a pattern.</p> <h2 id="iterator-behavior-3" class="section-header">Iterator behavior</h2> <p>The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="../primitive.str#method.split_terminator"><code>split_terminator</code></a> method can be used.</p> <h2 id="examples-66" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "A.B.".rsplit_terminator('.').collect();
assert_eq!(v, ["B", "A"]);

let v: Vec&lt;&amp;str&gt; = "A..B..".rsplit_terminator(".").collect();
assert_eq!(v, ["", "B", "", "A"]);</pre></div> </div>
<h4 id="method.splitn" class="method">
<code>pub fn <a href="#method.splitn" class="fnname">splitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="../primitive.usize">usize</a>, pat: P) -&gt; <a class="struct" href="../str/struct.splitn" title="struct std::str::SplitN">SplitN</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for SplitN&lt;'a, P&gt;</h3>
<pre class="content">impl&lt;'a, P&gt; Iterator for SplitN&lt;'a, P&gt; where
    P: Pattern&lt;'a&gt;, 
    type Item = &amp;'a str;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3586-3588" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>An iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most <code>n</code> items.</p> <p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring) will contain the remainder of the string.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="iterator-behavior-4" class="section-header">Iterator behavior</h2> <p>The returned iterator will not be double ended, because it is not efficient to support.</p> <p>If the pattern allows a reverse search, the <a href="../primitive.str#method.rsplitn"><code>rsplitn</code></a> method can be used.</p> <h2 id="examples-67" class="section-header">Examples</h2> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "Mary had a little lambda".splitn(3, ' ').collect();
assert_eq!(v, ["Mary", "had", "a little lambda"]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".splitn(3, "X").collect();
assert_eq!(v, ["lion", "", "tigerXleopard"]);

let v: Vec&lt;&amp;str&gt; = "abcXdef".splitn(1, 'X').collect();
assert_eq!(v, ["abcXdef"]);

let v: Vec&lt;&amp;str&gt; = "".splitn(1, 'X').collect();
assert_eq!(v, [""]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abc1defXghi".splitn(2, |c| c == '1' || c == 'X').collect();
assert_eq!(v, ["abc", "defXghi"]);</pre></div> </div>
<h4 id="method.rsplitn" class="method">
<code>pub fn <a href="#method.rsplitn" class="fnname">rsplitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="../primitive.usize">usize</a>, pat: P) -&gt; <a class="struct" href="../str/struct.rsplitn" title="struct std::str::RSplitN">RSplitN</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for RSplitN&lt;'a, P&gt;</h3>
<pre class="content">impl&lt;'a, P&gt; Iterator for RSplitN&lt;'a, P&gt; where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;, 
    type Item = &amp;'a str;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>    &lt;P as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3635-3640" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>An iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most <code>n</code> items.</p> <p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring) will contain the remainder of the string.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="iterator-behavior-5" class="section-header">Iterator behavior</h2> <p>The returned iterator will not be double ended, because it is not efficient to support.</p> <p>For splitting from the front, the <a href="../primitive.str#method.splitn"><code>splitn</code></a> method can be used.</p> <h2 id="examples-68" class="section-header">Examples</h2> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "Mary had a little lamb".rsplitn(3, ' ').collect();
assert_eq!(v, ["lamb", "little", "Mary had a"]);

let v: Vec&lt;&amp;str&gt; = "lionXXtigerXleopard".rsplitn(3, 'X').collect();
assert_eq!(v, ["leopard", "tiger", "lionX"]);

let v: Vec&lt;&amp;str&gt; = "lion::tiger::leopard".rsplitn(2, "::").collect();
assert_eq!(v, ["leopard", "lion::tiger"]);</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abc1defXghi".rsplitn(2, |c| c == '1' || c == 'X').collect();
assert_eq!(v, ["ghi", "abc1def"]);</pre></div> </div>
<h4 id="method.split_once" class="method">
<code>pub fn <a href="#method.split_once" class="fnname">split_once</a>&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="../primitive.tuple">(</a>&amp;'a <a class="primitive" href="../primitive.str">str</a>, &amp;'a <a class="primitive" href="../primitive.str">str</a><a class="primitive" href="../primitive.tuple">)</a>&gt; <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3656-3659" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (str_split_once #74773)newly added </span></div>
<div class="docblock">
<p>Splits the string on the first occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter.</p> <h2 id="examples-69" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(str_split_once)]

assert_eq!("cfg".split_once('='), None);
assert_eq!("cfg=foo".split_once('='), Some(("cfg", "foo")));
assert_eq!("cfg=foo=bar".split_once('='), Some(("cfg", "foo=bar")));</pre></div> </div>
<h4 id="method.rsplit_once" class="method">
<code>pub fn <a href="#method.rsplit_once" class="fnname">rsplit_once</a>&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="../primitive.tuple">(</a>&amp;'a <a class="primitive" href="../primitive.str">str</a>, &amp;'a <a class="primitive" href="../primitive.str">str</a><a class="primitive" href="../primitive.tuple">)</a>&gt; <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>    &lt;P as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3675-3681" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (str_split_once #74773)newly added </span></div>
<div class="docblock">
<p>Splits the string on the last occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter.</p> <h2 id="examples-70" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
#![feature(str_split_once)]

assert_eq!("cfg".rsplit_once('='), None);
assert_eq!("cfg=foo".rsplit_once('='), Some(("cfg", "foo")));
assert_eq!("cfg=foo=bar".rsplit_once('='), Some(("cfg=foo", "bar")));</pre></div> </div>
<h4 id="method.matches" class="method">
<code>pub fn <a href="#method.matches" class="fnname">matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.matches" title="struct std::str::Matches">Matches</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Matches&lt;'a, P&gt;</h3>
<pre class="content">impl&lt;'a, P&gt; Iterator for Matches&lt;'a, P&gt; where
    P: Pattern&lt;'a&gt;, 
    type Item = &amp;'a str;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3716-3718" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span>
</h4>
<div class="docblock">
<p>An iterator over the disjoint matches of a pattern within the given string slice.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="iterator-behavior-6" class="section-header">Iterator behavior</h2> <p>The returned iterator will be a <a href="../iter/trait.doubleendediterator" title="`DoubleEndedIterator`"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="../primitive.char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="../primitive.str#method.matches"><code>rmatches</code></a> method can be used.</p> <h2 id="examples-71" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abcXXXabcYYYabc".matches("abc").collect();
assert_eq!(v, ["abc", "abc", "abc"]);

let v: Vec&lt;&amp;str&gt; = "1abc2abc3".matches(char::is_numeric).collect();
assert_eq!(v, ["1", "2", "3"]);</pre></div> </div>
<h4 id="method.rmatches" class="method">
<code>pub fn <a href="#method.rmatches" class="fnname">rmatches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.rmatches" title="struct std::str::RMatches">RMatches</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for RMatches&lt;'a, P&gt;</h3>
<pre class="content">impl&lt;'a, P&gt; Iterator for RMatches&lt;'a, P&gt; where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;, 
    type Item = &amp;'a str;
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>    &lt;P as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3752-3757" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span>
</h4>
<div class="docblock">
<p>An iterator over the disjoint matches of a pattern within this string slice, yielded in reverse order.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="iterator-behavior-7" class="section-header">Iterator behavior</h2> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="../iter/trait.doubleendediterator" title="`DoubleEndedIterator`"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="../primitive.str#method.matches"><code>matches</code></a> method can be used.</p> <h2 id="examples-72" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;&amp;str&gt; = "abcXXXabcYYYabc".rmatches("abc").collect();
assert_eq!(v, ["abc", "abc", "abc"]);

let v: Vec&lt;&amp;str&gt; = "1abc2abc3".rmatches(char::is_numeric).collect();
assert_eq!(v, ["3", "2", "1"]);</pre></div> </div>
<h4 id="method.match_indices" class="method">
<code>pub fn <a href="#method.match_indices" class="fnname">match_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.matchindices" title="struct std::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for MatchIndices&lt;'a, P&gt;</h3>
<pre class="content">impl&lt;'a, P&gt; Iterator for MatchIndices&lt;'a, P&gt; where
    P: Pattern&lt;'a&gt;, 
    type Item = (usize, &amp;'a str);
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3798-3800" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</h4>
<div class="docblock">
<p>An iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at.</p> <p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices corresponding to the first match are returned.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="iterator-behavior-8" class="section-header">Iterator behavior</h2> <p>The returned iterator will be a <a href="../iter/trait.doubleendediterator" title="`DoubleEndedIterator`"><code>DoubleEndedIterator</code></a> if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., <a href="../primitive.char"><code>char</code></a>, but not for <code>&amp;str</code>.</p> <p>If the pattern allows a reverse search but its results might differ from a forward search, the <a href="../primitive.str#method.match_indices"><code>rmatch_indices</code></a> method can be used.</p> <h2 id="examples-73" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;_&gt; = "abcXXXabcYYYabc".match_indices("abc").collect();
assert_eq!(v, [(0, "abc"), (6, "abc"), (12, "abc")]);

let v: Vec&lt;_&gt; = "1abcabc2".match_indices("abc").collect();
assert_eq!(v, [(1, "abc"), (4, "abc")]);

let v: Vec&lt;_&gt; = "ababa".match_indices("aba").collect();
assert_eq!(v, [(0, "aba")]); // only the first `aba`</pre></div> </div>
<h4 id="method.rmatch_indices" class="method">
<code>pub fn <a href="#method.rmatch_indices" class="fnname">rmatch_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../str/struct.rmatchindices" title="struct std::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for RMatchIndices&lt;'a, P&gt;</h3>
<pre class="content">impl&lt;'a, P&gt; Iterator for RMatchIndices&lt;'a, P&gt; where
    P: Pattern&lt;'a&gt;,
    &lt;P as Pattern&lt;'a&gt;&gt;::Searcher: ReverseSearcher&lt;'a&gt;, 
    type Item = (usize, &amp;'a str);
</pre></span></div></span></span> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>    &lt;P as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3840-3845" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span>
</h4>
<div class="docblock">
<p>An iterator over the disjoint matches of a pattern within <code>self</code>, yielded in reverse order along with the index of the match.</p> <p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices corresponding to the last match are returned.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="iterator-behavior-9" class="section-header">Iterator behavior</h2> <p>The returned iterator requires that the pattern supports a reverse search, and it will be a <a href="../iter/trait.doubleendediterator" title="`DoubleEndedIterator`"><code>DoubleEndedIterator</code></a> if a forward/reverse search yields the same elements.</p> <p>For iterating from the front, the <a href="../primitive.str#method.match_indices"><code>match_indices</code></a> method can be used.</p> <h2 id="examples-74" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let v: Vec&lt;_&gt; = "abcXXXabcYYYabc".rmatch_indices("abc").collect();
assert_eq!(v, [(12, "abc"), (6, "abc"), (0, "abc")]);

let v: Vec&lt;_&gt; = "1abcabc2".rmatch_indices("abc").collect();
assert_eq!(v, [(4, "abc"), (1, "abc")]);

let v: Vec&lt;_&gt; = "ababa".rmatch_indices("aba").collect();
assert_eq!(v, [(2, "aba")]); // only the last `aba`</pre></div> </div>
<h4 id="method.trim" class="method">
<code><span class="docblock attributes">#[must_use =
  "this returns the trimmed string as a slice, \
                  without modifying the original"]</span>pub fn <a href="#method.trim" class="fnname">trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3864-3866" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns a string slice with leading and trailing whitespace removed.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h2 id="examples-75" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = " Hello\tworld\t";

assert_eq!("Hello\tworld", s.trim());</pre></div> </div>
<h4 id="method.trim_start" class="method">
<code><span class="docblock attributes">#[must_use =
  "this returns the trimmed string as a new slice, \
                  without modifying the original"]</span>pub fn <a href="#method.trim_start" class="fnname">trim_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3901-3903" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span>
</h4>
<div class="docblock">
<p>Returns a string slice with leading whitespace removed.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h2 id="text-directionality" class="section-header">Text directionality</h2> <p>A string is a sequence of bytes. <code>start</code> in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</p> <h2 id="examples-76" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = " Hello\tworld\t";
assert_eq!("Hello\tworld\t", s.trim_start());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "  English  ";
assert!(Some('E') == s.trim_start().chars().next());

let s = "  עברית  ";
assert!(Some('ע') == s.trim_start().chars().next());</pre></div> </div>
<h4 id="method.trim_end" class="method">
<code><span class="docblock attributes">#[must_use =
  "this returns the trimmed string as a new slice, \
                  without modifying the original"]</span>pub fn <a href="#method.trim_end" class="fnname">trim_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3938-3940" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span>
</h4>
<div class="docblock">
<p>Returns a string slice with trailing whitespace removed.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h2 id="text-directionality-1" class="section-header">Text directionality</h2> <p>A string is a sequence of bytes. <code>end</code> in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</p> <h2 id="examples-77" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = " Hello\tworld\t";
assert_eq!(" Hello\tworld", s.trim_end());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "  English  ";
assert!(Some('h') == s.trim_end().chars().rev().next());

let s = "  עברית  ";
assert!(Some('ת') == s.trim_end().chars().rev().next());</pre></div> </div>
<h4 id="method.trim_left" class="method">
<code>pub fn <a href="#method.trim_left" class="fnname">trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#3979-3981" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab deprecated">👎 Deprecated since 1.33.0: superseded by trim_start </span></div>
<div class="docblock">
<p>Returns a string slice with leading whitespace removed.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h2 id="text-directionality-2" class="section-header">Text directionality</h2> <p>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the <em>right</em> side, not the left.</p> <h2 id="examples-78" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = " Hello\tworld\t";

assert_eq!("Hello\tworld\t", s.trim_left());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "  English";
assert!(Some('E') == s.trim_left().chars().next());

let s = "  עברית";
assert!(Some('ע') == s.trim_left().chars().next());</pre></div> </div>
<h4 id="method.trim_right" class="method">
<code>pub fn <a href="#method.trim_right" class="fnname">trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4020-4022" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab deprecated">👎 Deprecated since 1.33.0: superseded by trim_end </span></div>
<div class="docblock">
<p>Returns a string slice with trailing whitespace removed.</p> <p>'Whitespace' is defined according to the terms of the Unicode Derived Core Property <code>White_Space</code>.</p> <h2 id="text-directionality-3" class="section-header">Text directionality</h2> <p>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the <em>left</em> side, not the right.</p> <h2 id="examples-79" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = " Hello\tworld\t";

assert_eq!(" Hello\tworld", s.trim_right());</pre></div> <p>Directionality:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "English  ";
assert!(Some('h') == s.trim_right().chars().rev().next());

let s = "עברית  ";
assert!(Some('ת') == s.trim_right().chars().rev().next());</pre></div> </div>
<h4 id="method.trim_matches" class="method">
<code><span class="docblock attributes">#[must_use =
  "this returns the trimmed string as a new slice, \
                  without modifying the original"]</span>pub fn <a href="#method.trim_matches" class="fnname">trim_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="../primitive.str">str</a> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>    &lt;P as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../str/pattern/trait.doubleendedsearcher" title="trait std::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4053-4070" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Returns a string slice with all prefixes and suffixes that match a pattern repeatedly removed.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="examples-80" class="section-header">Examples</h2> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("11foo1bar11".trim_matches('1'), "foo1bar");
assert_eq!("123foo1bar123".trim_matches(char::is_numeric), "foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_matches(x), "foo1bar");</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("1foo1barXX".trim_matches(|c| c == '1' || c == 'X'), "foo1bar");</pre></div> </div>
<h4 id="method.trim_start_matches" class="method">
<code><span class="docblock attributes">#[must_use =
  "this returns the trimmed string as a new slice, \
                  without modifying the original"]</span>pub fn <a href="#method.trim_start_matches" class="fnname">trim_start_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="../primitive.str">str</a> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4102-4110" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span>
</h4>
<div class="docblock">
<p>Returns a string slice with all prefixes that match a pattern repeatedly removed.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="text-directionality-4" class="section-header">Text directionality</h2> <p>A string is a sequence of bytes. <code>start</code> in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</p> <h2 id="examples-81" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("11foo1bar11".trim_start_matches('1'), "foo1bar11");
assert_eq!("123foo1bar123".trim_start_matches(char::is_numeric), "foo1bar123");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_start_matches(x), "foo1bar12");</pre></div> </div>
<h4 id="method.strip_prefix" class="method">
<code><span class="docblock attributes">#[must_use =
  "this returns the remaining substring as a new slice, \
                  without modifying the original"]</span>pub fn <a href="#method.strip_prefix" class="fnname">strip_prefix</a>&lt;'a, P&gt;(&amp;'a self, prefix: P) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="../primitive.str">str</a>&gt; <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4136-4138" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span>
</h4>
<div class="docblock">
<p>Returns a string slice with the prefix removed.</p> <p>If the string starts with the pattern <code>prefix</code>, <code>Some</code> is returned with the substring where the prefix is removed. Unlike <code>trim_start_matches</code>, this method removes the prefix exactly once.</p> <p>If the string does not start with <code>prefix</code>, <code>None</code> is returned.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="examples-82" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("foo:bar".strip_prefix("foo:"), Some("bar"));
assert_eq!("foo:bar".strip_prefix("bar"), None);
assert_eq!("foofoo".strip_prefix("foo"), Some("foo"));</pre></div> </div>
<h4 id="method.strip_suffix" class="method">
<code><span class="docblock attributes">#[must_use =
  "this returns the remaining substring as a new slice, \
                  without modifying the original"]</span>pub fn <a href="#method.strip_suffix" class="fnname">strip_suffix</a>&lt;'a, P&gt;(&amp;'a self, suffix: P) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="../primitive.str">str</a>&gt; <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>    &lt;P as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4164-4170" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span>
</h4>
<div class="docblock">
<p>Returns a string slice with the suffix removed.</p> <p>If the string ends with the pattern <code>suffix</code>, <code>Some</code> is returned with the substring where the suffix is removed. Unlike <code>trim_end_matches</code>, this method removes the suffix exactly once.</p> <p>If the string does not end with <code>suffix</code>, <code>None</code> is returned.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="examples-83" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("bar:foo".strip_suffix(":foo"), Some("bar"));
assert_eq!("bar:foo".strip_suffix("bar"), None);
assert_eq!("foofoo".strip_suffix("foo"), Some("foo"));</pre></div> </div>
<h4 id="method.trim_end_matches" class="method">
<code><span class="docblock attributes">#[must_use =
  "this returns the trimmed string as a new slice, \
                  without modifying the original"]</span>pub fn <a href="#method.trim_end_matches" class="fnname">trim_end_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="../primitive.str">str</a> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>    &lt;P as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4208-4219" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span>
</h4>
<div class="docblock">
<p>Returns a string slice with all suffixes that match a pattern repeatedly removed.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="text-directionality-5" class="section-header">Text directionality</h2> <p>A string is a sequence of bytes. <code>end</code> in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</p> <h2 id="examples-84" class="section-header">Examples</h2> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("11foo1bar11".trim_end_matches('1'), "11foo1bar");
assert_eq!("123foo1bar123".trim_end_matches(char::is_numeric), "123foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_end_matches(x), "12foo1bar");</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("1fooX".trim_end_matches(|c| c == '1' || c == 'X'), "1foo");</pre></div> </div>
<h4 id="method.trim_left_matches" class="method">
<code>pub fn <a href="#method.trim_left_matches" class="fnname">trim_left_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="../primitive.str">str</a> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4254-4256" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab deprecated">👎 Deprecated since 1.33.0: superseded by trim_start_matches </span></div>
<div class="docblock">
<p>Returns a string slice with all prefixes that match a pattern repeatedly removed.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="text-directionality-6" class="section-header">Text directionality</h2> <p>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the <em>right</em> side, not the left.</p> <h2 id="examples-85" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("11foo1bar11".trim_left_matches('1'), "foo1bar11");
assert_eq!("123foo1bar123".trim_left_matches(char::is_numeric), "foo1bar123");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_left_matches(x), "foo1bar12");</pre></div> </div>
<h4 id="method.trim_right_matches" class="method">
<code>pub fn <a href="#method.trim_right_matches" class="fnname">trim_right_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="../primitive.str">str</a> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>    &lt;P as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../str/pattern/trait.reversesearcher" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4297-4302" title="goto source code">[src]</a>
</h4>
<div class="stability"><span class="stab deprecated">👎 Deprecated since 1.33.0: superseded by trim_end_matches </span></div>
<div class="docblock">
<p>Returns a string slice with all suffixes that match a pattern repeatedly removed.</p> <p>The <a href="../str/pattern/index">pattern</a> can be a <code>&amp;str</code>, <a href="../primitive.char"><code>char</code></a>, a slice of <a href="../primitive.char"><code>char</code></a>s, or a function or closure that determines if a character matches.</p> <h2 id="text-directionality-7" class="section-header">Text directionality</h2> <p>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the <em>left</em> side, not the right.</p> <h2 id="examples-86" class="section-header">Examples</h2> <p>Simple patterns:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("11foo1bar11".trim_right_matches('1'), "11foo1bar");
assert_eq!("123foo1bar123".trim_right_matches(char::is_numeric), "123foo1bar");

let x: &amp;[_] = &amp;['1', '2'];
assert_eq!("12foo1bar12".trim_right_matches(x), "12foo1bar");</pre></div> <p>A more complex pattern, using a closure:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("1fooX".trim_right_matches(|c| c == '1' || c == 'X'), "1foo");</pre></div> </div>
<h4 id="method.parse" class="method">
<code>pub fn <a href="#method.parse" class="fnname">parse</a>&lt;F&gt;(&amp;self) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;F, &lt;F as <a class="trait" href="../str/trait.fromstr" title="trait std::str::FromStr">FromStr</a>&gt;::<a class="type" href="../str/trait.fromstr#associatedtype.Err" title="type std::str::FromStr::Err">Err</a>&gt; <span class="where fmt-newline">where<br>    F: <a class="trait" href="../str/trait.fromstr" title="trait std::str::FromStr">FromStr</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4349-4351" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Parses this string slice into another type.</p> <p>Because <code>parse</code> is so general, it can cause problems with type inference. As such, <code>parse</code> is one of the few times you'll see the syntax affectionately known as the 'turbofish': <code>::&lt;&gt;</code>. This helps the inference algorithm understand specifically which type you're trying to parse into.</p> <p><code>parse</code> can parse any type that implements the <a href="../str/trait.fromstr" title="`FromStr`"><code>FromStr</code></a> trait.</p> <h2 id="errors-3" class="section-header">Errors</h2> <p>Will return <a href="../str/trait.fromstr#associatedtype.Err"><code>Err</code></a> if it's not possible to parse this string slice into the desired type.</p> <h2 id="examples-87" class="section-header">Examples</h2> <p>Basic usage</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let four: u32 = "4".parse().unwrap();

assert_eq!(4, four);</pre></div> <p>Using the 'turbofish' instead of annotating <code>four</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let four = "4".parse::&lt;u32&gt;();

assert_eq!(Ok(4), four);</pre></div> <p>Failing to parse:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let nope = "j".parse::&lt;u32&gt;();

assert!(nope.is_err());</pre></div> </div>
<h4 id="method.is_ascii" class="method">
<code>pub fn <a href="#method.is_ascii" class="fnname">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4366-4371" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span>
</h4>
<div class="docblock">
<p>Checks if all characters in this string are within the ASCII range.</p> <h2 id="examples-88" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let ascii = "hello!\n";
let non_ascii = "Grüße, Jürgen ❤";

assert!(ascii.is_ascii());
assert!(!non_ascii.is_ascii());</pre></div> </div>
<h4 id="method.eq_ignore_ascii_case" class="method">
<code>pub fn <a href="#method.eq_ignore_ascii_case" class="fnname">eq_ignore_ascii_case</a>(&amp;self, other: &amp;<a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4387-4389" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span>
</h4>
<div class="docblock">
<p>Checks that two strings are an ASCII case-insensitive match.</p> <p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>, but without allocating and copying temporaries.</p> <h2 id="examples-89" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert!("Ferris".eq_ignore_ascii_case("FERRIS"));
assert!("Ferrös".eq_ignore_ascii_case("FERRöS"));
assert!(!"Ferrös".eq_ignore_ascii_case("FERRÖS"));</pre></div> </div>
<h4 id="method.make_ascii_uppercase" class="method">
<code>pub fn <a href="#method.make_ascii_uppercase" class="fnname">make_ascii_uppercase</a>(&amp;mut self)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4411-4415" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span>
</h4>
<div class="docblock">
<p>Converts this string to its ASCII upper case equivalent in-place.</p> <p>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</p> <p>To return a new uppercased value without modifying the existing one, use <a href="#method.to_ascii_uppercase"><code>to_ascii_uppercase</code></a>.</p> <h2 id="examples-90" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("Grüße, Jürgen ❤");

s.make_ascii_uppercase();

assert_eq!("GRüßE, JüRGEN ❤", s);</pre></div> </div>
<h4 id="method.make_ascii_lowercase" class="method">
<code>pub fn <a href="#method.make_ascii_lowercase" class="fnname">make_ascii_lowercase</a>(&amp;mut self)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4437-4441" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span>
</h4>
<div class="docblock">
<p>Converts this string to its ASCII lower case equivalent in-place.</p> <p>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</p> <p>To return a new lowercased value without modifying the existing one, use <a href="#method.to_ascii_lowercase"><code>to_ascii_lowercase</code></a>.</p> <h2 id="examples-91" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let mut s = String::from("GRÜßE, JÜRGEN ❤");

s.make_ascii_lowercase();

assert_eq!("grÜße, jÜrgen ❤", s);</pre></div> </div>
<h4 id="method.escape_debug" class="method">
<code>pub fn <a href="#method.escape_debug" class="fnname">escape_debug</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.escapedebug" title="struct std::str::EscapeDebug">EscapeDebug</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for EscapeDebug&lt;'a&gt;</h3>
<pre class="content">impl&lt;'a&gt; Iterator for EscapeDebug&lt;'a&gt;
    type Item = char;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4478-4488" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span>
</h4>
<div class="docblock">
<p>Return an iterator that escapes each char in <code>self</code> with <a href="../primitive.char#method.escape_debug" title="`char::escape_debug`"><code>char::escape_debug</code></a>.</p> <p>Note: only extended grapheme codepoints that begin the string will be escaped.</p> <h2 id="examples-92" class="section-header">Examples</h2> <p>As an iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
for c in "❤\n!".escape_debug() {
    print!("{}", c);
}
println!();</pre></div> <p>Using <code>println!</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
println!("{}", "❤\n!".escape_debug());</pre></div> <p>Both are equivalent to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
println!("❤\\n!");</pre></div> <p>Using <code>to_string</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("❤\n!".escape_debug().to_string(), "❤\\n!");</pre></div> </div>
<h4 id="method.escape_default" class="method">
<code>pub fn <a href="#method.escape_default" class="fnname">escape_default</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.escapedefault" title="struct std::str::EscapeDefault">EscapeDefault</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for EscapeDefault&lt;'a&gt;</h3>
<pre class="content">impl&lt;'a&gt; Iterator for EscapeDefault&lt;'a&gt;
    type Item = char;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4522-4524" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span>
</h4>
<div class="docblock">
<p>Return an iterator that escapes each char in <code>self</code> with <a href="../primitive.char#method.escape_default" title="`char::escape_default`"><code>char::escape_default</code></a>.</p> <h2 id="examples-93" class="section-header">Examples</h2> <p>As an iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
for c in "❤\n!".escape_default() {
    print!("{}", c);
}
println!();</pre></div> <p>Using <code>println!</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
println!("{}", "❤\n!".escape_default());</pre></div> <p>Both are equivalent to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
println!("\\u{{2764}}\\n!");</pre></div> <p>Using <code>to_string</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("❤\n!".escape_default().to_string(), "\\u{2764}\\n!");</pre></div> </div>
<h4 id="method.escape_unicode" class="method">
<code>pub fn <a href="#method.escape_unicode" class="fnname">escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="../str/struct.escapeunicode" title="struct std::str::EscapeUnicode">EscapeUnicode</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for EscapeUnicode&lt;'a&gt;</h3>
<pre class="content">impl&lt;'a&gt; Iterator for EscapeUnicode&lt;'a&gt;
    type Item = char;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/str/mod.rs.html#4558-4560" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span>
</h4>
<div class="docblock">
<p>Return an iterator that escapes each char in <code>self</code> with <a href="../primitive.char#method.escape_unicode" title="`char::escape_unicode`"><code>char::escape_unicode</code></a>.</p> <h2 id="examples-94" class="section-header">Examples</h2> <p>As an iterator:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
for c in "❤\n!".escape_unicode() {
    print!("{}", c);
}
println!();</pre></div> <p>Using <code>println!</code> directly:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
println!("{}", "❤\n!".escape_unicode());</pre></div> <p>Both are equivalent to:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
println!("\\u{{2764}}\\u{{a}}\\u{{21}}");</pre></div> <p>Using <code>to_string</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("❤\n!".escape_unicode().to_string(), "\\u{2764}\\u{a}\\u{21}");</pre></div> </div>
<h4 id="method.replace" class="method">
<code><span class="docblock attributes">#[must_use =
  "this returns the replaced string as a new allocation, \
                  without modifying the original"]</span>pub fn <a href="#method.replace" class="fnname">replace</a>&lt;'a, P&gt;(&amp;'a self, from: P, to: &amp;<a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#263-273" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Replaces all matches of a pattern with another string.</p> <p><code>replace</code> creates a new <a href="struct.string" title="`String`"><code>String</code></a>, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice.</p> <h2 id="examples-95" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "this is old";

assert_eq!("this is new", s.replace("old", "new"));</pre></div> <p>When the pattern doesn't match:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "this is old";
assert_eq!(s, s.replace("cookie monster", "little lamb"));</pre></div> </div>
<h4 id="method.replacen" class="method">
<code><span class="docblock attributes">#[must_use =
  "this returns the replaced string as a new allocation, \
                  without modifying the original"]</span>pub fn <a href="#method.replacen" class="fnname">replacen</a>&lt;'a, P&gt;(&amp;'a self, pat: P, to: &amp;<a class="primitive" href="../primitive.str">str</a>, count: <a class="primitive" href="../primitive.usize">usize</a>) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a> <span class="where fmt-newline">where<br>    P: <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#301-312" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span>
</h4>
<div class="docblock">
<p>Replaces first N matches of a pattern with another string.</p> <p><code>replacen</code> creates a new <a href="struct.string" title="`String`"><code>String</code></a>, and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice at most <code>count</code> times.</p> <h2 id="examples-96" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "foo foo 123 foo";
assert_eq!("new new 123 foo", s.replacen("foo", "new", 2));
assert_eq!("faa fao 123 foo", s.replacen('o', "a", 3));
assert_eq!("foo foo new23 foo", s.replacen(char::is_numeric, "new", 1));</pre></div> <p>When the pattern doesn't match:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "this is old";
assert_eq!(s, s.replacen("cookie monster", "little lamb", 10));</pre></div> </div>
<h4 id="method.to_lowercase" class="method">
<code>pub fn <a href="#method.to_lowercase" class="fnname">to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#354-397" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span>
</h4>
<div class="docblock">
<p>Returns the lowercase equivalent of this string slice, as a new <a href="struct.string" title="`String`"><code>String</code></a>.</p> <p>'Lowercase' is defined according to the terms of the Unicode Derived Core Property <code>Lowercase</code>.</p> <p>Since some characters can expand into multiple characters when changing the case, this function returns a <a href="struct.string" title="`String`"><code>String</code></a> instead of modifying the parameter in-place.</p> <h2 id="examples-97" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "HELLO";

assert_eq!("hello", s.to_lowercase());</pre></div> <p>A tricky example, with sigma:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let sigma = "Σ";

assert_eq!("σ", sigma.to_lowercase());

// but at the end of a word, it's ς, not σ:
let odysseus = "ὈΔΥΣΣΕΎΣ";

assert_eq!("ὀδυσσεύς", odysseus.to_lowercase());</pre></div> <p>Languages without case are not changed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let new_year = "农历新年";

assert_eq!(new_year, new_year.to_lowercase());</pre></div> </div>
<h4 id="method.to_uppercase" class="method">
<code>pub fn <a href="#method.to_uppercase" class="fnname">to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#433-450" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span>
</h4>
<div class="docblock">
<p>Returns the uppercase equivalent of this string slice, as a new <a href="struct.string" title="`String`"><code>String</code></a>.</p> <p>'Uppercase' is defined according to the terms of the Unicode Derived Core Property <code>Uppercase</code>.</p> <p>Since some characters can expand into multiple characters when changing the case, this function returns a <a href="struct.string" title="`String`"><code>String</code></a> instead of modifying the parameter in-place.</p> <h2 id="examples-98" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "hello";

assert_eq!("HELLO", s.to_uppercase());</pre></div> <p>Scripts without case are not changed:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let new_year = "农历新年";

assert_eq!(new_year, new_year.to_uppercase());</pre></div> <p>One character can become multiple:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "tschüß";

assert_eq!("TSCHÜSS", s.to_uppercase());</pre></div> </div>
<h4 id="method.repeat" class="method">
<code>pub fn <a href="#method.repeat" class="fnname">repeat</a>(&amp;self, n: <a class="primitive" href="../primitive.usize">usize</a>) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#494-496" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span>
</h4>
<div class="docblock">
<p>Creates a new <a href="struct.string" title="`String`"><code>String</code></a> by repeating a string <code>n</code> times.</p> <h2 id="panics-11" class="section-header">Panics</h2> <p>This function will panic if the capacity would overflow.</p> <h2 id="examples-99" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!("abc".repeat(4), String::from("abcabcabcabc"));</pre></div> <p>A panic upon overflow:</p> <div class="information">ⓘThis example panics</div>
<div class="example-wrap"><pre class="rust rust-example-rendered should_panic" data-language="rust">
// this will panic at runtime
"0123456789abcdef".repeat(usize::MAX);</pre></div> </div>
<h4 id="method.to_ascii_uppercase" class="method">
<code>pub fn <a href="#method.to_ascii_uppercase" class="fnname">to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#521-526" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span>
</h4>
<div class="docblock">
<p>Returns a copy of this string where each character is mapped to its ASCII upper case equivalent.</p> <p>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</p> <p>To uppercase the value in-place, use <a href="../primitive.str#method.make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p> <p>To uppercase ASCII characters in addition to non-ASCII characters, use <a href="#method.to_uppercase"><code>to_uppercase</code></a>.</p> <h2 id="examples-100" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Grüße, Jürgen ❤";

assert_eq!("GRüßE, JüRGEN ❤", s.to_ascii_uppercase());</pre></div> </div>
<h4 id="method.to_ascii_lowercase" class="method">
<code>pub fn <a href="#method.to_ascii_lowercase" class="fnname">to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#551-556" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span>
</h4>
<div class="docblock">
<p>Returns a copy of this string where each character is mapped to its ASCII lower case equivalent.</p> <p>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</p> <p>To lowercase the value in-place, use <a href="../primitive.str#method.make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p> <p>To lowercase ASCII characters in addition to non-ASCII characters, use <a href="#method.to_lowercase"><code>to_lowercase</code></a>.</p> <h2 id="examples-101" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s = "Grüße, Jürgen ❤";

assert_eq!("grüße, jürgen ❤", s.to_ascii_lowercase());</pre></div> </div>
<h2 id="trait-implementations" class="small-section-header">Trait Implementations</h2>
<div id="trait-implementations-list">
<h3 id="impl-Add%3C%26%27_%20str%3E" class="impl">
<code class="in-band">impl&lt;'_&gt; <a class="trait" href="../ops/trait.add" title="trait std::ops::Add">Add</a>&lt;&amp;'_ <a class="primitive" href="../primitive.str">str</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2012-2020" title="goto source code">[src]</a>
</h3>
<div class="docblock">
<p>Implements the <code>+</code> operator for concatenating two strings.</p> <p>This consumes the <code>String</code> on the left-hand side and re-uses its buffer (growing it if necessary). This is done to avoid allocating a new <code>String</code> and copying the entire contents on every operation, which would lead to <em>O</em>(<em>n</em>^2) running time when building an <em>n</em>-byte string by repeated concatenation.</p> <p>The string on the right-hand side is only borrowed; its contents are copied into the returned <code>String</code>.</p> <h2 id="examples-105" class="section-header">Examples</h2> <p>Concatenating two <code>String</code>s takes the first by value and borrows the second:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let a = String::from("hello");
let b = String::from(" world");
let c = a + &amp;b;
// `a` is moved and can no longer be used here.</pre></div> <p>If you want to keep using the first <code>String</code>, you can clone it and append to the clone instead:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let a = String::from("hello");
let b = String::from(" world");
let c = a.clone() + &amp;b;
// `a` is still valid here.</pre></div> <p>Concatenating <code>&amp;str</code> slices can be done by converting the first to a <code>String</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let a = "hello";
let b = " world";
let c = a.to_string() + b;</pre></div> </div>
<div class="impl-items">
<h4 id="associatedtype.Output" class="type"><code>type <a href="../ops/trait.add#associatedtype.Output" class="type">Output</a> = <a class="struct" href="struct.string" title="struct std::string::String">String</a></code></h4>
<div class="docblock">
<p>The resulting type after applying the <code>+</code> operator.</p> </div>
<h4 id="method.add" class="method hidden">
<code>fn <a href="../ops/trait.add#tymethod.add" class="fnname">add</a>(self, other: &amp;<a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2016-2019" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the <code>+</code> operation.</p> </div>
</div>
<h3 id="impl-AddAssign%3C%26%27_%20str%3E" class="impl">
<code class="in-band">impl&lt;'_&gt; <a class="trait" href="../ops/trait.addassign" title="trait std::ops::AddAssign">AddAssign</a>&lt;&amp;'_ <a class="primitive" href="../primitive.str">str</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2026-2031" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span>
</h3>
<div class="docblock">
<p>Implements the <code>+=</code> operator for appending to a <code>String</code>.</p> <p>This has the same behavior as the <a href="struct.string#method.push_str" title="String::push_str"><code>push_str</code></a> method.</p> </div>
<div class="impl-items">
<h4 id="method.add_assign" class="method hidden">
<code>fn <a href="../ops/trait.addassign#tymethod.add_assign" class="fnname">add_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="../primitive.str">str</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2028-2030" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the <code>+=</code> operation.</p> </div>
</div>
<h3 id="impl-AsMut%3Cstr%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.asmut" title="trait std::convert::AsMut">AsMut</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2256-2261" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span>
</h3>
<div class="impl-items">
<h4 id="method.as_mut" class="method hidden">
<code>fn <a href="../convert/trait.asmut#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2258-2260" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-AsRef%3C%5Bu8%5D%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.asref" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="../primitive.slice">[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2264-2269" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.as_ref-1" class="method hidden">
<code>fn <a href="../convert/trait.asref#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.slice">&amp;[</a><a class="primitive" href="../primitive.u8">u8</a><a class="primitive" href="../primitive.slice">]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ [u8]</h3>
<pre class="content">impl&lt;'_&gt; Read for &amp;'_ [u8]
impl&lt;'_&gt; Write for &amp;'_ mut [u8]
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2266-2268" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-AsRef%3COsStr%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.asref" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../ffi/struct.osstr" title="struct std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1114-1119" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.as_ref-2" class="method hidden">
<code>fn <a href="../convert/trait.asref#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../ffi/struct.osstr" title="struct std::ffi::OsStr">OsStr</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#1116-1118" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-AsRef%3CPath%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.asref" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../path/struct.path" title="struct std::path::Path">Path</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/path.rs.html#2604-2608" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.as_ref-3" class="method hidden">
<code>fn <a href="../convert/trait.asref#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../path/struct.path" title="struct std::path::Path">Path</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/path.rs.html#2605-2607" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-AsRef%3Cstr%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.asref" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2248-2253" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.as_ref" class="method hidden">
<code>fn <a href="../convert/trait.asref#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2250-2252" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-Borrow%3Cstr%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../borrow/trait.borrow" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#185-190" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.borrow" class="method hidden">
<code>fn <a href="../borrow/trait.borrow#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#187-189" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Immutably borrows from an owned value. <a href="../borrow/trait.borrow#tymethod.borrow">Read more</a></p> </div>
</div>
<h3 id="impl-BorrowMut%3Cstr%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../borrow/trait.borrowmut" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#193-198" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span>
</h3>
<div class="impl-items">
<h4 id="method.borrow_mut" class="method hidden">
<code>fn <a href="../borrow/trait.borrowmut#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/str.rs.html#195-197" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Mutably borrows from an owned value. <a href="../borrow/trait.borrowmut#tymethod.borrow_mut">Read more</a></p> </div>
</div>
<h3 id="impl-Clone" class="impl">
<code class="in-band">impl <a class="trait" href="../clone/trait.clone" title="trait std::clone::Clone">Clone</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1685-1693" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.clone" class="method hidden">
<code>fn <a href="../clone/trait.clone#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1686-1688" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Returns a copy of the value. <a href="../clone/trait.clone#tymethod.clone">Read more</a></p> </div>
<h4 id="method.clone_from" class="method hidden">
<code>fn <a href="../clone/trait.clone#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1690-1692" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs copy-assignment from <code>source</code>. <a href="../clone/trait.clone#method.clone_from">Read more</a></p> </div>
</div>
<h3 id="impl-Debug" class="impl">
<code class="in-band">impl <a class="trait" href="../fmt/trait.debug" title="trait std::fmt::Debug">Debug</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1959-1964" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.fmt" class="method hidden">
<code>fn <a href="../fmt/trait.debug#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../fmt/struct.formatter" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>, <a class="struct" href="../fmt/struct.error" title="struct std::fmt::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1961-1963" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Formats the value using the given formatter. <a href="../fmt/trait.debug#tymethod.fmt">Read more</a></p> </div>
</div>
<h3 id="impl-Default" class="impl">
<code class="in-band">impl <a class="trait" href="../default/trait.default" title="trait std::default::Default">Default</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1942-1948" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.default" class="method">
<code>fn <a href="../default/trait.default#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1945-1947" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Creates an empty <code>String</code>.</p> </div>
</div>
<h3 id="impl-Deref" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.deref" title="trait std::ops::Deref">Deref</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2132-2139" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Target" class="type"><code>type <a href="../ops/trait.deref#associatedtype.Target" class="type">Target</a> = <a class="primitive" href="../primitive.str">str</a></code></h4>
<div class="docblock">
<p>The resulting type after dereferencing.</p> </div>
<h4 id="method.deref" class="method hidden">
<code>fn <a href="../ops/trait.deref#tymethod.deref" class="fnname">deref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2136-2138" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Dereferences the value.</p> </div>
</div>
<h3 id="impl-DerefMut" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.derefmut" title="trait std::ops::DerefMut">DerefMut</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2142-2147" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span>
</h3>
<div class="impl-items">
<h4 id="method.deref_mut" class="method hidden">
<code>fn <a href="../ops/trait.derefmut#tymethod.deref_mut" class="fnname">deref_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2144-2146" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Mutably dereferences the value.</p> </div>
</div>
<h3 id="impl-Display" class="impl">
<code class="in-band">impl <a class="trait" href="../fmt/trait.display" title="trait std::fmt::Display">Display</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1951-1956" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.fmt-1" class="method hidden">
<code>fn <a href="../fmt/trait.display#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../fmt/struct.formatter" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>, <a class="struct" href="../fmt/struct.error" title="struct std::fmt::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1953-1955" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Formats the value using the given formatter. <a href="../fmt/trait.display#tymethod.fmt">Read more</a></p> </div>
</div>
<h3 id="impl-Eq" class="impl">
<code class="in-band">impl <a class="trait" href="../cmp/trait.eq" title="trait std::cmp::Eq">Eq</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#275" title="goto source code">[src]</a>
</h3>

<h3 id="impl-Extend%3C%26%27a%20char%3E" class="impl">
<code class="in-band">impl&lt;'a&gt; <a class="trait" href="../iter/trait.extend" title="trait std::iter::Extend">Extend</a>&lt;&amp;'a <a class="primitive" href="../primitive.char">char</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1789-1803" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span>
</h3>
<div class="impl-items">
<h4 id="method.extend-5" class="method hidden">
<code>fn <a href="../iter/trait.extend#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br>    I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="../primitive.char">char</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1790-1792" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Extends a collection with the contents of an iterator. <a href="../iter/trait.extend#tymethod.extend">Read more</a></p> </div>
<h4 id="method.extend_one-5" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, &amp;'a <a class="primitive" href="../primitive.char">char</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1795-1797" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Extends a collection with exactly one element.</p> </div>
<h4 id="method.extend_reserve-5" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1800-1802" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Reserves capacity in a collection for the given number of additional elements. <a href="../iter/trait.extend#method.extend_reserve">Read more</a></p> </div>
</div>
<h3 id="impl-Extend%3C%26%27a%20str%3E" class="impl">
<code class="in-band">impl&lt;'a&gt; <a class="trait" href="../iter/trait.extend" title="trait std::iter::Extend">Extend</a>&lt;&amp;'a <a class="primitive" href="../primitive.str">str</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1806-1815" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.extend" class="method hidden">
<code>fn <a href="../iter/trait.extend#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br>    I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="../primitive.str">str</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1807-1809" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Extends a collection with the contents of an iterator. <a href="../iter/trait.extend#tymethod.extend">Read more</a></p> </div>
<h4 id="method.extend_one" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, s: &amp;'a <a class="primitive" href="../primitive.str">str</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1812-1814" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Extends a collection with exactly one element.</p> </div>
<h4 id="method.extend_reserve" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/iter/traits/collect.rs.html#356-358" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Reserves capacity in a collection for the given number of additional elements. <a href="../iter/trait.extend#method.extend_reserve">Read more</a></p> </div>
</div>
<h3 id="impl-Extend%3CBox%3Cstr%3E%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../iter/trait.extend" title="trait std::iter::Extend">Extend</a>&lt;<a class="struct" href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1818-1822" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span>
</h3>
<div class="impl-items">
<h4 id="method.extend-3" class="method hidden">
<code>fn <a href="../iter/trait.extend#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br>    I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="struct" href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1819-1821" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Extends a collection with the contents of an iterator. <a href="../iter/trait.extend#tymethod.extend">Read more</a></p> </div>
<h4 id="method.extend_one-3" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, item: A)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/iter/traits/collect.rs.html#348-350" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Extends a collection with exactly one element.</p> </div>
<h4 id="method.extend_reserve-3" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/iter/traits/collect.rs.html#356-358" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Reserves capacity in a collection for the given number of additional elements. <a href="../iter/trait.extend#method.extend_reserve">Read more</a></p> </div>
</div>
<h3 id="impl-Extend%3CCow%3C%27a%2C%20str%3E%3E" class="impl">
<code class="in-band">impl&lt;'a&gt; <a class="trait" href="../iter/trait.extend" title="trait std::iter::Extend">Extend</a>&lt;<a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1837-1846" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.19.0">1.19.0</span>
</h3>
<div class="impl-items">
<h4 id="method.extend-1" class="method hidden">
<code>fn <a href="../iter/trait.extend#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br>    I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1838-1840" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Extends a collection with the contents of an iterator. <a href="../iter/trait.extend#tymethod.extend">Read more</a></p> </div>
<h4 id="method.extend_one-1" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, s: <a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1843-1845" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Extends a collection with exactly one element.</p> </div>
<h4 id="method.extend_reserve-1" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/iter/traits/collect.rs.html#356-358" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Reserves capacity in a collection for the given number of additional elements. <a href="../iter/trait.extend#method.extend_reserve">Read more</a></p> </div>
</div>
<h3 id="impl-Extend%3CString%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../iter/trait.extend" title="trait std::iter::Extend">Extend</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1825-1834" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span>
</h3>
<div class="impl-items">
<h4 id="method.extend-2" class="method hidden">
<code>fn <a href="../iter/trait.extend#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br>    I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1826-1828" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Extends a collection with the contents of an iterator. <a href="../iter/trait.extend#tymethod.extend">Read more</a></p> </div>
<h4 id="method.extend_one-2" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, s: <a class="struct" href="struct.string" title="struct std::string::String">String</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1831-1833" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Extends a collection with exactly one element.</p> </div>
<h4 id="method.extend_reserve-2" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/core/iter/traits/collect.rs.html#356-358" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Reserves capacity in a collection for the given number of additional elements. <a href="../iter/trait.extend#method.extend_reserve">Read more</a></p> </div>
</div>
<h3 id="impl-Extend%3Cchar%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../iter/trait.extend" title="trait std::iter::Extend">Extend</a>&lt;<a class="primitive" href="../primitive.char">char</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1769-1786" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.extend-4" class="method hidden">
<code>fn <a href="../iter/trait.extend#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br>    I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="../primitive.char">char</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1770-1775" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Extends a collection with the contents of an iterator. <a href="../iter/trait.extend#tymethod.extend">Read more</a></p> </div>
<h4 id="method.extend_one-4" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, c: <a class="primitive" href="../primitive.char">char</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1778-1780" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Extends a collection with exactly one element.</p> </div>
<h4 id="method.extend_reserve-4" class="method hidden">
<code>fn <a href="../iter/trait.extend#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize">usize</a>)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1783-1785" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (extend_one #72631)</span></div>
<div class="docblock hidden">
<p>Reserves capacity in a collection for the given number of additional elements. <a href="../iter/trait.extend#method.extend_reserve">Read more</a></p> </div>
</div>
<h3 id="impl-From%3C%26%27_%20String%3E" class="impl">
<code class="in-band">impl&lt;'_&gt; <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;&amp;'_ <a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2291-2296" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.35.0">1.35.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from" class="method hidden">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(s: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2293-2295" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-From%3C%26%27_%20mut%20str%3E" class="impl">
<code class="in-band">impl&lt;'_&gt; <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;&amp;'_ mut <a class="primitive" href="../primitive.str">str</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2280-2288" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from-6" class="method">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(s: &amp;mut <a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2285-2287" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts a <code>&amp;mut str</code> into a <code>String</code>.</p> <p>The result is allocated on the heap.</p> </div>
</div>
<h3 id="impl-From%3C%26%27_%20str%3E" class="impl">
<code class="in-band">impl&lt;'_&gt; <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;&amp;'_ <a class="primitive" href="../primitive.str">str</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2272-2277" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.from-2" class="method hidden">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(s: &amp;<a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2274-2276" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-From%3C%26%27a%20String%3E" class="impl">
<code class="in-band">impl&lt;'a&gt; <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;&amp;'a <a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2365-2370" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from-9" class="method hidden">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(s: &amp;'a <a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2367-2369" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-From%3CBox%3Cstr%3E%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="struct" href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2301-2319" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.18.0">1.18.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from-8" class="method">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(s: <a class="struct" href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2316-2318" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts the given boxed <code>str</code> slice to a <code>String</code>. It is notable that the <code>str</code> slice is owned.</p> <h2 id="examples-104" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s1: String = String::from("hello world");
let s2: Box&lt;str&gt; = s1.into_boxed_str();
let s3: String = String::from(s2);

assert_eq!("hello world", s3)</pre></div> </div>
</div>
<h3 id="impl-From%3CCow%3C%27a%2C%20str%3E%3E" class="impl">
<code class="in-band">impl&lt;'a&gt; <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2342-2346" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from-7" class="method hidden">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(s: <a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2343-2345" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-From%3CString%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="struct" href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2322-2339" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from-1" class="method">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(s: <a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="struct" href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Box&lt;F&gt;</h3>
<pre class="content">impl&lt;F&gt; Future for Box&lt;F&gt; where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;I&gt; Iterator for Box&lt;I&gt; where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized&gt; Read for Box&lt;R&gt;
impl&lt;W: Write + ?Sized&gt; Write for Box&lt;W&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2336-2338" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts the given <code>String</code> to a boxed <code>str</code> slice that is owned.</p> <h2 id="examples-102" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s1: String = String::from("hello world");
let s2: Box&lt;str&gt; = Box::from(s1);
let s3: String = String::from(s2);

assert_eq!("hello world", s3)</pre></div> </div>
</div>
<h3 id="impl-From%3CString%3E-1" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2394-2412" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from-3" class="method">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(string: <a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="struct" href="../vec/struct.vec" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8">u8</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Vec&lt;u8&gt;</h3>
<pre class="content">impl Write for Vec&lt;u8&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2409-2411" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts the given <code>String</code> to a vector <code>Vec</code> that holds values of type <code>u8</code>.</p> <h2 id="examples-103" class="section-header">Examples</h2> <p>Basic usage:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
let s1 = String::from("hello world");
let v1 = Vec::from(s1);

for b in v1 {
    println!("{}", b);
}</pre></div> </div>
</div>
<h3 id="impl-From%3CString%3E-2" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="struct" href="../sync/struct.arc" title="struct std::sync::Arc">Arc</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2180-2185" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from-4" class="method hidden">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(v: <a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="struct" href="../sync/struct.arc" title="struct std::sync::Arc">Arc</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/sync.rs.html#2182-2184" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-From%3CString%3E-3" class="impl">
<code class="in-band">impl&lt;'a&gt; <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2357-2362" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.from-10" class="method hidden">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(s: <a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2359-2361" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-From%3CString%3E-4" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="struct" href="../rc/struct.rc" title="struct std::rc::Rc">Rc</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1474-1479" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from-11" class="method hidden">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(v: <a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="struct" href="../rc/struct.rc" title="struct std::rc::Rc">Rc</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/rc.rs.html#1476-1478" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-From%3CString%3E-5" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="struct" href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;dyn <a class="trait" href="../error/trait.error" title="trait std::error::Error">Error</a> + <a class="trait" href="../marker/trait.send" title="trait std::marker::Send">Send</a> + <a class="trait" href="../marker/trait.sync" title="trait std::marker::Sync">Sync</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/error.rs.html#232-272" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.from-12" class="method">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(err: <a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="struct" href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;dyn <a class="trait" href="../error/trait.error" title="trait std::error::Error">Error</a> + <a class="trait" href="../marker/trait.send" title="trait std::marker::Send">Send</a> + <a class="trait" href="../marker/trait.sync" title="trait std::marker::Sync">Sync</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Box&lt;F&gt;</h3>
<pre class="content">impl&lt;F&gt; Future for Box&lt;F&gt; where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;I&gt; Iterator for Box&lt;I&gt; where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized&gt; Read for Box&lt;R&gt;
impl&lt;W: Write + ?Sized&gt; Write for Box&lt;W&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/error.rs.html#247-271" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts a <a href="struct.string" title="`String`"><code>String</code></a> into a box of dyn <a href="../error/trait.error" title="`Error`"><code>Error</code></a> + <a href="../marker/trait.send" title="`Send`"><code>Send</code></a> + <a href="../marker/trait.sync" title="`Sync`"><code>Sync</code></a>.</p> <h2 id="examples-107" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::error::Error;
use std::mem;

let a_string_error = "a string error".to_string();
let a_boxed_error = Box::&lt;dyn Error + Send + Sync&gt;::from(a_string_error);
assert!(
    mem::size_of::&lt;Box&lt;dyn Error + Send + Sync&gt;&gt;() == mem::size_of_val(&amp;a_boxed_error))</pre></div> </div>
</div>
<h3 id="impl-From%3CString%3E-6" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="struct" href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;dyn <a class="trait" href="../error/trait.error" title="trait std::error::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/error.rs.html#275-293" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from-13" class="method">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(str_err: <a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="struct" href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;dyn <a class="trait" href="../error/trait.error" title="trait std::error::Error">Error</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for Box&lt;F&gt;</h3>
<pre class="content">impl&lt;F&gt; Future for Box&lt;F&gt; where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;I&gt; Iterator for Box&lt;I&gt; where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized&gt; Read for Box&lt;R&gt;
impl&lt;W: Write + ?Sized&gt; Write for Box&lt;W&gt;
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/std/error.rs.html#288-292" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts a <a href="struct.string" title="`String`"><code>String</code></a> into a box of dyn <a href="../error/trait.error" title="`Error`"><code>Error</code></a>.</p> <h2 id="examples-108" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
use std::error::Error;
use std::mem;

let a_string_error = "a string error".to_string();
let a_boxed_error = Box::&lt;dyn Error&gt;::from(a_string_error);
assert!(mem::size_of::&lt;Box&lt;dyn Error&gt;&gt;() == mem::size_of_val(&amp;a_boxed_error))</pre></div> </div>
</div>
<h3 id="impl-From%3CString%3E-7" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="struct" href="../ffi/struct.osstring" title="struct std::ffi::OsString">OsString</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#338-345" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.from-14" class="method">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(s: <a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="struct" href="../ffi/struct.osstring" title="struct std::ffi::OsString">OsString</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/ffi/os_str.rs.html#342-344" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts a <a href="struct.string" title="`String`"><code>String</code></a> into a <a href="../ffi/struct.osstring" title="`OsString`"><code>OsString</code></a>.</p> <p>The conversion copies the data, and includes an allocation on the heap.</p> </div>
</div>
<h3 id="impl-From%3CString%3E-8" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="struct" href="../path/struct.pathbuf" title="struct std::path::PathBuf">PathBuf</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/path.rs.html#1456-1463" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.from-15" class="method">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(s: <a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="struct" href="../path/struct.pathbuf" title="struct std::path::PathBuf">PathBuf</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/path.rs.html#1460-1462" title="goto source code">[src]</a>
</h4>
<div class="docblock">
<p>Converts a <code>String</code> into a <code>PathBuf</code></p> <p>This conversion does not allocate or copy memory.</p> </div>
</div>
<h3 id="impl-From%3Cchar%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="../primitive.char">char</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2504-2509" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.46.0">1.46.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from-5" class="method hidden">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(c: <a class="primitive" href="../primitive.char">char</a>) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2506-2508" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-FromIterator%3C%26%27a%20char%3E" class="impl">
<code class="in-band">impl&lt;'a&gt; <a class="trait" href="../iter/trait.fromiterator" title="trait std::iter::FromIterator">FromIterator</a>&lt;&amp;'a <a class="primitive" href="../primitive.char">char</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1705-1711" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from_iter-6" class="method hidden">
<code>fn <a href="../iter/trait.fromiterator#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a> <span class="where fmt-newline">where<br>    I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="../primitive.char">char</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1706-1710" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a value from an iterator. <a href="../iter/trait.fromiterator#tymethod.from_iter">Read more</a></p> </div>
</div>
<h3 id="impl-FromIterator%3C%26%27a%20str%3E" class="impl">
<code class="in-band">impl&lt;'a&gt; <a class="trait" href="../iter/trait.fromiterator" title="trait std::iter::FromIterator">FromIterator</a>&lt;&amp;'a <a class="primitive" href="../primitive.str">str</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1714-1720" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.from_iter-1" class="method hidden">
<code>fn <a href="../iter/trait.fromiterator#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a> <span class="where fmt-newline">where<br>    I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="../primitive.str">str</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1715-1719" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a value from an iterator. <a href="../iter/trait.fromiterator#tymethod.from_iter">Read more</a></p> </div>
</div>
<h3 id="impl-FromIterator%3CBox%3Cstr%3E%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../iter/trait.fromiterator" title="trait std::iter::FromIterator">FromIterator</a>&lt;<a class="struct" href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1741-1747" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from_iter-5" class="method hidden">
<code>fn <a href="../iter/trait.fromiterator#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a> <span class="where fmt-newline">where<br>    I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="struct" href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt;&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1742-1746" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a value from an iterator. <a href="../iter/trait.fromiterator#tymethod.from_iter">Read more</a></p> </div>
</div>
<h3 id="impl-FromIterator%3CCow%3C%27a%2C%20str%3E%3E" class="impl">
<code class="in-band">impl&lt;'a&gt; <a class="trait" href="../iter/trait.fromiterator" title="trait std::iter::FromIterator">FromIterator</a>&lt;<a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1750-1766" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.19.0">1.19.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from_iter" class="method hidden">
<code>fn <a href="../iter/trait.fromiterator#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a> <span class="where fmt-newline">where<br>    I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1751-1765" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a value from an iterator. <a href="../iter/trait.fromiterator#tymethod.from_iter">Read more</a></p> </div>
</div>
<h3 id="impl-FromIterator%3CString%3E" class="impl">
<code class="in-band">impl&lt;'a&gt; <a class="trait" href="../iter/trait.fromiterator" title="trait std::iter::FromIterator">FromIterator</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2387-2391" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from_iter-2" class="method hidden">
<code>fn <a href="../iter/trait.fromiterator#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(it: I) -&gt; <a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt; <span class="where fmt-newline">where<br>    I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2388-2390" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a value from an iterator. <a href="../iter/trait.fromiterator#tymethod.from_iter">Read more</a></p> </div>
</div>
<h3 id="impl-FromIterator%3CString%3E-1" class="impl">
<code class="in-band">impl <a class="trait" href="../iter/trait.fromiterator" title="trait std::iter::FromIterator">FromIterator</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1723-1738" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span>
</h3>
<div class="impl-items">
<h4 id="method.from_iter-3" class="method hidden">
<code>fn <a href="../iter/trait.fromiterator#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a> <span class="where fmt-newline">where<br>    I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1724-1737" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a value from an iterator. <a href="../iter/trait.fromiterator#tymethod.from_iter">Read more</a></p> </div>
</div>
<h3 id="impl-FromIterator%3Cchar%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../iter/trait.fromiterator" title="trait std::iter::FromIterator">FromIterator</a>&lt;<a class="primitive" href="../primitive.char">char</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1696-1702" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.from_iter-4" class="method hidden">
<code>fn <a href="../iter/trait.fromiterator#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a> <span class="where fmt-newline">where<br>    I: <a class="trait" href="../iter/trait.intoiterator" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="../primitive.char">char</a>&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1697-1701" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates a value from an iterator. <a href="../iter/trait.fromiterator#tymethod.from_iter">Read more</a></p> </div>
</div>
<h3 id="impl-FromStr" class="impl">
<code class="in-band">impl <a class="trait" href="../str/trait.fromstr" title="trait std::str::FromStr">FromStr</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2158-2164" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Err" class="type"><code>type <a href="../str/trait.fromstr#associatedtype.Err" class="type">Err</a> = <a class="enum" href="../convert/enum.infallible" title="enum std::convert::Infallible">Infallible</a></code></h4>
<div class="docblock">
<p>The associated error which can be returned from parsing.</p> </div>
<h4 id="method.from_str" class="method hidden">
<code>fn <a href="../str/trait.fromstr#tymethod.from_str" class="fnname">from_str</a>(s: &amp;<a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>, &lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a> as <a class="trait" href="../str/trait.fromstr" title="trait std::str::FromStr">FromStr</a>&gt;::<a class="type" href="../str/trait.fromstr#associatedtype.Err" title="type std::str::FromStr::Err">Err</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2161-2163" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Parses a string <code>s</code> to return a value of this type. <a href="../str/trait.fromstr#tymethod.from_str">Read more</a></p> </div>
</div>
<h3 id="impl-Hash" class="impl">
<code class="in-band">impl <a class="trait" href="../hash/trait.hash" title="trait std::hash::Hash">Hash</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1967-1972" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.hash" class="method hidden">
<code>fn <a href="../hash/trait.hash#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, hasher: <a class="primitive" href="../primitive.reference">&amp;mut </a>H) <span class="where fmt-newline">where<br>    H: <a class="trait" href="../hash/trait.hasher" title="trait std::hash::Hasher">Hasher</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1969-1971" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Feeds this value into the given [<code>Hasher</code>]. <a href="../hash/trait.hash#tymethod.hash">Read more</a></p> </div>
<h4 id="method.hash_slice" class="method hidden">
<code>fn <a href="../hash/trait.hash#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="../primitive.slice">&amp;[Self]</a>, state: <a class="primitive" href="../primitive.reference">&amp;mut </a>H) <span class="where fmt-newline">where<br>    H: <a class="trait" href="../hash/trait.hasher" title="trait std::hash::Hasher">Hasher</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#192-199" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span>
</h4>
<div class="docblock hidden">
<p>Feeds a slice of this type into the given [<code>Hasher</code>]. <a href="../hash/trait.hash#method.hash_slice">Read more</a></p> </div>
</div>
<h3 id="impl-Index%3CRange%3Cusize%3E%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.index" title="trait std::ops::Index">Index</a>&lt;<a class="struct" href="../ops/struct.range" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2034-2041" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Output-4" class="type"><code>type <a href="../ops/trait.index#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../primitive.str">str</a></code></h4>
<div class="docblock">
<p>The returned type after indexing.</p> </div>
<h4 id="method.index-3" class="method hidden">
<code>fn <a href="../ops/trait.index#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="../ops/struct.range" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2038-2040" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-Index%3CRangeFrom%3Cusize%3E%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.index" title="trait std::ops::Index">Index</a>&lt;<a class="struct" href="../ops/struct.rangefrom" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2052-2059" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Output-2" class="type"><code>type <a href="../ops/trait.index#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../primitive.str">str</a></code></h4>
<div class="docblock">
<p>The returned type after indexing.</p> </div>
<h4 id="method.index-1" class="method hidden">
<code>fn <a href="../ops/trait.index#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="../ops/struct.rangefrom" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2056-2058" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-Index%3CRangeFull%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.index" title="trait std::ops::Index">Index</a>&lt;<a class="struct" href="../ops/struct.rangefull" title="struct std::ops::RangeFull">RangeFull</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2061-2068" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Output-5" class="type"><code>type <a href="../ops/trait.index#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../primitive.str">str</a></code></h4>
<div class="docblock">
<p>The returned type after indexing.</p> </div>
<h4 id="method.index-4" class="method hidden">
<code>fn <a href="../ops/trait.index#tymethod.index" class="fnname">index</a>(&amp;self, _index: <a class="struct" href="../ops/struct.rangefull" title="struct std::ops::RangeFull">RangeFull</a>) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2065-2067" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-Index%3CRangeInclusive%3Cusize%3E%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.index" title="trait std::ops::Index">Index</a>&lt;<a class="struct" href="../ops/struct.rangeinclusive" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2070-2077" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Output-3" class="type"><code>type <a href="../ops/trait.index#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../primitive.str">str</a></code></h4>
<div class="docblock">
<p>The returned type after indexing.</p> </div>
<h4 id="method.index-2" class="method hidden">
<code>fn <a href="../ops/trait.index#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="../ops/struct.rangeinclusive" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2074-2076" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-Index%3CRangeTo%3Cusize%3E%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.index" title="trait std::ops::Index">Index</a>&lt;<a class="struct" href="../ops/struct.rangeto" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2043-2050" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Output-1" class="type"><code>type <a href="../ops/trait.index#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../primitive.str">str</a></code></h4>
<div class="docblock">
<p>The returned type after indexing.</p> </div>
<h4 id="method.index" class="method hidden">
<code>fn <a href="../ops/trait.index#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="../ops/struct.rangeto" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2047-2049" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-Index%3CRangeToInclusive%3Cusize%3E%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.index" title="trait std::ops::Index">Index</a>&lt;<a class="struct" href="../ops/struct.rangetoinclusive" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2079-2086" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Output-6" class="type"><code>type <a href="../ops/trait.index#associatedtype.Output" class="type">Output</a> = <a class="primitive" href="../primitive.str">str</a></code></h4>
<div class="docblock">
<p>The returned type after indexing.</p> </div>
<h4 id="method.index-5" class="method hidden">
<code>fn <a href="../ops/trait.index#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="../ops/struct.rangetoinclusive" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;) -&gt; &amp;<a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2083-2085" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-IndexMut%3CRange%3Cusize%3E%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.indexmut" title="trait std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../ops/struct.range" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2089-2094" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span>
</h3>
<div class="impl-items">
<h4 id="method.index_mut-5" class="method hidden">
<code>fn <a href="../ops/trait.indexmut#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="../ops/struct.range" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2091-2093" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the mutable indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-IndexMut%3CRangeFrom%3Cusize%3E%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.indexmut" title="trait std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../ops/struct.rangefrom" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2103-2108" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span>
</h3>
<div class="impl-items">
<h4 id="method.index_mut-2" class="method hidden">
<code>fn <a href="../ops/trait.indexmut#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="../ops/struct.rangefrom" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2105-2107" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the mutable indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-IndexMut%3CRangeFull%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.indexmut" title="trait std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../ops/struct.rangefull" title="struct std::ops::RangeFull">RangeFull</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2110-2115" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span>
</h3>
<div class="impl-items">
<h4 id="method.index_mut-3" class="method hidden">
<code>fn <a href="../ops/trait.indexmut#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, _index: <a class="struct" href="../ops/struct.rangefull" title="struct std::ops::RangeFull">RangeFull</a>) -&gt; &amp;mut <a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2112-2114" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the mutable indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.indexmut" title="trait std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../ops/struct.rangeinclusive" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2117-2122" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span>
</h3>
<div class="impl-items">
<h4 id="method.index_mut-4" class="method hidden">
<code>fn <a href="../ops/trait.indexmut#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="../ops/struct.rangeinclusive" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2119-2121" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the mutable indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-IndexMut%3CRangeTo%3Cusize%3E%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.indexmut" title="trait std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../ops/struct.rangeto" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2096-2101" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span>
</h3>
<div class="impl-items">
<h4 id="method.index_mut-1" class="method hidden">
<code>fn <a href="../ops/trait.indexmut#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="../ops/struct.rangeto" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2098-2100" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the mutable indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../ops/trait.indexmut" title="trait std::ops::IndexMut">IndexMut</a>&lt;<a class="struct" href="../ops/struct.rangetoinclusive" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2124-2129" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span>
</h3>
<div class="impl-items">
<h4 id="method.index_mut" class="method hidden">
<code>fn <a href="../ops/trait.indexmut#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="../ops/struct.rangetoinclusive" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="../primitive.usize">usize</a>&gt;) -&gt; &amp;mut <a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2126-2128" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the mutable indexing (<code>container[index]</code>) operation.</p> </div>
</div>
<h3 id="impl-Ord" class="impl">
<code class="in-band">impl <a class="trait" href="../cmp/trait.ord" title="trait std::cmp::Ord">Ord</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#275" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.cmp" class="method hidden">
<code>fn <a href="../cmp/trait.ord#tymethod.cmp" class="fnname">cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="enum" href="../cmp/enum.ordering" title="enum std::cmp::Ordering">Ordering</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#275" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method returns an [<code>Ordering</code>] between <code>self</code> and <code>other</code>. <a href="../cmp/trait.ord#tymethod.cmp">Read more</a></p> </div>
<h4 id="method.max" class="method hidden">
<code>fn <a href="../cmp/trait.ord#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self</code><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#593-598" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span>
</h4>
<div class="docblock hidden">
<p>Compares and returns the maximum of two values. <a href="../cmp/trait.ord#method.max">Read more</a></p> </div>
<h4 id="method.min" class="method hidden">
<code>fn <a href="../cmp/trait.ord#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self</code><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#613-618" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span>
</h4>
<div class="docblock hidden">
<p>Compares and returns the minimum of two values. <a href="../cmp/trait.ord#method.min">Read more</a></p> </div>
<h4 id="method.clamp" class="method hidden">
<code>fn <a href="../cmp/trait.ord#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self</code><a class="srclink" href="https://doc.rust-lang.org/src/core/cmp.rs.html#640-652" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (clamp #44095)</span></div>
<div class="docblock hidden">
<p>Restrict a value to a certain interval. <a href="../cmp/trait.ord#method.clamp">Read more</a></p> </div>
</div>
<h3 id="impl-PartialEq%3C%26%27a%20str%3E" class="impl">
<code class="in-band">impl&lt;'a, 'b&gt; <a class="trait" href="../cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;&amp;'a <a class="primitive" href="../primitive.str">str</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1909-1918" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.eq" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;&amp;'a <a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1911-1913" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;&amp;'a <a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1915-1917" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<h3 id="impl-PartialEq%3CCow%3C%27a%2C%20str%3E%3E" class="impl">
<code class="in-band">impl&lt;'a, 'b&gt; <a class="trait" href="../cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1922-1931" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.eq-6" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1924-1926" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-6" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1928-1930" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<h3 id="impl-PartialEq%3CString%3E" class="impl">
<code class="in-band">impl&lt;'a, 'b&gt; <a class="trait" href="../cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1922-1931" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.eq-1" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1924-1926" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-1" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1928-1930" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<h3 id="impl-PartialEq%3CString%3E-1" class="impl">
<code class="in-band">impl <a class="trait" href="../cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1894-1903" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.eq-2" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1896-1898" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-2" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1900-1902" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<h3 id="impl-PartialEq%3CString%3E-2" class="impl">
<code class="in-band">impl&lt;'a, 'b&gt; <a class="trait" href="../cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for &amp;'a <a class="primitive" href="../primitive.str">str</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1922-1931" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.eq-3" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1924-1926" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-3" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1928-1930" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<h3 id="impl-PartialEq%3CString%3E-3" class="impl">
<code class="in-band">impl&lt;'a, 'b&gt; <a class="trait" href="../cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="enum" href="../borrow/enum.cow" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1909-1918" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.eq-4" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1911-1913" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-4" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1915-1917" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<h3 id="impl-PartialEq%3Cstr%3E" class="impl">
<code class="in-band">impl&lt;'a, 'b&gt; <a class="trait" href="../cmp/trait.partialeq" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="../primitive.str">str</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1909-1918" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.eq-5" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1911-1913" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../cmp/trait.partialeq#tymethod.eq">Read more</a></p> </div>
<h4 id="method.ne-5" class="method hidden">
<code>fn <a href="../cmp/trait.partialeq#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1915-1917" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests for <code>!=</code>.</p> </div>
</div>
<h3 id="impl-PartialOrd%3CString%3E" class="impl">
<code class="in-band">impl <a class="trait" href="../cmp/trait.partialord" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.string" title="struct std::string::String">String</a>&gt; for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#275" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.partial_cmp" class="method hidden">
<code>fn <a href="../cmp/trait.partialord#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="../cmp/enum.ordering" title="enum std::cmp::Ordering">Ordering</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#275" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a></p> </div>
<h4 id="method.lt" class="method hidden">
<code>fn <a href="../cmp/trait.partialord#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#275" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a></p> </div>
<h4 id="method.le" class="method hidden">
<code>fn <a href="../cmp/trait.partialord#method.le" class="fnname">le</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#275" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a></p> </div>
<h4 id="method.gt" class="method hidden">
<code>fn <a href="../cmp/trait.partialord#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#275" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a></p> </div>
<h4 id="method.ge" class="method hidden">
<code>fn <a href="../cmp/trait.partialord#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;<a class="struct" href="struct.string" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#275" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a></p> </div>
</div>
<h3 id="impl-Pattern%3C%27a%3E" class="impl">
<code class="in-band">impl&lt;'a, 'b&gt; <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt; for &amp;'b <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1860-1891" title="goto source code">[src]</a>
</h3>
<div class="docblock">
<p>A convenience impl that delegates to the impl for <code>&amp;str</code>.</p> <h2 id="examples-106" class="section-header">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">
assert_eq!(String::from("Hello world").find("world"), Some(6));</pre></div> </div>
<div class="impl-items">
<h4 id="associatedtype.Searcher" class="type"><code>type <a href="../str/pattern/trait.pattern#associatedtype.Searcher" class="type">Searcher</a> = &lt;&amp;'b <a class="primitive" href="../primitive.str">str</a> as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a></code></h4>
<div class="stability"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock">
<p>Associated searcher for this pattern</p> </div>
<h4 id="method.into_searcher" class="method hidden">
<code>fn <a href="../str/pattern/trait.pattern#tymethod.into_searcher" class="fnname">into_searcher</a>(self, haystack: &amp;'a <a class="primitive" href="../primitive.str">str</a>) -&gt; &lt;&amp;'b <a class="primitive" href="../primitive.str">str</a> as <a class="trait" href="../str/pattern/trait.pattern" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../str/pattern/trait.pattern#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1863-1865" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock hidden">
<p>Constructs the associated searcher from <code>self</code> and the <code>haystack</code> to search in. <a href="../str/pattern/trait.pattern#tymethod.into_searcher">Read more</a></p> </div>
<h4 id="method.is_contained_in" class="method hidden">
<code>fn <a href="../str/pattern/trait.pattern#method.is_contained_in" class="fnname">is_contained_in</a>(self, haystack: &amp;'a <a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1868-1870" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock hidden">
<p>Checks whether the pattern matches anywhere in the haystack</p> </div>
<h4 id="method.is_prefix_of" class="method hidden">
<code>fn <a href="../str/pattern/trait.pattern#method.is_prefix_of" class="fnname">is_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1873-1875" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock hidden">
<p>Checks whether the pattern matches at the front of the haystack</p> </div>
<h4 id="method.strip_prefix_of" class="method hidden">
<code>fn <a href="../str/pattern/trait.pattern#method.strip_prefix_of" class="fnname">strip_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1878-1880" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock hidden">
<p>Removes the pattern from the front of haystack, if it matches.</p> </div>
<h4 id="method.is_suffix_of" class="method hidden">
<code>fn <a href="../str/pattern/trait.pattern#method.is_suffix_of" class="fnname">is_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="primitive" href="../primitive.bool">bool</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1883-1885" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock hidden">
<p>Checks whether the pattern matches at the back of the haystack</p> </div>
<h4 id="method.strip_suffix_of" class="method hidden">
<code>fn <a href="../str/pattern/trait.pattern#method.strip_suffix_of" class="fnname">strip_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="enum" href="../option/enum.option" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="../primitive.str">str</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#1888-1890" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (pattern #27721)API not fully fleshed out and ready to be stabilized </span></div>
<div class="docblock hidden">
<p>Removes the pattern from the back of haystack, if it matches.</p> </div>
</div>
<h3 id="impl-StructuralEq" class="impl">
<code class="in-band">impl <a class="trait" href="../marker/trait.structuraleq" title="trait std::marker::StructuralEq">StructuralEq</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#275" title="goto source code">[src]</a>
</h3>

<h3 id="impl-ToSocketAddrs" class="impl">
<code class="in-band">impl <a class="trait" href="../net/trait.tosocketaddrs" title="trait std::net::ToSocketAddrs">ToSocketAddrs</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/addr.rs.html#988-993" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Iter" class="type"><code>type <a href="../net/trait.tosocketaddrs#associatedtype.Iter" class="type">Iter</a> = <a class="struct" href="../vec/struct.intoiter" title="struct std::vec::IntoIter">IntoIter</a>&lt;<a class="enum" href="../net/enum.socketaddr" title="enum std::net::SocketAddr">SocketAddr</a>&gt;</code></h4>
<div class="docblock">
<p>Returned iterator over socket addresses which this type may correspond to. <a href="../net/trait.tosocketaddrs#associatedtype.Iter">Read more</a></p> </div>
<h4 id="method.to_socket_addrs" class="method hidden">
<code>fn <a href="../net/trait.tosocketaddrs#tymethod.to_socket_addrs" class="fnname">to_socket_addrs</a>(&amp;self) -&gt; <a class="type" href="../io/type.result" title="type std::io::Result">Result</a>&lt;<a class="struct" href="../vec/struct.intoiter" title="struct std::vec::IntoIter">IntoIter</a>&lt;<a class="enum" href="../net/enum.socketaddr" title="enum std::net::SocketAddr">SocketAddr</a>&gt;&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/std/net/addr.rs.html#990-992" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Converts this object to an iterator of resolved <code>SocketAddr</code>s. <a href="../net/trait.tosocketaddrs#tymethod.to_socket_addrs">Read more</a></p> </div>
</div>
<h3 id="impl-ToString" class="impl">
<code class="in-band">impl <a class="trait" href="trait.tostring" title="trait std::string::ToString">ToString</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2240-2245" title="goto source code">[src]</a><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span>
</h3>
<div class="impl-items">
<h4 id="method.to_string" class="method hidden">
<code>fn <a href="trait.tostring#tymethod.to_string" class="fnname">to_string</a>(&amp;self) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2242-2244" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Converts the given value to a <code>String</code>. <a href="trait.tostring#tymethod.to_string">Read more</a></p> </div>
</div>
<h3 id="impl-Write" class="impl">
<code class="in-band">impl <a class="trait" href="../fmt/trait.write" title="trait std::fmt::Write">Write</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2415-2427" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.write_str" class="method hidden">
<code>fn <a href="../fmt/trait.write#tymethod.write_str" class="fnname">write_str</a>(&amp;mut self, s: &amp;<a class="primitive" href="../primitive.str">str</a>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>, <a class="struct" href="../fmt/struct.error" title="struct std::fmt::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2417-2420" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Writes a string slice into this writer, returning whether the write succeeded. <a href="../fmt/trait.write#tymethod.write_str">Read more</a></p> </div>
<h4 id="method.write_char" class="method hidden">
<code>fn <a href="../fmt/trait.write#method.write_char" class="fnname">write_char</a>(&amp;mut self, c: <a class="primitive" href="../primitive.char">char</a>) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>, <a class="struct" href="../fmt/struct.error" title="struct std::fmt::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2423-2426" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Writes a [<code>char</code>] into this writer, returning whether the write succeeded. <a href="../fmt/trait.write#method.write_char">Read more</a></p> </div>
<h4 id="method.write_fmt" class="method hidden">
<code>fn <a href="../fmt/trait.write#method.write_fmt" class="fnname">write_fmt</a>(&amp;mut self, args: <a class="struct" href="../fmt/struct.arguments" title="struct std::fmt::Arguments">Arguments</a>&lt;'_&gt;) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.unit">()</a>, <a class="struct" href="../fmt/struct.error" title="struct std::fmt::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/fmt/mod.rs.html#187-189" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Glue for usage of the [<code>write!</code>] macro with implementors of this trait. <a href="../fmt/trait.write#method.write_fmt">Read more</a></p> </div>
</div>
</div>
<h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations</h2>
<div id="synthetic-implementations-list">
<h3 id="impl-RefUnwindSafe" class="impl"><code class="in-band">impl <a class="trait" href="../panic/trait.refunwindsafe" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code></h3>

<h3 id="impl-Send" class="impl"><code class="in-band">impl <a class="trait" href="../marker/trait.send" title="trait std::marker::Send">Send</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code></h3>

<h3 id="impl-Sync" class="impl"><code class="in-band">impl <a class="trait" href="../marker/trait.sync" title="trait std::marker::Sync">Sync</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code></h3>

<h3 id="impl-Unpin" class="impl"><code class="in-band">impl <a class="trait" href="../marker/trait.unpin" title="trait std::marker::Unpin">Unpin</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code></h3>

<h3 id="impl-UnwindSafe" class="impl"><code class="in-band">impl <a class="trait" href="../panic/trait.unwindsafe" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.string" title="struct std::string::String">String</a></code></h3>

</div>
<h2 id="blanket-implementations" class="small-section-header">Blanket Implementations</h2>
<div id="blanket-implementations-list">
<h3 id="impl-Any" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../any/trait.any" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>    T: 'static + ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#108-112" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.type_id" class="method hidden">
<code>fn <a href="../any/trait.any#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="../any/struct.typeid" title="struct std::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/src/core/any.rs.html#109-111" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Gets the <code>TypeId</code> of <code>self</code>. <a href="../any/trait.any#tymethod.type_id">Read more</a></p> </div>
</div>
<h3 id="impl-Borrow%3CT%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.borrow" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>    T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#210-214" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.borrow-1" class="method hidden">
<code>fn <a href="../borrow/trait.borrow#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.reference">&amp;</a>T<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#211-213" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Immutably borrows from an owned value. <a href="../borrow/trait.borrow#tymethod.borrow">Read more</a></p> </div>
</div>
<h3 id="impl-BorrowMut%3CT%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.borrowmut" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>    T: ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#217-221" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.borrow_mut-1" class="method hidden">
<code>fn <a href="../borrow/trait.borrowmut#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.reference">&amp;mut </a>T<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for &amp;'_ mut F</h3>
<pre class="content">impl&lt;'_, F&gt; Future for &amp;'_ mut F where
    F: Unpin + Future + ?Sized, 
    type Output = &lt;F as Future&gt;::Output;
impl&lt;'_, I&gt; Iterator for &amp;'_ mut I where
    I: Iterator + ?Sized, 
    type Item = &lt;I as Iterator&gt;::Item;
impl&lt;R: Read + ?Sized, '_&gt; Read for &amp;'_ mut R
impl&lt;W: Write + ?Sized, '_&gt; Write for &amp;'_ mut W
</pre></span></div></span></span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/borrow.rs.html#218-220" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Mutably borrows from an owned value. <a href="../borrow/trait.borrowmut#tymethod.borrow_mut">Read more</a></p> </div>
</div>
<h3 id="impl-From%3CT%3E" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;T&gt; for T</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#570-574" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.from-16" class="method hidden">
<code>fn <a href="../convert/trait.from#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#571-573" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-Into%3CU%3E" class="impl">
<code class="in-band">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.into" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>    U: <a class="trait" href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#559-566" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.into" class="method hidden">
<code>fn <a href="../convert/trait.into#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#563-565" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-ToOwned" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.toowned" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>    T: <a class="trait" href="../clone/trait.clone" title="trait std::clone::Clone">Clone</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#80-92" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Owned" class="type"><code>type <a href="../borrow/trait.toowned#associatedtype.Owned" class="type">Owned</a> = T</code></h4>
<div class="docblock">
<p>The resulting type after obtaining ownership.</p> </div>
<h4 id="method.to_owned" class="method hidden">
<code>fn <a href="../borrow/trait.toowned#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#85-87" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Creates owned data from borrowed data, usually by cloning. <a href="../borrow/trait.toowned#tymethod.to_owned">Read more</a></p> </div>
<h4 id="method.clone_into" class="method hidden">
<code>fn <a href="../borrow/trait.toowned#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="../primitive.reference">&amp;mut </a>T)</code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#89-91" title="goto source code">[src]</a>
</h4>
<div class="stability hidden"><span class="stab unstable">🔬 This is a nightly-only experimental API. (toowned_clone_into #41263)recently added </span></div>
<div class="docblock hidden">
<p>Uses borrowed data to replace owned data, usually by cloning. <a href="../borrow/trait.toowned#method.clone_into">Read more</a></p> </div>
</div>
<h3 id="impl-ToString-1" class="impl">
<code class="in-band">impl&lt;T&gt; <a class="trait" href="trait.tostring" title="trait std::string::ToString">ToString</a> for T <span class="where fmt-newline">where<br>    T: <a class="trait" href="../fmt/trait.display" title="trait std::fmt::Display">Display</a> + ?<a class="trait" href="../marker/trait.sized" title="trait std::marker::Sized">Sized</a>, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2200-2213" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="method.to_string-1" class="method hidden">
<code>default fn <a href="trait.tostring#tymethod.to_string" class="fnname">to_string</a>(&amp;self) -&gt; <a class="struct" href="struct.string" title="struct std::string::String">String</a></code><a class="srclink" href="https://doc.rust-lang.org/src/alloc/string.rs.html#2205-2212" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Converts the given value to a <code>String</code>. <a href="trait.tostring#tymethod.to_string">Read more</a></p> </div>
</div>
<h3 id="impl-TryFrom%3CU%3E" class="impl">
<code class="in-band">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>    U: <a class="trait" href="../convert/trait.into" title="trait std::convert::Into">Into</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#607-616" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Error" class="type"><code>type <a href="../convert/trait.tryfrom#associatedtype.Error" class="type">Error</a> = <a class="enum" href="../convert/enum.infallible" title="enum std::convert::Infallible">Infallible</a></code></h4>
<div class="docblock">
<p>The type returned in the event of a conversion error.</p> </div>
<h4 id="method.try_from" class="method hidden">
<code>fn <a href="../convert/trait.tryfrom#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="../convert/trait.tryfrom#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#613-615" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
<h3 id="impl-TryInto%3CU%3E" class="impl">
<code class="in-band">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.tryinto" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>    U: <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;, </span></code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#593-602" title="goto source code">[src]</a>
</h3>
<div class="impl-items">
<h4 id="associatedtype.Error-1" class="type"><code>type <a href="../convert/trait.tryinto#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../convert/trait.tryfrom#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></code></h4>
<div class="docblock">
<p>The type returned in the event of a conversion error.</p> </div>
<h4 id="method.try_into" class="method hidden">
<code>fn <a href="../convert/trait.tryinto#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="../result/enum.result" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../convert/trait.tryfrom" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../convert/trait.tryfrom#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#599-601" title="goto source code">[src]</a>
</h4>
<div class="docblock hidden">
<p>Performs the conversion.</p> </div>
</div>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/string/struct.String.html" class="_attribution-link">https://doc.rust-lang.org/std/string/struct.String.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
