
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Functions of One Variable - Octave - W3cubDocs</title>
  
  <meta name="description" content=" Octave supports five different adaptive quadrature algorithms for computing the integral of a function f over the interval from a to b. These are ">
  <meta name="keywords" content="functions, one, variable, octave">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/octave/functions-of-one-variable.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/octave.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/octave/" class="_nav-link" title="" style="margin-left:0;">Octave</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _octave">
				
				
<h1 class="section">23.1 Functions of One Variable</h1> <p>Octave supports five different adaptive quadrature algorithms for computing the integral of a function <em>f</em> over the interval from <em>a</em> to <em>b</em>. These are </p> <dl compact> <dt><code>quad</code></dt> <dd>
<p>Numerical integration based on Gaussian quadrature. </p> </dd> <dt><code>quadv</code></dt> <dd>
<p>Numerical integration using an adaptive vectorized Simpson’s rule. </p> </dd> <dt><code>quadl</code></dt> <dd>
<p>Numerical integration using an adaptive Lobatto rule. </p> </dd> <dt><code>quadgk</code></dt> <dd>
<p>Numerical integration using an adaptive Gauss-Konrod rule. </p> </dd> <dt><code>quadcc</code></dt> <dd>
<p>Numerical integration using adaptive Clenshaw-Curtis rules. </p> <p>In addition, the following functions are also provided: </p> </dd> <dt><code>integral</code></dt> <dd>
<p>A compatibility wrapper function that will choose between <code>quadv</code> and <code>quadgk</code> depending on the integrand and options chosen. </p> </dd> <dt><code>trapz, cumtrapz</code></dt> <dd><p>Numerical integration of data using the trapezoidal method. </p></dd> </dl> <p>The best quadrature algorithm to use depends on the integrand. If you have empirical data, rather than a function, the choice is <code>trapz</code> or <code>cumtrapz</code>. If you are uncertain about the characteristics of the integrand, <code>quadcc</code> will be the most robust as it can handle discontinuities, singularities, oscillatory functions, and infinite intervals. When the integrand is smooth <code>quadgk</code> may be the fastest of the algorithms. </p> <table> <thead><tr>
<th width="5%"></th>
<th width="15%">Function</th>
<th width="80%">Characteristics</th>
</tr></thead> <tr>
<td width="5%"></td>
<td width="15%">quad</td>
<td width="80%">Low accuracy with nonsmooth integrands</td>
</tr> <tr>
<td width="5%"></td>
<td width="15%">quadv</td>
<td width="80%">Medium accuracy with smooth integrands</td>
</tr> <tr>
<td width="5%"></td>
<td width="15%">quadl</td>
<td width="80%">Medium accuracy with smooth integrands. Slower than quadgk.</td>
</tr> <tr>
<td width="5%"></td>
<td width="15%">quadgk</td>
<td width="80%">Medium accuracy (1e-6 – 1e-9) with smooth integrands.</td>
</tr> <tr>
<td width="5%"></td>
<td width="15%"></td>
<td width="80%">Handles oscillatory functions and infinite bounds</td>
</tr> <tr>
<td width="5%"></td>
<td width="15%">quadcc</td>
<td width="80%">Low to High accuracy with nonsmooth/smooth integrands</td>
</tr> <tr>
<td width="5%"></td>
<td width="15%"></td>
<td width="80%">Handles oscillatory functions, singularities, and infinite bounds</td>
</tr> </table> <p>Here is an example of using <code>quad</code> to integrate the function </p> <pre class="example" data-language="matlab">f(x) = x * sin (1/x) * sqrt (abs (1 - x))</pre> <p>from <var>x</var> = 0 to <var>x</var> = 3. </p> <p>This is a fairly difficult integration (plot the function over the range of integration to see why). </p> <p>The first step is to define the function: </p> <pre class="example" data-language="matlab">function y = f (x)
  y = x .* sin (1./x) .* sqrt (abs (1 - x));
endfunction</pre> <p>Note the use of the ‘dot’ forms of the operators. This is not necessary for the <code>quad</code> integrator, but is required by the other integrators. In any case, it makes it much easier to generate a set of points for plotting because it is possible to call the function with a vector argument to produce a vector result. </p> <p>The second step is to call quad with the limits of integration: </p> <pre class="example" data-language="matlab">[q, ier, nfun, err] = quad ("f", 0, 3)
     ⇒ 1.9819
     ⇒ 1
     ⇒ 5061
     ⇒ 1.1522e-07</pre> <p>Although <code>quad</code> returns a nonzero value for <var>ier</var>, the result is reasonably accurate (to see why, examine what happens to the result if you move the lower bound to 0.1, then 0.01, then 0.001, etc.). </p> <p>The function <code>"f"</code> can be the string name of a function, a function handle, or an inline function. These options make it quite easy to do integration without having to fully define a function in an m-file. For example: </p> <pre class="example" data-language="matlab"># Verify integral (x^3) = x^4/4
f = inline ("x.^3");
quadgk (f, 0, 1)
     ⇒ 0.25000

# Verify gamma function = (n-1)! for n = 4
f = @(x) x.^3 .* exp (-x);
quadcc (f, 0, Inf)
     ⇒ 6.0000</pre> <dl id="XREFquad"> <dt id="index-quad">q = quad (f, a, b)</dt> <dt id="index-quad-1">q = quad (f, a, b, tol)</dt> <dt id="index-quad-2">q = quad (f, a, b, tol, sing)</dt> <dt id="index-quad-3">[q, ier, nfun, err] = quad (…)</dt> <dd>
<p>Numerically evaluate the integral of <var>f</var> from <var>a</var> to <var>b</var> using Fortran routines from <small>QUADPACK</small>. </p> <p><var>f</var> is a function handle, inline function, or a string containing the name of the function to evaluate. The function must have the form <code>y =
f (x)</code> where <var>y</var> and <var>x</var> are scalars. </p> <p><var>a</var> and <var>b</var> are the lower and upper limits of integration. Either or both may be infinite. </p> <p>The optional argument <var>tol</var> is a vector that specifies the desired accuracy of the result. The first element of the vector is the desired absolute tolerance, and the second element is the desired relative tolerance. To choose a relative test only, set the absolute tolerance to zero. To choose an absolute test only, set the relative tolerance to zero. Both tolerances default to <code>sqrt (eps)</code> or approximately 1.5e-8. </p> <p>The optional argument <var>sing</var> is a vector of values at which the integrand is known to be singular. </p> <p>The result of the integration is returned in <var>q</var>. </p> <p><var>ier</var> contains an integer error code (0 indicates a successful integration). </p> <p><var>nfun</var> indicates the number of function evaluations that were made. </p> <p><var>err</var> contains an estimate of the error in the solution. </p> <p>The function <code>quad_options</code> can set other optional parameters for <code>quad</code>. </p> <p>Note: because <code>quad</code> is written in Fortran it cannot be called recursively. This prevents its use in integrating over more than one variable by routines <code>dblquad</code> and <code>triplequad</code>. </p> <p><strong>See also:</strong> <a href="#XREFquad_005foptions">quad_options</a>, <a href="#XREFquadv">quadv</a>, <a href="#XREFquadl">quadl</a>, <a href="#XREFquadgk">quadgk</a>, <a href="#XREFquadcc">quadcc</a>, <a href="#XREFtrapz">trapz</a>, <a href="functions-of-multiple-variables#XREFdblquad">dblquad</a>, <a href="functions-of-multiple-variables#XREFtriplequad">triplequad</a>. </p>
</dd>
</dl> <dl id="XREFquad_005foptions"> <dt id="index-quad_005foptions">quad_options ()</dt> <dt id="index-quad_005foptions-1">val = quad_options (opt)</dt> <dt id="index-quad_005foptions-2">quad_options (opt, val)</dt> <dd>
<p>Query or set options for the function <code>quad</code>. </p> <p>When called with no arguments, the names of all available options and their current values are displayed. </p> <p>Given one argument, return the value of the option <var>opt</var>. </p> <p>When called with two arguments, <code>quad_options</code> sets the option <var>opt</var> to value <var>val</var>. </p> <p>Options include </p> <dl compact> <dt><code>"absolute tolerance"</code></dt> <dd>
<p>Absolute tolerance; may be zero for pure relative error test. </p> </dd> <dt><code>"relative tolerance"</code></dt> <dd>
<p>Non-negative relative tolerance. If the absolute tolerance is zero, the relative tolerance must be greater than or equal to <code>max (50*eps, <span class="nolinebreak">0.5e-28)</span></code>. </p> </dd> <dt><code>"single precision absolute tolerance"</code></dt> <dd>
<p>Absolute tolerance for single precision; may be zero for pure relative error test. </p> </dd> <dt><code>"single precision relative tolerance"</code></dt> <dd><p>Non-negative relative tolerance for single precision. If the absolute tolerance is zero, the relative tolerance must be greater than or equal to <code>max (50*eps, <span class="nolinebreak">0.5e-28)</span></code>. </p></dd> </dl> </dd>
</dl> <dl id="XREFquadv"> <dt id="index-quadv">q = quadv (f, a, b)</dt> <dt id="index-quadv-1">q = quadv (f, a, b, tol)</dt> <dt id="index-quadv-2">q = quadv (f, a, b, tol, trace)</dt> <dt id="index-quadv-3">q = quadv (f, a, b, tol, trace, p1, p2, …)</dt> <dt id="index-quadv-4">[q, nfun] = quadv (…)</dt> <dd> <p>Numerically evaluate the integral of <var>f</var> from <var>a</var> to <var>b</var> using an adaptive Simpson’s rule. </p> <p><var>f</var> is a function handle, inline function, or string containing the name of the function to evaluate. <code>quadv</code> is a vectorized version of <code>quad</code> and the function defined by <var>f</var> must accept a scalar or vector as input and return a scalar, vector, or array as output. </p> <p><var>a</var> and <var>b</var> are the lower and upper limits of integration. Both limits must be finite. </p> <p>The optional argument <var>tol</var> defines the absolute tolerance used to stop the adaptation procedure. The default value is 1e-6. </p> <p>The algorithm used by <code>quadv</code> involves recursively subdividing the integration interval and applying Simpson’s rule on each subinterval. If <var>trace</var> is true then after computing each of these partial integrals display: (1) the total number of function evaluations, (2) the left end of the subinterval, (3) the length of the subinterval, (4) the approximation of the integral over the subinterval. </p> <p>Additional arguments <var>p1</var>, etc., are passed directly to the function <var>f</var>. To use default values for <var>tol</var> and <var>trace</var>, one may pass empty matrices ([]). </p> <p>The result of the integration is returned in <var>q</var>. </p> <p>The optional output <var>nfun</var> indicates the total number of function evaluations performed. </p> <p>Note: <code>quadv</code> is written in Octave’s scripting language and can be used recursively in <code>dblquad</code> and <code>triplequad</code>, unlike the <code>quad</code> function. </p> <p><strong>See also:</strong> <a href="#XREFquad">quad</a>, <a href="#XREFquadl">quadl</a>, <a href="#XREFquadgk">quadgk</a>, <a href="#XREFquadcc">quadcc</a>, <a href="#XREFtrapz">trapz</a>, <a href="functions-of-multiple-variables#XREFdblquad">dblquad</a>, <a href="functions-of-multiple-variables#XREFtriplequad">triplequad</a>, <a href="#XREFintegral">integral</a>, <a href="functions-of-multiple-variables#XREFintegral2">integral2</a>, <a href="functions-of-multiple-variables#XREFintegral3">integral3</a>. </p>
</dd>
</dl> <dl id="XREFquadl"> <dt id="index-quadl">q = quadl (f, a, b)</dt> <dt id="index-quadl-1">q = quadl (f, a, b, tol)</dt> <dt id="index-quadl-2">q = quadl (f, a, b, tol, trace)</dt> <dt id="index-quadl-3">q = quadl (f, a, b, tol, trace, p1, p2, …)</dt> <dt id="index-quadl-4">[q, nfun] = quadl (…)</dt> <dd> <p>Numerically evaluate the integral of <var>f</var> from <var>a</var> to <var>b</var> using an adaptive Lobatto rule. </p> <p><var>f</var> is a function handle, inline function, or string containing the name of the function to evaluate. The function <var>f</var> must be vectorized and return a vector of output values when given a vector of input values. </p> <p><var>a</var> and <var>b</var> are the lower and upper limits of integration. Both limits must be finite. </p> <p>The optional argument <var>tol</var> defines the absolute tolerance with which to perform the integration. The default value is 1e-6. </p> <p>The algorithm used by <code>quadl</code> involves recursively subdividing the integration interval. If <var>trace</var> is defined then for each subinterval display: (1) the total number of function evaluations, (2) the left end of the subinterval, (3) the length of the subinterval, (4) the approximation of the integral over the subinterval. </p> <p>Additional arguments <var>p1</var>, etc., are passed directly to the function <var>f</var>. To use default values for <var>tol</var> and <var>trace</var>, one may pass empty matrices ([]). </p> <p>The result of the integration is returned in <var>q</var>. </p> <p>The optional output <var>nfun</var> indicates the total number of function evaluations performed. </p> <p>Reference: W. Gander and W. Gautschi, <cite>Adaptive Quadrature - Revisited</cite>, BIT Vol. 40, No. 1, March 2000, pp. 84–101. <a href="https://www.inf.ethz.ch/personal/gander/">https://www.inf.ethz.ch/personal/gander/</a> </p> <p><strong>See also:</strong> <a href="#XREFquad">quad</a>, <a href="#XREFquadv">quadv</a>, <a href="#XREFquadgk">quadgk</a>, <a href="#XREFquadcc">quadcc</a>, <a href="#XREFtrapz">trapz</a>, <a href="functions-of-multiple-variables#XREFdblquad">dblquad</a>, <a href="functions-of-multiple-variables#XREFtriplequad">triplequad</a>, <a href="#XREFintegral">integral</a>, <a href="functions-of-multiple-variables#XREFintegral2">integral2</a>, <a href="functions-of-multiple-variables#XREFintegral3">integral3</a>. </p>
</dd>
</dl> <dl id="XREFquadgk"> <dt id="index-quadgk">q = quadgk (f, a, b)</dt> <dt id="index-quadgk-1">q = quadgk (f, a, b, abstol)</dt> <dt id="index-quadgk-2">q = quadgk (f, a, b, abstol, trace)</dt> <dt id="index-quadgk-3">q = quadgk (f, a, b, prop, val, …)</dt> <dt id="index-quadgk-4">[q, err] = quadgk (…)</dt> <dd> <p>Numerically evaluate the integral of <var>f</var> from <var>a</var> to <var>b</var> using adaptive Gauss-Konrod quadrature. </p> <p><var>f</var> is a function handle, inline function, or string containing the name of the function to evaluate. The function <var>f</var> must be vectorized and return a vector of output values when given a vector of input values. </p> <p><var>a</var> and <var>b</var> are the lower and upper limits of integration. Either or both limits may be infinite or contain weak end singularities. Variable transformation will be used to treat any infinite intervals and weaken the singularities. For example: </p> <pre class="example" data-language="matlab">quadgk (@(x) 1 ./ (sqrt (x) .* (x + 1)), 0, Inf)</pre> <p>Note that the formulation of the integrand uses the element-by-element operator <code>./</code> and all user functions to <code>quadgk</code> should do the same. </p> <p>The optional argument <var>tol</var> defines the absolute tolerance used to stop the integration procedure. The default value is 1e-10 (1e-5 for single). </p> <p>The algorithm used by <code>quadgk</code> involves subdividing the integration interval and evaluating each subinterval. If <var>trace</var> is true then after computing each of these partial integrals display: (1) the number of subintervals at this step, (2) the current estimate of the error <var>err</var>, (3) the current estimate for the integral <var>q</var>. </p> <p>Alternatively, properties of <code>quadgk</code> can be passed to the function as pairs <code>"<var>prop</var>", <var>val</var></code>. Valid properties are </p> <dl compact> <dt><code>AbsTol</code></dt> <dd>
<p>Define the absolute error tolerance for the quadrature. The default absolute tolerance is 1e-10 (1e-5 for single). </p> </dd> <dt><code>RelTol</code></dt> <dd>
<p>Define the relative error tolerance for the quadrature. The default relative tolerance is 1e-6 (1e-4 for single). </p> </dd> <dt><code>MaxIntervalCount</code></dt> <dd>
<p><code>quadgk</code> initially subdivides the interval on which to perform the quadrature into 10 intervals. Subintervals that have an unacceptable error are subdivided and re-evaluated. If the number of subintervals exceeds 650 subintervals at any point then a poor convergence is signaled and the current estimate of the integral is returned. The property <code>"MaxIntervalCount"</code> can be used to alter the number of subintervals that can exist before exiting. </p> </dd> <dt><code>WayPoints</code></dt> <dd>
<p>Discontinuities in the first derivative of the function to integrate can be flagged with the <code>"WayPoints"</code> property. This forces the ends of a subinterval to fall on the breakpoints of the function and can result in significantly improved estimation of the error in the integral, faster computation, or both. For example, </p> <pre class="example" data-language="matlab">quadgk (@(x) abs (1 - x.^2), 0, 2, "Waypoints", 1)</pre> <p>signals the breakpoint in the integrand at <code><var>x</var> = 1</code>. </p> </dd> <dt><code>Trace</code></dt> <dd><p>If logically true <code>quadgk</code> prints information on the convergence of the quadrature at each iteration. </p></dd> </dl> <p>If any of <var>a</var>, <var>b</var>, or <var>waypoints</var> is complex then the quadrature is treated as a contour integral along a piecewise continuous path defined by the above. In this case the integral is assumed to have no edge singularities. For example, </p> <pre class="example" data-language="matlab">quadgk (@(z) log (z), 1+1i, 1+1i, "WayPoints",
        [1-1i, -1,-1i, -1+1i])</pre> <p>integrates <code>log (z)</code> along the square defined by <code>[1+1i, 1-1i, -1-1i, -1+1i]</code>. </p> <p>The result of the integration is returned in <var>q</var>. </p> <p><var>err</var> is an approximate bound on the error in the integral <code>abs (<var>q</var> - <var>I</var>)</code>, where <var>I</var> is the exact value of the integral. </p> <p>Reference: L.F. Shampine, <cite>"Vectorized adaptive quadrature in <small>MATLAB</small>"</cite>, Journal of Computational and Applied Mathematics, pp. 131–140, Vol 211, Issue 2, Feb 2008. </p> <p><strong>See also:</strong> <a href="#XREFquad">quad</a>, <a href="#XREFquadv">quadv</a>, <a href="#XREFquadl">quadl</a>, <a href="#XREFquadcc">quadcc</a>, <a href="#XREFtrapz">trapz</a>, <a href="functions-of-multiple-variables#XREFdblquad">dblquad</a>, <a href="functions-of-multiple-variables#XREFtriplequad">triplequad</a>, <a href="#XREFintegral">integral</a>, <a href="functions-of-multiple-variables#XREFintegral2">integral2</a>, <a href="functions-of-multiple-variables#XREFintegral3">integral3</a>. </p>
</dd>
</dl> <dl id="XREFquadcc"> <dt id="index-quadcc">q = quadcc (f, a, b)</dt> <dt id="index-quadcc-1">q = quadcc (f, a, b, tol)</dt> <dt id="index-quadcc-2">q = quadcc (f, a, b, tol, sing)</dt> <dt id="index-quadcc-3">[q, err, nr_points] = quadcc (…)</dt> <dd>
<p>Numerically evaluate the integral of <var>f</var> from <var>a</var> to <var>b</var> using doubly-adaptive Clenshaw-Curtis quadrature. </p> <p><var>f</var> is a function handle, inline function, or string containing the name of the function to evaluate. The function <var>f</var> must be vectorized and must return a vector of output values if given a vector of input values. For example, </p> <pre class="example" data-language="matlab">f = @(x) x .* sin (1./x) .* sqrt (abs (1 - x));</pre> <p>which uses the element-by-element “dot” form for all operators. </p> <p><var>a</var> and <var>b</var> are the lower and upper limits of integration. Either or both limits may be infinite. <code>quadcc</code> handles an infinite limit by substituting the variable of integration with <code>x = tan (pi/2*u)</code>. </p> <p>The optional argument <var>tol</var> is a 1- or 2-element vector that specifies the desired accuracy of the result. The first element of the vector is the desired absolute tolerance, and the second element is the desired relative tolerance. To choose a relative test only, set the absolute tolerance to zero. To choose an absolute test only, set the relative tolerance to zero. The default absolute tolerance is 1e-10 (1e-5 for single), and the default relative tolerance is 1e-6 (1e-4 for single). </p> <p>The optional argument <var>sing</var> contains a list of points where the integrand has known singularities, or discontinuities in any of its derivatives, inside the integration interval. For the example above, which has a discontinuity at x=1, the call to <code>quadcc</code> would be as follows </p> <pre class="example" data-language="matlab">int = quadcc (f, a, b, [], [ 1 ]);</pre> <p>The result of the integration is returned in <var>q</var>. </p> <p><var>err</var> is an estimate of the absolute integration error. </p> <p><var>nr_points</var> is the number of points at which the integrand was evaluated. </p> <p>If the adaptive integration did not converge, the value of <var>err</var> will be larger than the requested tolerance. Therefore, it is recommended to verify this value for difficult integrands. </p> <p><code>quadcc</code> is capable of dealing with non-numeric values of the integrand such as <code>NaN</code> or <code>Inf</code>. If the integral diverges, and <code>quadcc</code> detects this, then a warning is issued and <code>Inf</code> or <code>-Inf</code> is returned. </p> <p>Note: <code>quadcc</code> is a general purpose quadrature algorithm and, as such, may be less efficient for a smooth or otherwise well-behaved integrand than other methods such as <code>quadgk</code>. </p> <p>The algorithm uses Clenshaw-Curtis quadrature rules of increasing degree in each interval and bisects the interval if either the function does not appear to be smooth or a rule of maximum degree has been reached. The error estimate is computed from the L2-norm of the difference between two successive interpolations of the integrand over the nodes of the respective quadrature rules. </p> <p>Implementation Note: For Octave versions ≤ 4.2, <code>quadcc</code> accepted a single tolerance argument which specified the relative tolerance. For versions 4.4 and 5, <code>quadcc</code> will issue a warning when called with a single tolerance argument indicating that the meaning of this input has changed from relative tolerance to absolute tolerance. The warning ID for this message is <code>"Octave:quadcc:RelTol-conversion"</code>. The warning may be disabled with <code>warning ("off", "Octave:quadcc:RelTol-conversion")</code>. </p> <p>Reference: P. Gonnet, <cite>Increasing the Reliability of Adaptive Quadrature Using Explicit Interpolants</cite>, ACM Transactions on Mathematical Software, Vol. 37, Issue 3, Article No. 3, 2010. </p> <p><strong>See also:</strong> <a href="#XREFquad">quad</a>, <a href="#XREFquadv">quadv</a>, <a href="#XREFquadl">quadl</a>, <a href="#XREFquadgk">quadgk</a>, <a href="#XREFtrapz">trapz</a>, <a href="functions-of-multiple-variables#XREFdblquad">dblquad</a>, <a href="functions-of-multiple-variables#XREFtriplequad">triplequad</a>. </p>
</dd>
</dl> <dl id="XREFintegral"> <dt id="index-integral">q = integral (f, a, b)</dt> <dt id="index-integral-1">q = integral (f, a, b, prop, val, …)</dt> <dd> <p>Numerically evaluate the integral of <var>f</var> from <var>a</var> to <var>b</var> using adaptive quadrature. </p> <p><code>integral</code> is a wrapper for <code>quadcc</code> (general scalar integrands), <code>quadgk</code> (integrals with specified integration paths), and <code>quadv</code> (array-valued integrands) that is intended to provide <small>MATLAB</small> compatibility. More control of the numerical integration may be achievable by calling the various quadrature functions directly. </p> <p><var>f</var> is a function handle, inline function, or string containing the name of the function to evaluate. The function <var>f</var> must be vectorized and return a vector of output values when given a vector of input values. </p> <p><var>a</var> and <var>b</var> are the lower and upper limits of integration. Either or both limits may be infinite or contain weak end singularities. If either or both limits are complex, <code>integral</code> will perform a straight line path integral. Alternatively, a complex domain path can be specified using the <code>"Waypoints"</code> option (see below). </p> <p>Additional optional parameters can be specified using <code>"<var>property</var>", <var>value</var></code> pairs. Valid properties are: </p> <dl compact> <dt><code>Waypoints</code></dt> <dd>
<p>Specifies points to be used in defining subintervals of the quadrature algorithm, or if <var>a</var>, <var>b</var>, or <var>waypoints</var> are complex then the quadrature is calculated as a contour integral along a piecewise continuous path. For more detail see <code>quadgk</code>. </p> </dd> <dt><code>ArrayValued</code></dt> <dd>
<p><code>integral</code> expects <var>f</var> to return a scalar value unless <var>arrayvalued</var> is specified as true. This option will cause <code>integral</code> to perform the integration over the entire array and return <var>q</var> with the same dimensions as returned by <var>f</var>. For more detail see <code>quadv</code>. </p> </dd> <dt><code>AbsTol</code></dt> <dd>
<p>Define the absolute error tolerance for the quadrature. The default absolute tolerance is 1e-10 (1e-5 for single). </p> </dd> <dt><code>RelTol</code></dt> <dd><p>Define the relative error tolerance for the quadrature. The default relative tolerance is 1e-6 (1e-4 for single). </p></dd> </dl> <p>Adaptive quadrature is used to minimize the estimate of error until the following is satisfied: </p> <pre class="example" data-language="matlab">error &lt;= max (AbsTol, RelTol*|q|).</pre> <p>Known <small>MATLAB</small> incompatibilities: </p> <ol> <li> If tolerances are left unspecified, and any integration limits or waypoints are of type <code>single</code>, then Octave’s integral functions automatically reduce the default absolute and relative error tolerances as specified above. If tighter tolerances are desired they must be specified. <small>MATLAB</small> leaves the tighter tolerances appropriate for <code>double</code> inputs in place regardless of the class of the integration limits. </li>
<li> As a consequence of using <code>quadcc</code>, <code>quadgk</code>, and <code>quadv</code>, certain option combinations are not supported. Currently, <code>"ArrayValued"</code> cannot be combined with <code>"RelTol"</code> or <code>"Waypoints"</code>. </li>
</ol> <p><strong>See also:</strong> <a href="functions-of-multiple-variables#XREFintegral2">integral2</a>, <a href="functions-of-multiple-variables#XREFintegral3">integral3</a>, <a href="#XREFquad">quad</a>, <a href="#XREFquadgk">quadgk</a>, <a href="#XREFquadv">quadv</a>, <a href="#XREFquadl">quadl</a>, <a href="#XREFquadcc">quadcc</a>, <a href="#XREFtrapz">trapz</a>, <a href="functions-of-multiple-variables#XREFdblquad">dblquad</a>, <a href="functions-of-multiple-variables#XREFtriplequad">triplequad</a>. </p>
</dd>
</dl> <p>Sometimes one does not have the function, but only the raw (x, y) points from which to perform an integration. This can occur when collecting data in an experiment. The <code>trapz</code> function can integrate these values as shown in the following example where "data" has been collected on the cosine function over the range [0, pi/2). </p> <pre class="example" data-language="matlab">x = 0:0.1:pi/2;  # Uniformly spaced points
y = cos (x);
trapz (x, y)
     ⇒ 0.99666</pre> <p>The answer is reasonably close to the exact value of 1. Ordinary quadrature is sensitive to the characteristics of the integrand. Empirical integration depends not just on the integrand, but also on the particular points chosen to represent the function. Repeating the example above with the sine function over the range [0, pi/2) produces far inferior results. </p> <pre class="example" data-language="matlab">x = 0:0.1:pi/2;  # Uniformly spaced points
y = sin (x);
trapz (x, y)
     ⇒ 0.92849</pre> <p>However, a slightly different choice of data points can change the result significantly. The same integration, with the same number of points, but spaced differently produces a more accurate answer. </p> <pre class="example" data-language="matlab">x = linspace (0, pi/2, 16);  # Uniformly spaced, but including endpoint
y = sin (x);
trapz (x, y)
     ⇒ 0.99909</pre> <p>In general there may be no way of knowing the best distribution of points ahead of time. Or the points may come from an experiment where there is no freedom to select the best distribution. In any case, one must remain aware of this issue when using <code>trapz</code>. </p> <dl id="XREFtrapz"> <dt id="index-trapz">q = trapz (y)</dt> <dt id="index-trapz-1">q = trapz (x, y)</dt> <dt id="index-trapz-2">q = trapz (…, dim)</dt> <dd> <p>Numerically evaluate the integral of points <var>y</var> using the trapezoidal method. </p> <p><code>trapz (<var>y</var>)</code> computes the integral of <var>y</var> along the first non-singleton dimension. When the argument <var>x</var> is omitted an equally spaced <var>x</var> vector with unit spacing (1) is assumed. <code>trapz (<var>x</var>, <var>y</var>)</code> evaluates the integral with respect to the spacing in <var>x</var> and the values in <var>y</var>. This is useful if the points in <var>y</var> have been sampled unevenly. </p> <p>If the optional <var>dim</var> argument is given, operate along this dimension. </p> <p>Application Note: If <var>x</var> is not specified then unit spacing will be used. To scale the integral to the correct value you must multiply by the actual spacing value (deltaX). As an example, the integral of <em>x^3</em> over the range [0, 1] is <em>x^4/4</em> or 0.25. The following code uses <code>trapz</code> to calculate the integral in three different ways. </p> <pre class="example" data-language="matlab">x = 0:0.1:1;
y = x.^3;
## No scaling
q = trapz (y)
  ⇒ q = 2.5250
## Approximation to integral by scaling
q * 0.1
  ⇒ 0.25250
## Same result by specifying x
trapz (x, y)
  ⇒ 0.25250</pre> <p><strong>See also:</strong> <a href="#XREFcumtrapz">cumtrapz</a>. </p>
</dd>
</dl> <dl id="XREFcumtrapz"> <dt id="index-cumtrapz">q = cumtrapz (y)</dt> <dt id="index-cumtrapz-1">q = cumtrapz (x, y)</dt> <dt id="index-cumtrapz-2">q = cumtrapz (…, dim)</dt> <dd>
<p>Cumulative numerical integration of points <var>y</var> using the trapezoidal method. </p> <p><code>cumtrapz (<var>y</var>)</code> computes the cumulative integral of <var>y</var> along the first non-singleton dimension. Where <code>trapz</code> reports only the overall integral sum, <code>cumtrapz</code> reports the current partial sum value at each point of <var>y</var>. </p> <p>When the argument <var>x</var> is omitted an equally spaced <var>x</var> vector with unit spacing (1) is assumed. <code>cumtrapz (<var>x</var>, <var>y</var>)</code> evaluates the integral with respect to the spacing in <var>x</var> and the values in <var>y</var>. This is useful if the points in <var>y</var> have been sampled unevenly. </p> <p>If the optional <var>dim</var> argument is given, operate along this dimension. </p> <p>Application Note: If <var>x</var> is not specified then unit spacing will be used. To scale the integral to the correct value you must multiply by the actual spacing value (deltaX). </p> <p><strong>See also:</strong> <a href="#XREFtrapz">trapz</a>, <a href="sums-and-products#XREFcumsum">cumsum</a>. </p>
</dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
          © 1996–2018 John W. Eaton<br>      Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://octave.org/doc/interpreter/Functions-of-One-Variable.html" class="_attribution-link">https://octave.org/doc/interpreter/Functions-of-One-Variable.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
