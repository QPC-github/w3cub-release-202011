
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Formatted Input - Octave - W3cubDocs</title>
  
  <meta name="description" content="Octave provides the scanf, fscanf, and sscanf functions to read formatted input. There are two forms of each of these functions. One can be used to &hellip;">
  <meta name="keywords" content="formatted, input, octave">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/octave/formatted-input.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/octave.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/octave/" class="_nav-link" title="" style="margin-left:0;">Octave</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _octave">
				
				
<h1 class="subsection">14.2.11 Formatted Input</h1> <p>Octave provides the <code>scanf</code>, <code>fscanf</code>, and <code>sscanf</code> functions to read formatted input. There are two forms of each of these functions. One can be used to extract vectors of data from a file, and the other is more ‘C-like’. </p> <dl id="XREFfscanf"> <dt id="index-fscanf">[val, count, errmsg] = fscanf (fid, template, size)</dt> <dt id="index-fscanf-1">[v1, v2, …, count, errmsg] = fscanf (fid, template, "C")</dt> <dd>
<p>In the first form, read from <var>fid</var> according to <var>template</var>, returning the result in the matrix <var>val</var>. </p> <p>The optional argument <var>size</var> specifies the amount of data to read and may be one of </p> <dl compact> <dt><code>Inf</code></dt> <dd>
<p>Read as much as possible, returning a column vector. </p> </dd> <dt><code><var>nr</var></code></dt> <dd>
<p>Read up to <var>nr</var> elements, returning a column vector. </p> </dd> <dt><code>[<var>nr</var>, Inf]</code></dt> <dd>
<p>Read as much as possible, returning a matrix with <var>nr</var> rows. If the number of elements read is not an exact multiple of <var>nr</var>, the last column is padded with zeros. </p> </dd> <dt><code>[<var>nr</var>, <var>nc</var>]</code></dt> <dd><p>Read up to <code><var>nr</var> * <var>nc</var></code> elements, returning a matrix with <var>nr</var> rows. If the number of elements read is not an exact multiple of <var>nr</var>, the last column is padded with zeros. </p></dd> </dl> <p>If <var>size</var> is omitted, a value of <code>Inf</code> is assumed. </p> <p>A string is returned if <var>template</var> specifies only character conversions. </p> <p>The number of items successfully read is returned in <var>count</var>. </p> <p>If an error occurs, <var>errmsg</var> contains a system-dependent error message. </p> <p>In the second form, read from <var>fid</var> according to <var>template</var>, with each conversion specifier in <var>template</var> corresponding to a single scalar return value. This form is more “C-like”, and also compatible with previous versions of Octave. The number of successful conversions is returned in <var>count</var> </p> <p>See the Formatted Input section of the GNU Octave manual for a complete description of the syntax of the template string. </p> <p><strong>See also:</strong> <a href="line_002doriented-input#XREFfgets">fgets</a>, <a href="line_002doriented-input#XREFfgetl">fgetl</a>, <a href="binary-i_002fo#XREFfread">fread</a>, <a href="#XREFscanf">scanf</a>, <a href="#XREFsscanf">sscanf</a>, <a href="opening-and-closing-files#XREFfopen">fopen</a>. </p>
</dd>
</dl> <dl id="XREFscanf"> <dt id="index-scanf">[val, count, errmsg] = scanf (template, size)</dt> <dt id="index-scanf-1">[v1, v2, …, count, errmsg] = scanf (template, "C")</dt> <dd>
<p>This is equivalent to calling <code>fscanf</code> with <var>fid</var> = <code>stdin</code>. </p> <p>It is currently not useful to call <code>scanf</code> in interactive programs. </p> <p><strong>See also:</strong> <a href="#XREFfscanf">fscanf</a>, <a href="#XREFsscanf">sscanf</a>, <a href="formatted-output#XREFprintf">printf</a>. </p>
</dd>
</dl> <dl id="XREFsscanf"> <dt id="index-sscanf">[val, count, errmsg, pos] = sscanf (string, template, size)</dt> <dt id="index-sscanf-1">[v1, v2, …, count, errmsg] = sscanf (string, template, "C")</dt> <dd>
<p>This is like <code>fscanf</code>, except that the characters are taken from the string <var>string</var> instead of from a stream. </p> <p>Reaching the end of the string is treated as an end-of-file condition. In addition to the values returned by <code>fscanf</code>, the index of the next character to be read is returned in <var>pos</var>. </p> <p><strong>See also:</strong> <a href="#XREFfscanf">fscanf</a>, <a href="#XREFscanf">scanf</a>, <a href="formatted-output#XREFsprintf">sprintf</a>. </p>
</dd>
</dl> <p>Calls to <code>scanf</code> are superficially similar to calls to <code>printf</code> in that arbitrary arguments are read under the control of a template string. While the syntax of the conversion specifications in the template is very similar to that for <code>printf</code>, the interpretation of the template is oriented more towards free-format input and simple pattern matching, rather than fixed-field formatting. For example, most <code>scanf</code> conversions skip over any amount of “white space” (including spaces, tabs, and newlines) in the input file, and there is no concept of precision for the numeric input conversions as there is for the corresponding output conversions. Ordinarily, non-whitespace characters in the template are expected to match characters in the input stream exactly.  </p> <p>When a <em>matching failure</em> occurs, <code>scanf</code> returns immediately, leaving the first non-matching character as the next character to be read from the stream, and <code>scanf</code> returns all the items that were successfully converted.  </p> <p>The formatted input functions are not used as frequently as the formatted output functions. Partly, this is because it takes some care to use them properly. Another reason is that it is difficult to recover from a matching error. </p>
<div class="_attribution">
  <p class="_attribution-p">
          © 1996–2018 John W. Eaton<br>      Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://octave.org/doc/interpreter/Formatted-Input.html" class="_attribution-link">https://octave.org/doc/interpreter/Formatted-Input.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
