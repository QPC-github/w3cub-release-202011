
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Statistics on Sliding Windows of Data - Octave - W3cubDocs</title>
  
  <meta name="description" content="It is often useful to calculate descriptive statistics over a subsection (i.e., window) of a full dataset. Octave provides the function movfun which &hellip;">
  <meta name="keywords" content="statistics, on, sliding, windows, data, octave">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/octave/statistics-on-sliding-windows-of-data.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/octave.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/octave/" class="_nav-link" title="" style="margin-left:0;">Octave</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _octave">
				
				
<h1 class="section">26.2 Statistics on Sliding Windows of Data</h1> <p>It is often useful to calculate descriptive statistics over a subsection (i.e., window) of a full dataset. Octave provides the function <code>movfun</code> which will call an arbitrary function handle with windows of data and accumulate the results. Many of the most commonly desired functions, such as the moving average over a window of data (<code>movmean</code>), are already provided. </p> <dl id="XREFmovfun"> <dt id="index-movfun">y = movfun (fcn, x, wlen)</dt> <dt id="index-movfun-1">y = movfun (fcn, x, [nb, na])</dt> <dt id="index-movfun-2">y = movfun (…, "property", value)</dt> <dd> <p>Apply function <var>fcn</var> to a moving window of length <var>wlen</var> on data <var>x</var>. </p> <p>If <var>wlen</var> is a scalar, the function <var>fcn</var> is applied to a moving window of length <var>wlen</var>. When <var>wlen</var> is an odd number the window is symmetric and includes <code>(<var>wlen</var> <span class="nolinebreak">-</span> 1) / 2</code> elements on either side of the central element. For example, when calculating the output at index 5 with a window length of 3, <code>movfun</code> uses data elements <code>[4, 5, 6]</code>. If <var>wlen</var> is an even number, the window is asymmetric and has <code><var>wlen</var>/2</code> elements to the left of the central element and <code><var>wlen</var>/2 <span class="nolinebreak">-</span> 1</code> elements to the right of the central element. For example, when calculating the output at index 5 with a window length of 4, <code>movfun</code> uses data elements <code>[3, 4, 5, 6]</code>. </p> <p>If <var>wlen</var> is an array with two elements <code>[<var>nb</var>, <var>na</var>]</code>, the function is applied to a moving window <code>-<var>nb</var>:<var>na</var></code>. This window includes <var>nb</var> number of elements <em>before</em> the current element and <var>na</var> number of elements <em>after</em> the current element. The current element is always included. For example, given <code><var>wlen</var> = [3, 0]</code>, the data used to calculate index 5 is <code>[2, 3, 4, 5]</code>. </p> <p>During calculations the data input <var>x</var> is reshaped into a 2-dimensional <var>wlen</var>-by-<var>N</var> matrix and <var>fcn</var> is called on this new matrix. Therefore, <var>fcn</var> must accept an array input argument and apply the computation along dimension 1, i.e., down the columns of the array. </p> <p>When applied to an array (possibly multi-dimensional) with <var>n</var> columns, <var>fcn</var> may return a result in either of two formats: Format 1) an array of size 1-by-<var>n</var>-by-<var>dim3</var>-by-…-by-<var>dimN</var>. This is the typical output format from Octave core functions. Type <code>demo ("movfun", 5)</code> for an example of this use case. Format 2) a row vector of length <code><var>n</var> * <var>numel_higher_dims</var></code> where <var>numel_higher_dims</var> is <code>prod (size (<var>x</var>)(3:end))</code>. The output of <var>fcn</var> for the i-th input column must be found in the output at indices <code>i:<var>n</var>:(<var>n</var>*<var><span class="nolinebreak">numel_higher_dims</span></var>)</code>. This format is useful when concatenating functions into arrays, or when using <code>nthargout</code>. Type <code>demo ("movfun", 6)</code> for an example of this case. </p> <p>The calculation can be controlled by specifying <var>property</var>/<var>value</var> pairs. Valid properties are </p> <dl compact> <dt><code>"dim"</code></dt> <dd>
<p>Operate along the dimension specified, rather than the default of the first non-singleton dimension. </p> </dd> <dt><code>"Endpoints"</code></dt> <dd> <p>This property controls how results are calculated at the boundaries (endpoints) of the window. Possible values are: </p> <dl compact> <dt>
<code>"shrink"</code> (default)</dt> <dd>
<p>The window is truncated at the beginning and end of the array to exclude elements for which there is no source data. For example, with a window of length 3, <code><var>y</var>(1) = <var>fcn</var> (<var>x</var>(1:2))</code>, and <code><var>y</var>(end) = <var>fcn</var> (<var>x</var>(end-1:end))</code>. </p> </dd> <dt><code>"discard"</code></dt> <dd>
<p>Any <var>y</var> values that use a window extending beyond the original data array are deleted. For example, with a 10-element data vector and a window of length 3, the output will contain only 8 elements. The first element would require calculating the function over indices <code>[0, 1, 2]</code> and is therefore discarded. The last element would require calculating the function over indices <code>[9, 10, 11]</code> and is therefore discarded. </p> </dd> <dt><code>"fill"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by <code>NaN</code>. For example, with a window of length 3, <code><var>y</var>(1) = <var>fcn</var> ([NaN, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = <var>fcn</var> ([<var>x</var>(end-1:end), NaN])</code>. This option usually results in <var>y</var> having <code>NaN</code> values at the boundaries, although it is influenced by how <var>fcn</var> handles <code>NaN</code>, and also by the property <code>"nancond"</code>. </p> </dd> <dt><var>user_value</var></dt> <dd>
<p>Any window elements outside the data array are replaced by the specified value <var>user_value</var> which must be a numeric scalar. For example, with a window of length 3, <code><var>y</var>(1) = <var>fcn</var> ([<var>user_value</var>, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = <var>fcn</var> ([<var>x</var>(end-1:end), <var>user_value</var>])</code>. A common choice for <var>user_value</var> is 0. </p> </dd> <dt><code>"same"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by the value of <var>x</var> at the boundary. For example, with a window of length 3, <code><var>y</var>(1) = <var>fcn</var> ([<var>x</var>(1), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = <var>fcn</var> ([<var>x</var>(end-1:end), <var>x</var>(end)])</code>. </p> </dd> <dt><code>"periodic"</code></dt> <dd>
<p>The window is wrapped so that any missing data elements are taken from the other side of the data. For example, with a window of length 3, <code><var>y</var>(1) = <var>fcn</var> ([<var>x</var>(end), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = <var>fcn</var> ([<var>x</var>(end-1:end), <var>x</var>(1)])</code>. </p> </dd> </dl> <p>Note that for some of these choices, the window size at the boundaries is not the same as for the central part, and <var>fcn</var> must work in these cases. </p> </dd> <dt><code>"nancond"</code></dt> <dd>
<p>Controls whether <code>NaN</code> and <code>NA</code> values should be included (value: <code>"includenan"</code>), or excluded (value: <code>"omitnan"</code>), from the data passed to <var>fcn</var>. The default is <code>"includenan"</code>. Caution: The <code>"omitnan"</code> option is not yet implemented. </p> </dd> <dt><code>"outdim"</code></dt> <dd>
<p>A row vector that selects which dimensions of the calculation will appear in the output <var>y</var>. This is only useful when <var>fcn</var> returns an N-dimensional array in Format 1. The default is to return all output dimensions. </p> </dd> </dl> <p>Programming Note: The property <code>"outdim"</code> can be used to save memory when the output of <var>fcn</var> has many dimensions, or when a wrapper to the base function that selects the desired outputs is too costly. When memory is not an issue, the easiest way to select output dimensions is to first calculate the complete result with <code>movfun</code> and then filter that result with indexing. If code complexity is not an issue then a wrapper can be created using anonymous functions. For example, if <code>basefcn</code> is a function returning a <var>K</var>-dimensional row output, and only dimension <var>D</var> is desired, then the following wrapper could be used. </p> <pre class="example" data-language="matlab">fcn = @(x) basefcn (x)(:,size(x,2) * (D-1) + (1:size(x,2)));
y = movfun (@fcn, …);</pre> <p><strong>See also:</strong> <a href="#XREFmovslice">movslice</a>, <a href="rearranging-matrices#XREFprepad">prepad</a>, <a href="rearranging-matrices#XREFpostpad">postpad</a>, <a href="rearranging-matrices#XREFpermute">permute</a>, <a href="rearranging-matrices#XREFreshape">reshape</a>. </p>
</dd>
</dl> <dl id="XREFmovslice"> <dt id="index-movslice">slcidx = movslice (N, wlen)</dt> <dt id="index-movslice-1">[slcidx, C, Cpre, Cpost, win] = movslice (…)</dt> <dd>
<p>Generate indices to slice a vector of length <var>N</var> in to windows of length <var>wlen</var>. </p> <p>FIXME: Document inputs N, wlen </p> <p>FIXME: Document outputs slcidx, C, Cpre, Cpost, win. </p> <p><strong>See also:</strong> <a href="#XREFmovfun">movfun</a>. </p>
</dd>
</dl> <dl id="XREFmovmad"> <dt id="index-movmad">y = movmad (x, wlen)</dt> <dt id="index-movmad-1">y = movmad (x, [na, nb])</dt> <dt id="index-movmad-2">y = movmad (…, dim)</dt> <dt id="index-movmad-3">y = movmad (…, "nancond")</dt> <dt id="index-movmad-4">y = movmad (…, property, value)</dt> <dd>
<p>Calculate the moving mean absolute deviation over a sliding window of length <var>wlen</var> on data <var>x</var>. </p> <p>If <var>wlen</var> is a scalar, the function <code>mad</code> is applied to a moving window of length <var>wlen</var>. When <var>wlen</var> is an odd number the window is symmetric and includes <code>(<var>wlen</var> <span class="nolinebreak">-</span> 1) / 2</code> elements on either side of the central element. For example, when calculating the output at index 5 with a window length of 3, <code>movmad</code> uses data elements <code>[4, 5, 6]</code>. If <var>wlen</var> is an even number, the window is asymmetric and has <code><var>wlen</var>/2</code> elements to the left of the central element and <code><var>wlen</var>/2 <span class="nolinebreak">-</span> 1</code> elements to the right of the central element. For example, when calculating the output at index 5 with a window length of 4, <code>movmad</code> uses data elements <code>[3, 4, 5, 6]</code>. </p> <p>If <var>wlen</var> is an array with two elements <code>[<var>nb</var>, <var>na</var>]</code>, the function is applied to a moving window <code>-<var>nb</var>:<var>na</var></code>. This window includes <var>nb</var> number of elements <em>before</em> the current element and <var>na</var> number of elements <em>after</em> the current element. The current element is always included. For example, given <code><var>wlen</var> = [3, 0]</code>, the data used to calculate index 5 is <code>[2, 3, 4, 5]</code>. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The optional string argument <code>"<var>nancond</var>"</code> controls whether <code>NaN</code> and <code>NA</code> values should be included (<code>"includenan"</code>), or excluded (<code>"omitnan"</code>), from the data passed to <code>mad</code>. The default is <code>"includenan"</code>. Caution: the <code>"omitnan"</code> option is not yet implemented. </p> <p>The calculation can be controlled by specifying <var>property</var>/<var>value</var> pairs. Valid properties are </p> <dl compact> <dt><code>"Endpoints"</code></dt> <dd> <p>This property controls how results are calculated at the boundaries (endpoints) of the window. Possible values are: </p> <dl compact> <dt>
<code>"shrink"</code> (default)</dt> <dd>
<p>The window is truncated at the beginning and end of the array to exclude elements for which there is no source data. For example, with a window of length 3, <code><var>y</var>(1) = mad (<var>x</var>(1:2))</code>, and <code><var>y</var>(end) = mad (<var>x</var>(end-1:end))</code>. </p> </dd> <dt><code>"discard"</code></dt> <dd>
<p>Any <var>y</var> values that use a window extending beyond the original data array are deleted. For example, with a 10-element data vector and a window of length 3, the output will contain only 8 elements. The first element would require calculating the function over indices <code>[0, 1, 2]</code> and is therefore discarded. The last element would require calculating the function over indices <code>[9, 10, 11]</code> and is therefore discarded. </p> </dd> <dt><code>"fill"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by <code>NaN</code>. For example, with a window of length 3, <code><var>y</var>(1) = mad ([NaN, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = mad ([<var>x</var>(end-1:end), NaN])</code>. This option usually results in <var>y</var> having <code>NaN</code> values at the boundaries, although it is influenced by how <code>mad</code> handles <code>NaN</code>, and also by the property <code>"nancond"</code>. </p> </dd> <dt><var>user_value</var></dt> <dd>
<p>Any window elements outside the data array are replaced by the specified value <var>user_value</var> which must be a numeric scalar. For example, with a window of length 3, <code><var>y</var>(1) = mad ([<var>user_value</var>, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = mad ([<var>x</var>(end-1:end), <var>user_value</var>])</code>. A common choice for <var>user_value</var> is 0. </p> </dd> <dt><code>"same"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by the value of <var>x</var> at the boundary. For example, with a window of length 3, <code><var>y</var>(1) = mad ([<var>x</var>(1), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = mad ([<var>x</var>(end-1:end), <var>x</var>(end)])</code>. </p> </dd> <dt><code>"periodic"</code></dt> <dd>
<p>The window is wrapped so that any missing data elements are taken from the other side of the data. For example, with a window of length 3, <code><var>y</var>(1) = mad ([<var>x</var>(end), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = mad ([<var>x</var>(end-1:end), <var>x</var>(1)])</code>. </p> </dd> </dl> </dd> <dt><code>"SamplePoints"</code></dt> <dd>
<p>Caution: This option is not yet implemented. </p> </dd> </dl> <p>Programming Note: This function is a wrapper which calls <code>movfun</code>. For additional options and documentation, See <a href="#XREFmovfun">movfun</a>. </p> <p><strong>See also:</strong> <a href="#XREFmovfun">movfun</a>, <a href="#XREFmovslice">movslice</a>, <a href="#XREFmovmax">movmax</a>, <a href="#XREFmovmean">movmean</a>, <a href="#XREFmovmedian">movmedian</a>, <a href="#XREFmovmin">movmin</a>, <a href="#XREFmovprod">movprod</a>, <a href="#XREFmovstd">movstd</a>, <a href="#XREFmovsum">movsum</a>, <a href="#XREFmovvar">movvar</a>. </p>
</dd>
</dl> <dl id="XREFmovmax"> <dt id="index-movmax">y = movmax (x, wlen)</dt> <dt id="index-movmax-1">y = movmax (x, [na, nb])</dt> <dt id="index-movmax-2">y = movmax (…, dim)</dt> <dt id="index-movmax-3">y = movmax (…, "nancond")</dt> <dt id="index-movmax-4">y = movmax (…, property, value)</dt> <dd>
<p>Calculate the moving maximum over a sliding window of length <var>wlen</var> on data <var>x</var>. </p> <p>If <var>wlen</var> is a scalar, the function <code>max</code> is applied to a moving window of length <var>wlen</var>. When <var>wlen</var> is an odd number the window is symmetric and includes <code>(<var>wlen</var> <span class="nolinebreak">-</span> 1) / 2</code> elements on either side of the central element. For example, when calculating the output at index 5 with a window length of 3, <code>movmax</code> uses data elements <code>[4, 5, 6]</code>. If <var>wlen</var> is an even number, the window is asymmetric and has <code><var>wlen</var>/2</code> elements to the left of the central element and <code><var>wlen</var>/2 <span class="nolinebreak">-</span> 1</code> elements to the right of the central element. For example, when calculating the output at index 5 with a window length of 4, <code>movmax</code> uses data elements <code>[3, 4, 5, 6]</code>. </p> <p>If <var>wlen</var> is an array with two elements <code>[<var>nb</var>, <var>na</var>]</code>, the function is applied to a moving window <code>-<var>nb</var>:<var>na</var></code>. This window includes <var>nb</var> number of elements <em>before</em> the current element and <var>na</var> number of elements <em>after</em> the current element. The current element is always included. For example, given <code><var>wlen</var> = [3, 0]</code>, the data used to calculate index 5 is <code>[2, 3, 4, 5]</code>. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The optional string argument <code>"<var>nancond</var>"</code> controls whether <code>NaN</code> and <code>NA</code> values should be included (<code>"includenan"</code>), or excluded (<code>"omitnan"</code>), from the data passed to <code>max</code>. The default is <code>"includenan"</code>. Caution: the <code>"omitnan"</code> option is not yet implemented. </p> <p>The calculation can be controlled by specifying <var>property</var>/<var>value</var> pairs. Valid properties are </p> <dl compact> <dt><code>"Endpoints"</code></dt> <dd> <p>This property controls how results are calculated at the boundaries (endpoints) of the window. Possible values are: </p> <dl compact> <dt>
<code>"shrink"</code> (default)</dt> <dd>
<p>The window is truncated at the beginning and end of the array to exclude elements for which there is no source data. For example, with a window of length 3, <code><var>y</var>(1) = max (<var>x</var>(1:2))</code>, and <code><var>y</var>(end) = max (<var>x</var>(end-1:end))</code>. </p> </dd> <dt><code>"discard"</code></dt> <dd>
<p>Any <var>y</var> values that use a window extending beyond the original data array are deleted. For example, with a 10-element data vector and a window of length 3, the output will contain only 8 elements. The first element would require calculating the function over indices <code>[0, 1, 2]</code> and is therefore discarded. The last element would require calculating the function over indices <code>[9, 10, 11]</code> and is therefore discarded. </p> </dd> <dt><code>"fill"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by <code>NaN</code>. For example, with a window of length 3, <code><var>y</var>(1) = max ([NaN, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = max ([<var>x</var>(end-1:end), NaN])</code>. This option usually results in <var>y</var> having <code>NaN</code> values at the boundaries, although it is influenced by how <code>max</code> handles <code>NaN</code>, and also by the property <code>"nancond"</code>. </p> </dd> <dt><var>user_value</var></dt> <dd>
<p>Any window elements outside the data array are replaced by the specified value <var>user_value</var> which must be a numeric scalar. For example, with a window of length 3, <code><var>y</var>(1) = max ([<var>user_value</var>, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = max ([<var>x</var>(end-1:end), <var>user_value</var>])</code>. A common choice for <var>user_value</var> is 0. </p> </dd> <dt><code>"same"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by the value of <var>x</var> at the boundary. For example, with a window of length 3, <code><var>y</var>(1) = max ([<var>x</var>(1), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = max ([<var>x</var>(end-1:end), <var>x</var>(end)])</code>. </p> </dd> <dt><code>"periodic"</code></dt> <dd>
<p>The window is wrapped so that any missing data elements are taken from the other side of the data. For example, with a window of length 3, <code><var>y</var>(1) = max ([<var>x</var>(end), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = max ([<var>x</var>(end-1:end), <var>x</var>(1)])</code>. </p> </dd> </dl> </dd> <dt><code>"SamplePoints"</code></dt> <dd>
<p>Caution: This option is not yet implemented. </p> </dd> </dl> <p>Programming Note: This function is a wrapper which calls <code>movfun</code>. For additional options and documentation, See <a href="#XREFmovfun">movfun</a>. </p> <p><strong>See also:</strong> <a href="#XREFmovfun">movfun</a>, <a href="#XREFmovslice">movslice</a>, <a href="#XREFmovmad">movmad</a>, <a href="#XREFmovmean">movmean</a>, <a href="#XREFmovmedian">movmedian</a>, <a href="#XREFmovmin">movmin</a>, <a href="#XREFmovprod">movprod</a>, <a href="#XREFmovstd">movstd</a>, <a href="#XREFmovsum">movsum</a>, <a href="#XREFmovvar">movvar</a>. </p>
</dd>
</dl> <dl id="XREFmovmean"> <dt id="index-movmean">y = movmean (x, wlen)</dt> <dt id="index-movmean-1">y = movmean (x, [na, nb])</dt> <dt id="index-movmean-2">y = movmean (…, dim)</dt> <dt id="index-movmean-3">y = movmean (…, "nancond")</dt> <dt id="index-movmean-4">y = movmean (…, property, value)</dt> <dd>
<p>Calculate the moving average over a sliding window of length <var>wlen</var> on data <var>x</var>. </p> <p>If <var>wlen</var> is a scalar, the function <code>mean</code> is applied to a moving window of length <var>wlen</var>. When <var>wlen</var> is an odd number the window is symmetric and includes <code>(<var>wlen</var> <span class="nolinebreak">-</span> 1) / 2</code> elements on either side of the central element. For example, when calculating the output at index 5 with a window length of 3, <code>movmean</code> uses data elements <code>[4, 5, 6]</code>. If <var>wlen</var> is an even number, the window is asymmetric and has <code><var>wlen</var>/2</code> elements to the left of the central element and <code><var>wlen</var>/2 <span class="nolinebreak">-</span> 1</code> elements to the right of the central element. For example, when calculating the output at index 5 with a window length of 4, <code>movmean</code> uses data elements <code>[3, 4, 5, 6]</code>. </p> <p>If <var>wlen</var> is an array with two elements <code>[<var>nb</var>, <var>na</var>]</code>, the function is applied to a moving window <code>-<var>nb</var>:<var>na</var></code>. This window includes <var>nb</var> number of elements <em>before</em> the current element and <var>na</var> number of elements <em>after</em> the current element. The current element is always included. For example, given <code><var>wlen</var> = [3, 0]</code>, the data used to calculate index 5 is <code>[2, 3, 4, 5]</code>. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The optional string argument <code>"<var>nancond</var>"</code> controls whether <code>NaN</code> and <code>NA</code> values should be included (<code>"includenan"</code>), or excluded (<code>"omitnan"</code>), from the data passed to <code>mean</code>. The default is <code>"includenan"</code>. Caution: the <code>"omitnan"</code> option is not yet implemented. </p> <p>The calculation can be controlled by specifying <var>property</var>/<var>value</var> pairs. Valid properties are </p> <dl compact> <dt><code>"Endpoints"</code></dt> <dd> <p>This property controls how results are calculated at the boundaries (endpoints) of the window. Possible values are: </p> <dl compact> <dt>
<code>"shrink"</code> (default)</dt> <dd>
<p>The window is truncated at the beginning and end of the array to exclude elements for which there is no source data. For example, with a window of length 3, <code><var>y</var>(1) = mean (<var>x</var>(1:2))</code>, and <code><var>y</var>(end) = mean (<var>x</var>(end-1:end))</code>. </p> </dd> <dt><code>"discard"</code></dt> <dd>
<p>Any <var>y</var> values that use a window extending beyond the original data array are deleted. For example, with a 10-element data vector and a window of length 3, the output will contain only 8 elements. The first element would require calculating the function over indices <code>[0, 1, 2]</code> and is therefore discarded. The last element would require calculating the function over indices <code>[9, 10, 11]</code> and is therefore discarded. </p> </dd> <dt><code>"fill"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by <code>NaN</code>. For example, with a window of length 3, <code><var>y</var>(1) = mean ([NaN, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = mean ([<var>x</var>(end-1:end), NaN])</code>. This option usually results in <var>y</var> having <code>NaN</code> values at the boundaries, although it is influenced by how <code>mean</code> handles <code>NaN</code>, and also by the property <code>"nancond"</code>. </p> </dd> <dt><var>user_value</var></dt> <dd>
<p>Any window elements outside the data array are replaced by the specified value <var>user_value</var> which must be a numeric scalar. For example, with a window of length 3, <code><var>y</var>(1) = mean ([<var>user_value</var>, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = mean ([<var>x</var>(end-1:end), <var>user_value</var>])</code>. A common choice for <var>user_value</var> is 0. </p> </dd> <dt><code>"same"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by the value of <var>x</var> at the boundary. For example, with a window of length 3, <code><var>y</var>(1) = mean ([<var>x</var>(1), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = mean ([<var>x</var>(end-1:end), <var>x</var>(end)])</code>. </p> </dd> <dt><code>"periodic"</code></dt> <dd>
<p>The window is wrapped so that any missing data elements are taken from the other side of the data. For example, with a window of length 3, <code><var>y</var>(1) = mean ([<var>x</var>(end), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = mean ([<var>x</var>(end-1:end), <var>x</var>(1)])</code>. </p> </dd> </dl> </dd> <dt><code>"SamplePoints"</code></dt> <dd>
<p>Caution: This option is not yet implemented. </p> </dd> </dl> <p>Programming Note: This function is a wrapper which calls <code>movfun</code>. For additional options and documentation, See <a href="#XREFmovfun">movfun</a>. </p> <p><strong>See also:</strong> <a href="#XREFmovfun">movfun</a>, <a href="#XREFmovslice">movslice</a>, <a href="#XREFmovmad">movmad</a>, <a href="#XREFmovmax">movmax</a>, <a href="#XREFmovmedian">movmedian</a>, <a href="#XREFmovmin">movmin</a>, <a href="#XREFmovprod">movprod</a>, <a href="#XREFmovstd">movstd</a>, <a href="#XREFmovsum">movsum</a>, <a href="#XREFmovvar">movvar</a>. </p>
</dd>
</dl> <dl id="XREFmovmedian"> <dt id="index-movmedian">y = movmedian (x, wlen)</dt> <dt id="index-movmedian-1">y = movmedian (x, [na, nb])</dt> <dt id="index-movmedian-2">y = movmedian (…, dim)</dt> <dt id="index-movmedian-3">y = movmedian (…, "nancond")</dt> <dt id="index-movmedian-4">y = movmedian (…, property, value)</dt> <dd>
<p>Calculate the moving median over a sliding window of length <var>wlen</var> on data <var>x</var>. </p> <p>If <var>wlen</var> is a scalar, the function <code>movmedian</code> is applied to a moving window of length <var>wlen</var>. When <var>wlen</var> is an odd number the window is symmetric and includes <code>(<var>wlen</var> <span class="nolinebreak">-</span> 1) / 2</code> elements on either side of the central element. For example, when calculating the output at index 5 with a window length of 3, <code>movmedian</code> uses data elements <code>[4, 5, 6]</code>. If <var>wlen</var> is an even number, the window is asymmetric and has <code><var>wlen</var>/2</code> elements to the left of the central element and <code><var>wlen</var>/2 <span class="nolinebreak">-</span> 1</code> elements to the right of the central element. For example, when calculating the output at index 5 with a window length of 4, <code>movmedian</code> uses data elements <code>[3, 4, 5, 6]</code>. </p> <p>If <var>wlen</var> is an array with two elements <code>[<var>nb</var>, <var>na</var>]</code>, the function is applied to a moving window <code>-<var>nb</var>:<var>na</var></code>. This window includes <var>nb</var> number of elements <em>before</em> the current element and <var>na</var> number of elements <em>after</em> the current element. The current element is always included. For example, given <code><var>wlen</var> = [3, 0]</code>, the data used to calculate index 5 is <code>[2, 3, 4, 5]</code>. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The optional string argument <code>"<var>nancond</var>"</code> controls whether <code>NaN</code> and <code>NA</code> values should be included (<code>"includenan"</code>), or excluded (<code>"omitnan"</code>), from the data passed to <code>movmedian</code>. The default is <code>"includenan"</code>. Caution: the <code>"omitnan"</code> option is not yet implemented. </p> <p>The calculation can be controlled by specifying <var>property</var>/<var>value</var> pairs. Valid properties are </p> <dl compact> <dt><code>"Endpoints"</code></dt> <dd> <p>This property controls how results are calculated at the boundaries (endpoints) of the window. Possible values are: </p> <dl compact> <dt>
<code>"shrink"</code> (default)</dt> <dd>
<p>The window is truncated at the beginning and end of the array to exclude elements for which there is no source data. For example, with a window of length 3, <code><var>y</var>(1) = movmedian (<var>x</var>(1:2))</code>, and <code><var>y</var>(end) = movmedian (<var>x</var>(end-1:end))</code>. </p> </dd> <dt><code>"discard"</code></dt> <dd>
<p>Any <var>y</var> values that use a window extending beyond the original data array are deleted. For example, with a 10-element data vector and a window of length 3, the output will contain only 8 elements. The first element would require calculating the function over indices <code>[0, 1, 2]</code> and is therefore discarded. The last element would require calculating the function over indices <code>[9, 10, 11]</code> and is therefore discarded. </p> </dd> <dt><code>"fill"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by <code>NaN</code>. For example, with a window of length 3, <code><var>y</var>(1) = movmedian ([NaN, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movmedian ([<var>x</var>(end-1:end), NaN])</code>. This option usually results in <var>y</var> having <code>NaN</code> values at the boundaries, although it is influenced by how <code>movmedian</code> handles <code>NaN</code>, and also by the property <code>"nancond"</code>. </p> </dd> <dt><var>user_value</var></dt> <dd>
<p>Any window elements outside the data array are replaced by the specified value <var>user_value</var> which must be a numeric scalar. For example, with a window of length 3, <code><var>y</var>(1) = movmedian ([<var>user_value</var>, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movmedian ([<var>x</var>(end-1:end), <var>user_value</var>])</code>. A common choice for <var>user_value</var> is 0. </p> </dd> <dt><code>"same"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by the value of <var>x</var> at the boundary. For example, with a window of length 3, <code><var>y</var>(1) = movmedian ([<var>x</var>(1), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movmedian ([<var>x</var>(end-1:end), <var>x</var>(end)])</code>. </p> </dd> <dt><code>"periodic"</code></dt> <dd>
<p>The window is wrapped so that any missing data elements are taken from the other side of the data. For example, with a window of length 3, <code><var>y</var>(1) = movmedian ([<var>x</var>(end), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movmedian ([<var>x</var>(end-1:end), <var>x</var>(1)])</code>. </p> </dd> </dl> </dd> <dt><code>"SamplePoints"</code></dt> <dd>
<p>Caution: This option is not yet implemented. </p> </dd> </dl> <p>Programming Note: This function is a wrapper which calls <code>movfun</code>. For additional options and documentation, See <a href="#XREFmovfun">movfun</a>. </p> <p><strong>See also:</strong> <a href="#XREFmovfun">movfun</a>, <a href="#XREFmovslice">movslice</a>, <a href="#XREFmovmad">movmad</a>, <a href="#XREFmovmax">movmax</a>, <a href="#XREFmovmean">movmean</a>, <a href="#XREFmovmin">movmin</a>, <a href="#XREFmovprod">movprod</a>, <a href="#XREFmovstd">movstd</a>, <a href="#XREFmovsum">movsum</a>, <a href="#XREFmovvar">movvar</a>. </p>
</dd>
</dl> <dl id="XREFmovmin"> <dt id="index-movmin">y = movmin (x, wlen)</dt> <dt id="index-movmin-1">y = movmin (x, [na, nb])</dt> <dt id="index-movmin-2">y = movmin (…, dim)</dt> <dt id="index-movmin-3">y = movmin (…, "nancond")</dt> <dt id="index-movmin-4">y = movmin (…, property, value)</dt> <dd>
<p>Calculate the moving minimum over a sliding window of length <var>wlen</var> on data <var>x</var>. </p> <p>If <var>wlen</var> is a scalar, the function <code>min</code> is applied to a moving window of length <var>wlen</var>. When <var>wlen</var> is an odd number the window is symmetric and includes <code>(<var>wlen</var> <span class="nolinebreak">-</span> 1) / 2</code> elements on either side of the central element. For example, when calculating the output at index 5 with a window length of 3, <code>movmin</code> uses data elements <code>[4, 5, 6]</code>. If <var>wlen</var> is an even number, the window is asymmetric and has <code><var>wlen</var>/2</code> elements to the left of the central element and <code><var>wlen</var>/2 <span class="nolinebreak">-</span> 1</code> elements to the right of the central element. For example, when calculating the output at index 5 with a window length of 4, <code>movmin</code> uses data elements <code>[3, 4, 5, 6]</code>. </p> <p>If <var>wlen</var> is an array with two elements <code>[<var>nb</var>, <var>na</var>]</code>, the function is applied to a moving window <code>-<var>nb</var>:<var>na</var></code>. This window includes <var>nb</var> number of elements <em>before</em> the current element and <var>na</var> number of elements <em>after</em> the current element. The current element is always included. For example, given <code><var>wlen</var> = [3, 0]</code>, the data used to calculate index 5 is <code>[2, 3, 4, 5]</code>. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The optional string argument <code>"<var>nancond</var>"</code> controls whether <code>NaN</code> and <code>NA</code> values should be included (<code>"includenan"</code>), or excluded (<code>"omitnan"</code>), from the data passed to <code>min</code>. The default is <code>"includenan"</code>. Caution: the <code>"omitnan"</code> option is not yet implemented. </p> <p>The calculation can be controlled by specifying <var>property</var>/<var>value</var> pairs. Valid properties are </p> <dl compact> <dt><code>"Endpoints"</code></dt> <dd> <p>This property controls how results are calculated at the boundaries (endpoints) of the window. Possible values are: </p> <dl compact> <dt>
<code>"shrink"</code> (default)</dt> <dd>
<p>The window is truncated at the beginning and end of the array to exclude elements for which there is no source data. For example, with a window of length 3, <code><var>y</var>(1) = min (<var>x</var>(1:2))</code>, and <code><var>y</var>(end) = min (<var>x</var>(end-1:end))</code>. </p> </dd> <dt><code>"discard"</code></dt> <dd>
<p>Any <var>y</var> values that use a window extending beyond the original data array are deleted. For example, with a 10-element data vector and a window of length 3, the output will contain only 8 elements. The first element would require calculating the function over indices <code>[0, 1, 2]</code> and is therefore discarded. The last element would require calculating the function over indices <code>[9, 10, 11]</code> and is therefore discarded. </p> </dd> <dt><code>"fill"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by <code>NaN</code>. For example, with a window of length 3, <code><var>y</var>(1) = min ([NaN, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = min ([<var>x</var>(end-1:end), NaN])</code>. This option usually results in <var>y</var> having <code>NaN</code> values at the boundaries, although it is influenced by how <code>min</code> handles <code>NaN</code>, and also by the property <code>"nancond"</code>. </p> </dd> <dt><var>user_value</var></dt> <dd>
<p>Any window elements outside the data array are replaced by the specified value <var>user_value</var> which must be a numeric scalar. For example, with a window of length 3, <code><var>y</var>(1) = min ([<var>user_value</var>, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = min ([<var>x</var>(end-1:end), <var>user_value</var>])</code>. A common choice for <var>user_value</var> is 0. </p> </dd> <dt><code>"same"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by the value of <var>x</var> at the boundary. For example, with a window of length 3, <code><var>y</var>(1) = min ([<var>x</var>(1), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = min ([<var>x</var>(end-1:end), <var>x</var>(end)])</code>. </p> </dd> <dt><code>"periodic"</code></dt> <dd>
<p>The window is wrapped so that any missing data elements are taken from the other side of the data. For example, with a window of length 3, <code><var>y</var>(1) = min ([<var>x</var>(end), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = min ([<var>x</var>(end-1:end), <var>x</var>(1)])</code>. </p> </dd> </dl> </dd> <dt><code>"SamplePoints"</code></dt> <dd>
<p>Caution: This option is not yet implemented. </p> </dd> </dl> <p>Programming Note: This function is a wrapper which calls <code>movfun</code>. For additional options and documentation, See <a href="#XREFmovfun">movfun</a>. </p> <p><strong>See also:</strong> <a href="#XREFmovfun">movfun</a>, <a href="#XREFmovslice">movslice</a>, <a href="#XREFmovmad">movmad</a>, <a href="#XREFmovmax">movmax</a>, <a href="#XREFmovmean">movmean</a>, <a href="#XREFmovmedian">movmedian</a>, <a href="#XREFmovprod">movprod</a>, <a href="#XREFmovstd">movstd</a>, <a href="#XREFmovsum">movsum</a>, <a href="#XREFmovvar">movvar</a>. </p>
</dd>
</dl> <dl id="XREFmovprod"> <dt id="index-movprod">y = movprod (x, wlen)</dt> <dt id="index-movprod-1">y = movprod (x, [na, nb])</dt> <dt id="index-movprod-2">y = movprod (…, dim)</dt> <dt id="index-movprod-3">y = movprod (…, "nancond")</dt> <dt id="index-movprod-4">y = movprod (…, property, value)</dt> <dd>
<p>Calculate the moving product over a sliding window of length <var>wlen</var> on data <var>x</var>. </p> <p>If <var>wlen</var> is a scalar, the function <code>movprod</code> is applied to a moving window of length <var>wlen</var>. When <var>wlen</var> is an odd number the window is symmetric and includes <code>(<var>wlen</var> <span class="nolinebreak">-</span> 1) / 2</code> elements on either side of the central element. For example, when calculating the output at index 5 with a window length of 3, <code>movprod</code> uses data elements <code>[4, 5, 6]</code>. If <var>wlen</var> is an even number, the window is asymmetric and has <code><var>wlen</var>/2</code> elements to the left of the central element and <code><var>wlen</var>/2 <span class="nolinebreak">-</span> 1</code> elements to the right of the central element. For example, when calculating the output at index 5 with a window length of 4, <code>movprod</code> uses data elements <code>[3, 4, 5, 6]</code>. </p> <p>If <var>wlen</var> is an array with two elements <code>[<var>nb</var>, <var>na</var>]</code>, the function is applied to a moving window <code>-<var>nb</var>:<var>na</var></code>. This window includes <var>nb</var> number of elements <em>before</em> the current element and <var>na</var> number of elements <em>after</em> the current element. The current element is always included. For example, given <code><var>wlen</var> = [3, 0]</code>, the data used to calculate index 5 is <code>[2, 3, 4, 5]</code>. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The optional string argument <code>"<var>nancond</var>"</code> controls whether <code>NaN</code> and <code>NA</code> values should be included (<code>"includenan"</code>), or excluded (<code>"omitnan"</code>), from the data passed to <code>movprod</code>. The default is <code>"includenan"</code>. Caution: the <code>"omitnan"</code> option is not yet implemented. </p> <p>The calculation can be controlled by specifying <var>property</var>/<var>value</var> pairs. Valid properties are </p> <dl compact> <dt><code>"Endpoints"</code></dt> <dd> <p>This property controls how results are calculated at the boundaries (endpoints) of the window. Possible values are: </p> <dl compact> <dt>
<code>"shrink"</code> (default)</dt> <dd>
<p>The window is truncated at the beginning and end of the array to exclude elements for which there is no source data. For example, with a window of length 3, <code><var>y</var>(1) = movprod (<var>x</var>(1:2))</code>, and <code><var>y</var>(end) = movprod (<var>x</var>(end-1:end))</code>. </p> </dd> <dt><code>"discard"</code></dt> <dd>
<p>Any <var>y</var> values that use a window extending beyond the original data array are deleted. For example, with a 10-element data vector and a window of length 3, the output will contain only 8 elements. The first element would require calculating the function over indices <code>[0, 1, 2]</code> and is therefore discarded. The last element would require calculating the function over indices <code>[9, 10, 11]</code> and is therefore discarded. </p> </dd> <dt><code>"fill"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by <code>NaN</code>. For example, with a window of length 3, <code><var>y</var>(1) = movprod ([NaN, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movprod ([<var>x</var>(end-1:end), NaN])</code>. This option usually results in <var>y</var> having <code>NaN</code> values at the boundaries, although it is influenced by how <code>movprod</code> handles <code>NaN</code>, and also by the property <code>"nancond"</code>. </p> </dd> <dt><var>user_value</var></dt> <dd>
<p>Any window elements outside the data array are replaced by the specified value <var>user_value</var> which must be a numeric scalar. For example, with a window of length 3, <code><var>y</var>(1) = movprod ([<var>user_value</var>, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movprod ([<var>x</var>(end-1:end), <var>user_value</var>])</code>. A common choice for <var>user_value</var> is 0. </p> </dd> <dt><code>"same"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by the value of <var>x</var> at the boundary. For example, with a window of length 3, <code><var>y</var>(1) = movprod ([<var>x</var>(1), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movprod ([<var>x</var>(end-1:end), <var>x</var>(end)])</code>. </p> </dd> <dt><code>"periodic"</code></dt> <dd>
<p>The window is wrapped so that any missing data elements are taken from the other side of the data. For example, with a window of length 3, <code><var>y</var>(1) = movprod ([<var>x</var>(end), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movprod ([<var>x</var>(end-1:end), <var>x</var>(1)])</code>. </p> </dd> </dl> </dd> <dt><code>"SamplePoints"</code></dt> <dd>
<p>Caution: This option is not yet implemented. </p> </dd> </dl> <p>Programming Note: This function is a wrapper which calls <code>movfun</code>. For additional options and documentation, See <a href="#XREFmovfun">movfun</a>. </p> <p><strong>See also:</strong> <a href="#XREFmovfun">movfun</a>, <a href="#XREFmovslice">movslice</a>, <a href="#XREFmovmad">movmad</a>, <a href="#XREFmovmax">movmax</a>, <a href="#XREFmovmean">movmean</a>, <a href="#XREFmovmedian">movmedian</a>, <a href="#XREFmovmin">movmin</a>, <a href="#XREFmovstd">movstd</a>, <a href="#XREFmovsum">movsum</a>, <a href="#XREFmovvar">movvar</a>. </p>
</dd>
</dl> <dl id="XREFmovstd"> <dt id="index-movstd">y = movstd (x, wlen)</dt> <dt id="index-movstd-1">y = movstd (x, [na, nb])</dt> <dt id="index-movstd-2">y = movstd (…, dim)</dt> <dt id="index-movstd-3">y = movstd (…, "nancond")</dt> <dt id="index-movstd-4">y = movstd (…, property, value)</dt> <dd>
<p>Calculate the moving standard deviation over a sliding window of length <var>wlen</var> on data <var>x</var>. </p> <p>If <var>wlen</var> is a scalar, the function <code>movstd</code> is applied to a moving window of length <var>wlen</var>. When <var>wlen</var> is an odd number the window is symmetric and includes <code>(<var>wlen</var> <span class="nolinebreak">-</span> 1) / 2</code> elements on either side of the central element. For example, when calculating the output at index 5 with a window length of 3, <code>movstd</code> uses data elements <code>[4, 5, 6]</code>. If <var>wlen</var> is an even number, the window is asymmetric and has <code><var>wlen</var>/2</code> elements to the left of the central element and <code><var>wlen</var>/2 <span class="nolinebreak">-</span> 1</code> elements to the right of the central element. For example, when calculating the output at index 5 with a window length of 4, <code>movstd</code> uses data elements <code>[3, 4, 5, 6]</code>. </p> <p>If <var>wlen</var> is an array with two elements <code>[<var>nb</var>, <var>na</var>]</code>, the function is applied to a moving window <code>-<var>nb</var>:<var>na</var></code>. This window includes <var>nb</var> number of elements <em>before</em> the current element and <var>na</var> number of elements <em>after</em> the current element. The current element is always included. For example, given <code><var>wlen</var> = [3, 0]</code>, the data used to calculate index 5 is <code>[2, 3, 4, 5]</code>. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The optional string argument <code>"<var>nancond</var>"</code> controls whether <code>NaN</code> and <code>NA</code> values should be included (<code>"includenan"</code>), or excluded (<code>"omitnan"</code>), from the data passed to <code>movstd</code>. The default is <code>"includenan"</code>. Caution: the <code>"omitnan"</code> option is not yet implemented. </p> <p>The calculation can be controlled by specifying <var>property</var>/<var>value</var> pairs. Valid properties are </p> <dl compact> <dt><code>"Endpoints"</code></dt> <dd> <p>This property controls how results are calculated at the boundaries (endpoints) of the window. Possible values are: </p> <dl compact> <dt>
<code>"shrink"</code> (default)</dt> <dd>
<p>The window is truncated at the beginning and end of the array to exclude elements for which there is no source data. For example, with a window of length 3, <code><var>y</var>(1) = movstd (<var>x</var>(1:2))</code>, and <code><var>y</var>(end) = movstd (<var>x</var>(end-1:end))</code>. </p> </dd> <dt><code>"discard"</code></dt> <dd>
<p>Any <var>y</var> values that use a window extending beyond the original data array are deleted. For example, with a 10-element data vector and a window of length 3, the output will contain only 8 elements. The first element would require calculating the function over indices <code>[0, 1, 2]</code> and is therefore discarded. The last element would require calculating the function over indices <code>[9, 10, 11]</code> and is therefore discarded. </p> </dd> <dt><code>"fill"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by <code>NaN</code>. For example, with a window of length 3, <code><var>y</var>(1) = movstd ([NaN, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movstd ([<var>x</var>(end-1:end), NaN])</code>. This option usually results in <var>y</var> having <code>NaN</code> values at the boundaries, although it is influenced by how <code>movstd</code> handles <code>NaN</code>, and also by the property <code>"nancond"</code>. </p> </dd> <dt><var>user_value</var></dt> <dd>
<p>Any window elements outside the data array are replaced by the specified value <var>user_value</var> which must be a numeric scalar. For example, with a window of length 3, <code><var>y</var>(1) = movstd ([<var>user_value</var>, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movstd ([<var>x</var>(end-1:end), <var>user_value</var>])</code>. A common choice for <var>user_value</var> is 0. </p> </dd> <dt><code>"same"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by the value of <var>x</var> at the boundary. For example, with a window of length 3, <code><var>y</var>(1) = movstd ([<var>x</var>(1), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movstd ([<var>x</var>(end-1:end), <var>x</var>(end)])</code>. </p> </dd> <dt><code>"periodic"</code></dt> <dd>
<p>The window is wrapped so that any missing data elements are taken from the other side of the data. For example, with a window of length 3, <code><var>y</var>(1) = movstd ([<var>x</var>(end), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movstd ([<var>x</var>(end-1:end), <var>x</var>(1)])</code>. </p> </dd> </dl> </dd> <dt><code>"SamplePoints"</code></dt> <dd>
<p>Caution: This option is not yet implemented. </p> </dd> </dl> <p>Programming Note: This function is a wrapper which calls <code>movfun</code>. For additional options and documentation, See <a href="#XREFmovfun">movfun</a>. </p> <p><strong>See also:</strong> <a href="#XREFmovfun">movfun</a>, <a href="#XREFmovslice">movslice</a>, <a href="#XREFmovmad">movmad</a>, <a href="#XREFmovmax">movmax</a>, <a href="#XREFmovmean">movmean</a>, <a href="#XREFmovmedian">movmedian</a>, <a href="#XREFmovmin">movmin</a>, <a href="#XREFmovprod">movprod</a>, <a href="#XREFmovsum">movsum</a>, <a href="#XREFmovvar">movvar</a>. </p>
</dd>
</dl> <dl id="XREFmovsum"> <dt id="index-movsum">y = movsum (x, wlen)</dt> <dt id="index-movsum-1">y = movsum (x, [na, nb])</dt> <dt id="index-movsum-2">y = movsum (…, dim)</dt> <dt id="index-movsum-3">y = movsum (…, "nancond")</dt> <dt id="index-movsum-4">y = movsum (…, property, value)</dt> <dd>
<p>Calculate the moving sum over a sliding window of length <var>wlen</var> on data <var>x</var>. </p> <p>If <var>wlen</var> is a scalar, the function <code>movsum</code> is applied to a moving window of length <var>wlen</var>. When <var>wlen</var> is an odd number the window is symmetric and includes <code>(<var>wlen</var> <span class="nolinebreak">-</span> 1) / 2</code> elements on either side of the central element. For example, when calculating the output at index 5 with a window length of 3, <code>movsum</code> uses data elements <code>[4, 5, 6]</code>. If <var>wlen</var> is an even number, the window is asymmetric and has <code><var>wlen</var>/2</code> elements to the left of the central element and <code><var>wlen</var>/2 <span class="nolinebreak">-</span> 1</code> elements to the right of the central element. For example, when calculating the output at index 5 with a window length of 4, <code>movsum</code> uses data elements <code>[3, 4, 5, 6]</code>. </p> <p>If <var>wlen</var> is an array with two elements <code>[<var>nb</var>, <var>na</var>]</code>, the function is applied to a moving window <code>-<var>nb</var>:<var>na</var></code>. This window includes <var>nb</var> number of elements <em>before</em> the current element and <var>na</var> number of elements <em>after</em> the current element. The current element is always included. For example, given <code><var>wlen</var> = [3, 0]</code>, the data used to calculate index 5 is <code>[2, 3, 4, 5]</code>. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The optional string argument <code>"<var>nancond</var>"</code> controls whether <code>NaN</code> and <code>NA</code> values should be included (<code>"includenan"</code>), or excluded (<code>"omitnan"</code>), from the data passed to <code>movsum</code>. The default is <code>"includenan"</code>. Caution: the <code>"omitnan"</code> option is not yet implemented. </p> <p>The calculation can be controlled by specifying <var>property</var>/<var>value</var> pairs. Valid properties are </p> <dl compact> <dt><code>"Endpoints"</code></dt> <dd> <p>This property controls how results are calculated at the boundaries (endpoints) of the window. Possible values are: </p> <dl compact> <dt>
<code>"shrink"</code> (default)</dt> <dd>
<p>The window is truncated at the beginning and end of the array to exclude elements for which there is no source data. For example, with a window of length 3, <code><var>y</var>(1) = movsum (<var>x</var>(1:2))</code>, and <code><var>y</var>(end) = movsum (<var>x</var>(end-1:end))</code>. </p> </dd> <dt><code>"discard"</code></dt> <dd>
<p>Any <var>y</var> values that use a window extending beyond the original data array are deleted. For example, with a 10-element data vector and a window of length 3, the output will contain only 8 elements. The first element would require calculating the function over indices <code>[0, 1, 2]</code> and is therefore discarded. The last element would require calculating the function over indices <code>[9, 10, 11]</code> and is therefore discarded. </p> </dd> <dt><code>"fill"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by <code>NaN</code>. For example, with a window of length 3, <code><var>y</var>(1) = movsum ([NaN, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movsum ([<var>x</var>(end-1:end), NaN])</code>. This option usually results in <var>y</var> having <code>NaN</code> values at the boundaries, although it is influenced by how <code>movsum</code> handles <code>NaN</code>, and also by the property <code>"nancond"</code>. </p> </dd> <dt><var>user_value</var></dt> <dd>
<p>Any window elements outside the data array are replaced by the specified value <var>user_value</var> which must be a numeric scalar. For example, with a window of length 3, <code><var>y</var>(1) = movsum ([<var>user_value</var>, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movsum ([<var>x</var>(end-1:end), <var>user_value</var>])</code>. A common choice for <var>user_value</var> is 0. </p> </dd> <dt><code>"same"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by the value of <var>x</var> at the boundary. For example, with a window of length 3, <code><var>y</var>(1) = movsum ([<var>x</var>(1), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movsum ([<var>x</var>(end-1:end), <var>x</var>(end)])</code>. </p> </dd> <dt><code>"periodic"</code></dt> <dd>
<p>The window is wrapped so that any missing data elements are taken from the other side of the data. For example, with a window of length 3, <code><var>y</var>(1) = movsum ([<var>x</var>(end), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = movsum ([<var>x</var>(end-1:end), <var>x</var>(1)])</code>. </p> </dd> </dl> </dd> <dt><code>"SamplePoints"</code></dt> <dd>
<p>Caution: This option is not yet implemented. </p> </dd> </dl> <p>Programming Note: This function is a wrapper which calls <code>movfun</code>. For additional options and documentation, See <a href="#XREFmovfun">movfun</a>. </p> <p><strong>See also:</strong> <a href="#XREFmovfun">movfun</a>, <a href="#XREFmovslice">movslice</a>, <a href="#XREFmovmad">movmad</a>, <a href="#XREFmovmax">movmax</a>, <a href="#XREFmovmean">movmean</a>, <a href="#XREFmovmedian">movmedian</a>, <a href="#XREFmovmin">movmin</a>, <a href="#XREFmovprod">movprod</a>, <a href="#XREFmovstd">movstd</a>, <a href="#XREFmovvar">movvar</a>. </p>
</dd>
</dl> <dl id="XREFmovvar"> <dt id="index-movvar">y = movvar (x, wlen)</dt> <dt id="index-movvar-1">y = movvar (x, [na, nb])</dt> <dt id="index-movvar-2">y = movvar (…, dim)</dt> <dt id="index-movvar-3">y = movvar (…, "nancond")</dt> <dt id="index-movvar-4">y = movvar (…, property, value)</dt> <dd>
<p>Calculate the moving variance over a sliding window of length <var>wlen</var> on data <var>x</var>. </p> <p>If <var>wlen</var> is a scalar, the function <code>var</code> is applied to a moving window of length <var>wlen</var>. When <var>wlen</var> is an odd number the window is symmetric and includes <code>(<var>wlen</var> <span class="nolinebreak">-</span> 1) / 2</code> elements on either side of the central element. For example, when calculating the output at index 5 with a window length of 3, <code>movvar</code> uses data elements <code>[4, 5, 6]</code>. If <var>wlen</var> is an even number, the window is asymmetric and has <code><var>wlen</var>/2</code> elements to the left of the central element and <code><var>wlen</var>/2 <span class="nolinebreak">-</span> 1</code> elements to the right of the central element. For example, when calculating the output at index 5 with a window length of 4, <code>movvar</code> uses data elements <code>[3, 4, 5, 6]</code>. </p> <p>If <var>wlen</var> is an array with two elements <code>[<var>nb</var>, <var>na</var>]</code>, the function is applied to a moving window <code>-<var>nb</var>:<var>na</var></code>. This window includes <var>nb</var> number of elements <em>before</em> the current element and <var>na</var> number of elements <em>after</em> the current element. The current element is always included. For example, given <code><var>wlen</var> = [3, 0]</code>, the data used to calculate index 5 is <code>[2, 3, 4, 5]</code>. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>The optional string argument <code>"<var>nancond</var>"</code> controls whether <code>NaN</code> and <code>NA</code> values should be included (<code>"includenan"</code>), or excluded (<code>"omitnan"</code>), from the data passed to <code>var</code>. The default is <code>"includenan"</code>. Caution: the <code>"omitnan"</code> option is not yet implemented. </p> <p>The calculation can be controlled by specifying <var>property</var>/<var>value</var> pairs. Valid properties are </p> <dl compact> <dt><code>"Endpoints"</code></dt> <dd> <p>This property controls how results are calculated at the boundaries (endpoints) of the window. Possible values are: </p> <dl compact> <dt>
<code>"shrink"</code> (default)</dt> <dd>
<p>The window is truncated at the beginning and end of the array to exclude elements for which there is no source data. For example, with a window of length 3, <code><var>y</var>(1) = var (<var>x</var>(1:2))</code>, and <code><var>y</var>(end) = var (<var>x</var>(end-1:end))</code>. </p> </dd> <dt><code>"discard"</code></dt> <dd>
<p>Any <var>y</var> values that use a window extending beyond the original data array are deleted. For example, with a 10-element data vector and a window of length 3, the output will contain only 8 elements. The first element would require calculating the function over indices <code>[0, 1, 2]</code> and is therefore discarded. The last element would require calculating the function over indices <code>[9, 10, 11]</code> and is therefore discarded. </p> </dd> <dt><code>"fill"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by <code>NaN</code>. For example, with a window of length 3, <code><var>y</var>(1) = var ([NaN, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = var ([<var>x</var>(end-1:end), NaN])</code>. This option usually results in <var>y</var> having <code>NaN</code> values at the boundaries, although it is influenced by how <code>var</code> handles <code>NaN</code>, and also by the property <code>"nancond"</code>. </p> </dd> <dt><var>user_value</var></dt> <dd>
<p>Any window elements outside the data array are replaced by the specified value <var>user_value</var> which must be a numeric scalar. For example, with a window of length 3, <code><var>y</var>(1) = var ([<var>user_value</var>, <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = var ([<var>x</var>(end-1:end), <var>user_value</var>])</code>. A common choice for <var>user_value</var> is 0. </p> </dd> <dt><code>"same"</code></dt> <dd>
<p>Any window elements outside the data array are replaced by the value of <var>x</var> at the boundary. For example, with a window of length 3, <code><var>y</var>(1) = var ([<var>x</var>(1), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = var ([<var>x</var>(end-1:end), <var>x</var>(end)])</code>. </p> </dd> <dt><code>"periodic"</code></dt> <dd>
<p>The window is wrapped so that any missing data elements are taken from the other side of the data. For example, with a window of length 3, <code><var>y</var>(1) = var ([<var>x</var>(end), <var>x</var>(1:2)])</code>, and <code><var>y</var>(end) = var ([<var>x</var>(end-1:end), <var>x</var>(1)])</code>. </p> </dd> </dl> </dd> <dt><code>"SamplePoints"</code></dt> <dd>
<p>Caution: This option is not yet implemented. </p> </dd> </dl> <p>Programming Note: This function is a wrapper which calls <code>movfun</code>. For additional options and documentation, See <a href="#XREFmovfun">movfun</a>. </p> <p><strong>See also:</strong> <a href="#XREFmovfun">movfun</a>, <a href="#XREFmovslice">movslice</a>, <a href="#XREFmovmad">movmad</a>, <a href="#XREFmovmax">movmax</a>, <a href="#XREFmovmean">movmean</a>, <a href="#XREFmovmedian">movmedian</a>, <a href="#XREFmovmin">movmin</a>, <a href="#XREFmovprod">movprod</a>, <a href="#XREFmovstd">movstd</a>, <a href="#XREFmovsum">movsum</a>. </p>
</dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
          © 1996–2018 John W. Eaton<br>      Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://octave.org/doc/interpreter/Statistics-on-Sliding-Windows-of-Data.html" class="_attribution-link">https://octave.org/doc/interpreter/Statistics-on-Sliding-Windows-of-Data.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
