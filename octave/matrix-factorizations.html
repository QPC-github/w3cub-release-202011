
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Matrix Factorizations - Octave - W3cubDocs</title>
  
  <meta name="description" content=" Compute the upper Cholesky factor, R, of the real symmetric or complex Hermitian positive definite matrix A. ">
  <meta name="keywords" content="matrix, factorizations, octave">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/octave/matrix-factorizations.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/octave.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/octave/" class="_nav-link" title="" style="margin-left:0;">Octave</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _octave">
				
				
<h1 class="section">18.3 Matrix Factorizations</h1>  <dl id="XREFchol"> <dt id="index-chol">R = chol (A)</dt> <dt id="index-chol-1">[R, p] = chol (A)</dt> <dt id="index-chol-2">[R, p, Q] = chol (A)</dt> <dt id="index-chol-3">[R, p, Q] = chol (A, "vector")</dt> <dt id="index-chol-4">[L, …] = chol (…, "lower")</dt> <dt id="index-chol-5">[R, …] = chol (…, "upper")</dt> <dd>
 <p>Compute the upper Cholesky factor, <var>R</var>, of the real symmetric or complex Hermitian positive definite matrix <var>A</var>. </p> <p>The upper Cholesky factor <var>R</var> is computed by using the upper triangular part of matrix <var>A</var> and is defined by </p> <pre class="example" data-language="matlab">R' * R = A.</pre> <p>Calling <code>chol</code> using the optional <code>"upper"</code> flag has the same behavior. In contrast, using the optional <code>"lower"</code> flag, <code>chol</code> returns the lower triangular factorization, computed by using the lower triangular part of matrix <var>A</var>, such that </p> <pre class="example" data-language="matlab">L * L' = A.</pre> <p>Called with one output argument <code>chol</code> fails if matrix <var>A</var> is not positive definite. Note that if matrix <var>A</var> is not real symmetric or complex Hermitian then the lower triangular part is considered to be the (complex conjugate) transpose of the upper triangular part, or vice versa, given the <code>"lower"</code> flag. </p> <p>Called with two or more output arguments <var>p</var> flags whether the matrix <var>A</var> was positive definite and <code>chol</code> does not fail. A zero value of <var>p</var> indicates that matrix <var>A</var> is positive definite and <var>R</var> gives the factorization. Otherwise, <var>p</var> will have a positive value. </p> <p>If called with three output arguments matrix <var>A</var> must be sparse and a sparsity preserving row/column permutation is applied to matrix <var>A</var> prior to the factorization. That is <var>R</var> is the factorization of <code><var>A</var>(<var>Q</var>,<var>Q</var>)</code> such that </p> <pre class="example" data-language="matlab">R' * R = Q' * A * Q.</pre> <p>The sparsity preserving permutation is generally returned as a matrix. However, given the optional flag <code>"vector"</code>, <var>Q</var> will be returned as a vector such that </p> <pre class="example" data-language="matlab">R' * R = A(Q, Q).</pre> <p>In general the lower triangular factorization is significantly faster for sparse matrices. </p> <p><strong>See also:</strong> <a href="#XREFhess">hess</a>, <a href="#XREFlu">lu</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqz">qz</a>, <a href="#XREFschur">schur</a>, <a href="#XREFsvd">svd</a>, <a href="iterative-techniques#XREFichol">ichol</a>, <a href="#XREFcholinv">cholinv</a>, <a href="#XREFchol2inv">chol2inv</a>, <a href="#XREFcholupdate">cholupdate</a>, <a href="#XREFcholinsert">cholinsert</a>, <a href="#XREFcholdelete">choldelete</a>, <a href="#XREFcholshift">cholshift</a>. </p>
</dd>
</dl> <dl id="XREFcholinv"> <dt id="index-cholinv">cholinv (A)</dt> <dd>
<p>Compute the inverse of the symmetric positive definite matrix <var>A</var> using the Cholesky factorization. </p> <p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFchol2inv">chol2inv</a>, <a href="basic-matrix-functions#XREFinv">inv</a>. </p>
</dd>
</dl> <dl id="XREFchol2inv"> <dt id="index-chol2inv">chol2inv (U)</dt> <dd>
<p>Invert a symmetric, positive definite square matrix from its Cholesky decomposition, <var>U</var>. </p> <p>Note that <var>U</var> should be an upper-triangular matrix with positive diagonal elements. <code>chol2inv (<var>U</var>)</code> provides <code>inv (<var>U</var>'*<var>U</var>)</code> but it is much faster than using <code>inv</code>. </p> <p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFcholinv">cholinv</a>, <a href="basic-matrix-functions#XREFinv">inv</a>. </p>
</dd>
</dl> <dl id="XREFcholupdate"> <dt id="index-cholupdate">[R1, info] = cholupdate (R, u, op)</dt> <dd>
<p>Update or downdate a Cholesky factorization. </p> <p>Given an upper triangular matrix <var>R</var> and a column vector <var>u</var>, attempt to determine another upper triangular matrix <var>R1</var> such that </p> <ul> <li> <var>R1</var>’*<var>R1</var> = <var>R</var>’*<var>R</var> + <var>u</var>*<var>u</var>’ if <var>op</var> is <code>"+"</code> </li>
<li> <var>R1</var>’*<var>R1</var> = <var>R</var>’*<var>R</var> - <var>u</var>*<var>u</var>’ if <var>op</var> is <code>"-"</code> </li>
</ul> <p>If <var>op</var> is <code>"-"</code>, <var>info</var> is set to </p> <ul> <li> 0 if the downdate was successful, </li>
<li> 1 if <var>R</var>’*<var>R</var> - <var>u</var>*<var>u</var>’ is not positive definite, </li>
<li> 2 if <var>R</var> is singular. </li>
</ul> <p>If <var>info</var> is not present, an error message is printed in cases 1 and 2. </p> <p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFcholinsert">cholinsert</a>, <a href="#XREFcholdelete">choldelete</a>, <a href="#XREFcholshift">cholshift</a>. </p>
</dd>
</dl> <dl id="XREFcholinsert"> <dt id="index-cholinsert">R1 = cholinsert (R, j, u)</dt> <dt id="index-cholinsert-1">[R1, info] = cholinsert (R, j, u)</dt> <dd>
<p>Update a Cholesky factorization given a row or column to insert in the original factored matrix. </p> <p>Given a Cholesky factorization of a real symmetric or complex Hermitian positive definite matrix <var>A</var> = <var>R</var>’*<var>R</var>, <var>R</var> upper triangular, return the Cholesky factorization of <var>A1</var>, where A1(p,p) = A, A1(:,j) = A1(j,:)’ = u and p = <span class="nolinebreak">[1:j-1,j+1:n+1]</span>. u(j) should be positive. </p> <p>On return, <var>info</var> is set to </p> <ul> <li> 0 if the insertion was successful, </li>
<li> 1 if <var>A1</var> is not positive definite, </li>
<li> 2 if <var>R</var> is singular. </li>
</ul> <p>If <var>info</var> is not present, an error message is printed in cases 1 and 2. </p> <p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFcholupdate">cholupdate</a>, <a href="#XREFcholdelete">choldelete</a>, <a href="#XREFcholshift">cholshift</a>. </p>
</dd>
</dl> <dl id="XREFcholdelete"> <dt id="index-choldelete">R1 = choldelete (R, j)</dt> <dd>
<p>Update a Cholesky factorization given a row or column to delete from the original factored matrix. </p> <p>Given a Cholesky factorization of a real symmetric or complex Hermitian positive definite matrix <var>A</var> = <var>R</var>’*<var>R</var>, <var>R</var> upper triangular, return the Cholesky factorization of A(p,p), where p = <span class="nolinebreak">[1:j-1,j+1:n+1]</span>. </p> <p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFcholupdate">cholupdate</a>, <a href="#XREFcholinsert">cholinsert</a>, <a href="#XREFcholshift">cholshift</a>. </p>
</dd>
</dl> <dl id="XREFcholshift"> <dt id="index-cholshift">R1 = cholshift (R, i, j)</dt> <dd>
<p>Update a Cholesky factorization given a range of columns to shift in the original factored matrix. </p> <p>Given a Cholesky factorization of a real symmetric or complex Hermitian positive definite matrix <var>A</var> = <var>R</var>’*<var>R</var>, <var>R</var> upper triangular, return the Cholesky factorization of <var>A</var>(p,p), where p is the permutation <br> <code>p = [1:i-1, shift(i:j, 1), j+1:n]</code> if <var>i</var> &lt; <var>j</var> <br> or <br> <code>p = [1:j-1, shift(j:i,-1), i+1:n]</code> if <var>j</var> &lt; <var>i</var>. <br> </p> <p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFcholupdate">cholupdate</a>, <a href="#XREFcholinsert">cholinsert</a>, <a href="#XREFcholdelete">choldelete</a>. </p>
</dd>
</dl> <dl id="XREFhess"> <dt id="index-hess">H = hess (A)</dt> <dt id="index-hess-1">[P, H] = hess (A)</dt> <dd>
 <p>Compute the Hessenberg decomposition of the matrix <var>A</var>. </p> <p>The Hessenberg decomposition is <code><var>P</var> * <var>H</var> * <var>P</var>' = <var>A</var></code> where <var>P</var> is a square unitary matrix (<code><var>P</var>' * <var>P</var> = I</code>, using complex-conjugate transposition) and <var>H</var> is upper Hessenberg (<code><var>H</var>(i, j) = 0 forall i &gt; j+1)</code>. </p> <p>The Hessenberg decomposition is usually used as the first step in an eigenvalue computation, but has other applications as well (see Golub, Nash, and Van Loan, IEEE Transactions on Automatic Control, 1979). </p> <p><strong>See also:</strong> <a href="basic-matrix-functions#XREFeig">eig</a>, <a href="#XREFchol">chol</a>, <a href="#XREFlu">lu</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqz">qz</a>, <a href="#XREFschur">schur</a>, <a href="#XREFsvd">svd</a>. </p>
</dd>
</dl> <dl id="XREFlu"> <dt id="index-lu">[L, U] = lu (A)</dt> <dt id="index-lu-1">[L, U, P] = lu (A)</dt> <dt id="index-lu-2">[L, U, P, Q] = lu (S)</dt> <dt id="index-lu-3">[L, U, P, Q, R] = lu (S)</dt> <dt id="index-lu-4">[…] = lu (S, thres)</dt> <dt id="index-lu-5">y = lu (…)</dt> <dt id="index-lu-6">[…] = lu (…, "vector")</dt> <dd>
 <p>Compute the LU decomposition of <var>A</var>. </p> <p>If <var>A</var> is full then subroutines from <small>LAPACK</small> are used, and if <var>A</var> is sparse then <small>UMFPACK</small> is used. </p> <p>The result is returned in a permuted form, according to the optional return value <var>P</var>. For example, given the matrix <code>a = [1, 2; 3, 4]</code>, </p> <pre class="example" data-language="matlab">[l, u, p] = lu (a)</pre> <p>returns </p> <pre class="example" data-language="matlab">l =

  1.00000  0.00000
  0.33333  1.00000

u =

  3.00000  4.00000
  0.00000  0.66667

p =

  0  1
  1  0</pre> <p>The matrix is not required to be square. </p> <p>When called with two or three output arguments and a sparse input matrix, <code>lu</code> does not attempt to perform sparsity preserving column permutations. Called with a fourth output argument, the sparsity preserving column transformation <var>Q</var> is returned, such that <code><var>P</var> * <var>A</var> * <var>Q</var> = <var>L</var> * <var>U</var></code>. This is the <strong>preferred</strong> way to call <code>lu</code> with sparse input matrices. </p> <p>Called with a fifth output argument and a sparse input matrix, <code>lu</code> attempts to use a scaling factor <var>R</var> on the input matrix such that <code><var>P</var> * (<var>R</var> \ <var>A</var>) * <var>Q</var> = <var>L</var> * <var>U</var></code>. This typically leads to a sparser and more stable factorization. </p> <p>An additional input argument <var>thres</var>, that defines the pivoting threshold can be given. <var>thres</var> can be a scalar, in which case it defines the <small>UMFPACK</small> pivoting tolerance for both symmetric and unsymmetric cases. If <var>thres</var> is a 2-element vector, then the first element defines the pivoting tolerance for the unsymmetric <small>UMFPACK</small> pivoting strategy and the second for the symmetric strategy. By default, the values defined by <code>spparms</code> are used ([0.1, 0.001]). </p> <p>Given the string argument <code>"vector"</code>, <code>lu</code> returns the values of <var>P</var> and <var>Q</var> as vector values, such that for full matrix, <code><var>A</var>(<var>P</var>,:) = <var>L</var> * <var>U</var></code>, and <code><var>R</var>(<var>P</var>,:)
* <var>A</var>(:,<var>Q</var>) = <var>L</var> * <var>U</var></code>. </p> <p>With two output arguments, returns the permuted forms of the upper and lower triangular matrices, such that <code><var>A</var> = <var>L</var> * <var>U</var></code>. With one output argument <var>y</var>, then the matrix returned by the <small>LAPACK</small> routines is returned. If the input matrix is sparse then the matrix <var>L</var> is embedded into <var>U</var> to give a return value similar to the full case. For both full and sparse matrices, <code>lu</code> loses the permutation information. </p> <p><strong>See also:</strong> <a href="#XREFluupdate">luupdate</a>, <a href="iterative-techniques#XREFilu">ilu</a>, <a href="#XREFchol">chol</a>, <a href="#XREFhess">hess</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqz">qz</a>, <a href="#XREFschur">schur</a>, <a href="#XREFsvd">svd</a>. </p>
</dd>
</dl> <dl id="XREFluupdate"> <dt id="index-luupdate">[L, U] = luupdate (L, U, x, y)</dt> <dt id="index-luupdate-1">[L, U, P] = luupdate (L, U, P, x, y)</dt> <dd>
<p>Given an LU factorization of a real or complex matrix <var>A</var> = <var>L</var>*<var>U</var>, <var>L</var> lower unit trapezoidal and <var>U</var> upper trapezoidal, return the LU factorization of <var>A</var> + <var>x</var>*<var>y</var>.’, where <var>x</var> and <var>y</var> are column vectors (rank-1 update) or matrices with equal number of columns (rank-k update). </p> <p>Optionally, row-pivoted updating can be used by supplying a row permutation (pivoting) matrix <var>P</var>; in that case, an updated permutation matrix is returned. Note that if <var>L</var>, <var>U</var>, <var>P</var> is a pivoted LU factorization as obtained by <code>lu</code>: </p> <pre class="example" data-language="matlab">[L, U, P] = lu (A);</pre> <p>then a factorization of <code><var>A</var>+<var>x</var>*<var>y</var>.'</code> can be obtained either as </p> <pre class="example" data-language="matlab">[L1, U1] = lu (L, U, P*x, y)</pre> <p>or </p> <pre class="example" data-language="matlab">[L1, U1, P1] = lu (L, U, P, x, y)</pre> <p>The first form uses the unpivoted algorithm, which is faster, but less stable. The second form uses a slower pivoted algorithm, which is more stable. </p> <p>The matrix case is done as a sequence of rank-1 updates; thus, for large enough k, it will be both faster and more accurate to recompute the factorization from scratch. </p> <p><strong>See also:</strong> <a href="#XREFlu">lu</a>, <a href="#XREFcholupdate">cholupdate</a>, <a href="#XREFqrupdate">qrupdate</a>. </p>
</dd>
</dl> <dl id="XREFqr"> <dt id="index-qr">[Q, R] = qr (A)</dt> <dt id="index-qr-1">[Q, R, P] = qr (A) # non-sparse A</dt> <dt id="index-qr-2">X = qr (A) # non-sparse A</dt> <dt id="index-qr-3">R = qr (A) # sparse A</dt> <dt id="index-qr-4">[C, R] = qr (A, B)</dt> <dt id="index-qr-5">[…] = qr (…, 0)</dt> <dt id="index-qr-6">[…] = qr (…, "vector")</dt> <dt id="index-qr-7">[…] = qr (…, "matrix")</dt> <dd>
 <p>Compute the QR factorization of <var>A</var>, using standard <small>LAPACK</small> subroutines. </p> <p>The QR factorization is </p> <pre class="example" data-language="matlab">Q * R = A</pre> <p>where <var>Q</var> is an orthogonal matrix and <var>R</var> is upper triangular. </p> <p>For example, given the matrix <code><var>A</var> = [1, 2; 3, 4]</code>, </p> <pre class="example" data-language="matlab">[Q, R] = qr (A)</pre> <p>returns </p> <pre class="example" data-language="matlab">Q =

  -0.31623  -0.94868
  -0.94868   0.31623

R =

  -3.16228  -4.42719
   0.00000  -0.63246</pre> <p>which multiplied together return the original matrix </p> <pre class="example" data-language="matlab">Q * R
  ⇒
     1.0000   2.0000
     3.0000   4.0000</pre> <p>If just a single return value is requested then it is either <var>R</var>, if <var>A</var> is sparse, or <var>X</var>, such that <code><var>R</var> = triu (<var>X</var>)</code> if <var>A</var> is full. (Note: unlike most commands, the single return value is not the first return value when multiple values are requested.) </p> <p>If the matrix <var>A</var> is full, and a third output <var>P</var> is requested, then <code>qr</code> calculates the permuted QR factorization </p> <pre class="example" data-language="matlab">Q * R = A * P</pre> <p>where <var>Q</var> is an orthogonal matrix, <var>R</var> is upper triangular, and <var>P</var> is a permutation matrix. </p> <p>The permuted QR factorization has the additional property that the diagonal entries of <var>R</var> are ordered by decreasing magnitude. In other words, <code>abs (diag (<var>R</var>))</code> will be ordered from largest to smallest. </p> <p>For example, given the matrix <code><var>A</var> = [1, 2; 3, 4]</code>, </p> <pre class="example" data-language="matlab">[Q, R, P] = qr (A)</pre> <p>returns </p> <pre class="example" data-language="matlab">Q =

  -0.44721  -0.89443
  -0.89443   0.44721

R =

  -4.47214  -3.13050
   0.00000   0.44721

P =

   0  1
   1  0</pre> <p>If the input matrix <var>A</var> is sparse then the sparse QR factorization is computed using <small>CSPARSE</small>. Because the matrix <var>Q</var> is, in general, a full matrix, it is recommended to request only one return value <var>R</var>. In that case, the computation avoids the construction of <var>Q</var> and returns <var>R</var> such that <code><var>R</var> = chol (<var>A</var>' * <var>A</var>)</code>. </p> <p>If an additional matrix <var>B</var> is supplied and two return values are requested, then <code>qr</code> returns <var>C</var>, where <code><var>C</var> = <var>Q</var>' * <var>B</var></code>. This allows the least squares approximation of <code><var>A</var> \ <var>B</var></code> to be calculated as </p> <pre class="example" data-language="matlab">[C, R] = qr (A, B)
x = R \ C</pre> <p>If the final argument is the string <code>"vector"</code> then <var>P</var> is a permutation vector (of the columns of <var>A</var>) instead of a permutation matrix. In this case, the defining relationship is </p> <pre class="example" data-language="matlab">Q * R = A(:, P)</pre> <p>The default, however, is to return a permutation matrix and this may be explicitly specified by using a final argument of <code>"matrix"</code>. </p> <p>If the final argument is the scalar 0 an <code>"economy"</code> factorization is returned. When the original matrix <var>A</var> has size MxN and M &gt; N then the <code>"economy"</code> factorization will calculate just N rows in <var>R</var> and N columns in <var>Q</var> and omit the zeros in <var>R</var>. If M ≤ N there is no difference between the economy and standard factorizations. When calculating an <code>"economy"</code> factorization the output <var>P</var> is always a vector rather than a matrix. </p> <p>Background: The QR factorization has applications in the solution of least squares problems </p> <pre class="example" data-language="matlab">min norm (A*x - b)</pre> <p>for overdetermined systems of equations (i.e., <var>A</var> is a tall, thin matrix). </p> <p>The permuted QR factorization <code>[<var>Q</var>, <var>R</var>, <var>P</var>] = qr (<var>A</var>)</code> allows the construction of an orthogonal basis of <code>span (A)</code>. </p> <p><strong>See also:</strong> <a href="#XREFchol">chol</a>, <a href="#XREFhess">hess</a>, <a href="#XREFlu">lu</a>, <a href="#XREFqz">qz</a>, <a href="#XREFschur">schur</a>, <a href="#XREFsvd">svd</a>, <a href="#XREFqrupdate">qrupdate</a>, <a href="#XREFqrinsert">qrinsert</a>, <a href="#XREFqrdelete">qrdelete</a>, <a href="#XREFqrshift">qrshift</a>. </p>
</dd>
</dl> <dl id="XREFqrupdate"> <dt id="index-qrupdate">[Q1, R1] = qrupdate (Q, R, u, v)</dt> <dd>
<p>Update a QR factorization given update vectors or matrices. </p> <p>Given a QR factorization of a real or complex matrix <var>A</var> = <var>Q</var>*<var>R</var>, <var>Q</var> unitary and <var>R</var> upper trapezoidal, return the QR factorization of <var>A</var> + <var>u</var>*<var>v</var>’, where <var>u</var> and <var>v</var> are column vectors (rank-1 update) or matrices with equal number of columns (rank-k update). Notice that the latter case is done as a sequence of rank-1 updates; thus, for k large enough, it will be both faster and more accurate to recompute the factorization from scratch. </p> <p>The QR factorization supplied may be either full (Q is square) or economized (R is square). </p> <p><strong>See also:</strong> <a href="#XREFqr">qr</a>, <a href="#XREFqrinsert">qrinsert</a>, <a href="#XREFqrdelete">qrdelete</a>, <a href="#XREFqrshift">qrshift</a>. </p>
</dd>
</dl> <dl id="XREFqrinsert"> <dt id="index-qrinsert">[Q1, R1] = qrinsert (Q, R, j, x, orient)</dt> <dd>
<p>Update a QR factorization given a row or column to insert in the original factored matrix. </p> <p>Given a QR factorization of a real or complex matrix <var>A</var> = <var>Q</var>*<var>R</var>, <var>Q</var> unitary and <var>R</var> upper trapezoidal, return the QR factorization of <span class="nolinebreak">[A(:,1:j-1)</span> x A(:,j:n)], where <var>u</var> is a column vector to be inserted into <var>A</var> (if <var>orient</var> is <code>"col"</code>), or the QR factorization of <span class="nolinebreak">[A(1:j-1,:);x;A(:,j:n)]</span>, where <var>x</var> is a row vector to be inserted into <var>A</var> (if <var>orient</var> is <code>"row"</code>). </p> <p>The default value of <var>orient</var> is <code>"col"</code>. If <var>orient</var> is <code>"col"</code>, <var>u</var> may be a matrix and <var>j</var> an index vector resulting in the QR factorization of a matrix <var>B</var> such that B(:,<var>j</var>) gives <var>u</var> and B(:,<var>j</var>) = [] gives <var>A</var>. Notice that the latter case is done as a sequence of k insertions; thus, for k large enough, it will be both faster and more accurate to recompute the factorization from scratch. </p> <p>If <var>orient</var> is <code>"col"</code>, the QR factorization supplied may be either full (Q is square) or economized (R is square). </p> <p>If <var>orient</var> is <code>"row"</code>, full factorization is needed. </p> <p><strong>See also:</strong> <a href="#XREFqr">qr</a>, <a href="#XREFqrupdate">qrupdate</a>, <a href="#XREFqrdelete">qrdelete</a>, <a href="#XREFqrshift">qrshift</a>. </p>
</dd>
</dl> <dl id="XREFqrdelete"> <dt id="index-qrdelete">[Q1, R1] = qrdelete (Q, R, j, orient)</dt> <dd>
<p>Update a QR factorization given a row or column to delete from the original factored matrix. </p> <p>Given a QR factorization of a real or complex matrix <var>A</var> = <var>Q</var>*<var>R</var>, <var>Q</var> unitary and <var>R</var> upper trapezoidal, return the QR factorization of <span class="nolinebreak">[A(:,1:j-1),</span> U, A(:,j:n)], where <var>u</var> is a column vector to be inserted into <var>A</var> (if <var>orient</var> is <code>"col"</code>), or the QR factorization of <span class="nolinebreak">[A(1:j-1,:);X;A(:,j:n)]</span>, where <var>x</var> is a row <var>orient</var> is <code>"row"</code>). The default value of <var>orient</var> is <code>"col"</code>. </p> <p>If <var>orient</var> is <code>"col"</code>, <var>j</var> may be an index vector resulting in the QR factorization of a matrix <var>B</var> such that A(:,<var>j</var>) = [] gives <var>B</var>. Notice that the latter case is done as a sequence of k deletions; thus, for k large enough, it will be both faster and more accurate to recompute the factorization from scratch. </p> <p>If <var>orient</var> is <code>"col"</code>, the QR factorization supplied may be either full (Q is square) or economized (R is square). </p> <p>If <var>orient</var> is <code>"row"</code>, full factorization is needed. </p> <p><strong>See also:</strong> <a href="#XREFqr">qr</a>, <a href="#XREFqrupdate">qrupdate</a>, <a href="#XREFqrinsert">qrinsert</a>, <a href="#XREFqrshift">qrshift</a>. </p>
</dd>
</dl> <dl id="XREFqrshift"> <dt id="index-qrshift">[Q1, R1] = qrshift (Q, R, i, j)</dt> <dd>
<p>Update a QR factorization given a range of columns to shift in the original factored matrix. </p> <p>Given a QR factorization of a real or complex matrix <var>A</var> = <var>Q</var>*<var>R</var>, <var>Q</var> unitary and <var>R</var> upper trapezoidal, return the QR factorization of <var>A</var>(:,p), where p is the permutation <br> <code>p = [1:i-1, shift(i:j, 1), j+1:n]</code> if <var>i</var> &lt; <var>j</var> <br> or <br> <code>p = [1:j-1, shift(j:i,-1), i+1:n]</code> if <var>j</var> &lt; <var>i</var>. <br> </p> <p><strong>See also:</strong> <a href="#XREFqr">qr</a>, <a href="#XREFqrupdate">qrupdate</a>, <a href="#XREFqrinsert">qrinsert</a>, <a href="#XREFqrdelete">qrdelete</a>. </p>
</dd>
</dl> <dl id="XREFqz"> <dt id="index-qz">lambda = qz (A, B)</dt> <dt id="index-qz-1">[AA, BB, Q, Z, V, W, lambda] = qz (A, B)</dt> <dt id="index-qz-2">[AA, BB, Z] = qz (A, B, opt)</dt> <dt id="index-qz-3">[AA, BB, Z, lambda] = qz (A, B, opt)</dt> <dd>
<p>Compute the QZ decomposition of a generalized eigenvalue problem. </p> <p>The generalized eigenvalue problem is defined as </p> <p><em>A x = <var>lambda</var> B x</em> </p> <p>There are three calling forms of the function: </p> <ol> <li> <code><var>lambda</var> = qz (<var>A</var>, <var>B</var>)</code> <p>Compute the generalized eigenvalues <var>lambda</var>. </p> </li>
<li> <code>[<var>AA</var>, <var>BB</var>, <var>Q</var>, <var>Z</var>, <var>V</var>, <var>W</var>, <var>lambda</var>] = qz (<var>A</var>, <var>B</var>)</code> <p>Compute QZ decomposition, generalized eigenvectors, and generalized eigenvalues. </p> <pre class="example" data-language="matlab">A * V = B * V * diag (lambda)
W' * A = diag (lambda) * W' * B
AA = Q * A * Z, BB = Q * B * Z</pre> <p>with <var>Q</var> and <var>Z</var> orthogonal (unitary for complex case). </p> </li>
<li> <code>[<var>AA</var>, <var>BB</var>, <var>Z</var> {, <var>lambda</var>}] = qz (<var>A</var>, <var>B</var>, <var>opt</var>)</code> <p>As in form 2 above, but allows ordering of generalized eigenpairs for, e.g., solution of discrete time algebraic Riccati equations. Form 3 is not available for complex matrices, and does not compute the generalized eigenvectors <var>V</var>, <var>W</var>, nor the orthogonal matrix <var>Q</var>. </p> <dl compact> <dt><var>opt</var></dt> <dd>
<p>for ordering eigenvalues of the GEP pencil. The leading block of the revised pencil contains all eigenvalues that satisfy: </p> <dl compact> <dt><code>"N"</code></dt> <dd>
<p>unordered (default) </p> </dd> <dt><code>"S"</code></dt> <dd>
<p>small: leading block has all |<var>lambda</var>| &lt; 1 </p> </dd> <dt><code>"B"</code></dt> <dd>
<p>big: leading block has all |<var>lambda</var>| ≥ 1 </p> </dd> <dt><code>"-"</code></dt> <dd>
<p>negative real part: leading block has all eigenvalues in the open left half-plane </p> </dd> <dt><code>"+"</code></dt> <dd><p>non-negative real part: leading block has all eigenvalues in the closed right half-plane </p></dd> </dl> </dd> </dl> </li>
</ol> <p>Note: <code>qz</code> performs permutation balancing, but not scaling (see <a href="basic-matrix-functions#XREFbalance">balance</a>), which may be lead to less accurate results than <code>eig</code>. The order of output arguments was selected for compatibility with <small>MATLAB</small>. </p> <p><strong>See also:</strong> <a href="basic-matrix-functions#XREFeig">eig</a>, <a href="#XREFordeig">ordeig</a>, <a href="basic-matrix-functions#XREFbalance">balance</a>, <a href="#XREFlu">lu</a>, <a href="#XREFchol">chol</a>, <a href="#XREFhess">hess</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqzhess">qzhess</a>, <a href="#XREFschur">schur</a>, <a href="#XREFsvd">svd</a>. </p>
</dd>
</dl> <dl id="XREFqzhess"> <dt id="index-qzhess">[aa, bb, q, z] = qzhess (A, B)</dt> <dd>
<p>Compute the Hessenberg-triangular decomposition of the matrix pencil <code>(<var>A</var>, <var>B</var>)</code>, returning <code><var>aa</var> = <var>q</var> * <var>A</var> * <var>z</var></code>, <code><var>bb</var> = <var>q</var> * <var>B</var> * <var>z</var></code>, with <var>q</var> and <var>z</var> orthogonal. </p> <p>For example: </p> <pre class="example" data-language="matlab">[aa, bb, q, z] = qzhess ([1, 2; 3, 4], [5, 6; 7, 8])
  ⇒ aa =
      -3.02244  -4.41741
       0.92998   0.69749
  ⇒ bb =
      -8.60233  -9.99730
       0.00000  -0.23250
  ⇒ q =
      -0.58124  -0.81373
      -0.81373   0.58124
  ⇒ z =
     Diagonal Matrix
       1   0
       0   1</pre> <p>The Hessenberg-triangular decomposition is the first step in Moler and Stewart’s QZ decomposition algorithm. </p> <p>Algorithm taken from Golub and Van Loan, <cite>Matrix Computations, 2nd edition</cite>. </p> <p><strong>See also:</strong> <a href="#XREFlu">lu</a>, <a href="#XREFchol">chol</a>, <a href="#XREFhess">hess</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqz">qz</a>, <a href="#XREFschur">schur</a>, <a href="#XREFsvd">svd</a>. </p>
</dd>
</dl> <dl id="XREFschur"> <dt id="index-schur">S = schur (A)</dt> <dt id="index-schur-1">S = schur (A, "real")</dt> <dt id="index-schur-2">S = schur (A, "complex")</dt> <dt id="index-schur-3">S = schur (A, opt)</dt> <dt id="index-schur-4">[U, S] = schur (…)</dt> <dd>
 <p>Compute the Schur decomposition of <var>A</var>. </p> <p>The Schur decomposition is defined as </p> <pre class="example" data-language="matlab">S = U' * A * U</pre> <p>where <var>U</var> is a unitary matrix (<code><var>U</var>'* <var>U</var></code> is identity) and <var>S</var> is upper triangular. The eigenvalues of <var>A</var> (and <var>S</var>) are the diagonal elements of <var>S</var>. If the matrix <var>A</var> is real, then the real Schur decomposition is computed, in which the matrix <var>U</var> is orthogonal and <var>S</var> is block upper triangular with blocks of size at most <code>2 x 2</code> along the diagonal. The diagonal elements of <var>S</var> (or the eigenvalues of the <code>2 x 2</code> blocks, when appropriate) are the eigenvalues of <var>A</var> and <var>S</var>. </p> <p>The default for real matrices is a real Schur decomposition. A complex decomposition may be forced by passing the flag <code>"complex"</code>. </p> <p>The eigenvalues are optionally ordered along the diagonal according to the value of <var>opt</var>. <code><var>opt</var> = "a"</code> indicates that all eigenvalues with negative real parts should be moved to the leading block of <var>S</var> (used in <code>are</code>), <code><var>opt</var> = "d"</code> indicates that all eigenvalues with magnitude less than one should be moved to the leading block of <var>S</var> (used in <code>dare</code>), and <code><var>opt</var> = "u"</code>, the default, indicates that no ordering of eigenvalues should occur. The leading <var>k</var> columns of <var>U</var> always span the <var>A</var>-invariant subspace corresponding to the <var>k</var> leading eigenvalues of <var>S</var>. </p> <p>The Schur decomposition is used to compute eigenvalues of a square matrix, and has applications in the solution of algebraic Riccati equations in control (see <code>are</code> and <code>dare</code>). </p> <p><strong>See also:</strong> <a href="#XREFrsf2csf">rsf2csf</a>, <a href="#XREFordschur">ordschur</a>, <a href="#XREFordeig">ordeig</a>, <a href="#XREFlu">lu</a>, <a href="#XREFchol">chol</a>, <a href="#XREFhess">hess</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqz">qz</a>, <a href="#XREFsvd">svd</a>. </p>
</dd>
</dl> <dl id="XREFrsf2csf"> <dt id="index-rsf2csf">[U, T] = rsf2csf (UR, TR)</dt> <dd>
<p>Convert a real, upper quasi-triangular Schur form <var>TR</var> to a complex, upper triangular Schur form <var>T</var>. </p> <p>Note that the following relations hold: </p> <p><code><var>UR</var> * <var>TR</var> * <var>UR</var>' = <var>U</var> * <var>T</var> * <var>U</var>'</code> and <code><var>U</var>' * <var>U</var></code> is the identity matrix I. </p> <p>Note also that <var>U</var> and <var>T</var> are not unique. </p> <p><strong>See also:</strong> <a href="#XREFschur">schur</a>. </p>
</dd>
</dl> <dl id="XREFordschur"> <dt id="index-ordschur">[UR, SR] = ordschur (U, S, select)</dt> <dd>
<p>Reorders the real Schur factorization (<var>U</var>,<var>S</var>) obtained with the <code>schur</code> function, so that selected eigenvalues appear in the upper left diagonal blocks of the quasi triangular Schur matrix. </p> <p>The logical vector <var>select</var> specifies the selected eigenvalues as they appear along <var>S</var>’s diagonal. </p> <p>For example, given the matrix <code><var>A</var> = [1, 2; 3, 4]</code>, and its Schur decomposition </p> <pre class="example" data-language="matlab">[U, S] = schur (A)</pre> <p>which returns </p> <pre class="example" data-language="matlab">U =

  -0.82456  -0.56577
   0.56577  -0.82456

S =

  -0.37228  -1.00000
   0.00000   5.37228</pre> <p>It is possible to reorder the decomposition so that the positive eigenvalue is in the upper left corner, by doing: </p> <pre class="example" data-language="matlab">[U, S] = ordschur (U, S, [0,1])</pre> <p><strong>See also:</strong> <a href="#XREFschur">schur</a>, <a href="#XREFordeig">ordeig</a>. </p>
</dd>
</dl> <dl id="XREFordeig"> <dt id="index-ordeig">lambda = ordeig (A)</dt> <dt id="index-ordeig-1">lambda = ordeig (A, B)</dt> <dd>
<p>Return the eigenvalues of quasi-triangular matrices in their order of appearance in the matrix <var>A</var>. </p> <p>The quasi-triangular matrix <var>A</var> is usually the result of a Schur factorization. If called with a second input <var>B</var> then the generalized eigenvalues of the pair <var>A</var>, <var>B</var> are returned in the order of appearance of the matrix <code><var>A</var>-<var>lambda</var>*<var>B</var></code>. The pair <var>A</var>, <var>B</var> is usually the result of a QZ decomposition. </p> <p><strong>See also:</strong> <a href="#XREFordschur">ordschur</a>, <a href="basic-matrix-functions#XREFeig">eig</a>, <a href="#XREFschur">schur</a>, <a href="#XREFqz">qz</a>. </p>
</dd>
</dl> <dl id="XREFsubspace"> <dt id="index-subspace">angle = subspace (A, B)</dt> <dd><p>Determine the largest principal angle between two subspaces spanned by the columns of matrices <var>A</var> and <var>B</var>. </p></dd>
</dl> <dl id="XREFsvd"> <dt id="index-svd">s = svd (A)</dt> <dt id="index-svd-1">[U, S, V] = svd (A)</dt> <dt id="index-svd-2">[U, S, V] = svd (A, "econ")</dt> <dt id="index-svd-3">[U, S, V] = svd (A, 0)</dt> <dd>
 <p>Compute the singular value decomposition of <var>A</var>. </p> <p>The singular value decomposition is defined by the relation </p> <pre class="example" data-language="matlab">A = U*S*V'</pre> <p>The function <code>svd</code> normally returns only the vector of singular values. When called with three return values, it computes <var>U</var>, <var>S</var>, and <var>V</var>. For example, </p> <pre class="example" data-language="matlab">svd (hilb (3))</pre> <p>returns </p> <pre class="example" data-language="matlab">ans =

  1.4083189
  0.1223271
  0.0026873</pre> <p>and </p> <pre class="example" data-language="matlab">[u, s, v] = svd (hilb (3))</pre> <p>returns </p> <pre class="example" data-language="matlab">u =

  -0.82704   0.54745   0.12766
  -0.45986  -0.52829  -0.71375
  -0.32330  -0.64901   0.68867

s =

  1.40832  0.00000  0.00000
  0.00000  0.12233  0.00000
  0.00000  0.00000  0.00269

v =

  -0.82704   0.54745   0.12766
  -0.45986  -0.52829  -0.71375
  -0.32330  -0.64901   0.68867</pre> <p>When given a second argument that is not 0, <code>svd</code> returns an economy-sized decomposition, eliminating the unnecessary rows or columns of <var>U</var> or <var>V</var>. </p> <p>If the second argument is exactly 0, then the choice of decomposition is based on the matrix <var>A</var>. If <var>A</var> has more rows than columns then an economy-sized decomposition is returned, otherwise a regular decomposition is calculated. </p> <p>Algorithm Notes: When calculating the full decomposition (left and right singular matrices in addition to singular values) there is a choice of two routines in <small>LAPACK</small>. The default routine used by Octave is <code>gesvd</code>. The alternative is <code>gesdd</code> which is 5X faster, but may use more memory and may be inaccurate for some input matrices. See the documentation for <code>svd_driver</code> for more information on choosing a driver. </p> <p><strong>See also:</strong> <a href="#XREFsvd_005fdriver">svd_driver</a>, <a href="sparse-linear-algebra#XREFsvds">svds</a>, <a href="basic-matrix-functions#XREFeig">eig</a>, <a href="#XREFlu">lu</a>, <a href="#XREFchol">chol</a>, <a href="#XREFhess">hess</a>, <a href="#XREFqr">qr</a>, <a href="#XREFqz">qz</a>. </p>
</dd>
</dl> <dl id="XREFsvd_005fdriver"> <dt id="index-svd_005fdriver">val = svd_driver ()</dt> <dt id="index-svd_005fdriver-1">old_val = svd_driver (new_val)</dt> <dt id="index-svd_005fdriver-2">svd_driver (new_val, "local")</dt> <dd>
<p>Query or set the underlying <small>LAPACK</small> driver used by <code>svd</code>. </p> <p>Currently recognized values are <code>"gesdd"</code> and <code>"gesvd"</code>. The default is <code>"gesvd"</code>. </p> <p>When called from inside a function with the <code>"local"</code> option, the variable is changed locally for the function and any subroutines it calls. The original variable value is restored when exiting the function. </p> <p>Algorithm Notes: The <small>LAPACK</small> library provides two routines for calculating the full singular value decomposition (left and right singular matrices as well as singular values). When calculating just the singular values the following discussion is not relevant. </p> <p>The newer <code>gesdd</code> routine is based on a Divide-and-Conquer algorithm that is 5X faster than the alternative <code>gesvd</code>, which is based on QR factorization. However, the new algorithm can use significantly more memory. For an MxN input matrix the memory usage is of order O(min(M,N) ^ 2), whereas the alternative is of order O(max(M,N)). </p> <p>Beyond speed and memory issues, there have been instances where some input matrices were not accurately decomposed by <code>gesdd</code>. See currently active bug <a href="https://savannah.gnu.org/bugs/?55564">https://savannah.gnu.org/bugs/?55564</a>. Until these accuracy issues are resolved in a new version of the <small>LAPACK</small> library, the default driver in Octave has been set to <code>"gesvd"</code>. </p> <p><strong>See also:</strong> <a href="#XREFsvd">svd</a>. </p>
</dd>
</dl> <dl id="XREFhoush"> <dt id="index-housh">[housv, beta, zer] = housh (x, j, z)</dt> <dd>
<p>Compute Householder reflection vector <var>housv</var> to reflect <var>x</var> to be the j-th column of identity, i.e., </p> <pre class="example" data-language="matlab">(I - beta*housv*housv')x =  norm (x)*e(j) if x(j) &lt; 0,
(I - beta*housv*housv')x = -norm (x)*e(j) if x(j) &gt;= 0</pre> <p>Inputs </p> <dl compact> <dt><var>x</var></dt> <dd>
<p>vector </p> </dd> <dt><var>j</var></dt> <dd>
<p>index into vector </p> </dd> <dt><var>z</var></dt> <dd><p>threshold for zero (usually should be the number 0) </p></dd> </dl> <p>Outputs (see Golub and Van Loan): </p> <dl compact> <dt><var>beta</var></dt> <dd>
<p>If beta = 0, then no reflection need be applied (zer set to 0) </p> </dd> <dt><var>housv</var></dt> <dd><p>householder vector </p></dd> </dl> </dd>
</dl> <dl id="XREFkrylov"> <dt id="index-krylov">[u, h, nu] = krylov (A, V, k, eps1, pflg)</dt> <dd>
<p>Construct an orthogonal basis <var>u</var> of a block Krylov subspace. </p> <p>The block Krylov subspace has the following form: </p> <pre class="example" data-language="matlab">[v a*v a^2*v … a^(k+1)*v]</pre> <p>The construction is made with Householder reflections to guard against loss of orthogonality. </p> <p>If <var>V</var> is a vector, then <var>h</var> contains the Hessenberg matrix such that <code>a*u == u*h+rk*ek'</code>, in which <code>rk = a*u(:,k)-u*h(:,k)</code>, and <code>ek'</code> is the vector <code>[0, 0, …, 1]</code> of length <var>k</var>. Otherwise, <var>h</var> is meaningless. </p> <p>If <var>V</var> is a vector and <var>k</var> is greater than <code>length (A) - 1</code>, then <var>h</var> contains the Hessenberg matrix such that <code>a*u == u*h</code>. </p> <p>The value of <var>nu</var> is the dimension of the span of the Krylov subspace (based on <var>eps1</var>). </p> <p>If <var>b</var> is a vector and <var>k</var> is greater than <var>m-1</var>, then <var>h</var> contains the Hessenberg decomposition of <var>A</var>. </p> <p>The optional parameter <var>eps1</var> is the threshold for zero. The default value is 1e-12. </p> <p>If the optional parameter <var>pflg</var> is nonzero, row pivoting is used to improve numerical behavior. The default value is 0. </p> <p>Reference: A. Hodel, P. Misra, <cite>Partial Pivoting in the Computation of Krylov Subspaces of Large Sparse Systems</cite>, Proceedings of the 42nd IEEE Conference on Decision and Control, December 2003. </p>
</dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
          © 1996–2018 John W. Eaton<br>      Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://octave.org/doc/interpreter/Matrix-Factorizations.html" class="_attribution-link">https://octave.org/doc/interpreter/Matrix-Factorizations.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
