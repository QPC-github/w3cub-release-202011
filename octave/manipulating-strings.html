
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Manipulating Strings - Octave - W3cubDocs</title>
  
  <meta name="description" content="Octave supports a wide range of functions for manipulating strings. Since a string is just a matrix, simple manipulations can be accomplished using &hellip;">
  <meta name="keywords" content="manipulating, strings, octave">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/octave/manipulating-strings.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/octave.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/octave/" class="_nav-link" title="" style="margin-left:0;">Octave</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _octave">
				
				
<h1 class="section">5.5 Manipulating Strings</h1> <p>Octave supports a wide range of functions for manipulating strings. Since a string is just a matrix, simple manipulations can be accomplished using standard operators. The following example shows how to replace all blank characters with underscores. </p> <pre class="example" data-language="matlab">quote = ...
  "First things first, but not necessarily in that order";
quote( quote == " " ) = "_"
⇒ quote =
    First_things_first,_but_not_necessarily_in_that_order</pre> <p>For more complex manipulations, such as searching, replacing, and general regular expressions, the following functions come with Octave. </p> <dl id="XREFdeblank"> <dt id="index-deblank">deblank (s)</dt> <dd>
<p>Remove trailing whitespace and nulls from <var>s</var>. </p> <p>If <var>s</var> is a matrix, <var>deblank</var> trims each row to the length of longest string. If <var>s</var> is a cell array of strings, operate recursively on each string element. </p> <p>Examples: </p> <pre class="example" data-language="matlab">deblank ("    abc  ")
     ⇒  "    abc"

deblank ([" abc   "; "   def   "])
     ⇒  [" abc  " ; "   def"]</pre> <p><strong>See also:</strong> <a href="#XREFstrtrim">strtrim</a>. </p>
</dd>
</dl> <dl id="XREFstrtrim"> <dt id="index-strtrim">strtrim (s)</dt> <dd>
<p>Remove leading and trailing whitespace from <var>s</var>. </p> <p>If <var>s</var> is a matrix, <var>strtrim</var> trims each row to the length of longest string. If <var>s</var> is a cell array of strings, operate recursively on each string element. </p> <p>For example: </p> <pre class="example" data-language="matlab">strtrim ("    abc  ")
     ⇒  "abc"

strtrim ([" abc   "; "   def   "])
     ⇒  ["abc  "  ; "  def"]</pre> <p><strong>See also:</strong> <a href="#XREFdeblank">deblank</a>. </p>
</dd>
</dl> <dl id="XREFstrtrunc"> <dt id="index-strtrunc">strtrunc (s, n)</dt> <dd>
<p>Truncate the character string <var>s</var> to length <var>n</var>. </p> <p>If <var>s</var> is a character matrix, then the number of columns is adjusted. </p> <p>If <var>s</var> is a cell array of strings, then the operation is performed on each cell element and the new cell array is returned. </p>
</dd>
</dl> <dl id="XREFfindstr"> <dt id="index-findstr">findstr (s, t)</dt> <dt id="index-findstr-1">findstr (s, t, overlap)</dt> <dd> <p>This function is obsolete. Use <code>strfind</code> instead. </p> <p>Return the vector of all positions in the longer of the two strings <var>s</var> and <var>t</var> where an occurrence of the shorter of the two starts. </p> <p>If the optional argument <var>overlap</var> is true (default), the returned vector can include overlapping positions. For example: </p> <pre class="example" data-language="matlab">findstr ("ababab", "a")
     ⇒ [1, 3, 5];
findstr ("abababa", "aba", 0)
     ⇒ [1, 5]</pre> <p><strong>Caution:</strong> <code>findstr</code> is obsolete. Use <code>strfind</code> in all new code. </p> <p><strong>See also:</strong> <a href="#XREFstrfind">strfind</a>, <a href="#XREFstrmatch">strmatch</a>, <a href="comparing-strings#XREFstrcmp">strcmp</a>, <a href="comparing-strings#XREFstrncmp">strncmp</a>, <a href="comparing-strings#XREFstrcmpi">strcmpi</a>, <a href="comparing-strings#XREFstrncmpi">strncmpi</a>, <a href="finding-elements-and-checking-conditions#XREFfind">find</a>. </p>
</dd>
</dl> <dl id="XREFstrchr"> <dt id="index-strchr">idx = strchr (str, chars)</dt> <dt id="index-strchr-1">idx = strchr (str, chars, n)</dt> <dt id="index-strchr-2">idx = strchr (str, chars, n, direction)</dt> <dt id="index-strchr-3">[i, j] = strchr (…)</dt> <dd>
<p>Search for the string <var>str</var> for occurrences of characters from the set <var>chars</var>. </p> <p>The return value(s), as well as the <var>n</var> and <var>direction</var> arguments behave identically as in <code>find</code>. </p> <p>This will be faster than using regexp in most cases. </p> <p><strong>See also:</strong> <a href="finding-elements-and-checking-conditions#XREFfind">find</a>. </p>
</dd>
</dl> <dl id="XREFindex"> <dt id="index-index">index (s, t)</dt> <dt id="index-index-1">index (s, t, direction)</dt> <dd>
<p>Return the position of the first occurrence of the string <var>t</var> in the string <var>s</var>, or 0 if no occurrence is found. </p> <p><var>s</var> may also be a string array or cell array of strings. </p> <p>For example: </p> <pre class="example" data-language="matlab">index ("Teststring", "t")
    ⇒ 4</pre> <p>If <var>direction</var> is <code>"first"</code>, return the first element found. If <var>direction</var> is <code>"last"</code>, return the last element found. </p> <p><strong>See also:</strong> <a href="finding-elements-and-checking-conditions#XREFfind">find</a>, <a href="#XREFrindex">rindex</a>. </p>
</dd>
</dl> <dl id="XREFrindex"> <dt id="index-rindex">rindex (s, t)</dt> <dd>
<p>Return the position of the last occurrence of the character string <var>t</var> in the character string <var>s</var>, or 0 if no occurrence is found. </p> <p><var>s</var> may also be a string array or cell array of strings. </p> <p>For example: </p> <pre class="example" data-language="matlab">rindex ("Teststring", "t")
     ⇒ 6</pre> <p>The <code>rindex</code> function is equivalent to <code>index</code> with <var>direction</var> set to <code>"last"</code>. </p> <p><strong>See also:</strong> <a href="finding-elements-and-checking-conditions#XREFfind">find</a>, <a href="#XREFindex">index</a>. </p>
</dd>
</dl> <dl id="XREFstrfind"> <dt id="index-strfind">idx = strfind (str, pattern)</dt> <dt id="index-strfind-1">idx = strfind (cellstr, pattern)</dt> <dt id="index-strfind-2">idx = strfind (…, "overlaps", val)</dt> <dd>
<p>Search for <var>pattern</var> in the string <var>str</var> and return the starting index of every such occurrence in the vector <var>idx</var>. </p> <p>If there is no such occurrence, or if <var>pattern</var> is longer than <var>str</var>, or if <var>pattern</var> itself is empty, then <var>idx</var> is the empty array <code>[]</code>. </p> <p>The optional argument <code>"overlaps"</code> determines whether the pattern can match at every position in <var>str</var> (true), or only for unique occurrences of the complete pattern (false). The default is true. </p> <p>If a cell array of strings <var>cellstr</var> is specified then <var>idx</var> is a cell array of vectors, as specified above. </p> <p>Examples: </p> <pre class="example" data-language="matlab">strfind ("abababa", "aba")
     ⇒ [1, 3, 5]

strfind ("abababa", "aba", "overlaps", false)
     ⇒ [1, 5]

strfind ({"abababa", "bebebe", "ab"}, "aba")
     ⇒
        {
          [1,1] =

             1   3   5

          [1,2] = [](1x0)
          [1,3] = [](1x0)
        }</pre> <p><strong>See also:</strong> <a href="#XREFregexp">regexp</a>, <a href="#XREFregexpi">regexpi</a>, <a href="finding-elements-and-checking-conditions#XREFfind">find</a>. </p>
</dd>
</dl> <dl id="XREFstrjoin"> <dt id="index-strjoin">str = strjoin (cstr)</dt> <dt id="index-strjoin-1">str = strjoin (cstr, delimiter)</dt> <dd>
<p>Join the elements of the cell string array, <var>cstr</var>, into a single string. </p> <p>If no <var>delimiter</var> is specified, the elements of <var>cstr</var> are separated by a space. </p> <p>If <var>delimiter</var> is specified as a string, the cell string array is joined using the string. Escape sequences are supported. </p> <p>If <var>delimiter</var> is a cell string array whose length is one less than <var>cstr</var>, then the elements of <var>cstr</var> are joined by interleaving the cell string elements of <var>delimiter</var>. Escape sequences are not supported. </p> <pre class="example" data-language="matlab">strjoin ({'Octave','Scilab','Lush','Yorick'}, '*')
      ⇒ 'Octave*Scilab*Lush*Yorick'</pre> <p><strong>See also:</strong> <a href="#XREFstrsplit">strsplit</a>. </p>
</dd>
</dl> <dl id="XREFstrmatch"> <dt id="index-strmatch">strmatch (s, A)</dt> <dt id="index-strmatch-1">strmatch (s, A, "exact")</dt> <dd> <p>This function is obsolete. Use an alternative such as <code>strncmp</code> or <code>strcmp</code> instead. </p> <p>Return indices of entries of <var>A</var> which begin with the string <var>s</var>. </p> <p>The second argument <var>A</var> must be a string, character matrix, or a cell array of strings. </p> <p>If the third argument <code>"exact"</code> is not given, then <var>s</var> only needs to match <var>A</var> up to the length of <var>s</var>. Trailing spaces and nulls in <var>s</var> and <var>A</var> are ignored when matching. </p> <p>For example: </p> <pre class="example" data-language="matlab">strmatch ("apple", "apple juice")
     ⇒ 1

strmatch ("apple", ["apple  "; "apple juice"; "an apple"])
     ⇒ [1; 2]

strmatch ("apple", ["apple  "; "apple juice"; "an apple"], "exact")
     ⇒ [1]</pre> <p><strong>Caution:</strong> <code>strmatch</code> is obsolete. Use <code>strncmp</code> (normal case) or <code>strcmp</code> (<code>"exact"</code> case) in all new code. Other replacement possibilities, depending on application, include <code>regexp</code> or <code>validatestring</code>. </p> <p><strong>See also:</strong> <a href="comparing-strings#XREFstrncmp">strncmp</a>, <a href="comparing-strings#XREFstrcmp">strcmp</a>, <a href="#XREFregexp">regexp</a>, <a href="#XREFstrfind">strfind</a>, <a href="multiple-return-values#XREFvalidatestring">validatestring</a>. </p>
</dd>
</dl> <dl id="XREFstrtok"> <dt id="index-strtok">[tok, rem] = strtok (str)</dt> <dt id="index-strtok-1">[tok, rem] = strtok (str, delim)</dt> <dd> <p>Find all characters in the string <var>str</var> up to, but not including, the first character which is in the string <var>delim</var>. </p> <p><var>str</var> may also be a cell array of strings in which case the function executes on every individual string and returns a cell array of tokens and remainders. </p> <p>Leading delimiters are ignored. If <var>delim</var> is not specified, whitespace is assumed. </p> <p>If <var>rem</var> is requested, it contains the remainder of the string, starting at the first delimiter. </p> <p>Examples: </p> <pre class="example" data-language="matlab">strtok ("this is the life")
     ⇒ "this"

[tok, rem] = strtok ("14*27+31", "+-*/")
     ⇒
        tok = 14
        rem = *27+31</pre> <p><strong>See also:</strong> <a href="#XREFindex">index</a>, <a href="#XREFstrsplit">strsplit</a>, <a href="#XREFstrchr">strchr</a>, <a href="character-class-functions#XREFisspace">isspace</a>. </p>
</dd>
</dl> <dl id="XREFstrsplit"> <dt id="index-strsplit">[cstr] = strsplit (str)</dt> <dt id="index-strsplit-1">[cstr] = strsplit (str, del)</dt> <dt id="index-strsplit-2">[cstr] = strsplit (…, name, value)</dt> <dt id="index-strsplit-3">[cstr, matches] = strsplit (…)</dt> <dd>
<p>Split the string <var>str</var> using the delimiters specified by <var>del</var> and return a cell string array of substrings. </p> <p>If a delimiter is not specified the string is split at whitespace <code>{" ", "\f", "\n", "\r", "\t", "\v"}</code>. Otherwise, the delimiter, <var>del</var> must be a string or cell array of strings. By default, consecutive delimiters in the input string <var>s</var> are collapsed into one resulting in a single split. </p> <p>Supported <var>name</var>/<var>value</var> pair arguments are: </p> <ul> <li> <var>collapsedelimiters</var> which may take the value of <code>true</code> (default) or <code>false</code>. </li>
<li> <var>delimitertype</var> which may take the value of <code>"simple"</code> (default) or <code>"regularexpression"</code>. A simple delimiter matches the text exactly as written. Otherwise, the syntax for regular expressions outlined in <code>regexp</code> is used. </li>
</ul> <p>The optional second output, <var>matches</var>, returns the delimiters which were matched in the original string. </p> <p>Examples with simple delimiters: </p> <pre class="example" data-language="matlab">strsplit ("a b c")
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = c
          }

strsplit ("a,b,c", ",")
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = c
          }

strsplit ("a foo b,bar c", {" ", ",", "foo", "bar"})
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = c
          }

strsplit ("a,,b, c", {",", " "}, "collapsedelimiters", false)
      ⇒
          {
            [1,1] = a
            [1,2] =
            [1,3] = b
            [1,4] =
            [1,5] = c
          }</pre> <p>Examples with regularexpression delimiters: </p> <div class="smallexample"> <pre class="smallexample">strsplit ("a foo b,bar c", ',|\s|foo|bar', ...
          "delimitertype", "regularexpression")
⇒
{
            [1,1] = a
            [1,2] = b
            [1,3] = c
}

strsplit ("a,,b, c", '[, ]', "collapsedelimiters", false, ...
          "delimitertype", "regularexpression")
⇒
{
            [1,1] = a
            [1,2] =
            [1,3] = b
            [1,4] =
            [1,5] = c
}

strsplit ("a,\t,b, c", {',', '\s'}, "delimitertype", "regularexpression")
⇒
{
            [1,1] = a
            [1,2] = b
            [1,3] = c
}

strsplit ("a,\t,b, c", {',', ' ', '\t'}, "collapsedelimiters", false)
⇒
{
            [1,1] = a
            [1,2] =
            [1,3] =
            [1,4] = b
            [1,5] =
            [1,6] = c
}
</pre>
</div> <p><strong>See also:</strong> <a href="#XREFostrsplit">ostrsplit</a>, <a href="#XREFstrjoin">strjoin</a>, <a href="#XREFstrtok">strtok</a>, <a href="#XREFregexp">regexp</a>. </p>
</dd>
</dl> <dl id="XREFostrsplit"> <dt id="index-ostrsplit">[cstr] = ostrsplit (s, sep)</dt> <dt id="index-ostrsplit-1">[cstr] = ostrsplit (s, sep, strip_empty)</dt> <dd>
<p>Split the string <var>s</var> using one or more separators <var>sep</var> and return a cell array of strings. </p> <p>Consecutive separators and separators at boundaries result in empty strings, unless <var>strip_empty</var> is true. The default value of <var>strip_empty</var> is false. </p> <p>2-D character arrays are split at separators and at the original column boundaries. </p> <p>Example: </p> <pre class="example" data-language="matlab">ostrsplit ("a,b,c", ",")
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = c
          }

ostrsplit (["a,b" ; "cde"], ",")
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = cde
          }</pre> <p><strong>See also:</strong> <a href="#XREFstrsplit">strsplit</a>, <a href="#XREFstrtok">strtok</a>. </p>
</dd>
</dl> <dl id="XREFstrread"> <dt id="index-strread">[a, …] = strread (str)</dt> <dt id="index-strread-1">[a, …] = strread (str, format)</dt> <dt id="index-strread-2">[a, …] = strread (str, format, format_repeat)</dt> <dt id="index-strread-3">[a, …] = strread (str, format, prop1, value1, …)</dt> <dt id="index-strread-4">[a, …] = strread (str, format, format_repeat, prop1, value1, …)</dt> <dd> <p>This function is obsolete. Use <code>textscan</code> instead. </p> <p>Read data from a string. </p> <p>The string <var>str</var> is split into words that are repeatedly matched to the specifiers in <var>format</var>. The first word is matched to the first specifier, the second to the second specifier and so forth. If there are more words than specifiers, the process is repeated until all words have been processed. </p> <p>The string <var>format</var> describes how the words in <var>str</var> should be parsed. It may contain any combination of the following specifiers: </p> <dl compact> <dt><code>%s</code></dt> <dd>
<p>The word is parsed as a string. </p> </dd> <dt><code>%f</code></dt> <dt><code>%n</code></dt> <dd>
<p>The word is parsed as a number and converted to double. </p> </dd> <dt><code>%d</code></dt> <dt><code>%u</code></dt> <dd>
<p>The word is parsed as a number and converted to int32. </p> </dd> <dt><code>%*</code></dt> <dt><code>%*f</code></dt> <dt><code>%*s</code></dt> <dd>
<p>The word is skipped. </p> <p>For %s and %d, %f, %n, %u and the associated %*s … specifiers an optional width can be specified as %Ns, etc. where N is an integer &gt; 1. For %f, format specifiers like %N.Mf are allowed. </p> </dd> <dt><code>literals</code></dt> <dd><p>In addition the format may contain literal character strings; these will be skipped during reading. </p></dd> </dl> <p>Parsed word corresponding to the first specifier are returned in the first output argument and likewise for the rest of the specifiers. </p> <p>By default, <var>format</var> is <tt>"%f"</tt>, meaning that numbers are read from <var>str</var>. This will do if <var>str</var> contains only numeric fields. </p> <p>For example, the string </p> <pre class="example" data-language="matlab">str = "\
Bunny Bugs   5.5\n\
Duck Daffy  -7.5e-5\n\
Penguin Tux   6"</pre> <p>can be read using </p> <pre class="example" data-language="matlab">[a, b, c] = strread (str, "%s %s %f");</pre> <p>Optional numeric argument <var>format_repeat</var> can be used for limiting the number of items read: </p> <dl compact> <dt>-1</dt> <dd>
<p>(default) read all of the string until the end. </p> </dd> <dt>N</dt> <dd><p>Read N times <var>nargout</var> items. 0 (zero) is an acceptable value for <var>format_repeat</var>. </p></dd> </dl> <p>The behavior of <code>strread</code> can be changed via property-value pairs. The following properties are recognized: </p> <dl compact> <dt><code>"commentstyle"</code></dt> <dd>
<p>Parts of <var>str</var> are considered comments and will be skipped. <var>value</var> is the comment style and can be any of the following. </p> <ul> <li> <code>"shell"</code> Everything from <code>#</code> characters to the nearest end-of-line is skipped. </li>
<li> <code>"c"</code> Everything between <code>/*</code> and <code>*/</code> is skipped. </li>
<li> <code>"c++"</code> Everything from <code>//</code> characters to the nearest end-of-line is skipped. </li>
<li> <code>"matlab"</code> Everything from <code>%</code> characters to the nearest end-of-line is skipped. </li>
<li> user-supplied. Two options: (1) One string, or 1x1 cell string: Skip everything to the right of it; (2) 2x1 cell string array: Everything between the left and right strings is skipped. </li>
</ul> </dd> <dt><code>"delimiter"</code></dt> <dd>
<p>Any character in <var>value</var> will be used to split <var>str</var> into words (default value = any whitespace). Note that whitespace is implicitly added to the set of delimiter characters unless a <code>"%s"</code> format conversion specifier is supplied; see <code>"whitespace"</code> parameter below. The set of delimiter characters cannot be empty; if needed Octave substitutes a space as delimiter. </p> </dd> <dt><code>"emptyvalue"</code></dt> <dd>
<p>Value to return for empty numeric values in non-whitespace delimited data. The default is NaN. When the data type does not support NaN (int32 for example), then default is zero. </p> </dd> <dt><code>"multipledelimsasone"</code></dt> <dd>
<p>Treat a series of consecutive delimiters, without whitespace in between, as a single delimiter. Consecutive delimiter series need not be vertically <code>"aligned"</code>. </p> </dd> <dt><code>"treatasempty"</code></dt> <dd>
<p>Treat single occurrences (surrounded by delimiters or whitespace) of the string(s) in <var>value</var> as missing values. </p> </dd> <dt><code>"returnonerror"</code></dt> <dd>
<p>If <var>value</var> true (1, default), ignore read errors and return normally. If false (0), return an error. </p> </dd> <dt><code>"whitespace"</code></dt> <dd>
<p>Any character in <var>value</var> will be interpreted as whitespace and trimmed; the string defining whitespace must be enclosed in double quotes for proper processing of special characters like <code>"\t"</code>. In each data field, multiple consecutive whitespace characters are collapsed into one space and leading and trailing whitespace is removed. The default value for whitespace is <code>"
\b\r\n\t"</code> (note the space). Whitespace is always added to the set of delimiter characters unless at least one <code>"%s"</code> format conversion specifier is supplied; in that case only whitespace explicitly specified in <code>"delimiter"</code> is retained as delimiter and removed from the set of whitespace characters. If whitespace characters are to be kept as-is (in e.g., strings), specify an empty value (i.e., <code>""</code>) for <code>"whitespace"</code>; obviously, whitespace cannot be a delimiter then. </p> </dd> </dl> <p>When the number of words in <var>str</var> doesn’t match an exact multiple of the number of format conversion specifiers, strread’s behavior depends on the last character of <var>str</var>: </p> <dl compact> <dt>last character = <code>"\n"</code>
</dt> <dd>
<p>Data columns are padded with empty fields or NaN so that all columns have equal length </p> </dd> <dt>last character is not <code>"\n"</code>
</dt> <dd>
<p>Data columns are not padded; strread returns columns of unequal length </p> </dd> </dl> <p><strong>See also:</strong> <a href="simple-file-i_002fo#XREFtextscan">textscan</a>, <a href="formatted-input#XREFsscanf">sscanf</a>. </p>
</dd>
</dl> <dl id="XREFstrrep"> <dt id="index-strrep">newstr = strrep (str, ptn, rep)</dt> <dt id="index-strrep-1">newstr = strrep (cellstr, ptn, rep)</dt> <dt id="index-strrep-2">newstr = strrep (…, "overlaps", val)</dt> <dd>
<p>Replace all occurrences of the pattern <var>ptn</var> in the string <var>str</var> with the string <var>rep</var> and return the result. </p> <p>The optional argument <code>"overlaps"</code> determines whether the pattern can match at every position in <var>str</var> (true), or only for unique occurrences of the complete pattern (false). The default is true. </p> <p><var>s</var> may also be a cell array of strings, in which case the replacement is done for each element and a cell array is returned. </p> <p>Example: </p> <pre class="example" data-language="matlab">strrep ("This is a test string", "is", "&amp;%$")
    ⇒  "Th&amp;%$ &amp;%$ a test string"</pre> <p><strong>See also:</strong> <a href="#XREFregexprep">regexprep</a>, <a href="#XREFstrfind">strfind</a>. </p>
</dd>
</dl> <dl id="XREFerase"> <dt id="index-erase">newstr = erase (str, ptn)</dt> <dd>
<p>Delete all occurrences of <var>ptn</var> within <var>str</var>. </p> <p><var>str</var> and <var>ptn</var> can be ordinary strings, cell array of strings, or character arrays. </p> <p>Examples </p> <pre class="example" data-language="matlab">## string, single pattern
erase ("Hello World!", " World")
    ⇒ "Hello!"

## cellstr, single pattern
erase ({"Hello", "World!"}, "World")
    ⇒ {"Hello", "!"}

## string, multiple patterns
erase ("The Octave interpreter is fabulous", ...
       {"interpreter ", "The "})
    ⇒ "Octave is fabulous"

## cellstr, multiple patterns
erase ({"The ", "Octave interpreter ", "is fabulous"}, ...
       {"interpreter ", "The "})
    ⇒ {"", "Octave ", "is fabulous"}</pre> <p>Programming Note: <code>erase</code> deletes the first instance of a pattern in a string when there are overlapping occurrences. For example: </p> <pre class="example" data-language="matlab">erase ("abababa", "aba")
    ⇒ "b"</pre> <p>See <code>strrep</code> for processing overlaps. </p> <p><strong>See also:</strong> <a href="#XREFstrrep">strrep</a>, <a href="#XREFregexprep">regexprep</a>. </p>
</dd>
</dl> <dl id="XREFsubstr"> <dt id="index-substr">substr (s, offset)</dt> <dt id="index-substr-1">substr (s, offset, len)</dt> <dd>
<p>Return the substring of <var>s</var> which starts at character number <var>offset</var> and is <var>len</var> characters long. </p> <p>Position numbering for offsets begins with 1. If <var>offset</var> is negative, extraction starts that far from the end of the string. </p> <p>If <var>len</var> is omitted, the substring extends to the end of <var>s</var>. A negative value for <var>len</var> extracts to within <var>len</var> characters of the end of the string </p> <p>Examples: </p> <pre class="example" data-language="matlab">substr ("This is a test string", 6, 9)
     ⇒ "is a test"
substr ("This is a test string", -11)
     ⇒ "test string"
substr ("This is a test string", -11, -7)
     ⇒ "test"</pre> <p>This function is patterned after the equivalent function in Perl. </p>
</dd>
</dl> <dl id="XREFregexp"> <dt id="index-regexp">[s, e, te, m, t, nm, sp] = regexp (str, pat)</dt> <dt id="index-regexp-1">[…] = regexp (str, pat, "opt1", …)</dt> <dd>
<p>Regular expression string matching. </p> <p>Search for <var>pat</var> in <var>str</var> and return the positions and substrings of any matches, or empty values if there are none. </p> <p>The matched pattern <var>pat</var> can include any of the standard regex operators, including: </p> <dl compact> <dt><code>.</code></dt> <dd>
<p>Match any character </p> </dd> <dt><code>* + ? {}</code></dt> <dd>
<p>Repetition operators, representing </p> <dl compact> <dt><code>*</code></dt> <dd>
<p>Match zero or more times </p> </dd> <dt><code>+</code></dt> <dd>
<p>Match one or more times </p> </dd> <dt><code>?</code></dt> <dd>
<p>Match zero or one times </p> </dd> <dt><code>{<var>n</var>}</code></dt> <dd>
<p>Match exactly <var>n</var> times </p> </dd> <dt><code>{<var>n</var>,}</code></dt> <dd>
<p>Match <var>n</var> or more times </p> </dd> <dt><code>{<var>m</var>,<var>n</var>}</code></dt> <dd><p>Match between <var>m</var> and <var>n</var> times </p></dd> </dl> </dd> <dt><code>[…] [^…]</code></dt> <dd> <p>List operators. The pattern will match any character listed between <code>"["</code> and <code>"]"</code>. If the first character is <code>"^"</code> then the pattern is inverted and any character except those listed between brackets will match. </p> <p>Escape sequences defined below can also be used inside list operators. For example, a template for a floating point number might be <code>[-+.\d]+</code>. </p> </dd> <dt><code>() (?:)</code></dt> <dd>
<p>Grouping operator. The first form, parentheses only, also creates a token. </p> </dd> <dt><code>|</code></dt> <dd>
<p>Alternation operator. Match one of a choice of regular expressions. The alternatives must be delimited by the grouping operator <code>()</code> above. </p> </dd> <dt><code>^ $</code></dt> <dd><p>Anchoring operators. Requires pattern to occur at the start (<code>^</code>) or end (<code>$</code>) of the string. </p></dd> </dl> <p>In addition, the following escaped characters have special meaning. </p> <dl compact> <dt><code>\d</code></dt> <dd>
<p>Match any digit </p> </dd> <dt><code>\D</code></dt> <dd>
<p>Match any non-digit </p> </dd> <dt><code>\s</code></dt> <dd>
<p>Match any whitespace character </p> </dd> <dt><code>\S</code></dt> <dd>
<p>Match any non-whitespace character </p> </dd> <dt><code>\w</code></dt> <dd>
<p>Match any word character </p> </dd> <dt><code>\W</code></dt> <dd>
<p>Match any non-word character </p> </dd> <dt><code>\&lt;</code></dt> <dd>
<p>Match the beginning of a word </p> </dd> <dt><code>\&gt;</code></dt> <dd>
<p>Match the end of a word </p> </dd> <dt><code>\B</code></dt> <dd><p>Match within a word </p></dd> </dl> <p>Implementation Note: For compatibility with <small>MATLAB</small>, escape sequences in <var>pat</var> (e.g., <code>"\n"</code> =&gt; newline) are expanded even when <var>pat</var> has been defined with single quotes. To disable expansion use a second backslash before the escape sequence (e.g., "\\n") or use the <code>regexptranslate</code> function. </p> <p>The outputs of <code>regexp</code> default to the order given below </p> <dl compact> <dt><var>s</var></dt> <dd>
<p>The start indices of each matching substring </p> </dd> <dt><var>e</var></dt> <dd>
<p>The end indices of each matching substring </p> </dd> <dt><var>te</var></dt> <dd>
<p>The extents of each matched token surrounded by <code>(…)</code> in <var>pat</var> </p> </dd> <dt><var>m</var></dt> <dd>
<p>A cell array of the text of each match </p> </dd> <dt><var>t</var></dt> <dd>
<p>A cell array of the text of each token matched </p> </dd> <dt><var>nm</var></dt> <dd>
<p>A structure containing the text of each matched named token, with the name being used as the fieldname. A named token is denoted by <code>(?&lt;name&gt;…)</code>. </p> </dd> <dt><var>sp</var></dt> <dd><p>A cell array of the text not returned by match, i.e., what remains if you split the string based on <var>pat</var>. </p></dd> </dl> <p>Particular output arguments, or the order of the output arguments, can be selected by additional <var>opt</var> arguments. These are strings and the correspondence between the output arguments and the optional argument are </p> <table> <tr>
<td width="20%"></td>
<td width="30%"><code>'start'</code></td>
<td width="30%"><var>s</var></td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%"><code>'end'</code></td>
<td width="30%"><var>e</var></td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%"><code>'tokenExtents'</code></td>
<td width="30%"><var>te</var></td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%"><code>'match'</code></td>
<td width="30%"><var>m</var></td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%"><code>'tokens'</code></td>
<td width="30%"><var>t</var></td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%"><code>'names'</code></td>
<td width="30%"><var>nm</var></td>
<td width="20%"></td>
</tr> <tr>
<td width="20%"></td>
<td width="30%"><code>'split'</code></td>
<td width="30%"><var>sp</var></td>
<td width="20%"></td>
</tr> </table> <p>Additional arguments are summarized below. </p> <dl compact> <dt>‘<samp>once</samp>’</dt> <dd>
<p>Return only the first occurrence of the pattern. </p> </dd> <dt>‘<samp>matchcase</samp>’</dt> <dd>
<p>Make the matching case sensitive. (default) </p> <p>Alternatively, use (?-i) in the pattern. </p> </dd> <dt>‘<samp>ignorecase</samp>’</dt> <dd>
<p>Ignore case when matching the pattern to the string. </p> <p>Alternatively, use (?i) in the pattern. </p> </dd> <dt>‘<samp>stringanchors</samp>’</dt> <dd>
<p>Match the anchor characters at the beginning and end of the string. (default) </p> <p>Alternatively, use (?-m) in the pattern. </p> </dd> <dt>‘<samp>lineanchors</samp>’</dt> <dd>
<p>Match the anchor characters at the beginning and end of the line. </p> <p>Alternatively, use (?m) in the pattern. </p> </dd> <dt>‘<samp>dotall</samp>’</dt> <dd>
<p>The pattern <code>.</code> matches all characters including the newline character. (default) </p> <p>Alternatively, use (?s) in the pattern. </p> </dd> <dt>‘<samp>dotexceptnewline</samp>’</dt> <dd>
<p>The pattern <code>.</code> matches all characters except the newline character. </p> <p>Alternatively, use (?-s) in the pattern. </p> </dd> <dt>‘<samp>literalspacing</samp>’</dt> <dd>
<p>All characters in the pattern, including whitespace, are significant and are used in pattern matching. (default) </p> <p>Alternatively, use (?-x) in the pattern. </p> </dd> <dt>‘<samp>freespacing</samp>’</dt> <dd>
<p>The pattern may include arbitrary whitespace and also comments beginning with the character ‘<samp>#</samp>’. </p> <p>Alternatively, use (?x) in the pattern. </p> </dd> <dt>‘<samp>noemptymatch</samp>’</dt> <dd>
<p>Zero-length matches are not returned. (default) </p> </dd> <dt>‘<samp>emptymatch</samp>’</dt> <dd>
<p>Return zero-length matches. </p> <p><code>regexp ('a', 'b*', 'emptymatch')</code> returns <code>[1 2]</code> because there are zero or more <code>'b'</code> characters at positions 1 and end-of-string. </p> </dd> </dl> <p>Stack Limitation Note: Pattern searches are done with a recursive function which can overflow the program stack when there are a high number of matches. For example, </p> <pre class="example" data-language="matlab">regexp (repmat ('a', 1, 1e5), '(a)+')</pre> <p>may lead to a segfault. As an alternative, consider constructing pattern searches that reduce the number of matches (e.g., by creatively using set complement), and then further processing the return variables (now reduced in size) with successive <code>regexp</code> searches. </p> <p><strong>See also:</strong> <a href="#XREFregexpi">regexpi</a>, <a href="#XREFstrfind">strfind</a>, <a href="#XREFregexprep">regexprep</a>. </p>
</dd>
</dl> <dl id="XREFregexpi"> <dt id="index-regexpi">[s, e, te, m, t, nm, sp] = regexpi (str, pat)</dt> <dt id="index-regexpi-1">[…] = regexpi (str, pat, "opt1", …)</dt> <dd> <p>Case insensitive regular expression string matching. </p> <p>Search for <var>pat</var> in <var>str</var> and return the positions and substrings of any matches, or empty values if there are none. See <a href="#XREFregexp">regexp</a>, for details on the syntax of the search pattern. </p> <p><strong>See also:</strong> <a href="#XREFregexp">regexp</a>. </p>
</dd>
</dl> <dl id="XREFregexprep"> <dt id="index-regexprep">outstr = regexprep (string, pat, repstr)</dt> <dt id="index-regexprep-1">outstr = regexprep (string, pat, repstr, "opt1", …)</dt> <dd>
<p>Replace occurrences of pattern <var>pat</var> in <var>string</var> with <var>repstr</var>. </p> <p>The pattern is a regular expression as documented for <code>regexp</code>. See <a href="#XREFregexp">regexp</a>. </p> <p>The replacement string may contain <code>$i</code>, which substitutes for the ith set of parentheses in the match string. For example, </p> <pre class="example" data-language="matlab">regexprep ("Bill Dunn", '(\w+) (\w+)', '$2, $1')</pre> <p>returns <code>"Dunn, Bill"</code> </p> <p>Options in addition to those of <code>regexp</code> are </p> <dl compact> <dt>‘<samp>once</samp>’</dt> <dd>
<p>Replace only the first occurrence of <var>pat</var> in the result. </p> </dd> <dt>‘<samp>warnings</samp>’</dt> <dd>
<p>This option is present for compatibility but is ignored. </p> </dd> </dl> <p>Implementation Note: For compatibility with <small>MATLAB</small>, escape sequences in <var>pat</var> (e.g., <code>"\n"</code> =&gt; newline) are expanded even when <var>pat</var> has been defined with single quotes. To disable expansion use a second backslash before the escape sequence (e.g., "\\n") or use the <code>regexptranslate</code> function. </p> <p><strong>See also:</strong> <a href="#XREFregexp">regexp</a>, <a href="#XREFregexpi">regexpi</a>, <a href="#XREFstrrep">strrep</a>. </p>
</dd>
</dl> <dl id="XREFregexptranslate"> <dt id="index-regexptranslate">regexptranslate (op, s)</dt> <dd>
<p>Translate a string for use in a regular expression. </p> <p>This may include either wildcard replacement or special character escaping. </p> <p>The behavior is controlled by <var>op</var> which can take the following values </p> <dl compact> <dt><code>"wildcard"</code></dt> <dd>
<p>The wildcard characters <code>.</code>, <code>*</code>, and <code>?</code> are replaced with wildcards that are appropriate for a regular expression. For example: </p> <pre class="example" data-language="matlab">regexptranslate ("wildcard", "*.m")
     ⇒ '.*\.m'</pre> </dd> <dt><code>"escape"</code></dt> <dd>
<p>The characters <code>$.?[]</code>, that have special meaning for regular expressions are escaped so that they are treated literally. For example: </p> <pre class="example" data-language="matlab">regexptranslate ("escape", "12.5")
     ⇒ '12\.5'</pre> </dd> </dl> <p><strong>See also:</strong> <a href="#XREFregexp">regexp</a>, <a href="#XREFregexpi">regexpi</a>, <a href="#XREFregexprep">regexprep</a>. </p>
</dd>
</dl> <dl id="XREFuntabify"> <dt id="index-untabify">untabify (t)</dt> <dt id="index-untabify-1">untabify (t, tw)</dt> <dt id="index-untabify-2">untabify (t, tw, deblank)</dt> <dd>
<p>Replace TAB characters in <var>t</var> with spaces. </p> <p>The input, <var>t</var>, may be either a 2-D character array, or a cell array of character strings. The output is the same class as the input. </p> <p>The tab width is specified by <var>tw</var>, and defaults to eight. </p> <p>If the optional argument <var>deblank</var> is true, then the spaces will be removed from the end of the character data. </p> <p>The following example reads a file and writes an untabified version of the same file with trailing spaces stripped. </p> <pre class="example" data-language="matlab">fid = fopen ("tabbed_script.m");
text = char (fread (fid, "uchar")');
fclose (fid);
fid = fopen ("untabified_script.m", "w");
text = untabify (strsplit (text, "\n"), 8, true);
fprintf (fid, "%s\n", text{:});
fclose (fid);</pre> <p><strong>See also:</strong> <a href="string-conversions#XREFstrjust">strjust</a>, <a href="#XREFstrsplit">strsplit</a>, <a href="#XREFdeblank">deblank</a>. </p>
</dd>
</dl> <dl id="XREFunicode_005fidx"> <dt id="index-unicode_005fidx">idx = unicode_idx (str)</dt> <dd>
<p>Return an array with the indices for each UTF-8 encoded character in <var>str</var>. </p> <pre class="example" data-language="matlab">unicode_idx ("aäbc")
     ⇒ [1, 2, 2, 3, 4]</pre> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
          © 1996–2018 John W. Eaton<br>      Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://octave.org/doc/interpreter/Manipulating-Strings.html" class="_attribution-link">https://octave.org/doc/interpreter/Manipulating-Strings.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
