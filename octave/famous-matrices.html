
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Famous Matrices - Octave - W3cubDocs</title>
  
  <meta name="description" content=" The following functions return famous matrix forms. ">
  <meta name="keywords" content="famous, matrices, octave">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/octave/famous-matrices.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/octave.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/octave/" class="_nav-link" title="" style="margin-left:0;">Octave</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _octave">
				
				
<h1 class="section">16.4 Famous Matrices</h1> <p>The following functions return famous matrix forms. </p> <dl id="XREFgallery"> <dt id="index-gallery">gallery (name)</dt> <dt id="index-gallery-1">gallery (name, args)</dt> <dd>
<p>Create interesting matrices for testing. </p> </dd>
</dl> <dl> <dt id="index-gallery-2">c = gallery ("cauchy", x)</dt> <dt id="index-gallery-3">c = gallery ("cauchy", x, y)</dt> <dd>
<p>Create a Cauchy matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-4">c = gallery ("chebspec", n)</dt> <dt id="index-gallery-5">c = gallery ("chebspec", n, k)</dt> <dd>
<p>Create a Chebyshev spectral differentiation matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-6">c = gallery ("chebvand", p)</dt> <dt id="index-gallery-7">c = gallery ("chebvand", m, p)</dt> <dd>
<p>Create a Vandermonde-like matrix for the Chebyshev polynomials. </p> </dd>
</dl> <dl> <dt id="index-gallery-8">a = gallery ("chow", n)</dt> <dt id="index-gallery-9">a = gallery ("chow", n, alpha)</dt> <dt id="index-gallery-10">a = gallery ("chow", n, alpha, delta)</dt> <dd>
<p>Create a Chow matrix – a singular Toeplitz lower Hessenberg matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-11">c = gallery ("circul", v)</dt> <dd>
<p>Create a circulant matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-12">a = gallery ("clement", n)</dt> <dt id="index-gallery-13">a = gallery ("clement", n, k)</dt> <dd>
<p>Create a tridiagonal matrix with zero diagonal entries. </p> </dd>
</dl> <dl> <dt id="index-gallery-14">c = gallery ("compar", a)</dt> <dt id="index-gallery-15">c = gallery ("compar", a, k)</dt> <dd>
<p>Create a comparison matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-16">a = gallery ("condex", n)</dt> <dt id="index-gallery-17">a = gallery ("condex", n, k)</dt> <dt id="index-gallery-18">a = gallery ("condex", n, k, theta)</dt> <dd>
<p>Create a ‘counterexample’ matrix to a condition estimator. </p> </dd>
</dl> <dl> <dt id="index-gallery-19">a = gallery ("cycol", [m n])</dt> <dt id="index-gallery-20">a = gallery ("cycol", n)</dt> <dt id="index-gallery-21">a = gallery (…, k)</dt> <dd>
<p>Create a matrix whose columns repeat cyclically. </p> </dd>
</dl> <dl> <dt id="index-gallery-22">[c, d, e] = gallery ("dorr", n)</dt> <dt id="index-gallery-23">[c, d, e] = gallery ("dorr", n, theta)</dt> <dt id="index-gallery-24">a = gallery ("dorr", …)</dt> <dd>
<p>Create a diagonally dominant, ill-conditioned, tridiagonal matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-25">a = gallery ("dramadah", n)</dt> <dt id="index-gallery-26">a = gallery ("dramadah", n, k)</dt> <dd>
<p>Create a (0, 1) matrix whose inverse has large integer entries. </p> </dd>
</dl> <dl> <dt id="index-gallery-27">a = gallery ("fiedler", c)</dt> <dd>
<p>Create a symmetric Fiedler matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-28">a = gallery ("forsythe", n)</dt> <dt id="index-gallery-29">a = gallery ("forsythe", n, alpha)</dt> <dt id="index-gallery-30">a = gallery ("forsythe", n, alpha, lambda)</dt> <dd>
<p>Create a Forsythe matrix (a perturbed Jordan block). </p> </dd>
</dl> <dl> <dt id="index-gallery-31">f = gallery ("frank", n)</dt> <dt id="index-gallery-32">f = gallery ("frank", n, k)</dt> <dd>
<p>Create a Frank matrix (ill-conditioned eigenvalues). </p> </dd>
</dl> <dl> <dt id="index-gallery-33">c = gallery ("gcdmat", n)</dt> <dd>
<p>Create a greatest common divisor matrix. </p> <p><var>c</var> is an <var>n</var>-by-<var>n</var> matrix whose values correspond to the greatest common divisor of its coordinate values, i.e., <var>c</var>(i,j) correspond <code>gcd (i, j)</code>. </p>
</dd>
</dl> <dl> <dt id="index-gallery-34">a = gallery ("gearmat", n)</dt> <dt id="index-gallery-35">a = gallery ("gearmat", n, i)</dt> <dt id="index-gallery-36">a = gallery ("gearmat", n, i, j)</dt> <dd>
<p>Create a Gear matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-37">g = gallery ("grcar", n)</dt> <dt id="index-gallery-38">g = gallery ("grcar", n, k)</dt> <dd>
<p>Create a Toeplitz matrix with sensitive eigenvalues. </p> </dd>
</dl> <dl> <dt id="index-gallery-39">a = gallery ("hanowa", n)</dt> <dt id="index-gallery-40">a = gallery ("hanowa", n, d)</dt> <dd>
<p>Create a matrix whose eigenvalues lie on a vertical line in the complex plane. </p> </dd>
</dl> <dl> <dt id="index-gallery-41">v = gallery ("house", x)</dt> <dt id="index-gallery-42">[v, beta] = gallery ("house", x)</dt> <dd>
<p>Create a householder matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-43">a = gallery ("integerdata", imax, [M N …], j)</dt> <dt id="index-gallery-44">a = gallery ("integerdata", imax, M, N, …, j)</dt> <dt id="index-gallery-45">a = gallery ("integerdata", [imin, imax], [M N …], j)</dt> <dt id="index-gallery-46">a = gallery ("integerdata", [imin, imax], M, N, …, j)</dt> <dt id="index-gallery-47">a = gallery ("integerdata", …, "class")</dt> <dd>
<p>Create a matrix with random integers in the range [1, <var>imax</var>]. If <var>imin</var> is given then the integers are in the range [<var>imin</var>, <var>imax</var>]. </p> <p>The second input is a matrix of dimensions describing the size of the output. The dimensions can also be input as comma-separated arguments. </p> <p>The input <var>j</var> is an integer index in the range [0, 2^32-1]. The values of the output matrix are always exactly the same (reproducibility) for a given size input and <var>j</var> index. </p> <p>The final optional argument determines the class of the resulting matrix. Possible values for <var>class</var>: <code>"uint8"</code>, <code>"uint16"</code>, <code>"uint32"</code>, <code>"int8"</code>, <code>"int16"</code>, int32", <code>"single"</code>, <code>"double"</code>. The default is <code>"double"</code>. </p> </dd>
</dl> <dl> <dt id="index-gallery-48">a = gallery ("invhess", x)</dt> <dt id="index-gallery-49">a = gallery ("invhess", x, y)</dt> <dd>
<p>Create the inverse of an upper Hessenberg matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-50">a = gallery ("invol", n)</dt> <dd>
<p>Create an involutory matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-51">a = gallery ("ipjfact", n)</dt> <dt id="index-gallery-52">a = gallery ("ipjfact", n, k)</dt> <dd>
<p>Create a Hankel matrix with factorial elements. </p> </dd>
</dl> <dl> <dt id="index-gallery-53">a = gallery ("jordbloc", n)</dt> <dt id="index-gallery-54">a = gallery ("jordbloc", n, lambda)</dt> <dd>
<p>Create a Jordan block. </p> </dd>
</dl> <dl> <dt id="index-gallery-55">u = gallery ("kahan", n)</dt> <dt id="index-gallery-56">u = gallery ("kahan", n, theta)</dt> <dt id="index-gallery-57">u = gallery ("kahan", n, theta, pert)</dt> <dd>
<p>Create a Kahan matrix (upper trapezoidal). </p> </dd>
</dl> <dl> <dt id="index-gallery-58">a = gallery ("kms", n)</dt> <dt id="index-gallery-59">a = gallery ("kms", n, rho)</dt> <dd>
<p>Create a Kac-Murdock-Szego Toeplitz matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-60">b = gallery ("krylov", a)</dt> <dt id="index-gallery-61">b = gallery ("krylov", a, x)</dt> <dt id="index-gallery-62">b = gallery ("krylov", a, x, j)</dt> <dd>
<p>Create a Krylov matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-63">a = gallery ("lauchli", n)</dt> <dt id="index-gallery-64">a = gallery ("lauchli", n, mu)</dt> <dd>
<p>Create a Lauchli matrix (rectangular). </p> </dd>
</dl> <dl> <dt id="index-gallery-65">a = gallery ("lehmer", n)</dt> <dd>
<p>Create a Lehmer matrix (symmetric positive definite). </p> </dd>
</dl> <dl> <dt id="index-gallery-66">t = gallery ("lesp", n)</dt> <dd>
<p>Create a tridiagonal matrix with real, sensitive eigenvalues. </p> </dd>
</dl> <dl> <dt id="index-gallery-67">a = gallery ("lotkin", n)</dt> <dd>
<p>Create a Lotkin matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-68">a = gallery ("minij", n)</dt> <dd>
<p>Create a symmetric positive definite matrix MIN(i,j). </p> </dd>
</dl> <dl> <dt id="index-gallery-69">a = gallery ("moler", n)</dt> <dt id="index-gallery-70">a = gallery ("moler", n, alpha)</dt> <dd>
<p>Create a Moler matrix (symmetric positive definite). </p> </dd>
</dl> <dl> <dt id="index-gallery-71">[a, t] = gallery ("neumann", n)</dt> <dd>
<p>Create a singular matrix from the discrete Neumann problem (sparse). </p> </dd>
</dl> <dl> <dt id="index-gallery-72">a = gallery ("normaldata", [M N …], j)</dt> <dt id="index-gallery-73">a = gallery ("normaldata", M, N, …, j)</dt> <dt id="index-gallery-74">a = gallery ("normaldata", …, "class")</dt> <dd>
<p>Create a matrix with random samples from the standard normal distribution (mean = 0, std = 1). </p> <p>The first input is a matrix of dimensions describing the size of the output. The dimensions can also be input as comma-separated arguments. </p> <p>The input <var>j</var> is an integer index in the range [0, 2^32-1]. The values of the output matrix are always exactly the same (reproducibility) for a given size input and <var>j</var> index. </p> <p>The final optional argument determines the class of the resulting matrix. Possible values for <var>class</var>: <code>"single"</code>, <code>"double"</code>. The default is <code>"double"</code>. </p> </dd>
</dl> <dl> <dt id="index-gallery-75">q = gallery ("orthog", n)</dt> <dt id="index-gallery-76">q = gallery ("orthog", n, k)</dt> <dd>
<p>Create orthogonal and nearly orthogonal matrices. </p> </dd>
</dl> <dl> <dt id="index-gallery-77">a = gallery ("parter", n)</dt> <dd>
<p>Create a Parter matrix (a Toeplitz matrix with singular values near pi). </p> </dd>
</dl> <dl> <dt id="index-gallery-78">p = gallery ("pei", n)</dt> <dt id="index-gallery-79">p = gallery ("pei", n, alpha)</dt> <dd>
<p>Create a Pei matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-80">a = gallery ("Poisson", n)</dt> <dd>
<p>Create a block tridiagonal matrix from Poisson’s equation (sparse). </p> </dd>
</dl> <dl> <dt id="index-gallery-81">a = gallery ("prolate", n)</dt> <dt id="index-gallery-82">a = gallery ("prolate", n, w)</dt> <dd>
<p>Create a prolate matrix (symmetric, ill-conditioned Toeplitz matrix). </p> </dd>
</dl> <dl> <dt id="index-gallery-83">h = gallery ("randhess", x)</dt> <dd>
<p>Create a random, orthogonal upper Hessenberg matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-84">a = gallery ("rando", n)</dt> <dt id="index-gallery-85">a = gallery ("rando", n, k)</dt> <dd>
<p>Create a random matrix with elements -1, 0 or 1. </p> </dd>
</dl> <dl> <dt id="index-gallery-86">a = gallery ("randsvd", n)</dt> <dt id="index-gallery-87">a = gallery ("randsvd", n, kappa)</dt> <dt id="index-gallery-88">a = gallery ("randsvd", n, kappa, mode)</dt> <dt id="index-gallery-89">a = gallery ("randsvd", n, kappa, mode, kl)</dt> <dt id="index-gallery-90">a = gallery ("randsvd", n, kappa, mode, kl, ku)</dt> <dd>
<p>Create a random matrix with pre-assigned singular values. </p> </dd>
</dl> <dl> <dt id="index-gallery-91">a = gallery ("redheff", n)</dt> <dd>
<p>Create a zero and ones matrix of Redheffer associated with the Riemann hypothesis. </p> </dd>
</dl> <dl> <dt id="index-gallery-92">a = gallery ("riemann", n)</dt> <dd>
<p>Create a matrix associated with the Riemann hypothesis. </p> </dd>
</dl> <dl> <dt id="index-gallery-93">a = gallery ("ris", n)</dt> <dd>
<p>Create a symmetric Hankel matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-94">a = gallery ("smoke", n)</dt> <dt id="index-gallery-95">a = gallery ("smoke", n, k)</dt> <dd>
<p>Create a complex matrix, with a ‘smoke ring’ pseudospectrum. </p> </dd>
</dl> <dl> <dt id="index-gallery-96">t = gallery ("toeppd", n)</dt> <dt id="index-gallery-97">t = gallery ("toeppd", n, m)</dt> <dt id="index-gallery-98">t = gallery ("toeppd", n, m, w)</dt> <dt id="index-gallery-99">t = gallery ("toeppd", n, m, w, theta)</dt> <dd>
<p>Create a symmetric positive definite Toeplitz matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-100">p = gallery ("toeppen", n)</dt> <dt id="index-gallery-101">p = gallery ("toeppen", n, a)</dt> <dt id="index-gallery-102">p = gallery ("toeppen", n, a, b)</dt> <dt id="index-gallery-103">p = gallery ("toeppen", n, a, b, c)</dt> <dt id="index-gallery-104">p = gallery ("toeppen", n, a, b, c, d)</dt> <dt id="index-gallery-105">p = gallery ("toeppen", n, a, b, c, d, e)</dt> <dd>
<p>Create a pentadiagonal Toeplitz matrix (sparse). </p> </dd>
</dl> <dl> <dt id="index-gallery-106">a = gallery ("tridiag", x, y, z)</dt> <dt id="index-gallery-107">a = gallery ("tridiag", n)</dt> <dt id="index-gallery-108">a = gallery ("tridiag", n, c, d, e)</dt> <dd>
<p>Create a tridiagonal matrix (sparse). </p> </dd>
</dl> <dl> <dt id="index-gallery-109">t = gallery ("triw", n)</dt> <dt id="index-gallery-110">t = gallery ("triw", n, alpha)</dt> <dt id="index-gallery-111">t = gallery ("triw", n, alpha, k)</dt> <dd>
<p>Create an upper triangular matrix discussed by Kahan, Golub, and Wilkinson. </p> </dd>
</dl> <dl> <dt id="index-gallery-112">a = gallery ("uniformdata", [M N …], j)</dt> <dt id="index-gallery-113">a = gallery ("uniformdata", M, N, …, j)</dt> <dt id="index-gallery-114">a = gallery ("uniformdata", …, "class")</dt> <dd>
<p>Create a matrix with random samples from the standard uniform distribution (range [0,1]). </p> <p>The first input is a matrix of dimensions describing the size of the output. The dimensions can also be input as comma-separated arguments. </p> <p>The input <var>j</var> is an integer index in the range [0, 2^32-1]. The values of the output matrix are always exactly the same (reproducibility) for a given size input and <var>j</var> index. </p> <p>The final optional argument determines the class of the resulting matrix. Possible values for <var>class</var>: <code>"single"</code>, <code>"double"</code>. The default is <code>"double"</code>. </p> </dd>
</dl> <dl> <dt id="index-gallery-115">a = gallery ("wathen", nx, ny)</dt> <dt id="index-gallery-116">a = gallery ("wathen", nx, ny, k)</dt> <dd>
<p>Create the Wathen matrix. </p> </dd>
</dl> <dl> <dt id="index-gallery-117">[a, b] = gallery ("wilk", n)</dt> <dd>
<p>Create various specific matrices devised/discussed by Wilkinson. </p> </dd>
</dl> <dl id="XREFhadamard"> <dt id="index-hadamard">hadamard (n)</dt> <dd>
<p>Construct a Hadamard matrix (Hn) of size <var>n</var>-by-<var>n</var>. </p> <p>The size <var>n</var> must be of the form <em>2^k * p</em> in which p is one of 1, 12, 20 or 28. The returned matrix is normalized, meaning <code>Hn(:,1) == 1</code> and <code>Hn(1,:) == 1</code>. </p> <p>Some of the properties of Hadamard matrices are: </p> <ul> <li> <code>kron (Hm, Hn)</code> is a Hadamard matrix of size <var>m</var>-by-<var>n</var>. </li>
<li> <code>Hn * Hn' = <var>n</var> * eye (<var>n</var>)</code>. </li>
<li> The rows of Hn are orthogonal. </li>
<li> <code>det (<var>A</var>) &lt;= abs (det (Hn))</code> for all <var>A</var> with <code>abs (<var>A</var>(i, j)) &lt;= 1</code>. </li>
<li> Multiplying any row or column by -1 and the matrix will remain a Hadamard matrix. </li>
</ul> <p><strong>See also:</strong> <a href="finding-roots#XREFcompan">compan</a>, <a href="#XREFhankel">hankel</a>, <a href="#XREFtoeplitz">toeplitz</a>. </p>
</dd>
</dl> <dl id="XREFhankel"> <dt id="index-hankel">hankel (c)</dt> <dt id="index-hankel-1">hankel (c, r)</dt> <dd>
<p>Return the Hankel matrix constructed from the first column <var>c</var>, and (optionally) the last row <var>r</var>. </p> <p>If the last element of <var>c</var> is not the same as the first element of <var>r</var>, the last element of <var>c</var> is used. If the second argument is omitted, it is assumed to be a vector of zeros with the same size as <var>c</var>. </p> <p>A Hankel matrix formed from an m-vector <var>c</var>, and an n-vector <var>r</var>, has the elements </p> <pre class="example" data-language="matlab">H(i,j) = c(i+j-1),  i+j-1 &lt;= m;
H(i,j) = r(i+j-m),  otherwise</pre> <p><strong>See also:</strong> <a href="#XREFhadamard">hadamard</a>, <a href="#XREFtoeplitz">toeplitz</a>. </p>
</dd>
</dl> <dl id="XREFhilb"> <dt id="index-hilb">hilb (n)</dt> <dd>
<p>Return the Hilbert matrix of order <var>n</var>. </p> <p>The <em>i,j</em> element of a Hilbert matrix is defined as </p> <pre class="example" data-language="matlab">H(i, j) = 1 / (i + j - 1)</pre> <p>Hilbert matrices are close to being singular which make them difficult to invert with numerical routines. Comparing the condition number of a random matrix 5x5 matrix with that of a Hilbert matrix of order 5 reveals just how difficult the problem is. </p> <pre class="example" data-language="matlab">cond (rand (5))
   ⇒ 14.392
cond (hilb (5))
   ⇒ 4.7661e+05</pre> <p><strong>See also:</strong> <a href="#XREFinvhilb">invhilb</a>. </p>
</dd>
</dl> <dl id="XREFinvhilb"> <dt id="index-invhilb">invhilb (n)</dt> <dd>
<p>Return the inverse of the Hilbert matrix of order <var>n</var>. </p> <p>This can be computed exactly using </p> <pre class="example" data-language="matlab">(i+j)         /n+i-1\  /n+j-1\   /i+j-2\ 2
A(i,j) = -1      (i+j-1)(       )(       ) (       )
                         \ n-j /  \ n-i /   \ i-2 /

       = p(i) p(j) / (i+j-1)</pre> <p>where </p> <pre class="example" data-language="matlab">k  /k+n-1\   /n\
p(k) = -1  (       ) (   )
            \ k-1 /   \k/</pre> <p>The validity of this formula can easily be checked by expanding the binomial coefficients in both formulas as factorials. It can be derived more directly via the theory of Cauchy matrices. See J. W. Demmel, <cite>Applied Numerical Linear Algebra</cite>, p. 92. </p> <p>Compare this with the numerical calculation of <code>inverse (hilb (n))</code>, which suffers from the ill-conditioning of the Hilbert matrix, and the finite precision of your computer’s floating point arithmetic. </p> <p><strong>See also:</strong> <a href="#XREFhilb">hilb</a>. </p>
</dd>
</dl> <dl id="XREFmagic"> <dt id="index-magic">magic (n)</dt> <dd> <p>Create an <var>n</var>-by-<var>n</var> magic square. </p> <p>A magic square is an arrangement of the integers <code>1:n^2</code> such that the row sums, column sums, and diagonal sums are all equal to the same value. </p> <p>Note: <var>n</var> must be a scalar greater than or equal to 3. If you supply <var>n</var> less than 3, magic returns either a nonmagic square, or else the degenerate magic squares 1 and []. </p>
</dd>
</dl> <dl id="XREFpascal"> <dt id="index-pascal">pascal (n)</dt> <dt id="index-pascal-1">pascal (n, t)</dt> <dd>
<p>Return the Pascal matrix of order <var>n</var> if <code><var>t</var> = 0</code>. </p> <p>The default value of <var>t</var> is 0. </p> <p>When <code><var>t</var> = 1</code>, return the pseudo-lower triangular Cholesky factor of the Pascal matrix (The sign of some columns may be negative). This matrix is its own inverse, that is <code>pascal (<var>n</var>, 1) ^ 2 == eye (<var>n</var>)</code>. </p> <p>If <code><var>t</var> = -1</code>, return the true Cholesky factor with strictly positive values on the diagonal. </p> <p>If <code><var>t</var> = 2</code>, return a transposed and permuted version of <code>pascal (<var>n</var>, 1)</code>, which is the cube root of the identity matrix. That is, <code>pascal (<var>n</var>, 2) ^ 3 == eye (<var>n</var>)</code>. </p> <p><strong>See also:</strong> <a href="matrix-factorizations#XREFchol">chol</a>. </p>
</dd>
</dl> <dl id="XREFrosser"> <dt id="index-rosser">rosser ()</dt> <dd>
<p>Return the Rosser matrix. </p> <p>This is a difficult test case used to evaluate eigenvalue algorithms. </p> <p><strong>See also:</strong> <a href="#XREFwilkinson">wilkinson</a>, <a href="basic-matrix-functions#XREFeig">eig</a>. </p>
</dd>
</dl> <dl id="XREFtoeplitz"> <dt id="index-toeplitz">toeplitz (c)</dt> <dt id="index-toeplitz-1">toeplitz (c, r)</dt> <dd>
<p>Return the Toeplitz matrix constructed from the first column <var>c</var>, and optionally the first row <var>r</var>. </p> <p>If the second argument is omitted, the first row is taken to be the same as the first column. If the first element of <var>r</var> is not the same as the first element of <var>c</var>, the first element of <var>c</var> is used. </p> <p>A Toeplitz, or diagonal-constant, matrix has the same value along each diagonal. Although it need not be square, it often is. An MxN Toeplitz matrix has the form: </p> <pre class="example" data-language="matlab">c(1)  r(2)   r(3)  …  r(n)
c(2)  c(1)   r(2)  … r(n-1)
c(3)  c(2)   c(1)  … r(n-2)
 .     .      .   .      .
 .     .      .     .    .
 .     .      .       .  .
c(m) c(m-1) c(m-2) … c(m-n+1)</pre> <p><strong>See also:</strong> <a href="#XREFhankel">hankel</a>. </p>
</dd>
</dl> <dl id="XREFvander"> <dt id="index-vander">vander (c)</dt> <dt id="index-vander-1">vander (c, n)</dt> <dd>
<p>Return the Vandermonde matrix whose next to last column is <var>c</var>. </p> <p>If <var>n</var> is specified, it determines the number of columns; otherwise, <var>n</var> is taken to be equal to the length of <var>c</var>. </p> <p>A Vandermonde matrix has the form: </p> <pre class="example" data-language="matlab">c(1)^(n-1) … c(1)^2  c(1)  1
c(2)^(n-1) … c(2)^2  c(2)  1
    .     .      .      .    .
    .       .    .      .    .
    .         .  .      .    .
c(n)^(n-1) … c(n)^2  c(n)  1</pre> <p><strong>See also:</strong> <a href="polynomial-interpolation#XREFpolyfit">polyfit</a>. </p>
</dd>
</dl> <dl id="XREFwilkinson"> <dt id="index-wilkinson">wilkinson (n)</dt> <dd>
<p>Return the Wilkinson matrix of order <var>n</var>. </p> <p>Wilkinson matrices are symmetric and tridiagonal with pairs of nearly, but not exactly, equal eigenvalues. They are useful in testing the behavior and performance of eigenvalue solvers. </p> <p><strong>See also:</strong> <a href="#XREFrosser">rosser</a>, <a href="basic-matrix-functions#XREFeig">eig</a>. </p>
</dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
          © 1996–2018 John W. Eaton<br>      Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://octave.org/doc/interpreter/Famous-Matrices.html" class="_attribution-link">https://octave.org/doc/interpreter/Famous-Matrices.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
