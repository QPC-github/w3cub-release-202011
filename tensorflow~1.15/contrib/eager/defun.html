
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>tf.contrib.eager.defun - TensorFlow 1.15 - W3cubDocs</title>
  
  <meta name="description" content=" Compiles a Python function into a callable TensorFlow graph. ">
  <meta name="keywords" content="tf, contrib, eager, defun, tensorflow, tensorflow~1.15">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow~1.15/contrib/eager/defun.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/tensorflow~1.15.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~1.15/" class="_nav-link" title="" style="margin-left:0;">TensorFlow 1.15</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<h1 class="devsite-page-title">tf.contrib.eager.defun</h1>       <p>Compiles a Python function into a callable TensorFlow graph.</p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.contrib.eager.defun(
    func=None, input_signature=None, autograph=True,
    experimental_autograph_options=None, experimental_relax_shapes=False
)
</pre>  <p><code translate="no" dir="ltr">defun</code> (short for "define function") compiles a Python function composed of TensorFlow operations into a callable that executes a <a href="../../graph"><code translate="no" dir="ltr">tf.Graph</code></a> containing those operations. The callable produced by <code translate="no" dir="ltr">defun</code> contains only the subgraph of TensorFlow operations that were executed when the Python function was called with a particular input signature, defined as a list of the shapes and dtypes of the Python function's Tensor-valued arguments and the values of its non-Tensor Python objects.</p> <p>When eager execution is enabled, the ability to create graphs from Python functions makes it possible to incrementally trade off debugability and interactivity for performance. Functions compiled with <code translate="no" dir="ltr">defun</code> cannot be inspected with <code translate="no" dir="ltr">pdb</code>; however, executing a graph generated by <code translate="no" dir="ltr">defun</code> sometimes takes less time and memory than eagerly executing the corresponding Python function, since specifying computations as graphs allows for optimizations like automatic buffer reuse and parallelization among ops. Note that executing a <code translate="no" dir="ltr">defun</code>-compiled function incurs a small constant overhead, so eagerly executing sufficiently small Python functions might take less time than executing their corresponding <code translate="no" dir="ltr">defun</code>-generated graphs.</p> <p>For a Python function to be compatible with <code translate="no" dir="ltr">defun</code>, all of its arguments must be hashable Python objects or lists thereof. The function itself may not modify the list/map structure of its arguments. Additionally, it must return zero or more <a href="../../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a> objects. If the Python function returns a <a href="../../variable"><code translate="no" dir="ltr">tf.Variable</code></a>, its compiled version will return the value of that variable as a <a href="../../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>.</p> <p>Executing a graph generated by <code translate="no" dir="ltr">defun</code> respects device annotations (i.e., all <code translate="no" dir="ltr">with tf.device</code> directives present in a Python function will also be present in its corresponding graph), but it is not yet possible to execute the generated graphs across multiple machines.</p> <p><em>Example Usage</em></p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">import tensorflow as tf

tf.compat.v1.enable_eager_execution()

# A simple example.
def f(x, y):
  return tf.reduce_mean(tf.multiply(x ** 2, 3) + y)

g = tf.contrib.eager.defun(f)

x = tf.constant([[2.0, 3.0]])
y = tf.constant([[3.0, -2.0]])

# `f` and `g` will return the same value, but `g` will be executed as a
# TensorFlow graph.
assert f(x, y).numpy() == g(x, y).numpy()

# `defun` is capable of compiling Python functions that close over Python
# objects, including Tensors and Variables.
@tf.contrib.eager.defun
def h():
  return f(x, y)

assert (h().numpy() == f(x, y).numpy()).all()

# `defun` automatically lifts variables out of the graphs it creates,
# allowing you to compile the `call` methods of `tf.keras.layers.Layer` and
# `tf.keras.Model` objects.
class MyModel(tf.keras.Model):

  def __init__(self, keep_probability=0.2):
    super(MyModel, self).__init__()
    self.dense1 = tf.keras.layers.Dense(4, activation=tf.nn.relu)
    self.dense2 = tf.keras.layers.Dense(5, activation=tf.nn.softmax)
    self.keep_probability = keep_probability

  @tf.contrib.eager.defun
  def call(self, inputs, training=True):
    x = self.dense2(self.dense1(inputs))
    if training:
      return tf.nn.dropout(x, self.keep_probability)
    else:
      return x

model = MyModel()
model(x, training=True)  # executes a graph, with dropout
model(x, training=False) # executes a graph, without dropout

# `defun`-compiled functions are differentiable.
optimizer = tf.compat.v1.train.GradientDescentOptimizer(learning_rate=0.01)
with tf.GradientTape() as tape:
  outputs = model(x)
gradient = tape.gradient(outputs, model.trainable_variables)
optimizer.apply_gradients((grad, var) for grad, var in zip(gradient,
                          model.trainable_variables))
</pre> <p>When using <code translate="no" dir="ltr">defun</code>, there are subtleties regarding inputs, Python control flow, and variable creation that one should be aware of. For concreteness, let <code translate="no" dir="ltr">f</code> be a Python function that returns zero or more <a href="../../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a> objects and let <code translate="no" dir="ltr">F = defun(f)</code>. <code translate="no" dir="ltr">F</code> builds a graph for each unique input signature it sees, Python control flow is baked into graphs, and operations related to variable initialization are automatically lifted out of the graphs that <code translate="no" dir="ltr">F</code> generates and placed in the eager context if executing eagerly or into an outer graph otherwise.</p> <p><em>Input Signatures</em></p> <p>By default, <code translate="no" dir="ltr">F = tf.contrib.eager.defun(f)</code> instantiates a separate graph for every unique sequence of the shapes and dtypes of Tensor arguments and the values of Python objects it is invoked with. For example, calling <code translate="no" dir="ltr">F(tf.random.uniform([2])</code> will execute a different graph than <code translate="no" dir="ltr">F(tf.random.uniform([3])</code> because the two inputs have different shapes. The first time that <code translate="no" dir="ltr">F(*args, **kwargs)</code> is called with a particular sequence of Tensor shapes and dtypes and Python values, it constructs a graph by tracing the execution of <code translate="no" dir="ltr">f(*args, **kwargs)</code>; this graph is bound to an input signature inferred from <code translate="no" dir="ltr">(*args, **kwargs)</code> and cached for future reuse.</p> <p>NumPy arrays passed as inputs to <code translate="no" dir="ltr">F</code> are converted to <a href="../../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a> objects before being passed to <code translate="no" dir="ltr">f</code>, and are treated as Tensors for caching. This allows a function to be called multiple times with NumPy arrays having different values but the same shape and dtype without re-tracing each time.</p> <p><a href="defun"><code translate="no" dir="ltr">tf.contrib.eager.defun</code></a> caches graphs for your convenience, letting you define TensorFlow functions without explicitly specifying their signatures. However, this policy is conservative and potentially expensive; for example, when different invocations of your function have differently-shaped Tensor inputs, this policy might generate more graph functions than necessary. To eliminate such costs, <a href="defun"><code translate="no" dir="ltr">tf.contrib.eager.defun</code></a> allows you to supply an optional <code translate="no" dir="ltr">input_signature</code> argument specifying the shapes and dtypes of the inputs. In particular, the shapes may be partially unspecified, with <code translate="no" dir="ltr">None</code>s in the unknown dimensions. When an input signature is provided, <a href="defun"><code translate="no" dir="ltr">tf.contrib.eager.defun</code></a> will only instantiate a single graph for the decorated Python function. The following is an example:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">import tensorflow as tf

# The first `TensorSpec` below describes the shape and dtype of `words`,
# and the second describes the shape and dtype of `another_tensor`. Note that
# the last dimension of the `words` `TensorSpec` is left unspecified.
@tf.contrib.eager.defun(input_signature=[
  tf.contrib.eager.TensorSpec(shape=[50, 300, None], dtype=tf.float32),
  tf.contrib.eager.TensorSpec(shape=[300, 100], dtype=tf.float32)
])
def my_sequence_model(words, another_tensor):
  ...

# Note how the third dimension of the first input can vary freely.
words = tf.random.uniform(([50, 300, 10])
second_input = tf.random.uniform([300, 100])
my_sequence_model(words, second_input)

words = tf.random.uniform(([50, 300, 20])
my_sequence_model(words, second_input)

# Passing an input with an incompatible shape will raise an error.
words = tf.random.uniform(([50, 100, 20])
my_sequence_model(words, second_input)  # &lt;---- This will raise an error.

</pre> <p>Python functions that are compiled with an <code translate="no" dir="ltr">input_signature</code> must only accept Tensors as arguments and must not take unnamed keyword arguments (**kwargs).</p> <p><em>Tracing</em></p> <p>Be aware that because <code translate="no" dir="ltr">F</code> only logs TensorFlow operations, all the other Python code that <code translate="no" dir="ltr">f</code> executes will only shape the <em>construction</em> of the graphs that <code translate="no" dir="ltr">F</code> executes: the Python code won't be executed when the graphs themselves are executed, though it will be executed every time the Python function is traced (and a given Python function might be traced multiple times, once for each input signature it is invoked with). For example, whereas the Python function</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">import tensorflow as tf
import numpy as np

tf.compat.v1.enable_eager_execution()

def add_noise():
  return tf.eye(5) + np.random.randn(5, 5)
</pre> <p>will return a different output everytime it is invoked, the compiled function <code translate="no" dir="ltr">compiled = tf.contrib.eager.defun(add_noise)</code> will return the same value every time it is called, since a particular random offset generated by NumPy will be inserted into the graph as a TensorFlow constant. The solution is to replace the call to <code translate="no" dir="ltr">np.random.randn</code> with <code translate="no" dir="ltr">tf.random.normal((5, 5))</code>.</p> <p><em>Python Side-Effects</em></p> <p>A corollary of the previous discussion on tracing is the following: If a Python function <code translate="no" dir="ltr">f</code> has Python side-effects, then executing <code translate="no" dir="ltr">f</code> multiple times will not necessarily be semantically equivalent to executing <code translate="no" dir="ltr">F = tf.contrib.eager.defun(f)</code> multiple times; this difference is due to the fact that <code translate="no" dir="ltr">defun</code> only captures the subgraph of TensorFlow operations that is constructed when <code translate="no" dir="ltr">f</code> is called in a graph-building context.</p> <p><em>Python Control Flow</em></p> <p>The structure of many machine learning computations depend upon whether one is training or validating, and it is common to nest specialized logic under <code translate="no" dir="ltr">if training:</code> blocks. By mapping each input signature to a unique graph, <code translate="no" dir="ltr">defun</code> lets users transparently compile such code, as the following code snippet demonstrates:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">import tensorflow as tf

tf.compat.v1.enable_eager_execution()

@tf.contrib.eager.defun
def lossy_matmul(W, x, training=True):
  outputs = tf.matmul(W, x)
  if training:
    outputs = tf.nn.dropout(outputs, keep_probability=0.2)
  return outputs

W = tf.random.normal((3, 5))
x = tf.random.normal((5, 1))

# Executes a graph that applies dropout.
lossy_outputs = lossy_matmul(W, x, training=True)

# Executes a graph that does not apply dropout.
exact_outputs = lossy_matmul(W, x, training=False)
</pre> <p><em>TensorFlow Control Flow</em></p> <p>When <code translate="no" dir="ltr">autograph</code> is <code translate="no" dir="ltr">True</code>, data-dependent control flow is allowed as well. Control flow statements that depend on <code translate="no" dir="ltr">Tensor</code> values are staged into corresponding TensorFlow ops. For example, the following code will work as expected:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">@tf.contrib.eager.defun
def dynamic_rnn_loop(cell, seq):
  state, output = cell.zero_state()
  for input in seq:
    state, output = cell(input, state)
  return output
</pre> <p>For more information see <a href="../../autograph"><code translate="no" dir="ltr">tf.autograph</code></a>.</p> <p><em>Variables</em></p> <p>TensorFlow operations related to variable creation and initialization are automatically lifted out of the graphs generated by <code translate="no" dir="ltr">defun</code>. In practice, this implies that variable creation and initialization only happen the first time <code translate="no" dir="ltr">F</code> is called, and that variables are reused every time thereafter. Many TensorFlow APIs, like <a href="../../keras/layers/layer"><code translate="no" dir="ltr">tf.keras.layers.Layer</code></a> objects, create variables the first time they are called and reuse them thereafter. Automatic variable lifting makes it possible to compile these APIs without extra effort, at the cost of introducing a discrepancy between the semantics of executing Python functions and their corresponding compiled functions. For example:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">import tensorflow as tf

tf.compat.v1.enable_eager_execution()

def fn():
  x = tf.Variable(0.0)
  x.assign_add(1.0)
  return x.read_value()

# `fn` is a Python function, so x is created, initialized, and destroyed upon
# every invocation
assert fn().numpy() == fn().numpy() == 1.0

compiled = tf.contrib.eager.defun(fn)

# Compiling `fn` with `defun` hoists all variables outside of the generated
# graph, so initialization happens exactly once.
assert compiled().numpy() == 1.0
assert compiled().numpy() == 2.0
</pre> <p>Finally, because each input signature is bound to a unique graph, if your Python function constructs <a href="../../variable"><code translate="no" dir="ltr">tf.Variable</code></a> objects, then each graph constructed for that Python function will reference a unique set of variables. To circumvent this problem, we recommend against compiling Python functions that create <a href="../../variable"><code translate="no" dir="ltr">tf.Variable</code></a> objects. Instead, Python functions should either lexically close over <a href="../../variable"><code translate="no" dir="ltr">tf.Variable</code></a> objects or accept them as arguments, preferably encapsulated in an object-oriented container. If you must create variables inside your Python function and you want each graph generated for it to reference the same set of variables, add logic to your Python function that ensures that variables are only created the first time it is called and are reused for every subsequent invocation; note that this is precisely what <a href="../../keras/layers/layer"><code translate="no" dir="ltr">tf.keras.layers.Layer</code></a> objects do, so we recommend using them to represent variable-bearing computations whenever possible.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">func</code> </td> <td> function to be compiled. If <code translate="no" dir="ltr">func</code> is None, returns a decorator that can be invoked with a single argument - <code translate="no" dir="ltr">func</code>. The end result is equivalent to providing all the arguments up front. In other words, defun(input_signature=...)(func) is equivalent to defun(func, input_signature=...). The former allows the following use case: @tf.contrib.eager.defun(input_signature=...) def foo(...): ... </td> </tr>
<tr> <td> <code translate="no" dir="ltr">input_signature</code> </td> <td> A possibly nested sequence of <a href="../../tensorspec"><code translate="no" dir="ltr">tf.contrib.eager.TensorSpec</code></a> objects specifying the shapes and dtypes of the Tensors that will be supplied to this function. If <code translate="no" dir="ltr">None</code>, a separate function is instantiated for each inferred input signature. If a signature is specified, every input to <code translate="no" dir="ltr">func</code> must be a <code translate="no" dir="ltr">Tensor</code>, and <code translate="no" dir="ltr">func</code> cannot accept <code translate="no" dir="ltr">**kwargs</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">autograph</code> </td> <td> Whether <code translate="no" dir="ltr">func</code> should be compiled before constructing the graph. See https://www.tensorflow.org/guide/autograph for more information. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">experimental_autograph_options</code> </td> <td> Experimental knobs (in the form of a tuple of tensorflow.autograph.Feature values) to control behavior when autograph=True. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">experimental_relax_shapes</code> </td> <td> When true, argument shapes may be relaxed to avoid unecessary retracing. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> If <code translate="no" dir="ltr">func</code> is not None, returns a callable that will execute the compiled function (and return zero or more <a href="../../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a> objects). If <code translate="no" dir="ltr">func</code> is None, returns a decorator that, when invoked with a single <code translate="no" dir="ltr">func</code> argument, returns a callable equivalent to the case above. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">TypeError</code> </td> <td> If <code translate="no" dir="ltr">input_signature</code> is neither <code translate="no" dir="ltr">None</code> nor a sequence of <a href="../../tensorspec"><code translate="no" dir="ltr">tf.contrib.eager.TensorSpec</code></a> objects. </td> </tr> </table>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    © 2020 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r1.15/api_docs/python/tf/contrib/eager/defun" class="_attribution-link">https://www.tensorflow.org/versions/r1.15/api_docs/python/tf/contrib/eager/defun</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
