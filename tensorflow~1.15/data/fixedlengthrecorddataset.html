
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>tf.data.FixedLengthRecordDataset - TensorFlow 1.15 - W3cubDocs</title>
  
  <meta name="description" content=" A Dataset of fixed-length records from one or more binary files. ">
  <meta name="keywords" content="tf, data, fixedlengthrecorddataset, tensorflow, tensorflow~1.15">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow~1.15/data/fixedlengthrecorddataset.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/tensorflow~1.15.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~1.15/" class="_nav-link" title="" style="margin-left:0;">TensorFlow 1.15</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<h1 class="devsite-page-title">tf.data.FixedLengthRecordDataset</h1>      <table class="tfo-notebook-buttons tfo-api" align="left">  <td> <a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/readers.py#L469-L492">  View source on GitHub </a> </td> </table> <p>A <code translate="no" dir="ltr">Dataset</code> of fixed-length records from one or more binary files.</p> <section class="expandable"> <h4 class="showalways" id="view-aliases" data-text="View aliases" tabindex="0">View aliases</h4> <p> <b>Compat aliases for migration</b> </p>
<p>See <a href="https://www.tensorflow.org/guide/migrate">Migration guide</a> for more details.</p> <p><a href="https://www.tensorflow.org/api_docs/python/tf/compat/v1/data/FixedLengthRecordDataset"><code translate="no" dir="ltr">tf.compat.v1.data.FixedLengthRecordDataset</code></a></p> </section> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.data.FixedLengthRecordDataset(
    filenames, record_bytes, header_bytes=None, footer_bytes=None, buffer_size=None,
    compression_type=None, num_parallel_reads=None
)
</pre>   
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">filenames</code> </td> <td> A <a href="../../tf#string"><code translate="no" dir="ltr">tf.string</code></a> tensor or <a href="dataset"><code translate="no" dir="ltr">tf.data.Dataset</code></a> containing one or more filenames. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">record_bytes</code> </td> <td> A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar representing the number of bytes in each record. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">header_bytes</code> </td> <td> (Optional.) A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar representing the number of bytes to skip at the start of a file. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">footer_bytes</code> </td> <td> (Optional.) A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar representing the number of bytes to ignore at the end of a file. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">buffer_size</code> </td> <td> (Optional.) A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar representing the number of bytes to buffer when reading. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">compression_type</code> </td> <td> (Optional.) A <a href="../../tf#string"><code translate="no" dir="ltr">tf.string</code></a> scalar evaluating to one of <code translate="no" dir="ltr">""</code> (no compression), <code translate="no" dir="ltr">"ZLIB"</code>, or <code translate="no" dir="ltr">"GZIP"</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">num_parallel_reads</code> </td> <td> (Optional.) A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar representing the number of files to read in parallel. If greater than one, the records of files read in parallel are outputted in an interleaved order. If your input pipeline is I/O bottlenecked, consider setting this parameter to a value greater than one to parallelize the I/O. If <code translate="no" dir="ltr">None</code>, files will be read sequentially. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Attributes</th></tr> 
<tr> <td> <code translate="no" dir="ltr">element_spec</code> </td> <td> The type specification of an element of this dataset. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">output_classes</code> </td> <td> Returns the class of each component of an element of this dataset. (deprecated) <aside class="warning"><strong>Warning:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <a href="get_output_classes"><code translate="no" dir="ltr">tf.compat.v1.data.get_output_classes(dataset)</code></a>. </span></aside>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">output_shapes</code> </td> <td> Returns the shape of each component of an element of this dataset. (deprecated)<aside class="warning"><strong>Warning:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <a href="get_output_shapes"><code translate="no" dir="ltr">tf.compat.v1.data.get_output_shapes(dataset)</code></a>. </span></aside>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">output_types</code> </td> <td> Returns the type of each component of an element of this dataset. (deprecated)<aside class="warning"><strong>Warning:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <a href="get_output_types"><code translate="no" dir="ltr">tf.compat.v1.data.get_output_types(dataset)</code></a>. </span></aside>
</td> </tr> </table> <h2 id="methods" data-text="Methods" tabindex="0">Methods</h2> <h3 id="apply" data-text="apply" tabindex="0"><code translate="no" dir="ltr">apply</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1355-L1384">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
apply(
    transformation_func
)
</pre> <p>Applies a transformation function to this dataset.</p> <p><code translate="no" dir="ltr">apply</code> enables chaining of custom <code translate="no" dir="ltr">Dataset</code> transformations, which are represented as functions that take one <code translate="no" dir="ltr">Dataset</code> argument and return a transformed <code translate="no" dir="ltr">Dataset</code>.</p> <h4 id="for_example" data-text="For example:" tabindex="0">For example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">dataset = (dataset.map(lambda x: x ** 2)
           .apply(group_by_window(key_func, reduce_func, window_size))
           .map(lambda x: x ** 3))
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">transformation_func</code> </td> <td> A function that takes one <code translate="no" dir="ltr">Dataset</code> argument and returns a <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> The <code translate="no" dir="ltr">Dataset</code> returned by applying <code translate="no" dir="ltr">transformation_func</code> to this dataset. </td> </tr> </table> <h3 id="batch" data-text="batch" tabindex="0"><code translate="no" dir="ltr">batch</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1026-L1047">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
batch(
    batch_size, drop_remainder=False
)
</pre> <p>Combines consecutive elements of this dataset into batches.</p> <p>The components of the resulting element will have an additional outer dimension, which will be <code translate="no" dir="ltr">batch_size</code> (or <code translate="no" dir="ltr">N % batch_size</code> for the last element if <code translate="no" dir="ltr">batch_size</code> does not divide the number of input elements <code translate="no" dir="ltr">N</code> evenly and <code translate="no" dir="ltr">drop_remainder</code> is <code translate="no" dir="ltr">False</code>). If your program depends on the batches having the same outer dimension, you should set the <code translate="no" dir="ltr">drop_remainder</code> argument to <code translate="no" dir="ltr">True</code> to prevent the smaller batch from being produced.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">batch_size</code> </td> <td> A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of consecutive elements of this dataset to combine in a single batch. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">drop_remainder</code> </td> <td> (Optional.) A <a href="../../tf#bool"><code translate="no" dir="ltr">tf.bool</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing whether the last batch should be dropped in the case it has fewer than <code translate="no" dir="ltr">batch_size</code> elements; the default behavior is not to drop the smaller batch. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="cache" data-text="cache" tabindex="0"><code translate="no" dir="ltr">cache</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L932-L943">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
cache(
    filename=''
)
</pre> <p>Caches the elements in this dataset.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">filename</code> </td> <td> A <a href="../../tf#string"><code translate="no" dir="ltr">tf.string</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the name of a directory on the filesystem to use for caching elements in this Dataset. If a filename is not provided, the dataset will be cached in memory. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="concatenate" data-text="concatenate" tabindex="0"><code translate="no" dir="ltr">concatenate</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L755-L777">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
concatenate(
    dataset
)
</pre> <p>Creates a <code translate="no" dir="ltr">Dataset</code> by concatenating the given dataset with this dataset.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">a = Dataset.range(1, 4)  # ==&gt; [ 1, 2, 3 ]
b = Dataset.range(4, 8)  # ==&gt; [ 4, 5, 6, 7 ]

# The input dataset and dataset to be concatenated should have the same
# nested structures and output types.
# c = Dataset.range(8, 14).batch(2)  # ==&gt; [ [8, 9], [10, 11], [12, 13] ]
# d = Dataset.from_tensor_slices([14.0, 15.0, 16.0])
# a.concatenate(c) and a.concatenate(d) would result in error.

a.concatenate(b)  # ==&gt; [ 1, 2, 3, 4, 5, 6, 7 ]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">dataset</code> </td> <td> <code translate="no" dir="ltr">Dataset</code> to be concatenated. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="enumerate" data-text="enumerate" tabindex="0"><code translate="no" dir="ltr">enumerate</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L873-L901">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
enumerate(
    start=0
)
</pre> <p>Enumerates the elements of this dataset.</p> <p>It is similar to python's <code translate="no" dir="ltr">enumerate</code>.</p> <h4 id="for_example_2" data-text="For example:" tabindex="0">For example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># NOTE: The following examples use `{ ... }` to represent the
# contents of a dataset.
a = { 1, 2, 3 }
b = { (7, 8), (9, 10) }

# The nested structure of the `datasets` argument determines the
# structure of elements in the resulting dataset.
a.enumerate(start=5)) == { (5, 1), (6, 2), (7, 3) }
b.enumerate() == { (0, (7, 8)), (1, (9, 10)) }
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">start</code> </td> <td> A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the start value for enumeration. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="filter" data-text="filter" tabindex="0"><code translate="no" dir="ltr">filter</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1331-L1353">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
filter(
    predicate
)
</pre> <p>Filters this dataset according to <code translate="no" dir="ltr">predicate</code>.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">d = tf.data.Dataset.from_tensor_slices([1, 2, 3])

d = d.filter(lambda x: x &lt; 3)  # ==&gt; [1, 2]

# `tf.math.equal(x, y)` is required for equality comparison
def filter_fn(x):
  return tf.math.equal(x, 1)

d = d.filter(filter_fn)  # ==&gt; [1]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">predicate</code> </td> <td> A function mapping a dataset element to a boolean. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> The <code translate="no" dir="ltr">Dataset</code> containing the elements of this dataset for which <code translate="no" dir="ltr">predicate</code> is <code translate="no" dir="ltr">True</code>. </td> </tr> </table> <h3 id="filter_with_legacy_function" data-text="filter_with_legacy_function" tabindex="0"><code translate="no" dir="ltr">filter_with_legacy_function</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1969-L1986">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
filter_with_legacy_function(
    predicate
)
</pre> <p>Filters this dataset according to <code translate="no" dir="ltr">predicate</code>. (deprecated)</p> <aside class="warning"><strong>Warning:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use `tf.data.Dataset.filter()</span></aside><blockquote class="note">
<strong>Note:</strong><span> This is an escape hatch for existing uses of <code translate="no" dir="ltr">filter</code> that do not work with V2 functions. New uses are strongly discouraged and existing uses should migrate to <code translate="no" dir="ltr">filter</code> as this method will be removed in V2.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">predicate</code> </td> <td> A function mapping a nested structure of tensors (having shapes and types defined by <code translate="no" dir="ltr">self.output_shapes</code> and <code translate="no" dir="ltr">self.output_types</code>) to a scalar <a href="../../tf#bool"><code translate="no" dir="ltr">tf.bool</code></a> tensor. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> The <code translate="no" dir="ltr">Dataset</code> containing the elements of this dataset for which <code translate="no" dir="ltr">predicate</code> is <code translate="no" dir="ltr">True</code>. </td> </tr> </table> <h3 id="flat_map" data-text="flat_map" tabindex="0"><code translate="no" dir="ltr">flat_map</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1225-L1249">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
flat_map(
    map_func
)
</pre> <p>Maps <code translate="no" dir="ltr">map_func</code> across this dataset and flattens the result.</p> <p>Use <code translate="no" dir="ltr">flat_map</code> if you want to make sure that the order of your dataset stays the same. For example, to flatten a dataset of batches into a dataset of their elements:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">a = Dataset.from_tensor_slices([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ])

a.flat_map(lambda x: Dataset.from_tensor_slices(x + 1)) # ==&gt;
#  [ 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
</pre> <p><a href="dataset#interleave"><code translate="no" dir="ltr">tf.data.Dataset.interleave()</code></a> is a generalization of <code translate="no" dir="ltr">flat_map</code>, since <code translate="no" dir="ltr">flat_map</code> produces the same output as <a href="dataset#interleave"><code translate="no" dir="ltr">tf.data.Dataset.interleave(cycle_length=1)</code></a></p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">map_func</code> </td> <td> A function mapping a dataset element to a dataset. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="from_generator" data-text="from_generator" tabindex="0"><code translate="no" dir="ltr">from_generator</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L482-L685">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@staticmethod
from_generator(
    generator, output_types, output_shapes=None, args=None
)
</pre> <p>Creates a <code translate="no" dir="ltr">Dataset</code> whose elements are generated by <code translate="no" dir="ltr">generator</code>.</p> <p>The <code translate="no" dir="ltr">generator</code> argument must be a callable object that returns an object that supports the <code translate="no" dir="ltr">iter()</code> protocol (e.g. a generator function). The elements generated by <code translate="no" dir="ltr">generator</code> must be compatible with the given <code translate="no" dir="ltr">output_types</code> and (optional) <code translate="no" dir="ltr">output_shapes</code> arguments.</p> <h4 id="for_example_3" data-text="For example:" tabindex="0">For example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">import itertools
tf.compat.v1.enable_eager_execution()

def gen():
  for i in itertools.count(1):
    yield (i, [1] * i)

ds = tf.data.Dataset.from_generator(
    gen, (tf.int64, tf.int64), (tf.TensorShape([]), tf.TensorShape([None])))

for value in ds.take(2):
  print value
# (1, array([1]))
# (2, array([1, 1]))
</pre>
<blockquote class="note">
<strong>Note:</strong><span> The current implementation of <a href="dataset#from_generator"><code translate="no" dir="ltr">Dataset.from_generator()</code></a> uses <a href="../numpy_function"><code translate="no" dir="ltr">tf.numpy_function</code></a> and inherits the same constraints. In particular, it requires the <code translate="no" dir="ltr">Dataset</code>- and <code translate="no" dir="ltr">Iterator</code>-related operations to be placed on a device in the same process as the Python program that called <a href="dataset#from_generator"><code translate="no" dir="ltr">Dataset.from_generator()</code></a>. The body of <code translate="no" dir="ltr">generator</code> will not be serialized in a <code translate="no" dir="ltr">GraphDef</code>, and you should not use this method if you need to serialize your model and restore it in a different environment.</span>
</blockquote>
<blockquote class="note">
<strong>Note:</strong><span> If <code translate="no" dir="ltr">generator</code> depends on mutable global variables or other external state, be aware that the runtime may invoke <code translate="no" dir="ltr">generator</code> multiple times (in order to support repeating the <code translate="no" dir="ltr">Dataset</code>) and at any time between the call to <a href="dataset#from_generator"><code translate="no" dir="ltr">Dataset.from_generator()</code></a> and the production of the first element from the generator. Mutating global variables or external state can cause undefined behavior, and we recommend that you explicitly cache any external state in <code translate="no" dir="ltr">generator</code> before calling <a href="dataset#from_generator"><code translate="no" dir="ltr">Dataset.from_generator()</code></a>.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">generator</code> </td> <td> A callable object that returns an object that supports the <code translate="no" dir="ltr">iter()</code> protocol. If <code translate="no" dir="ltr">args</code> is not specified, <code translate="no" dir="ltr">generator</code> must take no arguments; otherwise it must take as many arguments as there are values in <code translate="no" dir="ltr">args</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">output_types</code> </td> <td> A nested structure of <a href="../dtypes/dtype"><code translate="no" dir="ltr">tf.DType</code></a> objects corresponding to each component of an element yielded by <code translate="no" dir="ltr">generator</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">output_shapes</code> </td> <td> (Optional.) A nested structure of <a href="../tensorshape"><code translate="no" dir="ltr">tf.TensorShape</code></a> objects corresponding to each component of an element yielded by <code translate="no" dir="ltr">generator</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">args</code> </td> <td> (Optional.) A tuple of <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a> objects that will be evaluated and passed to <code translate="no" dir="ltr">generator</code> as NumPy-array arguments. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="from_sparse_tensor_slices" data-text="from_sparse_tensor_slices" tabindex="0"><code translate="no" dir="ltr">from_sparse_tensor_slices</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1824-L1835">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@staticmethod
from_sparse_tensor_slices(
    sparse_tensor
)
</pre> <p>Splits each rank-N <a href="../sparse/sparsetensor"><code translate="no" dir="ltr">tf.SparseTensor</code></a> in this dataset row-wise. (deprecated)</p> <aside class="warning"><strong>Warning:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <a href="dataset#from_tensor_slices"><code translate="no" dir="ltr">tf.data.Dataset.from_tensor_slices()</code></a>.</span></aside>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">sparse_tensor</code> </td> <td> A <a href="../sparse/sparsetensor"><code translate="no" dir="ltr">tf.SparseTensor</code></a>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code> of rank-(N-1) sparse tensors. </td> </tr> </table> <h3 id="from_tensor_slices" data-text="from_tensor_slices" tabindex="0"><code translate="no" dir="ltr">from_tensor_slices</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L425-L444">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@staticmethod
from_tensor_slices(
    tensors
)
</pre> <p>Creates a <code translate="no" dir="ltr">Dataset</code> whose elements are slices of the given tensors.</p> <p>Note that if <code translate="no" dir="ltr">tensors</code> contains a NumPy array, and eager execution is not enabled, the values will be embedded in the graph as one or more <a href="../constant"><code translate="no" dir="ltr">tf.constant</code></a> operations. For large datasets (&gt; 1 GB), this can waste memory and run into byte limits of graph serialization. If <code translate="no" dir="ltr">tensors</code> contains one or more large NumPy arrays, consider the alternative described in <a href="https://tensorflow.org/guide/datasets#consuming_numpy_arrays">this guide</a>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">tensors</code> </td> <td> A dataset element, with each component having the same size in the 0th dimension. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="from_tensors" data-text="from_tensors" tabindex="0"><code translate="no" dir="ltr">from_tensors</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L405-L423">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@staticmethod
from_tensors(
    tensors
)
</pre> <p>Creates a <code translate="no" dir="ltr">Dataset</code> with a single element, comprising the given tensors.</p> <p>Note that if <code translate="no" dir="ltr">tensors</code> contains a NumPy array, and eager execution is not enabled, the values will be embedded in the graph as one or more <a href="../constant"><code translate="no" dir="ltr">tf.constant</code></a> operations. For large datasets (&gt; 1 GB), this can waste memory and run into byte limits of graph serialization. If <code translate="no" dir="ltr">tensors</code> contains one or more large NumPy arrays, consider the alternative described in <a href="https://tensorflow.org/guide/datasets#consuming_numpy_arrays">this guide</a>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">tensors</code> </td> <td> A dataset element. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="interleave" data-text="interleave" tabindex="0"><code translate="no" dir="ltr">interleave</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1251-L1329">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
interleave(
    map_func, cycle_length=AUTOTUNE, block_length=1, num_parallel_calls=None
)
</pre> <p>Maps <code translate="no" dir="ltr">map_func</code> across this dataset, and interleaves the results.</p> <p>For example, you can use <a href="dataset#interleave"><code translate="no" dir="ltr">Dataset.interleave()</code></a> to process many input files concurrently:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># Preprocess 4 files concurrently, and interleave blocks of 16 records from
# each file.
filenames = ["/var/data/file1.txt", "/var/data/file2.txt", ...]
dataset = (Dataset.from_tensor_slices(filenames)
           .interleave(lambda x:
               TextLineDataset(x).map(parse_fn, num_parallel_calls=1),
               cycle_length=4, block_length=16))
</pre> <p>The <code translate="no" dir="ltr">cycle_length</code> and <code translate="no" dir="ltr">block_length</code> arguments control the order in which elements are produced. <code translate="no" dir="ltr">cycle_length</code> controls the number of input elements that are processed concurrently. If you set <code translate="no" dir="ltr">cycle_length</code> to 1, this transformation will handle one input element at a time, and will produce identical results to <a href="dataset#flat_map"><code translate="no" dir="ltr">tf.data.Dataset.flat_map</code></a>. In general, this transformation will apply <code translate="no" dir="ltr">map_func</code> to <code translate="no" dir="ltr">cycle_length</code> input elements, open iterators on the returned <code translate="no" dir="ltr">Dataset</code> objects, and cycle through them producing <code translate="no" dir="ltr">block_length</code> consecutive elements from each iterator, and consuming the next input element each time it reaches the end of an iterator.</p> <h4 id="for_example_4" data-text="For example:" tabindex="0">For example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">a = Dataset.range(1, 6)  # ==&gt; [ 1, 2, 3, 4, 5 ]

# NOTE: New lines indicate "block" boundaries.
a.interleave(lambda x: Dataset.from_tensors(x).repeat(6),
            cycle_length=2, block_length=4)  # ==&gt; [1, 1, 1, 1,
                                             #      2, 2, 2, 2,
                                             #      1, 1,
                                             #      2, 2,
                                             #      3, 3, 3, 3,
                                             #      4, 4, 4, 4,
                                             #      3, 3,
                                             #      4, 4,
                                             #      5, 5, 5, 5,
                                             #      5, 5]
</pre>
<blockquote class="note">
<strong>Note:</strong><span> The order of elements yielded by this transformation is deterministic, as long as <code translate="no" dir="ltr">map_func</code> is a pure function. If <code translate="no" dir="ltr">map_func</code> contains any stateful operations, the order in which that state is accessed is undefined.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">map_func</code> </td> <td> A function mapping a dataset element to a dataset. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">cycle_length</code> </td> <td> (Optional.) The number of input elements that will be processed concurrently. If not specified, the value will be derived from the number of available CPU cores. If the <code translate="no" dir="ltr">num_parallel_calls</code> argument is set to <a href="experimental#AUTOTUNE"><code translate="no" dir="ltr">tf.data.experimental.AUTOTUNE</code></a>, the <code translate="no" dir="ltr">cycle_length</code> argument also identifies the maximum degree of parallelism. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">block_length</code> </td> <td> (Optional.) The number of consecutive elements to produce from each input element before cycling to another input element. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">num_parallel_calls</code> </td> <td> (Optional.) If specified, the implementation creates a threadpool, which is used to fetch inputs from cycle elements asynchronously and in parallel. The default behavior is to fetch inputs from cycle elements synchronously with no parallelism. If the value <a href="experimental#AUTOTUNE"><code translate="no" dir="ltr">tf.data.experimental.AUTOTUNE</code></a> is used, then the number of parallel calls is set dynamically based on available CPU. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="list_files" data-text="list_files" tabindex="0"><code translate="no" dir="ltr">list_files</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L797-L855">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@staticmethod
list_files(
    file_pattern, shuffle=None, seed=None
)
</pre> <p>A dataset of all files matching one or more glob patterns.</p> <blockquote class="note">
<strong>Note:</strong><span> The default behavior of this method is to return filenames in a non-deterministic random shuffled order. Pass a <code translate="no" dir="ltr">seed</code> or <code translate="no" dir="ltr">shuffle=False</code> to get results in a deterministic order.</span>
</blockquote> <h4 id="example" data-text="Example:" tabindex="0">Example:</h4> <p>If we had the following files on our filesystem:</p> <ul> <li>/path/to/dir/a.txt</li> <li>/path/to/dir/b.py</li> <li>/path/to/dir/c.py If we pass "/path/to/dir/*.py" as the directory, the dataset would produce:</li> <li>/path/to/dir/b.py</li> <li>/path/to/dir/c.py</li> </ul>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">file_pattern</code> </td> <td> A string, a list of strings, or a <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a> of string type (scalar or vector), representing the filename glob (i.e. shell wildcard) pattern(s) that will be matched. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">shuffle</code> </td> <td> (Optional.) If <code translate="no" dir="ltr">True</code>, the file names will be shuffled randomly. Defaults to <code translate="no" dir="ltr">True</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">seed</code> </td> <td> (Optional.) A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the random seed that will be used to create the distribution. See <a href="../random/set_random_seed"><code translate="no" dir="ltr">tf.compat.v1.set_random_seed</code></a> for behavior. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code> of strings corresponding to file names. </td> </tr> </table> <h3 id="make_initializable_iterator" data-text="make_initializable_iterator" tabindex="0"><code translate="no" dir="ltr">make_initializable_iterator</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1713-L1743">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
make_initializable_iterator(
    shared_name=None
)
</pre> <p>Creates an <code translate="no" dir="ltr">Iterator</code> for enumerating the elements of this dataset. (deprecated)</p> <aside class="warning"><strong>Warning:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code translate="no" dir="ltr">for ... in dataset:</code> to iterate over a dataset. If using <code translate="no" dir="ltr">tf.estimator</code>, return the <code translate="no" dir="ltr">Dataset</code> object directly from your input function. As a last resort, you can use <code translate="no" dir="ltr">tf.compat.v1.data.make_initializable_iterator(dataset)</code>.</span></aside><blockquote class="note">
<strong>Note:</strong><span> The returned iterator will be in an uninitialized state, and you must run the <code translate="no" dir="ltr">iterator.initializer</code> operation before using it:</span>
</blockquote>
<pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">dataset = ...
iterator = dataset.make_initializable_iterator()
# ...
sess.run(iterator.initializer)
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">shared_name</code> </td> <td> (Optional.) If non-empty, the returned iterator will be shared under the given name across multiple sessions that share the same devices (e.g. when using a remote server). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An <code translate="no" dir="ltr">Iterator</code> over the elements of this dataset. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">RuntimeError</code> </td> <td> If eager execution is enabled. </td> </tr> </table> <h3 id="make_one_shot_iterator" data-text="make_one_shot_iterator" tabindex="0"><code translate="no" dir="ltr">make_one_shot_iterator</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1646-L1660">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
make_one_shot_iterator()
</pre> <p>Creates an <code translate="no" dir="ltr">Iterator</code> for enumerating the elements of this dataset. (deprecated)</p> <aside class="warning"><strong>Warning:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use <code translate="no" dir="ltr">for ... in dataset:</code> to iterate over a dataset. If using <code translate="no" dir="ltr">tf.estimator</code>, return the <code translate="no" dir="ltr">Dataset</code> object directly from your input function. As a last resort, you can use <code translate="no" dir="ltr">tf.compat.v1.data.make_one_shot_iterator(dataset)</code>.</span></aside><blockquote class="note">
<strong>Note:</strong><span> The returned iterator will be initialized automatically. A "one-shot" iterator does not currently support re-initialization.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An <code translate="no" dir="ltr">Iterator</code> over the elements of this dataset. </td> </tr> 
</table> <h3 id="map" data-text="map" tabindex="0"><code translate="no" dir="ltr">map</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1108-L1223">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
map(
    map_func, num_parallel_calls=None
)
</pre> <p>Maps <code translate="no" dir="ltr">map_func</code> across the elements of this dataset.</p> <p>This transformation applies <code translate="no" dir="ltr">map_func</code> to each element of this dataset, and returns a new dataset containing the transformed elements, in the same order as they appeared in the input.</p> <h4 id="for_example_5" data-text="For example:" tabindex="0">For example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">a = Dataset.range(1, 6)  # ==&gt; [ 1, 2, 3, 4, 5 ]

a.map(lambda x: x + 1)  # ==&gt; [ 2, 3, 4, 5, 6 ]
</pre> <p>The input signature of <code translate="no" dir="ltr">map_func</code> is determined by the structure of each element in this dataset. For example:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># NOTE: The following examples use `{ ... }` to represent the
# contents of a dataset.
# Each element is a `tf.Tensor` object.
a = { 1, 2, 3, 4, 5 }
# `map_func` takes a single argument of type `tf.Tensor` with the same
# shape and dtype.
result = a.map(lambda x: ...)

# Each element is a tuple containing two `tf.Tensor` objects.
b = { (1, "foo"), (2, "bar"), (3, "baz") }
# `map_func` takes two arguments of type `tf.Tensor`.
result = b.map(lambda x_int, y_str: ...)

# Each element is a dictionary mapping strings to `tf.Tensor` objects.
c = { {"a": 1, "b": "foo"}, {"a": 2, "b": "bar"}, {"a": 3, "b": "baz"} }
# `map_func` takes a single argument of type `dict` with the same keys as
# the elements.
result = c.map(lambda d: ...)
</pre> <p>The value or values returned by <code translate="no" dir="ltr">map_func</code> determine the structure of each element in the returned dataset.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># `map_func` returns a scalar `tf.Tensor` of type `tf.float32`.
def f(...):
  return tf.constant(37.0)
result = dataset.map(f)
result.output_classes == tf.Tensor
result.output_types == tf.float32
result.output_shapes == []  # scalar

# `map_func` returns two `tf.Tensor` objects.
def g(...):
  return tf.constant(37.0), tf.constant(["Foo", "Bar", "Baz"])
result = dataset.map(g)
result.output_classes == (tf.Tensor, tf.Tensor)
result.output_types == (tf.float32, tf.string)
result.output_shapes == ([], [3])

# Python primitives, lists, and NumPy arrays are implicitly converted to
# `tf.Tensor`.
def h(...):
  return 37.0, ["Foo", "Bar", "Baz"], np.array([1.0, 2.0] dtype=np.float64)
result = dataset.map(h)
result.output_classes == (tf.Tensor, tf.Tensor, tf.Tensor)
result.output_types == (tf.float32, tf.string, tf.float64)
result.output_shapes == ([], [3], [2])

# `map_func` can return nested structures.
def i(...):
  return {"a": 37.0, "b": [42, 16]}, "foo"
result.output_classes == ({"a": tf.Tensor, "b": tf.Tensor}, tf.Tensor)
result.output_types == ({"a": tf.float32, "b": tf.int32}, tf.string)
result.output_shapes == ({"a": [], "b": [2]}, [])
</pre> <p><code translate="no" dir="ltr">map_func</code> can accept as arguments and return any type of dataset element.</p> <p>Note that irrespective of the context in which <code translate="no" dir="ltr">map_func</code> is defined (eager vs. graph), tf.data traces the function and executes it as a graph. To use Python code inside of the function you have two options:</p> <p>1) Rely on AutoGraph to convert Python code into an equivalent graph computation. The downside of this approach is that AutoGraph can convert some but not all Python code.</p> <p>2) Use <a href="../py_function"><code translate="no" dir="ltr">tf.py_function</code></a>, which allows you to write arbitrary Python code but will generally result in worse performance than 1). For example:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">d = tf.data.Dataset.from_tensor_slices(['hello', 'world'])

# transform a string tensor to upper case string using a Python function
def upper_case_fn(t: tf.Tensor) -&gt; str:
    return t.numpy().decode('utf-8').upper()

d.map(lambda x: tf.py_function(func=upper_case_fn,
      inp=[x], Tout=tf.string))  # ==&gt; [ "HELLO", "WORLD" ]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">map_func</code> </td> <td> A function mapping a dataset element to another dataset element. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">num_parallel_calls</code> </td> <td> (Optional.) A <a href="../../tf#int32"><code translate="no" dir="ltr">tf.int32</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number elements to process asynchronously in parallel. If not specified, elements will be processed sequentially. If the value <a href="experimental#AUTOTUNE"><code translate="no" dir="ltr">tf.data.experimental.AUTOTUNE</code></a> is used, then the number of parallel calls is set dynamically based on available CPU. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="map_with_legacy_function" data-text="map_with_legacy_function" tabindex="0"><code translate="no" dir="ltr">map_with_legacy_function</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1915-L1950">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
map_with_legacy_function(
    map_func, num_parallel_calls=None
)
</pre> <p>Maps <code translate="no" dir="ltr">map_func</code> across the elements of this dataset. (deprecated)</p> <aside class="warning"><strong>Warning:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: Use `tf.data.Dataset.map()</span></aside><blockquote class="note">
<strong>Note:</strong><span> This is an escape hatch for existing uses of <code translate="no" dir="ltr">map</code> that do not work with V2 functions. New uses are strongly discouraged and existing uses should migrate to <code translate="no" dir="ltr">map</code> as this method will be removed in V2.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">map_func</code> </td> <td> A function mapping a nested structure of tensors (having shapes and types defined by <code translate="no" dir="ltr">self.output_shapes</code> and <code translate="no" dir="ltr">self.output_types</code>) to another nested structure of tensors. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">num_parallel_calls</code> </td> <td> (Optional.) A <a href="../../tf#int32"><code translate="no" dir="ltr">tf.int32</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number elements to process asynchronously in parallel. If not specified, elements will be processed sequentially. If the value <a href="experimental#AUTOTUNE"><code translate="no" dir="ltr">tf.data.experimental.AUTOTUNE</code></a> is used, then the number of parallel calls is set dynamically based on available CPU. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="options" data-text="options" tabindex="0"><code translate="no" dir="ltr">options</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L2026-L2027">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
options()
</pre> <p>Returns the options for this dataset and its inputs.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <a href="options"><code translate="no" dir="ltr">tf.data.Options</code></a> object representing the dataset options. </td> </tr> 
</table> <h3 id="padded_batch" data-text="padded_batch" tabindex="0"><code translate="no" dir="ltr">padded_batch</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1049-L1106">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
padded_batch(
    batch_size, padded_shapes, padding_values=None, drop_remainder=False
)
</pre> <p>Combines consecutive elements of this dataset into padded batches.</p> <p>This transformation combines multiple consecutive elements of the input dataset into a single element.</p> <p>Like <a href="dataset#batch"><code translate="no" dir="ltr">tf.data.Dataset.batch</code></a>, the components of the resulting element will have an additional outer dimension, which will be <code translate="no" dir="ltr">batch_size</code> (or <code translate="no" dir="ltr">N % batch_size</code> for the last element if <code translate="no" dir="ltr">batch_size</code> does not divide the number of input elements <code translate="no" dir="ltr">N</code> evenly and <code translate="no" dir="ltr">drop_remainder</code> is <code translate="no" dir="ltr">False</code>). If your program depends on the batches having the same outer dimension, you should set the <code translate="no" dir="ltr">drop_remainder</code> argument to <code translate="no" dir="ltr">True</code> to prevent the smaller batch from being produced.</p> <p>Unlike <a href="dataset#batch"><code translate="no" dir="ltr">tf.data.Dataset.batch</code></a>, the input elements to be batched may have different shapes, and this transformation will pad each component to the respective shape in <code translate="no" dir="ltr">padding_shapes</code>. The <code translate="no" dir="ltr">padding_shapes</code> argument determines the resulting shape for each dimension of each component in an output element:</p> <ul> <li>If the dimension is a constant (e.g. <a href="../dimension"><code translate="no" dir="ltr">tf.compat.v1.Dimension(37)</code></a>), the component will be padded out to that length in that dimension.</li> <li>If the dimension is unknown (e.g. <a href="../dimension"><code translate="no" dir="ltr">tf.compat.v1.Dimension(None)</code></a>), the component will be padded out to the maximum length of all elements in that dimension.</li> </ul> <p>See also <a href="experimental/dense_to_sparse_batch"><code translate="no" dir="ltr">tf.data.experimental.dense_to_sparse_batch</code></a>, which combines elements that may have different shapes into a <a href="../sparse/sparsetensor"><code translate="no" dir="ltr">tf.SparseTensor</code></a>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">batch_size</code> </td> <td> A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of consecutive elements of this dataset to combine in a single batch. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">padded_shapes</code> </td> <td> A nested structure of <a href="../tensorshape"><code translate="no" dir="ltr">tf.TensorShape</code></a> or <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> vector tensor-like objects representing the shape to which the respective component of each input element should be padded prior to batching. Any unknown dimensions (e.g. <a href="../dimension"><code translate="no" dir="ltr">tf.compat.v1.Dimension(None)</code></a> in a <a href="../tensorshape"><code translate="no" dir="ltr">tf.TensorShape</code></a> or <code translate="no" dir="ltr">-1</code> in a tensor-like object) will be padded to the maximum size of that dimension in each batch. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">padding_values</code> </td> <td> (Optional.) A nested structure of scalar-shaped <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the padding values to use for the respective components. Defaults are <code translate="no" dir="ltr">0</code> for numeric types and the empty string for string types. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">drop_remainder</code> </td> <td> (Optional.) A <a href="../../tf#bool"><code translate="no" dir="ltr">tf.bool</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing whether the last batch should be dropped in the case it has fewer than <code translate="no" dir="ltr">batch_size</code> elements; the default behavior is not to drop the smaller batch. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="prefetch" data-text="prefetch" tabindex="0"><code translate="no" dir="ltr">prefetch</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L779-L795">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
prefetch(
    buffer_size
)
</pre> <p>Creates a <code translate="no" dir="ltr">Dataset</code> that prefetches elements from this dataset.</p> <blockquote class="note">
<strong>Note:</strong><span> Like other <code translate="no" dir="ltr">Dataset</code> methods, prefetch operates on the elements of the input dataset. It has no concept of examples vs. batches. <code translate="no" dir="ltr">examples.prefetch(2)</code> will prefetch two elements (2 examples), while <code translate="no" dir="ltr">examples.batch(20).prefetch(2)</code> will prefetch 2 elements (2 batches, of 20 examples each).</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">buffer_size</code> </td> <td> A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the maximum number of elements that will be buffered when prefetching. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="range" data-text="range" tabindex="0"><code translate="no" dir="ltr">range</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L687-L714">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@staticmethod
range(
    *args
)
</pre> <p>Creates a <code translate="no" dir="ltr">Dataset</code> of a step-separated range of values.</p> <h4 id="for_example_6" data-text="For example:" tabindex="0">For example:</h4> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">Dataset.range(5) == [0, 1, 2, 3, 4]
Dataset.range(2, 5) == [2, 3, 4]
Dataset.range(1, 5, 2) == [1, 3]
Dataset.range(1, 5, -2) == []
Dataset.range(5, 1) == []
Dataset.range(5, 1, -2) == [5, 3]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">*args</code> </td> <td> follows the same semantics as python's xrange. len(args) == 1 -&gt; start = 0, stop = args[0], step = 1 len(args) == 2 -&gt; start = args[0], stop = args[1], step = 1 len(args) == 3 -&gt; start = args[0], stop = args[1, stop = args[2] </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">RangeDataset</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> if len(args) == 0. </td> </tr> </table> <h3 id="reduce" data-text="reduce" tabindex="0"><code translate="no" dir="ltr">reduce</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1436-L1546">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
reduce(
    initial_state, reduce_func
)
</pre> <p>Reduces the input dataset to a single element.</p> <p>The transformation calls <code translate="no" dir="ltr">reduce_func</code> successively on every element of the input dataset until the dataset is exhausted, aggregating information in its internal state. The <code translate="no" dir="ltr">initial_state</code> argument is used for the initial state and the final state is returned as the result.</p> <h4 id="for_example_7" data-text="For example:" tabindex="0">For example:</h4> <ul> <li>
<code translate="no" dir="ltr">tf.data.Dataset.range(5).reduce(np.int64(0), lambda x, _: x + 1)</code> produces <code translate="no" dir="ltr">5</code>
</li> <li>
<code translate="no" dir="ltr">tf.data.Dataset.range(5).reduce(np.int64(0), lambda x, y: x + y)</code> produces <code translate="no" dir="ltr">10</code>
</li> </ul>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">initial_state</code> </td> <td> An element representing the initial state of the transformation. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">reduce_func</code> </td> <td> A function that maps <code translate="no" dir="ltr">(old_state, input_element)</code> to <code translate="no" dir="ltr">new_state</code>. It must take two arguments and return a new element The structure of <code translate="no" dir="ltr">new_state</code> must match the structure of <code translate="no" dir="ltr">initial_state</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A dataset element corresponding to the final state of the transformation. </td> </tr> 
</table> <h3 id="repeat" data-text="repeat" tabindex="0"><code translate="no" dir="ltr">repeat</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L857-L871">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
repeat(
    count=None
)
</pre> <p>Repeats this dataset <code translate="no" dir="ltr">count</code> times.</p> <blockquote class="note">
<strong>Note:</strong><span> If this dataset is a function of global state (e.g. a random number generator), then different repetitions may produce different elements.</span>
</blockquote>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">count</code> </td> <td> (Optional.) A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of times the dataset should be repeated. The default behavior (if <code translate="no" dir="ltr">count</code> is <code translate="no" dir="ltr">None</code> or <code translate="no" dir="ltr">-1</code>) is for the dataset be repeated indefinitely. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="shard" data-text="shard" tabindex="0"><code translate="no" dir="ltr">shard</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L973-L1024">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
shard(
    num_shards, index
)
</pre> <p>Creates a <code translate="no" dir="ltr">Dataset</code> that includes only 1/<code translate="no" dir="ltr">num_shards</code> of this dataset.</p> <p>This dataset operator is very useful when running distributed training, as it allows each worker to read a unique subset.</p> <p>When reading a single input file, you can skip elements as follows:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">d = tf.data.TFRecordDataset(input_file)
d = d.shard(num_workers, worker_index)
d = d.repeat(num_epochs)
d = d.shuffle(shuffle_buffer_size)
d = d.map(parser_fn, num_parallel_calls=num_map_threads)
</pre> <h4 id="important_caveats" data-text="Important caveats:" tabindex="0">Important caveats:</h4> <ul> <li>Be sure to shard before you use any randomizing operator (such as shuffle).</li> <li>Generally it is best if the shard operator is used early in the dataset pipeline. For example, when reading from a set of TFRecord files, shard before converting the dataset to input samples. This avoids reading every file on every worker. The following is an example of an efficient sharding strategy within a complete pipeline:</li> </ul> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">d = Dataset.list_files(pattern)
d = d.shard(num_workers, worker_index)
d = d.repeat(num_epochs)
d = d.shuffle(shuffle_buffer_size)
d = d.interleave(tf.data.TFRecordDataset,
                 cycle_length=num_readers, block_length=1)
d = d.map(parser_fn, num_parallel_calls=num_map_threads)
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">num_shards</code> </td> <td> A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of shards operating in parallel. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">index</code> </td> <td> A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the worker index. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">InvalidArgumentError</code> </td> <td> if <code translate="no" dir="ltr">num_shards</code> or <code translate="no" dir="ltr">index</code> are illegal values. Note: error checking is done on a best-effort basis, and errors aren't guaranteed to be caught upon dataset creation. (e.g. providing in a placeholder tensor bypasses the early checking, and will instead result in an error during a session.run call.) </td> </tr> </table> <h3 id="shuffle" data-text="shuffle" tabindex="0"><code translate="no" dir="ltr">shuffle</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L903-L930">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
shuffle(
    buffer_size, seed=None, reshuffle_each_iteration=None
)
</pre> <p>Randomly shuffles the elements of this dataset.</p> <p>This dataset fills a buffer with <code translate="no" dir="ltr">buffer_size</code> elements, then randomly samples elements from this buffer, replacing the selected elements with new elements. For perfect shuffling, a buffer size greater than or equal to the full size of the dataset is required.</p> <p>For instance, if your dataset contains 10,000 elements but <code translate="no" dir="ltr">buffer_size</code> is set to 1,000, then <code translate="no" dir="ltr">shuffle</code> will initially select a random element from only the first 1,000 elements in the buffer. Once an element is selected, its space in the buffer is replaced by the next (i.e. 1,001-st) element, maintaining the 1,000 element buffer.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">buffer_size</code> </td> <td> A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of elements from this dataset from which the new dataset will sample. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">seed</code> </td> <td> (Optional.) A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the random seed that will be used to create the distribution. See <a href="../random/set_random_seed"><code translate="no" dir="ltr">tf.compat.v1.set_random_seed</code></a> for behavior. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">reshuffle_each_iteration</code> </td> <td> (Optional.) A boolean, which if true indicates that the dataset should be pseudorandomly reshuffled each time it is iterated over. (Defaults to <code translate="no" dir="ltr">True</code>.) </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="skip" data-text="skip" tabindex="0"><code translate="no" dir="ltr">skip</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L959-L971">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
skip(
    count
)
</pre> <p>Creates a <code translate="no" dir="ltr">Dataset</code> that skips <code translate="no" dir="ltr">count</code> elements from this dataset.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">count</code> </td> <td> A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of elements of this dataset that should be skipped to form the new dataset. If <code translate="no" dir="ltr">count</code> is greater than the size of this dataset, the new dataset will contain no elements. If <code translate="no" dir="ltr">count</code> is -1, skips the entire dataset. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="take" data-text="take" tabindex="0"><code translate="no" dir="ltr">take</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L945-L957">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
take(
    count
)
</pre> <p>Creates a <code translate="no" dir="ltr">Dataset</code> with at most <code translate="no" dir="ltr">count</code> elements from this dataset.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">count</code> </td> <td> A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of elements of this dataset that should be taken to form the new dataset. If <code translate="no" dir="ltr">count</code> is -1, or if <code translate="no" dir="ltr">count</code> is greater than the size of this dataset, the new dataset will contain all elements of this dataset. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="unbatch" data-text="unbatch" tabindex="0"><code translate="no" dir="ltr">unbatch</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1548-L1590">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
unbatch()
</pre> <p>Splits elements of a dataset into multiple elements.</p> <p>For example, if elements of the dataset are shaped <code translate="no" dir="ltr">[B, a0, a1, ...]</code>, where <code translate="no" dir="ltr">B</code> may vary for each input element, then for each element in the dataset, the unbatched dataset will contain <code translate="no" dir="ltr">B</code> consecutive elements of shape <code translate="no" dir="ltr">[a0, a1, ...]</code>.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># NOTE: The following example uses `{ ... }` to represent the contents
# of a dataset.
ds = { ['a', 'b', 'c'], ['a', 'b'], ['a', 'b', 'c', 'd'] }

ds.unbatch() == {'a', 'b', 'c', 'a', 'b', 'a', 'b', 'c', 'd'}
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Dataset</code> transformation function, which can be passed to <a href="dataset#apply"><code translate="no" dir="ltr">tf.data.Dataset.apply</code></a>. </td> </tr> 
</table> <h3 id="window" data-text="window" tabindex="0"><code translate="no" dir="ltr">window</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1386-L1434">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
window(
    size, shift=None, stride=1, drop_remainder=False
)
</pre> <p>Combines (nests of) input elements into a dataset of (nests of) windows.</p> <p>A "window" is a finite dataset of flat elements of size <code translate="no" dir="ltr">size</code> (or possibly fewer if there are not enough input elements to fill the window and <code translate="no" dir="ltr">drop_remainder</code> evaluates to false).</p> <p>The <code translate="no" dir="ltr">stride</code> argument determines the stride of the input elements, and the <code translate="no" dir="ltr">shift</code> argument determines the shift of the window.</p> <p>For example, letting {...} to represent a Dataset:</p> <ul> <li>
<code translate="no" dir="ltr">tf.data.Dataset.range(7).window(2)</code> produces <code translate="no" dir="ltr">{ {0, 1}, {2, 3}, {4, 5}, {6} }</code>
</li> <li>
<code translate="no" dir="ltr">tf.data.Dataset.range(7).window(3, 2, 1, True)</code> produces <code translate="no" dir="ltr">{ {0, 1, 2}, {2, 3, 4}, {4, 5, 6} }</code>
</li> <li>
<code translate="no" dir="ltr">tf.data.Dataset.range(7).window(3, 1, 2, True)</code> produces <code translate="no" dir="ltr">{ {0, 2, 4}, {1, 3, 5}, {2, 4, 6} }</code>
</li> </ul> <p>Note that when the <code translate="no" dir="ltr">window</code> transformation is applied to a dataset of nested elements, it produces a dataset of nested windows.</p> <h4 id="for_example_8" data-text="For example:" tabindex="0">For example:</h4> <ul> <li>
<code translate="no" dir="ltr">tf.data.Dataset.from_tensor_slices((range(4), range(4))).window(2)</code> produces <code translate="no" dir="ltr">{({0, 1}, {0, 1}), ({2, 3}, {2, 3})}</code>
</li> <li>
<code translate="no" dir="ltr">tf.data.Dataset.from_tensor_slices({"a": range(4)}).window(2)</code> produces <code translate="no" dir="ltr">{ {"a": {0, 1} }, {"a": {2, 3} } }</code>
</li> </ul>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">size</code> </td> <td> A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the number of elements of the input dataset to combine into a window. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">shift</code> </td> <td> (Optional.) A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the forward shift of the sliding window in each iteration. Defaults to <code translate="no" dir="ltr">size</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">stride</code> </td> <td> (Optional.) A <a href="../../tf#int64"><code translate="no" dir="ltr">tf.int64</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing the stride of the input elements in the sliding window. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">drop_remainder</code> </td> <td> (Optional.) A <a href="../../tf#bool"><code translate="no" dir="ltr">tf.bool</code></a> scalar <a href="../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a>, representing whether a window should be dropped in case its size is smaller than <code translate="no" dir="ltr">window_size</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code> of (nests of) windows -- a finite datasets of flat elements created from the (nests of) input elements. </td> </tr> </table> <h3 id="with_options" data-text="with_options" tabindex="0"><code translate="no" dir="ltr">with_options</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L1592-L1608">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
with_options(
    options
)
</pre> <p>Returns a new <a href="dataset"><code translate="no" dir="ltr">tf.data.Dataset</code></a> with the given options set.</p> <p>The options are "global" in the sense they apply to the entire dataset. If options are set multiple times, they are merged as long as different options do not use different non-default values.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">options</code> </td> <td> A <a href="options"><code translate="no" dir="ltr">tf.data.Options</code></a> that identifies the options the use. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code> with the given options. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> when an option is set more than once to a non-default value </td> </tr> </table> <h3 id="zip" data-text="zip" tabindex="0"><code translate="no" dir="ltr">zip</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L716-L753">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
@staticmethod
zip(
    datasets
)
</pre> <p>Creates a <code translate="no" dir="ltr">Dataset</code> by zipping together the given datasets.</p> <p>This method has similar semantics to the built-in <code translate="no" dir="ltr">zip()</code> function in Python, with the main difference being that the <code translate="no" dir="ltr">datasets</code> argument can be an arbitrary nested structure of <code translate="no" dir="ltr">Dataset</code> objects. For example:</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">a = Dataset.range(1, 4)  # ==&gt; [ 1, 2, 3 ]
b = Dataset.range(4, 7)  # ==&gt; [ 4, 5, 6 ]
c = Dataset.range(7, 13).batch(2)  # ==&gt; [ [7, 8], [9, 10], [11, 12] ]
d = Dataset.range(13, 15)  # ==&gt; [ 13, 14 ]

# The nested structure of the `datasets` argument determines the
# structure of elements in the resulting dataset.
Dataset.zip((a, b))  # ==&gt; [ (1, 4), (2, 5), (3, 6) ]
Dataset.zip((b, a))  # ==&gt; [ (4, 1), (5, 2), (6, 3) ]

# The `datasets` argument may contain an arbitrary number of
# datasets.
Dataset.zip((a, b, c))  # ==&gt; [ (1, 4, [7, 8]),
                        #       (2, 5, [9, 10]),
                        #       (3, 6, [11, 12]) ]

# The number of elements in the resulting dataset is the same as
# the size of the smallest dataset in `datasets`.
Dataset.zip((a, d))  # ==&gt; [ (1, 13), (2, 14) ]
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">datasets</code> </td> <td> A nested structure of datasets. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> 
<tr> <td> <code translate="no" dir="ltr">Dataset</code> </td> <td> A <code translate="no" dir="ltr">Dataset</code>. </td> </tr> </table> <h3 id="__iter__" data-text="__iter__" tabindex="0"><code translate="no" dir="ltr">__iter__</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v1.15.0/tensorflow/python/data/ops/dataset_ops.py#L2033-L2034">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
__iter__()
</pre> <p>Creates an <code translate="no" dir="ltr">Iterator</code> for enumerating the elements of this dataset.</p> <p>The returned iterator implements the Python iterator protocol and therefore can only be used in eager mode.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> An <code translate="no" dir="ltr">Iterator</code> over the elements of this dataset. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">RuntimeError</code> </td> <td> If not inside of tf.function and not executing eagerly. </td> </tr> </table>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    © 2020 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r1.15/api_docs/python/tf/data/FixedLengthRecordDataset" class="_attribution-link">https://www.tensorflow.org/versions/r1.15/api_docs/python/tf/data/FixedLengthRecordDataset</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
