
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Filters - Scikit-image - W3cubDocs</title>
  
  <meta name="description" content=" Apply the filter in reverse to the given data. ">
  <meta name="keywords" content="module, filters, scikit-image, scikit_image">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/scikit_image/api/skimage.filters.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/scikit_image.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_image/" class="_nav-link" title="" style="margin-left:0;">scikit-image</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="module-filters">Module: filters</h1> <table class="longtable docutils" id="module-skimage.filters">   <tr>
<td>
<a class="reference internal" href="#skimage.filters.inverse" title="skimage.filters.inverse"><code>skimage.filters.inverse</code></a>(data[, …])</td> <td>Apply the filter in reverse to the given data.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.wiener" title="skimage.filters.wiener"><code>skimage.filters.wiener</code></a>(data[, …])</td> <td>Minimum Mean Square Error (Wiener) inverse filter.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.gaussian" title="skimage.filters.gaussian"><code>skimage.filters.gaussian</code></a>(image[, sigma, …])</td> <td>Multi-dimensional Gaussian filter.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.median" title="skimage.filters.median"><code>skimage.filters.median</code></a>(image[, selem, out, …])</td> <td>Return local median of an image.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.sobel" title="skimage.filters.sobel"><code>skimage.filters.sobel</code></a>(image[, mask])</td> <td>Find the edge magnitude using the Sobel transform.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.sobel_h" title="skimage.filters.sobel_h"><code>skimage.filters.sobel_h</code></a>(image[, mask])</td> <td>Find the horizontal edges of an image using the Sobel transform.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.sobel_v" title="skimage.filters.sobel_v"><code>skimage.filters.sobel_v</code></a>(image[, mask])</td> <td>Find the vertical edges of an image using the Sobel transform.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><code>skimage.filters.scharr</code></a>(image[, mask])</td> <td>Find the edge magnitude using the Scharr transform.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.scharr_h" title="skimage.filters.scharr_h"><code>skimage.filters.scharr_h</code></a>(image[, mask])</td> <td>Find the horizontal edges of an image using the Scharr transform.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.scharr_v" title="skimage.filters.scharr_v"><code>skimage.filters.scharr_v</code></a>(image[, mask])</td> <td>Find the vertical edges of an image using the Scharr transform.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.prewitt" title="skimage.filters.prewitt"><code>skimage.filters.prewitt</code></a>(image[, mask])</td> <td>Find the edge magnitude using the Prewitt transform.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.prewitt_h" title="skimage.filters.prewitt_h"><code>skimage.filters.prewitt_h</code></a>(image[, mask])</td> <td>Find the horizontal edges of an image using the Prewitt transform.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.prewitt_v" title="skimage.filters.prewitt_v"><code>skimage.filters.prewitt_v</code></a>(image[, mask])</td> <td>Find the vertical edges of an image using the Prewitt transform.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.roberts" title="skimage.filters.roberts"><code>skimage.filters.roberts</code></a>(image[, mask])</td> <td>Find the edge magnitude using Roberts’ cross operator.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.roberts_pos_diag" title="skimage.filters.roberts_pos_diag"><code>skimage.filters.roberts_pos_diag</code></a>(image[, mask])</td> <td>Find the cross edges of an image using Roberts’ cross operator.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.roberts_neg_diag" title="skimage.filters.roberts_neg_diag"><code>skimage.filters.roberts_neg_diag</code></a>(image[, mask])</td> <td>Find the cross edges of an image using the Roberts’ Cross operator.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.laplace" title="skimage.filters.laplace"><code>skimage.filters.laplace</code></a>(image[, ksize, mask])</td> <td>Find the edges of an image using the Laplace operator.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.rank_order" title="skimage.filters.rank_order"><code>skimage.filters.rank_order</code></a>(image)</td> <td>Return an image of the same shape where each pixel is the index of the pixel value in the ascending order of the unique values of <code>image</code>, aka the rank-order value.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.gabor_kernel" title="skimage.filters.gabor_kernel"><code>skimage.filters.gabor_kernel</code></a>(frequency[, …])</td> <td>Return complex 2D Gabor filter kernel.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.gabor" title="skimage.filters.gabor"><code>skimage.filters.gabor</code></a>(image, frequency[, …])</td> <td>Return real and imaginary responses to Gabor filter.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.try_all_threshold" title="skimage.filters.try_all_threshold"><code>skimage.filters.try_all_threshold</code></a>(image[, …])</td> <td>Returns a figure comparing the outputs of different thresholding methods.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.frangi" title="skimage.filters.frangi"><code>skimage.filters.frangi</code></a>(image[, scale_range, …])</td> <td>Filter an image with the Frangi filter.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.hessian" title="skimage.filters.hessian"><code>skimage.filters.hessian</code></a>(image[, …])</td> <td>Filter an image with the Hessian filter.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.threshold_adaptive" title="skimage.filters.threshold_adaptive"><code>skimage.filters.threshold_adaptive</code></a>(image, …)</td> <td>
<strong>Deprecated function</strong>.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.threshold_otsu" title="skimage.filters.threshold_otsu"><code>skimage.filters.threshold_otsu</code></a>(image[, nbins])</td> <td>Return threshold value based on Otsu’s method.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.threshold_yen" title="skimage.filters.threshold_yen"><code>skimage.filters.threshold_yen</code></a>(image[, nbins])</td> <td>Return threshold value based on Yen’s method.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.threshold_isodata" title="skimage.filters.threshold_isodata"><code>skimage.filters.threshold_isodata</code></a>(image[, …])</td> <td>Return threshold value(s) based on ISODATA method.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.threshold_li" title="skimage.filters.threshold_li"><code>skimage.filters.threshold_li</code></a>(image)</td> <td>Compute threshold value by Li’s iterative Minimum Cross Entropy method.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.threshold_local" title="skimage.filters.threshold_local"><code>skimage.filters.threshold_local</code></a>(image, …)</td> <td>Compute a threshold mask image based on local pixel neighborhood.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.threshold_minimum" title="skimage.filters.threshold_minimum"><code>skimage.filters.threshold_minimum</code></a>(image[, …])</td> <td>Return threshold value based on minimum method.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.threshold_mean" title="skimage.filters.threshold_mean"><code>skimage.filters.threshold_mean</code></a>(image)</td> <td>Return threshold value based on the mean of grayscale values.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.threshold_niblack" title="skimage.filters.threshold_niblack"><code>skimage.filters.threshold_niblack</code></a>(image[, …])</td> <td>Applies Niblack local threshold to an array.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.threshold_sauvola" title="skimage.filters.threshold_sauvola"><code>skimage.filters.threshold_sauvola</code></a>(image[, …])</td> <td>Applies Sauvola local threshold to an array.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.threshold_triangle" title="skimage.filters.threshold_triangle"><code>skimage.filters.threshold_triangle</code></a>(image[, …])</td> <td>Return threshold value based on the triangle algorithm.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.apply_hysteresis_threshold" title="skimage.filters.apply_hysteresis_threshold"><code>skimage.filters.apply_hysteresis_threshold</code></a>(…)</td> <td>Apply hysteresis thresholding to <code>image</code>.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.filters.LPIFilter2D" title="skimage.filters.LPIFilter2D"><code>skimage.filters.LPIFilter2D</code></a>(…)</td> <td>Linear Position-Invariant Filter (2-dimensional)</td> </tr> <tr>
<td><a class="reference internal" href="skimage.filters.rank#module-skimage.filters.rank" title="skimage.filters.rank"><code>skimage.filters.rank</code></a></td> <td></td> </tr>  </table>  <h2 id="inverse">inverse</h2> <dl class="function"> <dt id="skimage.filters.inverse">
<code>skimage.filters.inverse(data, impulse_response=None, filter_params={}, max_gain=2, predefined_filter=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/lpi_filter.py#L167"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the filter in reverse to the given data.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>data : (M,N) ndarray</code> </dt> <dd>
<p class="first last">Input data.</p> </dd> <dt>
<code>impulse_response : callable f(r, c, **filter_params)</code> </dt> <dd>
<p class="first last">Impulse response of the filter. See LPIFilter2D.__init__.</p> </dd> <dt>
<code>filter_params : dict</code> </dt> <dd>
<p class="first last">Additional keyword parameters to the impulse_response function.</p> </dd> <dt>
<code>max_gain : float</code> </dt> <dd>
<p class="first last">Limit the filter gain. Often, the filter contains zeros, which would cause the inverse filter to have infinite gain. High gain causes amplification of artefacts, so a conservative limit is recommended.</p> </dd> </dl> </td> </tr> <tr><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr>
<td> </td>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>predefined_filter : LPIFilter2D</code> </dt> <dd>
<p class="first last">If you need to apply the same filter multiple times over different images, construct the LPIFilter2D and specify it here.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl>   <h2 id="wiener">wiener</h2> <dl class="function"> <dt id="skimage.filters.wiener">
<code>skimage.filters.wiener(data, impulse_response=None, filter_params={}, K=0.25, predefined_filter=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/lpi_filter.py#L207"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Minimum Mean Square Error (Wiener) inverse filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>data : (M,N) ndarray</code> </dt> <dd>
<p class="first last">Input data.</p> </dd> <dt>
<code>K : float or (M,N) ndarray</code> </dt> <dd>
<p class="first last">Ratio between power spectrum of noise and undegraded image.</p> </dd> <dt>
<code>impulse_response : callable f(r, c, **filter_params)</code> </dt> <dd>
<p class="first last">Impulse response of the filter. See LPIFilter2D.__init__.</p> </dd> <dt>
<code>filter_params : dict</code> </dt> <dd>
<p class="first last">Additional keyword parameters to the impulse_response function.</p> </dd> </dl> </td> </tr> <tr><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr>
<td> </td>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>predefined_filter : LPIFilter2D</code> </dt> <dd>
<p class="first last">If you need to apply the same filter multiple times over different images, construct the LPIFilter2D and specify it here.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl>   <h2 id="gaussian">gaussian</h2> <dl class="function"> <dt id="skimage.filters.gaussian">
<code>skimage.filters.gaussian(image, sigma=1, output=None, mode='nearest', cval=0, multichannel=None, preserve_range=False, truncate=4.0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/_gaussian.py#L21"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Multi-dimensional Gaussian filter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : array-like</code> </dt> <dd>
<p class="first last">Input image (grayscale or color) to filter.</p> </dd> <dt>
<code>sigma : scalar or sequence of scalars, optional</code> </dt> <dd>
<p class="first last">Standard deviation for Gaussian kernel. The standard deviations of the Gaussian filter are given for each axis as a sequence, or as a single number, in which case it is equal for all axes.</p> </dd> <dt>
<code>output : array, optional</code> </dt> <dd>
<p class="first last">The <code>output</code> parameter passes an array in which to store the filter output.</p> </dd> <dt>
<code>mode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional</code> </dt> <dd>
<p class="first last">The <code>mode</code> parameter determines how the array borders are handled, where <code>cval</code> is the value when mode is equal to ‘constant’. Default is ‘nearest’.</p> </dd> <dt>
<code>cval : scalar, optional</code> </dt> <dd>
<p class="first last">Value to fill past edges of input if <code>mode</code> is ‘constant’. Default is 0.0</p> </dd> <dt>
<code>multichannel : bool, optional (default: None)</code> </dt> <dd>
<p class="first last">Whether the last axis of the image is to be interpreted as multiple channels. If True, each channel is filtered separately (channels are not mixed together). Only 3 channels are supported. If <code>None</code>, the function will attempt to guess this, and raise a warning if ambiguous, when the array has shape (M, N, 3).</p> </dd> <dt>
<code>preserve_range : bool, optional</code> </dt> <dd>
<p class="first last">Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>.</p> </dd> <dt>
<code>truncate : float, optional</code> </dt> <dd>
<p class="first last">Truncate the filter at this many standard deviations.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>filtered_image : ndarray</code> </dt> <dd>
<p class="first last">the filtered array</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>This function is a wrapper around <code>scipy.ndi.gaussian_filter()</code>.</p> <p>Integer arrays are converted to float.</p> <p>The multi-dimensional filter is implemented as a sequence of one-dimensional convolution filters. The intermediate arrays are stored in the same data type as the output. Therefore, for output types with a limited precision, the results may be imprecise because intermediate results may be stored with insufficient precision.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.zeros((3, 3))
&gt;&gt;&gt; a[1, 1] = 1
&gt;&gt;&gt; a
array([[ 0.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  0.]])
&gt;&gt;&gt; gaussian(a, sigma=0.4)  # mild smoothing
array([[ 0.00163116,  0.03712502,  0.00163116],
       [ 0.03712502,  0.84496158,  0.03712502],
       [ 0.00163116,  0.03712502,  0.00163116]])
&gt;&gt;&gt; gaussian(a, sigma=1)  # more smoothing
array([[ 0.05855018,  0.09653293,  0.05855018],
       [ 0.09653293,  0.15915589,  0.09653293],
       [ 0.05855018,  0.09653293,  0.05855018]])
&gt;&gt;&gt; # Several modes are possible for handling boundaries
&gt;&gt;&gt; gaussian(a, sigma=1, mode='reflect')
array([[ 0.08767308,  0.12075024,  0.08767308],
       [ 0.12075024,  0.16630671,  0.12075024],
       [ 0.08767308,  0.12075024,  0.08767308]])
&gt;&gt;&gt; # For RGB images, each is filtered separately
&gt;&gt;&gt; from skimage.data import astronaut
&gt;&gt;&gt; image = astronaut()
&gt;&gt;&gt; filtered_img = gaussian(image, sigma=1, multichannel=True)
</pre> </dd>
</dl>   <h2 id="median">median</h2> <dl class="function"> <dt id="skimage.filters.median">
<code>skimage.filters.median(image, selem=None, out=None, mask=None, shift_x=False, shift_y=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/rank/generic.py#L147"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return local median of an image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array (uint8, uint16)</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>selem : 2-D array, optional</code> </dt> <dd>
<p class="first last">The neighborhood expressed as a 2-D array of 1’s and 0’s. If None, a full square of size 3 is used.</p> </dd> <dt>
<code>out : 2-D array (same dtype as input)</code> </dt> <dd>
<p class="first last">If None, a new array is allocated.</p> </dd> <dt>
<code>mask : ndarray</code> </dt> <dd>
<p class="first last">Mask array that defines (&gt;0) area of the image included in the local neighborhood. If None, the complete image is used (default).</p> </dd> <dt>
<code>shift_x, shift_y : int</code> </dt> <dd>
<p class="first last">Offset added to the structuring element center point. Shift is bounded to the structuring element sizes (center must be inside the given structuring element).</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>out : 2-D array (same dtype as input image)</code> </dt> <dd>
<p class="first last">Output image.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage.morphology import disk
&gt;&gt;&gt; from skimage.filters.rank import median
&gt;&gt;&gt; img = data.camera()
&gt;&gt;&gt; med = median(img, disk(5))
</pre> </dd>
</dl>   <h2 id="sobel">sobel</h2> <dl class="function"> <dt id="skimage.filters.sobel">
<code>skimage.filters.sobel(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/edges.py#L59"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edge magnitude using the Sobel transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array</code> </dt> <dd>
<p class="first last">Image to process.</p> </dd> <dt>
<code>mask : 2-D array, optional</code> </dt> <dd>
<p class="first last">An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>output : 2-D array</code> </dt> <dd>
<p class="first last">The Sobel edge map.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><code>scharr</code></a>, <a class="reference internal" href="#skimage.filters.prewitt" title="skimage.filters.prewitt"><code>prewitt</code></a>, <a class="reference internal" href="#skimage.filters.roberts" title="skimage.filters.roberts"><code>roberts</code></a>, <code>feature.canny</code></p> </div> <h4 class="rubric">Notes</h4> <p>Take the square root of the sum of the squares of the horizontal and vertical Sobels to get a magnitude that’s somewhat insensitive to direction.</p> <p>The 3x3 convolution kernel used in the horizontal and vertical Sobels is an approximation of the gradient of the image (with some slight blurring since 9 pixels are used to compute the gradient at a given pixel). As an approximation of the gradient, the Sobel operator is not completely rotation-invariant. The Scharr operator should be used for a better rotation invariance.</p> <p>Note that <code>scipy.ndimage.sobel</code> returns a directional Sobel which has to be further processed to perform edge detection.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; camera = data.camera()
&gt;&gt;&gt; from skimage import filters
&gt;&gt;&gt; edges = filters.sobel(camera)
</pre> </dd>
</dl>   <h2 id="sobel-h">sobel_h</h2> <dl class="function"> <dt id="skimage.filters.sobel_h">
<code>skimage.filters.sobel_h(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/edges.py#L109"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the horizontal edges of an image using the Sobel transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array</code> </dt> <dd>
<p class="first last">Image to process.</p> </dd> <dt>
<code>mask : 2-D array, optional</code> </dt> <dd>
<p class="first last">An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>output : 2-D array</code> </dt> <dd>
<p class="first last">The Sobel edge map.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 1   2   1
 0   0   0
-1  -2  -1
</pre> </dd>
</dl>   <h2 id="sobel-v">sobel_v</h2> <dl class="function"> <dt id="skimage.filters.sobel_v">
<code>skimage.filters.sobel_v(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/edges.py#L141"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the vertical edges of an image using the Sobel transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array</code> </dt> <dd>
<p class="first last">Image to process.</p> </dd> <dt>
<code>mask : 2-D array, optional</code> </dt> <dd>
<p class="first last">An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>output : 2-D array</code> </dt> <dd>
<p class="first last">The Sobel edge map.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python">1   0  -1
2   0  -2
1   0  -1
</pre> </dd>
</dl>   <h2 id="scharr">scharr</h2> <dl class="function"> <dt id="skimage.filters.scharr">
<code>skimage.filters.scharr(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/edges.py#L173"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edge magnitude using the Scharr transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array</code> </dt> <dd>
<p class="first last">Image to process.</p> </dd> <dt>
<code>mask : 2-D array, optional</code> </dt> <dd>
<p class="first last">An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>output : 2-D array</code> </dt> <dd>
<p class="first last">The Scharr edge map.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.filters.sobel" title="skimage.filters.sobel"><code>sobel</code></a>, <a class="reference internal" href="#skimage.filters.prewitt" title="skimage.filters.prewitt"><code>prewitt</code></a>, <code>canny</code></p> </div> <h4 class="rubric">Notes</h4> <p>Take the square root of the sum of the squares of the horizontal and vertical Scharrs to get a magnitude that is somewhat insensitive to direction. The Scharr operator has a better rotation invariance than other edge filters such as the Sobel or the Prewitt operators.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r6247f1470247-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id1">[1]</a></td>
<td>D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of Kernel Based Image Derivatives.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r6247f1470247-2" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id2">[2]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators">http://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; camera = data.camera()
&gt;&gt;&gt; from skimage import filters
&gt;&gt;&gt; edges = filters.scharr(camera)
</pre> </dd>
</dl>   <h2 id="scharr-h">scharr_h</h2> <dl class="function"> <dt id="skimage.filters.scharr_h">
<code>skimage.filters.scharr_h(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/edges.py#L220"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the horizontal edges of an image using the Scharr transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array</code> </dt> <dd>
<p class="first last">Image to process.</p> </dd> <dt>
<code>mask : 2-D array, optional</code> </dt> <dd>
<p class="first last">An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>output : 2-D array</code> </dt> <dd>
<p class="first last">The Scharr edge map.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 3   10   3
 0    0   0
-3  -10  -3
</pre> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="rd36c6da974bf-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id3">[1]</a></td>
<td>D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of Kernel Based Image Derivatives.</td>
</tr>  </table> </dd>
</dl>   <h2 id="scharr-v">scharr_v</h2> <dl class="function"> <dt id="skimage.filters.scharr_v">
<code>skimage.filters.scharr_v(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/edges.py#L257"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the vertical edges of an image using the Scharr transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array</code> </dt> <dd>
<p class="first last">Image to process</p> </dd> <dt>
<code>mask : 2-D array, optional</code> </dt> <dd>
<p class="first last">An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>output : 2-D array</code> </dt> <dd>
<p class="first last">The Scharr edge map.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 3   0   -3
10   0  -10
 3   0   -3
</pre> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="rb707fee1145e-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id4">[1]</a></td>
<td>D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of Kernel Based Image Derivatives.</td>
</tr>  </table> </dd>
</dl>   <h2 id="prewitt">prewitt</h2> <dl class="function"> <dt id="skimage.filters.prewitt">
<code>skimage.filters.prewitt(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/edges.py#L294"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edge magnitude using the Prewitt transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array</code> </dt> <dd>
<p class="first last">Image to process.</p> </dd> <dt>
<code>mask : 2-D array, optional</code> </dt> <dd>
<p class="first last">An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>output : 2-D array</code> </dt> <dd>
<p class="first last">The Prewitt edge map.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.filters.sobel" title="skimage.filters.sobel"><code>sobel</code></a>, <a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><code>scharr</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>Return the square root of the sum of squares of the horizontal and vertical Prewitt transforms. The edge magnitude depends slightly on edge directions, since the approximation of the gradient operator by the Prewitt operator is not completely rotation invariant. For a better rotation invariance, the Scharr operator should be used. The Sobel operator has a better rotation invariance than the Prewitt operator, but a worse rotation invariance than the Scharr operator.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; camera = data.camera()
&gt;&gt;&gt; from skimage import filters
&gt;&gt;&gt; edges = filters.prewitt(camera)
</pre> </dd>
</dl>   <h2 id="prewitt-h">prewitt_h</h2> <dl class="function"> <dt id="skimage.filters.prewitt_h">
<code>skimage.filters.prewitt_h(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/edges.py#L338"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the horizontal edges of an image using the Prewitt transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array</code> </dt> <dd>
<p class="first last">Image to process.</p> </dd> <dt>
<code>mask : 2-D array, optional</code> </dt> <dd>
<p class="first last">An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>output : 2-D array</code> </dt> <dd>
<p class="first last">The Prewitt edge map.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 1   1   1
 0   0   0
-1  -1  -1
</pre> </dd>
</dl>   <h2 id="prewitt-v">prewitt_v</h2> <dl class="function"> <dt id="skimage.filters.prewitt_v">
<code>skimage.filters.prewitt_v(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/edges.py#L370"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the vertical edges of an image using the Prewitt transform.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array</code> </dt> <dd>
<p class="first last">Image to process.</p> </dd> <dt>
<code>mask : 2-D array, optional</code> </dt> <dd>
<p class="first last">An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>output : 2-D array</code> </dt> <dd>
<p class="first last">The Prewitt edge map.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python">1   0  -1
1   0  -1
1   0  -1
</pre> </dd>
</dl>   <h2 id="roberts">roberts</h2> <dl class="function"> <dt id="skimage.filters.roberts">
<code>skimage.filters.roberts(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/edges.py#L402"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edge magnitude using Roberts’ cross operator.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array</code> </dt> <dd>
<p class="first last">Image to process.</p> </dd> <dt>
<code>mask : 2-D array, optional</code> </dt> <dd>
<p class="first last">An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>output : 2-D array</code> </dt> <dd>
<p class="first last">The Roberts’ Cross edge map.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.filters.sobel" title="skimage.filters.sobel"><code>sobel</code></a>, <a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><code>scharr</code></a>, <a class="reference internal" href="#skimage.filters.prewitt" title="skimage.filters.prewitt"><code>prewitt</code></a>, <code>feature.canny</code></p> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; camera = data.camera()
&gt;&gt;&gt; from skimage import filters
&gt;&gt;&gt; edges = filters.roberts(camera)
</pre> </dd>
</dl>   <h2 id="roberts-pos-diag">roberts_pos_diag</h2> <dl class="function"> <dt id="skimage.filters.roberts_pos_diag">
<code>skimage.filters.roberts_pos_diag(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/edges.py#L438"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the cross edges of an image using Roberts’ cross operator.</p> <p>The kernel is applied to the input image to produce separate measurements of the gradient component one orientation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array</code> </dt> <dd>
<p class="first last">Image to process.</p> </dd> <dt>
<code>mask : 2-D array, optional</code> </dt> <dd>
<p class="first last">An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>output : 2-D array</code> </dt> <dd>
<p class="first last">The Robert’s edge map.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python">1   0
0  -1
</pre> </dd>
</dl>   <h2 id="roberts-neg-diag">roberts_neg_diag</h2> <dl class="function"> <dt id="skimage.filters.roberts_neg_diag">
<code>skimage.filters.roberts_neg_diag(image, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/edges.py#L472"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the cross edges of an image using the Roberts’ Cross operator.</p> <p>The kernel is applied to the input image to produce separate measurements of the gradient component one orientation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array</code> </dt> <dd>
<p class="first last">Image to process.</p> </dd> <dt>
<code>mask : 2-D array, optional</code> </dt> <dd>
<p class="first last">An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>output : 2-D array</code> </dt> <dd>
<p class="first last">The Robert’s edge map.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 0   1
-1   0
</pre> </dd>
</dl>   <h2 id="laplace">laplace</h2> <dl class="function"> <dt id="skimage.filters.laplace">
<code>skimage.filters.laplace(image, ksize=3, mask=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/edges.py#L506"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edges of an image using the Laplace operator.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : ndarray</code> </dt> <dd>
<p class="first last">Image to process.</p> </dd> <dt>
<code>ksize : int, optional</code> </dt> <dd>
<p class="first last">Define the size of the discrete Laplacian operator such that it will have a size of (ksize,) * image.ndim.</p> </dd> <dt>
<code>mask : ndarray, optional</code> </dt> <dd>
<p class="first last">An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>output : ndarray</code> </dt> <dd>
<p class="first last">The Laplace edge map.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The Laplacian operator is generated using the function skimage.restoration.uft.laplacian().</p> </dd>
</dl>   <h2 id="rank-order">rank_order</h2> <dl class="function"> <dt id="skimage.filters.rank_order">
<code>skimage.filters.rank_order(image)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/_rank_order.py#L14"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return an image of the same shape where each pixel is the index of the pixel value in the ascending order of the unique values of <code>image</code>, aka the rank-order value.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>image: ndarray</strong></dt>  </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt><strong>labels: ndarray of type np.uint32, of shape image.shape</strong></dt> <dd>
<p class="first last">New array where each pixel has the rank-order value of the corresponding pixel in <code>image</code>. Pixel values are between 0 and n - 1, where n is the number of distinct unique values in <code>image</code>.</p> </dd> <dt><strong>original_values: 1-D ndarray</strong></dt> <dd>
<p class="first last">Unique original values of <code>image</code></p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.array([[1, 4, 5], [4, 4, 1], [5, 1, 1]])
&gt;&gt;&gt; a
array([[1, 4, 5],
       [4, 4, 1],
       [5, 1, 1]])
&gt;&gt;&gt; rank_order(a)
(array([[0, 1, 2],
       [1, 1, 0],
       [2, 0, 0]], dtype=uint32), array([1, 4, 5]))
&gt;&gt;&gt; b = np.array([-1., 2.5, 3.1, 2.5])
&gt;&gt;&gt; rank_order(b)
(array([0, 1, 2, 1], dtype=uint32), array([-1. ,  2.5,  3.1]))
</pre> </dd>
</dl>   <h2 id="gabor-kernel">gabor_kernel</h2> <dl class="function"> <dt id="skimage.filters.gabor_kernel">
<code>skimage.filters.gabor_kernel(frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/_gabor.py#L16"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return complex 2D Gabor filter kernel.</p> <p>Gabor kernel is a Gaussian kernel modulated by a complex harmonic function. Harmonic function consists of an imaginary sine function and a real cosine function. Spatial frequency is inversely proportional to the wavelength of the harmonic and to the standard deviation of a Gaussian kernel. The bandwidth is also inversely proportional to the standard deviation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>frequency : float</code> </dt> <dd>
<p class="first last">Spatial frequency of the harmonic function. Specified in pixels.</p> </dd> <dt>
<code>theta : float, optional</code> </dt> <dd>
<p class="first last">Orientation in radians. If 0, the harmonic is in the x-direction.</p> </dd> <dt>
<code>bandwidth : float, optional</code> </dt> <dd>
<p class="first last">The bandwidth captured by the filter. For fixed bandwidth, <code>sigma_x</code> and <code>sigma_y</code> will decrease with increasing frequency. This value is ignored if <code>sigma_x</code> and <code>sigma_y</code> are set by the user.</p> </dd> <dt>
<code>sigma_x, sigma_y : float, optional</code> </dt> <dd>
<p class="first last">Standard deviation in x- and y-directions. These directions apply to the kernel <em>before</em> rotation. If <code>theta = pi/2</code>, then the kernel is rotated 90 degrees so that <code>sigma_x</code> controls the <em>vertical</em> direction.</p> </dd> <dt>
<code>n_stds : scalar, optional</code> </dt> <dd>
<p class="first last">The linear size of the kernel is n_stds (3 by default) standard deviations</p> </dd> <dt>
<code>offset : float, optional</code> </dt> <dd>
<p class="first last">Phase offset of harmonic function in radians.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>g : complex array</code> </dt> <dd>
<p class="first last">Complex filter kernel.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r5ad457f519cf-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id5">[1]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Gabor_filter">http://en.wikipedia.org/wiki/Gabor_filter</a></td>
</tr>  </table> <table class="docutils citation" frame="void" id="r5ad457f519cf-2" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id6">[2]</a></td>
<td><a class="reference external" href="http://mplab.ucsd.edu/tutorials/gabor.pdf">http://mplab.ucsd.edu/tutorials/gabor.pdf</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.filters import gabor_kernel
&gt;&gt;&gt; from skimage import io
&gt;&gt;&gt; from matplotlib import pyplot as plt  # doctest: +SKIP
</pre> <pre data-language="python">&gt;&gt;&gt; gk = gabor_kernel(frequency=0.2)
&gt;&gt;&gt; plt.figure()        # doctest: +SKIP
&gt;&gt;&gt; io.imshow(gk.real)  # doctest: +SKIP
&gt;&gt;&gt; io.show()           # doctest: +SKIP
</pre> <pre data-language="python">&gt;&gt;&gt; # more ripples (equivalent to increasing the size of the
&gt;&gt;&gt; # Gaussian spread)
&gt;&gt;&gt; gk = gabor_kernel(frequency=0.2, bandwidth=0.1)
&gt;&gt;&gt; plt.figure()        # doctest: +SKIP
&gt;&gt;&gt; io.imshow(gk.real)  # doctest: +SKIP
&gt;&gt;&gt; io.show()           # doctest: +SKIP
</pre> </dd>
</dl>   <h2 id="gabor">gabor</h2> <dl class="function"> <dt id="skimage.filters.gabor">
<code>skimage.filters.gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, mode='reflect', cval=0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/_gabor.py#L97"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return real and imaginary responses to Gabor filter.</p> <p>The real and imaginary parts of the Gabor filter kernel are applied to the image and the response is returned as a pair of arrays.</p> <p>Gabor filter is a linear filter with a Gaussian kernel which is modulated by a sinusoidal plane wave. Frequency and orientation representations of the Gabor filter are similar to those of the human visual system. Gabor filter banks are commonly used in computer vision and image processing. They are especially suitable for edge detection and texture classification.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : 2-D array</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>frequency : float</code> </dt> <dd>
<p class="first last">Spatial frequency of the harmonic function. Specified in pixels.</p> </dd> <dt>
<code>theta : float, optional</code> </dt> <dd>
<p class="first last">Orientation in radians. If 0, the harmonic is in the x-direction.</p> </dd> <dt>
<code>bandwidth : float, optional</code> </dt> <dd>
<p class="first last">The bandwidth captured by the filter. For fixed bandwidth, <code>sigma_x</code> and <code>sigma_y</code> will decrease with increasing frequency. This value is ignored if <code>sigma_x</code> and <code>sigma_y</code> are set by the user.</p> </dd> <dt>
<code>sigma_x, sigma_y : float, optional</code> </dt> <dd>
<p class="first last">Standard deviation in x- and y-directions. These directions apply to the kernel <em>before</em> rotation. If <code>theta = pi/2</code>, then the kernel is rotated 90 degrees so that <code>sigma_x</code> controls the <em>vertical</em> direction.</p> </dd> <dt>
<code>n_stds : scalar, optional</code> </dt> <dd>
<p class="first last">The linear size of the kernel is n_stds (3 by default) standard deviations.</p> </dd> <dt>
<code>offset : float, optional</code> </dt> <dd>
<p class="first last">Phase offset of harmonic function in radians.</p> </dd> <dt>
<code>mode : {‘constant’, ‘nearest’, ‘reflect’, ‘mirror’, ‘wrap’}, optional</code> </dt> <dd>
<p class="first last">Mode used to convolve image with a kernel, passed to <code>ndi.convolve</code></p> </dd> <dt>
<code>cval : scalar, optional</code> </dt> <dd>
<p class="first last">Value to fill past edges of input if <code>mode</code> of convolution is ‘constant’. The parameter is passed to <code>ndi.convolve</code>.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>real, imag : arrays</code> </dt> <dd>
<p class="first last">Filtered images using the real and imaginary parts of the Gabor filter kernel. Images are of the same dimensions as the input one.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="rc394129659a3-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id7">[1]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Gabor_filter">http://en.wikipedia.org/wiki/Gabor_filter</a></td>
</tr>  </table> <table class="docutils citation" frame="void" id="rc394129659a3-2" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id8">[2]</a></td>
<td><a class="reference external" href="http://mplab.ucsd.edu/tutorials/gabor.pdf">http://mplab.ucsd.edu/tutorials/gabor.pdf</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.filters import gabor
&gt;&gt;&gt; from skimage import data, io
&gt;&gt;&gt; from matplotlib import pyplot as plt  # doctest: +SKIP
</pre> <pre data-language="python">&gt;&gt;&gt; image = data.coins()
&gt;&gt;&gt; # detecting edges in a coin image
&gt;&gt;&gt; filt_real, filt_imag = gabor(image, frequency=0.6)
&gt;&gt;&gt; plt.figure()            # doctest: +SKIP
&gt;&gt;&gt; io.imshow(filt_real)    # doctest: +SKIP
&gt;&gt;&gt; io.show()               # doctest: +SKIP
</pre> <pre data-language="python">&gt;&gt;&gt; # less sensitivity to finer details with the lower frequency kernel
&gt;&gt;&gt; filt_real, filt_imag = gabor(image, frequency=0.1)
&gt;&gt;&gt; plt.figure()            # doctest: +SKIP
&gt;&gt;&gt; io.imshow(filt_real)    # doctest: +SKIP
&gt;&gt;&gt; io.show()               # doctest: +SKIP
</pre> </dd>
</dl>   <h2 id="try-all-threshold">try_all_threshold</h2> <dl class="function"> <dt id="skimage.filters.try_all_threshold">
<code>skimage.filters.try_all_threshold(image, figsize=(8, 5), verbose=True)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/thresholding.py#L75"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a figure comparing the outputs of different thresholding methods.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : (N, M) ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>figsize : tuple, optional</code> </dt> <dd>
<p class="first last">Figure size (in inches).</p> </dd> <dt>
<code>verbose : bool, optional</code> </dt> <dd>
<p class="first last">Print function name for each method.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fig, ax : tuple</code> </dt> <dd>
<p class="first last">Matplotlib figure and axes.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The following algorithms are used:</p> <ul class="simple"> <li>isodata</li> <li>li</li> <li>mean</li> <li>minimum</li> <li>otsu</li> <li>triangle</li> <li>yen</li> </ul> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import text
&gt;&gt;&gt; fig, ax = try_all_threshold(text(), figsize=(10, 6), verbose=False)
</pre> </dd>
</dl>   <h2 id="frangi">frangi</h2> <dl class="function"> <dt id="skimage.filters.frangi">
<code>skimage.filters.frangi(image, scale_range=(1, 10), scale_step=2, beta1=0.5, beta2=15, black_ridges=True)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/_frangi.py#L72"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Filter an image with the Frangi filter.</p> <p>This filter can be used to detect continuous edges, e.g. vessels, wrinkles, rivers. It can be used to calculate the fraction of the whole image containing such objects.</p> <p>Calculates the eigenvectors of the Hessian to compute the similarity of an image region to vessels, according to the method described in <a class="reference internal" href="#r9152c279884a-1" id="id9">[1]</a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : (N, M) ndarray</code> </dt> <dd>
<p class="first last">Array with input image data.</p> </dd> <dt>
<code>scale_range : 2-tuple of floats, optional</code> </dt> <dd>
<p class="first last">The range of sigmas used.</p> </dd> <dt>
<code>scale_step : float, optional</code> </dt> <dd>
<p class="first last">Step size between sigmas.</p> </dd> <dt>
<code>beta1 : float, optional</code> </dt> <dd>
<p class="first last">Frangi correction constant that adjusts the filter’s sensitivity to deviation from a blob-like structure.</p> </dd> <dt>
<code>beta2 : float, optional</code> </dt> <dd>
<p class="first last">Frangi correction constant that adjusts the filter’s sensitivity to areas of high variance/texture/structure.</p> </dd> <dt>
<code>black_ridges : boolean, optional</code> </dt> <dd>
<p class="first last">When True (the default), the filter detects black ridges; when False, it detects white ridges.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>out : (N, M) ndarray</code> </dt> <dd>
<p class="first last">Filtered image (maximum of pixels across all scales).</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Written by Marc Schrijver, 2/11/2001 Re-Written by D. J. Kroon University of Twente (May 2009)</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r9152c279884a-1" rules="none">   <tr>
<td class="label">[1]</td>
<td>
<em>(<a class="fn-backref" href="#id9">1</a>, <a class="fn-backref" href="#id10">2</a>)</em> A. Frangi, W. Niessen, K. Vincken, and M. Viergever. “Multiscale vessel enhancement filtering,” In LNCS, vol. 1496, pages 130-137, Germany, 1998. Springer-Verlag.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r9152c279884a-2" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id11">[2]</a></td>
<td>Kroon, D.J.: Hessian based Frangi vesselness filter.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r9152c279884a-3" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id12">[3]</a></td>
<td>
<a class="reference external" href="http://mplab.ucsd.edu/tutorials/gabor.pdf">http://mplab.ucsd.edu/tutorials/gabor.pdf</a>.</td>
</tr>  </table> </dd>
</dl>   <h2 id="hessian">hessian</h2> <dl class="function"> <dt id="skimage.filters.hessian">
<code>skimage.filters.hessian(image, scale_range=(1, 10), scale_step=2, beta1=0.5, beta2=15)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/_frangi.py#L132"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Filter an image with the Hessian filter.</p> <p>This filter can be used to detect continuous edges, e.g. vessels, wrinkles, rivers. It can be used to calculate the fraction of the whole image containing such objects.</p> <p>Almost equal to Frangi filter, but uses alternative method of smoothing. Refer to <a class="reference internal" href="#r29057abd4159-1" id="id13">[1]</a> to find the differences between Frangi and Hessian filters.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : (N, M) ndarray</code> </dt> <dd>
<p class="first last">Array with input image data.</p> </dd> <dt>
<code>scale_range : 2-tuple of floats, optional</code> </dt> <dd>
<p class="first last">The range of sigmas used.</p> </dd> <dt>
<code>scale_step : float, optional</code> </dt> <dd>
<p class="first last">Step size between sigmas.</p> </dd> <dt>
<code>beta1 : float, optional</code> </dt> <dd>
<p class="first last">Frangi correction constant that adjusts the filter’s sensitivity to deviation from a blob-like structure.</p> </dd> <dt>
<code>beta2 : float, optional</code> </dt> <dd>
<p class="first last">Frangi correction constant that adjusts the filter’s sensitivity to areas of high variance/texture/structure.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>out : (N, M) ndarray</code> </dt> <dd>
<p class="first last">Filtered image (maximum of pixels across all scales).</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Written by Marc Schrijver, 2/11/2001 Re-Written by D. J. Kroon University of Twente (May 2009)</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r29057abd4159-1" rules="none">   <tr>
<td class="label">[1]</td>
<td>
<em>(<a class="fn-backref" href="#id13">1</a>, <a class="fn-backref" href="#id14">2</a>)</em> Choon-Ching Ng, Moi Hoon Yap, Nicholas Costen and Baihua Li, “Automatic Wrinkle Detection using Hybrid Hessian Filter”.</td>
</tr>  </table> </dd>
</dl>   <h2 id="threshold-adaptive">threshold_adaptive</h2> <dl class="function"> <dt id="skimage.filters.threshold_adaptive">
<code>skimage.filters.threshold_adaptive(image, block_size, method='gaussian', offset=0, mode='reflect', param=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/_shared/utils.py#L59"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>threshold_local</code> instead.</p> </dd>
</dl>   <h2 id="threshold-otsu">threshold_otsu</h2> <dl class="function"> <dt id="skimage.filters.threshold_otsu">
<code>skimage.filters.threshold_otsu(image, nbins=256)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/thresholding.py#L238"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value based on Otsu’s method.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : (N, M) ndarray</code> </dt> <dd>
<p class="first last">Grayscale input image.</p> </dd> <dt>
<code>nbins : int, optional</code> </dt> <dd>
<p class="first last">Number of bins used to calculate histogram. This value is ignored for integer arrays.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>threshold : float</code> </dt> <dd>
<p class="first last">Upper threshold value. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Raises:</th>
<td class="field-body">
<dl class="first last docutils"> <dt><strong>ValueError</strong></dt> <dd>
<p class="first last">If <code>image</code> only contains a single grayscale value.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The input image must be grayscale.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r1bb8cdf6ebea-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id15">[1]</a></td>
<td>Wikipedia, <a class="reference external" href="http://en.wikipedia.org/wiki/Otsu's_Method">http://en.wikipedia.org/wiki/Otsu’s_Method</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_otsu(image)
&gt;&gt;&gt; binary = image &lt;= thresh
</pre> </dd>
</dl>   <h2 id="threshold-yen">threshold_yen</h2> <dl class="function"> <dt id="skimage.filters.threshold_yen">
<code>skimage.filters.threshold_yen(image, nbins=256)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/thresholding.py#L306"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value based on Yen’s method.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : (N, M) ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>nbins : int, optional</code> </dt> <dd>
<p class="first last">Number of bins used to calculate histogram. This value is ignored for integer arrays.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>threshold : float</code> </dt> <dd>
<p class="first last">Upper threshold value. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="rc5144ffaa46d-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id16">[1]</a></td>
<td>Yen J.C., Chang F.J., and Chang S. (1995) “A New Criterion for Automatic Multilevel Thresholding” IEEE Trans. on Image Processing, 4(3): 370-378. DOI:10.1109/83.366472</td>
</tr>  </table> <table class="docutils citation" frame="void" id="rc5144ffaa46d-2" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id17">[2]</a></td>
<td>Sezgin M. and Sankur B. (2004) “Survey over Image Thresholding Techniques and Quantitative Performance Evaluation” Journal of Electronic Imaging, 13(1): 146-165, DOI:10.1117/1.1631315 http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf</td>
</tr>  </table> <table class="docutils citation" frame="void" id="rc5144ffaa46d-3" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id18">[3]</a></td>
<td>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_yen(image)
&gt;&gt;&gt; binary = image &lt;= thresh
</pre> </dd>
</dl>   <h2 id="threshold-isodata">threshold_isodata</h2> <dl class="function"> <dt id="skimage.filters.threshold_isodata">
<code>skimage.filters.threshold_isodata(image, nbins=256, return_all=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/thresholding.py#L360"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value(s) based on ISODATA method.</p> <p>Histogram-based threshold, known as Ridler-Calvard method or inter-means. Threshold values returned satisfy the following equality:</p> <pre data-language="python">threshold = (image[image &lt;= threshold].mean() +
             image[image &gt; threshold].mean()) / 2.0
</pre> <p>That is, returned thresholds are intensities that separate the image into two groups of pixels, where the threshold intensity is midway between the mean intensities of these groups.</p> <p>For integer images, the above equality holds to within one; for floating- point images, the equality holds to within the histogram bin-width.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : (N, M) ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>nbins : int, optional</code> </dt> <dd>
<p class="first last">Number of bins used to calculate histogram. This value is ignored for integer arrays.</p> </dd> <dt><strong>return_all: bool, optional</strong></dt> <dd>
<p class="first last">If False (default), return only the lowest threshold that satisfies the above equality. If True, return all valid thresholds.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>threshold : float or int or array</code> </dt> <dd>
<p class="first last">Threshold value(s).</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="re728dd270820-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id19">[1]</a></td>
<td>Ridler, TW &amp; Calvard, S (1978), “Picture thresholding using an iterative selection method” IEEE Transactions on Systems, Man and Cybernetics 8: 630-632, DOI:10.1109/TSMC.1978.4310039</td>
</tr>  </table> <table class="docutils citation" frame="void" id="re728dd270820-2" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id20">[2]</a></td>
<td>Sezgin M. and Sankur B. (2004) “Survey over Image Thresholding Techniques and Quantitative Performance Evaluation” Journal of Electronic Imaging, 13(1): 146-165, <a class="reference external" href="http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf">http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf</a> DOI:10.1117/1.1631315</td>
</tr>  </table> <table class="docutils citation" frame="void" id="re728dd270820-3" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id21">[3]</a></td>
<td>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import coins
&gt;&gt;&gt; image = coins()
&gt;&gt;&gt; thresh = threshold_isodata(image)
&gt;&gt;&gt; binary = image &gt; thresh
</pre> </dd>
</dl>   <h2 id="threshold-li">threshold_li</h2> <dl class="function"> <dt id="skimage.filters.threshold_li">
<code>skimage.filters.threshold_li(image)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/thresholding.py#L524"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute threshold value by Li’s iterative Minimum Cross Entropy method.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>tolerance : float, optional</code> </dt> <dd>
<p class="first last">Finish the computation when the change in the threshold in an iteration is less than this value. By default, this is half of the range of the input image, divided by 256.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>threshold : float</code> </dt> <dd>
<p class="first last">Upper threshold value. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="rc1e664efa0df-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id22">[1]</a></td>
<td>Li C.H. and Lee C.K. (1993) “Minimum Cross Entropy Thresholding” Pattern Recognition, 26(4): 617-625 DOI:10.1016/0031-3203(93)90115-D</td>
</tr>  </table> <table class="docutils citation" frame="void" id="rc1e664efa0df-2" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id23">[2]</a></td>
<td>Li C.H. and Tam P.K.S. (1998) “An Iterative Algorithm for Minimum Cross Entropy Thresholding” Pattern Recognition Letters, 18(8): 771-776 DOI:10.1016/S0167-8655(98)00057-9</td>
</tr>  </table> <table class="docutils citation" frame="void" id="rc1e664efa0df-3" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id24">[3]</a></td>
<td>Sezgin M. and Sankur B. (2004) “Survey over Image Thresholding Techniques and Quantitative Performance Evaluation” Journal of Electronic Imaging, 13(1): 146-165 DOI:10.1117/1.1631315</td>
</tr>  </table> <table class="docutils citation" frame="void" id="rc1e664efa0df-4" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id25">[4]</a></td>
<td>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_li(image)
&gt;&gt;&gt; binary = image &gt; thresh
</pre> </dd>
</dl>   <h2 id="threshold-local">threshold_local</h2> <dl class="function"> <dt id="skimage.filters.threshold_local">
<code>skimage.filters.threshold_local(image, block_size, method='gaussian', offset=0, mode='reflect', param=None, cval=0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/thresholding.py#L134"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute a threshold mask image based on local pixel neighborhood.</p> <p>Also known as adaptive or dynamic thresholding. The threshold value is the weighted mean for the local neighborhood of a pixel subtracted by a constant. Alternatively the threshold can be determined dynamically by a given function, using the ‘generic’ method.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : (N, M) ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>block_size : int</code> </dt> <dd>
<p class="first last">Odd size of pixel neighborhood which is used to calculate the threshold value (e.g. 3, 5, 7, …, 21, …).</p> </dd> <dt>
<code>method : {‘generic’, ‘gaussian’, ‘mean’, ‘median’}, optional</code> </dt> <dd>
<p class="first">Method used to determine adaptive threshold for local neighbourhood in weighted mean image.</p> <ul class="simple"> <li>‘generic’: use custom function (see <code>param</code> parameter)</li> <li>‘gaussian’: apply gaussian filter (see <code>param</code> parameter for custom sigma value)</li> <li>‘mean’: apply arithmetic mean filter</li> <li>‘median’: apply median rank filter</li> </ul> <p class="last">By default the ‘gaussian’ method is used.</p> </dd> <dt>
<code>offset : float, optional</code> </dt> <dd>
<p class="first last">Constant subtracted from weighted mean of neighborhood to calculate the local threshold value. Default offset is 0.</p> </dd> <dt>
<code>mode : {‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional</code> </dt> <dd>
<p class="first last">The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’.</p> </dd> <dt>
<code>param : {int, function}, optional</code> </dt> <dd>
<p class="first last">Either specify sigma for ‘gaussian’ method or function object for ‘generic’ method. This functions takes the flat array of local neighbourhood as a single argument and returns the calculated threshold for the centre pixel.</p> </dd> <dt>
<code>cval : float, optional</code> </dt> <dd>
<p class="first last">Value to fill past edges of input if mode is ‘constant’.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>threshold : (N, M) ndarray</code> </dt> <dd>
<p class="first last">Threshold image. All pixels in the input image higher than the corresponding pixel in the threshold image are considered foreground.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="rf57739a75c82-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id26">[1]</a></td>
<td><a class="reference external" href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#adaptivethreshold">http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#adaptivethreshold</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()[:50, :50]
&gt;&gt;&gt; binary_image1 = image &gt; threshold_local(image, 15, 'mean')
&gt;&gt;&gt; func = lambda arr: arr.mean()
&gt;&gt;&gt; binary_image2 = image &gt; threshold_local(image, 15, 'generic',
...                                         param=func)
</pre> </dd>
</dl>   <h2 id="threshold-minimum">threshold_minimum</h2> <dl class="function"> <dt id="skimage.filters.threshold_minimum">
<code>skimage.filters.threshold_minimum(image, nbins=256, max_iter=10000)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/thresholding.py#L607"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value based on minimum method.</p> <p>The histogram of the input <code>image</code> is computed and smoothed until there are only two maxima. Then the minimum in between is the threshold value.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : (M, N) ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>nbins : int, optional</code> </dt> <dd>
<p class="first last">Number of bins used to calculate histogram. This value is ignored for integer arrays.</p> </dd> <dt><strong>max_iter: int, optional</strong></dt> <dd>
<p class="first last">Maximum number of iterations to smooth the histogram.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>threshold : float</code> </dt> <dd>
<p class="first last">Upper threshold value. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Raises:</th>
<td class="field-body">
<dl class="first last docutils"> <dt><strong>RuntimeError</strong></dt> <dd>
<p class="first last">If unable to find two local maxima in the histogram or if the smoothing takes more than 1e4 iterations.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="rd44294765be8-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id27">[1]</a></td>
<td>C. A. Glasbey, “An analysis of histogram-based thresholding algorithms,” CVGIP: Graphical Models and Image Processing, vol. 55, pp. 532-537, 1993.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="rd44294765be8-2" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id28">[2]</a></td>
<td>Prewitt, JMS &amp; Mendelsohn, ML (1966), “The analysis of cell images”, Annals of the New York Academy of Sciences 128: 1035-1053 DOI:10.1111/j.1749-6632.1965.tb11715.x</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_minimum(image)
&gt;&gt;&gt; binary = image &gt; thresh
</pre> </dd>
</dl>   <h2 id="threshold-mean">threshold_mean</h2> <dl class="function"> <dt id="skimage.filters.threshold_mean">
<code>skimage.filters.threshold_mean(image)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/thresholding.py#L691"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value based on the mean of grayscale values.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : (N, M[, …, P]) ndarray</code> </dt> <dd>
<p class="first last">Grayscale input image.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>threshold : float</code> </dt> <dd>
<p class="first last">Upper threshold value. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r6186ece30463-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id29">[1]</a></td>
<td>C. A. Glasbey, “An analysis of histogram-based thresholding algorithms,” CVGIP: Graphical Models and Image Processing, vol. 55, pp. 532-537, 1993. DOI:10.1006/cgip.1993.1040</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_mean(image)
&gt;&gt;&gt; binary = image &gt; thresh
</pre> </dd>
</dl>   <h2 id="threshold-niblack">threshold_niblack</h2> <dl class="function"> <dt id="skimage.filters.threshold_niblack">
<code>skimage.filters.threshold_niblack(image, window_size=15, k=0.2)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/thresholding.py#L853"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies Niblack local threshold to an array.</p> <p>A threshold T is calculated for every pixel in the image using the following formula:</p> <pre data-language="python">T = m(x,y) - k * s(x,y)
</pre> <p>where m(x,y) and s(x,y) are the mean and standard deviation of pixel (x,y) neighborhood defined by a rectangular window with size w times w centered around the pixel. k is a configurable parameter that weights the effect of standard deviation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>image: (N, M) ndarray</strong></dt> <dd>
<p class="first last">Grayscale input image.</p> </dd> <dt>
<code>window_size : int, optional</code> </dt> <dd>
<p class="first last">Odd size of pixel neighborhood window (e.g. 3, 5, 7…).</p> </dd> <dt>
<code>k : float, optional</code> </dt> <dd>
<p class="first last">Value of parameter k in threshold formula.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>threshold : (N, M) ndarray</code> </dt> <dd>
<p class="first last">Threshold mask. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>This algorithm is originally designed for text recognition.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="re9c5e7c193ed-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id30">[1]</a></td>
<td>Niblack, W (1986), An introduction to Digital Image Processing, Prentice-Hall.</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; image = data.page()
&gt;&gt;&gt; binary_image = threshold_niblack(image, window_size=7, k=0.1)
</pre> </dd>
</dl>   <h2 id="threshold-sauvola">threshold_sauvola</h2> <dl class="function"> <dt id="skimage.filters.threshold_sauvola">
<code>skimage.filters.threshold_sauvola(image, window_size=15, k=0.2, r=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/thresholding.py#L900"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies Sauvola local threshold to an array. Sauvola is a modification of Niblack technique.</p> <p>In the original method a threshold T is calculated for every pixel in the image using the following formula:</p> <pre data-language="python">T = m(x,y) * (1 + k * ((s(x,y) / R) - 1))
</pre> <p>where m(x,y) and s(x,y) are the mean and standard deviation of pixel (x,y) neighborhood defined by a rectangular window with size w times w centered around the pixel. k is a configurable parameter that weights the effect of standard deviation. R is the maximum standard deviation of a greyscale image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>image: (N, M) ndarray</strong></dt> <dd>
<p class="first last">Grayscale input image.</p> </dd> <dt>
<code>window_size : int, optional</code> </dt> <dd>
<p class="first last">Odd size of pixel neighborhood window (e.g. 3, 5, 7…).</p> </dd> <dt>
<code>k : float, optional</code> </dt> <dd>
<p class="first last">Value of the positive parameter k.</p> </dd> <dt>
<code>r : float, optional</code> </dt> <dd>
<p class="first last">Value of R, the dynamic range of standard deviation. If None, set to the half of the image dtype range.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>threshold : (N, M) ndarray</code> </dt> <dd>
<p class="first last">Threshold mask. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>This algorithm is originally designed for text recognition.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="rea1071b48c0e-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id31">[1]</a></td>
<td>J. Sauvola and M. Pietikainen, “Adaptive document image binarization,” Pattern Recognition 33(2), pp. 225-236, 2000. DOI:10.1016/S0031-3203(99)00055-2</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; image = data.page()
&gt;&gt;&gt; t_sauvola = threshold_sauvola(image, window_size=15, k=0.2)
&gt;&gt;&gt; binary_image = image &gt; t_sauvola
</pre> </dd>
</dl>   <h2 id="threshold-triangle">threshold_triangle</h2> <dl class="function"> <dt id="skimage.filters.threshold_triangle">
<code>skimage.filters.threshold_triangle(image, nbins=256)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/thresholding.py#L722"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value based on the triangle algorithm.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : (N, M[, …, P]) ndarray</code> </dt> <dd>
<p class="first last">Grayscale input image.</p> </dd> <dt>
<code>nbins : int, optional</code> </dt> <dd>
<p class="first last">Number of bins used to calculate histogram. This value is ignored for integer arrays.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>threshold : float</code> </dt> <dd>
<p class="first last">Upper threshold value. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="rb6780315cbfc-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id32">[1]</a></td>
<td>Zack, G. W., Rogers, W. E. and Latt, S. A., 1977, Automatic Measurement of Sister Chromatid Exchange Frequency, Journal of Histochemistry and Cytochemistry 25 (7), pp. 741-753 DOI:10.1177/25.7.70454</td>
</tr>  </table> <table class="docutils citation" frame="void" id="rb6780315cbfc-2" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id33">[2]</a></td>
<td>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_triangle(image)
&gt;&gt;&gt; binary = image &gt; thresh
</pre> </dd>
</dl>   <h2 id="apply-hysteresis-threshold">apply_hysteresis_threshold</h2> <dl class="function"> <dt id="skimage.filters.apply_hysteresis_threshold">
<code>skimage.filters.apply_hysteresis_threshold(image, low, high)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/thresholding.py#L958"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply hysteresis thresholding to <code>image</code>.</p> <p>This algorithm finds regions where <code>image</code> is greater than <code>high</code> OR <code>image</code> is greater than <code>low</code> <em>and</em> that region is connected to a region greater than <code>high</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : array, shape (M,[ N, …, P])</code> </dt> <dd>
<p class="first last">Grayscale input image.</p> </dd> <dt>
<code>low : float, or array of same shape as image</code> </dt> <dd>
<p class="first last">Lower threshold.</p> </dd> <dt>
<code>high : float, or array of same shape as image</code> </dt> <dd>
<p class="first last">Higher threshold.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>thresholded : array of bool, same shape as image</code> </dt> <dd>
<p class="first last">Array in which <code>True</code> indicates the locations where <code>image</code> was above the hysteresis threshold.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="rfd96194f9a6b-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id34">[1]</a></td>
<td>J. Canny. A computational approach to edge detection. IEEE Transactions on Pattern Analysis and Machine Intelligence. 1986; vol. 8, pp.679-698. DOI: 10.1109/TPAMI.1986.4767851</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; image = np.array([1, 2, 3, 2, 1, 2, 1, 3, 2])
&gt;&gt;&gt; apply_hysteresis_threshold(image, 1.5, 2.5).astype(int)
array([0, 1, 1, 1, 0, 0, 0, 1, 1])
</pre> </dd>
</dl>   <h2 id="lpifilter2d">LPIFilter2D</h2> <dl class="class"> <dt id="skimage.filters.LPIFilter2D">
<code>class skimage.filters.LPIFilter2D(impulse_response, **filter_params)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/lpi_filter.py#L42"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3.6/library/functions.html#object" title="(in Python v3.6)"><code>object</code></a></p> <p>Linear Position-Invariant Filter (2-dimensional)</p> <dl class="method"> <dt id="skimage.filters.LPIFilter2D.__init__">
<code>__init__(impulse_response, **filter_params)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/filters/lpi_filter.py#L47"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>impulse_response : callable f(r, c, **filter_params)</code> </dt> <dd>
<p class="first">Function that yields the impulse response. <code>r</code> and <code>c</code> are 1-dimensional vectors that represent row and column positions, in other words coordinates are (r[0],c[0]),(r[0],c[1]) etc. <code>**filter_params</code> are passed through.</p> <p>In other words, <code>impulse_response</code> would be called like this:</p> <pre data-language="python">&gt;&gt;&gt; def impulse_response(r, c, **filter_params):
...     pass
&gt;&gt;&gt;
&gt;&gt;&gt; r = [0,0,0,1,1,1,2,2,2]
&gt;&gt;&gt; c = [0,1,2,0,1,2,0,1,2]
&gt;&gt;&gt; filter_params = {'kw1': 1, 'kw2': 2, 'kw3': 3}
&gt;&gt;&gt; impulse_response(r, c, **filter_params)
</pre> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Examples</h4> <p>Gaussian filter: Use a 1-D gaussian in each direction without normalization coefficients.</p> <pre data-language="python">&gt;&gt;&gt; def filt_func(r, c, sigma = 1):
...     return np.exp(-np.hypot(r, c)/sigma)
&gt;&gt;&gt; filter = LPIFilter2D(filt_func)
</pre> </dd>
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="http://scikit-image.org/docs/0.14.x/api/skimage.filters.html" class="_attribution-link">http://scikit-image.org/docs/0.14.x/api/skimage.filters.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
