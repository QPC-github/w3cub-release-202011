
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Util - Scikit-image - W3cubDocs</title>
  
  <meta name="description" content=" Convert an image to single-precision (32-bit) floating point format. ">
  <meta name="keywords" content="module, util, scikit-image, scikit_image">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/scikit_image/api/skimage.util.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/scikit_image.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_image/" class="_nav-link" title="" style="margin-left:0;">scikit-image</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="module-util">Module: util</h1> <table class="longtable docutils" id="module-skimage.util">   <tr>
<td>
<a class="reference internal" href="#skimage.util.img_as_float32" title="skimage.util.img_as_float32"><code>skimage.util.img_as_float32</code></a>(image[, force_copy])</td> <td>Convert an image to single-precision (32-bit) floating point format.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.img_as_float64" title="skimage.util.img_as_float64"><code>skimage.util.img_as_float64</code></a>(image[, force_copy])</td> <td>Convert an image to double-precision (64-bit) floating point format.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.img_as_float" title="skimage.util.img_as_float"><code>skimage.util.img_as_float</code></a>(image[, force_copy])</td> <td>Convert an image to floating point format.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.img_as_int" title="skimage.util.img_as_int"><code>skimage.util.img_as_int</code></a>(image[, force_copy])</td> <td>Convert an image to 16-bit signed integer format.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.img_as_uint" title="skimage.util.img_as_uint"><code>skimage.util.img_as_uint</code></a>(image[, force_copy])</td> <td>Convert an image to 16-bit unsigned integer format.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.img_as_ubyte" title="skimage.util.img_as_ubyte"><code>skimage.util.img_as_ubyte</code></a>(image[, force_copy])</td> <td>Convert an image to 8-bit unsigned integer format.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.img_as_bool" title="skimage.util.img_as_bool"><code>skimage.util.img_as_bool</code></a>(image[, force_copy])</td> <td>Convert an image to boolean format.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.dtype_limits" title="skimage.util.dtype_limits"><code>skimage.util.dtype_limits</code></a>(image[, clip_negative])</td> <td>Return intensity limits, i.e.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.view_as_blocks" title="skimage.util.view_as_blocks"><code>skimage.util.view_as_blocks</code></a>(arr_in, block_shape)</td> <td>Block view of the input n-dimensional array (using re-striding).</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.view_as_windows" title="skimage.util.view_as_windows"><code>skimage.util.view_as_windows</code></a>(arr_in, …[, step])</td> <td>Rolling window view of the input n-dimensional array.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.pad" title="skimage.util.pad"><code>skimage.util.pad</code></a>(array, pad_width, mode, …)</td> <td>Pads an array.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.crop" title="skimage.util.crop"><code>skimage.util.crop</code></a>(ar, crop_width[, copy, order])</td> <td>Crop array <code>ar</code> by <code>crop_width</code> along each dimension.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.montage" title="skimage.util.montage"><code>skimage.util.montage</code></a>(arr_in[, fill, …])</td> <td>Create a montage of several single- or multichannel images.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.montage2d" title="skimage.util.montage2d"><code>skimage.util.montage2d</code></a>(arr_in[, fill, …])</td> <td>
<strong>Deprecated function</strong>.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.random_noise" title="skimage.util.random_noise"><code>skimage.util.random_noise</code></a>(image[, mode, …])</td> <td>Function to add random noise of various types to a floating-point image.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.regular_grid" title="skimage.util.regular_grid"><code>skimage.util.regular_grid</code></a>(ar_shape, n_points)</td> <td>Find <code>n_points</code> regularly spaced along <code>ar_shape</code>.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.regular_seeds" title="skimage.util.regular_seeds"><code>skimage.util.regular_seeds</code></a>(ar_shape, n_points)</td> <td>Return an image with ~`n_points` regularly-spaced nonzero pixels.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.apply_parallel" title="skimage.util.apply_parallel"><code>skimage.util.apply_parallel</code></a>(function, array)</td> <td>Map a function in parallel across an array.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.invert" title="skimage.util.invert"><code>skimage.util.invert</code></a>(image[, signed_float])</td> <td>Invert an image.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.util.unique_rows" title="skimage.util.unique_rows"><code>skimage.util.unique_rows</code></a>(ar)</td> <td>Remove repeated rows from a 2D array.</td> </tr>  </table>  <h2 id="img-as-float32">img_as_float32</h2> <dl class="function"> <dt id="skimage.util.img_as_float32">
<code>skimage.util.img_as_float32(image, force_copy=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/dtype.py#L341"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert an image to single-precision (32-bit) floating point format.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>force_copy : bool, optional</code> </dt> <dd>
<p class="first last">Force a copy of the data, irrespective of its current dtype.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>out : ndarray of float32</code> </dt> <dd>
<p class="first last">Output image.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The range of a floating point image is [0.0, 1.0] or [-1.0, 1.0] when converting from unsigned or signed datatypes, respectively. If the input image has a float type, intensity values are not modified and can be outside the ranges [0.0, 1.0] or [-1.0, 1.0].</p> </dd>
</dl>   <h2 id="img-as-float64">img_as_float64</h2> <dl class="function"> <dt id="skimage.util.img_as_float64">
<code>skimage.util.img_as_float64(image, force_copy=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/dtype.py#L367"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert an image to double-precision (64-bit) floating point format.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>force_copy : bool, optional</code> </dt> <dd>
<p class="first last">Force a copy of the data, irrespective of its current dtype.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>out : ndarray of float64</code> </dt> <dd>
<p class="first last">Output image.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The range of a floating point image is [0.0, 1.0] or [-1.0, 1.0] when converting from unsigned or signed datatypes, respectively. If the input image has a float type, intensity values are not modified and can be outside the ranges [0.0, 1.0] or [-1.0, 1.0].</p> </dd>
</dl>   <h2 id="img-as-float">img_as_float</h2> <dl class="function"> <dt id="skimage.util.img_as_float">
<code>skimage.util.img_as_float(image, force_copy=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/dtype.py#L393"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert an image to floating point format.</p> <p>This function is similar to <code>img_as_float64</code>, but will not convert lower-precision floating point arrays to <code>float64</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>force_copy : bool, optional</code> </dt> <dd>
<p class="first last">Force a copy of the data, irrespective of its current dtype.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>out : ndarray of float</code> </dt> <dd>
<p class="first last">Output image.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The range of a floating point image is [0.0, 1.0] or [-1.0, 1.0] when converting from unsigned or signed datatypes, respectively. If the input image has a float type, intensity values are not modified and can be outside the ranges [0.0, 1.0] or [-1.0, 1.0].</p> </dd>
</dl>   <h2 id="img-as-int">img_as_int</h2> <dl class="function"> <dt id="skimage.util.img_as_int">
<code>skimage.util.img_as_int(image, force_copy=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/dtype.py#L446"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert an image to 16-bit signed integer format.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>force_copy : bool, optional</code> </dt> <dd>
<p class="first last">Force a copy of the data, irrespective of its current dtype.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>out : ndarray of uint16</code> </dt> <dd>
<p class="first last">Output image.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The values are scaled between -32768 and 32767. If the input data-type is positive-only (e.g., uint8), then the output image will still only have positive values.</p> </dd>
</dl>   <h2 id="img-as-uint">img_as_uint</h2> <dl class="function"> <dt id="skimage.util.img_as_uint">
<code>skimage.util.img_as_uint(image, force_copy=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/dtype.py#L422"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert an image to 16-bit unsigned integer format.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>force_copy : bool, optional</code> </dt> <dd>
<p class="first last">Force a copy of the data, irrespective of its current dtype.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>out : ndarray of uint16</code> </dt> <dd>
<p class="first last">Output image.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Negative input values will be clipped. Positive values are scaled between 0 and 65535.</p> </dd>
</dl>   <h2 id="img-as-ubyte">img_as_ubyte</h2> <dl class="function"> <dt id="skimage.util.img_as_ubyte">
<code>skimage.util.img_as_ubyte(image, force_copy=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/dtype.py#L471"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert an image to 8-bit unsigned integer format.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>force_copy : bool, optional</code> </dt> <dd>
<p class="first last">Force a copy of the data, irrespective of its current dtype.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>out : ndarray of ubyte (uint8)</code> </dt> <dd>
<p class="first last">Output image.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Negative input values will be clipped. Positive values are scaled between 0 and 255.</p> </dd>
</dl>   <h2 id="img-as-bool">img_as_bool</h2> <dl class="function"> <dt id="skimage.util.img_as_bool">
<code>skimage.util.img_as_bool(image, force_copy=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/dtype.py#L495"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert an image to boolean format.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>force_copy : bool, optional</code> </dt> <dd>
<p class="first last">Force a copy of the data, irrespective of its current dtype.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>out : ndarray of bool (bool_)</code> </dt> <dd>
<p class="first last">Output image.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The upper half of the input dtype’s positive range is True, and the lower half is False. All negative values (if present) are False.</p> </dd>
</dl>   <h2 id="dtype-limits">dtype_limits</h2> <dl class="function"> <dt id="skimage.util.dtype_limits">
<code>skimage.util.dtype_limits(image, clip_negative=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/dtype.py#L36"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return intensity limits, i.e. (min, max) tuple, of the image’s dtype.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>clip_negative : bool, optional</code> </dt> <dd>
<p class="first last">If True, clip the negative range (i.e. return 0 for min intensity) even if the image dtype allows negative values. The default behavior (None) is equivalent to True.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>imin, imax : tuple</code> </dt> <dd>
<p class="first last">Lower and upper intensity limits.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl>   <h2 id="view-as-blocks">view_as_blocks</h2> <dl class="function"> <dt id="skimage.util.view_as_blocks">
<code>skimage.util.view_as_blocks(arr_in, block_shape)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/shape.py#L10"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Block view of the input n-dimensional array (using re-striding).</p> <p>Blocks are non-overlapping views of the input array.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>arr_in : ndarray</code> </dt> <dd>
<p class="first last">N-d input array.</p> </dd> <dt>
<code>block_shape : tuple</code> </dt> <dd>
<p class="first last">The shape of the block. Each dimension must divide evenly into the corresponding dimensions of <code>arr_in</code>.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>arr_out : ndarray</code> </dt> <dd>
<p class="first last">Block view of the input array. If <code>arr_in</code> is non-contiguous, a copy is made.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.util.shape import view_as_blocks
&gt;&gt;&gt; A = np.arange(4*4).reshape(4,4)
&gt;&gt;&gt; A
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
&gt;&gt;&gt; B = view_as_blocks(A, block_shape=(2, 2))
&gt;&gt;&gt; B[0, 0]
array([[0, 1],
       [4, 5]])
&gt;&gt;&gt; B[0, 1]
array([[2, 3],
       [6, 7]])
&gt;&gt;&gt; B[1, 0, 1, 1]
13
</pre> <pre data-language="python">&gt;&gt;&gt; A = np.arange(4*4*6).reshape(4,4,6)
&gt;&gt;&gt; A  # doctest: +NORMALIZE_WHITESPACE
array([[[ 0,  1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10, 11],
        [12, 13, 14, 15, 16, 17],
        [18, 19, 20, 21, 22, 23]],
       [[24, 25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34, 35],
        [36, 37, 38, 39, 40, 41],
        [42, 43, 44, 45, 46, 47]],
       [[48, 49, 50, 51, 52, 53],
        [54, 55, 56, 57, 58, 59],
        [60, 61, 62, 63, 64, 65],
        [66, 67, 68, 69, 70, 71]],
       [[72, 73, 74, 75, 76, 77],
        [78, 79, 80, 81, 82, 83],
        [84, 85, 86, 87, 88, 89],
        [90, 91, 92, 93, 94, 95]]])
&gt;&gt;&gt; B = view_as_blocks(A, block_shape=(1, 2, 2))
&gt;&gt;&gt; B.shape
(4, 2, 3, 1, 2, 2)
&gt;&gt;&gt; B[2:, 0, 2]  # doctest: +NORMALIZE_WHITESPACE
array([[[[52, 53],
         [58, 59]]],
       [[[76, 77],
         [82, 83]]]])
</pre> </dd>
</dl>   <h2 id="view-as-windows">view_as_windows</h2> <dl class="function"> <dt id="skimage.util.view_as_windows">
<code>skimage.util.view_as_windows(arr_in, window_shape, step=1)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/shape.py#L107"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Rolling window view of the input n-dimensional array.</p> <p>Windows are overlapping views of the input array, with adjacent windows shifted by a single row or column (or an index of a higher dimension).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>arr_in : ndarray</code> </dt> <dd>
<p class="first last">N-d input array.</p> </dd> <dt>
<code>window_shape : integer or tuple of length arr_in.ndim</code> </dt> <dd>
<p class="first last">Defines the shape of the elementary n-dimensional orthotope (better know as hyperrectangle <a class="reference internal" href="#redb8d40dc8d4-1" id="id1">[1]</a>) of the rolling window view. If an integer is given, the shape will be a hypercube of sidelength given by its value.</p> </dd> <dt>
<code>step : integer or tuple of length arr_in.ndim</code> </dt> <dd>
<p class="first last">Indicates step size at which extraction shall be performed. If integer is given, then the step is uniform in all dimensions.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>arr_out : ndarray</code> </dt> <dd>
<p class="first last">(rolling) window view of the input array. If <code>arr_in</code> is non-contiguous, a copy is made.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>One should be very careful with rolling views when it comes to memory usage. Indeed, although a ‘view’ has the same memory footprint as its base array, the actual array that emerges when this ‘view’ is used in a computation is generally a (much) larger array than the original, especially for 2-dimensional arrays and above.</p> <p>For example, let us consider a 3 dimensional array of size (100, 100, 100) of <code>float64</code>. This array takes about 8*100**3 Bytes for storage which is just 8 MB. If one decides to build a rolling view on this array with a window of (3, 3, 3) the hypothetical size of the rolling view (if one was to reshape the view for example) would be 8*(100-3+1)**3*3**3 which is about 203 MB! The scaling becomes even worse as the dimension of the input array becomes larger.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="redb8d40dc8d4-1" rules="none">   <tr>
<td class="label">[1]</td>
<td>
<em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> <a class="reference external" href="http://en.wikipedia.org/wiki/Hyperrectangle">http://en.wikipedia.org/wiki/Hyperrectangle</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.util.shape import view_as_windows
&gt;&gt;&gt; A = np.arange(4*4).reshape(4,4)
&gt;&gt;&gt; A
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
&gt;&gt;&gt; window_shape = (2, 2)
&gt;&gt;&gt; B = view_as_windows(A, window_shape)
&gt;&gt;&gt; B[0, 0]
array([[0, 1],
       [4, 5]])
&gt;&gt;&gt; B[0, 1]
array([[1, 2],
       [5, 6]])
</pre> <pre data-language="python">&gt;&gt;&gt; A = np.arange(10)
&gt;&gt;&gt; A
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt; window_shape = (3,)
&gt;&gt;&gt; B = view_as_windows(A, window_shape)
&gt;&gt;&gt; B.shape
(8, 3)
&gt;&gt;&gt; B
array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4],
       [3, 4, 5],
       [4, 5, 6],
       [5, 6, 7],
       [6, 7, 8],
       [7, 8, 9]])
</pre> <pre data-language="python">&gt;&gt;&gt; A = np.arange(5*4).reshape(5, 4)
&gt;&gt;&gt; A
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19]])
&gt;&gt;&gt; window_shape = (4, 3)
&gt;&gt;&gt; B = view_as_windows(A, window_shape)
&gt;&gt;&gt; B.shape
(2, 2, 4, 3)
&gt;&gt;&gt; B  # doctest: +NORMALIZE_WHITESPACE
array([[[[ 0,  1,  2],
         [ 4,  5,  6],
         [ 8,  9, 10],
         [12, 13, 14]],
        [[ 1,  2,  3],
         [ 5,  6,  7],
         [ 9, 10, 11],
         [13, 14, 15]]],
       [[[ 4,  5,  6],
         [ 8,  9, 10],
         [12, 13, 14],
         [16, 17, 18]],
        [[ 5,  6,  7],
         [ 9, 10, 11],
         [13, 14, 15],
         [17, 18, 19]]]])
</pre> </dd>
</dl>   <h2 id="pad">pad</h2> <dl class="function"> <dt id="skimage.util.pad">
<code>skimage.util.pad(array, pad_width, mode, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/../numpy/lib/arraypad.py#L1094"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Pads an array.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>array : array_like of rank N</code> </dt> <dd>
<p class="first last">Input array</p> </dd> <dt>
<code>pad_width : {sequence, array_like, int}</code> </dt> <dd>
<p class="first last">Number of values padded to the edges of each axis. ((before_1, after_1), … (before_N, after_N)) unique pad widths for each axis. ((before, after),) yields same before and after pad for each axis. (pad,) or int is a shortcut for before = after = pad width for all axes.</p> </dd> <dt>
<code>mode : str or function</code> </dt> <dd>
<p class="first">One of the following string values or a user supplied function.</p> <dl class="last docutils"> <dt>‘constant’</dt> <dd>
<p class="first last">Pads with a constant value.</p> </dd> <dt>‘edge’</dt> <dd>
<p class="first last">Pads with the edge values of array.</p> </dd> <dt>‘linear_ramp’</dt> <dd>
<p class="first last">Pads with the linear ramp between end_value and the array edge value.</p> </dd> <dt>‘maximum’</dt> <dd>
<p class="first last">Pads with the maximum value of all or part of the vector along each axis.</p> </dd> <dt>‘mean’</dt> <dd>
<p class="first last">Pads with the mean value of all or part of the vector along each axis.</p> </dd> <dt>‘median’</dt> <dd>
<p class="first last">Pads with the median value of all or part of the vector along each axis.</p> </dd> <dt>‘minimum’</dt> <dd>
<p class="first last">Pads with the minimum value of all or part of the vector along each axis.</p> </dd> <dt>‘reflect’</dt> <dd>
<p class="first last">Pads with the reflection of the vector mirrored on the first and last values of the vector along each axis.</p> </dd> <dt>‘symmetric’</dt> <dd>
<p class="first last">Pads with the reflection of the vector mirrored along the edge of the array.</p> </dd> <dt>‘wrap’</dt> <dd>
<p class="first last">Pads with the wrap of the vector along the axis. The first values are used to pad the end and the end values are used to pad the beginning.</p> </dd> <dt>&lt;function&gt;</dt> <dd>
<p class="first last">Padding function, see Notes.</p> </dd> </dl> </dd> <dt>
<code>stat_length : sequence or int, optional</code> </dt> <dd>
<p class="first">Used in ‘maximum’, ‘mean’, ‘median’, and ‘minimum’. Number of values at edge of each axis used to calculate the statistic value.</p> <p>((before_1, after_1), … (before_N, after_N)) unique statistic lengths for each axis.</p> <p>((before, after),) yields same before and after statistic lengths for each axis.</p> <p>(stat_length,) or int is a shortcut for before = after = statistic length for all axes.</p> <p class="last">Default is <code>None</code>, to use the entire axis.</p> </dd> <dt>
<code>constant_values : sequence or int, optional</code> </dt> <dd>
<p class="first">Used in ‘constant’. The values to set the padded values for each axis.</p> <p>((before_1, after_1), … (before_N, after_N)) unique pad constants for each axis.</p> <p>((before, after),) yields same before and after constants for each axis.</p> <p>(constant,) or int is a shortcut for before = after = constant for all axes.</p> <p class="last">Default is 0.</p> </dd> <dt>
<code>end_values : sequence or int, optional</code> </dt> <dd>
<p class="first">Used in ‘linear_ramp’. The values used for the ending value of the linear_ramp and that will form the edge of the padded array.</p> <p>((before_1, after_1), … (before_N, after_N)) unique end values for each axis.</p> <p>((before, after),) yields same before and after end values for each axis.</p> <p>(constant,) or int is a shortcut for before = after = end value for all axes.</p> <p class="last">Default is 0.</p> </dd> <dt>
<code>reflect_type : {‘even’, ‘odd’}, optional</code> </dt> <dd>
<p class="first last">Used in ‘reflect’, and ‘symmetric’. The ‘even’ style is the default with an unaltered reflection around the edge value. For the ‘odd’ style, the extented part of the array is created by subtracting the reflected values from two times the edge value.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>pad : ndarray</code> </dt> <dd>
<p class="first last">Padded array of rank equal to <code>array</code> with shape increased according to <code>pad_width</code>.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <div class="versionadded"> <p><span class="versionmodified">New in version 1.7.0.</span></p> </div> <p>For an array with rank greater than 1, some of the padding of later axes is calculated from padding of previous axes. This is easiest to think about with a rank 2 array where the corners of the padded array are calculated by using padded values from the first axis.</p> <p>The padding function, if used, should return a rank 1 array equal in length to the vector argument with padded values replaced. It has the following signature:</p> <pre data-language="python">padding_func(vector, iaxis_pad_width, iaxis, kwargs)
</pre> <p>where</p>  <dl class="docutils"> <dt>
<code>vector : ndarray</code> </dt> <dd>A rank 1 array already padded with zeros. Padded values are vector[:pad_tuple[0]] and vector[-pad_tuple[1]:].</dd> <dt>
<code>iaxis_pad_width : tuple</code> </dt> <dd>A 2-tuple of ints, iaxis_pad_width[0] represents the number of values padded at the beginning of vector where iaxis_pad_width[1] represents the number of values padded at the end of vector.</dd> <dt>
<code>iaxis : int</code> </dt> <dd>The axis currently being calculated.</dd> <dt>
<code>kwargs : dict</code> </dt> <dd>Any keyword arguments the function requires.</dd> </dl>  <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; np.pad(a, (2,3), 'constant', constant_values=(4, 6))
array([4, 4, 1, 2, 3, 4, 5, 6, 6, 6])
</pre> <pre data-language="python">&gt;&gt;&gt; np.pad(a, (2, 3), 'edge')
array([1, 1, 1, 2, 3, 4, 5, 5, 5, 5])
</pre> <pre data-language="python">&gt;&gt;&gt; np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4))
array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])
</pre> <pre data-language="python">&gt;&gt;&gt; np.pad(a, (2,), 'maximum')
array([5, 5, 1, 2, 3, 4, 5, 5, 5])
</pre> <pre data-language="python">&gt;&gt;&gt; np.pad(a, (2,), 'mean')
array([3, 3, 1, 2, 3, 4, 5, 3, 3])
</pre> <pre data-language="python">&gt;&gt;&gt; np.pad(a, (2,), 'median')
array([3, 3, 1, 2, 3, 4, 5, 3, 3])
</pre> <pre data-language="python">&gt;&gt;&gt; a = [[1, 2], [3, 4]]
&gt;&gt;&gt; np.pad(a, ((3, 2), (2, 3)), 'minimum')
array([[1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [3, 3, 3, 4, 3, 3, 3],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1]])
</pre> <pre data-language="python">&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; np.pad(a, (2, 3), 'reflect')
array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])
</pre> <pre data-language="python">&gt;&gt;&gt; np.pad(a, (2, 3), 'reflect', reflect_type='odd')
array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])
</pre> <pre data-language="python">&gt;&gt;&gt; np.pad(a, (2, 3), 'symmetric')
array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])
</pre> <pre data-language="python">&gt;&gt;&gt; np.pad(a, (2, 3), 'symmetric', reflect_type='odd')
array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])
</pre> <pre data-language="python">&gt;&gt;&gt; np.pad(a, (2, 3), 'wrap')
array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])
</pre> <pre data-language="python">&gt;&gt;&gt; def pad_with(vector, pad_width, iaxis, kwargs):
...     pad_value = kwargs.get('padder', 10)
...     vector[:pad_width[0]] = pad_value
...     vector[-pad_width[1]:] = pad_value
...     return vector
&gt;&gt;&gt; a = np.arange(6)
&gt;&gt;&gt; a = a.reshape((2, 3))
&gt;&gt;&gt; np.pad(a, 2, pad_with)
array([[10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10,  0,  1,  2, 10, 10],
       [10, 10,  3,  4,  5, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10]])
&gt;&gt;&gt; np.pad(a, 2, pad_with, padder=100)
array([[100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100,   0,   1,   2, 100, 100],
       [100, 100,   3,   4,   5, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100]])
</pre> </dd>
</dl>   <h2 id="crop">crop</h2> <dl class="function"> <dt id="skimage.util.crop">
<code>skimage.util.crop(ar, crop_width, copy=False, order='K')</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/arraycrop.py#L142"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Crop array <code>ar</code> by <code>crop_width</code> along each dimension.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>ar : array-like of rank N</code> </dt> <dd>
<p class="first last">Input array.</p> </dd> <dt>
<code>crop_width : {sequence, int}</code> </dt> <dd>
<p class="first last">Number of values to remove from the edges of each axis. <code>((before_1, after_1),</code> … <code>(before_N, after_N))</code> specifies unique crop widths at the start and end of each axis. <code>((before, after),)</code> specifies a fixed start and end crop for every axis. <code>(n,)</code> or <code>n</code> for integer <code>n</code> is a shortcut for before = after = <code>n</code> for all axes.</p> </dd> <dt>
<code>copy : bool, optional</code> </dt> <dd>
<p class="first last">If <code>True</code>, ensure the returned array is a contiguous copy. Normally, a crop operation will return a discontiguous view of the underlying input array.</p> </dd> <dt>
<code>order : {‘C’, ‘F’, ‘A’, ‘K’}, optional</code> </dt> <dd>
<p class="first last">If <code>copy==True</code>, control the memory layout of the copy. See <code>np.copy</code>.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cropped : array</code> </dt> <dd>
<p class="first last">The cropped array. If <code>copy=False</code> (default), this is a sliced view of the input array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl>   <h2 id="montage">montage</h2> <dl class="function"> <dt id="skimage.util.montage">
<code>skimage.util.montage(arr_in, fill='mean', rescale_intensity=False, grid_shape=None, padding_width=0, multichannel=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/_montage.py#L9"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a montage of several single- or multichannel images.</p> <p>Create a rectangular montage from an input array representing an ensemble of equally shaped single- (gray) or multichannel (color) images.</p> <p>For example, <code>montage(arr_in)</code> called with the following <code>arr_in</code></p> <table class="docutils">   <tr>
<td>1</td> <td>2</td> <td>3</td> </tr>  </table> <p>will return</p> <table class="docutils">   <tr>
<td>1</td> <td>2</td> </tr> <tr>
<td>3</td> <td>
<ul class="first last simple"> <li> </li>
</ul> </td> </tr>  </table> <p>where the ‘*’ patch will be determined by the <code>fill</code> parameter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>arr_in : (K, M, N[, C]) ndarray</code> </dt> <dd>
<p class="first last">An array representing an ensemble of <code>K</code> images of equal shape.</p> </dd> <dt>
<code>fill : float or array-like of floats or ‘mean’, optional</code> </dt> <dd>
<p class="first last">Value to fill the padding areas and/or the extra tiles in the output array. Has to be <code>float</code> for single channel collections. For multichannel collections has to be an array-like of shape of number of channels. If <code>mean</code>, uses the mean value over all images.</p> </dd> <dt>
<code>rescale_intensity : bool, optional</code> </dt> <dd>
<p class="first last">Whether to rescale the intensity of each image to [0, 1].</p> </dd> <dt>
<code>grid_shape : tuple, optional</code> </dt> <dd>
<p class="first last">The desired grid shape for the montage <code>(ntiles_row, ntiles_column)</code>. The default aspect ratio is square.</p> </dd> <dt>
<code>padding_width : int, optional</code> </dt> <dd>
<p class="first last">The size of the spacing between the tiles and between the tiles and the borders. If non-zero, makes the boundaries of individual images easier to perceive.</p> </dd> <dt>
<code>multichannel : boolean, optional</code> </dt> <dd>
<p class="first last">If True, the last <code>arr_in</code> dimension is threated as a color channel, otherwise as spatial.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>arr_out : (K*(M+p)+p, K*(N+p)+p[, C]) ndarray</code> </dt> <dd>
<p class="first last">Output array with input images glued together (including padding <code>p</code>).</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.util import montage
&gt;&gt;&gt; arr_in = np.arange(3 * 2 * 2).reshape(3, 2, 2)
&gt;&gt;&gt; arr_in  # doctest: +NORMALIZE_WHITESPACE
array([[[ 0,  1],
        [ 2,  3]],
       [[ 4,  5],
        [ 6,  7]],
       [[ 8,  9],
        [10, 11]]])
&gt;&gt;&gt; arr_out = montage(arr_in)
&gt;&gt;&gt; arr_out.shape
(4, 4)
&gt;&gt;&gt; arr_out
array([[ 0,  1,  4,  5],
       [ 2,  3,  6,  7],
       [ 8,  9,  5,  5],
       [10, 11,  5,  5]])
&gt;&gt;&gt; arr_in.mean()
5.5
&gt;&gt;&gt; arr_out_nonsquare = montage(arr_in, grid_shape=(1, 3))
&gt;&gt;&gt; arr_out_nonsquare
array([[ 0,  1,  4,  5,  8,  9],
       [ 2,  3,  6,  7, 10, 11]])
&gt;&gt;&gt; arr_out_nonsquare.shape
(2, 6)
</pre> </dd>
</dl>   <h2 id="montage2d">montage2d</h2> <dl class="function"> <dt id="skimage.util.montage2d">
<code>skimage.util.montage2d(arr_in, fill='mean', rescale_intensity=False, grid_shape=None, padding_width=0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/_shared/utils.py#L59"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>montage</code> instead.</p> <p>Create a 2-dimensional ‘montage’ from a 3-dimensional input array representing an ensemble of equally shaped 2-dimensional images.</p> <p>For example, <code>montage2d(arr_in, fill)</code> with the following <code>arr_in</code></p> <table class="docutils">   <tr>
<td>1</td> <td>2</td> <td>3</td> </tr>  </table> <p>will return:</p> <table class="docutils">   <tr>
<td>1</td> <td>2</td> </tr> <tr>
<td>3</td> <td>
<ul class="first last simple"> <li> </li>
</ul> </td> </tr>  </table> <p>Where the ‘*’ patch will be determined by the <code>fill</code> parameter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>arr_in : ndarray, shape=[n_images, height, width]</code> </dt> <dd>
<p class="first last">3-dimensional input array representing an ensemble of n_images of equal shape (i.e. [height, width]).</p> </dd> <dt>
<code>fill : float or ‘mean’, optional</code> </dt> <dd>
<p class="first last">How to fill the 2-dimensional output array when sqrt(n_images) is not an integer. If ‘mean’ is chosen, then fill = arr_in.mean().</p> </dd> <dt>
<code>rescale_intensity : bool, optional</code> </dt> <dd>
<p class="first last">Whether to rescale the intensity of each image to [0, 1].</p> </dd> <dt>
<code>grid_shape : tuple, optional</code> </dt> <dd>
<p class="first last">The desired grid shape for the montage (tiles_y, tiles_x). The default aspect ratio is square.</p> </dd> <dt>
<code>padding_width : int, optional</code> </dt> <dd>
<p class="first last">The size of the spacing between the tiles to make the boundaries of individual frames easier to see.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>arr_out : ndarray, shape=[alpha * height, alpha * width]</code> </dt> <dd>
<p class="first last">Output array where ‘alpha’ has been determined automatically to fit (at least) the <code>n_images</code> in <code>arr_in</code>.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.util import montage2d
&gt;&gt;&gt; arr_in = np.arange(3 * 2 * 2).reshape(3, 2, 2)
&gt;&gt;&gt; arr_in  # doctest: +NORMALIZE_WHITESPACE
array([[[ 0,  1],
        [ 2,  3]],
       [[ 4,  5],
        [ 6,  7]],
       [[ 8,  9],
        [10, 11]]])
&gt;&gt;&gt; arr_out = montage2d(arr_in)
&gt;&gt;&gt; arr_out.shape
(4, 4)
&gt;&gt;&gt; arr_out
array([[ 0,  1,  4,  5],
       [ 2,  3,  6,  7],
       [ 8,  9,  5,  5],
       [10, 11,  5,  5]])
&gt;&gt;&gt; arr_in.mean()
5.5
&gt;&gt;&gt; arr_out_nonsquare = montage2d(arr_in, grid_shape=(1, 3))
&gt;&gt;&gt; arr_out_nonsquare
array([[ 0,  1,  4,  5,  8,  9],
       [ 2,  3,  6,  7, 10, 11]])
&gt;&gt;&gt; arr_out_nonsquare.shape
(2, 6)
</pre> </dd>
</dl>   <h2 id="random-noise">random_noise</h2> <dl class="function"> <dt id="skimage.util.random_noise">
<code>skimage.util.random_noise(image, mode='gaussian', seed=None, clip=True, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/noise.py#L8"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Function to add random noise of various types to a floating-point image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : ndarray</code> </dt> <dd>
<p class="first last">Input image data. Will be converted to float.</p> </dd> <dt>
<code>mode : str</code> </dt> <dd>
<p class="first">One of the following strings, selecting the type of noise to add:</p> <ul class="last simple"> <li>‘gaussian’ Gaussian-distributed additive noise.</li> <li>
<dl class="first docutils"> <dt>‘localvar’ Gaussian-distributed additive noise, with specified</dt> <dd>local variance at each point of <code>image</code>
</dd> </dl> </li> <li>‘poisson’ Poisson-distributed noise generated from the data.</li> <li>‘salt’ Replaces random pixels with 1.</li> <li>
<dl class="first docutils"> <dt>‘pepper’ Replaces random pixels with 0 (for unsigned images) or</dt> <dd>-1 (for signed images).</dd> </dl> </li> <li>
<dl class="first docutils"> <dt>
<code>‘s&amp;p’ Replaces random pixels with either 1 or low_val, where</code> </dt> <dd>
<code>low_val</code> is 0 for unsigned images or -1 for signed images.</dd> </dl> </li> <li>
<dl class="first docutils"> <dt>‘speckle’ Multiplicative noise using out = image + n*image, where</dt> <dd>n is uniform noise with specified mean &amp; variance.</dd> </dl> </li> </ul> </dd> <dt>
<code>seed : int</code> </dt> <dd>
<p class="first last">If provided, this will set the random seed before generating noise, for valid pseudo-random comparisons.</p> </dd> <dt>
<code>clip : bool</code> </dt> <dd>
<p class="first last">If True (default), the output will be clipped after noise applied for modes <code>‘speckle’</code>, <code>‘poisson’</code>, and <code>‘gaussian’</code>. This is needed to maintain the proper image data range. If False, clipping is not applied, and the output may extend beyond the range [-1, 1].</p> </dd> <dt>
<code>mean : float</code> </dt> <dd>
<p class="first last">Mean of random distribution. Used in ‘gaussian’ and ‘speckle’. Default : 0.</p> </dd> <dt>
<code>var : float</code> </dt> <dd>
<p class="first last">Variance of random distribution. Used in ‘gaussian’ and ‘speckle’. Note: variance = (standard deviation) ** 2. Default : 0.01</p> </dd> <dt>
<code>local_vars : ndarray</code> </dt> <dd>
<p class="first last">Array of positive floats, same shape as <code>image</code>, defining the local variance at every image point. Used in ‘localvar’.</p> </dd> <dt>
<code>amount : float</code> </dt> <dd>
<p class="first last">Proportion of image pixels to replace with noise on range [0, 1]. Used in ‘salt’, ‘pepper’, and ‘salt &amp; pepper’. Default : 0.05</p> </dd> <dt>
<code>salt_vs_pepper : float</code> </dt> <dd>
<p class="first last">Proportion of salt vs. pepper noise for ‘s&amp;p’ on range [0, 1]. Higher values represent more salt. Default : 0.5 (equal amounts)</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>out : ndarray</code> </dt> <dd>
<p class="first last">Output floating-point image data on range [0, 1] or [-1, 1] if the input <code>image</code> was unsigned or signed, respectively.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Speckle, Poisson, Localvar, and Gaussian noise may generate noise outside the valid image range. The default is to clip (not alias) these values, but they may be preserved by setting <code>clip=False</code>. Note that in this case the output may contain values outside the ranges [0, 1] or [-1, 1]. Use this option with care.</p> <p>Because of the prevalence of exclusively positive floating-point images in intermediate calculations, it is not possible to intuit if an input is signed based on dtype alone. Instead, negative values are explicity searched for. Only if found does this function assume signed input. Unexpected results only occur in rare, poorly exposes cases (e.g. if all values are above 50 percent gray in a signed <code>image</code>). In this event, manually scaling the input to the positive domain will solve the problem.</p> <p>The Poisson distribution is only defined for positive integers. To apply this noise type, the number of unique values in the image is found and the next round power of two is used to scale up the floating-point result, after which it is scaled back down to the floating-point image range.</p> <p>To generate Poisson noise against a signed image, the signed image is temporarily converted to an unsigned image in the floating point domain, Poisson noise is generated, then it is returned to the original range.</p> </dd>
</dl>   <h2 id="regular-grid">regular_grid</h2> <dl class="function"> <dt id="skimage.util.regular_grid">
<code>skimage.util.regular_grid(ar_shape, n_points)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/_regular_grid.py#L4"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find <code>n_points</code> regularly spaced along <code>ar_shape</code>.</p> <p>The returned points (as slices) should be as close to cubically-spaced as possible. Essentially, the points are spaced by the Nth root of the input array size, where N is the number of dimensions. However, if an array dimension cannot fit a full step size, it is “discarded”, and the computation is done for only the remaining dimensions.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>ar_shape : array-like of ints</code> </dt> <dd>
<p class="first last">The shape of the space embedding the grid. <code>len(ar_shape)</code> is the number of dimensions.</p> </dd> <dt>
<code>n_points : int</code> </dt> <dd>
<p class="first last">The (approximate) number of points to embed in the space.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>slices : tuple of slice objects</code> </dt> <dd>
<p class="first">A slice along each dimension of <code>ar_shape</code>, such that the intersection of all the slices give the coordinates of regularly spaced points.</p> <div class="last versionchanged"> <p><span class="versionmodified">Changed in version 0.14.1: </span>In scikit-image 0.14.1 and 0.15, the return type was changed from a list to a tuple to ensure <a class="reference external" href="https://github.com/numpy/numpy/blob/master/doc/release/1.15.0-notes.rst#deprecations">compatibility with Numpy 1.15</a> and higher. If your code requires the returned result to be a list, you may convert the output of this function to a list with:</p> <pre data-language="python">&gt;&gt;&gt; result = list(regular_grid(ar_shape=(3, 20, 40), n_points=8))
</pre> </div> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; ar = np.zeros((20, 40))
&gt;&gt;&gt; g = regular_grid(ar.shape, 8)
&gt;&gt;&gt; g
(slice(5, None, 10), slice(5, None, 10))
&gt;&gt;&gt; ar[g] = 1
&gt;&gt;&gt; ar.sum()
8.0
&gt;&gt;&gt; ar = np.zeros((20, 40))
&gt;&gt;&gt; g = regular_grid(ar.shape, 32)
&gt;&gt;&gt; g
(slice(2, None, 5), slice(2, None, 5))
&gt;&gt;&gt; ar[g] = 1
&gt;&gt;&gt; ar.sum()
32.0
&gt;&gt;&gt; ar = np.zeros((3, 20, 40))
&gt;&gt;&gt; g = regular_grid(ar.shape, 8)
&gt;&gt;&gt; g
(slice(1, None, 3), slice(5, None, 10), slice(5, None, 10))
&gt;&gt;&gt; ar[g] = 1
&gt;&gt;&gt; ar.sum()
8.0
</pre> </dd>
</dl>   <h2 id="regular-seeds">regular_seeds</h2> <dl class="function"> <dt id="skimage.util.regular_seeds">
<code>skimage.util.regular_seeds(ar_shape, n_points, dtype=&lt;class 'int'&gt;)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/_regular_grid.py#L85"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return an image with ~`n_points` regularly-spaced nonzero pixels.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>ar_shape : tuple of int</code> </dt> <dd>
<p class="first last">The shape of the desired output image.</p> </dd> <dt>
<code>n_points : int</code> </dt> <dd>
<p class="first last">The desired number of nonzero points.</p> </dd> <dt>
<code>dtype : numpy data type, optional</code> </dt> <dd>
<p class="first last">The desired data type of the output.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>seed_img : array of int or bool</code> </dt> <dd>
<p class="first last">The desired image.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; regular_seeds((5, 5), 4)
array([[0, 0, 0, 0, 0],
       [0, 1, 0, 2, 0],
       [0, 0, 0, 0, 0],
       [0, 3, 0, 4, 0],
       [0, 0, 0, 0, 0]])
</pre> </dd>
</dl>   <h2 id="apply-parallel">apply_parallel</h2> <dl class="function"> <dt id="skimage.util.apply_parallel">
<code>skimage.util.apply_parallel(function, array, chunks=None, depth=0, mode=None, extra_arguments=(), extra_keywords={})</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/apply_parallel.py#L53"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Map a function in parallel across an array.</p> <p>Split an array into possibly overlapping chunks of a given depth and boundary type, call the given function in parallel on the chunks, combine the chunks and return the resulting array.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>function : function</code> </dt> <dd>
<p class="first last">Function to be mapped which takes an array as an argument.</p> </dd> <dt>
<code>array : numpy array</code> </dt> <dd>
<p class="first last">Array which the function will be applied to.</p> </dd> <dt>
<code>chunks : int, tuple, or tuple of tuples, optional</code> </dt> <dd>
<p class="first last">A single integer is interpreted as the length of one side of a square chunk that should be tiled across the array. One tuple of length <code>array.ndim</code> represents the shape of a chunk, and it is tiled across the array. A list of tuples of length <code>ndim</code>, where each sub-tuple is a sequence of chunk sizes along the corresponding dimension. If None, the array is broken up into chunks based on the number of available cpus. More information about chunks is in the documentation <a class="reference external" href="https://dask.pydata.org/en/latest/array-design.html">here</a>.</p> </dd> <dt>
<code>depth : int, optional</code> </dt> <dd>
<p class="first last">Integer equal to the depth of the added boundary cells. Defaults to zero.</p> </dd> <dt>
<code>mode : {‘reflect’, ‘symmetric’, ‘periodic’, ‘wrap’, ‘nearest’, ‘edge’}, optional</code> </dt> <dd>
<p class="first last">type of external boundary padding.</p> </dd> <dt>
<code>extra_arguments : tuple, optional</code> </dt> <dd>
<p class="first last">Tuple of arguments to be passed to the function.</p> </dd> <dt>
<code>extra_keywords : dictionary, optional</code> </dt> <dd>
<p class="first last">Dictionary of keyword arguments to be passed to the function.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Numpy edge modes ‘symmetric’, ‘wrap’, and ‘edge’ are converted to the equivalent <code>dask</code> boundary modes ‘reflect’, ‘periodic’ and ‘nearest’, respectively.</p> </dd>
</dl>   <h2 id="invert">invert</h2> <dl class="function"> <dt id="skimage.util.invert">
<code>skimage.util.invert(image, signed_float=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/_invert.py#L5"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Invert an image.</p> <p>Invert the intensity range of the input image, so that the dtype maximum is now the dtype minimum, and vice-versa. This operation is slightly different depending on the input dtype:</p> <ul class="simple"> <li>unsigned integers: subtract the image from the dtype maximum</li> <li>signed integers: subtract the image from -1 (see Notes)</li> <li>floats: subtract the image from 1 (if signed_float is False, so we assume the image is unsigned), or from 0 (if signed_float is True).</li> </ul> <p>See the examples for clarification.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>image : ndarray</code> </dt> <dd>
<p class="first last">Input image.</p> </dd> <dt>
<code>signed_float : bool, optional</code> </dt> <dd>
<p class="first last">If True and the image is of type float, the range is assumed to be [-1, 1]. If False and the image is of type float, the range is assumed to be [0, 1].</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>inverted : ndarray</code> </dt> <dd>
<p class="first last">Inverted image.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Ideally, for signed integers we would simply multiply by -1. However, signed integer ranges are asymmetric. For example, for np.int8, the range of possible values is [-128, 127], so that -128 * -1 equals -128! By subtracting from -1, we correctly map the maximum dtype value to the minimum.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; img = np.array([[100,  0, 200],
...                 [  0, 50,   0],
...                 [ 30,  0, 255]], np.uint8)
&gt;&gt;&gt; invert(img)
array([[155, 255,  55],
       [255, 205, 255],
       [225, 255,   0]], dtype=uint8)
&gt;&gt;&gt; img2 = np.array([[ -2, 0, -128],
...                  [127, 0,    5]], np.int8)
&gt;&gt;&gt; invert(img2)
array([[   1,   -1,  127],
       [-128,   -1,   -6]], dtype=int8)
&gt;&gt;&gt; img3 = np.array([[ 0., 1., 0.5, 0.75]])
&gt;&gt;&gt; invert(img3)
array([[ 1.  ,  0.  ,  0.5 ,  0.25]])
&gt;&gt;&gt; img4 = np.array([[ 0., 1., -1., -0.25]])
&gt;&gt;&gt; invert(img4, signed_float=True)
array([[-0.  , -1.  ,  1.  ,  0.25]])
</pre> </dd>
</dl>   <h2 id="unique-rows">unique_rows</h2> <dl class="function"> <dt id="skimage.util.unique_rows">
<code>skimage.util.unique_rows(ar)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.14.1/skimage/util/unique.py#L4"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Remove repeated rows from a 2D array.</p> <p>In particular, if given an array of coordinates of shape (Npoints, Ndim), it will remove repeated points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>ar : 2-D ndarray</code> </dt> <dd>
<p class="first last">The input array.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>ar_out : 2-D ndarray</code> </dt> <dd>
<p class="first last">A copy of the input array with repeated rows removed.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Raises:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ValueError : if ar is not two-dimensional.</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The function will generate a copy of <code>ar</code> if it is not C-contiguous, which will negatively affect performance for large input arrays.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; ar = np.array([[1, 0, 1],
...                [0, 1, 0],
...                [1, 0, 1]], np.uint8)
&gt;&gt;&gt; unique_rows(ar)
array([[0, 1, 0],
       [1, 0, 1]], dtype=uint8)
</pre> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="http://scikit-image.org/docs/0.14.x/api/skimage.util.html" class="_attribution-link">http://scikit-image.org/docs/0.14.x/api/skimage.util.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
