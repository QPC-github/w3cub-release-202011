
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Introspecting and Extending Trio With trio.hazmat - Trio - W3cubDocs</title>
  
  <meta name="description" content=" You probably don’t want to use this module. ">
  <meta name="keywords" content="introspecting, and, extending, trio, with, hazmat">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/trio/reference-hazmat.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/trio.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/trio/" class="_nav-link" title="" style="margin-left:0;">Trio</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _simple">
				
				
<h1>Introspecting and extending Trio with <code class="docutils literal notranslate"><span class="pre">trio.hazmat</span></code>
</h1> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>You probably don’t want to use this module.</p> </blockquote> <p><a class="reference internal" href="#module-trio.hazmat" title="trio.hazmat"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.hazmat</span></code></a> is Trio’s “hazardous materials” layer: it contains APIs useful for introspecting and extending Trio. If you’re writing ordinary, everyday code, then you can ignore this module completely. But sometimes you need something a bit lower level. Here are some examples of situations where you should reach for <a class="reference internal" href="#module-trio.hazmat" title="trio.hazmat"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.hazmat</span></code></a>:</p> <ul class="simple"> <li><p>You want to implement a new <a class="reference internal" href="reference-core#synchronization"><span class="std std-ref">synchronization primitive</span></a> that Trio doesn’t (yet) provide, like a reader-writer lock.</p></li> <li><p>You want to extract low-level metrics to monitor the health of your application.</p></li> <li><p>You want to add support for a low-level operating system interface that Trio doesn’t (yet) expose, like watching a filesystem directory for changes.</p></li> <li><p>You want to implement an interface for calling between Trio and another event loop within the same process.</p></li> <li><p>You’re writing a debugger and want to visualize Trio’s task tree.</p></li> <li><p>You need to interoperate with a C library whose API exposes raw file descriptors.</p></li> </ul> <p>Using <a class="reference internal" href="#module-trio.hazmat" title="trio.hazmat"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.hazmat</span></code></a> isn’t really <em>that</em> hazardous; in fact you’re already using it – it’s how most of the functionality described in previous chapters is implemented. The APIs described here have strictly defined and carefully documented semantics, and are perfectly safe – <em>if</em> you read carefully and take proper precautions. Some of those strict semantics have <a class="reference external" href="https://en.wikipedia.org/wiki/Rabbit_of_Caerbannog">nasty big pointy teeth</a>. If you make a mistake, Trio may not be able to handle it gracefully; conventions and guarantees that are followed strictly in the rest of Trio do not always apply. Using this module makes it your responsibility to think through and handle the nasty cases to expose a friendly Trio-style API to your users.</p>  <h2>Debugging and instrumentation</h2> <p>Trio tries hard to provide useful hooks for debugging and instrumentation. Some are documented above (the nursery introspection attributes, <a class="reference internal" href="reference-core#trio.Lock.statistics" title="trio.Lock.statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.Lock.statistics()</span></code></a>, etc.). Here are some more.</p>  <h3>Global statistics</h3> <dl class="function"> <h3 id="trio.hazmat.current_statistics"><code>trio.hazmat.current_statistics()</code></h3> <dd>
<p>Returns an object containing run-loop-level debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_living</span></code> (int): The number of tasks that have been spawned and not yet exited.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_runnable</span></code> (int): The number of tasks that are currently queued on the run queue (as opposed to blocked waiting for something to happen).</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">seconds_to_next_deadline</span></code> (float): The time until the next pending cancel scope deadline. May be negative if the deadline has expired but we haven’t yet processed cancellations. May be <a class="reference external" href="https://docs.python.org/3/library/math.html#math.inf" title="(in Python v3.7)"><code class="xref py py-data docutils literal notranslate"><span class="pre">inf</span></code></a> if there are no pending deadlines.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">run_sync_soon_queue_size</span></code> (int): The number of unprocessed callbacks queued via <a class="reference internal" href="#trio.hazmat.TrioToken.run_sync_soon" title="trio.hazmat.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.hazmat.TrioToken.run_sync_soon()</span></code></a>.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">io_statistics</span></code> (object): Some statistics from Trio’s I/O backend. This always has an attribute <code class="docutils literal notranslate"><span class="pre">backend</span></code> which is a string naming which operating-system-specific I/O backend is in use; the other attributes vary between backends.</p></li> </ul> </dd>
</dl>   <h3>The current clock</h3> <dl class="function"> <h3 id="trio.hazmat.current_clock"><code>trio.hazmat.current_clock()</code></h3> <dd>
<p>Returns the current <a class="reference internal" href="reference-core#trio.abc.Clock" title="trio.abc.Clock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clock</span></code></a>.</p> </dd>
</dl>   <h3>Instrument API</h3> <p>The instrument API provides a standard way to add custom instrumentation to the run loop. Want to make a histogram of scheduling latencies, log a stack trace of any task that blocks the run loop for &gt;50 ms, or measure what percentage of your process’s running time is spent waiting for I/O? This is the place.</p> <p>The general idea is that at any given moment, <a class="reference internal" href="reference-core#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> maintains a set of “instruments”, which are objects that implement the <a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Instrument</span></code></a> interface. When an interesting event happens, it loops over these instruments and notifies them by calling an appropriate method. The tutorial has <a class="reference internal" href="https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example"><span class="std std-ref">a simple example of using this for tracing</span></a>.</p> <p>Since this hooks into Trio at a rather low level, you do have to be careful. The callbacks are run synchronously, and in many cases if they error out then there isn’t any plausible way to propagate this exception (for instance, we might be deep in the guts of the exception propagation machinery…). Therefore our <a class="reference external" href="https://github.com/python-trio/trio/issues/47">current strategy</a> for handling exceptions raised by instruments is to (a) log an exception to the <code class="docutils literal notranslate"><span class="pre">"trio.abc.Instrument"</span></code> logger, which by default prints a stack trace to standard error and (b) disable the offending instrument.</p> <p>You can register an initial list of instruments by passing them to <a class="reference internal" href="reference-core#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>. <a class="reference internal" href="#trio.hazmat.add_instrument" title="trio.hazmat.add_instrument"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_instrument()</span></code></a> and <a class="reference internal" href="#trio.hazmat.remove_instrument" title="trio.hazmat.remove_instrument"><code class="xref py py-func docutils literal notranslate"><span class="pre">remove_instrument()</span></code></a> let you add and remove instruments at runtime.</p> <dl class="function"> <h3 id="trio.hazmat.add_instrument"><code>trio.hazmat.add_instrument(instrument)</code></h3> <dd>
<p>Start instrumenting the current run loop with the given instrument.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>instrument</code> (<a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><em>trio.abc.Instrument</em></a>) – The instrument to activate.</p> </dd> </dl> <p>If <code class="docutils literal notranslate"><span class="pre">instrument</span></code> is already active, does nothing.</p> </dd>
</dl> <dl class="function"> <h3 id="trio.hazmat.remove_instrument"><code>trio.hazmat.remove_instrument(instrument)</code></h3> <dd>
<p>Stop instrumenting the current run loop with the given instrument.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>instrument</code> (<a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><em>trio.abc.Instrument</em></a>) – The instrument to de-activate.</p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.7)"><code>KeyError</code></a> – if the instrument is not currently active. This could occur either because you never added it, or because you added it and then it raised an unhandled exception and was automatically deactivated.</p> </dd> </dl> </dd>
</dl> <p>And here’s the interface to implement if you want to build your own <a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instrument</span></code></a>:</p> <dl class="class"> <h3 id="trio.abc.Instrument"><code><em>class</em> trio.abc.Instrument</code></h3> <dd>
<p>The interface for run loop instrumentation.</p> <p>Instruments don’t have to inherit from this abstract base class, and all of these methods are optional. This class serves mostly as documentation.</p> <dl class="method"> <h3 id="trio.abc.Instrument.after_io_wait"><code>after_io_wait(timeout)</code></h3> <dd>
<p>Called after handling pending I/O.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>timeout</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The number of seconds we were willing to wait. This much time may or may not have elapsed, depending on whether any I/O was ready.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.abc.Instrument.after_run"><code>after_run()</code></h3> <dd>
<p>Called just before <a class="reference internal" href="reference-core#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> returns.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.abc.Instrument.after_task_step"><code>after_task_step(task)</code></h3> <dd>
<p>Called when we return to the main run loop after a task has yielded.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>task</code> (<a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><em>trio.hazmat.Task</em></a>) – The task that just ran.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.abc.Instrument.before_io_wait"><code>before_io_wait(timeout)</code></h3> <dd>
<p>Called before blocking to wait for I/O readiness.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>timeout</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – The number of seconds we are willing to wait.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.abc.Instrument.before_run"><code>before_run()</code></h3> <dd>
<p>Called at the beginning of <a class="reference internal" href="reference-core#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.abc.Instrument.before_task_step"><code>before_task_step(task)</code></h3> <dd>
<p>Called immediately before we resume running the given task.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>task</code> (<a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><em>trio.hazmat.Task</em></a>) – The task that is about to run.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.abc.Instrument.task_exited"><code>task_exited(task)</code></h3> <dd>
<p>Called when the given task exits.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>task</code> (<a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><em>trio.hazmat.Task</em></a>) – The finished task.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.abc.Instrument.task_scheduled"><code>task_scheduled(task)</code></h3> <dd>
<p>Called when the given task becomes runnable.</p> <p>It may still be some time before it actually runs, if there are other runnable tasks ahead of it.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>task</code> (<a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><em>trio.hazmat.Task</em></a>) – The task that became runnable.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.abc.Instrument.task_spawned"><code>task_spawned(task)</code></h3> <dd>
<p>Called when the given task is created.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>task</code> (<a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><em>trio.hazmat.Task</em></a>) – The new task.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <p>The tutorial has a <a class="reference internal" href="https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example"><span class="std std-ref">fully-worked example</span></a> of defining a custom instrument to log Trio’s internal scheduling decisions.</p>    <h2>Low-level I/O primitives</h2> <p>Different environments expose different low-level APIs for performing async I/O. <a class="reference internal" href="#module-trio.hazmat" title="trio.hazmat"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.hazmat</span></code></a> exposes these APIs in a relatively direct way, so as to allow maximum power and flexibility for higher level code. However, this means that the exact API provided may vary depending on what system Trio is running on.</p>  <h3>Universally available API</h3> <p>All environments provide the following functions:</p> <dl class="function"> <h3 id="trio.hazmat.wait_readable"><code><em>await</em> trio.hazmat.wait_readable(obj)</code></h3> <dd>
<p>Block until the kernel reports that the given object is readable.</p> <p>On Unix systems, <code class="docutils literal notranslate"><span class="pre">obj</span></code> must either be an integer file descriptor, or else an object with a <code class="docutils literal notranslate"><span class="pre">.fileno()</span></code> method which returns an integer file descriptor. Any kind of file descriptor can be passed, though the exact semantics will depend on your kernel. For example, this probably won’t do anything useful for on-disk files.</p> <p>On Windows systems, <code class="docutils literal notranslate"><span class="pre">obj</span></code> must either be an integer <code class="docutils literal notranslate"><span class="pre">SOCKET</span></code> handle, or else an object with a <code class="docutils literal notranslate"><span class="pre">.fileno()</span></code> method which returns an integer <code class="docutils literal notranslate"><span class="pre">SOCKET</span></code> handle. File descriptors aren’t supported, and neither are handles that refer to anything besides a <code class="docutils literal notranslate"><span class="pre">SOCKET</span></code>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="reference-core#trio.BusyResourceError" title="trio.BusyResourceError"><code>trio.BusyResourceError</code></a> – if another task is already waiting for the given socket to become readable.</p></li> <li><p><a class="reference internal" href="reference-core#trio.ClosedResourceError" title="trio.ClosedResourceError"><code>trio.ClosedResourceError</code></a> – if another task calls <a class="reference internal" href="#trio.hazmat.notify_closing" title="trio.hazmat.notify_closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">notify_closing()</span></code></a> while this function is still working.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <h3 id="trio.hazmat.wait_writable"><code><em>await</em> trio.hazmat.wait_writable(obj)</code></h3> <dd>
<p>Block until the kernel reports that the given object is writable.</p> <p>See <a class="reference internal" href="#trio.hazmat.wait_readable" title="trio.hazmat.wait_readable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait_readable</span></code></a> for the definition of <code class="docutils literal notranslate"><span class="pre">obj</span></code>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="reference-core#trio.BusyResourceError" title="trio.BusyResourceError"><code>trio.BusyResourceError</code></a> – if another task is already waiting for the given socket to become writable.</p></li> <li><p><a class="reference internal" href="reference-core#trio.ClosedResourceError" title="trio.ClosedResourceError"><code>trio.ClosedResourceError</code></a> – if another task calls <a class="reference internal" href="#trio.hazmat.notify_closing" title="trio.hazmat.notify_closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">notify_closing()</span></code></a> while this function is still working.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="function"> <h3 id="trio.hazmat.notify_closing"><code>trio.hazmat.notify_closing(obj)</code></h3> <dd>
<p>Call this before closing a file descriptor or <code class="docutils literal notranslate"><span class="pre">SOCKET</span></code> handle that another task might be waiting on. This will cause any <a class="reference internal" href="#trio.hazmat.wait_readable" title="trio.hazmat.wait_readable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait_readable</span></code></a> or <a class="reference internal" href="#trio.hazmat.wait_writable" title="trio.hazmat.wait_writable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait_writable</span></code></a> calls to immediately raise <a class="reference internal" href="reference-core#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>.</p> <p>This doesn’t actually close the object – you still have to do that yourself afterwards.</p> </dd>
</dl>   <h3>Unix-specific API</h3> <p><a class="reference internal" href="#trio.hazmat.FdStream" title="trio.hazmat.FdStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FdStream</span></code></a> supports wrapping Unix files (such as a pipe or TTY) as a stream.</p> <p>If you have two different file descriptors for sending and receiving, and want to bundle them together into a single bidirectional <a class="reference internal" href="reference-io#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Stream</span></code></a>, then use <a class="reference internal" href="reference-io#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.StapledStream</span></code></a>:</p> <pre data-language="python">bidirectional_stream = trio.StapledStream(
    trio.hazmat.FdStream(write_fd),
    trio.hazmat.FdStream(read_fd)
)</pre> <dl class="class"> <h3 id="trio.hazmat.FdStream"><code><em>class</em> trio.hazmat.FdStream(fd: int)</code></h3> <dd>
<p>Bases: <a class="reference internal" href="reference-io#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Stream</span></code></a></p> <p>Represents a stream given the file descriptor to a pipe, TTY, etc.</p> <p><em>fd</em> must refer to a file that is open for reading and/or writing and supports non-blocking I/O (pipes and TTYs will work, on-disk files probably not). The returned stream takes ownership of the fd, so closing the stream will close the fd too. As with <a class="reference external" href="https://docs.python.org/3/library/os.html#os.fdopen" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">os.fdopen</span></code></a>, you should not directly use an fd after you have wrapped it in a stream using this function.</p> <p>To be used as a Trio stream, an open file must be placed in non-blocking mode. Unfortunately, this impacts all I/O that goes through the underlying open file, including I/O that uses a different file descriptor than the one that was passed to Trio. If other threads or processes are using file descriptors that are related through <a class="reference external" href="https://docs.python.org/3/library/os.html#os.dup" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">os.dup</span></code></a> or inheritance across <a class="reference external" href="https://docs.python.org/3/library/os.html#os.fork" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">os.fork</span></code></a> to the one that Trio is using, they are unlikely to be prepared to have non-blocking I/O semantics suddenly thrust upon them. For example, you can use <code class="docutils literal notranslate"><span class="pre">FdStream(os.dup(0))</span></code> to obtain a stream for reading from standard input, but it is only safe to do so with heavy caveats: your stdin must not be shared by any other processes and you must not make any calls to synchronous methods of <a class="reference external" href="https://docs.python.org/3/library/sys.html#sys.stdin" title="(in Python v3.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sys.stdin</span></code></a> until the stream returned by <a class="reference internal" href="#trio.hazmat.FdStream" title="trio.hazmat.FdStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FdStream</span></code></a> is closed. See <a class="reference external" href="https://github.com/python-trio/trio/issues/174">issue #174</a> for a discussion of the challenges involved in relaxing this restriction.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>fd</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – The fd to be wrapped.</p> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>A new <a class="reference internal" href="#trio.hazmat.FdStream" title="trio.hazmat.FdStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FdStream</span></code></a> object.</p> </dd> </dl> </dd>
</dl>   <h3>Kqueue-specific API</h3> <p>TODO: these are implemented, but are currently more of a sketch than anything real. See <a class="reference external" href="https://github.com/python-trio/trio/issues/26">#26</a>.</p> <dl class="function"> <h3 id="trio.hazmat.current_kqueue"><code>trio.hazmat.current_kqueue()</code></h3> 
</dl> <dl class="function"> <h3 id="trio.hazmat.wait_kevent"><code><em>await</em> trio.hazmat.wait_kevent(ident, filter, abort_func)</code></h3> 
</dl> <dl class="function"> <h3 id="trio.hazmat.monitor_kevent"><code><em>with</em> trio.hazmat.monitor_kevent(ident, filter) as queue</code></h3> 
</dl>   <h3>Windows-specific API</h3> <dl class="function"> <h3 id="trio.hazmat.WaitForSingleObject"><code><em>await</em> trio.hazmat.WaitForSingleObject(handle)</code></h3> <dd>
<p>Async and cancellable variant of <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx">WaitForSingleObject</a>. Windows only.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>handle</code> – A Win32 object handle, as a Python integer.</p> </dd> <h4 class="field-even" style="margin: 0">Raises</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.7)"><code>OSError</code></a> – If the handle is invalid, e.g. when it is already closed.</p> </dd> </dl> </dd>
</dl> <p>TODO: these are implemented, but are currently more of a sketch than anything real. See <a class="reference external" href="https://github.com/python-trio/trio/issues/26">#26</a> and <a class="reference external" href="https://github.com/python-trio/trio/issues/52">#52</a>.</p> <dl class="function"> <h3 id="trio.hazmat.register_with_iocp"><code>trio.hazmat.register_with_iocp(handle)</code></h3> 
</dl> <dl class="function"> <h3 id="trio.hazmat.wait_overlapped"><code><em>await</em> trio.hazmat.wait_overlapped(handle, lpOverlapped)</code></h3> 
</dl> <dl class="function"> <h3 id="trio.hazmat.current_iocp"><code>trio.hazmat.current_iocp()</code></h3> 
</dl> <dl class="function"> <h3 id="trio.hazmat.monitor_completion_key"><code><em>with</em> trio.hazmat.monitor_completion_key() as queue</code></h3> 
</dl>    <h2>Global state: system tasks and run-local variables</h2> <dl class="class"> <h3 id="trio.hazmat.RunVar"><code><em>class</em> trio.hazmat.RunVar(name, default=<object object>)</object></code></h3> <dd>
<p>The run-local variant of a context variable.</p> <p><a class="reference internal" href="#trio.hazmat.RunVar" title="trio.hazmat.RunVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunVar</span></code></a> objects are similar to context variable objects, except that they are shared across a single call to <a class="reference internal" href="reference-core#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> rather than a single task.</p> </dd>
</dl> <dl class="function"> <h3 id="trio.hazmat.spawn_system_task"><code>trio.hazmat.spawn_system_task(async_fn, *args, name=None)</code></h3> <dd>
<p>Spawn a “system” task.</p> <p>System tasks have a few differences from regular tasks:</p> <ul class="simple"> <li><p>They don’t need an explicit nursery; instead they go into the internal “system nursery”.</p></li> <li><p>If a system task raises an exception, then it’s converted into a <a class="reference internal" href="reference-core#trio.TrioInternalError" title="trio.TrioInternalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TrioInternalError</span></code></a> and <em>all</em> tasks are cancelled. If you write a system task, you should be careful to make sure it doesn’t crash.</p></li> <li><p>System tasks are automatically cancelled when the main task exits.</p></li> <li><p>By default, system tasks have <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection <em>enabled</em>. If you want your task to be interruptible by control-C, then you need to use <a class="reference internal" href="#trio.hazmat.disable_ki_protection" title="trio.hazmat.disable_ki_protection"><code class="xref py py-func docutils literal notranslate"><span class="pre">disable_ki_protection()</span></code></a> explicitly (and come up with some plan for what to do with a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>, given that system tasks aren’t allowed to raise exceptions).</p></li> <li><p>System tasks do not inherit context variables from their creator.</p></li> </ul> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>async_fn</code> – An async callable.</p></li> <li><p><code>args</code> – Positional arguments for <code class="docutils literal notranslate"><span class="pre">async_fn</span></code>. If you want to pass keyword arguments, use <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>.</p></li> <li><p><code>name</code> – The name for this task. Only used for debugging/introspection (e.g. <code class="docutils literal notranslate"><span class="pre">repr(task_obj)</span></code>). If this isn’t a string, <a class="reference internal" href="#trio.hazmat.spawn_system_task" title="trio.hazmat.spawn_system_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn_system_task()</span></code></a> will try to make it one. A common use case is if you’re wrapping a function before spawning a new task, you might pass the original function as the <code class="docutils literal notranslate"><span class="pre">name=</span></code> to make debugging easier.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns</h4> <dd class="field-even">
<p>the newly spawned task</p> </dd> <h4 class="field-odd" style="margin: 0">Return type</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task">Task</a></p> </dd> </dl> </dd>
</dl>   <h2>Trio tokens</h2> <dl class="class"> <h3 id="trio.hazmat.TrioToken"><code><em>class</em> trio.hazmat.TrioToken</code></h3> <dd>
<p>An opaque object representing a single call to <a class="reference internal" href="reference-core#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>.</p> <p>It has no public constructor; instead, see <a class="reference internal" href="#trio.hazmat.current_trio_token" title="trio.hazmat.current_trio_token"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_trio_token()</span></code></a>.</p> <p>This object has two uses:</p> <ol class="arabic simple"> <li><p>It lets you re-enter the Trio run loop from external threads or signal handlers. This is the low-level primitive that <a class="reference internal" href="reference-core#module-trio.to_thread" title="trio.to_thread"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread()</span></code></a> and <a class="reference internal" href="reference-core#module-trio.from_thread" title="trio.from_thread"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.from_thread</span></code></a> use to communicate with worker threads, that <a class="reference internal" href="reference-io#trio.open_signal_receiver" title="trio.open_signal_receiver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.open_signal_receiver</span></code></a> uses to receive notifications about signals, and so forth.</p></li> <li><p>Each call to <a class="reference internal" href="reference-core#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> has exactly one associated <a class="reference internal" href="#trio.hazmat.TrioToken" title="trio.hazmat.TrioToken"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrioToken</span></code></a> object, so you can use it to identify a particular call.</p></li> </ol> <dl class="method"> <h3 id="trio.hazmat.TrioToken.run_sync_soon"><code>run_sync_soon(sync_fn, *args, idempotent=False)</code></h3> <dd>
<p>Schedule a call to <code class="docutils literal notranslate"><span class="pre">sync_fn(*args)</span></code> to occur in the context of a Trio task.</p> <p>This is safe to call from the main thread, from other threads, and from signal handlers. This is the fundamental primitive used to re-enter the Trio run loop from outside of it.</p> <p>The call will happen “soon”, but there’s no guarantee about exactly when, and no mechanism provided for finding out when it’s happened. If you need this, you’ll have to build your own.</p> <p>The call is effectively run as part of a system task (see <a class="reference internal" href="#trio.hazmat.spawn_system_task" title="trio.hazmat.spawn_system_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn_system_task()</span></code></a>). In particular this means that:</p> <ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection is <em>enabled</em> by default; if you want <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> to be interruptible by control-C, then you need to use <a class="reference internal" href="#trio.hazmat.disable_ki_protection" title="trio.hazmat.disable_ki_protection"><code class="xref py py-func docutils literal notranslate"><span class="pre">disable_ki_protection()</span></code></a> explicitly.</p></li> <li><p>If <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> raises an exception, then it’s converted into a <a class="reference internal" href="reference-core#trio.TrioInternalError" title="trio.TrioInternalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TrioInternalError</span></code></a> and <em>all</em> tasks are cancelled. You should be careful that <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> doesn’t crash.</p></li> </ul> <p>All calls with <code class="docutils literal notranslate"><span class="pre">idempotent=False</span></code> are processed in strict first-in first-out order.</p> <p>If <code class="docutils literal notranslate"><span class="pre">idempotent=True</span></code>, then <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> and <code class="docutils literal notranslate"><span class="pre">args</span></code> must be hashable, and Trio will make a best-effort attempt to discard any call submission which is equal to an already-pending call. Trio will make an attempt to process these in first-in first-out order, but no guarantees. (Currently processing is FIFO on CPython 3.6 and PyPy, but not CPython 3.5.)</p> <p>Any ordering guarantees apply separately to <code class="docutils literal notranslate"><span class="pre">idempotent=False</span></code> and <code class="docutils literal notranslate"><span class="pre">idempotent=True</span></code> calls; there’s no rule for how calls in the different categories are ordered with respect to each other.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises</h4> <dd class="field-odd">
<p><a class="reference internal" href="reference-core#trio.RunFinishedError" title="trio.RunFinishedError"><code>trio.RunFinishedError</code></a> – if the associated call to <a class="reference internal" href="reference-core#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> has already exited. (Any call that <em>doesn’t</em> raise this error is guaranteed to be fully processed before <a class="reference internal" href="reference-core#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> exits.)</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="function"> <h3 id="trio.hazmat.current_trio_token"><code>trio.hazmat.current_trio_token()</code></h3> <dd>
<p>Retrieve the <a class="reference internal" href="#trio.hazmat.TrioToken" title="trio.hazmat.TrioToken"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrioToken</span></code></a> for the current call to <a class="reference internal" href="reference-core#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>.</p> </dd>
</dl>   <h2>Safer KeyboardInterrupt handling</h2> <p>Trio’s handling of control-C is designed to balance usability and safety. On the one hand, there are sensitive regions (like the core scheduling loop) where it’s simply impossible to handle arbitrary <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> exceptions while maintaining our core correctness invariants. On the other, if the user accidentally writes an infinite loop, we do want to be able to break out of that. Our solution is to install a default signal handler which checks whether it’s safe to raise <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> at the place where the signal is received. If so, then we do; otherwise, we schedule a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> to be delivered to the main task at the next available opportunity (similar to how <a class="reference internal" href="reference-core#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> is delivered).</p> <p>So that’s great, but – how do we know whether we’re in one of the sensitive parts of the program or not?</p> <p>This is determined on a function-by-function basis. By default, a function is protected if its caller is, and not if its caller isn’t; this is helpful because it means you only need to override the defaults at places where you transition from protected code to unprotected code or vice-versa.</p> <p>These transitions are accomplished using two function decorators:</p> <dl class="function"> <h3 id="trio.hazmat.disable_ki_protection"><code>@trio.hazmat.disable_ki_protection</code></h3> <dd>
<p>Decorator that marks the given regular function, generator function, async function, or async generator function as unprotected against <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>, i.e., the code inside this function <em>can</em> be rudely interrupted by <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> at any moment.</p> <p>If you have multiple decorators on the same function, then this should be at the bottom of the stack (closest to the actual function).</p> <p>An example of where you’d use this is in implementing something like <a class="reference internal" href="reference-core#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.from_thread.run()</span></code></a>, which uses <a class="reference internal" href="#trio.hazmat.TrioToken.run_sync_soon" title="trio.hazmat.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TrioToken.run_sync_soon()</span></code></a> to get into the Trio thread. <a class="reference internal" href="#trio.hazmat.TrioToken.run_sync_soon" title="trio.hazmat.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_sync_soon()</span></code></a> callbacks are run with <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection enabled, and <a class="reference internal" href="reference-core#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.from_thread.run()</span></code></a> takes advantage of this to safely set up the machinery for sending a response back to the original thread, but then uses <a class="reference internal" href="#trio.hazmat.disable_ki_protection" title="trio.hazmat.disable_ki_protection"><code class="xref py py-func docutils literal notranslate"><span class="pre">disable_ki_protection()</span></code></a> when entering the user-provided function.</p> </dd>
</dl> <dl class="function"> <h3 id="trio.hazmat.enable_ki_protection"><code>@trio.hazmat.enable_ki_protection</code></h3> <dd>
<p>Decorator that marks the given regular function, generator function, async function, or async generator function as protected against <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>, i.e., the code inside this function <em>won’t</em> be rudely interrupted by <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>. (Though if it contains any <a class="reference internal" href="reference-core#checkpoints"><span class="std std-ref">checkpoints</span></a>, then it can still receive <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> at those. This is considered a polite interruption.)</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>Be very careful to only use this decorator on functions that you know will either exit in bounded time, or else pass through a checkpoint regularly. (Of course all of your functions should have this property, but if you mess it up here then you won’t even be able to use control-C to escape!)</p> </blockquote> <p>If you have multiple decorators on the same function, then this should be at the bottom of the stack (closest to the actual function).</p> <p>An example of where you’d use this is on the <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> implementation for something like a <a class="reference internal" href="reference-core#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>, where a poorly-timed <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> could leave the lock in an inconsistent state and cause a deadlock.</p> </dd>
</dl> <dl class="function"> <h3 id="trio.hazmat.currently_ki_protected"><code>trio.hazmat.currently_ki_protected()</code></h3> <dd>
<p>Check whether the calling code has <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection enabled.</p> <p>It’s surprisingly easy to think that one’s <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection is enabled when it isn’t, or vice-versa. This function tells you what Trio thinks of the matter, which makes it useful for <code class="docutils literal notranslate"><span class="pre">assert</span></code>s and unit tests.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>True if protection is enabled, and False otherwise.</p> </dd> <h4 class="field-even" style="margin: 0">Return type</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)">bool</a></p> </dd> </dl> </dd>
</dl>   <h2>Sleeping and waking</h2>  <h3>Wait queue abstraction</h3> <dl class="class"> <h3 id="trio.hazmat.ParkingLot"><code><em>class</em> trio.hazmat.ParkingLot</code></h3> <dd>
<p>A fair wait queue with cancellation and requeueing.</p> <p>This class encapsulates the tricky parts of implementing a wait queue. It’s useful for implementing higher-level synchronization primitives like queues and locks.</p> <p>In addition to the methods below, you can use <code class="docutils literal notranslate"><span class="pre">len(parking_lot)</span></code> to get the number of parked tasks, and <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">parking_lot:</span> <span class="pre">...</span></code> to check whether there are any parked tasks.</p> <dl class="method"> <h3 id="trio.hazmat.ParkingLot.park"><code><em>await</em> park()</code></h3> <dd>
<p>Park the current task until woken by a call to <a class="reference internal" href="#trio.hazmat.ParkingLot.unpark" title="trio.hazmat.ParkingLot.unpark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unpark()</span></code></a> or <a class="reference internal" href="#trio.hazmat.ParkingLot.unpark_all" title="trio.hazmat.ParkingLot.unpark_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unpark_all()</span></code></a>.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.hazmat.ParkingLot.repark"><code>repark(new_lot, *, count=1)</code></h3> <dd>
<p>Move parked tasks from one <a class="reference internal" href="#trio.hazmat.ParkingLot" title="trio.hazmat.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a> object to another.</p> <p>This dequeues <code class="docutils literal notranslate"><span class="pre">count</span></code> tasks from one lot, and requeues them on another, preserving order. For example:</p> <pre data-language="python">async def parker(lot):
    print("sleeping")
    await lot.park()
    print("woken")

async def main():
    lot1 = trio.hazmat.ParkingLot()
    lot2 = trio.hazmat.ParkingLot()
    async with trio.open_nursery() as nursery:
        nursery.start_soon(parker, lot1)
        await trio.testing.wait_all_tasks_blocked()
        assert len(lot1) == 1
        assert len(lot2) == 0
        lot1.repark(lot2)
        assert len(lot1) == 0
        assert len(lot2) == 1
        # This wakes up the task that was originally parked in lot1
        lot2.unpark()</pre> <p>If there are fewer than <code class="docutils literal notranslate"><span class="pre">count</span></code> tasks parked, then reparks as many tasks as are available and then returns successfully.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>new_lot</code> (<a class="reference internal" href="#trio.hazmat.ParkingLot" title="trio.hazmat.ParkingLot"><em>ParkingLot</em></a>) – the parking lot to move tasks to.</p></li> <li><p><code>count</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the number of tasks to move.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.hazmat.ParkingLot.repark_all"><code>repark_all(new_lot)</code></h3> <dd>
<p>Move all parked tasks from one <a class="reference internal" href="#trio.hazmat.ParkingLot" title="trio.hazmat.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a> object to another.</p> <p>See <a class="reference internal" href="#trio.hazmat.ParkingLot.repark" title="trio.hazmat.ParkingLot.repark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">repark()</span></code></a> for details.</p> </dd>
</dl> <dl class="method"> <h3 id="trio.hazmat.ParkingLot.statistics"><code>statistics()</code></h3> <dd>
<p>Return an object containing debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this lot’s <a class="reference internal" href="#trio.hazmat.ParkingLot.park" title="trio.hazmat.ParkingLot.park"><code class="xref py py-meth docutils literal notranslate"><span class="pre">park()</span></code></a> method.</p></li> </ul> </dd>
</dl> <dl class="method"> <h3 id="trio.hazmat.ParkingLot.unpark"><code>unpark(*, count=1)</code></h3> <dd>
<p>Unpark one or more tasks.</p> <p>This wakes up <code class="docutils literal notranslate"><span class="pre">count</span></code> tasks that are blocked in <a class="reference internal" href="#trio.hazmat.ParkingLot.park" title="trio.hazmat.ParkingLot.park"><code class="xref py py-meth docutils literal notranslate"><span class="pre">park()</span></code></a>. If there are fewer than <code class="docutils literal notranslate"><span class="pre">count</span></code> tasks parked, then wakes as many tasks are available and then returns successfully.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>count</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the number of tasks to unpark.</p> </dd> </dl> </dd>
</dl> <dl class="method"> <h3 id="trio.hazmat.ParkingLot.unpark_all"><code>unpark_all()</code></h3> <dd>
<p>Unpark all parked tasks.</p> </dd>
</dl> </dd>
</dl>   <h3>Low-level checkpoint functions</h3> <dl class="function"> <h3 id="trio.hazmat.checkpoint"><code><em>await</em> trio.hazmat.checkpoint()</code></h3> <dd>
<p>A pure <a class="reference internal" href="reference-core#checkpoints"><span class="std std-ref">checkpoint</span></a>.</p> <p>This checks for cancellation and allows other tasks to be scheduled, without otherwise blocking.</p> <p>Note that the scheduler has the option of ignoring this and continuing to run the current task if it decides this is appropriate (e.g. for increased efficiency).</p> <p>Equivalent to <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">trio.sleep(0)</span></code> (which is implemented by calling <a class="reference internal" href="#trio.hazmat.checkpoint" title="trio.hazmat.checkpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkpoint()</span></code></a>.)</p> </dd>
</dl> <p>The next two functions are used <em>together</em> to make up a checkpoint:</p> <dl class="function"> <h3 id="trio.hazmat.checkpoint_if_cancelled"><code><em>await</em> trio.hazmat.checkpoint_if_cancelled()</code></h3> <dd>
<p>Issue a <a class="reference internal" href="reference-core#checkpoints"><span class="std std-ref">checkpoint</span></a> if the calling context has been cancelled.</p> <p>Equivalent to (but potentially more efficient than):</p> <pre data-language="python">if trio.current_deadline() == -inf:
    await trio.hazmat.checkpoint()</pre> <p>This is either a no-op, or else it allow other tasks to be scheduled and then raises <a class="reference internal" href="reference-core#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.Cancelled</span></code></a>.</p> <p>Typically used together with <a class="reference internal" href="#trio.hazmat.cancel_shielded_checkpoint" title="trio.hazmat.cancel_shielded_checkpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">cancel_shielded_checkpoint()</span></code></a>.</p> </dd>
</dl> <dl class="function"> <h3 id="trio.hazmat.cancel_shielded_checkpoint"><code><em>await</em> trio.hazmat.cancel_shielded_checkpoint()</code></h3> <dd>
<p>Introduce a schedule point, but not a cancel point.</p> <p>This is <em>not</em> a <a class="reference internal" href="reference-core#checkpoints"><span class="std std-ref">checkpoint</span></a>, but it is half of a checkpoint, and when combined with <a class="reference internal" href="#trio.hazmat.checkpoint_if_cancelled" title="trio.hazmat.checkpoint_if_cancelled"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkpoint_if_cancelled()</span></code></a> it can make a full checkpoint.</p> <p>Equivalent to (but potentially more efficient than):</p> <pre data-language="python">with trio.CancelScope(shield=True):
    await trio.hazmat.checkpoint()</pre> </dd>
</dl> <p>These are commonly used in cases where you have an operation that might-or-might-not block, and you want to implement Trio’s standard checkpoint semantics. Example:</p> <pre data-language="python">async def operation_that_maybe_blocks():
    await checkpoint_if_cancelled()
    try:
        ret = attempt_operation()
    except BlockingIOError:
        # need to block and then retry, which we do below
        pass
    else:
        # operation succeeded, finish the checkpoint then return
        await cancel_shielded_checkpoint()
        return ret
    while True:
        await wait_for_operation_to_be_ready()
        try:
            return attempt_operation()
        except BlockingIOError:
            pass</pre> <p>This logic is a bit convoluted, but accomplishes all of the following:</p> <ul class="simple"> <li><p>Every successful execution path passes through a checkpoint (assuming that <code class="docutils literal notranslate"><span class="pre">wait_for_operation_to_be_ready</span></code> is an unconditional checkpoint)</p></li> <li><p>Our <a class="reference internal" href="reference-core#cancellable-primitives"><span class="std std-ref">cancellation semantics</span></a> say that <a class="reference internal" href="reference-core#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> should only be raised if the operation didn’t happen. Using <a class="reference internal" href="#trio.hazmat.cancel_shielded_checkpoint" title="trio.hazmat.cancel_shielded_checkpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">cancel_shielded_checkpoint()</span></code></a> on the early-exit branch accomplishes this.</p></li> <li><p>On the path where we do end up blocking, we don’t pass through any schedule points before that, which avoids some unnecessary work.</p></li> <li><p>Avoids implicitly chaining the <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#BlockingIOError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> with any errors raised by <code class="docutils literal notranslate"><span class="pre">attempt_operation</span></code> or <code class="docutils literal notranslate"><span class="pre">wait_for_operation_to_be_ready</span></code>, by keeping the <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">True:</span></code> loop outside of the <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">BlockingIOError:</span></code> block.</p></li> </ul> <p>These functions can also be useful in other situations. For example, when <a class="reference internal" href="reference-core#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> schedules some work to run in a worker thread, it blocks until the work is finished (so it’s a schedule point), but by default it doesn’t allow cancellation. So to make sure that the call always acts as a checkpoint, it calls <a class="reference internal" href="#trio.hazmat.checkpoint_if_cancelled" title="trio.hazmat.checkpoint_if_cancelled"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkpoint_if_cancelled()</span></code></a> before starting the thread.</p>   <h3>Low-level blocking</h3> <dl class="function"> <h3 id="trio.hazmat.wait_task_rescheduled"><code><em>await</em> trio.hazmat.wait_task_rescheduled(abort_func)</code></h3> <dd>
<p>Put the current task to sleep, with cancellation support.</p> <p>This is the lowest-level API for blocking in Trio. Every time a <a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> blocks, it does so by calling this function (usually indirectly via some higher-level API).</p> <p>This is a tricky interface with no guard rails. If you can use <a class="reference internal" href="#trio.hazmat.ParkingLot" title="trio.hazmat.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a> or the built-in I/O wait functions instead, then you should.</p> <p>Generally the way it works is that before calling this function, you make arrangements for “someone” to call <a class="reference internal" href="#trio.hazmat.reschedule" title="trio.hazmat.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> on the current task at some later point.</p> <p>Then you call <a class="reference internal" href="#trio.hazmat.wait_task_rescheduled" title="trio.hazmat.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>, passing in <code class="docutils literal notranslate"><span class="pre">abort_func</span></code>, an “abort callback”.</p> <p>(Terminology: in Trio, “aborting” is the process of attempting to interrupt a blocked task to deliver a cancellation.)</p> <p>There are two possibilities for what happens next:</p> <ol class="arabic"> <li><p>“Someone” calls <a class="reference internal" href="#trio.hazmat.reschedule" title="trio.hazmat.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> on the current task, and <a class="reference internal" href="#trio.hazmat.wait_task_rescheduled" title="trio.hazmat.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> returns or raises whatever value or error was passed to <a class="reference internal" href="#trio.hazmat.reschedule" title="trio.hazmat.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a>.</p></li> <li>
<p>The call’s context transitions to a cancelled state (e.g. due to a timeout expiring). When this happens, the <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> is called. Its interface looks like:</p> <pre data-language="python">def abort_func(raise_cancel):
    ...
    return trio.hazmat.Abort.SUCCEEDED  # or FAILED</pre> <p>It should attempt to clean up any state associated with this call, and in particular, arrange that <a class="reference internal" href="#trio.hazmat.reschedule" title="trio.hazmat.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> will <em>not</em> be called later. If (and only if!) it is successful, then it should return <a class="reference internal" href="#trio.hazmat.Abort.SUCCEEDED" title="trio.hazmat.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a>, in which case the task will automatically be rescheduled with an appropriate <a class="reference internal" href="reference-core#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> error.</p> <p>Otherwise, it should return <a class="reference internal" href="#trio.hazmat.Abort.FAILED" title="trio.hazmat.Abort.FAILED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a>. This means that the task can’t be cancelled at this time, and still has to make sure that “someone” eventually calls <a class="reference internal" href="#trio.hazmat.reschedule" title="trio.hazmat.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a>.</p> <p>At that point there are again two possibilities. You can simply ignore the cancellation altogether: wait for the operation to complete and then reschedule and continue as normal. (For example, this is what <a class="reference internal" href="reference-core#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> does if cancellation is disabled.) The other possibility is that the <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> does succeed in cancelling the operation, but for some reason isn’t able to report that right away. (Example: on Windows, it’s possible to request that an async (“overlapped”) I/O operation be cancelled, but this request is <em>also</em> asynchronous – you don’t find out until later whether the operation was actually cancelled or not.) To report a delayed cancellation, then you should reschedule the task yourself, and call the <code class="docutils literal notranslate"><span class="pre">raise_cancel</span></code> callback passed to <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> to raise a <a class="reference internal" href="reference-core#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> (or possibly <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>) exception into this task. Either of the approaches sketched below can work:</p> <pre data-language="python"># Option 1:
# Catch the exception from raise_cancel and inject it into the task.
# (This is what Trio does automatically for you if you return
# Abort.SUCCEEDED.)
trio.hazmat.reschedule(task, outcome.capture(raise_cancel))

# Option 2:
# wait to be woken by "someone", and then decide whether to raise
# the error from inside the task.
outer_raise_cancel = None
def abort(inner_raise_cancel):
    nonlocal outer_raise_cancel
    outer_raise_cancel = inner_raise_cancel
    TRY_TO_CANCEL_OPERATION()
    return trio.hazmat.Abort.FAILED
await wait_task_rescheduled(abort)
if OPERATION_WAS_SUCCESSFULLY_CANCELLED:
    # raises the error
    outer_raise_cancel()</pre> <p>In any case it’s guaranteed that we only call the <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> at most once per call to <a class="reference internal" href="#trio.hazmat.wait_task_rescheduled" title="trio.hazmat.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>.</p> </li> </ol> <p>Sometimes, it’s useful to be able to share some mutable sleep-related data between the sleeping task, the abort function, and the waking task. You can use the sleeping task’s <a class="reference internal" href="#trio.hazmat.Task.custom_sleep_data" title="trio.hazmat.Task.custom_sleep_data"><code class="xref py py-data docutils literal notranslate"><span class="pre">custom_sleep_data</span></code></a> attribute to store this data, and Trio won’t touch it, except to make sure that it gets cleared when the task is rescheduled.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If your <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> raises an error, or returns any value other than <a class="reference internal" href="#trio.hazmat.Abort.SUCCEEDED" title="trio.hazmat.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a> or <a class="reference internal" href="#trio.hazmat.Abort.FAILED" title="trio.hazmat.Abort.FAILED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a>, then Trio will crash violently. Be careful! Similarly, it is entirely possible to deadlock a Trio program by failing to reschedule a blocked task, or cause havoc by calling <a class="reference internal" href="#trio.hazmat.reschedule" title="trio.hazmat.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> too many times. Remember what we said up above about how you should use a higher-level API if at all possible?</p> </blockquote> </dd>
</dl> <dl class="class"> <h3 id="trio.hazmat.Abort"><code><em>class</em> trio.hazmat.Abort</code></h3> <dd>
<p><a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.Enum" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></a> used as the return value from abort functions.</p> <p>See <a class="reference internal" href="#trio.hazmat.wait_task_rescheduled" title="trio.hazmat.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> for details.</p> <dl class="data"> <h3 id="trio.hazmat.Abort.SUCCEEDED"><code>SUCCEEDED</code></h3> <h3 id="trio.hazmat.Abort.FAILED"><code>FAILED</code></h3> 
</dl> </dd>
</dl> <dl class="function"> <h3 id="trio.hazmat.reschedule"><code>trio.hazmat.reschedule(task, next_send=<object object>)</object></code></h3> <dd>
<p>Reschedule the given task with the given <a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="(in outcome v1.0.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">outcome.Outcome</span></code></a>.</p> <p>See <a class="reference internal" href="#trio.hazmat.wait_task_rescheduled" title="trio.hazmat.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> for the gory details.</p> <p>There must be exactly one call to <a class="reference internal" href="#trio.hazmat.reschedule" title="trio.hazmat.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> for every call to <a class="reference internal" href="#trio.hazmat.wait_task_rescheduled" title="trio.hazmat.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>. (And when counting, keep in mind that returning <a class="reference internal" href="#trio.hazmat.Abort.SUCCEEDED" title="trio.hazmat.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a> from an abort callback is equivalent to calling <a class="reference internal" href="#trio.hazmat.reschedule" title="trio.hazmat.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> once.)</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>task</code> (<a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><em>trio.hazmat.Task</em></a>) – the task to be rescheduled. Must be blocked in a call to <a class="reference internal" href="#trio.hazmat.wait_task_rescheduled" title="trio.hazmat.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>.</p></li> <li><p><code>next_send</code> (<a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="(in outcome v1.0.0)"><em>outcome.Outcome</em></a>) – the value (or error) to return (or raise) from <a class="reference internal" href="#trio.hazmat.wait_task_rescheduled" title="trio.hazmat.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>.</p></li> </ul> </dd> </dl> </dd>
</dl> <p>Here’s an example lock class implemented using <a class="reference internal" href="#trio.hazmat.wait_task_rescheduled" title="trio.hazmat.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> directly. This implementation has a number of flaws, including lack of fairness, O(n) cancellation, missing error checking, failure to insert a checkpoint on the non-blocking path, etc. If you really want to implement your own lock, then you should study the implementation of <a class="reference internal" href="reference-core#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.Lock</span></code></a> and use <a class="reference internal" href="#trio.hazmat.ParkingLot" title="trio.hazmat.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a>, which handles some of these issues for you. But this does serve to illustrate the basic structure of the <a class="reference internal" href="#trio.hazmat.wait_task_rescheduled" title="trio.hazmat.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> API:</p> <pre data-language="python">class NotVeryGoodLock:
    def __init__(self):
        self._blocked_tasks = collections.deque()
        self._held = False

    async def acquire(self):
        while self._held:
            task = trio.current_task()
            self._blocked_tasks.append(task)
            def abort_fn(_):
                self._blocked_tasks.remove(task)
                return trio.hazmat.Abort.SUCCEEDED
            await trio.hazmat.wait_task_rescheduled(abort_fn)
        self._held = True

    def release(self):
        self._held = False
        if self._blocked_tasks:
            woken_task = self._blocked_tasks.popleft()
            trio.hazmat.reschedule(woken_task)</pre>   <h3>Task API</h3> <dl class="function"> <h3 id="trio.hazmat.current_root_task"><code>trio.hazmat.current_root_task()</code></h3> <dd>
<p>Returns the current root <a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>.</p> <p>This is the task that is the ultimate parent of all other tasks.</p> </dd>
</dl> <dl class="function"> <h3 id="trio.hazmat.current_task"><code>trio.hazmat.current_task()</code></h3> <dd>
<p>Return the <a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object representing the current task.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns</h4> <dd class="field-odd">
<p>the <a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> that called <a class="reference internal" href="#trio.hazmat.current_task" title="trio.hazmat.current_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_task()</span></code></a>.</p> </dd> <h4 class="field-even" style="margin: 0">Return type</h4> <dd class="field-even">
<p><a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task">Task</a></p> </dd> </dl> </dd>
</dl> <dl class="class"> <h3 id="trio.hazmat.Task"><code><em>class</em> trio.hazmat.Task</code></h3> <dd>
<p>A <a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object represents a concurrent “thread” of execution. It has no public constructor; Trio internally creates a <a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object for each call to <code class="docutils literal notranslate"><span class="pre">nursery.start(...)</span></code> or <code class="docutils literal notranslate"><span class="pre">nursery.start_soon(...)</span></code>.</p> <p>Its public members are mostly useful for introspection and debugging:</p> <dl class="attribute"> <h3 id="trio.hazmat.Task.name"><code>name</code></h3> <dd>
<p>String containing this <a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>’s name. Usually the name of the function this <a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> is running, but can be overridden by passing <code class="docutils literal notranslate"><span class="pre">name=</span></code> to <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">start_soon</span></code>.</p> </dd>
</dl> <dl class="attribute"> <h3 id="trio.hazmat.Task.coro"><code>coro</code></h3> <dd>
<p>This task’s coroutine object. Example usage: extracting a stack trace:</p> <pre data-language="python">import traceback

def walk_coro_stack(coro):
    while coro is not None:
        if hasattr(coro, "cr_frame"):
            # A real coroutine
            yield coro.cr_frame, coro.cr_frame.f_lineno
            coro = coro.cr_await
        else:
            # A generator decorated with @types.coroutine
            yield coro.gi_frame, coro.gi_frame.f_lineno
            coro = coro.gi_yieldfrom

def print_stack_for_task(task):
    ss = traceback.StackSummary.extract(walk_coro_stack(task.coro))
    print("".join(ss.format()))</pre> </dd>
</dl> <dl class="attribute"> <h3 id="trio.hazmat.Task.context"><code>context</code></h3> <dd>
<p>This task’s <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#contextvars.Context" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> object.</p> </dd>
</dl> <dl class="attribute"> <h3 id="trio.hazmat.Task.parent_nursery"><code>parent_nursery</code></h3> <dd>
<p>The nursery this task is inside (or None if this is the “init” task).</p> <p>Example use case: drawing a visualization of the task tree in a debugger.</p> </dd>
</dl> <dl class="attribute"> <h3 id="trio.hazmat.Task.child_nurseries"><code>child_nurseries</code></h3> <dd>
<p>The nurseries this task contains.</p> <p>This is a list, with outer nurseries before inner nurseries.</p> </dd>
</dl> <dl class="attribute"> <h3 id="trio.hazmat.Task.custom_sleep_data"><code>custom_sleep_data</code></h3> <dd>
<p>Trio doesn’t assign this variable any meaning, except that it sets it to <code class="docutils literal notranslate"><span class="pre">None</span></code> whenever a task is rescheduled. It can be used to share data between the different tasks involved in putting a task to sleep and then waking it up again. (See <a class="reference internal" href="#trio.hazmat.wait_task_rescheduled" title="trio.hazmat.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> for details.)</p> </dd>
</dl> </dd>
</dl>   <h3>Handing off live coroutine objects between coroutine runners</h3> <p>Internally, Python’s async/await syntax is built around the idea of “coroutine objects” and “coroutine runners”. A coroutine object represents the state of an async callstack. But by itself, this is just a static object that sits there. If you want it to do anything, you need a coroutine runner to push it forward. Every Trio task has an associated coroutine object (see <a class="reference internal" href="#trio.hazmat.Task.coro" title="trio.hazmat.Task.coro"><code class="xref py py-data docutils literal notranslate"><span class="pre">Task.coro</span></code></a>), and the Trio scheduler acts as their coroutine runner.</p> <p>But of course, Trio isn’t the only coroutine runner in Python – <a class="reference external" href="https://docs.python.org/3/library/asyncio.html#module-asyncio" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> has one, other event loops have them, you can even define your own.</p> <p>And in some very, very unusual circumstances, it even makes sense to transfer a single coroutine object back and forth between different coroutine runners. That’s what this section is about. This is an <em>extremely</em> exotic use case, and assumes a lot of expertise in how Python async/await works internally. For motivating examples, see <a class="reference external" href="https://github.com/python-trio/trio-asyncio/issues/42">trio-asyncio issue #42</a>, and <a class="reference external" href="https://github.com/python-trio/trio/issues/649">trio issue #649</a>. For more details on how coroutines work, we recommend André Caron’s <a class="reference external" href="https://github.com/AndreLouisCaron/a-tale-of-event-loops">A tale of event loops</a>, or going straight to <a class="reference external" href="https://www.python.org/dev/peps/pep-0492/">PEP 492</a> for the full details.</p> <dl class="function"> <h3 id="trio.hazmat.permanently_detach_coroutine_object"><code><em>await</em> trio.hazmat.permanently_detach_coroutine_object(final_outcome)</code></h3> <dd>
<p>Permanently detach the current task from the Trio scheduler.</p> <p>Normally, a Trio task doesn’t exit until its coroutine object exits. When you call this function, Trio acts like the coroutine object just exited and the task terminates with the given outcome. This is useful if you want to permanently switch the coroutine object over to a different coroutine runner.</p> <p>When the calling coroutine enters this function it’s running under Trio, and when the function returns it’s running under the foreign coroutine runner.</p> <p>You should make sure that the coroutine object has released any Trio-specific resources it has acquired (e.g. nurseries).</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>final_outcome</code> (<a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="(in outcome v1.0.0)"><em>outcome.Outcome</em></a>) – Trio acts as if the current task exited with the given return value or exception.</p> </dd> </dl> <p>Returns or raises whatever value or exception the new coroutine runner uses to resume the coroutine.</p> </dd>
</dl> <dl class="function"> <h3 id="trio.hazmat.temporarily_detach_coroutine_object"><code><em>await</em> trio.hazmat.temporarily_detach_coroutine_object(abort_func)</code></h3> <dd>
<p>Temporarily detach the current coroutine object from the Trio scheduler.</p> <p>When the calling coroutine enters this function it’s running under Trio, and when the function returns it’s running under the foreign coroutine runner.</p> <p>The Trio <a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> will continue to exist, but will be suspended until you use <a class="reference internal" href="#trio.hazmat.reattach_detached_coroutine_object" title="trio.hazmat.reattach_detached_coroutine_object"><code class="xref py py-func docutils literal notranslate"><span class="pre">reattach_detached_coroutine_object()</span></code></a> to resume it. In the mean time, you can use another coroutine runner to schedule the coroutine object. In fact, you have to – the function doesn’t return until the coroutine is advanced from outside.</p> <p>Note that you’ll need to save the current <a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object to later resume; you can retrieve it with <a class="reference internal" href="#trio.hazmat.current_task" title="trio.hazmat.current_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_task()</span></code></a>. You can also use this <a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object to retrieve the coroutine object – see <a class="reference internal" href="#trio.hazmat.Task.coro" title="trio.hazmat.Task.coro"><code class="xref py py-data docutils literal notranslate"><span class="pre">Task.coro</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<p><code>abort_func</code> – Same as for <a class="reference internal" href="#trio.hazmat.wait_task_rescheduled" title="trio.hazmat.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>, except that it must return <a class="reference internal" href="#trio.hazmat.Abort.FAILED" title="trio.hazmat.Abort.FAILED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a>. (If it returned <a class="reference internal" href="#trio.hazmat.Abort.SUCCEEDED" title="trio.hazmat.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a>, then Trio would attempt to reschedule the detached task directly without going through <a class="reference internal" href="#trio.hazmat.reattach_detached_coroutine_object" title="trio.hazmat.reattach_detached_coroutine_object"><code class="xref py py-func docutils literal notranslate"><span class="pre">reattach_detached_coroutine_object()</span></code></a>, which would be bad.) Your <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> should still arrange for whatever the coroutine object is doing to be cancelled, and then reattach to Trio and call the <code class="docutils literal notranslate"><span class="pre">raise_cancel</span></code> callback, if possible.</p> </dd> </dl> <p>Returns or raises whatever value or exception the new coroutine runner uses to resume the coroutine.</p> </dd>
</dl> <dl class="function"> <h3 id="trio.hazmat.reattach_detached_coroutine_object"><code><em>await</em> trio.hazmat.reattach_detached_coroutine_object(task, yield_value)</code></h3> <dd>
<p>Reattach a coroutine object that was detached using <a class="reference internal" href="#trio.hazmat.temporarily_detach_coroutine_object" title="trio.hazmat.temporarily_detach_coroutine_object"><code class="xref py py-func docutils literal notranslate"><span class="pre">temporarily_detach_coroutine_object()</span></code></a>.</p> <p>When the calling coroutine enters this function it’s running under the foreign coroutine runner, and when the function returns it’s running under Trio.</p> <p>This must be called from inside the coroutine being resumed, and yields whatever value you pass in. (Presumably you’ll pass a value that will cause the current coroutine runner to stop scheduling this task.) Then the coroutine is resumed by the Trio scheduler at the next opportunity.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters</h4> <dd class="field-odd">
<ul class="simple"> <li><p><code>task</code> (<a class="reference internal" href="#trio.hazmat.Task" title="trio.hazmat.Task"><em>Task</em></a>) – The Trio task object that the current coroutine was detached from.</p></li> <li><p><code>yield_value</code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><em>object</em></a>) – The object to yield to the current coroutine runner.</p></li> </ul> </dd> </dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2017 Nathaniel J. Smith<br>Licensed under the MIT License.<br>
    <a href="https://trio.readthedocs.io/en/v0.12.1/reference-hazmat.html" class="_attribution-link">https://trio.readthedocs.io/en/v0.12.1/reference-hazmat.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
