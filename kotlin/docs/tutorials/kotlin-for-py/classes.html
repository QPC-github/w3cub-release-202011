
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Classes - Kotlin - W3cubDocs</title>
  
  <meta name="description" content="Kotlin&#39;s object model is substantially different from Python&#39;s. Most importantly, classes are not dynamically modifiable at runtime! (There &hellip;">
  <meta name="keywords" content="classes, kotlin">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/kotlin/docs/tutorials/kotlin-for-py/classes.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/kotlin.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/kotlin/" class="_nav-link" title="" style="margin-left:0;">Kotlin</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _kotlin">
				
				
<h1> Classes </h1>  <p class="typo-para">Kotlin's object model is substantially different from Python's. Most importantly, classes are <em>not</em> dynamically modifiable at runtime! (There are some limited exceptions to this, but you generally shouldn't do it. However, it <em>is</em> possible to dynamically <em>inspect</em> classes and objects at runtime with a feature called <em>reflection</em> - this can be useful, but should be judiciously used.) All properties (attributes) and functions that might ever be needed on a class must be declared either directly in the class body or as <a class="typo-link" href="extension-functionsproperties"><em>extension functions</em></a>, so you should think carefully through your class design.</p> <h2 class="typo-header typo-h2" id="declaration-and-instantiation">Declaration and instantiation</h2> <p class="typo-para">Classes are declared with the <code>class</code> keyword. A basic class without any properties or functions of its own looks like this:</p> <div class="sample"> <pre data-language="kotlin">class Empty
</pre> </div> <p class="typo-para">You can then create an instance of this class in a way that looks similar to Python, as if the class were a function (but this is just syntactic sugar - unlike Python, classes in Kotlin aren't really functions):</p> <div class="sample"> <pre data-language="kotlin">val object = Empty()
</pre> </div> <p class="typo-para">Class names should use <code>UpperCamelCase</code>, just like in Python.</p> <h2 class="typo-header typo-h2" id="inherited-built-in-functions">Inherited built-in functions</h2> <p class="typo-para">Every class that doesn't explicitly declare a parent class inherits from <code>Any</code>, which is the root of the class hierarchy (similar to <code>object</code> in Python) - more on <a class="typo-link" href="inheritance">inheritance</a> later. Via <code>Any</code>, every class automatically has the following functions:</p> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">
<code>toString()</code> returns a string representation of the object, similar to <code>__str__()</code> in Python (the default implementation is rather uninteresting, as it only returns the class name and something akin to the object's id)</li> <li class="typo-list__item">
<code>equals(x)</code> checks if this object is equal to some other object <code>x</code> of any class (by default, this just checks if this object is the <em>same</em> object as <code>x</code> - just like <code>is</code> in Python - but it can be overridden by subclasses to do custom comparisons of property values)</li> <li class="typo-list__item">
<code>hashCode()</code> returns an integer that can be used by hash tables and for shortcutting complex equality comparisons (objects that are equal according to <code>equals()</code> must have the same hash code, so if two objects' hash codes are different, the objects cannot be equal)</li> </ul> <h2 class="typo-header typo-h2" id="properties">Properties</h2> <p class="typo-para">Empty classes aren't very interesting, so let's make a class with some <em>properties</em>:</p> <div class="sample"> <pre data-language="kotlin">class Person {
    var name = "Anne"
    var age = 32
}
</pre> </div> <p class="typo-para">Note that the type of a property must be explicitly specified. As opposed to Python, declaring a property directly inside the class does not create a class-level property, but an instance-level one: every instance of <code>Person</code> will have <em>its own</em> <code>name</code> and <code>age</code>. Their values will start out in every instance as <code>"Anne"</code> and <code>32</code>, respectively, but the value in each instance can be modified independently of the others:</p> <div class="sample"> <pre data-language="kotlin">val a = Person()
val b = Person()
println("${a.age} ${b.age}") // Prints "32 32"
a.age = 42
println("${a.age} ${b.age}") // Prints "42 32"
</pre> </div> <p class="typo-para">To be fair, you'd get the same output in Python, but the mechanism would be different: both instances would start out without any attributes of their own (<code>age</code> and <code>name</code> would be attributes on the class), and the first printing would access the class attribute; only the assignment would cause an <code>age</code> attribute to appear on <code>a</code>. In Kotlin, there are no class properties in this example, and each instance starts out with both properties. If you need a class-level property, see the section on <a class="typo-link" href="objects-and-companion-objects#companion-objects">companion objects</a>.</p> <p class="typo-para">Because the set of properties of an object is constrained to be exactly the set of properties that are declared at compile-time in the object's class, it's not possible to add new properties to an object or to a class at runtime, so e.g. <code>a.nationality = "Norwegian"</code> won't compile.</p> <p class="typo-para">Property names should use <code>lowerCamelCase</code> instead of <code>snake_case</code>.</p> <h2 class="typo-header typo-h2" id="constructors-and-initializer-blocks">Constructors and initializer blocks</h2> <p class="typo-para">Properties that don't have a sensible default should be taken as constructor parameters. Like with Python's <code>__init__()</code>, Kotlin constructors and initializer blocks run automatically whenever an instance of an object is created (note that there's nothing that corresponds to <code>__new__()</code>). A Kotlin class may have one <em>primary constructor</em>, whose parameters are supplied after the class name. The primary constructor parameters are available when you initialize properties in the class body, and also in the optional <em>initializer block</em>, which can contain complex initialization logic (a property can be declared without an initial value, in which case it must be initialized in <code>init</code>). Also, you'll frequently want to use <code>val</code> instead of <code>var</code> in order to make your properties immutable after construction.</p> <div class="sample"> <pre data-language="kotlin">class Person(firstName: String, lastName: String, yearOfBirth: Int) {
    val fullName = "$firstName $lastName"
    var age: Int
    
    init {
        age = 2018 - yearOfBirth
    }
}
</pre> </div> <p class="typo-para">If all you want to do with a constructor parameter value is to assign it to a property with the same name, you can declare the property in the primary constructor parameter list (the oneliner below is sufficient for both declaring the properties, declaring the constructor parameters, and initializing the properties with the parameters):</p> <div class="sample"> <pre data-language="kotlin">class Person(val name: String, var age: Int)
</pre> </div> <p class="typo-para">If you need multiple ways to initialize a class, you can create <em>secondary constructors</em>, each of which looks like a function whose name is <code>constructor</code>. Every secondary constructor must invoke another (primary or secondary) constructor by using the <code>this</code> keyword as if it were a function (so that every instance construction eventually calls the primary constructor).</p> <div class="sample"> <pre data-language="kotlin">class Person(val name: String, var age: Int) {
    constructor(name: String) : this(name, 0)
    constructor(yearOfBirth: Int, name: String)
        : this(name, 2018 - yearOfBirth)
}
</pre> </div> <p class="typo-para">(A secondary constructor can also have a body in curly braces if needs to do more than what the primary constructor does.) The constructors are distinguished from each other through the types of their parameters, like in ordinary function overloading. That's the reason we had to flip the parameter order in the last secondary constructor - otherwise, it would have been indistinguishable from the primary constructor (parameter names are not a part of a function's signature and don't have any effect on overload resolution). In the most recent example, we can now create a <code>Person</code> in three different ways:</p> <div class="sample"> <pre data-language="kotlin">val a = Person("Jaime", 35)
val b = Person("Jack") // age = 0
val c = Person(1995, "Lynne") // age = 23
</pre> </div> <p class="typo-para">Note that if a class has got a primary constructor, it is no longer possible to create an instance of it without supplying any parameters (unless one of the secondary constructors is parameterless).</p> <h2 class="typo-header typo-h2" id="setters-and-getters">Setters and getters</h2> <p class="typo-para">A property is really a <em>backing field</em> (kind of a hidden variable inside the object) and two accessor functions: one that gets the value of the variable and one that sets the value. You can override one or both of the accessors (an accessor that is not overridden automatically gets the default behavior of just returning or setting the backing field directly). Inside an accessor, you can reference the backing field with <code>field</code>. The setter accessor must take a parameter <code>value</code>, which is the value that is being assigned to the property. A getter body could either be a one-line expression preceded by <code>=</code> or a more complex body enclosed in curly braces, while a setter body typically includes an assignment and must therefore be enclosed in curly braces. If you want to validate that the age is nonnegative:</p> <div class="sample"> <pre data-language="kotlin">class Person(age: Int) {
    var age = 0
        set(value) {
            if (value &lt; 0) throw IllegalArgumentException(
                    "Age cannot be negative")
            field = value
        }

    init {
        this.age = age
    }
}
</pre> </div> <p class="typo-para">Annoyingly, the setter logic is not invoked by the initialization, which instead sets the backing field directly - that's why we have to use an initializer block in this example in order to verify that newly-created persons also don't get a negative age. Note the use of <code>this.age</code> in the initializer block in order to distinguish between the identically-named property and constructor parameter.</p> <p class="typo-para">If for some reason you want to store a different value in the backing field than the value that is being assigned to the property, you're free to do that, but then you will probably want a getter to give the calling code back what they expect: if you say <code>field = value * 2</code> in the setter and <code>this.age = age * 2</code> in the initializer block, you should also have <code>get() = field / 2</code>.</p> <p class="typo-para">You can also create properties that don't actually have a backing field, but just reference another property:</p> <div class="sample"> <pre data-language="kotlin">val isNewborn
    get() = age == 0
</pre> </div> <p class="typo-para">Note that even though this is a read-only property due to declaring it with <code>val</code> (in which case you may not provide a setter), its value can still change since it reads from a mutable property - you just can't assign to the property. Also, note that the property type is inferred from the return value of the getter.</p> <p class="typo-para">The indentation in front of the accessors is due to convention; like elsewhere in Kotlin, it has no syntactic significance. The compiler can tell which accessors belong to which properties because the only legal place for an accessor is immediately after the property declaration (and there can be at most one getter and one setter) - so you can't split the property declaration and the accessor declarations. However, the order of the accessors doesn't matter.</p> <h2 class="typo-header typo-h2" id="member-functions">Member functions</h2> <p class="typo-para">A function declared inside a class is called a <em>member function</em> of that class. Like in Python, every invocation of a member function must be performed on an instance of the class, and the instance will be available during the execution of the function - but unlike Python, the function signature doesn't declare that: there is no explicit <code>self</code> parameter. Instead, every member function can use the keyword <code>this</code> to reference the current instance, without declaring it. Unlike Python, as long as there is no name conflict with an identically-named parameter or local variable, <code>this</code> can be omitted. If we do this inside a <code>Person</code> class with a <code>name</code> property:</p> <div class="sample"> <pre data-language="kotlin">fun present() {
    println("Hello, I'm $name!")
}
</pre> </div> <p class="typo-para">We can then do this:</p> <div class="sample"> <pre data-language="kotlin">val p = Person("Claire")
p.present() // Prints "Hello, I'm Claire!"
</pre> </div> <p class="typo-para">You could have said <code>${this.name}</code>, but that's redundant and generally discouraged. Oneliner functions can be declared with an <code>=</code>:</p> <div class="sample"> <pre data-language="kotlin">fun greet(other: Person) = println("Hello, ${other.name}, I'm $name!")
</pre> </div> <p class="typo-para">Apart from the automatic passing of the instance into <code>this</code>, member functions generally act like ordinary functions.</p> <p class="typo-para">Because the set of member functions of an object is constrained to be exactly the set of member functions that are declared at compile-time in the object's class and base classes, it's not possible to add new member functions to an object or to a class at runtime, so e.g. <code>p.leave = fun() { println("Bye!") }</code> or anything of the sort won't compile.</p> <p class="typo-para">Member function names should use <code>lowerCamelCase</code> instead of <code>snake_case</code>.</p> <h2 class="typo-header typo-h2" id="lateinit">Lateinit</h2> <p class="typo-para">Kotlin requires that every member property is initialized during instance construction. Sometimes, a class is intended to be used in such a way that the constructor doesn't have enough information to initialize all properties (such as when making a builder class or when using property-based dependency injection). In order to not have to make those properties nullable, you can use a <em>late-initialized property</em>:</p> <div class="sample"> <pre data-language="kotlin">lateinit var name: String
</pre> </div> <p class="typo-para">Kotlin will allow you to declare this property without initializing it, and you can set the property value at some point after construction (either directly or via a function). It is the responsibility of the class itself as well as its users to take care not to read the property before it has been set, and Kotlin allows you to write code that reads <code>name</code> as if it were an ordinary, non-nullable property. However, the compiler is unable to enforce correct usage, so if the property is read before it has been set, an <code>UninitializedPropertyAccessException</code> will be thrown at runtime.</p> <p class="typo-para">Inside the class that declares a lateinit property, you can check if it has been initialized:</p> <div class="sample"> <pre data-language="kotlin">if (::name.isInitialized) println(name)
</pre> </div> <p class="typo-para"><code>lateinit</code> can only be used with <code>var</code>, not with <code>val</code>, and the type must be non-primitive and non-nullable.</p> <h2 class="typo-header typo-h2" id="infix-functions">Infix functions</h2> <p class="typo-para">You can designate a one-parameter member function or <a class="typo-link" href="extension-functionsproperties">extension function</a> for use as an infix operator, which can be useful if you're designing a DSL. The left operand will become <code>this</code>, and the right operand will become the parameter. If you do this inside a <code>Person</code> class that has got a <code>name</code> property:</p> <div class="sample"> <pre data-language="kotlin">infix fun marry(spouse: Person) {
    println("$name and ${spouse.name} are getting married!")
}
</pre> </div> <p class="typo-para">We can now do this (but it's still possible to call the function the normal way):</p> <div class="sample"> <pre data-language="kotlin">val lisa = Person("Lisa")
val anne = Person("Anne")
lisa marry anne // Prints "Lisa and Anne are getting married!"
</pre> </div> <p class="typo-para">All infix functions have the same <a class="typo-link" href="https://kotlinlang.org/docs/reference/grammar.html#precedence">precedence</a> (which is shared with all the built-in infix functions, such as the bitwise functions <code>and</code>, <code>or</code>, <code>inv</code>, etc.): lower than the arithmetic operators and the <code>..</code> range operator, but higher than the Elvis operator <code>?:</code>, comparisons, logic operators, and assignments.</p> <h2 class="typo-header typo-h2" id="operators">Operators</h2> <p class="typo-para">Most of the operators that are recognized by Kotlin's syntax have predefined textual names and are available for implementation in your classes, just like you can do with Python's double-underscore operator names. For example, the binary <code>+</code> operator is called <code>plus</code>. Similarly to the infix example, if you do this inside a <code>Person</code> class that has got a <code>name</code> property:</p> <div class="sample"> <pre data-language="kotlin">operator fun plus(spouse: Person) {
    println("$name and ${spouse.name} are getting married!")
}
</pre> </div> <p class="typo-para">With <code>lisa</code> and <code>anne</code> from the infix example, you can now do:</p> <div class="sample"> <pre data-language="kotlin">lisa + anne // Prints "Lisa and Anne are getting married!"
</pre> </div> <p class="typo-para">A particularly interesting operator is the function-call parenthesis pair, whose function name is <code>invoke</code> - if you implement this, you'll be able to call instances of your class as if they were functions. You can even overload it in order to provide different function signatures.</p> <p class="typo-para"><code>operator</code> can also be used for certain other predefined functions in order to create fancy effects, such as <a class="typo-link" href="inheritance#delegated-properties">delegated properties</a>.</p> <p class="typo-para">Since the available operators are hardcoded into the formal Kotlin syntax, you can not invent new operators, and overriding an operator does not affect its <a class="typo-link" href="https://kotlinlang.org/docs/reference/grammar.html#precedence">precedence</a>.</p> <h2 class="typo-header typo-h2" id="enum-classes">Enum classes</h2> <p class="typo-para">Whenever you want a variable that can only take on a limited number of values where the only feature of each value is that it's distinct from all the other values, you can create an <em>enum class</em>:</p> <div class="sample"> <pre data-language="kotlin">enum class ContentKind {
    TOPIC,
    ARTICLE,
    EXERCISE,
    VIDEO,
}
</pre> </div> <p class="typo-para">There are exactly four instances of this class, named <code>ContentKind.TOPIC</code>, and so on. Instances of this class can be compared to each other with <code>==</code> and <code>!=</code>, and you can get all the allowable values with <code>ContentKind.values()</code>. You can also tack on more information to each instance if you need:</p> <div class="sample"> <pre data-language="kotlin">enum class ContentKind(val kind: String) {
    TOPIC("Topic"),
    ARTICLE("Article"),
    EXERCISE("Exercise"),
    VIDEO("Video"),
    ;

    override fun toString(): String {
        return kind
    }
}
</pre> </div> <p class="typo-para">Null safety is enforced as usual, so a variable of type <code>ContentKind</code> can not be null, unlike in Java.</p> <h2 class="typo-header typo-h2" id="data-classes">Data classes</h2> <p class="typo-para">Frequently - especially if you want a complex return type from a function or a complex key for a map - you'll want a quick and dirty class which only contains some properties, but is still comparable for equality and is usable as a map key. If you create a <em>data class</em>, you'll get automatic implementations of the following functions: <code>toString()</code> (which will produce a string containing all the property names and values), <code>equals()</code> (which will do a per-property <code>equals()</code>), <code>hashCode()</code> (which will hash the individual properties and combine the hashes), and the functions that are required to enable Kotlin to destructure an instance of the class into a declaration (<code>component1()</code>, <code>component2()</code>, etc.):</p> <div class="sample"> <pre data-language="kotlin">data class ContentDescriptor(val kind: ContentKind, val id: String) {
    override fun toString(): String {
        return kind.toString() + ":" + id
    }
}
</pre> </div> <hr class="typo-hr"> <table class="typo-table"> <tbody> <tr class="typo-table__row"> <td class="typo-table__column"><a class="typo-link" href="functions">← Previous: Functions</a></td> <td class="typo-table__column"><a class="typo-link" href="exceptions">Next: Exceptions →</a></td> </tr> </tbody> </table> <hr class="typo-hr"> <p class="typo-para"><em>This material was written by <a class="typo-link" href="https://eldhuset.net/">Aasmund Eldhuset</a>; it is owned by <a class="typo-link" href="https://www.khanacademy.org/">Khan Academy</a> and is licensed for use under <a class="typo-link" href="https://creativecommons.org/licenses/by-nc-sa/3.0/us/">CC BY-NC-SA 3.0 US</a>. Please note that this is not a part of Khan Academy's official product offering.</em></p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2020 JetBrains s.r.o. and Kotlin Programming Language contributors<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://kotlinlang.org/docs/tutorials/kotlin-for-py/classes.html" class="_attribution-link">https://kotlinlang.org/docs/tutorials/kotlin-for-py/classes.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
