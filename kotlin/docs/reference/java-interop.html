
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Calling Java Code From Kotlin - Kotlin - W3cubDocs</title>
  
  <meta name="description" content="Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used &hellip;">
  <meta name="keywords" content="calling, java, code, from, kotlin">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/kotlin/docs/reference/java-interop.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/kotlin.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/kotlin/" class="_nav-link" title="" style="margin-left:0;">Kotlin</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _kotlin">
				
				
<h1 class="typo-header typo-h1" id="calling-java-code-from-kotlin">Calling Java code from Kotlin</h1> <p class="typo-para">Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well. In this section we describe some details about calling Java code from Kotlin.</p> <p class="typo-para">Pretty much all Java code can be used without any issues:</p> <div class="sample"> <pre data-language="kotlin">import java.util.*

fun demo(source: List&lt;Int&gt;) {
    val list = ArrayList&lt;Int&gt;()
    // 'for'-loops work for Java collections:
    for (item in source) {
        list.add(item)
    }
    // Operator conventions work as well:
    for (i in 0..source.size - 1) {
        list[i] = source[i] // get and set are called
    }
}
</pre> </div> <h2 class="typo-header typo-h2" id="getters-and-setters">Getters and Setters</h2> <p class="typo-para">Methods that follow the Java conventions for getters and setters (no-argument methods with names starting with <code>get</code> and single-argument methods with names starting with <code>set</code>) are represented as properties in Kotlin. <code>Boolean</code> accessor methods (where the name of the getter starts with <code>is</code> and the name of the setter starts with <code>set</code>) are represented as properties which have the same name as the getter method.</p> <p class="typo-para">For example:</p> <div class="sample"> <pre data-language="kotlin">import java.util.Calendar

fun calendarDemo() {
    val calendar = Calendar.getInstance()
    if (calendar.firstDayOfWeek == Calendar.SUNDAY) {  // call getFirstDayOfWeek()
        calendar.firstDayOfWeek = Calendar.MONDAY      // call setFirstDayOfWeek()
    }
    if (!calendar.isLenient) {                         // call isLenient()
        calendar.isLenient = true                      // call setLenient()
    }
}
</pre> </div> <p class="typo-para">Note that, if the Java class only has a setter, it will not be visible as a property in Kotlin, because Kotlin does not support set-only properties at this time.</p> <h2 class="typo-header typo-h2" id="methods-returning-void">Methods returning void</h2> <p class="typo-para">If a Java method returns void, it will return <code>Unit</code> when called from Kotlin. If, by any chance, someone uses that return value, it will be assigned at the call site by the Kotlin compiler, since the value itself is known in advance (being <code>Unit</code>).</p> <h2 class="typo-header typo-h2" id="escaping-for-java-identifiers-that-are-keywords-in-kotlin">Escaping for Java identifiers that are keywords in Kotlin</h2> <p class="typo-para">Some of the Kotlin keywords are valid identifiers in Java: <em class="keyword">in</em>, <em class="keyword">object</em>, <em class="keyword">is</em>, etc. If a Java library uses a Kotlin keyword for a method, you can still call the method escaping it with the backtick (`) character:</p> <div class="sample"> <pre data-language="kotlin">foo.`is`(bar)
</pre> </div> <h2 class="typo-header typo-h2" id="null-safety-and-platform-types">Null-Safety and Platform Types</h2> <p class="typo-para">Any reference in Java may be <em class="keyword">null</em>, which makes Kotlin's requirements of strict null-safety impractical for objects coming from Java. Types of Java declarations are treated specially in Kotlin and called <em>platform types</em>. Null-checks are relaxed for such types, so that safety guarantees for them are the same as in Java (see more <a class="typo-link" href="#mapped-types">below</a>).</p> <p class="typo-para">Consider the following examples:</p> <div class="sample"> <pre data-language="kotlin">val list = ArrayList&lt;String&gt;() // non-null (constructor result)
list.add("Item")
val size = list.size // non-null (primitive int)
val item = list[0] // platform type inferred (ordinary Java object)
</pre> </div> <p class="typo-para">When we call methods on variables of platform types, Kotlin does not issue nullability errors at compile time, but the call may fail at runtime, because of a null-pointer exception or an assertion that Kotlin generates to prevent nulls from propagating:</p> <div class="sample"> <pre data-language="kotlin">item.substring(1) // allowed, may throw an exception if item == null
</pre> </div> <p class="typo-para">Platform types are <em>non-denotable</em>, meaning that one can not write them down explicitly in the language. When a platform value is assigned to a Kotlin variable, we can rely on type inference (the variable will have an inferred platform type then, as <code>item</code> has in the example above), or we can choose the type that we expect (both nullable and non-null types are allowed):</p> <div class="sample"> <pre data-language="kotlin">val nullable: String? = item // allowed, always works
val notNull: String = item // allowed, may fail at runtime
</pre> </div> <p class="typo-para">If we choose a non-null type, the compiler will emit an assertion upon assignment. This prevents Kotlin's non-null variables from holding nulls. Assertions are also emitted when we pass platform values to Kotlin functions expecting non-null values etc. Overall, the compiler does its best to prevent nulls from propagating far through the program (although sometimes this is impossible to eliminate entirely, because of generics).</p> <h3 class="typo-header typo-h3" id="notation-for-platform-types">Notation for Platform Types</h3> <p class="typo-para">As mentioned above, platform types cannot be mentioned explicitly in the program, so there's no syntax for them in the language. Nevertheless, the compiler and IDE need to display them sometimes (in error messages, parameter info etc), so we have a mnemonic notation for them:</p> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">
<code>T!</code> means "<code>T</code> or <code>T?</code>",</li> <li class="typo-list__item">
<code>(Mutable)Collection&lt;T&gt;!</code> means "Java collection of <code>T</code> may be mutable or not, may be nullable or not",</li> <li class="typo-list__item">
<code>Array&lt;(out) T&gt;!</code> means "Java array of <code>T</code> (or a subtype of <code>T</code>), nullable or not"</li> </ul> <h3 class="typo-header typo-h3" id="nullability-annotations">Nullability annotations</h3> <p class="typo-para">Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null Kotlin types. The compiler supports several flavors of nullability annotations, including:</p> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">
<a class="typo-link" href="https://www.jetbrains.com/idea/help/nullable-and-notnull-annotations.html">JetBrains</a> (<code>@Nullable</code> and <code>@NotNull</code> from the <code>org.jetbrains.annotations</code> package)</li> <li class="typo-list__item">Android (<code>com.android.annotations</code> and <code>android.support.annotations</code>)</li> <li class="typo-list__item">JSR-305 (<code>javax.annotation</code>, more details below)</li> <li class="typo-list__item">FindBugs (<code>edu.umd.cs.findbugs.annotations</code>)</li> <li class="typo-list__item">Eclipse (<code>org.eclipse.jdt.annotation</code>)</li> <li class="typo-list__item">Lombok (<code>lombok.NonNull</code>).</li> </ul> <p class="typo-para">You can find the full list in the <a class="typo-link" href="https://github.com/JetBrains/kotlin/blob/master/core/compiler.common.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt">Kotlin compiler source code</a>.</p> <h3 class="typo-header typo-h3" id="annotating-type-parameters">Annotating type parameters</h3> <p class="typo-para">It is possible to annotate type arguments of generic types to provide nullability information for them as well. For example, consider these annotations on a Java declaration:</p> <div class="sample" mode="java"> <pre>@NotNull
Set&lt;@NotNull String&gt; toSet(@NotNull Collection&lt;@NotNull String&gt; elements) { ... }
</pre> </div> <p class="typo-para">It leads to the following signature seen in Kotlin:</p> <div class="sample"> <pre data-language="kotlin">fun toSet(elements: (Mutable)Collection&lt;String&gt;) : (Mutable)Set&lt;String&gt; { ... }
</pre> </div> <p class="typo-para">Note the <code>@NotNull</code> annotations on <code>String</code> type arguments. Without them, we get platform types in the type arguments:</p> <div class="sample"> <pre data-language="kotlin">fun toSet(elements: (Mutable)Collection&lt;String!&gt;) : (Mutable)Set&lt;String!&gt; { ... }
</pre> </div> <p class="typo-para">Annotating type arguments works with Java 8 target or higher and requires the nullability annotations to support the <code>TYPE_USE</code> target (<code>org.jetbrains.annotations</code> supports this in version 15 and above).</p> <blockquote class="note typo-quote"> <p class="typo-para">Note: due to the current technical limitations, the IDE does not correctly recognize these annotations on type arguments in compiled Java libraries that are used as dependencies.</p> </blockquote> <h3 class="typo-header typo-h3" id="jsr-305-support">JSR-305 Support</h3> <p class="typo-para">The <a class="typo-link" href="https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html"><code>@Nonnull</code></a> annotation defined in <a class="typo-link" href="https://jcp.org/en/jsr/detail?id=305">JSR-305</a> is supported for denoting nullability of Java types.</p> <p class="typo-para">If the <code>@Nonnull(when = ...)</code> value is <code>When.ALWAYS</code>, the annotated type is treated as non-null; <code>When.MAYBE</code> and <code>When.NEVER</code> denote a nullable type; and <code>When.UNKNOWN</code> forces the type to be <a class="typo-link" href="#null-safety-and-platform-types">platform one</a>.</p> <p class="typo-para">A library can be compiled against the JSR-305 annotations, but there's no need to make the annotations artifact (e.g. <code>jsr305.jar</code>) a compile dependency for the library consumers. The Kotlin compiler can read the JSR-305 annotations from a library without the annotations present on the classpath.</p> <p class="typo-para">Since Kotlin 1.1.50, <a class="typo-link" href="https://github.com/Kotlin/KEEP/blob/41091f1cc7045142181d8c89645059f4a15cc91a/proposals/jsr-305-custom-nullability-qualifiers.md">custom nullability qualifiers (KEEP-79)</a> are also supported (see below).</p> <h4 class="typo-header typo-h4" id="type-qualifier-nicknames-since-1150">Type qualifier nicknames (since 1.1.50)</h4> <p class="typo-para">If an annotation type is annotated with both <a class="typo-link" href="https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/meta/TypeQualifierNickname.html"><code>@TypeQualifierNickname</code></a> and JSR-305 <code>@Nonnull</code> (or its another nickname, such as <code>@CheckForNull</code>), then the annotation type is itself used for retrieving precise nullability and has the same meaning as that nullability annotation:</p> <div class="sample" mode="java"> <pre>@TypeQualifierNickname
@Nonnull(when = When.ALWAYS)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyNonnull {
}

@TypeQualifierNickname
@CheckForNull // a nickname to another type qualifier nickname
@Retention(RetentionPolicy.RUNTIME)
public @interface MyNullable {
}

interface A {
    @MyNullable String foo(@MyNonnull String x);
    // in Kotlin (strict mode): `fun foo(x: String): String?`

    String bar(List&lt;@MyNonnull String&gt; x);
    // in Kotlin (strict mode): `fun bar(x: List&lt;String&gt;!): String!`
}
</pre> </div> <h4 class="typo-header typo-h4" id="type-qualifier-defaults-since-1150">Type qualifier defaults (since 1.1.50)</h4> <p class="typo-para"><a class="typo-link" href="https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/meta/TypeQualifierDefault.html"><code>@TypeQualifierDefault</code></a> allows introducing annotations that, when being applied, define the default nullability within the scope of the annotated element.</p> <p class="typo-para">Such annotation type should itself be annotated with both <code>@Nonnull</code> (or its nickname) and <code>@TypeQualifierDefault(...)</code> with one or more <code>ElementType</code> values:</p> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">
<code>ElementType.METHOD</code> for return types of methods;</li> <li class="typo-list__item">
<code>ElementType.PARAMETER</code> for value parameters;</li> <li class="typo-list__item">
<code>ElementType.FIELD</code> for fields; and</li> <li class="typo-list__item">
<code>ElementType.TYPE_USE</code> (since 1.1.60) for any type including type arguments, upper bounds of type parameters and wildcard types.</li> </ul> <p class="typo-para">The default nullability is used when a type itself is not annotated by a nullability annotation, and the default is determined by the innermost enclosing element annotated with a type qualifier default annotation with the <code>ElementType</code> matching the type usage.</p> <div class="sample" mode="java"> <pre>@Nonnull
@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})
public @interface NonNullApi {
}

@Nonnull(when = When.MAYBE)
@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE_USE})
public @interface NullableApi {
}

@NullableApi
interface A {
    String foo(String x); // fun foo(x: String?): String?

    @NotNullApi // overriding default from the interface
    String bar(String x, @Nullable String y); // fun bar(x: String, y: String?): String

    // The List&lt;String&gt; type argument is seen as nullable because of `@NullableApi`
    // having the `TYPE_USE` element type:
    String baz(List&lt;String&gt; x); // fun baz(List&lt;String?&gt;?): String?

    // The type of `x` parameter remains platform because there's an explicit
    // UNKNOWN-marked nullability annotation:
    String qux(@Nonnull(when = When.UNKNOWN) String x); // fun baz(x: String!): String?
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">Note: the types in this example only take place with the strict mode enabled, otherwise, the platform types remain. See the <a class="typo-link" href="#undermigration-annotation-since-1160"><code>@UnderMigration</code> annotation</a> and <a class="typo-link" href="#compiler-configuration">Compiler configuration</a> sections.</p> </blockquote> <p class="typo-para">Package-level default nullability is also supported:</p> <div class="sample" mode="java"> <pre>// FILE: test/package-info.java
@NonNullApi // declaring all types in package 'test' as non-nullable by default
package test;
</pre> </div> <h4 class="typo-header typo-h4" id="undermigration-annotation-since-1160">
<code>@UnderMigration</code> annotation (since 1.1.60)</h4> <p class="typo-para">The <code>@UnderMigration</code> annotation (provided in a separate artifact <code>kotlin-annotations-jvm</code>) can be used by library maintainers to define the migration status for the nullability type qualifiers.</p> <p class="typo-para">The status value in <code>@UnderMigration(status = ...)</code> specifies how the compiler treats inappropriate usages of the annotated types in Kotlin (e.g. using a <code>@MyNullable</code>-annotated type value as non-null):</p> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item"> <p class="typo-para"><code>MigrationStatus.STRICT</code> makes annotation work as any plain nullability annotation, i.e. report errors for the inappropriate usages and affect the types in the annotated declarations as they are seen in Kotlin;</p> </li> <li class="typo-list__item"> <p class="typo-para">with <code>MigrationStatus.WARN</code>, the inappropriate usages are reported as compilation warnings instead of errors, but the types in the annotated declarations remain platform; and</p> </li> <li class="typo-list__item"> <p class="typo-para"><code>MigrationStatus.IGNORE</code> makes the compiler ignore the nullability annotation completely.</p> </li> </ul> <p class="typo-para">A library maintainer can add <code>@UnderMigration</code> status to both type qualifier nicknames and type qualifier defaults:</p> <div class="sample" mode="java"> <pre>@Nonnull(when = When.ALWAYS)
@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})
@UnderMigration(status = MigrationStatus.WARN)
public @interface NonNullApi {
}

// The types in the class are non-null, but only warnings are reported
// because `@NonNullApi` is annotated `@UnderMigration(status = MigrationStatus.WARN)`
@NonNullApi
public class Test {}
</pre> </div> <p class="typo-para">Note: the migration status of a nullability annotation is not inherited by its type qualifier nicknames but is applied to its usages in default type qualifiers.</p> <p class="typo-para">If a default type qualifier uses a type qualifier nickname and they are both <code>@UnderMigration</code>, the status from the default type qualifier is used.</p> <h4 class="typo-header typo-h4" id="compiler-configuration">Compiler configuration</h4> <p class="typo-para">The JSR-305 checks can be configured by adding the <code>-Xjsr305</code> compiler flag with the following options (and their combination):</p> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item"> <p class="typo-para"><code>-Xjsr305={strict|warn|ignore}</code> to set up the behavior for non-<code>@UnderMigration</code> annotations. Custom nullability qualifiers, especially <code>@TypeQualifierDefault</code>, are already spread among many well-known libraries, and users may need to migrate smoothly when updating to the Kotlin version containing JSR-305 support. Since Kotlin 1.1.60, this flag only affects non-<code>@UnderMigration</code> annotations.</p> </li> <li class="typo-list__item"> <p class="typo-para"><code>-Xjsr305=under-migration:{strict|warn|ignore}</code> (since 1.1.60) to override the behavior for the <code>@UnderMigration</code> annotations. Users may have different view on the migration status for the libraries: they may want to have errors while the official migration status is <code>WARN</code>, or vice versa, they may wish to postpone errors reporting for some until they complete their migration.</p> </li> <li class="typo-list__item"> <p class="typo-para"><code>-Xjsr305=@&lt;fq.name&gt;:{strict|warn|ignore}</code> (since 1.1.60) to override the behavior for a single annotation, where <code>&lt;fq.name&gt;</code> is the fully qualified class name of the annotation. May appear several times for different annotations. This is useful for managing the migration state for a particular library.</p> </li> </ul> <p class="typo-para">The <code>strict</code>, <code>warn</code> and <code>ignore</code> values have the same meaning as those of <code>MigrationStatus</code>, and only the <code>strict</code> mode affects the types in the annotated declarations as they are seen in Kotlin.</p> <blockquote class="typo-quote"> <p class="typo-para">Note: the built-in JSR-305 annotations <a class="typo-link" href="https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html"><code>@Nonnull</code></a>, <a class="typo-link" href="https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nullable.html"><code>@Nullable</code></a> and <a class="typo-link" href="https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/CheckForNull.html"><code>@CheckForNull</code></a> are always enabled and affect the types of the annotated declarations in Kotlin, regardless of compiler configuration with the <code>-Xjsr305</code> flag.</p> </blockquote> <p class="typo-para">For example, adding <code>-Xjsr305=ignore -Xjsr305=under-migration:ignore -Xjsr305=@org.library.MyNullable:warn</code> to the compiler arguments makes the compiler generate warnings for inappropriate usages of types annotated by <code>@org.library.MyNullable</code> and ignore all other JSR-305 annotations.</p> <p class="typo-para">For kotlin versions 1.1.50+/1.2, the default behavior is the same to <code>-Xjsr305=warn</code>. The <code>strict</code> value should be considered experimental (more checks may be added to it in the future).</p> <h2 class="typo-header typo-h2" id="mapped-types">Mapped types</h2> <p class="typo-para">Kotlin treats some Java types specially. Such types are not loaded from Java "as is", but are <em>mapped</em> to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping <a class="typo-link" href="#null-safety-and-platform-types">platform types</a> in mind):</p> <table class="zebra typo-table"> <thead> <tr class="typo-table__row"> <th><strong class="typo-strong">Java type</strong></th> <th><strong class="typo-strong">Kotlin type</strong></th> </tr> </thead> <tbody> <tr class="typo-table__row"> <td class="typo-table__column"><code>byte</code></td> <td class="typo-table__column"><code>kotlin.Byte</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>short</code></td> <td class="typo-table__column"><code>kotlin.Short</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>int</code></td> <td class="typo-table__column"><code>kotlin.Int</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>long</code></td> <td class="typo-table__column"><code>kotlin.Long</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>char</code></td> <td class="typo-table__column"><code>kotlin.Char</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>float</code></td> <td class="typo-table__column"><code>kotlin.Float</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>double</code></td> <td class="typo-table__column"><code>kotlin.Double</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>boolean</code></td> <td class="typo-table__column"><code>kotlin.Boolean</code></td> </tr> </tbody> </table> <p class="typo-para">Some non-primitive built-in classes are also mapped:</p> <table class="zebra typo-table"> <thead> <tr class="typo-table__row"> <th><strong class="typo-strong">Java type</strong></th> <th><strong class="typo-strong">Kotlin type</strong></th> </tr> </thead> <tbody> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Object</code></td> <td class="typo-table__column"><code>kotlin.Any!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Cloneable</code></td> <td class="typo-table__column"><code>kotlin.Cloneable!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Comparable</code></td> <td class="typo-table__column"><code>kotlin.Comparable!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Enum</code></td> <td class="typo-table__column"><code>kotlin.Enum!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Annotation</code></td> <td class="typo-table__column"><code>kotlin.Annotation!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.CharSequence</code></td> <td class="typo-table__column"><code>kotlin.CharSequence!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.String</code></td> <td class="typo-table__column"><code>kotlin.String!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Number</code></td> <td class="typo-table__column"><code>kotlin.Number!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Throwable</code></td> <td class="typo-table__column"><code>kotlin.Throwable!</code></td> </tr> </tbody> </table> <p class="typo-para">Java's boxed primitive types are mapped to nullable Kotlin types:</p> <table class="zebra typo-table"> <thead> <tr class="typo-table__row"> <th><strong class="typo-strong">Java type</strong></th> <th><strong class="typo-strong">Kotlin type</strong></th> </tr> </thead> <tbody> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Byte</code></td> <td class="typo-table__column"><code>kotlin.Byte?</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Short</code></td> <td class="typo-table__column"><code>kotlin.Short?</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Integer</code></td> <td class="typo-table__column"><code>kotlin.Int?</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Long</code></td> <td class="typo-table__column"><code>kotlin.Long?</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Character</code></td> <td class="typo-table__column"><code>kotlin.Char?</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Float</code></td> <td class="typo-table__column"><code>kotlin.Float?</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Double</code></td> <td class="typo-table__column"><code>kotlin.Double?</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>java.lang.Boolean</code></td> <td class="typo-table__column"><code>kotlin.Boolean?</code></td> </tr> </tbody> </table> <p class="typo-para">Note that a boxed primitive type used as a type parameter is mapped to a platform type: for example, <code>List&lt;java.lang.Integer&gt;</code> becomes a <code>List&lt;Int!&gt;</code> in Kotlin.</p> <p class="typo-para">Collection types may be read-only or mutable in Kotlin, so Java's collections are mapped as follows (all Kotlin types in this table reside in the package <code>kotlin.collections</code>):</p> <table class="zebra typo-table"> <thead> <tr class="typo-table__row"> <th><strong class="typo-strong">Java type</strong></th> <th><strong class="typo-strong">Kotlin read-only type</strong></th> <th><strong class="typo-strong">Kotlin mutable type</strong></th> <th><strong class="typo-strong">Loaded platform type</strong></th> </tr> </thead> <tbody> <tr class="typo-table__row"> <td class="typo-table__column"><code>Iterator&lt;T&gt;</code></td> <td class="typo-table__column"><code>Iterator&lt;T&gt;</code></td> <td class="typo-table__column"><code>MutableIterator&lt;T&gt;</code></td> <td class="typo-table__column"><code>(Mutable)Iterator&lt;T&gt;!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>Iterable&lt;T&gt;</code></td> <td class="typo-table__column"><code>Iterable&lt;T&gt;</code></td> <td class="typo-table__column"><code>MutableIterable&lt;T&gt;</code></td> <td class="typo-table__column"><code>(Mutable)Iterable&lt;T&gt;!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>Collection&lt;T&gt;</code></td> <td class="typo-table__column"><code>Collection&lt;T&gt;</code></td> <td class="typo-table__column"><code>MutableCollection&lt;T&gt;</code></td> <td class="typo-table__column"><code>(Mutable)Collection&lt;T&gt;!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>Set&lt;T&gt;</code></td> <td class="typo-table__column"><code>Set&lt;T&gt;</code></td> <td class="typo-table__column"><code>MutableSet&lt;T&gt;</code></td> <td class="typo-table__column"><code>(Mutable)Set&lt;T&gt;!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>List&lt;T&gt;</code></td> <td class="typo-table__column"><code>List&lt;T&gt;</code></td> <td class="typo-table__column"><code>MutableList&lt;T&gt;</code></td> <td class="typo-table__column"><code>(Mutable)List&lt;T&gt;!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>ListIterator&lt;T&gt;</code></td> <td class="typo-table__column"><code>ListIterator&lt;T&gt;</code></td> <td class="typo-table__column"><code>MutableListIterator&lt;T&gt;</code></td> <td class="typo-table__column"><code>(Mutable)ListIterator&lt;T&gt;!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>Map&lt;K, V&gt;</code></td> <td class="typo-table__column"><code>Map&lt;K, V&gt;</code></td> <td class="typo-table__column"><code>MutableMap&lt;K, V&gt;</code></td> <td class="typo-table__column"><code>(Mutable)Map&lt;K, V&gt;!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>Map.Entry&lt;K, V&gt;</code></td> <td class="typo-table__column"><code>Map.Entry&lt;K, V&gt;</code></td> <td class="typo-table__column"><code>MutableMap.MutableEntry&lt;K,V&gt;</code></td> <td class="typo-table__column"><code>(Mutable)Map.(Mutable)Entry&lt;K, V&gt;!</code></td> </tr> </tbody> </table> <p class="typo-para">Java's arrays are mapped as mentioned <a class="typo-link" href="java-interop#java-arrays">below</a>:</p> <table class="zebra typo-table"> <thead> <tr class="typo-table__row"> <th><strong class="typo-strong">Java type</strong></th> <th><strong class="typo-strong">Kotlin type</strong></th> </tr> </thead> <tbody> <tr class="typo-table__row"> <td class="typo-table__column"><code>int[]</code></td> <td class="typo-table__column"><code>kotlin.IntArray!</code></td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>String[]</code></td> <td class="typo-table__column"><code>kotlin.Array&lt;(out) String&gt;!</code></td> </tr> </tbody> </table> <p class="typo-para">Note: the static members of these Java types are not directly accessible on the <a class="typo-link" href="object-declarations#companion-objects">companion objects</a> of the Kotlin types. To call them, use the full qualified names of the Java types, e.g. <code>java.lang.Integer.toHexString(foo)</code>.</p> <h2 class="typo-header typo-h2" id="java-generics-in-kotlin">Java generics in Kotlin</h2> <p class="typo-para">Kotlin's generics are a little different from Java's (see <a class="typo-link" href="generics">Generics</a>). When importing Java types to Kotlin we perform some conversions:</p> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">Java's wildcards are converted into type projections, <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">
<code>Foo&lt;? extends Bar&gt;</code> becomes <code>Foo&lt;out Bar!&gt;!</code>,</li> <li class="typo-list__item">
<code>Foo&lt;? super Bar&gt;</code> becomes <code>Foo&lt;in Bar!&gt;!</code>;</li> </ul> </li> <li class="typo-list__item">Java's raw types are converted into star projections, <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">
<code>List</code> becomes <code>List&lt;*&gt;!</code>, i.e. <code>List&lt;out Any?&gt;!</code>.</li> </ul> </li> </ul> <p class="typo-para">Like Java's, Kotlin's generics are not retained at runtime, i.e. objects do not carry information about actual type arguments passed to their constructors, i.e. <code>ArrayList&lt;Integer&gt;()</code> is indistinguishable from <code>ArrayList&lt;Character&gt;()</code>. This makes it impossible to perform <em class="keyword">is</em>-checks that take generics into account. Kotlin only allows <em class="keyword">is</em>-checks for star-projected generic types:</p> <div class="sample"> <pre data-language="kotlin">if (a is List&lt;Int&gt;) // Error: cannot check if it is really a List of Ints
// but
if (a is List&lt;*&gt;) // OK: no guarantees about the contents of the list
</pre> </div> <h2 class="typo-header typo-h2" id="java-arrays">Java Arrays</h2> <p class="typo-para">Arrays in Kotlin are invariant, unlike Java. This means that Kotlin does not let us assign an <code>Array&lt;String&gt;</code> to an <code>Array&lt;Any&gt;</code>, which prevents a possible runtime failure. Passing an array of a subclass as an array of superclass to a Kotlin method is also prohibited, but for Java methods this is allowed (through <a class="typo-link" href="#null-safety-and-platform-types">platform types</a> of the form <code>Array&lt;(out) String&gt;!</code>).</p> <p class="typo-para">Arrays are used with primitive datatypes on the Java platform to avoid the cost of boxing/unboxing operations. As Kotlin hides those implementation details, a workaround is required to interface with Java code. There are specialized classes for every type of primitive array (<code>IntArray</code>, <code>DoubleArray</code>, <code>CharArray</code>, and so on) to handle this case. They are not related to the <code>Array</code> class and are compiled down to Java's primitive arrays for maximum performance.</p> <p class="typo-para">Suppose there is a Java method that accepts an int array of indices:</p> <div class="sample" mode="java"> <pre>public class JavaArrayExample {

    public void removeIndices(int[] indices) {
        // code here...
    }
}
</pre> </div> <p class="typo-para">To pass an array of primitive values you can do the following in Kotlin:</p> <div class="sample"> <pre data-language="kotlin">val javaObj = JavaArrayExample()
val array = intArrayOf(0, 1, 2, 3)
javaObj.removeIndices(array)  // passes int[] to method
</pre> </div> <p class="typo-para">When compiling to JVM byte codes, the compiler optimizes access to arrays so that there's no overhead introduced:</p> <div class="sample"> <pre data-language="kotlin">val array = arrayOf(1, 2, 3, 4)
array[1] = array[1] * 2 // no actual calls to get() and set() generated
for (x in array) { // no iterator created
    print(x)
}
</pre> </div> <p class="typo-para">Even when we navigate with an index, it does not introduce any overhead:</p> <div class="sample"> <pre data-language="kotlin">for (i in array.indices) { // no iterator created
    array[i] += 2
}
</pre> </div> <p class="typo-para">Finally, <em class="keyword">in</em>-checks have no overhead either:</p> <div class="sample"> <pre data-language="kotlin">if (i in array.indices) { // same as (i &gt;= 0 &amp;&amp; i &lt; array.size)
    print(array[i])
}
</pre> </div> <h2 class="typo-header typo-h2" id="java-varargs">Java Varargs</h2> <p class="typo-para">Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):</p> <div class="sample" mode="java"> <pre>public class JavaArrayExample {

    public void removeIndicesVarArg(int... indices) {
        // code here...
    }
}
</pre> </div> <p class="typo-para">In that case you need to use the spread operator <code>*</code> to pass the <code>IntArray</code>:</p> <div class="sample"> <pre data-language="kotlin">val javaObj = JavaArrayExample()
val array = intArrayOf(0, 1, 2, 3)
javaObj.removeIndicesVarArg(*array)
</pre> </div> <p class="typo-para">It's currently not possible to pass <em class="keyword">null</em> to a method that is declared as varargs.</p> <h2 class="typo-header typo-h2" id="operators">Operators</h2> <p class="typo-para">Since Java has no way of marking methods for which it makes sense to use the operator syntax, Kotlin allows using any Java methods with the right name and signature as operator overloads and other conventions (<code>invoke()</code> etc.) Calling Java methods using the infix call syntax is not allowed.</p> <h2 class="typo-header typo-h2" id="checked-exceptions">Checked Exceptions</h2> <p class="typo-para">In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them. So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything:</p> <div class="sample"> <pre data-language="kotlin">fun render(list: List&lt;*&gt;, to: Appendable) {
    for (item in list) {
        to.append(item.toString()) // Java would require us to catch IOException here
    }
}
</pre> </div> <h2 class="typo-header typo-h2" id="object-methods">Object Methods</h2> <p class="typo-para">When Java types are imported into Kotlin, all the references of the type <code>java.lang.Object</code> are turned into <code>Any</code>. Since <code>Any</code> is not platform-specific, it only declares <code>toString()</code>, <code>hashCode()</code> and <code>equals()</code> as its members, so to make other members of <code>java.lang.Object</code> available, Kotlin uses <a class="typo-link" href="extensions">extension functions</a>.</p> <h3 class="typo-header typo-h3" id="waitnotify">wait()/notify()</h3> <p class="typo-para">Methods <code>wait()</code> and <code>notify()</code> are not available on references of type <code>Any</code>. Their usage is generally discouraged in favor of <code>java.util.concurrent</code>. If you really need to call these methods, you can cast to <code>java.lang.Object</code>:</p> <div class="sample"> <pre data-language="kotlin">(foo as java.lang.Object).wait()
</pre> </div> <h3 class="typo-header typo-h3" id="getclass">getClass()</h3> <p class="typo-para">To retrieve the Java class of an object, use the <code>java</code> extension property on a <a class="typo-link" href="reflection#class-references">class reference</a>:</p> <div class="sample"> <pre data-language="kotlin">val fooClass = foo::class.java
</pre> </div> <p class="typo-para">The code above uses a <a class="typo-link" href="reflection#bound-class-references-since-11">bound class reference</a>, which is supported since Kotlin 1.1. You can also use the <code>javaClass</code> extension property:</p> <div class="sample"> <pre data-language="kotlin">val fooClass = foo.javaClass
</pre> </div> <h3 class="typo-header typo-h3" id="clone">clone()</h3> <p class="typo-para">To override <code>clone()</code>, your class needs to extend <code>kotlin.Cloneable</code>:</p> <div class="sample"> <pre data-language="kotlin">class Example : Cloneable {
    override fun clone(): Any { ... }
}
</pre> </div> <p class="typo-para">Do not forget about <a class="typo-link" href="http://www.oracle.com/technetwork/java/effectivejava-136174.html">Effective Java, 3rd Edition</a>, Item 13: <em>Override clone judiciously</em>.</p> <h3 class="typo-header typo-h3" id="finalize">finalize()</h3> <p class="typo-para">To override <code>finalize()</code>, all you need to do is simply declare it, without using the <em class="keyword">override</em> keyword:</p> <div class="sample"> <pre data-language="kotlin">class C {
    protected fun finalize() {
        // finalization logic
    }
}
</pre> </div> <p class="typo-para">According to Java's rules, <code>finalize()</code> must not be <em class="keyword">private</em>.</p> <h2 class="typo-header typo-h2" id="inheritance-from-java-classes">Inheritance from Java classes</h2> <p class="typo-para">At most one Java class (and as many Java interfaces as you like) can be a supertype for a class in Kotlin.</p> <h2 class="typo-header typo-h2" id="accessing-static-members">Accessing static members</h2> <p class="typo-para">Static members of Java classes form "companion objects" for these classes. We cannot pass such a "companion object" around as a value, but can access the members explicitly, for example:</p> <div class="sample"> <pre data-language="kotlin">if (Character.isLetter(a)) { ... }
</pre> </div> <p class="typo-para">To access static members of a Java type that is <a class="typo-link" href="#mapped-types">mapped</a> to a Kotlin type, use the full qualified name of the Java type: <code>java.lang.Integer.bitCount(foo)</code>.</p> <h2 class="typo-header typo-h2" id="java-reflection">Java Reflection</h2> <p class="typo-para">Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use <code>instance::class.java</code>, <code>ClassName::class.java</code> or <code>instance.javaClass</code> to enter Java reflection through <code>java.lang.Class</code>. You may also use <code>ClassName::class.javaObjectType</code> for getting primitive types wrappers.</p> <p class="typo-para">Other supported cases include acquiring a Java getter/setter method or a backing field for a Kotlin property, a <code>KProperty</code> for a Java field, a Java method or constructor for a <code>KFunction</code> and vice versa.</p> <h2 class="typo-header typo-h2" id="sam-conversions">SAM Conversions</h2> <p class="typo-para">Kotlin supports SAM conversions for both Java and <a class="typo-link" href="fun-interfaces">Kotlin interfaces</a>. This support for Java means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</p> <p class="typo-para">You can use this for creating instances of SAM interfaces:</p> <div class="sample"> <pre data-language="kotlin">val runnable = Runnable { println("This runs in a runnable") }
</pre> </div> <p class="typo-para">…and in method calls:</p> <div class="sample"> <pre data-language="kotlin">val executor = ThreadPoolExecutor()
// Java signature: void execute(Runnable command)
executor.execute { println("This runs in a thread pool") }
</pre> </div> <p class="typo-para">If the Java class has multiple methods taking functional interfaces, you can choose the one you need to call by using an adapter function that converts a lambda to a specific SAM type. Those adapter functions are also generated by the compiler when needed:</p> <div class="sample"> <pre data-language="kotlin">executor.execute(Runnable { println("This runs in a thread pool") })
</pre> </div> <blockquote class="note typo-quote"> <p class="typo-para">SAM conversions only work for interfaces, not for abstract classes, even if those also have just a single abstract method.</p> </blockquote> <h2 class="typo-header typo-h2" id="using-jni-with-kotlin">Using JNI with Kotlin</h2> <p class="typo-para">To declare a function that is implemented in native (C or C++) code, you need to mark it with the <code>external</code> modifier:</p> <div class="sample"> <pre data-language="kotlin">external fun foo(x: Int): Double
</pre> </div> <p class="typo-para">The rest of the procedure works in exactly the same way as in Java.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2020 JetBrains s.r.o. and Kotlin Programming Language contributors<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://kotlinlang.org/docs/reference/java-interop.html" class="_attribution-link">https://kotlinlang.org/docs/reference/java-interop.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
