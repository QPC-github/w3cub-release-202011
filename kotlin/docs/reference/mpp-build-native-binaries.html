
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Build Final Native Binaries - Kotlin - W3cubDocs</title>
  
  <meta name="description" content="By default, a Kotlin&#47;Native target is compiled down to a &#42;.klib library artifact, which can be consumed by Kotlin&#47;Native itself as a &hellip;">
  <meta name="keywords" content="build, final, native, binaries, kotlin">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/kotlin/docs/reference/mpp-build-native-binaries.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/kotlin.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/kotlin/" class="_nav-link" title="" style="margin-left:0;">Kotlin</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _kotlin">
				
				
<h1 class="typo-header typo-h1" id="build-final-native-binaries">Build final native binaries</h1> <p class="typo-para">By default, a Kotlin/Native target is compiled down to a <code>*.klib</code> library artifact, which can be consumed by Kotlin/Native itself as a dependency but cannot be executed or used as a native library.</p> <p class="typo-para">To declare final native binaries such as executables or shared libraries, use the <code>binaries</code> property of a native target. This property represents a collection of native binaries built for this target in addition to the default <code>*.klib</code> artifact and provides a set of methods for declaring and configuring them.</p> <blockquote class="note typo-quote"> <p class="typo-para">The <code>kotlin-multiplatform</code> plugin doesn't create any production binaries by default. The only binary available by default is a debug test executable that lets you run unit tests from the <code>test</code> compilation.</p> </blockquote> <h2 class="typo-header typo-h2" id="declare-binaries">Declare binaries</h2> <p class="typo-para">Use the following factory methods to declare elements of the <code>binaries</code> collection.</p> <table class="typo-table"> <thead> <tr class="typo-table__row"> <th>Factory method</th> <th>Binary kind</th> <th>Available for</th> </tr> </thead> <tbody> <tr class="typo-table__row"> <td class="typo-table__column"><code>executable</code></td> <td class="typo-table__column">Product executable</td> <td class="typo-table__column">All native targets</td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>test</code></td> <td class="typo-table__column">Test executable</td> <td class="typo-table__column">All native targets</td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>sharedLib</code></td> <td class="typo-table__column">Shared native library</td> <td class="typo-table__column">All native targets, except for <code>WebAssembly</code>
</td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>staticLib</code></td> <td class="typo-table__column">Static native library</td> <td class="typo-table__column">All native targets, except for <code>WebAssembly</code>
</td> </tr> <tr class="typo-table__row"> <td class="typo-table__column"><code>framework</code></td> <td class="typo-table__column">Objective-C framework</td> <td class="typo-table__column">macOS, iOS, watchOS, and tvOS targets only</td> </tr> </tbody> </table> <p class="typo-para">The simplest version doesn't require any additional parameters and creates one binary for each build type. Currently there two build types available:</p> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">
<code>DEBUG</code> – produces a non-optimized binary with debug information</li> <li class="typo-list__item">
<code>RELEASE</code> – produces an optimized binary without debug information</li> </ul> <p class="typo-para">The following snippet creates two executable binaries: debug and release.</p> <div class="sample"> <pre data-language="kotlin">kotlin {
    linuxX64 { // Use your target instead.
        binaries {
            executable {
                // Binary configuration.
            }
        }
    }
}
</pre> </div> <p class="typo-para">You can drop the lambda if there is no need for <a class="typo-link" href="mpp-dsl-reference#native-targets">additional configuration</a>:</p> <div class="sample"> <pre data-language="kotlin">binaries {
    executable()
}

</pre> </div> <p class="typo-para">You can specify for which build types to create binaries. In the following example, only the <code>debug</code> executable is created.</p> <div class="multi-language-sample" data-lang="groovy"> <div class="sample" mode="groovy"> <pre data-language="groovy">binaries {
    executable([DEBUG]) {
        // Binary configuration.
    }
}
</pre> </div> </div> <div class="multi-language-sample" data-lang="kotlin"> <div class="sample" mode="kotlin"> <pre data-language="kotlin">binaries {
    executable(listOf(DEBUG)) {
        // Binary configuration.
    }
}
</pre> </div> </div> <p class="typo-para">You can also declare binaries with custom names.</p> <div class="multi-language-sample" data-lang="groovy"> <div class="sample" mode="groovy"> <pre data-language="groovy">binaries {
    executable('foo', [DEBUG]) {
        // Binary configuration.
    }

    // It's possible to drop the list of build types (in which case, all the available build types will be used).
    executable('bar') {
        // Binary configuration.
    }
}
</pre> </div> </div> <div class="multi-language-sample" data-lang="kotlin"> <div class="sample" mode="kotlin"> <pre data-language="kotlin">binaries {
    executable("foo", listOf(DEBUG)) {
        // Binary configuration.
    }

    // It's possible to drop the list of build types (in which case, all the available build types will be used).
    executable("bar") {
        // Binary configuration.
    }
}
</pre> </div> </div> <p class="typo-para">The first argument sets a name prefix, which is the default name for the binary file. For example, for Windows the code produces the files <code>foo.exe</code> and <code>bar.exe</code>. You can also use the name prefix to <a class="typo-link" href="#access-binaries">access the binary in the build script</a>.</p> <h2 class="typo-header typo-h2" id="access-binaries">Access binaries</h2> <p class="typo-para">You can access binaries to <a class="typo-link" href="mpp-dsl-reference#native-targets">configure them</a> or get their properties (for example, the path to an output file).</p> <p class="typo-para">You can get a binary by its unique name. This name is based on the name prefix (if it is specified), build type, and binary kind following the pattern: <code>&lt;optional-name-prefix&gt;&lt;build-type&gt;&lt;binary-kind&gt;</code>, for example, <code>releaseFramework</code> or <code>testDebugExecutable</code>.</p> <blockquote class="note typo-quote"> <p class="typo-para">Static and shared libraries have the suffixes static and shared respectively, for example, <code>fooDebugStatic</code> or <code>barReleaseShared</code>.</p> </blockquote> <div class="multi-language-sample" data-lang="groovy"> <div class="sample" mode="groovy"> <pre data-language="groovy">// Fails if there is no such binary.
binaries['fooDebugExecutable']
binaries.fooDebugExecutable
binaries.getByName('fooDebugExecutable')

// Returns null if there is no such binary.
binaries.findByName('fooDebugExecutable')
</pre> </div> </div> <div class="multi-language-sample" data-lang="kotlin"> <div class="sample" mode="kotlin"> <pre data-language="kotlin">// Fails if there is no such binary.
binaries["fooDebugExecutable"]
binaries.getByName("fooDebugExecutable")

// Returns null if there is no such binary.
binaries.findByName("fooDebugExecutable")

</pre> </div> </div> <p class="typo-para">Alternatively, you can access a binary by its name prefix and build type using typed getters.</p> <div class="multi-language-sample" data-lang="groovy"> <div class="sample" mode="groovy"> <pre data-language="groovy">// Fails if there is no such binary.
binaries.getExecutable('foo', DEBUG)
binaries.getExecutable(DEBUG)          // Skip the first argument if the name prefix isn't set.
binaries.getExecutable('bar', 'DEBUG') // You also can use a string for build type.

// Similar getters are available for other binary kinds:
// getFramework, getStaticLib and getSharedLib.

// Returns null if there is no such binary.
binaries.findExecutable('foo', DEBUG)

// Similar getters are available for other binary kinds:
// findFramework, findStaticLib and findSharedLib.

</pre> </div> </div> <div class="multi-language-sample" data-lang="kotlin"> <div class="sample" mode="kotlin"> <pre data-language="kotlin">// Fails if there is no such binary.
binaries.getExecutable("foo", DEBUG)
binaries.getExecutable(DEBUG)          // Skip the first argument if the name prefix isn't set.
binaries.getExecutable("bar", "DEBUG") // You also can use a string for build type.

// Similar getters are available for other binary kinds:
// getFramework, getStaticLib and getSharedLib.

// Returns null if there is no such binary.
binaries.findExecutable("foo", DEBUG)

// Similar getters are available for other binary kinds:
// findFramework, findStaticLib and findSharedLib.
</pre> </div> </div> <h2 class="typo-header typo-h2" id="export-dependencies-to-binaries">Export dependencies to binaries</h2> <p class="typo-para">When building an Objective-C framework or a native library (shared or static), you may need to pack not just the classes of the current project, but also the classes of its dependencies. Specify which dependencies to export to a binary using the <code>export</code> method.</p> <div class="multi-language-sample" data-lang="groovy"> <div class="sample" mode="groovy"> <pre data-language="groovy">kotlin {
    sourceSets {
        macosMain.dependencies {
            // Will be exported.
            api project(':dependency')
            api 'org.example:exported-library:1.0'
            // Will not be exported.
            api 'org.example:not-exported-library:1.0'
        }
    }
    macosX64("macos").binaries {
        framework {
            export project(':dependency')
            export 'org.example:exported-library:1.0'
        }
        sharedLib {
            // It's possible to export different sets of dependencies to different binaries.
            export project(':dependency')
        }
    }
}
</pre> </div> </div> <div class="multi-language-sample" data-lang="kotlin"> <div class="sample" mode="kotlin"> <pre data-language="kotlin">kotlin {
    sourceSets {
        macosMain.dependencies {
            // Will be exported.
            api(project(":dependency"))
            api("org.example:exported-library:1.0")
            // Will not be exported.
            api("org.example:not-exported-library:1.0")
        }
    }
    macosX64("macos").binaries {
        framework {
            export(project(":dependency"))
            export("org.example:exported-library:1.0")
        }
        sharedLib {
            // It's possible to export different sets of dependencies to different binaries.
            export(project(':dependency'))
        }
    }
}

</pre> </div> </div> <blockquote class="note typo-quote"> <p class="typo-para">You can export only <a class="typo-link" href="using-gradle#dependency-types"><code>api</code> dependencies</a> of the corresponding source set.<br> You can export maven dependencies, but due to current limitations of Gradle metadata, such a dependency should be either a platform dependency (for example, <code>kotlinx-coroutines-core-native_debug_macos_x64</code> instead of <code>kotlinx-coroutines-core-native</code>) or be exported transitively.</p> </blockquote> <p class="typo-para">By default, export works non-transitively. This means that if you export the library <code>foo</code> depending on the library <code>bar</code>, only methods of <code>foo</code> are added to the output framework.</p> <p class="typo-para">You can change this behavior using the <code>transitiveExport</code> flag. If set to <code>true</code>, the declarations of the library <code>bar</code> are exported as well.</p> <div class="multi-language-sample" data-lang="groovy"> <div class="sample" mode="groovy"> <pre data-language="groovy">binaries {
   framework {
       export project(':dependency')
       // Export transitively.
       transitiveExport = true
   }
}
</pre> </div> </div> <div class="multi-language-sample" data-lang="kotlin"> <div class="sample" mode="kotlin"> <pre data-language="kotlin">binaries {
    framework {
        export(project(":dependency"))
        // Export transitively.
        transitiveExport = true
    }
}
</pre> </div> </div> <p class="typo-para">For example, assume that you write several modules in Kotlin and then want to access them from Swift. Since usage of several Kotlin/Native frameworks in one Swift application is limited, you can create a single umbrella framework and export all these modules to it.</p> <h2 class="typo-header typo-h2" id="build-universal-frameworks">Build universal frameworks</h2> <p class="typo-para">By default, an Objective-C framework produced by Kotlin/Native supports only one platform. However, you can merge such frameworks into a single universal (fat) binary using the <a class="typo-link" href="https://llvm.org/docs/CommandGuide/llvm-lipo.html"><code>lipo</code> tool</a>. This operation especially makes sense for 32-bit and 64-bit iOS frameworks. In this case, you can use the resulting universal framework on both 32-bit and 64-bit devices.</p> <blockquote class="note typo-quote"> <p class="typo-para">The fat framework must have the same base name as the initial frameworks.</p> </blockquote> <div class="multi-language-sample" data-lang="groovy"> <div class="sample" mode="groovy"> <pre data-language="groovy">import org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask

kotlin {
    // Create and configure the targets.
    targets {
        iosArm32("ios32")
        iosArm64("ios64")
        configure([ios32, ios64]) {
            binaries.framework {
                baseName = "my_framework"
            }
        }
    }
    // Create a task building a fat framework.
    task debugFatFramework(type: FatFrameworkTask) {
        // The fat framework must have the same base name as the initial frameworks.
        baseName = "my_framework"
        // The default destination directory is '&lt;build directory&gt;/fat-framework'.
        destinationDir = file("$buildDir/fat-framework/debug")
        // Specify the frameworks to be merged.
        from(
                targets.ios32.binaries.getFramework("DEBUG"),
                targets.ios64.binaries.getFramework("DEBUG")
        )
    }
}

</pre> </div> </div> <div class="multi-language-sample" data-lang="kotlin"> <div class="sample" mode="kotlin"> <pre data-language="kotlin">import org.jetbrains.kotlin.gradle.tasks.FatFrameworkTask

kotlin {
    // Create and configure the targets.
    val ios32 = iosArm32("ios32")
    val ios64 = iosArm64("ios64")
    configure(listOf(ios32, ios64)) {
        binaries.framework {
            baseName = "my_framework"
        }
    }
    // Create a task to build a fat framework.
    tasks.create("debugFatFramework", FatFrameworkTask::class) {
        // The fat framework must have the same base name as the initial frameworks.
        baseName = "my_framework"
        // The default destination directory is '&lt;build directory&gt;/fat-framework'.
        destinationDir = buildDir.resolve("fat-framework/debug")
        // Specify the frameworks to be merged.
        from(
                ios32.binaries.getFramework("DEBUG"),
                ios64.binaries.getFramework("DEBUG")
        )
    }
}

</pre> </div> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2020 JetBrains s.r.o. and Kotlin Programming Language contributors<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://kotlinlang.org/docs/reference/mpp-build-native-binaries.html" class="_attribution-link">https://kotlinlang.org/docs/reference/mpp-build-native-binaries.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
