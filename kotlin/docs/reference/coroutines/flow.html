
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Asynchronous Flow - Kotlin - W3cubDocs</title>
  
  <meta name="description" content=" Table of contents ">
  <meta name="keywords" content="asynchronous, flow, kotlin">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/kotlin/docs/reference/coroutines/flow.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/kotlin.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/kotlin/" class="_nav-link" title="" style="margin-left:0;">Kotlin</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _kotlin">
				
				
<p class="typo-para"><strong class="typo-strong">Table of contents</strong></p>  <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">
<a class="typo-link" href="#asynchronous-flow">Asynchronous Flow</a> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">
<a class="typo-link" href="#representing-multiple-values">Representing multiple values</a> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item"><a class="typo-link" href="#sequences">Sequences</a></li> <li class="typo-list__item"><a class="typo-link" href="#suspending-functions">Suspending functions</a></li> <li class="typo-list__item"><a class="typo-link" href="#flows">Flows</a></li> </ul> </li> <li class="typo-list__item"><a class="typo-link" href="#flows-are-cold">Flows are cold</a></li> <li class="typo-list__item"><a class="typo-link" href="#flow-cancellation-basics">Flow cancellation basics</a></li> <li class="typo-list__item"><a class="typo-link" href="#flow-builders">Flow builders</a></li> <li class="typo-list__item">
<a class="typo-link" href="#intermediate-flow-operators">Intermediate flow operators</a> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item"><a class="typo-link" href="#transform-operator">Transform operator</a></li> <li class="typo-list__item"><a class="typo-link" href="#size-limiting-operators">Size-limiting operators</a></li> </ul> </li> <li class="typo-list__item"><a class="typo-link" href="#terminal-flow-operators">Terminal flow operators</a></li> <li class="typo-list__item"><a class="typo-link" href="#flows-are-sequential">Flows are sequential</a></li> <li class="typo-list__item">
<a class="typo-link" href="#flow-context">Flow context</a> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item"><a class="typo-link" href="#wrong-emission-withcontext">Wrong emission withContext</a></li> <li class="typo-list__item"><a class="typo-link" href="#flowon-operator">flowOn operator</a></li> </ul> </li> <li class="typo-list__item">
<a class="typo-link" href="#buffering">Buffering</a> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item"><a class="typo-link" href="#conflation">Conflation</a></li> <li class="typo-list__item"><a class="typo-link" href="#processing-the-latest-value">Processing the latest value</a></li> </ul> </li> <li class="typo-list__item">
<a class="typo-link" href="#composing-multiple-flows">Composing multiple flows</a> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item"><a class="typo-link" href="#zip">Zip</a></li> <li class="typo-list__item"><a class="typo-link" href="#combine">Combine</a></li> </ul> </li> <li class="typo-list__item">
<a class="typo-link" href="#flattening-flows">Flattening flows</a> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item"><a class="typo-link" href="#flatmapconcat">flatMapConcat</a></li> <li class="typo-list__item"><a class="typo-link" href="#flatmapmerge">flatMapMerge</a></li> <li class="typo-list__item"><a class="typo-link" href="#flatmaplatest">flatMapLatest</a></li> </ul> </li> <li class="typo-list__item">
<a class="typo-link" href="#flow-exceptions">Flow exceptions</a> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item"><a class="typo-link" href="#collector-try-and-catch">Collector try and catch</a></li> <li class="typo-list__item"><a class="typo-link" href="#everything-is-caught">Everything is caught</a></li> </ul> </li> <li class="typo-list__item">
<a class="typo-link" href="#exception-transparency">Exception transparency</a> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item"><a class="typo-link" href="#transparent-catch">Transparent catch</a></li> <li class="typo-list__item"><a class="typo-link" href="#catching-declaratively">Catching declaratively</a></li> </ul> </li> <li class="typo-list__item">
<a class="typo-link" href="#flow-completion">Flow completion</a> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item"><a class="typo-link" href="#imperative-finally-block">Imperative finally block</a></li> <li class="typo-list__item"><a class="typo-link" href="#declarative-handling">Declarative handling</a></li> <li class="typo-list__item"><a class="typo-link" href="#successful-completion">Successful completion</a></li> </ul> </li> <li class="typo-list__item"><a class="typo-link" href="#imperative-versus-declarative">Imperative versus declarative</a></li> <li class="typo-list__item"><a class="typo-link" href="#launching-flow">Launching flow</a></li> <li class="typo-list__item">
<a class="typo-link" href="#flow-cancellation-checks">Flow cancellation checks</a> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item"><a class="typo-link" href="#making-busy-flow-cancellable">Making busy flow cancellable</a></li> </ul> </li> <li class="typo-list__item"><a class="typo-link" href="#flow-and-reactive-streams">Flow and Reactive Streams</a></li> </ul> </li> </ul>  <h2 class="typo-header typo-h2" id="asynchronous-flow">Asynchronous Flow</h2> <p class="typo-para">A suspending function asynchronously returns a single value, but how can we return multiple asynchronously computed values? This is where Kotlin Flows come in.</p> <h3 class="typo-header typo-h3" id="representing-multiple-values">Representing multiple values</h3> <p class="typo-para">Multiple values can be represented in Kotlin using <a class="typo-link" href="../collections-overview">collections</a>. For example, we can have a <code>simple</code> function that returns a <a class="typo-link" href="../../../api/latest/jvm/stdlib/kotlin.collections/-list/index">List</a> of three numbers and then print them all using <a class="typo-link" href="../../../api/latest/jvm/stdlib/kotlin.collections/for-each">forEach</a>:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">fun simple(): List&lt;Int&gt; = listOf(1, 2, 3)
 
fun main() {
    simple().forEach { value -&gt; println(value) } 
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-01.kt">here</a>.</p> </blockquote> <p class="typo-para">This code outputs:</p> <pre>1
2
3
</pre>  <h4 class="typo-header typo-h4" id="sequences">Sequences</h4> <p class="typo-para">If we are computing the numbers with some CPU-consuming blocking code (each computation taking 100ms), then we can represent the numbers using a <a class="typo-link" href="../../../api/latest/jvm/stdlib/kotlin.sequences/index">Sequence</a>:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">fun simple(): Sequence&lt;Int&gt; = sequence { // sequence builder
    for (i in 1..3) {
        Thread.sleep(100) // pretend we are computing it
        yield(i) // yield next value
    }
}

fun main() {
    simple().forEach { value -&gt; println(value) } 
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-02.kt">here</a>.</p> </blockquote> <p class="typo-para">This code outputs the same numbers, but it waits 100ms before printing each one.</p>  <h4 class="typo-header typo-h4" id="suspending-functions">Suspending functions</h4> <p class="typo-para">However, this computation blocks the main thread that is running the code. When these values are computed by asynchronous code we can mark the <code>simple</code> function with a <code>suspend</code> modifier, so that it can perform its work without blocking and return the result as a list:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*                 
                           
//sampleStart
suspend fun simple(): List&lt;Int&gt; {
    delay(1000) // pretend we are doing something asynchronous here
    return listOf(1, 2, 3)
}

fun main() = runBlocking&lt;Unit&gt; {
    simple().forEach { value -&gt; println(value) } 
}
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-03.kt">here</a>.</p> </blockquote> <p class="typo-para">This code prints the numbers after waiting for a second.</p>  <h4 class="typo-header typo-h4" id="flows">Flows</h4> <p class="typo-para">Using the <code>List&lt;Int&gt;</code> result type, means we can only return all the values at once. To represent the stream of values that are being asynchronously computed, we can use a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html"><code>Flow&lt;Int&gt;</code></a> type just like we would use the <code>Sequence&lt;Int&gt;</code> type for synchronously computed values:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart               
fun simple(): Flow&lt;Int&gt; = flow { // flow builder
    for (i in 1..3) {
        delay(100) // pretend we are doing something useful here
        emit(i) // emit next value
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    // Launch a concurrent coroutine to check if the main thread is blocked
    launch {
        for (k in 1..3) {
            println("I'm not blocked $k")
            delay(100)
        }
    }
    // Collect the flow
    simple().collect { value -&gt; println(value) } 
}
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-04.kt">here</a>.</p> </blockquote> <p class="typo-para">This code waits 100ms before printing each number without blocking the main thread. This is verified by printing "I'm not blocked" every 100ms from a separate coroutine that is running in the main thread:</p> <pre>I'm not blocked 1
1
I'm not blocked 2
2
I'm not blocked 3
3
</pre>  <p class="typo-para">Notice the following differences in the code with the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html">Flow</a> from the earlier examples:</p> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">A builder function for <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html">Flow</a> type is called <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html">flow</a>.</li> <li class="typo-list__item">Code inside the <code>flow { ... }</code> builder block can suspend.</li> <li class="typo-list__item">The <code>simple</code> function is no longer marked with <code>suspend</code> modifier.</li> <li class="typo-list__item">Values are <em>emitted</em> from the flow using <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a> function.</li> <li class="typo-list__item">Values are <em>collected</em> from the flow using <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> function.</li> </ul> <blockquote class="typo-quote"> <p class="typo-para">We can replace <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a> with <code>Thread.sleep</code> in the body of <code>simple</code>'s <code>flow { ... }</code> and see that the main thread is blocked in this case.</p> </blockquote> <h3 class="typo-header typo-h3" id="flows-are-cold">Flows are cold</h3> <p class="typo-para">Flows are <em>cold</em> streams similar to sequences — the code inside a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html">flow</a> builder does not run until the flow is collected. This becomes clear in the following example:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart      
fun simple(): Flow&lt;Int&gt; = flow { 
    println("Flow started")
    for (i in 1..3) {
        delay(100)
        emit(i)
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    println("Calling simple function...")
    val flow = simple()
    println("Calling collect...")
    flow.collect { value -&gt; println(value) } 
    println("Calling collect again...")
    flow.collect { value -&gt; println(value) } 
}
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-05.kt">here</a>.</p> </blockquote> <p class="typo-para">Which prints:</p> <pre>Calling simple function...
Calling collect...
Flow started
1
2
3
Calling collect again...
Flow started
1
2
3
</pre>  <p class="typo-para">This is a key reason the <code>simple</code> function (which returns a flow) is not marked with <code>suspend</code> modifier. By itself, <code>simple()</code> call returns quickly and does not wait for anything. The flow starts every time it is collected, that is why we see "Flow started" when we call <code>collect</code> again.</p> <h3 class="typo-header typo-h3" id="flow-cancellation-basics">Flow cancellation basics</h3> <p class="typo-para">Flow adheres to the general cooperative cancellation of coroutines. As usual, flow collection can be cancelled when the flow is suspended in a cancellable suspending function (like <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>). The following example shows how the flow gets cancelled on a timeout when running in a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout-or-null.html">withTimeoutOrNull</a> block and stops executing its code:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart           
fun simple(): Flow&lt;Int&gt; = flow { 
    for (i in 1..3) {
        delay(100)          
        println("Emitting $i")
        emit(i)
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    withTimeoutOrNull(250) { // Timeout after 250ms 
        simple().collect { value -&gt; println(value) } 
    }
    println("Done")
}
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-06.kt">here</a>.</p> </blockquote> <p class="typo-para">Notice how only two numbers get emitted by the flow in the <code>simple</code> function, producing the following output:</p> <pre>Emitting 1
1
Emitting 2
2
Done
</pre>  <p class="typo-para">See <a class="typo-link" href="#flow-cancellation-checks">Flow cancellation checks</a> section for more details.</p> <h3 class="typo-header typo-h3" id="flow-builders">Flow builders</h3> <p class="typo-para">The <code>flow { ... }</code> builder from the previous examples is the most basic one. There are other builders for easier declaration of flows:</p> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">
<a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-of.html">flowOf</a> builder that defines a flow emitting a fixed set of values.</li> <li class="typo-list__item">Various collections and sequences can be converted to flows using <code>.asFlow()</code> extension functions.</li> </ul> <p class="typo-para">So, the example that prints the numbers from 1 to 3 from a flow can be written as:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    // Convert an integer range to a flow
    (1..3).asFlow().collect { value -&gt; println(value) }
//sampleEnd 
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-07.kt">here</a>.</p> </blockquote>  <h3 class="typo-header typo-h3" id="intermediate-flow-operators">Intermediate flow operators</h3> <p class="typo-para">Flows can be transformed with operators, just as you would with collections and sequences. Intermediate operators are applied to an upstream flow and return a downstream flow. These operators are cold, just like flows are. A call to such an operator is not a suspending function itself. It works quickly, returning the definition of a new transformed flow.</p> <p class="typo-para">The basic operators have familiar names like <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html">map</a> and <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html">filter</a>. The important difference to sequences is that blocks of code inside these operators can call suspending functions.</p> <p class="typo-para">For example, a flow of incoming requests can be mapped to the results with the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html">map</a> operator, even when performing a request is a long-running operation that is implemented by a suspending function:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart           
suspend fun performRequest(request: Int): String {
    delay(1000) // imitate long-running asynchronous work
    return "response $request"
}

fun main() = runBlocking&lt;Unit&gt; {
    (1..3).asFlow() // a flow of requests
        .map { request -&gt; performRequest(request) }
        .collect { response -&gt; println(response) }
}
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-08.kt">here</a>.</p> </blockquote> <p class="typo-para">It produces the following three lines, each line appearing after each second:</p> <pre>response 1
response 2
response 3
</pre>  <h4 class="typo-header typo-h4" id="transform-operator">Transform operator</h4> <p class="typo-para">Among the flow transformation operators, the most general one is called <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html">transform</a>. It can be used to imitate simple transformations like <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html">map</a> and <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html">filter</a>, as well as implement more complex transformations. Using the <code>transform</code> operator, we can <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a> arbitrary values an arbitrary number of times.</p> <p class="typo-para">For example, using <code>transform</code> we can emit a string before performing a long-running asynchronous request and follow it with a response:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

suspend fun performRequest(request: Int): String {
    delay(1000) // imitate long-running asynchronous work
    return "response $request"
}

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    (1..3).asFlow() // a flow of requests
        .transform { request -&gt;
            emit("Making request $request") 
            emit(performRequest(request)) 
        }
        .collect { response -&gt; println(response) }
//sampleEnd
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-09.kt">here</a>.</p> </blockquote> <p class="typo-para">The output of this code is:</p> <pre>Making request 1
response 1
Making request 2
response 2
Making request 3
response 3
</pre>  <h4 class="typo-header typo-h4" id="size-limiting-operators">Size-limiting operators</h4> <p class="typo-para">Size-limiting intermediate operators like <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/take.html">take</a> cancel the execution of the flow when the corresponding limit is reached. Cancellation in coroutines is always performed by throwing an exception, so that all the resource-management functions (like <code>try { ... } finally { ... }</code> blocks) operate normally in case of cancellation:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun numbers(): Flow&lt;Int&gt; = flow {
    try {                          
        emit(1)
        emit(2) 
        println("This line will not execute")
        emit(3)    
    } finally {
        println("Finally in numbers")
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    numbers() 
        .take(2) // take only the first two
        .collect { value -&gt; println(value) }
}            
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-10.kt">here</a>.</p> </blockquote> <p class="typo-para">The output of this code clearly shows that the execution of the <code>flow { ... }</code> body in the <code>numbers()</code> function stopped after emitting the second number:</p> <pre>1
2
Finally in numbers
</pre>  <h3 class="typo-header typo-h3" id="terminal-flow-operators">Terminal flow operators</h3> <p class="typo-para">Terminal operators on flows are <em>suspending functions</em> that start a collection of the flow. The <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> operator is the most basic one, but there are other terminal operators, which can make it easier:</p> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">Conversion to various collections like <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html">toList</a> and <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-set.html">toSet</a>.</li> <li class="typo-list__item">Operators to get the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/first.html">first</a> value and to ensure that a flow emits a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/single.html">single</a> value.</li> <li class="typo-list__item">Reducing a flow to a value with <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/reduce.html">reduce</a> and <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/fold.html">fold</a>.</li> </ul> <p class="typo-para">For example:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart         
    val sum = (1..5).asFlow()
        .map { it * it } // squares of numbers from 1 to 5                           
        .reduce { a, b -&gt; a + b } // sum them (terminal operator)
    println(sum)
//sampleEnd     
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-11.kt">here</a>.</p> </blockquote> <p class="typo-para">Prints a single number:</p> <pre>55
</pre>  <h3 class="typo-header typo-h3" id="flows-are-sequential">Flows are sequential</h3> <p class="typo-para">Each individual collection of a flow is performed sequentially unless special operators that operate on multiple flows are used. The collection works directly in the coroutine that calls a terminal operator. No new coroutines are launched by default. Each emitted value is processed by all the intermediate operators from upstream to downstream and is then delivered to the terminal operator after.</p> <p class="typo-para">See the following example that filters the even integers and maps them to strings:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart         
    (1..5).asFlow()
        .filter {
            println("Filter $it")
            it % 2 == 0              
        }              
        .map { 
            println("Map $it")
            "string $it"
        }.collect { 
            println("Collect $it")
        }    
//sampleEnd                  
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-12.kt">here</a>.</p> </blockquote> <p class="typo-para">Producing:</p> <pre>Filter 1
Filter 2
Map 2
Collect string 2
Filter 3
Filter 4
Map 4
Collect string 4
Filter 5
</pre>  <h3 class="typo-header typo-h3" id="flow-context">Flow context</h3> <p class="typo-para">Collection of a flow always happens in the context of the calling coroutine. For example, if there is a <code>simple</code> flow, then the following code runs in the context specified by the author of this code, regardless of the implementation details of the <code>simple</code> flow:</p> <div class="sample"> <pre data-language="kotlin">withContext(context) {
    simple().collect { value -&gt;
        println(value) // run in the specified context 
    }
}
</pre> </div>  <p class="typo-para">This property of a flow is called <em>context preservation</em>.</p> <p class="typo-para">So, by default, code in the <code>flow { ... }</code> builder runs in the context that is provided by a collector of the corresponding flow. For example, consider the implementation of a <code>simple</code> function that prints the thread it is called on and emits three numbers:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")
           
//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    log("Started simple flow")
    for (i in 1..3) {
        emit(i)
    }
}  

fun main() = runBlocking&lt;Unit&gt; {
    simple().collect { value -&gt; log("Collected $value") } 
}            
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-13.kt">here</a>.</p> </blockquote> <p class="typo-para">Running this code produces:</p> <pre>[main @coroutine#1] Started simple flow
[main @coroutine#1] Collected 1
[main @coroutine#1] Collected 2
[main @coroutine#1] Collected 3
</pre>  <p class="typo-para">Since <code>simple().collect</code> is called from the main thread, the body of <code>simple</code>'s flow is also called in the main thread. This is the perfect default for fast-running or asynchronous code that does not care about the execution context and does not block the caller.</p> <h4 class="typo-header typo-h4" id="wrong-emission-withcontext">Wrong emission withContext</h4> <p class="typo-para">However, the long-running CPU-consuming code might need to be executed in the context of <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Dispatchers.Default</a> and UI-updating code might need to be executed in the context of <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html">Dispatchers.Main</a>. Usually, <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">withContext</a> is used to change the context in the code using Kotlin coroutines, but code in the <code>flow { ... }</code> builder has to honor the context preservation property and is not allowed to <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a> from a different context.</p> <p class="typo-para">Try running the following code:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
                      
//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    // The WRONG way to change context for CPU-consuming code in flow builder
    kotlinx.coroutines.withContext(Dispatchers.Default) {
        for (i in 1..3) {
            Thread.sleep(100) // pretend we are computing it in CPU-consuming way
            emit(i) // emit next value
        }
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    simple().collect { value -&gt; println(value) } 
}            
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-14.kt">here</a>.</p> </blockquote> <p class="typo-para">This code produces the following exception:</p> <pre>Exception in thread "main" java.lang.IllegalStateException: Flow invariant is violated:
		Flow was collected in [CoroutineId(1), "coroutine#1":BlockingCoroutine{Active}@5511c7f8, BlockingEventLoop@2eac3323],
		but emission happened in [CoroutineId(1), "coroutine#1":DispatchedCoroutine{Active}@2dae0000, Dispatchers.Default].
		Please refer to 'flow' documentation or use 'flowOn' instead
	at ...
</pre>  <h4 class="typo-header typo-h4" id="flowon-operator">flowOn operator</h4> <p class="typo-para">The exception refers to the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html">flowOn</a> function that shall be used to change the context of the flow emission. The correct way to change the context of a flow is shown in the example below, which also prints the names of the corresponding threads to show how it all works:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")
           
//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        Thread.sleep(100) // pretend we are computing it in CPU-consuming way
        log("Emitting $i")
        emit(i) // emit next value
    }
}.flowOn(Dispatchers.Default) // RIGHT way to change context for CPU-consuming code in flow builder

fun main() = runBlocking&lt;Unit&gt; {
    simple().collect { value -&gt;
        log("Collected $value") 
    } 
}            
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-15.kt">here</a>.</p> </blockquote> <p class="typo-para">Notice how <code>flow { ... }</code> works in the background thread, while collection happens in the main thread:</p>  <p class="typo-para">Another thing to observe here is that the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html">flowOn</a> operator has changed the default sequential nature of the flow. Now collection happens in one coroutine ("coroutine#1") and emission happens in another coroutine ("coroutine#2") that is running in another thread concurrently with the collecting coroutine. The <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html">flowOn</a> operator creates another coroutine for an upstream flow when it has to change the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a> in its context.</p> <h3 class="typo-header typo-h3" id="buffering">Buffering</h3> <p class="typo-para">Running different parts of a flow in different coroutines can be helpful from the standpoint of the overall time it takes to collect the flow, especially when long-running asynchronous operations are involved. For example, consider a case when the emission by a <code>simple</code> flow is slow, taking 100 ms to produce an element; and collector is also slow, taking 300 ms to process an element. Let's see how long it takes to collect such a flow with three numbers:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlin.system.*

//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        delay(100) // pretend we are asynchronously waiting 100 ms
        emit(i) // emit next value
    }
}

fun main() = runBlocking&lt;Unit&gt; { 
    val time = measureTimeMillis {
        simple().collect { value -&gt; 
            delay(300) // pretend we are processing it for 300 ms
            println(value) 
        } 
    }   
    println("Collected in $time ms")
}
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-16.kt">here</a>.</p> </blockquote> <p class="typo-para">It produces something like this, with the whole collection taking around 1200 ms (three numbers, 400 ms for each):</p> <pre>1
2
3
Collected in 1220 ms
</pre>  <p class="typo-para">We can use a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html">buffer</a> operator on a flow to run emitting code of the <code>simple</code> flow concurrently with collecting code, as opposed to running them sequentially:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlin.system.*

fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        delay(100) // pretend we are asynchronously waiting 100 ms
        emit(i) // emit next value
    }
}

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart
    val time = measureTimeMillis {
        simple()
            .buffer() // buffer emissions, don't wait
            .collect { value -&gt; 
                delay(300) // pretend we are processing it for 300 ms
                println(value) 
            } 
    }   
    println("Collected in $time ms")
//sampleEnd
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-17.kt">here</a>.</p> </blockquote> <p class="typo-para">It produces the same numbers just faster, as we have effectively created a processing pipeline, having to only wait 100 ms for the first number and then spending only 300 ms to process each number. This way it takes around 1000 ms to run:</p> <pre>1
2
3
Collected in 1071 ms
</pre>  <blockquote class="typo-quote"> <p class="typo-para">Note that the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html">flowOn</a> operator uses the same buffering mechanism when it has to change a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a>, but here we explicitly request buffering without changing the execution context.</p> </blockquote> <h4 class="typo-header typo-h4" id="conflation">Conflation</h4> <p class="typo-para">When a flow represents partial results of the operation or operation status updates, it may not be necessary to process each value, but instead, only most recent ones. In this case, the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html">conflate</a> operator can be used to skip intermediate values when a collector is too slow to process them. Building on the previous example:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlin.system.*

fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        delay(100) // pretend we are asynchronously waiting 100 ms
        emit(i) // emit next value
    }
}

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart
    val time = measureTimeMillis {
        simple()
            .conflate() // conflate emissions, don't process each one
            .collect { value -&gt; 
                delay(300) // pretend we are processing it for 300 ms
                println(value) 
            } 
    }   
    println("Collected in $time ms")
//sampleEnd
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-18.kt">here</a>.</p> </blockquote> <p class="typo-para">We see that while the first number was still being processed the second, and third were already produced, so the second one was <em>conflated</em> and only the most recent (the third one) was delivered to the collector:</p> <pre>1
3
Collected in 758 ms
</pre>  <h4 class="typo-header typo-h4" id="processing-the-latest-value">Processing the latest value</h4> <p class="typo-para">Conflation is one way to speed up processing when both the emitter and collector are slow. It does it by dropping emitted values. The other way is to cancel a slow collector and restart it every time a new value is emitted. There is a family of <code>xxxLatest</code> operators that perform the same essential logic of a <code>xxx</code> operator, but cancel the code in their block on a new value. Let's try changing <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html">conflate</a> to <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html">collectLatest</a> in the previous example:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlin.system.*

fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        delay(100) // pretend we are asynchronously waiting 100 ms
        emit(i) // emit next value
    }
}

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart
    val time = measureTimeMillis {
        simple()
            .collectLatest { value -&gt; // cancel &amp; restart on the latest value
                println("Collecting $value") 
                delay(300) // pretend we are processing it for 300 ms
                println("Done $value") 
            } 
    }   
    println("Collected in $time ms")
//sampleEnd
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-19.kt">here</a>.</p> </blockquote> <p class="typo-para">Since the body of <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html">collectLatest</a> takes 300 ms, but new values are emitted every 100 ms, we see that the block is run on every value, but completes only for the last value:</p> <pre>Collecting 1
Collecting 2
Collecting 3
Done 3
Collected in 741 ms
</pre>  <h3 class="typo-header typo-h3" id="composing-multiple-flows">Composing multiple flows</h3> <p class="typo-para">There are lots of ways to compose multiple flows.</p> <h4 class="typo-header typo-h4" id="zip">Zip</h4> <p class="typo-para">Just like the <a class="typo-link" href="../../../api/latest/jvm/stdlib/kotlin.sequences/zip">Sequence.zip</a> extension function in the Kotlin standard library, flows have a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html">zip</a> operator that combines the corresponding values of two flows:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart                                                                           
    val nums = (1..3).asFlow() // numbers 1..3
    val strs = flowOf("one", "two", "three") // strings 
    nums.zip(strs) { a, b -&gt; "$a -&gt; $b" } // compose a single string
        .collect { println(it) } // collect and print
//sampleEnd
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-20.kt">here</a>.</p> </blockquote> <p class="typo-para">This example prints:</p> <pre>1 -&gt; one
2 -&gt; two
3 -&gt; three
</pre>  <h4 class="typo-header typo-h4" id="combine">Combine</h4> <p class="typo-para">When flow represents the most recent value of a variable or operation (see also the related section on <a class="typo-link" href="#conflation">conflation</a>), it might be needed to perform a computation that depends on the most recent values of the corresponding flows and to recompute it whenever any of the upstream flows emit a value. The corresponding family of operators is called <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html">combine</a>.</p> <p class="typo-para">For example, if the numbers in the previous example update every 300ms, but strings update every 400 ms, then zipping them using the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html">zip</a> operator will still produce the same result, albeit results that are printed every 400 ms:</p> <blockquote class="typo-quote"> <p class="typo-para">We use a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html">onEach</a> intermediate operator in this example to delay each element and make the code that emits sample flows more declarative and shorter.</p> </blockquote> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart                                                                           
    val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms
    val strs = flowOf("one", "two", "three").onEach { delay(400) } // strings every 400 ms
    val startTime = System.currentTimeMillis() // remember the start time 
    nums.zip(strs) { a, b -&gt; "$a -&gt; $b" } // compose a single string with "zip"
        .collect { value -&gt; // collect and print 
            println("$value at ${System.currentTimeMillis() - startTime} ms from start") 
        } 
//sampleEnd
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-21.kt">here</a>.</p> </blockquote>  <p class="typo-para">However, when using a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html">combine</a> operator here instead of a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html">zip</a>:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart                                                                           
    val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms
    val strs = flowOf("one", "two", "three").onEach { delay(400) } // strings every 400 ms          
    val startTime = System.currentTimeMillis() // remember the start time 
    nums.combine(strs) { a, b -&gt; "$a -&gt; $b" } // compose a single string with "combine"
        .collect { value -&gt; // collect and print 
            println("$value at ${System.currentTimeMillis() - startTime} ms from start") 
        } 
//sampleEnd
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-22.kt">here</a>.</p> </blockquote> <p class="typo-para">We get quite a different output, where a line is printed at each emission from either <code>nums</code> or <code>strs</code> flows:</p> <pre>1 -&gt; one at 452 ms from start
2 -&gt; one at 651 ms from start
2 -&gt; two at 854 ms from start
3 -&gt; two at 952 ms from start
3 -&gt; three at 1256 ms from start
</pre>  <h3 class="typo-header typo-h3" id="flattening-flows">Flattening flows</h3> <p class="typo-para">Flows represent asynchronously received sequences of values, so it is quite easy to get in a situation where each value triggers a request for another sequence of values. For example, we can have the following function that returns a flow of two strings 500 ms apart:</p> <div class="sample"> <pre data-language="kotlin">fun requestFlow(i: Int): Flow&lt;String&gt; = flow {
    emit("$i: First") 
    delay(500) // wait 500 ms
    emit("$i: Second")    
}
</pre> </div>  <p class="typo-para">Now if we have a flow of three integers and call <code>requestFlow</code> for each of them like this:</p> <div class="sample"> <pre data-language="kotlin">(1..3).asFlow().map { requestFlow(it) }
</pre> </div>  <p class="typo-para">Then we end up with a flow of flows (<code>Flow&lt;Flow&lt;String&gt;&gt;</code>) that needs to be <em>flattened</em> into a single flow for further processing. Collections and sequences have <a class="typo-link" href="../../../api/latest/jvm/stdlib/kotlin.sequences/flatten">flatten</a> and <a class="typo-link" href="../../../api/latest/jvm/stdlib/kotlin.sequences/flat-map">flatMap</a> operators for this. However, due to the asynchronous nature of flows they call for different <em>modes</em> of flattening, as such, there is a family of flattening operators on flows.</p> <h4 class="typo-header typo-h4" id="flatmapconcat">flatMapConcat</h4> <p class="typo-para">Concatenating mode is implemented by <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html">flatMapConcat</a> and <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-concat.html">flattenConcat</a> operators. They are the most direct analogues of the corresponding sequence operators. They wait for the inner flow to complete before starting to collect the next one as the following example shows:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun requestFlow(i: Int): Flow&lt;String&gt; = flow {
    emit("$i: First") 
    delay(500) // wait 500 ms
    emit("$i: Second")    
}

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart
    val startTime = System.currentTimeMillis() // remember the start time 
    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms 
        .flatMapConcat { requestFlow(it) }                                                                           
        .collect { value -&gt; // collect and print 
            println("$value at ${System.currentTimeMillis() - startTime} ms from start") 
        } 
//sampleEnd
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-23.kt">here</a>.</p> </blockquote> <p class="typo-para">The sequential nature of <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html">flatMapConcat</a> is clearly seen in the output:</p> <pre>1: First at 121 ms from start
1: Second at 622 ms from start
2: First at 727 ms from start
2: Second at 1227 ms from start
3: First at 1328 ms from start
3: Second at 1829 ms from start
</pre>  <h4 class="typo-header typo-h4" id="flatmapmerge">flatMapMerge</h4> <p class="typo-para">Another flattening mode is to concurrently collect all the incoming flows and merge their values into a single flow so that values are emitted as soon as possible. It is implemented by <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html">flatMapMerge</a> and <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-merge.html">flattenMerge</a> operators. They both accept an optional <code>concurrency</code> parameter that limits the number of concurrent flows that are collected at the same time (it is equal to <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-d-e-f-a-u-l-t_-c-o-n-c-u-r-r-e-n-c-y.html">DEFAULT_CONCURRENCY</a> by default).</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun requestFlow(i: Int): Flow&lt;String&gt; = flow {
    emit("$i: First") 
    delay(500) // wait 500 ms
    emit("$i: Second")    
}

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart
    val startTime = System.currentTimeMillis() // remember the start time 
    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms 
        .flatMapMerge { requestFlow(it) }                                                                           
        .collect { value -&gt; // collect and print 
            println("$value at ${System.currentTimeMillis() - startTime} ms from start") 
        } 
//sampleEnd
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-24.kt">here</a>.</p> </blockquote> <p class="typo-para">The concurrent nature of <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html">flatMapMerge</a> is obvious:</p> <pre>1: First at 136 ms from start
2: First at 231 ms from start
3: First at 333 ms from start
1: Second at 639 ms from start
2: Second at 732 ms from start
3: Second at 833 ms from start
</pre>  <blockquote class="typo-quote"> <p class="typo-para">Note that the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html">flatMapMerge</a> calls its block of code (<code>{ requestFlow(it) }</code> in this example) sequentially, but collects the resulting flows concurrently, it is the equivalent of performing a sequential <code>map { requestFlow(it) }</code> first and then calling <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-merge.html">flattenMerge</a> on the result.</p> </blockquote> <h4 class="typo-header typo-h4" id="flatmaplatest">flatMapLatest</h4> <p class="typo-para">In a similar way to the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html">collectLatest</a> operator, that was shown in <a class="typo-link" href="#processing-the-latest-value">"Processing the latest value"</a> section, there is the corresponding "Latest" flattening mode where a collection of the previous flow is cancelled as soon as new flow is emitted. It is implemented by the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html">flatMapLatest</a> operator.</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun requestFlow(i: Int): Flow&lt;String&gt; = flow {
    emit("$i: First") 
    delay(500) // wait 500 ms
    emit("$i: Second")    
}

fun main() = runBlocking&lt;Unit&gt; { 
//sampleStart
    val startTime = System.currentTimeMillis() // remember the start time 
    (1..3).asFlow().onEach { delay(100) } // a number every 100 ms 
        .flatMapLatest { requestFlow(it) }                                                                           
        .collect { value -&gt; // collect and print 
            println("$value at ${System.currentTimeMillis() - startTime} ms from start") 
        } 
//sampleEnd
}
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-25.kt">here</a>.</p> </blockquote> <p class="typo-para">The output here in this example is a good demonstration of how <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html">flatMapLatest</a> works:</p> <pre>1: First at 142 ms from start
2: First at 322 ms from start
3: First at 425 ms from start
3: Second at 931 ms from start
</pre>  <blockquote class="typo-quote"> <p class="typo-para">Note that <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html">flatMapLatest</a> cancels all the code in its block (<code>{ requestFlow(it) }</code> in this example) on a new value. It makes no difference in this particular example, because the call to <code>requestFlow</code> itself is fast, not-suspending, and cannot be cancelled. However, it would show up if we were to use suspending functions like <code>delay</code> in there.</p> </blockquote> <h3 class="typo-header typo-h3" id="flow-exceptions">Flow exceptions</h3> <p class="typo-para">Flow collection can complete with an exception when an emitter or code inside the operators throw an exception. There are several ways to handle these exceptions.</p> <h4 class="typo-header typo-h4" id="collector-try-and-catch">Collector try and catch</h4> <p class="typo-para">A collector can use Kotlin's <a class="typo-link" href="../exceptions"><code>try/catch</code></a> block to handle exceptions:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        println("Emitting $i")
        emit(i) // emit next value
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    try {
        simple().collect { value -&gt;         
            println(value)
            check(value &lt;= 1) { "Collected $value" }
        }
    } catch (e: Throwable) {
        println("Caught $e")
    } 
}            
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-26.kt">here</a>.</p> </blockquote> <p class="typo-para">This code successfully catches an exception in <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> terminal operator and, as we see, no more values are emitted after that:</p> <pre>Emitting 1
1
Emitting 2
2
Caught java.lang.IllegalStateException: Collected 2
</pre>  <h4 class="typo-header typo-h4" id="everything-is-caught">Everything is caught</h4> <p class="typo-para">The previous example actually catches any exception happening in the emitter or in any intermediate or terminal operators. For example, let's change the code so that emitted values are <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html">mapped</a> to strings, but the corresponding code produces an exception:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun simple(): Flow&lt;String&gt; = 
    flow {
        for (i in 1..3) {
            println("Emitting $i")
            emit(i) // emit next value
        }
    }
    .map { value -&gt;
        check(value &lt;= 1) { "Crashed on $value" }                 
        "string $value"
    }

fun main() = runBlocking&lt;Unit&gt; {
    try {
        simple().collect { value -&gt; println(value) }
    } catch (e: Throwable) {
        println("Caught $e")
    } 
}            
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-27.kt">here</a>.</p> </blockquote> <p class="typo-para">This exception is still caught and collection is stopped:</p> <pre>Emitting 1
string 1
Emitting 2
Caught java.lang.IllegalStateException: Crashed on 2
</pre>  <h3 class="typo-header typo-h3" id="exception-transparency">Exception transparency</h3> <p class="typo-para">But how can code of the emitter encapsulate its exception handling behavior?</p> <p class="typo-para">Flows must be <em>transparent to exceptions</em> and it is a violation of the exception transparency to <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a> values in the <code>flow { ... }</code> builder from inside of a <code>try/catch</code> block. This guarantees that a collector throwing an exception can always catch it using <code>try/catch</code> as in the previous example.</p> <p class="typo-para">The emitter can use a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch</a> operator that preserves this exception transparency and allows encapsulation of its exception handling. The body of the <code>catch</code> operator can analyze an exception and react to it in different ways depending on which exception was caught:</p> <ul class="typo-list typo-list_type_simple"> <li class="typo-list__item">Exceptions can be rethrown using <code>throw</code>.</li> <li class="typo-list__item">Exceptions can be turned into emission of values using <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a> from the body of <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch</a>.</li> <li class="typo-list__item">Exceptions can be ignored, logged, or processed by some other code.</li> </ul> <p class="typo-para">For example, let us emit the text on catching an exception:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun simple(): Flow&lt;String&gt; = 
    flow {
        for (i in 1..3) {
            println("Emitting $i")
            emit(i) // emit next value
        }
    }
    .map { value -&gt;
        check(value &lt;= 1) { "Crashed on $value" }                 
        "string $value"
    }

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    simple()
        .catch { e -&gt; emit("Caught $e") } // emit on exception
        .collect { value -&gt; println(value) }
//sampleEnd
}            
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-28.kt">here</a>.</p> </blockquote> <p class="typo-para">The output of the example is the same, even though we do not have <code>try/catch</code> around the code anymore.</p>  <h4 class="typo-header typo-h4" id="transparent-catch">Transparent catch</h4> <p class="typo-para">The <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch</a> intermediate operator, honoring exception transparency, catches only upstream exceptions (that is an exception from all the operators above <code>catch</code>, but not below it). If the block in <code>collect { ... }</code> (placed below <code>catch</code>) throws an exception then it escapes:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        println("Emitting $i")
        emit(i)
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    simple()
        .catch { e -&gt; println("Caught $e") } // does not catch downstream exceptions
        .collect { value -&gt;
            check(value &lt;= 1) { "Collected $value" }                 
            println(value) 
        }
}            
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-29.kt">here</a>.</p> </blockquote> <p class="typo-para">A "Caught …" message is not printed despite there being a <code>catch</code> operator:</p> <pre>Emitting 1
1
Emitting 2
Exception in thread "main" java.lang.IllegalStateException: Collected 2
	at ...
</pre>  <h4 class="typo-header typo-h4" id="catching-declaratively">Catching declaratively</h4> <p class="typo-para">We can combine the declarative nature of the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch</a> operator with a desire to handle all the exceptions, by moving the body of the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> operator into <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html">onEach</a> and putting it before the <code>catch</code> operator. Collection of this flow must be triggered by a call to <code>collect()</code> without parameters:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun simple(): Flow&lt;Int&gt; = flow {
    for (i in 1..3) {
        println("Emitting $i")
        emit(i)
    }
}

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    simple()
        .onEach { value -&gt;
            check(value &lt;= 1) { "Collected $value" }                 
            println(value) 
        }
        .catch { e -&gt; println("Caught $e") }
        .collect()
//sampleEnd
}            
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-30.kt">here</a>.</p> </blockquote> <p class="typo-para">Now we can see that a "Caught …" message is printed and so we can catch all the exceptions without explicitly using a <code>try/catch</code> block:</p> <pre>Emitting 1
1
Emitting 2
Caught java.lang.IllegalStateException: Collected 2
</pre>  <h3 class="typo-header typo-h3" id="flow-completion">Flow completion</h3> <p class="typo-para">When flow collection completes (normally or exceptionally) it may need to execute an action. As you may have already noticed, it can be done in two ways: imperative or declarative.</p> <h4 class="typo-header typo-h4" id="imperative-finally-block">Imperative finally block</h4> <p class="typo-para">In addition to <code>try</code>/<code>catch</code>, a collector can also use a <code>finally</code> block to execute an action upon <code>collect</code> completion.</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun simple(): Flow&lt;Int&gt; = (1..3).asFlow()

fun main() = runBlocking&lt;Unit&gt; {
    try {
        simple().collect { value -&gt; println(value) }
    } finally {
        println("Done")
    }
}            
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-31.kt">here</a>.</p> </blockquote> <p class="typo-para">This code prints three numbers produced by the <code>simple</code> flow followed by a "Done" string:</p> <pre>1
2
3
Done
</pre>  <h4 class="typo-header typo-h4" id="declarative-handling">Declarative handling</h4> <p class="typo-para">For the declarative approach, flow has <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html">onCompletion</a> intermediate operator that is invoked when the flow has completely collected.</p> <p class="typo-para">The previous example can be rewritten using an <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html">onCompletion</a> operator and produces the same output:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun simple(): Flow&lt;Int&gt; = (1..3).asFlow()

fun main() = runBlocking&lt;Unit&gt; {
//sampleStart
    simple()
        .onCompletion { println("Done") }
        .collect { value -&gt; println(value) }
//sampleEnd
}            
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-32.kt">here</a>.</p> </blockquote>  <p class="typo-para">The key advantage of <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html">onCompletion</a> is a nullable <code>Throwable</code> parameter of the lambda that can be used to determine whether the flow collection was completed normally or exceptionally. In the following example the <code>simple</code> flow throws an exception after emitting the number 1:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun simple(): Flow&lt;Int&gt; = flow {
    emit(1)
    throw RuntimeException()
}

fun main() = runBlocking&lt;Unit&gt; {
    simple()
        .onCompletion { cause -&gt; if (cause != null) println("Flow completed exceptionally") }
        .catch { cause -&gt; println("Caught exception") }
        .collect { value -&gt; println(value) }
}            
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-33.kt">here</a>.</p> </blockquote> <p class="typo-para">As you may expect, it prints:</p> <pre>1
Flow completed exceptionally
Caught exception
</pre>  <p class="typo-para">The <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html">onCompletion</a> operator, unlike <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch</a>, does not handle the exception. As we can see from the above example code, the exception still flows downstream. It will be delivered to further <code>onCompletion</code> operators and can be handled with a <code>catch</code> operator.</p> <h4 class="typo-header typo-h4" id="successful-completion">Successful completion</h4> <p class="typo-para">Another difference with <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch</a> operator is that <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html">onCompletion</a> sees all exceptions and receives a <code>null</code> exception only on successful completion of the upstream flow (without cancellation or failure).</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
fun simple(): Flow&lt;Int&gt; = (1..3).asFlow()

fun main() = runBlocking&lt;Unit&gt; {
    simple()
        .onCompletion { cause -&gt; println("Flow completed with $cause") }
        .collect { value -&gt;
            check(value &lt;= 1) { "Collected $value" }                 
            println(value) 
        }
}
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-34.kt">here</a>.</p> </blockquote> <p class="typo-para">We can see the completion cause is not null, because the flow was aborted due to downstream exception:</p> <pre>1
Flow completed with java.lang.IllegalStateException: Collected 2
Exception in thread "main" java.lang.IllegalStateException: Collected 2
</pre>  <h3 class="typo-header typo-h3" id="imperative-versus-declarative">Imperative versus declarative</h3> <p class="typo-para">Now we know how to collect flow, and handle its completion and exceptions in both imperative and declarative ways. The natural question here is, which approach is preferred and why? As a library, we do not advocate for any particular approach and believe that both options are valid and should be selected according to your own preferences and code style.</p> <h3 class="typo-header typo-h3" id="launching-flow">Launching flow</h3> <p class="typo-para">It is easy to use flows to represent asynchronous events that are coming from some source. In this case, we need an analogue of the <code>addEventListener</code> function that registers a piece of code with a reaction for incoming events and continues further work. The <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html">onEach</a> operator can serve this role. However, <code>onEach</code> is an intermediate operator. We also need a terminal operator to collect the flow. Otherwise, just calling <code>onEach</code> has no effect.</p> <p class="typo-para">If we use the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> terminal operator after <code>onEach</code>, then the code after it will wait until the flow is collected:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart
// Imitate a flow of events
fun events(): Flow&lt;Int&gt; = (1..3).asFlow().onEach { delay(100) }

fun main() = runBlocking&lt;Unit&gt; {
    events()
        .onEach { event -&gt; println("Event: $event") }
        .collect() // &lt;--- Collecting the flow waits
    println("Done")
}            
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-35.kt">here</a>.</p> </blockquote> <p class="typo-para">As you can see, it prints:</p> <pre>Event: 1
Event: 2
Event: 3
Done
</pre>  <p class="typo-para">The <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/launch-in.html">launchIn</a> terminal operator comes in handy here. By replacing <code>collect</code> with <code>launchIn</code> we can launch a collection of the flow in a separate coroutine, so that execution of further code immediately continues:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

// Imitate a flow of events
fun events(): Flow&lt;Int&gt; = (1..3).asFlow().onEach { delay(100) }

//sampleStart
fun main() = runBlocking&lt;Unit&gt; {
    events()
        .onEach { event -&gt; println("Event: $event") }
        .launchIn(this) // &lt;--- Launching the flow in a separate coroutine
    println("Done")
}            
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-36.kt">here</a>.</p> </blockquote> <p class="typo-para">It prints:</p> <pre>Done
Event: 1
Event: 2
Event: 3
</pre>  <p class="typo-para">The required parameter to <code>launchIn</code> must specify a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a> in which the coroutine to collect the flow is launched. In the above example this scope comes from the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a> coroutine builder, so while the flow is running, this <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a> scope waits for completion of its child coroutine and keeps the main function from returning and terminating this example.</p> <p class="typo-para">In actual applications a scope will come from an entity with a limited lifetime. As soon as the lifetime of this entity is terminated the corresponding scope is cancelled, cancelling the collection of the corresponding flow. This way the pair of <code>onEach { ... }.launchIn(scope)</code> works like the <code>addEventListener</code>. However, there is no need for the corresponding <code>removeEventListener</code> function, as cancellation and structured concurrency serve this purpose.</p> <p class="typo-para">Note that <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/launch-in.html">launchIn</a> also returns a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>, which can be used to <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/cancel.html">cancel</a> the corresponding flow collection coroutine only without cancelling the whole scope or to <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html">join</a> it.</p> <h3 class="typo-header typo-h3" id="flow-cancellation-checks">Flow cancellation checks</h3> <p class="typo-para">For convenience, the <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html">flow</a> builder performs additional <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/ensure-active.html">ensureActive</a> checks for cancellation on each emitted value. It means that a busy loop emitting from a <code>flow { ... }</code> is cancellable:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart           
fun foo(): Flow&lt;Int&gt; = flow { 
    for (i in 1..5) {
        println("Emitting $i") 
        emit(i) 
    }
}

fun main() = runBlocking&lt;Unit&gt; {
    foo().collect { value -&gt; 
        if (value == 3) cancel()  
        println(value)
    } 
}
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-37.kt">here</a>.</p> </blockquote> <p class="typo-para">We get only numbers up to 3 and a <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">CancellationException</a> after trying to emit number 4:</p> <pre>Emitting 1
1
Emitting 2
2
Emitting 3
3
Emitting 4
Exception in thread "main" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job="coroutine#1":BlockingCoroutine{Cancelled}@6d7b4f4c
</pre>  <p class="typo-para">However, most other flow operators do not do additional cancellation checks on their own for performance reasons. For example, if you use <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/kotlin.ranges.-int-range/as-flow.html">IntRange.asFlow</a> extension to write the same busy loop and don't suspend anywhere, then there are no checks for cancellation:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart           
fun main() = runBlocking&lt;Unit&gt; {
    (1..5).asFlow().collect { value -&gt; 
        if (value == 3) cancel()  
        println(value)
    } 
}
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-38.kt">here</a>.</p> </blockquote> <p class="typo-para">All numbers from 1 to 5 are collected and cancellation gets detected only before return from <code>runBlocking</code>:</p> <pre>1
2
3
4
5
Exception in thread "main" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job="coroutine#1":BlockingCoroutine{Cancelled}@3327bd23
</pre>  <h4 class="typo-header typo-h4" id="making-busy-flow-cancellable">Making busy flow cancellable</h4> <p class="typo-para">In the case where you have a busy loop with coroutines you must explicitly check for cancellation. You can add <code>.onEach { currentCoroutineContext().ensureActive() }</code>, but there is a ready-to-use <a class="typo-link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/cancellable.html">cancellable</a> operator provided to do that:</p> <div class="sample" data-min-compiler-version="1.3"> <pre data-language="kotlin">import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

//sampleStart           
fun main() = runBlocking&lt;Unit&gt; {
    (1..5).asFlow().cancellable().collect { value -&gt; 
        if (value == 3) cancel()  
        println(value)
    } 
}
//sampleEnd
</pre> </div> <blockquote class="typo-quote"> <p class="typo-para">You can get the full code from <a class="typo-link" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-flow-39.kt">here</a>.</p> </blockquote> <p class="typo-para">With the <code>cancellable</code> operator only the numbers from 1 to 3 are collected:</p> <pre>1
2
3
Exception in thread "main" kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job="coroutine#1":BlockingCoroutine{Cancelled}@5ec0a365
</pre>  <h3 class="typo-header typo-h3" id="flow-and-reactive-streams">Flow and Reactive Streams</h3> <p class="typo-para">For those who are familiar with <a class="typo-link" href="https://www.reactive-streams.org/">Reactive Streams</a> or reactive frameworks such as RxJava and project Reactor, design of the Flow may look very familiar.</p> <p class="typo-para">Indeed, its design was inspired by Reactive Streams and its various implementations. But Flow main goal is to have as simple design as possible, be Kotlin and suspension friendly and respect structured concurrency. Achieving this goal would be impossible without reactive pioneers and their tremendous work. You can read the complete story in <a class="typo-link" href="https://medium.com/@elizarov/reactive-streams-and-kotlin-flows-bfd12772cda4">Reactive Streams and Kotlin Flows</a> article.</p> <p class="typo-para">While being different, conceptually, Flow <em>is</em> a reactive stream and it is possible to convert it to the reactive (spec and TCK compliant) Publisher and vice versa. Such converters are provided by <code>kotlinx.coroutines</code> out-of-the-box and can be found in corresponding reactive modules (<code>kotlinx-coroutines-reactive</code> for Reactive Streams, <code>kotlinx-coroutines-reactor</code> for Project Reactor and <code>kotlinx-coroutines-rx2</code>/<code>kotlinx-coroutines-rx3</code> for RxJava2/RxJava3). Integration modules include conversions from and to <code>Flow</code>, integration with Reactor's <code>Context</code> and suspension-friendly ways to work with various reactive entities.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2020 JetBrains s.r.o. and Kotlin Programming Language contributors<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://kotlinlang.org/docs/reference/coroutines/flow.html" class="_attribution-link">https://kotlinlang.org/docs/reference/coroutines/flow.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
