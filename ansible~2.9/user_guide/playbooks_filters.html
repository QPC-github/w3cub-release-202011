
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Filters - Ansible 2.9 - W3cubDocs</title>
  
  <meta name="description" content="Filters in Ansible are from Jinja2, and are used for transforming data inside a template expression. Jinja2 ships with many filters. See builtin &hellip;">
  <meta name="keywords" content="filters, ansible, ansible~2.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ansible~2.9/user_guide/playbooks_filters.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/ansible~2.9.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ansible~2.9/" class="_nav-link" title="" style="margin-left:0;">Ansible 2.9</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="playbooks-filters">Filters</h1>   <ul id="filters"> <li><a class="reference internal" href="#filters-for-formatting-data" id="id10">Filters For Formatting Data</a></li> <li><a class="reference internal" href="#forcing-variables-to-be-defined" id="id11">Forcing Variables To Be Defined</a></li> <li><a class="reference internal" href="#defaulting-undefined-variables" id="id12">Defaulting Undefined Variables</a></li> <li><a class="reference internal" href="#omitting-parameters" id="id13">Omitting Parameters</a></li> <li><a class="reference internal" href="#list-filters" id="id14">List Filters</a></li> <li><a class="reference internal" href="#set-theory-filters" id="id15">Set Theory Filters</a></li> <li><a class="reference internal" href="#dict-filter" id="id16">Dict Filter</a></li> <li><a class="reference internal" href="#items2dict-filter" id="id17">items2dict filter</a></li> <li><a class="reference internal" href="#zip-and-zip-longest-filters" id="id18">zip and zip_longest filters</a></li> <li><a class="reference internal" href="#subelements-filter" id="id19">subelements Filter</a></li> <li><a class="reference internal" href="#random-mac-address-filter" id="id20">Random Mac Address Filter</a></li> <li><a class="reference internal" href="#random-number-filter" id="id21">Random Number Filter</a></li> <li><a class="reference internal" href="#shuffle-filter" id="id22">Shuffle Filter</a></li> <li><a class="reference internal" href="#math" id="id23">Math</a></li> <li><a class="reference internal" href="#json-query-filter" id="id24">JSON Query Filter</a></li> <li><a class="reference internal" href="#ip-address-filter" id="id25">IP address filter</a></li> <li><a class="reference internal" href="#network-cli-filters" id="id26">Network CLI filters</a></li> <li><a class="reference internal" href="#network-xml-filters" id="id27">Network XML filters</a></li> <li><a class="reference internal" href="#network-vlan-filters" id="id28">Network VLAN filters</a></li> <li><a class="reference internal" href="#hashing-filters" id="id29">Hashing filters</a></li> <li><a class="reference internal" href="#combining-hashes-dictionaries" id="id30">Combining hashes/dictionaries</a></li> <li><a class="reference internal" href="#extracting-values-from-containers" id="id31">Extracting values from containers</a></li> <li><a class="reference internal" href="#comment-filter" id="id32">Comment Filter</a></li> <li><a class="reference internal" href="#url-split-filter" id="id33">URL Split Filter</a></li> <li><a class="reference internal" href="#regular-expression-filters" id="id34">Regular Expression Filters</a></li> <li><a class="reference internal" href="#kubernetes-filters" id="id35">Kubernetes Filters</a></li> <li><a class="reference internal" href="#id8" id="id36">Other Useful Filters</a></li> <li><a class="reference internal" href="#combination-filters" id="id37">Combination Filters</a></li> <li><a class="reference internal" href="#product-filters" id="id38">Product Filters</a></li> <li><a class="reference internal" href="#debugging-filters" id="id39">Debugging Filters</a></li> <li><a class="reference internal" href="#computer-theory-assertions" id="id40">Computer Theory Assertions</a></li> <li><a class="reference internal" href="#human-readable" id="id41">Human Readable</a></li> <li><a class="reference internal" href="#human-to-bytes" id="id42">Human to Bytes</a></li> </ul>
  <p>Filters in Ansible are from Jinja2, and are used for transforming data inside a template expression. Jinja2 ships with many filters. See <a class="reference external" href="http://jinja.pocoo.org/docs/templates/#builtin-filters">builtin filters</a> in the official Jinja2 template documentation.</p> <p>Take into account that templating happens on the Ansible controller, <strong>not</strong> on the task’s target host, so filters also execute on the controller as they manipulate local data.</p> <p>In addition the ones provided by Jinja2, Ansible ships with its own and allows users to add their own custom filters.</p>  <h2 id="id1">Filters For Formatting Data</h2> <p id="filters-for-formatting-data">The following filters will take a data structure in a template and render it in a slightly different format. These are occasionally useful for debugging:</p> <pre data-language="YAML">{{ some_variable | to_json }}
{{ some_variable | to_yaml }}
</pre> <p>For human readable output, you can use:</p> <pre data-language="YAML">{{ some_variable | to_nice_json }}
{{ some_variable | to_nice_yaml }}
</pre> <p>It’s also possible to change the indentation of both (new in version 2.2):</p> <pre data-language="YAML">{{ some_variable | to_nice_json(indent=2) }}
{{ some_variable | to_nice_yaml(indent=8) }}
</pre> <p><code>to_yaml</code> and <code>to_nice_yaml</code> filters use <a class="reference external" href="https://pyyaml.org/">PyYAML library</a> which has a default 80 symbol string length limit. That causes unexpected line break after 80th symbol (if there is a space after 80th symbol) To avoid such behaviour and generate long lines it is possible to use <code>width</code> option:</p> <pre data-language="YAML">{{ some_variable | to_yaml(indent=8, width=1337) }}
{{ some_variable | to_nice_yaml(indent=8, width=1337) }}
</pre> <p>While it would be nicer to use a construction like <code>float("inf")</code> instead of a hardcoded number, unfortunately the filter doesn’t support proxying Python functions. Note that it also supports passing through other YAML parameters. Full list can be found in <a class="reference external" href="https://pyyaml.org/wiki/PyYAMLDocumentation">PyYAML documentation</a>.</p> <p>Alternatively, you may be reading in some already formatted data:</p> <pre data-language="YAML">{{ some_variable | from_json }}
{{ some_variable | from_yaml }}
</pre> <p>for example:</p> <pre data-language="YAML">tasks:
  - shell: cat /some/path/to/file.json
    register: result

  - set_fact:
      myvar: "{{ result.stdout | from_json }}"
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 2.7.</span></p> </div> <p>To parse multi-document yaml strings, the <code>from_yaml_all</code> filter is provided. The <code>from_yaml_all</code> filter will return a generator of parsed yaml documents.</p> <p>for example:</p> <pre data-language="YAML">tasks:
  - shell: cat /some/path/to/multidoc-file.yaml
    register: result
  - debug:
      msg: '{{ item }}'
    loop: '{{ result.stdout | from_yaml_all | list }}'
</pre>   <h2 id="id2">Forcing Variables To Be Defined</h2> <p id="forcing-variables-to-be-defined">The default behavior from ansible and ansible.cfg is to fail if variables are undefined, but you can turn this off.</p> <p>This allows an explicit check with this feature off:</p> <pre data-language="YAML">{{ variable | mandatory }}
</pre> <p>The variable value will be used as is, but the template evaluation will raise an error if it is undefined.</p>   <h2 id="id3">Defaulting Undefined Variables</h2> <p id="defaulting-undefined-variables">Jinja2 provides a useful ‘default’ filter that is often a better approach to failing if a variable is not defined:</p> <pre data-language="YAML">{{ some_variable | default(5) }}
</pre> <p>In the above example, if the variable ‘some_variable’ is not defined, the value used will be 5, rather than an error being raised.</p> <p>If you want to use the default value when variables evaluate to false or an empty string you have to set the second parameter to <code>true</code>:</p> <pre data-language="YAML">{{ lookup('env', 'MY_USER') | default('admin', true) }}
</pre>   <h2 id="omitting-undefined-variables">Omitting Parameters</h2> <p id="omitting-parameters">As of Ansible 1.8, it is possible to use the default filter to omit module parameters using the special <code>omit</code> variable:</p> <pre data-language="YAML">- name: touch files with an optional mode
  file:
    dest: "{{ item.path }}"
    state: touch
    mode: "{{ item.mode | default(omit) }}"
  loop:
    - path: /tmp/foo
    - path: /tmp/bar
    - path: /tmp/baz
      mode: "0444"
</pre> <p>For the first two files in the list, the default mode will be determined by the umask of the system as the <code>mode=</code> parameter will not be sent to the file module while the final file will receive the <code>mode=0444</code> option.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If you are “chaining” additional filters after the <code>default(omit)</code> filter, you should instead do something like this: <code>"{{ foo | default(None) | some_filter or omit }}"</code>. In this example, the default <code>None</code> (Python null) value will cause the later filters to fail, which will trigger the <code>or omit</code> portion of the logic. Using <code>omit</code> in this manner is very specific to the later filters you’re chaining though, so be prepared for some trial and error if you do this.</p> </div>   <h2 id="id4">List Filters</h2> <p id="list-filters">These filters all operate on list variables.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 1.8.</span></p> </div> <p>To get the minimum value from list of numbers:</p> <pre data-language="YAML">{{ list1 | min }}
</pre> <p>To get the maximum value from a list of numbers:</p> <pre data-language="YAML">{{ [3, 4, 2] | max }}
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 2.5.</span></p> </div> <p>Flatten a list (same thing the <code>flatten</code> lookup does):</p> <pre data-language="YAML">{{ [3, [4, 2] ] | flatten }}
</pre> <p>Flatten only the first level of a list (akin to the <code>items</code> lookup):</p> <pre data-language="YAML">{{ [3, [4, [2]] ] | flatten(levels=1) }}
</pre>   <h2 id="id5">Set Theory Filters</h2> <p id="set-theory-filters">All these functions return a unique set from sets or lists.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 1.4.</span></p> </div> <p>To get a unique set from a list:</p> <pre data-language="YAML">{{ list1 | unique }}
</pre> <p>To get a union of two lists:</p> <pre data-language="YAML">{{ list1 | union(list2) }}
</pre> <p>To get the intersection of 2 lists (unique list of all items in both):</p> <pre data-language="YAML">{{ list1 | intersect(list2) }}
</pre> <p>To get the difference of 2 lists (items in 1 that don’t exist in 2):</p> <pre data-language="YAML">{{ list1 | difference(list2) }}
</pre> <p>To get the symmetric difference of 2 lists (items exclusive to each list):</p> <pre data-language="YAML">{{ list1 | symmetric_difference(list2) }}
</pre>   <h2 id="id6">Dict Filter</h2> <div class="versionadded" id="dict-filter"> <p><span class="versionmodified">New in version 2.6.</span></p> </div> <p>To turn a dictionary into a list of items, suitable for looping, use <code>dict2items</code>:</p> <pre data-language="YAML">{{ dict | dict2items }}
</pre> <p>Which turns:</p> <pre data-language="YAML">tags:
  Application: payment
  Environment: dev
</pre> <p>into:</p> <pre data-language="YAML">- key: Application
  value: payment
- key: Environment
  value: dev
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 2.8.</span></p> </div> <p><code>dict2items</code> accepts 2 keyword arguments, <code>key_name</code> and <code>value_name</code> that allow configuration of the names of the keys to use for the transformation:</p> <pre data-language="YAML">{{ files | dict2items(key_name='file', value_name='path') }}
</pre> <p>Which turns:</p> <pre data-language="YAML">files:
  users: /etc/passwd
  groups: /etc/group
</pre> <p>into:</p> <pre data-language="YAML">- file: users
  path: /etc/passwd
- file: groups
  path: /etc/group
</pre>   <h2 id="items2dict-filter">items2dict filter</h2> <div class="versionadded"> <p><span class="versionmodified">New in version 2.7.</span></p> </div> <p>This filter turns a list of dicts with 2 keys, into a dict, mapping the values of those keys into <code>key: value</code> pairs:</p> <pre data-language="YAML">{{ tags | items2dict }}
</pre> <p>Which turns:</p> <pre data-language="YAML">tags:
  - key: Application
    value: payment
  - key: Environment
    value: dev
</pre> <p>into:</p> <pre data-language="YAML">Application: payment
Environment: dev
</pre> <p>This is the reverse of the <code>dict2items</code> filter.</p> <p><code>items2dict</code> accepts 2 keyword arguments, <code>key_name</code> and <code>value_name</code> that allow configuration of the names of the keys to use for the transformation:</p> <pre data-language="YAML">{{ tags | items2dict(key_name='key', value_name='value') }}
</pre>   <h2 id="zip-filter">zip and zip_longest filters</h2> <div class="versionadded" id="zip-and-zip-longest-filters"> <p><span class="versionmodified">New in version 2.3.</span></p> </div> <p>To get a list combining the elements of other lists use <code>zip</code>:</p> <pre data-language="YAML">- name: give me list combo of two lists
  debug:
   msg: "{{ [1,2,3,4,5] | zip(['a','b','c','d','e','f']) | list }}"

- name: give me shortest combo of two lists
  debug:
    msg: "{{ [1,2,3] | zip(['a','b','c','d','e','f']) | list }}"
</pre> <p>To always exhaust all list use <code>zip_longest</code>:</p> <pre data-language="YAML">- name: give me longest combo of three lists , fill with X
  debug:
    msg: "{{ [1,2,3] | zip_longest(['a','b','c','d','e','f'], [21, 22, 23], fillvalue='X') | list }}"
</pre> <p>Similarly to the output of the <code>items2dict</code> filter mentioned above, these filters can be used to construct a <code>dict</code>:</p> <pre data-language="YAML">{{ dict(keys_list | zip(values_list)) }}
</pre> <p>Which turns:</p> <pre data-language="YAML">keys_list:
  - one
  - two
values_list:
  - apple
  - orange
</pre> <p>into:</p> <pre data-language="YAML">one: apple
two: orange
</pre>   <h2 id="subelements-filter">subelements Filter</h2> <div class="versionadded"> <p><span class="versionmodified">New in version 2.7.</span></p> </div> <p>Produces a product of an object, and subelement values of that object, similar to the <code>subelements</code> lookup:</p> <pre data-language="YAML">{{ users | subelements('groups', skip_missing=True) }}
</pre> <p>Which turns:</p> <pre data-language="YAML">users:
- name: alice
  authorized:
  - /tmp/alice/onekey.pub
  - /tmp/alice/twokey.pub
  groups:
  - wheel
  - docker
- name: bob
  authorized:
  - /tmp/bob/id_rsa.pub
  groups:
  - docker
</pre> <p>Into:</p> <pre data-language="YAML">-
  - name: alice
    groups:
    - wheel
    - docker
    authorized:
    - /tmp/alice/onekey.pub
    - /tmp/alice/twokey.pub
  - wheel
-
  - name: alice
    groups:
    - wheel
    - docker
    authorized:
    - /tmp/alice/onekey.pub
    - /tmp/alice/twokey.pub
  - docker
-
  - name: bob
    authorized:
    - /tmp/bob/id_rsa.pub
    groups:
    - docker
  - docker
</pre> <p>An example of using this filter with <code>loop</code>:</p> <pre data-language="YAML">- name: Set authorized ssh key, extracting just that data from 'users'
  authorized_key:
    user: "{{ item.0.name }}"
    key: "{{ lookup('file', item.1) }}"
  loop: "{{ users | subelements('authorized') }}"
</pre>   <h2 id="random-mac-filter">Random Mac Address Filter</h2> <div class="versionadded" id="random-mac-address-filter"> <p><span class="versionmodified">New in version 2.6.</span></p> </div> <p>This filter can be used to generate a random MAC address from a string prefix.</p> <p>To get a random MAC address from a string prefix starting with ‘52:54:00’:</p> <pre data-language="YAML">"{{ '52:54:00' | random_mac }}"
# =&gt; '52:54:00:ef:1c:03'
</pre> <p>Note that if anything is wrong with the prefix string, the filter will issue an error.</p> <p>As of Ansible version 2.9, it’s also possible to initialize the random number generator from a seed. This way, you can create random-but-idempotent MAC addresses:</p> <pre data-language="YAML">"{{ '52:54:00' | random_mac(seed=inventory_hostname) }}"
</pre>   <h2 id="random-filter">Random Number Filter</h2> <div class="versionadded" id="random-number-filter"> <p><span class="versionmodified">New in version 1.6.</span></p> </div> <p>This filter can be used similar to the default jinja2 random filter (returning a random item from a sequence of items), but can also generate a random number based on a range.</p> <p>To get a random item from a list:</p> <pre data-language="YAML">"{{ ['a','b','c'] | random }}"
# =&gt; 'c'
</pre> <p>To get a random number between 0 and a specified number:</p> <pre data-language="YAML">"{{ 60 | random }} * * * * root /script/from/cron"
# =&gt; '21 * * * * root /script/from/cron'
</pre> <p>Get a random number from 0 to 100 but in steps of 10:</p> <pre data-language="YAML">{{ 101 | random(step=10) }}
# =&gt; 70
</pre> <p>Get a random number from 1 to 100 but in steps of 10:</p> <pre data-language="YAML">{{ 101 | random(1, 10) }}
# =&gt; 31
{{ 101 | random(start=1, step=10) }}
# =&gt; 51
</pre> <p>As of Ansible version 2.3, it’s also possible to initialize the random number generator from a seed. This way, you can create random-but-idempotent numbers:</p> <pre data-language="YAML">"{{ 60 | random(seed=inventory_hostname) }} * * * * root /script/from/cron"
</pre>   <h2 id="shuffle-filter">Shuffle Filter</h2> <div class="versionadded"> <p><span class="versionmodified">New in version 1.8.</span></p> </div> <p>This filter will randomize an existing list, giving a different order every invocation.</p> <p>To get a random list from an existing list:</p> <pre data-language="YAML">{{ ['a','b','c'] | shuffle }}
# =&gt; ['c','a','b']
{{ ['a','b','c'] | shuffle }}
# =&gt; ['b','c','a']
</pre> <p>As of Ansible version 2.3, it’s also possible to shuffle a list idempotent. All you need is a seed.:</p> <pre data-language="YAML">{{ ['a','b','c'] | shuffle(seed=inventory_hostname) }}
# =&gt; ['b','a','c']
</pre> <p>note that when used with a non ‘listable’ item it is a noop, otherwise it always returns a list</p>   <h2 id="math-stuff">Math</h2> <div class="versionadded" id="math"> <p><span class="versionmodified">New in version 1.9.</span></p> </div> <p>Get the logarithm (default is e):</p> <pre data-language="YAML">{{ myvar | log }}
</pre> <p>Get the base 10 logarithm:</p> <pre data-language="YAML">{{ myvar | log(10) }}
</pre> <p>Give me the power of 2! (or 5):</p> <pre data-language="YAML">{{ myvar | pow(2) }}
{{ myvar | pow(5) }}
</pre> <p>Square root, or the 5th:</p> <pre data-language="YAML">{{ myvar | root }}
{{ myvar | root(5) }}
</pre> <p>Note that jinja2 already provides some like abs() and round().</p>   <h2 id="json-query-filter">JSON Query Filter</h2> <div class="versionadded"> <p><span class="versionmodified">New in version 2.2.</span></p> </div> <p>Sometimes you end up with a complex data structure in JSON format and you need to extract only a small set of data within it. The <strong>json_query</strong> filter lets you query a complex JSON structure and iterate over it using a loop structure.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This filter is built upon <strong>jmespath</strong>, and you can use the same syntax. For examples, see <a class="reference external" href="http://jmespath.org/examples.html">jmespath examples</a>.</p> </div> <p>Now, let’s take the following data structure:</p> <pre data-language="YAML">{
    "domain_definition": {
        "domain": {
            "cluster": [
                {
                    "name": "cluster1"
                },
                {
                    "name": "cluster2"
                }
            ],
            "server": [
                {
                    "name": "server11",
                    "cluster": "cluster1",
                    "port": "8080"
                },
                {
                    "name": "server12",
                    "cluster": "cluster1",
                    "port": "8090"
                },
                {
                    "name": "server21",
                    "cluster": "cluster2",
                    "port": "9080"
                },
                {
                    "name": "server22",
                    "cluster": "cluster2",
                    "port": "9090"
                }
            ],
            "library": [
                {
                    "name": "lib1",
                    "target": "cluster1"
                },
                {
                    "name": "lib2",
                    "target": "cluster2"
                }
            ]
        }
    }
}
</pre> <p>To extract all clusters from this structure, you can use the following query:</p> <pre data-language="YAML">- name: "Display all cluster names"
  debug:
    var: item
  loop: "{{ domain_definition | json_query('domain.cluster[*].name') }}"
</pre> <p>Same thing for all server names:</p> <pre data-language="YAML">- name: "Display all server names"
  debug:
    var: item
  loop: "{{ domain_definition | json_query('domain.server[*].name') }}"
</pre> <p>This example shows ports from cluster1:</p> <pre data-language="YAML">- name: "Display all ports from cluster1"
  debug:
    var: item
  loop: "{{ domain_definition | json_query(server_name_cluster1_query) }}"
  vars:
    server_name_cluster1_query: "domain.server[?cluster=='cluster1'].port"
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">You can use a variable to make the query more readable.</p> </div> <p>Or, alternatively print out the ports in a comma separated string:</p> <pre data-language="YAML">- name: "Display all ports from cluster1 as a string"
  debug:
    msg: "{{ domain_definition | json_query('domain.server[?cluster==`cluster1`].port') | join(', ') }}"
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Here, quoting literals using backticks avoids escaping quotes and maintains readability.</p> </div> <p>Or, using YAML <a class="reference external" href="https://yaml.org/spec/current.html#id2534365">single quote escaping</a>:</p> <pre data-language="YAML">- name: "Display all ports from cluster1"
  debug:
    var: item
  loop: "{{ domain_definition | json_query('domain.server[?cluster==''cluster1''].port') }}"
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Escaping single quotes within single quotes in YAML is done by doubling the single quote.</p> </div> <p>In this example, we get a hash map with all ports and names of a cluster:</p> <pre data-language="YAML">- name: "Display all server ports and names from cluster1"
  debug:
    var: item
  loop: "{{ domain_definition | json_query(server_name_cluster1_query) }}"
  vars:
    server_name_cluster1_query: "domain.server[?cluster=='cluster2'].{name: name, port: port}"
</pre>   <h2 id="ipaddr-filter">IP address filter</h2> <div class="versionadded" id="ip-address-filter"> <p><span class="versionmodified">New in version 1.9.</span></p> </div> <p>To test if a string is a valid IP address:</p> <pre data-language="YAML">{{ myvar | ipaddr }}
</pre> <p>You can also require a specific IP protocol version:</p> <pre data-language="YAML">{{ myvar | ipv4 }}
{{ myvar | ipv6 }}
</pre> <p>IP address filter can also be used to extract specific information from an IP address. For example, to get the IP address itself from a CIDR, you can use:</p> <pre data-language="YAML">{{ '192.0.2.1/24' | ipaddr('address') }}
</pre> <p>More information about <code>ipaddr</code> filter and complete usage guide can be found in <a class="reference internal" href="playbooks_filters_ipaddr#playbooks-filters-ipaddr"><span class="std std-ref">ipaddr filter</span></a>.</p>   <h2 id="network-filters">Network CLI filters</h2> <div class="versionadded" id="network-cli-filters"> <p><span class="versionmodified">New in version 2.4.</span></p> </div> <p>To convert the output of a network device CLI command into structured JSON output, use the <code>parse_cli</code> filter:</p> <pre data-language="YAML">{{ output | parse_cli('path/to/spec') }}
</pre> <p>The <code>parse_cli</code> filter will load the spec file and pass the command output through it, returning JSON output. The YAML spec file defines how to parse the CLI output.</p> <p>The spec file should be valid formatted YAML. It defines how to parse the CLI output and return JSON data. Below is an example of a valid spec file that will parse the output from the <code>show vlan</code> command.</p> <pre data-language="yaml">---
vars:
  vlan:
    vlan_id: "{{ item.vlan_id }}"
    name: "{{ item.name }}"
    enabled: "{{ item.state != 'act/lshut' }}"
    state: "{{ item.state }}"

keys:
  vlans:
    value: "{{ vlan }}"
    items: "^(?P&lt;vlan_id&gt;\\d+)\\s+(?P&lt;name&gt;\\w+)\\s+(?P&lt;state&gt;active|act/lshut|suspended)"
  state_static:
    value: present
</pre> <p>The spec file above will return a JSON data structure that is a list of hashes with the parsed VLAN information.</p> <p>The same command could be parsed into a hash by using the key and values directives. Here is an example of how to parse the output into a hash value using the same <code>show vlan</code> command.</p> <pre data-language="yaml">---
vars:
  vlan:
    key: "{{ item.vlan_id }}"
    values:
      vlan_id: "{{ item.vlan_id }}"
      name: "{{ item.name }}"
      enabled: "{{ item.state != 'act/lshut' }}"
      state: "{{ item.state }}"

keys:
  vlans:
    value: "{{ vlan }}"
    items: "^(?P&lt;vlan_id&gt;\\d+)\\s+(?P&lt;name&gt;\\w+)\\s+(?P&lt;state&gt;active|act/lshut|suspended)"
  state_static:
    value: present
</pre> <p>Another common use case for parsing CLI commands is to break a large command into blocks that can be parsed. This can be done using the <code>start_block</code> and <code>end_block</code> directives to break the command into blocks that can be parsed.</p> <pre data-language="yaml">---
vars:
  interface:
    name: "{{ item[0].match[0] }}"
    state: "{{ item[1].state }}"
    mode: "{{ item[2].match[0] }}"

keys:
  interfaces:
    value: "{{ interface }}"
    start_block: "^Ethernet.*$"
    end_block: "^$"
    items:
      - "^(?P&lt;name&gt;Ethernet\\d\\/\\d*)"
      - "admin state is (?P&lt;state&gt;.+),"
      - "Port mode is (.+)"
</pre> <p>The example above will parse the output of <code>show interface</code> into a list of hashes.</p> <p>The network filters also support parsing the output of a CLI command using the TextFSM library. To parse the CLI output with TextFSM use the following filter:</p> <pre data-language="YAML">{{ output.stdout[0] | parse_cli_textfsm('path/to/fsm') }}
</pre> <p>Use of the TextFSM filter requires the TextFSM library to be installed.</p>   <h2 id="network-xml-filters">Network XML filters</h2> <div class="versionadded"> <p><span class="versionmodified">New in version 2.5.</span></p> </div> <p>To convert the XML output of a network device command into structured JSON output, use the <code>parse_xml</code> filter:</p> <pre data-language="YAML">{{ output | parse_xml('path/to/spec') }}
</pre> <p>The <code>parse_xml</code> filter will load the spec file and pass the command output through formatted as JSON.</p> <p>The spec file should be valid formatted YAML. It defines how to parse the XML output and return JSON data.</p> <p>Below is an example of a valid spec file that will parse the output from the <code>show vlan | display xml</code> command.</p> <pre data-language="yaml">---
vars:
  vlan:
    vlan_id: "{{ item.vlan_id }}"
    name: "{{ item.name }}"
    desc: "{{ item.desc }}"
    enabled: "{{ item.state.get('inactive') != 'inactive' }}"
    state: "{% if item.state.get('inactive') == 'inactive'%} inactive {% else %} active {% endif %}"

keys:
  vlans:
    value: "{{ vlan }}"
    top: configuration/vlans/vlan
    items:
      vlan_id: vlan-id
      name: name
      desc: description
      state: ".[@inactive='inactive']"
</pre> <p>The spec file above will return a JSON data structure that is a list of hashes with the parsed VLAN information.</p> <p>The same command could be parsed into a hash by using the key and values directives. Here is an example of how to parse the output into a hash value using the same <code>show vlan | display xml</code> command.</p> <pre data-language="yaml">---
vars:
  vlan:
    key: "{{ item.vlan_id }}"
    values:
        vlan_id: "{{ item.vlan_id }}"
        name: "{{ item.name }}"
        desc: "{{ item.desc }}"
        enabled: "{{ item.state.get('inactive') != 'inactive' }}"
        state: "{% if item.state.get('inactive') == 'inactive'%} inactive {% else %} active {% endif %}"

keys:
  vlans:
    value: "{{ vlan }}"
    top: configuration/vlans/vlan
    items:
      vlan_id: vlan-id
      name: name
      desc: description
      state: ".[@inactive='inactive']"
</pre> <p>The value of <code>top</code> is the XPath relative to the XML root node. In the example XML output given below, the value of <code>top</code> is <code>configuration/vlans/vlan</code>, which is an XPath expression relative to the root node (&lt;rpc-reply&gt;). <code>configuration</code> in the value of <code>top</code> is the outer most container node, and <code>vlan</code> is the inner-most container node.</p> <p><code>items</code> is a dictionary of key-value pairs that map user-defined names to XPath expressions that select elements. The Xpath expression is relative to the value of the XPath value contained in <code>top</code>. For example, the <code>vlan_id</code> in the spec file is a user defined name and its value <code>vlan-id</code> is the relative to the value of XPath in <code>top</code></p> <p>Attributes of XML tags can be extracted using XPath expressions. The value of <code>state</code> in the spec is an XPath expression used to get the attributes of the <code>vlan</code> tag in output XML.:</p> <pre data-language="YAML">&lt;rpc-reply&gt;
  &lt;configuration&gt;
    &lt;vlans&gt;
      &lt;vlan inactive="inactive"&gt;
       &lt;name&gt;vlan-1&lt;/name&gt;
       &lt;vlan-id&gt;200&lt;/vlan-id&gt;
       &lt;description&gt;This is vlan-1&lt;/description&gt;
      &lt;/vlan&gt;
    &lt;/vlans&gt;
  &lt;/configuration&gt;
&lt;/rpc-reply&gt;
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">For more information on supported XPath expressions, see <a class="reference external" href="https://docs.python.org/2/library/xml.etree.elementtree.html#xpath-support">https://docs.python.org/2/library/xml.etree.elementtree.html#xpath-support</a>.</p> </div>   <h2 id="network-vlan-filters">Network VLAN filters</h2> <div class="versionadded"> <p><span class="versionmodified">New in version 2.8.</span></p> </div> <p>Use the <code>vlan_parser</code> filter to manipulate an unsorted list of VLAN integers into a sorted string list of integers according to IOS-like VLAN list rules. This list has the following properties:</p> <ul class="simple"> <li>Vlans are listed in ascending order.</li> <li>Three or more consecutive VLANs are listed with a dash.</li> <li>The first line of the list can be first_line_len characters long.</li> <li>Subsequent list lines can be other_line_len characters.</li> </ul> <p>To sort a VLAN list:</p> <pre data-language="YAML">{{ [3003, 3004, 3005, 100, 1688, 3002, 3999] | vlan_parser }}
</pre> <p>This example renders the following sorted list:</p> <pre data-language="YAML">['100,1688,3002-3005,3999']
</pre> <p>Another example Jinja template:</p> <pre data-language="YAML">{% set parsed_vlans = vlans | vlan_parser %}
switchport trunk allowed vlan {{ parsed_vlans[0] }}
{% for i in range (1, parsed_vlans | count) %}
switchport trunk allowed vlan add {{ parsed_vlans[i] }}
</pre> <p>This allows for dynamic generation of VLAN lists on a Cisco IOS tagged interface. You can store an exhaustive raw list of the exact VLANs required for an interface and then compare that to the parsed IOS output that would actually be generated for the configuration.</p>   <h2 id="hash-filters">Hashing filters</h2> <div class="versionadded" id="hashing-filters"> <p><span class="versionmodified">New in version 1.9.</span></p> </div> <p>To get the sha1 hash of a string:</p> <pre data-language="YAML">{{ 'test1' | hash('sha1') }}
</pre> <p>To get the md5 hash of a string:</p> <pre data-language="YAML">{{ 'test1' | hash('md5') }}
</pre> <p>Get a string checksum:</p> <pre data-language="YAML">{{ 'test2' | checksum }}
</pre> <p>Other hashes (platform dependent):</p> <pre data-language="YAML">{{ 'test2' | hash('blowfish') }}
</pre> <p>To get a sha512 password hash (random salt):</p> <pre data-language="YAML">{{ 'passwordsaresecret' | password_hash('sha512') }}
</pre> <p>To get a sha256 password hash with a specific salt:</p> <pre data-language="YAML">{{ 'secretpassword' | password_hash('sha256', 'mysecretsalt') }}
</pre> <p>An idempotent method to generate unique hashes per system is to use a salt that is consistent between runs:</p> <pre data-language="YAML">{{ 'secretpassword' | password_hash('sha512', 65534 | random(seed=inventory_hostname) | string) }}
</pre> <p>Hash types available depend on the master system running ansible, ‘hash’ depends on hashlib password_hash depends on passlib (<a class="reference external" href="https://passlib.readthedocs.io/en/stable/lib/passlib.hash.html">https://passlib.readthedocs.io/en/stable/lib/passlib.hash.html</a>).</p> <div class="versionadded"> <p><span class="versionmodified">New in version 2.7.</span></p> </div> <p>Some hash types allow providing a rounds parameter:</p> <pre data-language="YAML">{{ 'secretpassword' | password_hash('sha256', 'mysecretsalt', rounds=10000) }}
</pre>   <h2 id="combine-filter">Combining hashes/dictionaries</h2> <div class="versionadded" id="combining-hashes-dictionaries"> <p><span class="versionmodified">New in version 2.0.</span></p> </div> <p>The <code>combine</code> filter allows hashes to be merged. For example, the following would override keys in one hash:</p> <pre data-language="YAML">{{ {'a':1, 'b':2} | combine({'b':3}) }}
</pre> <p>The resulting hash would be:</p> <pre data-language="YAML">{'a':1, 'b':3}
</pre> <p>The filter also accepts an optional <code>recursive=True</code> parameter to not only override keys in the first hash, but also recurse into nested hashes and merge their keys too</p> <pre data-language="jinja">{{ {'a':{'foo':1, 'bar':2}, 'b':2} | combine({'a':{'bar':3, 'baz':4}}, recursive=True) }}
</pre> <p>This would result in:</p> <pre data-language="YAML">{'a':{'foo':1, 'bar':3, 'baz':4}, 'b':2}
</pre> <p>The filter can also take multiple arguments to merge:</p> <pre data-language="YAML">{{ a | combine(b, c, d) }}
</pre> <p>In this case, keys in <code>d</code> would override those in <code>c</code>, which would override those in <code>b</code>, and so on.</p> <p>This behaviour does not depend on the value of the <code>hash_behaviour</code> setting in <code>ansible.cfg</code>.</p>   <h2 id="extract-filter">Extracting values from containers</h2> <div class="versionadded" id="extracting-values-from-containers"> <p><span class="versionmodified">New in version 2.1.</span></p> </div> <p>The <code>extract</code> filter is used to map from a list of indices to a list of values from a container (hash or array):</p> <pre data-language="YAML">{{ [0,2] | map('extract', ['x','y','z']) | list }}
{{ ['x','y'] | map('extract', {'x': 42, 'y': 31}) | list }}
</pre> <p>The results of the above expressions would be:</p> <pre data-language="YAML">['x', 'z']
[42, 31]
</pre> <p>The filter can take another argument:</p> <pre data-language="YAML">{{ groups['x'] | map('extract', hostvars, 'ec2_ip_address') | list }}
</pre> <p>This takes the list of hosts in group ‘x’, looks them up in <code>hostvars</code>, and then looks up the <code>ec2_ip_address</code> of the result. The final result is a list of IP addresses for the hosts in group ‘x’.</p> <p>The third argument to the filter can also be a list, for a recursive lookup inside the container:</p> <pre data-language="YAML">{{ ['a'] | map('extract', b, ['x','y']) | list }}
</pre> <p>This would return a list containing the value of <code>b[‘a’][‘x’][‘y’]</code>.</p>   <h2 id="id7">Comment Filter</h2> <div class="versionadded" id="comment-filter"> <p><span class="versionmodified">New in version 2.0.</span></p> </div> <p>The <code>comment</code> filter allows to decorate the text with a chosen comment style. For example the following:</p> <pre data-language="YAML">{{ "Plain style (default)" | comment }}
</pre> <p>will produce this output:</p> <pre data-language="text">#
# Plain style (default)
#
</pre> <p>Similar way can be applied style for C (<code>//...</code>), C block (<code>/*...*/</code>), Erlang (<code>%...</code>) and XML (<code>&lt;!--...--&gt;</code>):</p> <pre data-language="YAML">{{ "C style" | comment('c') }}
{{ "C block style" | comment('cblock') }}
{{ "Erlang style" | comment('erlang') }}
{{ "XML style" | comment('xml') }}
</pre> <p>If you need a specific comment character that is not included by any of the above, you can customize it with:</p> <pre data-language="YAML">{{ "My Special Case" | comment(decoration="! ") }}
</pre> <p>producing:</p> <pre data-language="text">!
! My Special Case
!
</pre> <p>It is also possible to fully customize the comment style:</p> <pre data-language="YAML">{{ "Custom style" | comment('plain', prefix='#######\n#', postfix='#\n#######\n   ###\n    #') }}
</pre> <p>That will create the following output:</p> <pre data-language="text">#######
#
# Custom style
#
#######
   ###
    #
</pre> <p>The filter can also be applied to any Ansible variable. For example to make the output of the <code>ansible_managed</code> variable more readable, we can change the definition in the <code>ansible.cfg</code> file to this:</p> <pre data-language="jinja">[defaults]

ansible_managed = This file is managed by Ansible.%n
  template: {file}
  date: %Y-%m-%d %H:%M:%S
  user: {uid}
  host: {host}
</pre> <p>and then use the variable with the <code>comment</code> filter:</p> <pre data-language="YAML">{{ ansible_managed | comment }}
</pre> <p>which will produce this output:</p> <pre data-language="sh">#
# This file is managed by Ansible.
#
# template: /home/ansible/env/dev/ansible_managed/roles/role1/templates/test.j2
# date: 2015-09-10 11:02:58
# user: ansible
# host: myhost
#
</pre>   <h2 id="other-useful-filters">URL Split Filter</h2> <div class="versionadded" id="url-split-filter"> <p><span class="versionmodified">New in version 2.4.</span></p> </div> <p>The <code>urlsplit</code> filter extracts the fragment, hostname, netloc, password, path, port, query, scheme, and username from an URL. With no arguments, returns a dictionary of all the fields:</p> <pre data-language="YAML">{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('hostname') }}
# =&gt; 'www.acme.com'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('netloc') }}
# =&gt; 'user:password@www.acme.com:9000'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('username') }}
# =&gt; 'user'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('password') }}
# =&gt; 'password'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('path') }}
# =&gt; '/dir/index.html'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('port') }}
# =&gt; '9000'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('scheme') }}
# =&gt; 'http'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('query') }}
# =&gt; 'query=term'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('fragment') }}
# =&gt; 'fragment'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit }}
# =&gt;
#   {
#       "fragment": "fragment",
#       "hostname": "www.acme.com",
#       "netloc": "user:password@www.acme.com:9000",
#       "password": "password",
#       "path": "/dir/index.html",
#       "port": 9000,
#       "query": "query=term",
#       "scheme": "http",
#       "username": "user"
#   }
</pre>   <h2 id="regular-expression-filters">Regular Expression Filters</h2> <p>To search a string with a regex, use the “regex_search” filter:</p> <pre data-language="YAML"># search for "foo" in "foobar"
{{ 'foobar' | regex_search('(foo)') }}

# will return empty if it cannot find a match
{{ 'ansible' | regex_search('(foobar)') }}

# case insensitive search in multiline mode
{{ 'foo\nBAR' | regex_search("^bar", multiline=True, ignorecase=True) }}
</pre> <p>To search for all occurrences of regex matches, use the “regex_findall” filter:</p> <pre data-language="YAML"># Return a list of all IPv4 addresses in the string
{{ 'Some DNS servers are 8.8.8.8 and 8.8.4.4' | regex_findall('\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b') }}
</pre> <p>To replace text in a string with regex, use the “regex_replace” filter:</p> <pre data-language="YAML"># convert "ansible" to "able"
{{ 'ansible' | regex_replace('^a.*i(.*)$', 'a\\1') }}

# convert "foobar" to "bar"
{{ 'foobar' | regex_replace('^f.*o(.*)$', '\\1') }}

# convert "localhost:80" to "localhost, 80" using named groups
{{ 'localhost:80' | regex_replace('^(?P&lt;host&gt;.+):(?P&lt;port&gt;\\d+)$', '\\g&lt;host&gt;, \\g&lt;port&gt;') }}

# convert "localhost:80" to "localhost"
{{ 'localhost:80' | regex_replace(':80') }}
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>If you want to match the whole string and you are using <code>*</code> make sure to always wraparound your regular expression with the start/end anchors. For example <code>^(.*)$</code> will always match only one result, while <code>(.*)</code> on some Python versions will match the whole string and an empty string at the end, which means it will make two replacements.</p>  <p># add “<a class="reference external" href="#">https://</a>” prefix to each item in a list GOOD: {{ hosts | map(‘regex_replace’, ‘^(.*)$’, ‘<a class="reference external" href="#">https://</a>\1’) | list }} {{ hosts | map(‘regex_replace’, ‘(.+)’, ‘<a class="reference external" href="#">https://</a>\1’) | list }} {{ hosts | map(‘regex_replace’, ‘^’, ‘<a class="reference external" href="#">https://</a>’) | list }}</p> <p>BAD: {{ hosts | map(‘regex_replace’, ‘(.*)’, ‘<a class="reference external" href="#">https://</a>\1’) | list }}</p> <p># append ‘:80’ to each item in a list GOOD: {{ hosts | map(‘regex_replace’, ‘^(.*)$’, ‘\1:80’) | list }} {{ hosts | map(‘regex_replace’, ‘(.+)’, ‘\1:80’) | list }} {{ hosts | map(‘regex_replace’, ‘$’, ‘:80’) | list }}</p> <p>BAD: {{ hosts | map(‘regex_replace’, ‘(.*)’, ‘\1:80’) | list }}</p>  </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Prior to ansible 2.0, if “regex_replace” filter was used with variables inside YAML arguments (as opposed to simpler ‘key=value’ arguments), then you needed to escape backreferences (e.g. <code>\\1</code>) with 4 backslashes (<code>\\\\</code>) instead of 2 (<code>\\</code>).</p> </div> <div class="versionadded"> <p><span class="versionmodified">New in version 2.0.</span></p> </div> <p>To escape special characters within a standard Python regex, use the “regex_escape” filter (using the default re_type=’python’ option):</p> <pre data-language="YAML"># convert '^f.*o(.*)$' to '\^f\.\*o\(\.\*\)\$'
{{ '^f.*o(.*)$' | regex_escape() }}
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 2.8.</span></p> </div> <p>To escape special characters within a POSIX basic regex, use the “regex_escape” filter with the re_type=’posix_basic’ option:</p> <pre data-language="YAML"># convert '^f.*o(.*)$' to '\^f\.\*o(\.\*)\$'
{{ '^f.*o(.*)$' | regex_escape('posix_basic') }}
</pre>   <h2 id="kubernetes-filters">Kubernetes Filters</h2> <p>Use the “k8s_config_resource_name” filter to obtain the name of a Kubernetes ConfigMap or Secret, including its hash:</p> <pre data-language="YAML">{{ configmap_resource_definition | k8s_config_resource_name }}
</pre> <p>This can then be used to reference hashes in Pod specifications:</p> <pre data-language="YAML">my_secret:
  kind: Secret
  name: my_secret_name

deployment_resource:
  kind: Deployment
  spec:
    template:
      spec:
        containers:
        - envFrom:
            - secretRef:
                name: {{ my_secret | k8s_config_resource_name }}
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 2.8.</span></p> </div>   <h2 id="id8">Other Useful Filters</h2> <p>To add quotes for shell usage:</p> <pre data-language="YAML">- shell: echo {{ string_value | quote }}
</pre> <p>To use one value on true and another on false (new in version 1.9):</p> <pre data-language="YAML">{{ (name == "John") | ternary('Mr','Ms') }}
</pre> <p>To use one value on true, one value on false and a third value on null (new in version 2.8):</p> <pre data-language="YAML">{{ enabled | ternary('no shutdown', 'shutdown', omit) }}
</pre> <p>To concatenate a list into a string:</p> <pre data-language="YAML">{{ list | join(" ") }}
</pre> <p>To get the last name of a file path, like ‘foo.txt’ out of ‘/etc/asdf/foo.txt’:</p> <pre data-language="YAML">{{ path | basename }}
</pre> <p>To get the last name of a windows style file path (new in version 2.0):</p> <pre data-language="YAML">{{ path | win_basename }}
</pre> <p>To separate the windows drive letter from the rest of a file path (new in version 2.0):</p> <pre data-language="YAML">{{ path | win_splitdrive }}
</pre> <p>To get only the windows drive letter:</p> <pre data-language="YAML">{{ path | win_splitdrive | first }}
</pre> <p>To get the rest of the path without the drive letter:</p> <pre data-language="YAML">{{ path | win_splitdrive | last }}
</pre> <p>To get the directory from a path:</p> <pre data-language="YAML">{{ path | dirname }}
</pre> <p>To get the directory from a windows path (new version 2.0):</p> <pre data-language="YAML">{{ path | win_dirname }}
</pre> <p>To expand a path containing a tilde (<code>~</code>) character (new in version 1.5):</p> <pre data-language="YAML">{{ path | expanduser }}
</pre> <p>To expand a path containing environment variables:</p> <pre data-language="YAML">{{ path | expandvars }}
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><code>expandvars</code> expands local variables; using it on remote paths can lead to errors.</p> </div> <div class="versionadded"> <p><span class="versionmodified">New in version 2.6.</span></p> </div> <p>To get the real path of a link (new in version 1.8):</p> <pre data-language="YAML">{{ path | realpath }}
</pre> <p>To get the relative path of a link, from a start point (new in version 1.7):</p> <pre data-language="YAML">{{ path | relpath('/etc') }}
</pre> <p>To get the root and extension of a path or filename (new in version 2.0):</p> <pre data-language="YAML"># with path == 'nginx.conf' the return would be ('nginx', '.conf')
{{ path | splitext }}
</pre> <p>To work with Base64 encoded strings:</p> <pre data-language="YAML">{{ encoded | b64decode }}
{{ decoded | string | b64encode }}
</pre> <p>As of version 2.6, you can define the type of encoding to use, the default is <code>utf-8</code>:</p> <pre data-language="YAML">{{ encoded | b64decode(encoding='utf-16-le') }}
{{ decoded | string | b64encode(encoding='utf-16-le') }}
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The <code>string</code> filter is only required for Python 2 and ensures that text to encode is a unicode string. Without that filter before b64encode the wrong value will be encoded.</p> </div> <div class="versionadded"> <p><span class="versionmodified">New in version 2.6.</span></p> </div> <p>To create a UUID from a string (new in version 1.9):</p> <pre data-language="YAML">{{ hostname | to_uuid }}
</pre> <p>To cast values as certain types, such as when you input a string as “True” from a vars_prompt and the system doesn’t know it is a boolean value:</p> <pre data-language="YAML">- debug:
    msg: test
  when: some_string_value | bool
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 1.6.</span></p> </div> <p>To make use of one attribute from each item in a list of complex variables, use the “map” filter (see the <a class="reference external" href="http://jinja.pocoo.org/docs/dev/templates/#map">Jinja2 map() docs</a> for more):</p> <pre data-language="YAML"># get a comma-separated list of the mount points (e.g. "/,/mnt/stuff") on a host
{{ ansible_mounts | map(attribute='mount') | join(',') }}
</pre> <p>To get date object from string use the <code>to_datetime</code> filter, (new in version in 2.2):</p> <pre data-language="YAML"># Get total amount of seconds between two dates. Default date format is %Y-%m-%d %H:%M:%S but you can pass your own format
{{ (("2016-08-14 20:00:12" | to_datetime) - ("2015-12-25" | to_datetime('%Y-%m-%d'))).total_seconds()  }}

# Get remaining seconds after delta has been calculated. NOTE: This does NOT convert years, days, hours, etc to seconds. For that, use total_seconds()
{{ (("2016-08-14 20:00:12" | to_datetime) - ("2016-08-14 18:00:00" | to_datetime)).seconds  }}
# This expression evaluates to "12" and not "132". Delta is 2 hours, 12 seconds

# get amount of days between two dates. This returns only number of days and discards remaining hours, minutes, and seconds
{{ (("2016-08-14 20:00:12" | to_datetime) - ("2015-12-25" | to_datetime('%Y-%m-%d'))).days  }}
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 2.4.</span></p> </div> <p>To format a date using a string (like with the shell date command), use the “strftime” filter:</p> <pre data-language="YAML"># Display year-month-day
{{ '%Y-%m-%d' | strftime }}

# Display hour:min:sec
{{ '%H:%M:%S' | strftime }}

# Use ansible_date_time.epoch fact
{{ '%Y-%m-%d %H:%M:%S' | strftime(ansible_date_time.epoch) }}

# Use arbitrary epoch value
{{ '%Y-%m-%d' | strftime(0) }}          # =&gt; 1970-01-01
{{ '%Y-%m-%d' | strftime(1441357287) }} # =&gt; 2015-09-04
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">To get all string possibilities, check <a class="reference external" href="https://docs.python.org/2/library/time.html#time.strftime">https://docs.python.org/2/library/time.html#time.strftime</a></p> </div>   <h2 id="combination-filters">Combination Filters</h2> <div class="versionadded"> <p><span class="versionmodified">New in version 2.3.</span></p> </div> <p>This set of filters returns a list of combined lists. To get permutations of a list:</p> <pre data-language="YAML">- name: give me largest permutations (order matters)
  debug:
    msg: "{{ [1,2,3,4,5] | permutations | list }}"

- name: give me permutations of sets of three
  debug:
    msg: "{{ [1,2,3,4,5] | permutations(3) | list }}"
</pre> <p>Combinations always require a set size:</p> <pre data-language="YAML">- name: give me combinations for sets of two
  debug:
    msg: "{{ [1,2,3,4,5] | combinations(2) | list }}"
</pre> <p>Also see the <a class="reference internal" href="#zip-filter"><span class="std std-ref">zip and zip_longest filters</span></a></p>   <h2 id="product-filters">Product Filters</h2> <p>The product filter returns the <a class="reference external" href="https://docs.python.org/3/library/itertools.html#itertools.product">cartesian product</a> of the input iterables.</p> <p>This is roughly equivalent to nested for-loops in a generator expression.</p> <p>For example:</p> <pre data-language="YAML">- name: generate multiple hostnames
  debug:
    msg: "{{ ['foo', 'bar'] | product(['com']) | map('join', '.') | join(',') }}"
</pre> <p>This would result in:</p> <pre data-language="YAML">{ "msg": "foo.com,bar.com" }
</pre>   <h2 id="debugging-filters">Debugging Filters</h2> <div class="versionadded"> <p><span class="versionmodified">New in version 2.3.</span></p> </div> <p>Use the <code>type_debug</code> filter to display the underlying Python type of a variable. This can be useful in debugging in situations where you may need to know the exact type of a variable:</p> <pre data-language="YAML">{{ myvar | type_debug }}
</pre>   <h2 id="computer-theory-assertions">Computer Theory Assertions</h2> <p>The <code>human_readable</code> and <code>human_to_bytes</code> functions let you test your playbooks to make sure you are using the right size format in your tasks - that you’re providing Byte format to computers and human-readable format to people.</p>   <h2 id="human-readable">Human Readable</h2> <p>Asserts whether the given string is human readable or not.</p> <p>For example:</p> <pre data-language="YAML">- name: "Human Readable"
  assert:
    that:
      - '"1.00 Bytes" == 1|human_readable'
      - '"1.00 bits" == 1|human_readable(isbits=True)'
      - '"10.00 KB" == 10240|human_readable'
      - '"97.66 MB" == 102400000|human_readable'
      - '"0.10 GB" == 102400000|human_readable(unit="G")'
      - '"0.10 Gb" == 102400000|human_readable(isbits=True, unit="G")'
</pre> <p>This would result in:</p> <pre data-language="YAML">{ "changed": false, "msg": "All assertions passed" }
</pre>   <h2 id="human-to-bytes">Human to Bytes</h2> <p>Returns the given string in the Bytes format.</p> <p>For example:</p> <pre data-language="YAML">- name: "Human to Bytes"
  assert:
    that:
      - "{{'0'|human_to_bytes}}        == 0"
      - "{{'0.1'|human_to_bytes}}      == 0"
      - "{{'0.9'|human_to_bytes}}      == 1"
      - "{{'1'|human_to_bytes}}        == 1"
      - "{{'10.00 KB'|human_to_bytes}} == 10240"
      - "{{   '11 MB'|human_to_bytes}} == 11534336"
      - "{{  '1.1 GB'|human_to_bytes}} == 1181116006"
      - "{{'10.00 Kb'|human_to_bytes(isbits=True)}} == 10240"
</pre> <p>This would result in:</p> <pre data-language="YAML">{ "changed": false, "msg": "All assertions passed" }
</pre> <p>A few useful filters are typically added with each new Ansible release. The development documentation shows how to extend Ansible filters by writing your own as plugins, though in general, we encourage new ones to be added to core so everyone can make use of them.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt><a class="reference internal" href="playbooks_intro#about-playbooks"><span class="std std-ref">About Playbooks</span></a></dt> <dd>An introduction to playbooks</dd> <dt><a class="reference internal" href="playbooks_conditionals#playbooks-conditionals"><span class="std std-ref">Conditionals</span></a></dt> <dd>Conditional statements in playbooks</dd> <dt><a class="reference internal" href="playbooks_variables#playbooks-variables"><span class="std std-ref">Using Variables</span></a></dt> <dd>All about variables</dd> <dt><a class="reference internal" href="playbooks_loops#playbooks-loops"><span class="std std-ref">Loops</span></a></dt> <dd>Looping in playbooks</dd> <dt><a class="reference internal" href="playbooks_reuse_roles#playbooks-reuse-roles"><span class="std std-ref">Roles</span></a></dt> <dd>Playbook organization by roles</dd> <dt><a class="reference internal" href="playbooks_best_practices#playbooks-best-practices"><span class="std std-ref">Best Practices</span></a></dt> <dd>Best practices in playbooks</dd> <dt><a class="reference external" href="https://groups.google.com/group/ansible-devel">User Mailing List</a></dt> <dd>Have a question? Stop by the google group!</dd> <dt><a class="reference external" href="http://irc.freenode.net">irc.freenode.net</a></dt> <dd>#ansible IRC chat channel</dd> </dl> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2018 Michael DeHaan<br>© 2018–2019 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/2.9/user_guide/playbooks_filters.html" class="_attribution-link">https://docs.ansible.com/ansible/2.9/user_guide/playbooks_filters.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
