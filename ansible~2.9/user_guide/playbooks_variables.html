
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Using Variables - Ansible 2.9 - W3cubDocs</title>
  
  <meta name="description" content="While automation exists to make it easier to make things repeatable, all systems are not exactly alike; some may require configuration that is &hellip;">
  <meta name="keywords" content="using, variables, ansible, ansible~2.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/ansible~2.9/user_guide/playbooks_variables.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/ansible~2.9.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ansible~2.9/" class="_nav-link" title="" style="margin-left:0;">Ansible 2.9</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="playbooks-variables">Using Variables</h1>  <ul class="simple" id="using-variables"> <li><a class="reference internal" href="#creating-valid-variable-names" id="id19">Creating valid variable names</a></li> <li><a class="reference internal" href="#defining-variables-in-inventory" id="id20">Defining variables in inventory</a></li> <li><a class="reference internal" href="#defining-variables-in-a-playbook" id="id21">Defining variables in a playbook</a></li> <li><a class="reference internal" href="#defining-variables-in-included-files-and-roles" id="id22">Defining variables in included files and roles</a></li> <li><a class="reference internal" href="#using-variables-with-jinja2" id="id23">Using variables with Jinja2</a></li> <li><a class="reference internal" href="#transforming-variables-with-jinja2-filters" id="id24">Transforming variables with Jinja2 filters</a></li> <li><a class="reference internal" href="#hey-wait-a-yaml-gotcha" id="id25">Hey wait, a YAML gotcha</a></li> <li>
<a class="reference internal" href="#variables-discovered-from-systems-facts" id="id26">Variables discovered from systems: Facts</a><ul> <li><a class="reference internal" href="#disabling-facts" id="id27">Disabling facts</a></li> <li><a class="reference internal" href="#local-facts-facts-d" id="id28">Local facts (facts.d)</a></li> <li><a class="reference internal" href="#ansible-version" id="id29">Ansible version</a></li> <li><a class="reference internal" href="#caching-facts" id="id30">Caching Facts</a></li> </ul> </li> <li><a class="reference internal" href="#registering-variables" id="id31">Registering variables</a></li> <li><a class="reference internal" href="#accessing-complex-variable-data" id="id32">Accessing complex variable data</a></li> <li><a class="reference internal" href="#accessing-information-about-other-hosts-with-magic-variables" id="id33">Accessing information about other hosts with magic variables</a></li> <li><a class="reference internal" href="#defining-variables-in-files" id="id34">Defining variables in files</a></li> <li><a class="reference internal" href="#passing-variables-on-the-command-line" id="id35">Passing variables on the command line</a></li> <li>
<a class="reference internal" href="#variable-precedence-where-should-i-put-a-variable" id="id36">Variable precedence: Where should I put a variable?</a><ul> <li><a class="reference internal" href="#scoping-variables" id="id37">Scoping variables</a></li> <li><a class="reference internal" href="#examples-of-where-to-set-a-variable" id="id38">Examples of where to set a variable</a></li> </ul> </li> <li><a class="reference internal" href="#using-advanced-variable-syntax" id="id39">Using advanced variable syntax</a></li> </ul>  <p>While automation exists to make it easier to make things repeatable, all systems are not exactly alike; some may require configuration that is slightly different from others. In some instances, the observed behavior or state of one system might influence how you configure other systems. For example, you might need to find out the IP address of a system and use it as a configuration value on another system.</p> <p>Ansible uses <em>variables</em> to help deal with differences between systems.</p> <p>To understand variables you’ll also want to read <a class="reference internal" href="playbooks_conditionals#playbooks-conditionals"><span class="std std-ref">Conditionals</span></a> and <a class="reference internal" href="playbooks_loops#playbooks-loops"><span class="std std-ref">Loops</span></a>. Useful things like the <strong>group_by</strong> module and the <code>when</code> conditional can also be used with variables, and to help manage differences between systems.</p> <p>The <a class="reference external" href="https://github.com/ansible/ansible-examples">ansible-examples github repository</a> contains many examples of how variables are used in Ansible.</p>  <h2 id="valid-variable-names">Creating valid variable names</h2> <p id="creating-valid-variable-names">Before you start using variables, it’s important to know what are valid variable names.</p> <p>Variable names should be letters, numbers, and underscores. Variables should always start with a letter.</p> <p><code>foo_port</code> is a great variable. <code>foo5</code> is fine too.</p> <p><code>foo-port</code>, <code>foo port</code>, <code>foo.port</code> and <code>12</code> are not valid variable names.</p> <p>YAML also supports dictionaries which map keys to values. For instance:</p> <pre data-language="YAML">foo:
  field1: one
  field2: two
</pre> <p>You can then reference a specific field in the dictionary using either bracket notation or dot notation:</p> <pre data-language="YAML">foo['field1']
foo.field1
</pre> <p>These will both reference the same value (“one”). However, if you choose to use dot notation be aware that some keys can cause problems because they collide with attributes and methods of python dictionaries. You should use bracket notation instead of dot notation if you use keys which start and end with two underscores (Those are reserved for special meanings in python) or are any of the known public attributes:</p> <p><code>add</code>, <code>append</code>, <code>as_integer_ratio</code>, <code>bit_length</code>, <code>capitalize</code>, <code>center</code>, <code>clear</code>, <code>conjugate</code>, <code>copy</code>, <code>count</code>, <code>decode</code>, <code>denominator</code>, <code>difference</code>, <code>difference_update</code>, <code>discard</code>, <code>encode</code>, <code>endswith</code>, <code>expandtabs</code>, <code>extend</code>, <code>find</code>, <code>format</code>, <code>fromhex</code>, <code>fromkeys</code>, <code>get</code>, <code>has_key</code>, <code>hex</code>, <code>imag</code>, <code>index</code>, <code>insert</code>, <code>intersection</code>, <code>intersection_update</code>, <code>isalnum</code>, <code>isalpha</code>, <code>isdecimal</code>, <code>isdigit</code>, <code>isdisjoint</code>, <code>is_integer</code>, <code>islower</code>, <code>isnumeric</code>, <code>isspace</code>, <code>issubset</code>, <code>issuperset</code>, <code>istitle</code>, <code>isupper</code>, <code>items</code>, <code>iteritems</code>, <code>iterkeys</code>, <code>itervalues</code>, <code>join</code>, <code>keys</code>, <code>ljust</code>, <code>lower</code>, <code>lstrip</code>, <code>numerator</code>, <code>partition</code>, <code>pop</code>, <code>popitem</code>, <code>real</code>, <code>remove</code>, <code>replace</code>, <code>reverse</code>, <code>rfind</code>, <code>rindex</code>, <code>rjust</code>, <code>rpartition</code>, <code>rsplit</code>, <code>rstrip</code>, <code>setdefault</code>, <code>sort</code>, <code>split</code>, <code>splitlines</code>, <code>startswith</code>, <code>strip</code>, <code>swapcase</code>, <code>symmetric_difference</code>, <code>symmetric_difference_update</code>, <code>title</code>, <code>translate</code>, <code>union</code>, <code>update</code>, <code>upper</code>, <code>values</code>, <code>viewitems</code>, <code>viewkeys</code>, <code>viewvalues</code>, <code>zfill</code>.</p>   <h2 id="variables-in-inventory">Defining variables in inventory</h2> <p id="defining-variables-in-inventory">Often you’ll want to set variables for an individual host, or for a group of hosts in your inventory. For instance, machines in Boston may all use ‘boston.ntp.example.com’ as an NTP server. The <a class="reference internal" href="intro_inventory#intro-inventory"><span class="std std-ref">How to build your inventory</span></a> page has details on setting <a class="reference internal" href="intro_inventory#host-variables"><span class="std std-ref">Assigning a variable to one machine: host variables</span></a> and <a class="reference internal" href="intro_inventory#group-variables"><span class="std std-ref">Assigning a variable to many machines: group variables</span></a> in inventory.</p>   <h2 id="playbook-variables">Defining variables in a playbook</h2> <p id="defining-variables-in-a-playbook">You can define variables directly in a playbook:</p> <pre data-language="YAML">- hosts: webservers
  vars:
    http_port: 80
</pre> <p>This can be nice as it’s right there when you are reading the playbook.</p>   <h2 id="included-variables">Defining variables in included files and roles</h2> <p id="defining-variables-in-included-files-and-roles">As described in <a class="reference internal" href="playbooks_reuse_roles#playbooks-reuse-roles"><span class="std std-ref">Roles</span></a>, variables can also be included in the playbook via include files, which may or may not be part of an Ansible Role. Usage of roles is preferred as it provides a nice organizational system.</p>   <h2 id="about-jinja2">Using variables with Jinja2</h2> <p id="using-variables-with-jinja2">Once you’ve defined variables, you can use them in your playbooks using the Jinja2 templating system. Here’s a simple Jinja2 template:</p> <pre data-language="YAML">My amp goes to {{ max_amp_value }}
</pre> <p>This expression provides the most basic form of variable substitution.</p> <p>You can use the same syntax in playbooks. For example:</p> <pre data-language="YAML">template: src=foo.cfg.j2 dest={{ remote_install_path }}/foo.cfg
</pre> <p>Here the variable defines the location of a file, which can vary from one system to another.</p> <p>Inside a template you automatically have access to all variables that are in scope for a host. Actually it’s more than that – you can also read variables about other hosts. We’ll show how to do that in a bit.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">ansible allows Jinja2 loops and conditionals in templates, but in playbooks, we do not use them. Ansible playbooks are pure machine-parseable YAML. This is a rather important feature as it means it is possible to code-generate pieces of files, or to have other ecosystem tools read Ansible files. Not everyone will need this but it can unlock possibilities.</p> </div> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt><a class="reference internal" href="playbooks_templating#playbooks-templating"><span class="std std-ref">Templating (Jinja2)</span></a></dt> <dd>More information about Jinja2 templating</dd> </dl> </div>   <h2 id="jinja2-filters">Transforming variables with Jinja2 filters</h2> <p id="transforming-variables-with-jinja2-filters">Jinja2 filters let you transform the value of a variable within a template expression. For example, the <code>capitalize</code> filter capitalizes any value passed to it; the <code>to_yaml</code> and <code>to_json</code> filters change the format of your variable values. Jinja2 includes many <a class="reference external" href="http://jinja.pocoo.org/docs/templates/#builtin-filters">built-in filters</a> and Ansible supplies <a class="reference internal" href="playbooks_filters#playbooks-filters"><span class="std std-ref">many more filters</span></a>.</p>   <h2 id="yaml-gotchas">Hey wait, a YAML gotcha</h2> <p id="hey-wait-a-yaml-gotcha">YAML syntax requires that if you start a value with <code>{{ foo }}</code> you quote the whole line, since it wants to be sure you aren’t trying to start a YAML dictionary. This is covered on the <a class="reference internal" href="../reference_appendices/yamlsyntax#yaml-syntax"><span class="std std-ref">YAML Syntax</span></a> documentation.</p> <p>This won’t work:</p> <pre data-language="YAML">- hosts: app_servers
  vars:
      app_path: {{ base_path }}/22
</pre> <p>Do it like this and you’ll be fine:</p> <pre data-language="YAML">- hosts: app_servers
  vars:
       app_path: "{{ base_path }}/22"
</pre>   <h2 id="vars-and-facts">Variables discovered from systems: Facts</h2> <p id="variables-discovered-from-systems-facts">There are other places where variables can come from, but these are a type of variable that are discovered, not set by the user.</p> <p>Facts are information derived from speaking with your remote systems. You can find a complete set under the <code>ansible_facts</code> variable, most facts are also ‘injected’ as top level variables preserving the <code>ansible_</code> prefix, but some are dropped due to conflicts. This can be disabled via the <a class="reference internal" href="../reference_appendices/config#inject-facts-as-vars"><span class="std std-ref">INJECT_FACTS_AS_VARS</span></a> setting.</p> <p>An example of this might be the IP address of the remote host, or what the operating system is.</p> <p>To see what information is available, try the following in a play:</p> <pre data-language="YAML">- debug: var=ansible_facts
</pre> <p>To see the ‘raw’ information as gathered:</p> <pre data-language="YAML">ansible hostname -m setup
</pre> <p>This will return a large amount of variable data, which may look like this on Ansible 2.7:</p> <pre data-language="json">{
    "ansible_all_ipv4_addresses": [
        "REDACTED IP ADDRESS"
    ],
    "ansible_all_ipv6_addresses": [
        "REDACTED IPV6 ADDRESS"
    ],
    "ansible_apparmor": {
        "status": "disabled"
    },
    "ansible_architecture": "x86_64",
    "ansible_bios_date": "11/28/2013",
    "ansible_bios_version": "4.1.5",
    "ansible_cmdline": {
        "BOOT_IMAGE": "/boot/vmlinuz-3.10.0-862.14.4.el7.x86_64",
        "console": "ttyS0,115200",
        "no_timer_check": true,
        "nofb": true,
        "nomodeset": true,
        "ro": true,
        "root": "LABEL=cloudimg-rootfs",
        "vga": "normal"
    },
    "ansible_date_time": {
        "date": "2018-10-25",
        "day": "25",
        "epoch": "1540469324",
        "hour": "12",
        "iso8601": "2018-10-25T12:08:44Z",
        "iso8601_basic": "20181025T120844109754",
        "iso8601_basic_short": "20181025T120844",
        "iso8601_micro": "2018-10-25T12:08:44.109968Z",
        "minute": "08",
        "month": "10",
        "second": "44",
        "time": "12:08:44",
        "tz": "UTC",
        "tz_offset": "+0000",
        "weekday": "Thursday",
        "weekday_number": "4",
        "weeknumber": "43",
        "year": "2018"
    },
    "ansible_default_ipv4": {
        "address": "REDACTED",
        "alias": "eth0",
        "broadcast": "REDACTED",
        "gateway": "REDACTED",
        "interface": "eth0",
        "macaddress": "REDACTED",
        "mtu": 1500,
        "netmask": "255.255.255.0",
        "network": "REDACTED",
        "type": "ether"
    },
    "ansible_default_ipv6": {},
    "ansible_device_links": {
        "ids": {},
        "labels": {
            "xvda1": [
                "cloudimg-rootfs"
            ],
            "xvdd": [
                "config-2"
            ]
        },
        "masters": {},
        "uuids": {
            "xvda1": [
                "cac81d61-d0f8-4b47-84aa-b48798239164"
            ],
            "xvdd": [
                "2018-10-25-12-05-57-00"
            ]
        }
    },
    "ansible_devices": {
        "xvda": {
            "holders": [],
            "host": "",
            "links": {
                "ids": [],
                "labels": [],
                "masters": [],
                "uuids": []
            },
            "model": null,
            "partitions": {
                "xvda1": {
                    "holders": [],
                    "links": {
                        "ids": [],
                        "labels": [
                            "cloudimg-rootfs"
                        ],
                        "masters": [],
                        "uuids": [
                            "cac81d61-d0f8-4b47-84aa-b48798239164"
                        ]
                    },
                    "sectors": "83883999",
                    "sectorsize": 512,
                    "size": "40.00 GB",
                    "start": "2048",
                    "uuid": "cac81d61-d0f8-4b47-84aa-b48798239164"
                }
            },
            "removable": "0",
            "rotational": "0",
            "sas_address": null,
            "sas_device_handle": null,
            "scheduler_mode": "deadline",
            "sectors": "83886080",
            "sectorsize": "512",
            "size": "40.00 GB",
            "support_discard": "0",
            "vendor": null,
            "virtual": 1
        },
        "xvdd": {
            "holders": [],
            "host": "",
            "links": {
                "ids": [],
                "labels": [
                    "config-2"
                ],
                "masters": [],
                "uuids": [
                    "2018-10-25-12-05-57-00"
                ]
            },
            "model": null,
            "partitions": {},
            "removable": "0",
            "rotational": "0",
            "sas_address": null,
            "sas_device_handle": null,
            "scheduler_mode": "deadline",
            "sectors": "131072",
            "sectorsize": "512",
            "size": "64.00 MB",
            "support_discard": "0",
            "vendor": null,
            "virtual": 1
        },
        "xvde": {
            "holders": [],
            "host": "",
            "links": {
                "ids": [],
                "labels": [],
                "masters": [],
                "uuids": []
            },
            "model": null,
            "partitions": {
                "xvde1": {
                    "holders": [],
                    "links": {
                        "ids": [],
                        "labels": [],
                        "masters": [],
                        "uuids": []
                    },
                    "sectors": "167770112",
                    "sectorsize": 512,
                    "size": "80.00 GB",
                    "start": "2048",
                    "uuid": null
                }
            },
            "removable": "0",
            "rotational": "0",
            "sas_address": null,
            "sas_device_handle": null,
            "scheduler_mode": "deadline",
            "sectors": "167772160",
            "sectorsize": "512",
            "size": "80.00 GB",
            "support_discard": "0",
            "vendor": null,
            "virtual": 1
        }
    },
    "ansible_distribution": "CentOS",
    "ansible_distribution_file_parsed": true,
    "ansible_distribution_file_path": "/etc/redhat-release",
    "ansible_distribution_file_variety": "RedHat",
    "ansible_distribution_major_version": "7",
    "ansible_distribution_release": "Core",
    "ansible_distribution_version": "7.5.1804",
    "ansible_dns": {
        "nameservers": [
            "127.0.0.1"
        ]
    },
    "ansible_domain": "",
    "ansible_effective_group_id": 1000,
    "ansible_effective_user_id": 1000,
    "ansible_env": {
        "HOME": "/home/zuul",
        "LANG": "en_US.UTF-8",
        "LESSOPEN": "||/usr/bin/lesspipe.sh %s",
        "LOGNAME": "zuul",
        "MAIL": "/var/mail/zuul",
        "PATH": "/usr/local/bin:/usr/bin",
        "PWD": "/home/zuul",
        "SELINUX_LEVEL_REQUESTED": "",
        "SELINUX_ROLE_REQUESTED": "",
        "SELINUX_USE_CURRENT_RANGE": "",
        "SHELL": "/bin/bash",
        "SHLVL": "2",
        "SSH_CLIENT": "REDACTED 55672 22",
        "SSH_CONNECTION": "REDACTED 55672 REDACTED 22",
        "USER": "zuul",
        "XDG_RUNTIME_DIR": "/run/user/1000",
        "XDG_SESSION_ID": "1",
        "_": "/usr/bin/python2"
    },
    "ansible_eth0": {
        "active": true,
        "device": "eth0",
        "ipv4": {
            "address": "REDACTED",
            "broadcast": "REDACTED",
            "netmask": "255.255.255.0",
            "network": "REDACTED"
        },
        "ipv6": [
            {
                "address": "REDACTED",
                "prefix": "64",
                "scope": "link"
            }
        ],
        "macaddress": "REDACTED",
        "module": "xen_netfront",
        "mtu": 1500,
        "pciid": "vif-0",
        "promisc": false,
        "type": "ether"
    },
    "ansible_eth1": {
        "active": true,
        "device": "eth1",
        "ipv4": {
            "address": "REDACTED",
            "broadcast": "REDACTED",
            "netmask": "255.255.224.0",
            "network": "REDACTED"
        },
        "ipv6": [
            {
                "address": "REDACTED",
                "prefix": "64",
                "scope": "link"
            }
        ],
        "macaddress": "REDACTED",
        "module": "xen_netfront",
        "mtu": 1500,
        "pciid": "vif-1",
        "promisc": false,
        "type": "ether"
    },
    "ansible_fips": false,
    "ansible_form_factor": "Other",
    "ansible_fqdn": "centos-7-rax-dfw-0003427354",
    "ansible_hostname": "centos-7-rax-dfw-0003427354",
    "ansible_interfaces": [
        "lo",
        "eth1",
        "eth0"
    ],
    "ansible_is_chroot": false,
    "ansible_kernel": "3.10.0-862.14.4.el7.x86_64",
    "ansible_lo": {
        "active": true,
        "device": "lo",
        "ipv4": {
            "address": "127.0.0.1",
            "broadcast": "host",
            "netmask": "255.0.0.0",
            "network": "127.0.0.0"
        },
        "ipv6": [
            {
                "address": "::1",
                "prefix": "128",
                "scope": "host"
            }
        ],
        "mtu": 65536,
        "promisc": false,
        "type": "loopback"
    },
    "ansible_local": {},
    "ansible_lsb": {
        "codename": "Core",
        "description": "CentOS Linux release 7.5.1804 (Core)",
        "id": "CentOS",
        "major_release": "7",
        "release": "7.5.1804"
    },
    "ansible_machine": "x86_64",
    "ansible_machine_id": "2db133253c984c82aef2fafcce6f2bed",
    "ansible_memfree_mb": 7709,
    "ansible_memory_mb": {
        "nocache": {
            "free": 7804,
            "used": 173
        },
        "real": {
            "free": 7709,
            "total": 7977,
            "used": 268
        },
        "swap": {
            "cached": 0,
            "free": 0,
            "total": 0,
            "used": 0
        }
    },
    "ansible_memtotal_mb": 7977,
    "ansible_mounts": [
        {
            "block_available": 7220998,
            "block_size": 4096,
            "block_total": 9817227,
            "block_used": 2596229,
            "device": "/dev/xvda1",
            "fstype": "ext4",
            "inode_available": 10052341,
            "inode_total": 10419200,
            "inode_used": 366859,
            "mount": "/",
            "options": "rw,seclabel,relatime,data=ordered",
            "size_available": 29577207808,
            "size_total": 40211361792,
            "uuid": "cac81d61-d0f8-4b47-84aa-b48798239164"
        },
        {
            "block_available": 0,
            "block_size": 2048,
            "block_total": 252,
            "block_used": 252,
            "device": "/dev/xvdd",
            "fstype": "iso9660",
            "inode_available": 0,
            "inode_total": 0,
            "inode_used": 0,
            "mount": "/mnt/config",
            "options": "ro,relatime,mode=0700",
            "size_available": 0,
            "size_total": 516096,
            "uuid": "2018-10-25-12-05-57-00"
        }
    ],
    "ansible_nodename": "centos-7-rax-dfw-0003427354",
    "ansible_os_family": "RedHat",
    "ansible_pkg_mgr": "yum",
    "ansible_processor": [
        "0",
        "GenuineIntel",
        "Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz",
        "1",
        "GenuineIntel",
        "Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz",
        "2",
        "GenuineIntel",
        "Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz",
        "3",
        "GenuineIntel",
        "Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz",
        "4",
        "GenuineIntel",
        "Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz",
        "5",
        "GenuineIntel",
        "Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz",
        "6",
        "GenuineIntel",
        "Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz",
        "7",
        "GenuineIntel",
        "Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz"
    ],
    "ansible_processor_cores": 8,
    "ansible_processor_count": 8,
    "ansible_processor_threads_per_core": 1,
    "ansible_processor_vcpus": 8,
    "ansible_product_name": "HVM domU",
    "ansible_product_serial": "REDACTED",
    "ansible_product_uuid": "REDACTED",
    "ansible_product_version": "4.1.5",
    "ansible_python": {
        "executable": "/usr/bin/python2",
        "has_sslcontext": true,
        "type": "CPython",
        "version": {
            "major": 2,
            "micro": 5,
            "minor": 7,
            "releaselevel": "final",
            "serial": 0
        },
        "version_info": [
            2,
            7,
            5,
            "final",
            0
        ]
    },
    "ansible_python_version": "2.7.5",
    "ansible_real_group_id": 1000,
    "ansible_real_user_id": 1000,
    "ansible_selinux": {
        "config_mode": "enforcing",
        "mode": "enforcing",
        "policyvers": 31,
        "status": "enabled",
        "type": "targeted"
    },
    "ansible_selinux_python_present": true,
    "ansible_service_mgr": "systemd",
    "ansible_ssh_host_key_ecdsa_public": "REDACTED KEY VALUE",
    "ansible_ssh_host_key_ed25519_public": "REDACTED KEY VALUE",
    "ansible_ssh_host_key_rsa_public": "REDACTED KEY VALUE",
    "ansible_swapfree_mb": 0,
    "ansible_swaptotal_mb": 0,
    "ansible_system": "Linux",
    "ansible_system_capabilities": [
        ""
    ],
    "ansible_system_capabilities_enforced": "True",
    "ansible_system_vendor": "Xen",
    "ansible_uptime_seconds": 151,
    "ansible_user_dir": "/home/zuul",
    "ansible_user_gecos": "",
    "ansible_user_gid": 1000,
    "ansible_user_id": "zuul",
    "ansible_user_shell": "/bin/bash",
    "ansible_user_uid": 1000,
    "ansible_userspace_architecture": "x86_64",
    "ansible_userspace_bits": "64",
    "ansible_virtualization_role": "guest",
    "ansible_virtualization_type": "xen",
    "gather_subset": [
        "all"
    ],
    "module_setup": true
}
</pre> <p>In the above the model of the first disk may be referenced in a template or playbook as:</p> <pre data-language="YAML">{{ ansible_facts['devices']['xvda']['model'] }}
</pre> <p>Similarly, the hostname as the system reports it is:</p> <pre data-language="YAML">{{ ansible_facts['nodename'] }}
</pre> <p>Facts are frequently used in conditionals (see <a class="reference internal" href="playbooks_conditionals#playbooks-conditionals"><span class="std std-ref">Conditionals</span></a>) and also in templates.</p> <p>Facts can be also used to create dynamic groups of hosts that match particular criteria, see the <a class="reference external" href="https://docs.python.org/3/library/modules.html#modules" title="(in Python v3.9)"><span>Importing Modules</span></a> documentation on <strong>group_by</strong> for details, as well as in generalized conditional statements as discussed in the <a class="reference internal" href="playbooks_conditionals#playbooks-conditionals"><span class="std std-ref">Conditionals</span></a> chapter.</p>  <h3 id="id1">Disabling facts</h3> <p id="disabling-facts">If you know you don’t need any fact data about your hosts, and know everything about your systems centrally, you can turn off fact gathering. This has advantages in scaling Ansible in push mode with very large numbers of systems, mainly, or if you are using Ansible on experimental platforms. In any play, just do this:</p> <pre data-language="YAML">- hosts: whatever
  gather_facts: no
</pre>   <h3 id="local-facts">Local facts (facts.d)</h3> <div class="versionadded" id="local-facts-facts-d"> <p><span class="versionmodified">New in version 1.3.</span></p> </div> <p>As discussed in the playbooks chapter, Ansible facts are a way of getting data about remote systems for use in playbook variables.</p> <p>Usually these are discovered automatically by the <code>setup</code> module in Ansible. Users can also write custom facts modules, as described in the API guide. However, what if you want to have a simple way to provide system or user provided data for use in Ansible variables, without writing a fact module?</p> <p>“Facts.d” is one mechanism for users to control some aspect of how their systems are managed.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Perhaps “local facts” is a bit of a misnomer, it means “locally supplied user values” as opposed to “centrally supplied user values”, or what facts are – “locally dynamically determined values”.</p> </div> <p>If a remotely managed system has an <code>/etc/ansible/facts.d</code> directory, any files in this directory ending in <code>.fact</code>, can be JSON, INI, or executable files returning JSON, and these can supply local facts in Ansible. An alternate directory can be specified using the <code>fact_path</code> play keyword.</p> <p>For example, assume <code>/etc/ansible/facts.d/preferences.fact</code> contains:</p> <pre data-language="YAML">[general]
asdf=1
bar=2
</pre> <p>This will produce a hash variable fact named <code>general</code> with <code>asdf</code> and <code>bar</code> as members. To validate this, run the following:</p> <pre data-language="YAML">ansible &lt;hostname&gt; -m setup -a "filter=ansible_local"
</pre> <p>And you will see the following fact added:</p> <pre data-language="YAML">"ansible_local": {
        "preferences": {
            "general": {
                "asdf" : "1",
                "bar"  : "2"
            }
        }
 }
</pre> <p>And this data can be accessed in a <code>template/playbook</code> as:</p> <pre data-language="YAML">{{ ansible_local['preferences']['general']['asdf'] }}
</pre> <p>The local namespace prevents any user supplied fact from overriding system facts or variables defined elsewhere in the playbook.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The key part in the key=value pairs will be converted into lowercase inside the ansible_local variable. Using the example above, if the ini file contained <code>XYZ=3</code> in the <code>[general]</code> section, then you should expect to access it as: <code>{{ ansible_local['preferences']['general']['xyz'] }}</code> and not <code>{{ ansible_local['preferences']['general']['XYZ'] }}</code>. This is because Ansible uses Python’s <a class="reference external" href="https://docs.python.org/2/library/configparser.html">ConfigParser</a> which passes all option names through the <a class="reference external" href="https://docs.python.org/2/library/configparser.html#ConfigParser.RawConfigParser.optionxform">optionxform</a> method and this method’s default implementation converts option names to lower case.</p> </div> <p>If you have a playbook that is copying over a custom fact and then running it, making an explicit call to re-run the setup module can allow that fact to be used during that particular play. Otherwise, it will be available in the next play that gathers fact information. Here is an example of what that might look like:</p> <pre data-language="YAML">- hosts: webservers
  tasks:
    - name: create directory for ansible custom facts
      file: state=directory recurse=yes path=/etc/ansible/facts.d
    - name: install custom ipmi fact
      copy: src=ipmi.fact dest=/etc/ansible/facts.d
    - name: re-read facts after adding custom fact
      setup: filter=ansible_local
</pre> <p>In this pattern however, you could also write a fact module as well, and may wish to consider this as an option.</p>   <h3 id="id2">Ansible version</h3> <div class="versionadded" id="ansible-version"> <p><span class="versionmodified">New in version 1.8.</span></p> </div> <p>To adapt playbook behavior to specific version of ansible, a variable ansible_version is available, with the following structure:</p> <pre data-language="YAML">"ansible_version": {
    "full": "2.0.0.2",
    "major": 2,
    "minor": 0,
    "revision": 0,
    "string": "2.0.0.2"
}
</pre>   <h3 id="fact-caching">Caching Facts</h3> <div class="versionadded" id="caching-facts"> <p><span class="versionmodified">New in version 1.8.</span></p> </div> <p>As shown elsewhere in the docs, it is possible for one server to reference variables about another, like so:</p> <pre data-language="YAML">{{ hostvars['asdf.example.com']['ansible_facts']['os_family'] }}
</pre> <p>With “Fact Caching” disabled, in order to do this, Ansible must have already talked to ‘asdf.example.com’ in the current play, or another play up higher in the playbook. This is the default configuration of ansible.</p> <p>To avoid this, Ansible 1.8 allows the ability to save facts between playbook runs, but this feature must be manually enabled. Why might this be useful?</p> <p>With a very large infrastructure with thousands of hosts, fact caching could be configured to run nightly. Configuration of a small set of servers could run ad-hoc or periodically throughout the day. With fact caching enabled, it would not be necessary to “hit” all servers to reference variables and information about them.</p> <p>With fact caching enabled, it is possible for machine in one group to reference variables about machines in the other group, despite the fact that they have not been communicated with in the current execution of /usr/bin/ansible-playbook.</p> <p>To benefit from cached facts, you will want to change the <code>gathering</code> setting to <code>smart</code> or <code>explicit</code> or set <code>gather_facts</code> to <code>False</code> in most plays.</p> <p>Currently, Ansible ships with two persistent cache plugins: redis and jsonfile.</p> <p>To configure fact caching using redis, enable it in <code>ansible.cfg</code> as follows:</p> <pre data-language="YAML">[defaults]
gathering = smart
fact_caching = redis
fact_caching_timeout = 86400
# seconds
</pre> <p>To get redis up and running, perform the equivalent OS commands:</p> <pre data-language="YAML">yum install redis
service redis start
pip install redis
</pre> <p>Note that the Python redis library should be installed from pip, the version packaged in EPEL is too old for use by Ansible.</p> <p>In current embodiments, this feature is in beta-level state and the Redis plugin does not support port or password configuration, this is expected to change in the near future.</p> <p>To configure fact caching using jsonfile, enable it in <code>ansible.cfg</code> as follows:</p> <pre data-language="YAML">[defaults]
gathering = smart
fact_caching = jsonfile
fact_caching_connection = /path/to/cachedir
fact_caching_timeout = 86400
# seconds
</pre> <p><code>fact_caching_connection</code> is a local filesystem path to a writeable directory (ansible will attempt to create the directory if one does not exist).</p> <p><code>fact_caching_timeout</code> is the number of seconds to cache the recorded facts.</p>    <h2 id="registered-variables">Registering variables</h2> <p id="registering-variables">Another major use of variables is running a command and registering the result of that command as a variable. When you execute a task and save the return value in a variable for use in later tasks, you create a registered variable. There are more examples of this in the <a class="reference internal" href="playbooks_conditionals#playbooks-conditionals"><span class="std std-ref">Conditionals</span></a> chapter.</p> <p>For example:</p> <pre data-language="YAML">- hosts: web_servers

  tasks:

     - shell: /usr/bin/foo
       register: foo_result
       ignore_errors: True

     - shell: /usr/bin/bar
       when: foo_result.rc == 5
</pre> <p>Results will vary from module to module. Each module’s documentation includes a <code>RETURN</code> section describing that module’s return values. To see the values for a particular task, run your playbook with <code>-v</code>.</p> <p>Registered variables are similar to facts, with a few key differences. Like facts, registered variables are host-level variables. However, registered variables are only stored in memory. (Ansible facts are backed by whatever cache plugin you have configured.) Registered variables are only valid on the host for the rest of the current playbook run. Finally, registered variables and facts have different <a class="reference internal" href="#ansible-variable-precedence"><span class="std std-ref">precedence levels</span></a>.</p> <p>When you register a variable in a task with a loop, the registered variable contains a value for each item in the loop. The data structure placed in the variable during the loop will contain a <code>results</code> attribute, that is a list of all responses from the module. For a more in-depth example of how this works, see the <a class="reference internal" href="playbooks_loops#playbooks-loops"><span class="std std-ref">Loops</span></a> section on using register with a loop.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If a task fails or is skipped, the variable still is registered with a failure or skipped status, the only way to avoid registering a variable is using tags.</p> </div>   <h2 id="id3">Accessing complex variable data</h2> <p id="accessing-complex-variable-data">We already described facts a little higher up in the documentation.</p> <p>Some provided facts, like networking information, are made available as nested data structures. To access them a simple <code>{{ foo }}</code> is not sufficient, but it is still easy to do. Here’s how we get an IP address:</p> <pre data-language="YAML">{{ ansible_facts["eth0"]["ipv4"]["address"] }}
</pre> <p>OR alternatively:</p> <pre data-language="YAML">{{ ansible_facts.eth0.ipv4.address }}
</pre> <p>Similarly, this is how we access the first element of an array:</p> <pre data-language="YAML">{{ foo[0] }}
</pre>   <h2 id="magic-variables-and-hostvars">Accessing information about other hosts with magic variables</h2> <p id="accessing-information-about-other-hosts-with-magic-variables">Whether or not you define any variables, you can access information about your hosts with the <a class="reference internal" href="../reference_appendices/special_variables#special-variables"><span class="std std-ref">Special Variables</span></a> Ansible provides, including “magic” variables, facts, and connection variables. Magic variable names are reserved - do not set variables with these names. The variable <code>environment</code> is also reserved.</p> <p>The most commonly used magic variables are <code>hostvars</code>, <code>groups</code>, <code>group_names</code>, and <code>inventory_hostname</code>.</p> <p><code>hostvars</code> lets you access variables for another host, including facts that have been gathered about that host. You can access host variables at any point in a playbook. Even if you haven’t connected to that host yet in any play in the playbook or set of playbooks, you can still get the variables, but you will not be able to see the facts.</p> <p>If your database server wants to use the value of a ‘fact’ from another node, or an inventory variable assigned to another node, it’s easy to do so within a template or even an action line:</p> <pre data-language="YAML">{{ hostvars['test.example.com']['ansible_facts']['distribution'] }}
</pre> <p><code>groups</code> is a list of all the groups (and hosts) in the inventory. This can be used to enumerate all hosts within a group. For example:</p> <pre data-language="jinja">{% for host in groups['app_servers'] %}
   # something that applies to all app servers.
{% endfor %}
</pre> <p>A frequently used idiom is walking a group to find all IP addresses in that group.</p> <pre data-language="jinja">{% for host in groups['app_servers'] %}
   {{ hostvars[host]['ansible_facts']['eth0']['ipv4']['address'] }}
{% endfor %}
</pre> <p>You can use this idiom to point a frontend proxy server to all of the app servers, to set up the correct firewall rules between servers, etc. You need to make sure that the facts of those hosts have been populated before though, for example by running a play against them if the facts have not been cached recently (fact caching was added in Ansible 1.8).</p> <p><code>group_names</code> is a list (array) of all the groups the current host is in. This can be used in templates using Jinja2 syntax to make template source files that vary based on the group membership (or role) of the host:</p> <pre data-language="jinja">{% if 'webserver' in group_names %}
   # some part of a configuration file that only applies to webservers
{% endif %}
</pre> <p><code>inventory_hostname</code> is the name of the hostname as configured in Ansible’s inventory host file. This can be useful when you’ve disabled fact-gathering, or you don’t want to rely on the discovered hostname <code>ansible_hostname</code>. If you have a long FQDN, you can use <code>inventory_hostname_short</code>, which contains the part up to the first period, without the rest of the domain.</p> <p>Other useful magic variables refer to the current play or playbook, including:</p> <div class="versionadded"> <p><span class="versionmodified">New in version 2.2.</span></p> </div> <p><code>ansible_play_hosts</code> is the full list of all hosts still active in the current play.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 2.2.</span></p> </div> <p><code>ansible_play_batch</code> is available as a list of hostnames that are in scope for the current ‘batch’ of the play. The batch size is defined by <code>serial</code>, when not set it is equivalent to the whole play (making it the same as <code>ansible_play_hosts</code>).</p> <div class="versionadded"> <p><span class="versionmodified">New in version 2.3.</span></p> </div> <p><code>ansible_playbook_python</code> is the path to the python executable used to invoke the Ansible command line tool.</p> <p>These vars may be useful for filling out templates with multiple hostnames or for injecting the list into the rules for a load balancer.</p> <p>Also available, <code>inventory_dir</code> is the pathname of the directory holding Ansible’s inventory host file, <code>inventory_file</code> is the pathname and the filename pointing to the Ansible’s inventory host file.</p> <p><code>playbook_dir</code> contains the playbook base directory.</p> <p>We then have <code>role_path</code> which will return the current role’s pathname (since 1.8). This will only work inside a role.</p> <p>And finally, <code>ansible_check_mode</code> (added in version 2.1), a boolean magic variable which will be set to <code>True</code> if you run Ansible with <code>--check</code>.</p>   <h2 id="variable-file-separation-details">Defining variables in files</h2> <p id="defining-variables-in-files">It’s a great idea to keep your playbooks under source control, but you may wish to make the playbook source public while keeping certain important variables private. Similarly, sometimes you may just want to keep certain information in different files, away from the main playbook.</p> <p>You can do this by using an external variables file, or files, just like this:</p> <pre data-language="YAML">---

- hosts: all
  remote_user: root
  vars:
    favcolor: blue
  vars_files:
    - /vars/external_vars.yml

  tasks:

  - name: this is just a placeholder
    command: /bin/echo foo
</pre> <p>This removes the risk of sharing sensitive data with others when sharing your playbook source with them.</p> <p>The contents of each variables file is a simple YAML dictionary, like this:</p> <pre data-language="YAML">---
# in the above example, this would be vars/external_vars.yml
somevar: somevalue
password: magic
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">It’s also possible to keep per-host and per-group variables in very similar files, this is covered in <a class="reference internal" href="intro_inventory#splitting-out-vars"><span class="std std-ref">Organizing host and group variables</span></a>.</p> </div>   <h2 id="id4">Passing variables on the command line</h2> <p id="passing-variables-on-the-command-line">In addition to <code>vars_prompt</code> and <code>vars_files</code>, it is possible to set variables at the command line using the <code>--extra-vars</code> (or <code>-e</code>) argument. Variables can be defined using a single quoted string (containing one or more variables) using one of the formats below</p> <p>key=value format:</p> <pre data-language="YAML">ansible-playbook release.yml --extra-vars "version=1.23.45 other_variable=foo"
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Values passed in using the <code>key=value</code> syntax are interpreted as strings. Use the JSON format if you need to pass in anything that shouldn’t be a string (Booleans, integers, floats, lists etc).</p> </div> <p>JSON string format:</p> <pre data-language="YAML">ansible-playbook release.yml --extra-vars '{"version":"1.23.45","other_variable":"foo"}'
ansible-playbook arcade.yml --extra-vars '{"pacman":"mrs","ghosts":["inky","pinky","clyde","sue"]}'
</pre> <p>vars from a JSON or YAML file:</p> <pre data-language="YAML">ansible-playbook release.yml --extra-vars "@some_file.json"
</pre> <p>This is useful for, among other things, setting the hosts group or the user for the playbook.</p> <p>Escaping quotes and other special characters:</p> <p>Ensure you’re escaping quotes appropriately for both your markup (e.g. JSON), and for the shell you’re operating in.:</p> <pre data-language="YAML">ansible-playbook arcade.yml --extra-vars "{\"name\":\"Conan O\'Brien\"}"
ansible-playbook arcade.yml --extra-vars '{"name":"Conan O'\\\''Brien"}'
ansible-playbook script.yml --extra-vars "{\"dialog\":\"He said \\\"I just can\'t get enough of those single and double-quotes"\!"\\\"\"}"
</pre> <p>In these cases, it’s probably best to use a JSON or YAML file containing the variable definitions.</p>   <h2 id="ansible-variable-precedence">Variable precedence: Where should I put a variable?</h2> <p id="variable-precedence-where-should-i-put-a-variable">A lot of folks may ask about how variables override another. Ultimately it’s Ansible’s philosophy that it’s better you know where to put a variable, and then you have to think about it a lot less.</p> <p>Avoid defining the variable “x” in 47 places and then ask the question “which x gets used”. Why? Because that’s not Ansible’s Zen philosophy of doing things.</p> <p>There is only one Empire State Building. One Mona Lisa, etc. Figure out where to define a variable, and don’t make it complicated.</p> <p>However, let’s go ahead and get precedence out of the way! It exists. It’s a real thing, and you might have a use for it.</p> <p>If multiple variables of the same name are defined in different places, they get overwritten in a certain order.</p> <p>Here is the order of precedence from least to greatest (the last listed variables winning prioritization):</p>  <ol class="arabic simple"> <li>command line values (eg “-u user”)</li> <li>role defaults <a class="footnote-reference" href="#id15" id="id5">[1]</a>
</li> <li>inventory file or script group vars <a class="footnote-reference" href="#id16" id="id6">[2]</a>
</li> <li>inventory group_vars/all <a class="footnote-reference" href="#id17" id="id7">[3]</a>
</li> <li>playbook group_vars/all <a class="footnote-reference" href="#id17" id="id8">[3]</a>
</li> <li>inventory group_vars/* <a class="footnote-reference" href="#id17" id="id9">[3]</a>
</li> <li>playbook group_vars/* <a class="footnote-reference" href="#id17" id="id10">[3]</a>
</li> <li>inventory file or script host vars <a class="footnote-reference" href="#id16" id="id11">[2]</a>
</li> <li>inventory host_vars/* <a class="footnote-reference" href="#id17" id="id12">[3]</a>
</li> <li>playbook host_vars/* <a class="footnote-reference" href="#id17" id="id13">[3]</a>
</li> <li>host facts / cached set_facts <a class="footnote-reference" href="#id18" id="id14">[4]</a>
</li> <li>play vars</li> <li>play vars_prompt</li> <li>play vars_files</li> <li>role vars (defined in role/vars/main.yml)</li> <li>block vars (only for tasks in block)</li> <li>task vars (only for the task)</li> <li>include_vars</li> <li>set_facts / registered vars</li> <li>role (and include_role) params</li> <li>include params</li> <li>extra vars (always win precedence)</li> </ol>  <p>Basically, anything that goes into “role defaults” (the defaults folder inside the role) is the most malleable and easily overridden. Anything in the vars directory of the role overrides previous versions of that variable in namespace. The idea here to follow is that the more explicit you get in scope, the more precedence it takes with command line <code>-e</code> extra vars always winning. Host and/or inventory variables can win over role defaults, but not explicit includes like the vars directory or an <code>include_vars</code> task.</p> <h4 class="rubric">Footnotes</h4> <table class="docutils footnote" frame="void" id="id15" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id5">[1]</a></td>
<td>Tasks in each role will see their own role’s defaults. Tasks defined outside of a role will see the last role’s defaults.</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id16" rules="none">   <tr>
<td class="label">[2]</td>
<td>
<em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> Variables defined in inventory file or provided by dynamic inventory.</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id17" rules="none">   <tr>
<td class="label">[3]</td>
<td>
<em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id8">2</a>, <a class="fn-backref" href="#id9">3</a>, <a class="fn-backref" href="#id10">4</a>, <a class="fn-backref" href="#id12">5</a>, <a class="fn-backref" href="#id13">6</a>)</em> Includes vars added by ‘vars plugins’ as well as host_vars and group_vars which are added by the default vars plugin shipped with Ansible.</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id18" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id14">[4]</a></td>
<td>When created with set_facts’s cacheable option, variables will have the high precedence in the play, but will be the same as a host facts precedence when they come from the cache.</td>
</tr>  </table> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Within any section, redefining a var will overwrite the previous instance. If multiple groups have the same variable, the last one loaded wins. If you define a variable twice in a play’s <code>vars:</code> section, the second one wins.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The previous describes the default config <code>hash_behaviour=replace</code>, switch to <code>merge</code> to only partially overwrite.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Group loading follows parent/child relationships. Groups of the same ‘parent/child’ level are then merged following alphabetical order. This last one can be superseded by the user via <code>ansible_group_priority</code>, which defaults to <code>1</code> for all groups. This variable, <code>ansible_group_priority</code>, can only be set in the inventory source and not in group_vars/ as the variable is used in the loading of group_vars/.</p> </div> <p>Another important thing to consider (for all versions) is that connection variables override config, command line and play/role/task specific options and keywords. See <a class="reference internal" href="../reference_appendices/general_precedence#general-precedence-rules"><span class="std std-ref">Controlling how Ansible behaves: precedence rules</span></a> for more details. For example, if your inventory specifies <code>ansible_user: ramon</code> and you run:</p> <pre data-language="YAML">ansible -u lola myhost
</pre> <p>This will still connect as <code>ramon</code> because the value from the variable takes priority (in this case, the variable came from the inventory, but the same would be true no matter where the variable was defined).</p> <p>For plays/tasks this is also true for <code>remote_user</code>. Assuming the same inventory config, the following play:</p> <pre data-language="YAML">- hosts: myhost
  tasks:
   - command: I'll connect as ramon still
     remote_user: lola
</pre> <p>will have the value of <code>remote_user</code> overwritten by <code>ansible_user</code> in the inventory.</p> <p>This is done so host-specific settings can override the general settings. These variables are normally defined per host or group in inventory, but they behave like other variables.</p> <p>If you want to override the remote user globally (even over inventory) you can use extra vars. For instance, if you run:</p> <pre data-language="YAML">ansible... -e "ansible_user=maria" -u lola
</pre> <p>the <code>lola</code> value is still ignored, but <code>ansible_user=maria</code> takes precedence over all other places where <code>ansible_user</code> (or <code>remote_user</code>) might be set.</p> <p>A connection-specific version of a variable takes precedence over more generic versions. For example, <code>ansible_ssh_user</code> specified as a group_var would have a higher precedence than <code>ansible_user</code> specified as a host_var.</p> <p>You can also override as a normal variable in a play:</p> <pre data-language="YAML">- hosts: all
  vars:
    ansible_user: lola
  tasks:
    - command: I'll connect as lola!
</pre>  <h3 id="variable-scopes">Scoping variables</h3> <p id="scoping-variables">You can decide where to set a variable based on the scope you want that value to have. Ansible has three main scopes:</p>  <ul class="simple"> <li>Global: this is set by config, environment variables and the command line</li> <li>Play: each play and contained structures, vars entries (vars; vars_files; vars_prompt), role defaults and vars.</li> <li>Host: variables directly associated to a host, like inventory, include_vars, facts or registered task outputs</li> </ul>    <h3 id="variable-examples">Examples of where to set a variable</h3>  Let’s show some examples and where you would choose to put what based on the kind of control you might want over values. <p>First off, group variables are powerful.</p> <p>Site-wide defaults should be defined as a <code>group_vars/all</code> setting. Group variables are generally placed alongside your inventory file. They can also be returned by a dynamic inventory script (see <a class="reference internal" href="intro_dynamic_inventory#intro-dynamic-inventory"><span class="std std-ref">Working with dynamic inventory</span></a>) or defined in things like <a class="reference internal" href="https://docs.ansible.com/ansible/2.9/reference_appendices/tower.html#ansible-tower"><span class="std std-ref">Red Hat Ansible Tower</span></a> from the UI or API:</p> <pre data-language="YAML">---
# file: /etc/ansible/group_vars/all
# this is the site wide default
ntp_server: default-time.example.com
</pre> <p>Regional information might be defined in a <code>group_vars/region</code> variable. If this group is a child of the <code>all</code> group (which it is, because all groups are), it will override the group that is higher up and more general:</p> <pre data-language="YAML">---
# file: /etc/ansible/group_vars/boston
ntp_server: boston-time.example.com
</pre> <p>If for some crazy reason we wanted to tell just a specific host to use a specific NTP server, it would then override the group variable!:</p> <pre data-language="YAML">---
# file: /etc/ansible/host_vars/xyz.boston.example.com
ntp_server: override.example.com
</pre> <p>So that covers inventory and what you would normally set there. It’s a great place for things that deal with geography or behavior. Since groups are frequently the entity that maps roles onto hosts, it is sometimes a shortcut to set variables on the group instead of defining them on a role. You could go either way.</p> <p>Remember: Child groups override parent groups, and hosts always override their groups.</p> <p>Next up: learning about role variable precedence.</p> <p>We’ll pretty much assume you are using roles at this point. You should be using roles for sure. Roles are great. You are using roles aren’t you? Hint hint.</p> <p>If you are writing a redistributable role with reasonable defaults, put those in the <code>roles/x/defaults/main.yml</code> file. This means the role will bring along a default value but ANYTHING in Ansible will override it. See <a class="reference internal" href="playbooks_reuse_roles#playbooks-reuse-roles"><span class="std std-ref">Roles</span></a> for more info about this:</p> <pre data-language="YAML">---
# file: roles/x/defaults/main.yml
# if not overridden in inventory or as a parameter, this is the value that will be used
http_port: 80
</pre> <p>If you are writing a role and want to ensure the value in the role is absolutely used in that role, and is not going to be overridden by inventory, you should put it in <code>roles/x/vars/main.yml</code> like so, and inventory values cannot override it. <code>-e</code> however, still will:</p> <pre data-language="YAML">---
# file: roles/x/vars/main.yml
# this will absolutely be used in this role
http_port: 80
</pre> <p>This is one way to plug in constants about the role that are always true. If you are not sharing your role with others, app specific behaviors like ports is fine to put in here. But if you are sharing roles with others, putting variables in here might be bad. Nobody will be able to override them with inventory, but they still can by passing a parameter to the role.</p> <p>Parameterized roles are useful.</p> <p>If you are using a role and want to override a default, pass it as a parameter to the role like so:</p> <pre data-language="YAML">roles:
   - role: apache
     vars:
        http_port: 8080
</pre> <p>This makes it clear to the playbook reader that you’ve made a conscious choice to override some default in the role, or pass in some configuration that the role can’t assume by itself. It also allows you to pass something site-specific that isn’t really part of the role you are sharing with others.</p> <p>This can often be used for things that might apply to some hosts multiple times. For example:</p> <pre data-language="YAML">roles:
   - role: app_user
     vars:
        myname: Ian
   - role: app_user
     vars:
       myname: Terry
   - role: app_user
     vars:
       myname: Graham
   - role: app_user
     vars:
       myname: John
</pre> <p>In this example, the same role was invoked multiple times. It’s quite likely there was no default for <code>name</code> supplied at all. Ansible can warn you when variables aren’t defined – it’s the default behavior in fact.</p> <p>There are a few other things that go on with roles.</p> <p>Generally speaking, variables set in one role are available to others. This means if you have a <code>roles/common/vars/main.yml</code> you can set variables in there and make use of them in other roles and elsewhere in your playbook:</p> <pre data-language="YAML">roles:
   - role: common_settings
   - role: something
     vars:
       foo: 12
   - role: something_else
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">There are some protections in place to avoid the need to namespace variables. In the above, variables defined in common_settings are most definitely available to ‘something’ and ‘something_else’ tasks, but if “something’s” guaranteed to have foo set at 12, even if somewhere deep in common settings it set foo to 20.</p> </div> <p>So, that’s precedence, explained in a more direct way. Don’t worry about precedence, just think about if your role is defining a variable that is a default, or a “live” variable you definitely want to use. Inventory lies in precedence right in the middle, and if you want to forcibly override something, use <code>-e</code>.</p> <p>If you found that a little hard to understand, take a look at the <a class="reference external" href="https://github.com/ansible/ansible-examples">ansible-examples</a> repo on GitHub for a bit more about how all of these things can work together.</p>    <h2 id="using-advanced-variable-syntax">Using advanced variable syntax</h2> <p>For information about advanced YAML syntax used to declare variables and have more control over the data placed in YAML files used by Ansible, see <a class="reference internal" href="playbooks_advanced_syntax#playbooks-advanced-syntax"><span class="std std-ref">Advanced Syntax</span></a>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt><a class="reference internal" href="playbooks_intro#about-playbooks"><span class="std std-ref">About Playbooks</span></a></dt> <dd>An introduction to playbooks</dd> <dt><a class="reference internal" href="playbooks_conditionals#playbooks-conditionals"><span class="std std-ref">Conditionals</span></a></dt> <dd>Conditional statements in playbooks</dd> <dt><a class="reference internal" href="playbooks_filters#playbooks-filters"><span class="std std-ref">Filters</span></a></dt> <dd>Jinja2 filters and their uses</dd> <dt><a class="reference internal" href="playbooks_loops#playbooks-loops"><span class="std std-ref">Loops</span></a></dt> <dd>Looping in playbooks</dd> <dt><a class="reference internal" href="playbooks_reuse_roles#playbooks-reuse-roles"><span class="std std-ref">Roles</span></a></dt> <dd>Playbook organization by roles</dd> <dt><a class="reference internal" href="playbooks_best_practices#playbooks-best-practices"><span class="std std-ref">Best Practices</span></a></dt> <dd>Best practices in playbooks</dd> <dt><a class="reference internal" href="../reference_appendices/special_variables#special-variables"><span class="std std-ref">Special Variables</span></a></dt> <dd>List of special variables</dd> <dt><a class="reference external" href="https://groups.google.com/group/ansible-devel">User Mailing List</a></dt> <dd>Have a question? Stop by the google group!</dd> <dt><a class="reference external" href="http://irc.freenode.net">irc.freenode.net</a></dt> <dd>#ansible IRC chat channel</dd> </dl> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2018 Michael DeHaan<br>© 2018–2019 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/2.9/user_guide/playbooks_variables.html" class="_attribution-link">https://docs.ansible.com/ansible/2.9/user_guide/playbooks_variables.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
