
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>VCL - Varnish - W3cubDocs</title>
  
  <meta name="description" content=" 7 ">
  <meta name="keywords" content="vcl, varnish">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/varnish/reference/vcl.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-c2f2e7d1236e299f399a2d9bf4342fa70a8839fbe6eb79130546d6bf383b99636ffdf29c557090085d7c4ac34eeb5426851b42d2f4ec63cf218916cbd19aa876.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/varnish.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/varnish/" class="_nav-link" title="" style="margin-left:0;">Varnish</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="vcl-7">VCL</h1>  <h2 id="varnish-configuration-language">Varnish Configuration Language</h2> <dl class="field-list simple"> <dt class="field-odd">Manual section</dt> <dd class="field-odd">
<p>7</p> </dd> </dl>  <h3 id="description">DESCRIPTION</h3> <p>The VCL language is a small domain-specific language designed to be used to describe request handling and document caching policies for Varnish Cache.</p> <p>When a new configuration is loaded, the varnishd management process translates the VCL code to C and compiles it to a shared object which is then loaded into the server process.</p> <p>This document focuses on the syntax of the VCL language. For a full description of syntax and semantics, with ample examples, please see the online documentation at <a class="reference external" href="https://www.varnish-cache.org/docs/">https://www.varnish-cache.org/docs/</a> .</p> <p>Starting with Varnish 4.0, each VCL file must start by declaring its version with <code>vcl</code> <em>&lt;major&gt;.&lt;minor&gt;</em><code>;</code> marker at the top of the file. See more about this under Versioning below.</p>  <h4 id="operators">Operators</h4> <p>The following operators are available in VCL:</p>  <dl> <dt>
<code>=</code> </dt>
<dd>
<p>Assignment operator.</p> </dd> <dt>
<code>+=, -=, *=, /=</code> </dt>
<dd>
<p>Assign and increment/decrement/multiply/divide operator.</p> <p>For strings, <code>+=</code> appends.</p> </dd> <dt>
<code>==, !=, &lt;, &gt;, &lt;=, &gt;=</code> </dt>
<dd>
<p>Comparisons</p> </dd> <dt>
<code>~, !~</code> </dt>
<dd>
<p>Match / non-match. Can either be used with regular expressions or ACLs.</p> </dd> <dt>
<code>!</code> </dt>
<dd>
<p>Negation.</p> </dd> <dt>
<code>&amp;&amp; / ||</code> </dt>
<dd>
<p>Logical and/or.</p> </dd> </dl>    <h4 id="conditionals">Conditionals</h4> <p>VCL has <code>if</code> and <code>else</code> statements. Nested logic can be implemented with the <code>elseif</code> statement (<code>elsif</code>/<code>elif</code>/<code>else if</code> are equivalent).</p> <p>Note that there are no loops or iterators of any kind in VCL.</p>   <h4 id="strings-booleans-time-duration-integers-and-real-numbers">Strings, booleans, time, duration, integers and real numbers</h4> <p>These are the data types in Varnish. You can <code>set</code> or <code>unset</code> these.</p> <p>Example:</p> <pre data-language="python">set req.http.User-Agent = "unknown";
unset req.http.Range;
</pre>  <h5 id="strings">Strings</h5> <p>Basic strings are enclosed in double quotes <code>"</code><em>…</em><code>"</code>, and may not contain newlines. Long strings are enclosed in <code>{"</code><em>…</em><code>"}</code>. They may contain any character including single double quotes <code>"</code>, newline and other control characters except for the <em>NUL</em> (0x00) character.</p>   <h5 id="booleans">Booleans</h5> <p>Booleans can be either <code>true</code> or <code>false</code>. In addition, in a boolean context some data types will evaluate to <code>true</code> or <code>false</code> depending on their value.</p> <p>String types will evaluate to <code>false</code> if they are unset. This allows checks of the type <code>if (req.http.opthdr) {}</code> to test if a header exists, even if it is empty, whereas <code>if (req.http.opthdr == "") {}</code> does not distinguish if the header does not exist or if it is empty.</p> <p>Backend types will evaluate to <code>false</code> if they don’t have a backend assigned; integer types will evaluate to <code>false</code> if their value is zero; duration types will evaluate to <code>false</code> if their value is equal or less than zero.</p>   <h5 id="time">Time</h5> <p>VCL has time. A duration can be added to a time to make another time. In string context they return a formatted string in RFC1123 format, e.g. <code>Sun, 06 Nov 1994 08:49:37 GMT</code>.</p> <p>The keyword <code>now</code> returns a notion of the current time, which is kept consistent during VCL subroutine invocations, so during the execution of a VCL state subroutine (<code>vcl_* {}</code>), including all user-defined subroutines being called, <code>now</code> always returns the same value.</p>   <h5 id="durations">Durations</h5> <p>Durations are defined by a number followed by a unit. The number can include a fractional part, e.g. <code>1.5s</code>. The supported units are:</p>  <dl class="simple"> <dt>
<code>ms</code> </dt>
<dd>
<p>milliseconds</p> </dd> <dt>
<code>s</code> </dt>
<dd>
<p>seconds</p> </dd> <dt>
<code>m</code> </dt>
<dd>
<p>minutes</p> </dd> <dt>
<code>h</code> </dt>
<dd>
<p>hours</p> </dd> <dt>
<code>d</code> </dt>
<dd>
<p>days</p> </dd> <dt>
<code>w</code> </dt>
<dd>
<p>weeks</p> </dd> <dt>
<code>y</code> </dt>
<dd>
<p>years</p> </dd> </dl>  <p>In string context they return a string with their value rounded to 3 decimal places and excluding the unit, e.g. <code>1.500</code>.</p>   <h5 id="integers">Integers</h5> <p>Certain fields are integers, used as expected. In string context they return a string, e.g. <code>1234</code>.</p>   <h5 id="real-numbers">Real numbers</h5> <p>VCL understands real numbers. In string context they return a string with their value rounded to 3 decimal places, e.g. <code>3.142</code>.</p>    <h4 id="regular-expressions">Regular Expressions</h4> <p>Varnish uses Perl-compatible regular expressions (PCRE). For a complete description please see the pcre(3) man page.</p> <p>To send flags to the PCRE engine, such as to do case insensitive matching, add the flag within parens following a question mark, like this:</p> <pre data-language="python"># If host is NOT example dot com..
if (req.http.host !~ "(?i)example\.com$") {
    ...
}
</pre>   <h4 id="include-statement">Include statement</h4> <p>To include a VCL file in another file use the include keyword:</p> <pre data-language="python">include "foo.vcl";
</pre>   <h4 id="import-statement">Import statement</h4> <p>The <code>import</code> statement is used to load Varnish Modules (VMODs.)</p> <p>Example:</p> <pre data-language="python">import std;
sub vcl_recv {
    std.log("foo");
}
</pre>   <h4 id="comments">Comments</h4> <p>Single lines of VCL can be commented out using <code>//</code> or <code>#</code>. Multi-line blocks can be commented out with <code>/*</code><em>block</em><code>*/</code>.</p> <p>Example:</p> <pre data-language="python">sub vcl_recv {
    // Single line of out-commented VCL.
    # Another way of commenting out a single line.
    /*
        Multi-line block of commented-out VCL.
    */
}
</pre>   <h4 id="id1">Backend definition</h4> <p id="backend-definition">A backend declaration creates and initialises a named backend object. A declaration start with the keyword <code>backend</code> followed by the name of the backend. The actual declaration is in curly brackets, in a key/value fashion.:</p> <pre data-language="python">backend name {
    .attribute = "value";
}
</pre> <p>One of the attributes <code>.host</code> or <code>.path</code> is mandatory (but not both). The attributes will inherit their defaults from the global parameters. The following attributes are available:</p>  <dl class="simple"> <dt>
<code>.host</code> </dt>
<dd>
<p>The host to be used. IP address or a hostname that resolves to a single IP address. This attribute is mandatory, unless <code>.path</code> is declared.</p> </dd> </dl> <p><code>.path</code> (<code>VCL &gt;= 4.1</code>)</p>  <p>The absolute path of a Unix domain socket at which a backend is listening. If the file at that path does not exist or is not accessible to Varnish at VCL load time, then the VCL compiler issues a warning, but does not fail. This makes it possible to start the UDS-listening peer, or set the socket file’s permissions, after starting Varnish or loading VCL with a UDS backend. But the socket file must exist and have necessary permissions before the first connection is attempted, otherwise fetches will fail. If the file does exist and is accessible, then it must be a socket; otherwise the VCL load fails. One of <code>.path</code> or <code>.host</code> must be declared (but not both). <code>.path</code> may only be used in VCL since version 4.1.</p>  <dl> <dt>
<code>.port</code> </dt>
<dd>
<p>The port on the backend that Varnish should connect to. Ignored if a Unix domain socket is declared in <code>.path</code>.</p> </dd> <dt>
<code>.host_header</code> </dt>
<dd>
<p>A host header to add to probes and regular backend requests if they have no such header.</p> </dd> <dt>
<code>.connect_timeout</code> </dt>
<dd>
<p>Timeout for connections.</p> <p>Default: <code>connect_timeout</code> parameter, see <a class="reference internal" href="varnishd#varnishd-1"><span class="std std-ref">varnishd</span></a></p> </dd> <dt>
<code>.first_byte_timeout</code> </dt>
<dd>
<p>Timeout for first byte.</p> <p>Default: <code>first_byte_timeout</code> parameter, see <a class="reference internal" href="varnishd#varnishd-1"><span class="std std-ref">varnishd</span></a></p> </dd> <dt>
<code>.between_bytes_timeout</code> </dt>
<dd>
<p>Timeout between bytes.</p> <p>Default: <code>between_bytes_timeout</code> parameter, see <a class="reference internal" href="varnishd#varnishd-1"><span class="std std-ref">varnishd</span></a></p> </dd> <dt>
<code>.probe</code> </dt>
<dd>
<p>Attach a probe to the backend. See <a class="reference internal" href="#probes">Probes</a></p> </dd> <dt>
<code>.proxy_header</code> </dt>
<dd>
<p>The PROXY protocol version Varnish should use when connecting to this backend. Allowed values are <code>1</code> and <code>2</code>.</p> <p><em>Notice</em> this setting will lead to backend connections being used for a single request only (subject to future improvements). Thus, extra care should be taken to avoid running into failing backend connections with EADDRNOTAVAIL due to no local ports being available. Possible options are:</p> <ul class="simple"> <li>Use additional backend connections to extra IP addresses or TCP ports</li> <li>Increase the number of available ports (Linux sysctl <code>net.ipv4.ip_local_port_range</code>)</li> <li>Reuse backend connection ports early (Linux sysctl <code>net.ipv4.tcp_tw_reuse</code>)</li> </ul> </dd> <dt>
<code>.max_connections</code> </dt>
<dd>
<p>Maximum number of open connections towards this backend. If Varnish reaches the maximum Varnish it will start failing connections.</p> </dd> </dl>  <p>Empty backends can also be defined using the following syntax.:</p> <pre data-language="python">backend name none;
</pre> <p>An empty backend will always return status code 503 as if it is sick.</p> <p>Backends can be used with <em>directors</em>. Please see the <a class="reference internal" href="vmod_directors#vmod-directors-3"><span class="std std-ref">VMOD directors - Varnish Directors Module</span></a> man page for more information.</p>   <h4 id="reference-vcl-probes">Probes</h4> <p id="probes">Probes will query the backend for status on a regular basis and mark the backend as down it they fail. A probe is defined as this:</p> <pre data-language="python">probe name {
    .attribute = "value";
}
</pre> <p>The probe named <code>default</code> is special and will be used for all backends which do not explicitly reference a probe.</p> <p>There are no mandatory options. These are the options you can set:</p>  <dl> <dt>
<code>.url</code> </dt>
<dd>
<p>The URL to query. Defaults to <code>/</code>. Mutually exclusive with <code>.request</code></p> </dd> <dt>
<code>.request</code> </dt>
<dd>
<p>Specify a full HTTP request using multiple strings. <code>.request</code> will have <code>\r\n</code> automatically inserted after every string. Mutually exclusive with <code>.url</code>.</p> <p><em>Note</em> that probes require the backend to complete sending the response and close the connection within the specified timeout, so <code>.request</code> will, for <code>HTTP/1.1</code>, most likely need to contain a <code>"Connection: close"</code> string.</p> </dd> <dt>
<code>.expected_response</code> </dt>
<dd>
<p>The expected HTTP response code. Defaults to <code>200</code>.</p> </dd> <dt>
<code>.timeout</code> </dt>
<dd>
<p>The timeout for the probe. Default is <code>2s</code>.</p> </dd> <dt>
<code>.interval</code> </dt>
<dd>
<p>How often the probe is run. Default is <code>5s</code>.</p> </dd> <dt>
<code>.initial</code> </dt>
<dd>
<p>How many of the polls in <code>.window</code> are considered good when Varnish starts. Defaults to the value of <code>.threshold</code> - 1. In this case, the backend starts as sick and requires one single poll to be considered healthy.</p> </dd> <dt>
<code>.window</code> </dt>
<dd>
<p>How many of the latest polls we examine to determine backend health. Defaults to <code>8</code>.</p> </dd> <dt>
<code>.threshold</code> </dt>
<dd>
<p>How many of the polls in <code>.window</code> must have succeeded to consider the backend to be healthy. Defaults to <code>3</code>.</p> </dd> </dl>    <h4 id="access-control-list-acl">Access Control List (ACL)</h4> <p>An Access Control List (ACL) declaration creates and initialises a named access control list which can later be used to match client addresses:</p> <pre data-language="python">acl localnetwork {
    "localhost";    # myself
    "192.0.2.0"/24; # and everyone on the local network
    ! "192.0.2.23"; # except for the dial-in router
}
</pre> <p>If an ACL entry specifies a host name which Varnish is unable to resolve, it will match any address it is compared to. Consequently, if it is preceded by a negation mark, it will reject any address it is compared to, which may not be what you intended. If the entry is enclosed in parentheses, however, it will simply be ignored.</p> <p>To match an IP address against an ACL, simply use the match operator:</p> <pre data-language="python">if (client.ip ~ localnetwork) {
    return (pipe);
}
</pre>   <h4 id="vcl-objects">VCL objects</h4> <p>A VCL object can be instantiated with the <code>new</code> keyword:</p> <pre data-language="python">sub vcl_init {
    new b = directors.round_robin()
    b.add_backend(node1);
}
</pre> <p>This is only available in <code>vcl_init</code>.</p>   <h4 id="subroutines">Subroutines</h4> <p>A subroutine is used to group code for legibility or reusability:</p> <pre data-language="python">sub pipe_if_local {
    if (client.ip ~ localnetwork) {
        return (pipe);
    }
}
</pre> <p>Subroutines in VCL do not take arguments, nor do they return values. The built in subroutines all have names beginning with <code>vcl_</code>, which is reserved.</p> <p>To call a subroutine, use the <code>call</code> keyword followed by the subroutine’s name:</p> <pre data-language="python">sub vcl_recv {
    call pipe_if_local;
}
</pre>  <h5 id="return-statements">Return statements</h5> <p>The ongoing <code>vcl_*</code> subroutine execution ends when a <code>return(</code><em>&lt;action&gt;</em><code>)</code> statement is made.</p> <p>The <em>&lt;action&gt;</em> specifies how execution should proceed. The context defines which actions are available.</p>   <h5 id="multiple-subroutines">Multiple subroutines</h5> <p>If multiple subroutines with the name of one of the built-in ones are defined, they are concatenated in the order in which they appear in the source.</p> <p>The built-in VCL distributed with Varnish will be implicitly concatenated when the VCL is compiled.</p>    <h4 id="id2">VCL Variables</h4> <p id="vcl-variables">Variables provide read, write and delete access to almost all aspects of the work at hand.</p> <p>Reading a variable is done simply by using its name in VCL:</p> <pre data-language="python">if (client.ip ~ bad_guys) {
    return (synth(400));
}
</pre> <p>Writing a variable, where this is possible, is done with a <code>set</code> statement:</p> <pre data-language="python">set resp.http.never = "Let You Down";
</pre> <p>Similarly, deleting a variable, for the few variables where this is possible, is done with a <code>unset</code> statement:</p> <pre data-language="python">unset req.http.cookie;
</pre> <p>Which operations are possible on each variable is described below, often with the shorthand “backend” which covers the <code>vcl_backend_* {}</code> subroutines and “client” which covers the rest, except <code>vcl_init {}</code> and <code>vcl_fini {}</code>.</p> <p>When setting a variable, the right hand side of the equal sign must have the variables type, you cannot assign a STRING to a variable of type NUMBER, even if the string is <code>"42"</code>. (Explicit conversion functions can be found in <a class="reference internal" href="vmod_std#vmod-std-3"><span class="std std-ref">VMOD std - Varnish Standard Module</span></a>).</p>  <h5 id="local-server-remote-and-client">local, server, remote and client</h5> <p>These variables describe the network connection between the client and varnishd.</p> <p>Without PROXY protocol:</p> <pre data-language="python">     client    server
     remote    local
       v          v
CLIENT ------------ VARNISHD
</pre> <p>With PROXY protocol:</p> <pre data-language="python">     client    server   remote     local
       v          v       v          v
CLIENT ------------ PROXY ------------ VARNISHD
</pre> <p>local.ip</p>  <p>Type: IP</p> <p>Readable from: client, backend</p> <p>The IP address (and port number) of the local end of the TCP connection, for instance <code>192.168.1.1:81</code></p> <p>If the connection is a UNIX domain socket, the value will be <code>0.0.0.0:0</code></p>  <p>local.endpoint <code>VCL &gt;= 4.1</code></p>  <p>Type: STRING</p> <p>Readable from: client, backend</p> <p>The address of the ‘-a’ socket the session was accepted on.</p> <p>If the argument was <code>-a foo=:81</code> this would be “:81”</p>  <p>local.socket <code>VCL &gt;= 4.1</code></p>  <p>Type: STRING</p> <p>Readable from: client, backend</p> <p>The name of the ‘-a’ socket the session was accepted on.</p> <p>If the argument was <code>-a foo=:81</code> this would be “foo”.</p> <p>Note that all ‘-a’ gets a default name on the form <code>a%d</code> if no name is provided.</p>  <p>remote.ip</p>  <p>Type: IP</p> <p>Readable from: client, backend</p> <p>The IP address of the other end of the TCP connection. This can either be the clients IP, or the outgoing IP of a proxy server.</p> <p>If the connection is a UNIX domain socket, the value will be <code>0.0.0.0:0</code></p>  <p>client.ip</p>  <p>Type: IP</p> <p>Readable from: client, backend</p> <p>The client’s IP address, either the same as <code>remote.ip</code> or what the PROXY protocol told us.</p>  <p>client.identity</p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Identification of the client, used to load balance in the client director. Defaults to <code>client.ip</code></p> <p>This variable can be overwritten with more precise information, for instance extracted from a <code>Cookie:</code> header.</p>  <p>server.ip</p>  <p>Type: IP</p> <p>Readable from: client, backend</p> <p>The IP address of the socket on which the client connection was received, either the same as <code>server.ip</code> or what the PROXY protocol told us.</p>  <p>server.hostname</p>  <p>Type: STRING</p> <p>Readable from: all</p> <p>The host name of the server, as returned by the <code>gethostname(3)</code> system function.</p>  <p>server.identity</p>  <p>Type: STRING</p> <p>Readable from: all</p> <p>The identity of the server, as set by the <code>-i</code> parameter.</p> <p>If an <code>-i</code> parameter is not passed to varnishd, the return value from <code>gethostname(3)</code> system function will be used.</p>    <h5 id="req-and-req-top">req and req_top</h5> <p>These variables describe the present request, and when ESI:include requests are being processed, req_top points to the request received from the client.</p> <p>req</p>  <p>Type: HTTP</p> <p>Readable from: client</p> <p>The entire request HTTP data structure. Mostly useful for passing to VMODs.</p>  <p>req.method</p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>The request method (e.g. “GET”, “HEAD”, …)</p>  <p>req.hash</p>  <p>Type: BLOB</p> <p>Readable from: vcl_hit, vcl_miss, vcl_pass, vcl_purge, vcl_deliver</p> <p>The hash key of this request. Mostly useful for passing to VMODs, but can also be useful for debugging hit/miss status.</p>  <p>req.url</p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>The requested URL, for instance “/robots.txt”.</p>  <p>req.proto <code>VCL &lt;= 4.0</code></p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>The HTTP protocol version used by the client, usually “HTTP/1.1” or “HTTP/2.0”.</p>  <p>req.proto <code>VCL &gt;= 4.1</code></p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>The HTTP protocol version used by the client, usually “HTTP/1.1” or “HTTP/2.0”.</p>  <p>req.http.*</p>  <p>Type: HEADER</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Unsetable from: client</p> <p>The headers of request, things like <code>req.http.date</code>.</p> <p>The RFCs allow multiple headers with the same name, and both <code>set</code> and <code>unset</code> will remove <em>all</em> headers with the name given.</p>  <p>req.restarts</p>  <p>Type: INT</p> <p>Readable from: client</p> <p>A count of how many times this request has been restarted.</p>  <p>req.storage</p>  <p>Type: STEVEDORE</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>The storage backend to use to save this request body.</p>  <p>req.esi_level</p>  <p>Type: INT</p> <p>Readable from: client</p> <p>A count of how many levels of ESI requests we’re currently at.</p>  <p>req.ttl</p>  <p>Type: DURATION</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Upper limit on the object age for cache lookups to return hit.</p>  <p>req.grace</p>  <p>Type: DURATION</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Upper limit on the object grace.</p> <p>During lookup the minimum of req.grace and the object’s stored grace value will be used as the object’s grace.</p>  <p>req.xid</p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>Unique ID of this request.</p>  <p>req.esi <code>VCL &lt;= 4.0</code></p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Set to <code>false</code> to disable ESI processing regardless of any value in beresp.do_esi. Defaults to <code>true</code>. This variable is replaced by <code>resp.do_esi</code> in VCL 4.1.</p>  <p>req.can_gzip</p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>True if the client provided <code>gzip</code> or <code>x-gzip</code> in the <code>Accept-Encoding</code> header.</p>  <p>req.backend_hint</p>  <p>Type: BACKEND</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Set bereq.backend to this if we attempt to fetch. When set to a director, reading this variable returns an actual backend if the director has resolved immediately, or the director otherwise. When used in string context, returns the name of the director or backend, respectively.</p>  <p>req.hash_ignore_busy</p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Default: <code>false</code>.</p> <p>Ignore any busy object during cache lookup.</p> <p>You only want to do this when you have two server looking up content sideways from each other to avoid deadlocks.</p>  <p>req.hash_always_miss</p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Default: <code>false</code>.</p> <p>Force a cache miss for this request, even if perfectly good matching objects are in the cache.</p> <p>This is useful to force-update the cache without invalidating existing entries in case the fetch fails.</p>  <p>req.is_hitmiss</p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>If this request resulted in a hitmiss</p>  <p>req.is_hitpass</p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>If this request resulted in a hitpass</p>  <p>req_top.method</p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>The request method of the top-level request in a tree of ESI requests. (e.g. “GET”, “HEAD”). Identical to req.method in non-ESI requests.</p>  <p>req_top.url</p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>The requested URL of the top-level request in a tree of ESI requests. Identical to req.url in non-ESI requests.</p>  <p>req_top.http.*</p>  <p>Type: HEADER</p> <p>Readable from: client</p> <p>HTTP headers of the top-level request in a tree of ESI requests. Identical to req.http. in non-ESI requests.</p>  <p>req_top.proto</p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>HTTP protocol version of the top-level request in a tree of ESI requests. Identical to req.proto in non-ESI requests.</p>    <h5 id="bereq">bereq</h5> <p>This is the request we send to the backend, it is built from the clients <code>req.*</code> fields by filtering out “per-hop” fields which should not be passed along (<code>Connection:</code>, <code>Range:</code> and similar).</p> <p>Slightly more fields are allowed through for <code>pass` fetches
than for `miss` fetches, for instance ``Range</code>.</p> <p>bereq</p>  <p>Type: HTTP</p> <p>Readable from: backend</p> <p>The entire backend request HTTP data structure. Mostly useful as argument to VMODs.</p>  <p>bereq.xid</p>  <p>Type: STRING</p> <p>Readable from: backend</p> <p>Unique ID of this request.</p>  <p>bereq.retries</p>  <p>Type: INT</p> <p>Readable from: backend</p> <p>A count of how many times this request has been retried.</p>  <p>bereq.backend</p>  <p>Type: BACKEND</p> <p>Readable from: vcl_pipe, backend</p> <p>Writable from: vcl_pipe, backend</p> <p>This is the backend or director we attempt to fetch from. When set to a director, reading this variable returns an actual backend if the director has resolved immediately, or the director otherwise. When used in string context, returns the name of the director or backend, respectively.</p>  <p>bereq.body</p>  <p>Type: BODY</p> <p>Unsetable from: vcl_backend_fetch</p> <p>The request body.</p> <p>Unset will also remove <code>bereq.http.Content-Length</code>.</p>  <p>bereq.hash</p>  <p>Type: BLOB</p> <p>Readable from: vcl_pipe, backend</p> <p>The hash key of this request, a copy of <code>req.hash</code>.</p>  <p>bereq.method</p>  <p>Type: STRING</p> <p>Readable from: vcl_pipe, backend</p> <p>Writable from: vcl_pipe, backend</p> <p>The request type (e.g. “GET”, “HEAD”).</p> <p>Regular (non-pipe, non-pass) fetches are always “GET”</p>  <p>bereq.url</p>  <p>Type: STRING</p> <p>Readable from: vcl_pipe, backend</p> <p>Writable from: vcl_pipe, backend</p> <p>The requested URL, copied from <code>req.url</code></p>  <p>bereq.proto <code>VCL &lt;= 4.0</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_pipe, backend</p> <p>Writable from: vcl_pipe, backend</p> <p>The HTTP protocol version, “HTTP/1.1” unless a pass or pipe request has “HTTP/1.0” in <code>req.proto</code></p>  <p>bereq.proto <code>VCL &gt;= 4.1</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_pipe, backend</p> <p>The HTTP protocol version, “HTTP/1.1” unless a pass or pipe request has “HTTP/1.0” in <code>req.proto</code></p>  <p>bereq.http.*</p>  <p>Type: HEADER</p> <p>Readable from: vcl_pipe, backend</p> <p>Writable from: vcl_pipe, backend</p> <p>Unsetable from: vcl_pipe, backend</p> <p>The headers to be sent to the backend.</p>  <p>bereq.uncacheable</p>  <p>Type: BOOL</p> <p>Readable from: backend</p> <p>Indicates whether this request is uncacheable due to a <code>pass</code> in the client side or a hit on an hit-for-pass object.</p>  <p>bereq.connect_timeout</p>  <p>Type: DURATION</p> <p>Readable from: vcl_pipe, backend</p> <p>Writable from: vcl_pipe, backend</p> <p>Default: <code>.connect_timeout</code> attribute from the <a class="reference internal" href="#backend-definition"><span class="std std-ref">Backend definition</span></a>, which defaults to the <code>connect_timeout</code> parameter, see <a class="reference internal" href="varnishd#varnishd-1"><span class="std std-ref">varnishd</span></a>.</p> <p>The time in seconds to wait for a backend connection to be established.</p>  <p>bereq.first_byte_timeout</p>  <p>Type: DURATION</p> <p>Readable from: backend</p> <p>Writable from: backend</p> <p>Default: <code>.first_byte_timeout</code> attribute from the <a class="reference internal" href="#backend-definition"><span class="std std-ref">Backend definition</span></a>, which defaults to the <code>first_byte_timeout</code> parameter, see <a class="reference internal" href="varnishd#varnishd-1"><span class="std std-ref">varnishd</span></a>.</p> <p>The time in seconds to wait getting the first byte back from the backend. Not available in pipe mode.</p>  <p>bereq.between_bytes_timeout</p>  <p>Type: DURATION</p> <p>Readable from: backend</p> <p>Writable from: backend</p> <p>Default: <code>.between_bytes_timeout</code> attribute from the <a class="reference internal" href="#backend-definition"><span class="std std-ref">Backend definition</span></a>, which defaults to the <code>between_bytes_timeout</code> parameter, see <a class="reference internal" href="varnishd#varnishd-1"><span class="std std-ref">varnishd</span></a>.</p> <p>The time in seconds to wait between each received byte from the backend. Not available in pipe mode.</p>  <p>bereq.is_bgfetch</p>  <p>Type: BOOL</p> <p>Readable from: backend</p> <p>True for fetches where the client got a hit on an object in grace, and this fetch was kicked of in the background to get a fresh copy.</p>    <h5 id="beresp">beresp</h5> <p>The response received from the backend, one cache misses, the store object is built from <code>beresp</code>.</p> <p>beresp</p>  <p>Type: HTTP</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>The entire backend response HTTP data structure, useful as argument to VMOD functions.</p>  <p>beresp.body</p>  <p>Type: BODY</p> <p>Writable from: vcl_backend_error</p> <p>For producing a synthetic body.</p>  <p>beresp.proto <code>VCL &lt;= 4.0</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>The HTTP protocol version the backend replied with.</p>  <p>beresp.proto <code>VCL &gt;= 4.1</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>The HTTP protocol version the backend replied with.</p>  <p>beresp.status</p>  <p>Type: INT</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>The HTTP status code returned by the server.</p> <p>More information in the <a class="reference internal" href="#http-response-status">HTTP response status</a> section.</p>  <p>beresp.reason</p>  <p>Type: STRING</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>The HTTP status message returned by the server.</p>  <p>beresp.http.*</p>  <p>Type: HEADER</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Unsetable from: vcl_backend_response, vcl_backend_error</p> <p>The HTTP headers returned from the server.</p>  <p>beresp.do_esi</p>  <p>Type: BOOL</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: <code>false</code>.</p> <p>Set it to true to parse the object for ESI directives. Will only be honored if req.esi is true.</p> <p>It is a VCL error to use beresp.do_esi after setting beresp.filters.</p>  <p>beresp.do_stream</p>  <p>Type: BOOL</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: <code>true</code>.</p> <p>Deliver the object to the client while fetching the whole object into varnish.</p> <p>For uncacheable objects, storage for parts of the body which have been sent to the client may get freed early, depending on the storage engine used.</p> <p>This variable has no effect if do_esi is true or when the response body is empty.</p>  <p>beresp.do_gzip</p>  <p>Type: BOOL</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: <code>false</code>.</p> <p>Set to <code>true</code> to gzip the object while storing it.</p> <p>If <code>http_gzip_support</code> is disabled, setting this variable has no effect.</p> <p>It is a VCL error to use beresp.do_gzip after setting beresp.filters.</p>  <p>beresp.do_gunzip</p>  <p>Type: BOOL</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: <code>false</code>.</p> <p>Set to <code>true</code> to gunzip the object while storing it in the cache.</p> <p>If <code>http_gzip_support</code> is disabled, setting this variable has no effect.</p> <p>It is a VCL error to use beresp.do_gunzip after setting beresp.filters.</p>  <p>beresp.was_304</p>  <p>Type: BOOL</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>When <code>true</code> this indicates that we got a 304 response to our conditional fetch from the backend and turned that into <code>beresp.status = 200</code></p>  <p>beresp.uncacheable</p>  <p>Type: BOOL</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Inherited from bereq.uncacheable, see there.</p> <p>Setting this variable makes the object uncacheable.</p> <p>This may may produce a hit-for-miss object in the cache.</p> <p>Clearing the variable has no effect and will log the warning “Ignoring attempt to reset beresp.uncacheable”.</p>  <p>beresp.ttl</p>  <p>Type: DURATION</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: Cache-Control <code>s-maxage</code> or <code>max-age</code> directives, or a value computed from the Expires header’s deadline, or the <code>default_ttl</code> parameter.</p> <p>The object’s remaining time to live, in seconds.</p>  <p>beresp.age</p>  <p>Type: DURATION</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Default: Age header, or zero.</p> <p>The age of the object.</p>  <p>beresp.grace</p>  <p>Type: DURATION</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: Cache-Control <code>stale-while-revalidate</code> directive, or <code>default_grace</code> parameter.</p> <p>Set to a period to enable grace.</p>  <p>beresp.keep</p>  <p>Type: DURATION</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: <code>default_keep</code> parameter.</p> <p>Set to a period to enable conditional backend requests.</p> <p>The keep time is cache lifetime in addition to the ttl.</p> <p>Objects with ttl expired but with keep time left may be used to issue conditional (If-Modified-Since / If-None-Match) requests to the backend to refresh them.</p>  <p>beresp.backend</p>  <p>Type: BACKEND</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>This is the backend we fetched from. If bereq.backend was set to a director, this will be the backend selected by the director. When used in string context, returns its name.</p>  <p>beresp.backend.name</p>  <p>Type: STRING</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Name of the backend this response was fetched from. Same as beresp.backend.</p>  <p>beresp.backend.ip <code>VCL &lt;= 4.0</code></p>  <p>Type: IP</p> <p>Readable from: vcl_backend_response</p> <p>IP of the backend this response was fetched from.</p>  <p>beresp.storage</p>  <p>Type: STEVEDORE</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>The storage backend to use to save this object.</p>  <p>beresp.storage_hint <code>VCL &lt;= 4.0</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Deprecated since varnish 5.1 and discontinued since VCL 4.1 (varnish 6.0). Use beresp.storage instead.</p> <p>Hint to Varnish that you want to save this object to a particular storage backend.</p>  <p>beresp.filters</p>  <p>Type: STRING</p> <p>Readable from: vcl_backend_response</p> <p>Writable from: vcl_backend_response</p> <p>List of Varnish Fetch Processor (VFP) filters the beresp.body will be pulled through. The order left to right signifies processing from backend to cache, iow the leftmost filter is run first on the body as received from the backend after decoding of any transfer encodings.</p> <p>VFP Filters change the body before going into the cache and/or being handed to the client side, where it may get processed again by resp.filters.</p> <p>The following VFP filters exist in varnish-cache:</p> <ul> <li>
<code>gzip</code>: compress a body using gzip</li> <li>
<code>testgunzip</code>: Test if a body is valid gzip and refuse it otherwise</li> <li>
<code>gunzip</code>: Uncompress gzip content</li> <li>
<code>esi</code>: ESI-process plain text content</li> <li>
<p><code>esi_gzip</code>: Save gzipped snippets for efficient ESI-processing</p> <p>This filter enables stitching together ESI from individually gzipped fragments, saving processing power for re-compression on the client side at the expense of some compression efficiency.</p> </li> </ul> <p>Additional VFP filters are available from VMODs.</p> <p>By default, beresp.filters is constructed as follows:</p> <ul class="simple"> <li>
<code>gunzip</code> gets added for gzipped content if <code>beresp.do_gunzip</code> or <code>beresp.do_esi</code> are true.</li> <li>
<code>esi_gzip</code> gets added if <code>beresp.do_esi</code> is true together with <code>beresp.do_gzip</code> or content is already compressed.</li> <li>
<code>esi</code> gets added if <code>beresp.do_esi</code> is true</li> <li>
<code>gzip</code> gets added for uncompressed content if <code>beresp.do_gzip</code> is true</li> <li>
<code>testgunzip</code> gets added for compressed content if <code>beresp.do_gunzip</code> is false.</li> </ul> <p>After beresp.filters is set, using any of the beforementioned <code>beresp.do_*</code> switches is a VCL error.</p>    <h5 id="obj">obj</h5> <p>This is the object we found in cache. It cannot be modified.</p> <p>obj.proto</p>  <p>Type: STRING</p> <p>Readable from: vcl_hit</p> <p>The HTTP protocol version stored in the object.</p>  <p>obj.status</p>  <p>Type: INT</p> <p>Readable from: vcl_hit</p> <p>The HTTP status code stored in the object.</p> <p>More information in the <a class="reference internal" href="#http-response-status">HTTP response status</a> section.</p>  <p>obj.reason</p>  <p>Type: STRING</p> <p>Readable from: vcl_hit</p> <p>The HTTP reason phrase stored in the object.</p>  <p>obj.hits</p>  <p>Type: INT</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>The count of cache-hits on this object.</p> <p>In <code>vcl_deliver</code> a value of 0 indicates a cache miss.</p>  <p>obj.http.*</p>  <p>Type: HEADER</p> <p>Readable from: vcl_hit</p> <p>The HTTP headers stored in the object.</p>  <p>obj.ttl</p>  <p>Type: DURATION</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>The object’s remaining time to live, in seconds.</p>  <p>obj.age</p>  <p>Type: DURATION</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>The age of the object.</p>  <p>obj.grace</p>  <p>Type: DURATION</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>The object’s grace period in seconds.</p>  <p>obj.keep</p>  <p>Type: DURATION</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>The object’s keep period in seconds.</p>  <p>obj.uncacheable</p>  <p>Type: BOOL</p> <p>Readable from: vcl_deliver</p> <p>Whether the object is uncacheable (pass, hit-for-pass or hit-for-miss).</p>  <p>obj.storage</p>  <p>Type: STEVEDORE</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>The storage backend where this object is stored.</p>  <p>obj.can_esi</p>  <p>Type: BOOL</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>If the object can be ESI processed, that is if setting <code>resp.do_esi</code> or adding <code>esi</code> to <code>resp.filters</code> in <code>vcl_deliver {}</code> would cause the response body to be ESI processed.</p>    <h5 id="resp">resp</h5> <p>This is the response we send to the client, it is built from either <code>beresp</code> (pass/miss), <code>obj</code> (hits) or created from whole cloth (synth).</p> <p>With the exception of <code>resp.body</code> all <code>resp.*</code> variables available in both <code>vcl_deliver{}</code> and <code>vcl_synth{}</code> as a matter of symmetry.</p> <p>resp</p>  <p>Type: HTTP</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>The entire response HTTP data structure, useful as argument to VMODs.</p>  <p>resp.body</p>  <p>Type: BODY</p> <p>Writable from: vcl_synth</p> <p>To produce a synthetic response body, for instance for errors.</p>  <p>resp.proto <code>VCL &lt;= 4.0</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Writable from: vcl_deliver, vcl_synth</p> <p>The HTTP protocol version to use for the response.</p>  <p>resp.proto <code>VCL &gt;= 4.1</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Writable from: vcl_deliver, vcl_synth</p> <p>The HTTP protocol version to use for the response.</p>  <p>resp.status</p>  <p>Type: INT</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Writable from: vcl_deliver, vcl_synth</p> <p>The HTTP status code that will be returned.</p> <p>More information in the <a class="reference internal" href="#http-response-status">HTTP response status</a> section.</p> <p>resp.status 200 will get changed into 304 by core code after a return(deliver) from vcl_deliver for conditional requests to cached content if validation succeeds.</p> <p>For the validation, first <code>req.http.If-None-Match</code> is compared against <code>resp.http.Etag</code>. If they compare equal according to the rules for weak validation (see RFC7232), a 304 is sent.</p> <p>Secondly, <code>req.http.If-Modified-Since</code> is compared against <code>resp.http.Last-Modified</code> or, if it is unset, against the point in time when the object was last modified based on the <code>Date</code> and <code>Age</code> headers received with the backend response which created the object. If the object has not been modified based on that comparison, a 304 is sent.</p>  <p>resp.reason</p>  <p>Type: STRING</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Writable from: vcl_deliver, vcl_synth</p> <p>The HTTP status message that will be returned.</p>  <p>resp.http.*</p>  <p>Type: HEADER</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Writable from: vcl_deliver, vcl_synth</p> <p>Unsetable from: vcl_deliver, vcl_synth</p> <p>The HTTP headers that will be returned.</p>  <p>resp.do_esi <code>VCL &gt;= 4.1</code></p>  <p>Type: BOOL</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Writable from: vcl_deliver, vcl_synth</p> <p>Default: obj.can_esi</p> <p>This can be used to selectively disable ESI processing, even though ESI parsing happened during fetch. This is useful when Varnish caches peer with each other.</p> <p>It is a VCL error to use resp.do_esi after setting resp.filters.</p>  <p>resp.is_streaming</p>  <p>Type: BOOL</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Returns true when the response will be streamed while being fetched from the backend.</p>  <p>resp.filters</p>  <p>Type: STRING</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Writable from: vcl_deliver, vcl_synth</p> <p>List of VDP filters the resp.body will be pushed through.</p> <p>Before resp.filters is set, the value read will be the default filter list as determined by varnish based on resp.do_esi and request headers.</p> <p>After resp.filters is set, changing any of the conditions which otherwise determine the filter selection will have no effiect. Using resp.do_esi is an error once resp.filters is set.</p>    <h5 id="special-variables">Special variables</h5> <p>now</p>  <p>Type: TIME</p> <p>Readable from: all</p> <p>The current time, in seconds since the UNIX epoch.</p> <p>When converted to STRING in expressions it returns a formatted timestamp like <code>Tue, 20 Feb 2018 09:30:31 GMT</code></p>    <h5 id="sess">sess</h5> <p>A session corresponds to the “conversation” that Varnish has with a single client connection, over which one or more request/response transactions may take place. It may comprise the traffic over an HTTP/1 keep-alive connection, or the multiplexed traffic over an HTTP/2 connection.</p> <p>sess.xid <code>VCL &gt;= 4.1</code></p>  <p>Type: STRING</p> <p>Readable from: client, backend</p> <p>Unique ID of this session.</p>  <p>sess.timeout_idle</p>  <p>Type: DURATION</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Idle timeout for this session, defaults to the <code>timeout_idle</code> parameter, see <a class="reference internal" href="varnishd#varnishd-1"><span class="std std-ref">varnishd</span></a></p>  <p>sess.timeout_linger</p>  <p>Type: DURATION</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Linger timeout for this session, defaults to the <code>timeout_linger</code> parameter, see <a class="reference internal" href="varnishd#varnishd-1"><span class="std std-ref">varnishd</span></a></p>  <p>sess.send_timeout</p>  <p>Type: DURATION</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Total timeout for ordinary HTTP1 responses, defaults to the <code>send_timeout</code> parameter, see <a class="reference internal" href="varnishd#varnishd-1"><span class="std std-ref">varnishd</span></a></p>  <p>sess.idle_send_timeout</p>  <p>Type: DURATION</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Send timeout for individual pieces of data on client connections, defaults to the <code>idle_send_timeout</code> parameter, see <a class="reference internal" href="varnishd#varnishd-1"><span class="std std-ref">varnishd</span></a></p>    <h5 id="storage">storage</h5> <p>storage.&lt;name&gt;.free_space</p>  <p>Type: BYTES</p> <p>Readable from: client, backend</p> <p>Free space available in the named stevedore. Only available for the malloc stevedore.</p>  <p>storage.&lt;name&gt;.used_space</p>  <p>Type: BYTES</p> <p>Readable from: client, backend</p> <p>Used space in the named stevedore. Only available for the malloc stevedore.</p>  <p>storage.&lt;name&gt;.happy</p>  <p>Type: BOOL</p> <p>Readable from: client, backend</p> <p>Health status for the named stevedore. Not available in any of the current stevedores.</p>     <h4 id="http-response-status">HTTP response status</h4> <p>A status code normally has 3 digits XYZ where X must be between 1 and 5 included. Since it is not uncommon to see HTTP clients or servers relying on non-standard or even invalid status codes Varnish tolerates any status between 100 and 999.</p> <p>With VCL code it is possible to use status codes in the form XXYZZ where the overall value is lower than 65536 and the Y digit is between 1 and 9 included. Only the YZZ part is sent to the client.</p> <p>The XXYZZ form of status codes can be set on <code>resp.status</code> and <code>beresp.status</code> or passed via <code>return(synth(...))</code> and <code>return(error(...))</code> transitions.</p> <p>XX can be therefore be used to pass information around inside VCL, for instance <code>return(synth(22404))</code> from <code>vcl_recv{}</code> to <code>vcl_synth{}</code>.</p> <p>The <code>obj.status</code> variable will inherit the XXYZZ form, but in a ban expresion only the YZZ part will be available. The XXYZZ form is strictly limited to VCL execution.</p> <p>Assigning an HTTP standardized code to <code>resp.status</code> or <code>beresp.status</code> will also set <code>resp.reason</code> or <code>beresp.reason</code> to the corresponding status message.</p>   <h4 id="functions">Functions</h4> <p>The following built-in functions are available:</p>  <h5 id="vcl-7-ban">ban(STRING)</h5>  <p>Invalidates all objects in cache that match the given expression with the ban mechanism.</p> <p>The format of <em>STRING</em> is:</p> <pre data-language="python">&lt;field&gt; &lt;operator&gt; &lt;arg&gt; [&amp;&amp; &lt;field&gt; &lt;oper&gt; &lt;arg&gt; ...]
</pre> <ul> <li>
<p><em>&lt;field&gt;</em>:</p> <ul> <li>
<p>string fields:</p> <ul class="simple"> <li>
<code>req.url</code>: The request url</li> <li>
<code>req.http.*</code>: Any request header</li> <li>
<code>obj.status</code>: The cache object status</li> <li>
<code>obj.http.*</code>: Any cache object header</li> </ul> <p><code>obj.status</code> is treated as a string despite the fact that it is actually an integer.</p> </li> <li>
<p>duration fields:</p> <ul class="simple"> <li>
<code>obj.ttl</code>: Remaining ttl at the time the ban is issued</li> <li>
<code>obj.age</code>: Object age at the time the ban is issued</li> <li>
<code>obj.grace</code>: The grace time of the object</li> <li>
<code>obj.keep</code>: The keep time of the object</li> </ul> </li> </ul> </li> <li>
<p><em>&lt;operator&gt;</em>:</p> <ul> <li>
<p>for all fields:</p> <ul class="simple"> <li>
<code>==</code>: <em>&lt;field&gt;</em> and <em>&lt;arg&gt;</em> are equal</li> <li>
<code>!=</code>: <em>&lt;field&gt;</em> and <em>&lt;arg&gt;</em> are unequal</li> </ul> <p>strings are compared case sensitively</p> </li> <li>
<p>for string fields:</p> <ul class="simple"> <li>
<code>~</code>: <em>&lt;field&gt;</em> matches the regular expression <em>&lt;arg&gt;</em>
</li> <li>
<code>!~</code>:<em>&lt;field&gt;</em> does not match the regular expression <em>&lt;arg&gt;</em>
</li> </ul> </li> <li>
<p>for duration fields:</p> <ul class="simple"> <li>
<code>&gt;</code>: <em>&lt;field&gt;</em> is greater than <em>&lt;arg&gt;</em>
</li> <li>
<code>&gt;=</code>: <em>&lt;field&gt;</em> is greater than or equal to <em>&lt;arg&gt;</em>
</li> <li>
<code>&lt;</code>: <em>&lt;field&gt;</em> is less than <em>&lt;arg&gt;</em>
</li> <li>
<code>&lt;=</code>: <em>&lt;field&gt;</em> is less than or equal to <em>&lt;arg&gt;</em>
</li> </ul> </li> </ul> </li> <li>
<p><em>&lt;arg&gt;</em>:</p> <ul> <li>
<p>for string fields:</p> <p>Either a literal string or a regular expression. Note that <em>&lt;arg&gt;</em> does not use any of the string delimiters like <code>"</code> or <code>{"</code><em>…</em><code>"}</code> used elsewhere in varnish. To match against strings containing whitespace, regular expressions containing <code>\s</code> can be used.</p> </li> <li>
<p>for duration fields:</p> <p>A VCL duration like <code>10s</code>, <code>5m</code> or <code>1h</code>, see <a class="reference internal" href="#durations">Durations</a></p> </li> </ul> </li> </ul> <p>Expressions can be chained using the <em>and</em> operator <code>&amp;&amp;</code>. For <em>or</em> semantics, use several bans.</p> <p>The unset <em>&lt;field&gt;</em> is not equal to any string, such that, for a non-existing header, the operators <code>==</code> and <code>~</code> always evaluate as false, while the operators <code>!=</code> and <code>!~</code> always evaluate as true, respectively, for any value of <em>&lt;arg&gt;</em>.</p>    <h5 id="hash-data-input">hash_data(input)</h5>  <p>Adds an input to the hash input. In the built-in VCL <code>hash_data()</code> is called on the host and URL of the request. Available in <code>vcl_hash</code>.</p>    <h5 id="synthetic-string">synthetic(STRING)</h5>  <p>Prepare a synthetic response body containing the <em>STRING</em>. Available in <code>vcl_synth</code> and <code>vcl_backend_error</code>.</p> <p>Identical to <code>set resp.body</code> / <code>set beresp.body</code>.</p>    <h5 id="regsub-str-regex-sub">regsub(str, regex, sub)</h5>  <p>Returns a copy of <em>str</em> with the first occurrence of the regular expression <em>regex</em> replaced with <em>sub</em>. Within <em>sub</em>, <code>\0</code> (which can also be spelled <code>\&amp;</code>) is replaced with the entire matched string, and <code>\</code><em>n</em> is replaced with the contents of subgroup <em>n</em> in the matched string.</p>    <h5 id="regsuball-str-regex-sub">regsuball(str, regex, sub)</h5>  <p>As <code>regsub()</code>, but this replaces all occurrences.</p>  <p>For converting or casting VCL values between data types use the functions available in the std VMOD.</p>     <h3 id="versioning">Versioning</h3> <p>Multiple versions of the VCL syntax can coexist within certain constraints.</p> <p>The VCL syntax version at the start of VCL file specified with <code>-f</code> sets the hard limit that cannot be exceeded anywhere, and it selects the appropriate version of the builtin VCL.</p> <p>That means that you can never include <code>vcl 9.1;</code> from <code>vcl 8.7;</code>, but the opposite <em>may</em> be possible, to the extent the compiler supports it.</p> <p>Files pulled in via <code>include</code> do not need to have a <code>vcl</code> <em>X.Y</em><code>;</code> but it may be a good idea to do it anyway, to not have surprises in the future. The syntax version set in an included file only applies to that file and any files it includes - unless these set their own VCL syntax version.</p> <p>The version of Varnish this file belongs to supports syntax 4.0 and 4.1.</p>   <h3 id="examples">EXAMPLES</h3> <p>For examples, please see the online documentation.</p>   <h3 id="see-also">SEE ALSO</h3> <ul class="simple"> <li><a class="reference internal" href="varnishd#varnishd-1"><span class="std std-ref">varnishd</span></a></li> <li><a class="reference internal" href="vmod_directors#vmod-directors-3"><span class="std std-ref">VMOD directors - Varnish Directors Module</span></a></li> <li><a class="reference internal" href="vmod_std#vmod-std-3"><span class="std std-ref">VMOD std - Varnish Standard Module</span></a></li> </ul>   <h3 id="history">HISTORY</h3> <p>VCL was developed by Poul-Henning Kamp in cooperation with Verdens Gang AS, Redpill Linpro and Varnish Software. This manual page is written by Per Buer, Poul-Henning Kamp, Martin Blix Grydeland, Kristian Lyngstøl, Lasse Karstensen and possibly others.</p>   <h3 id="copyright">COPYRIGHT</h3> <p>This document is licensed under the same license as Varnish itself. See LICENSE for details.</p> <ul class="simple"> <li>Copyright (c) 2006 Verdens Gang AS</li> <li>Copyright (c) 2006-2015 Varnish Software AS</li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    Copyright © 2006 Verdens Gang AS<br>Copyright © 2006–2020 Varnish Software AS<br>Licensed under the BSD-2-Clause License.<br>
    <a href="https://varnish-cache.org/docs/6.5/reference/vcl.html" class="_attribution-link">https://varnish-cache.org/docs/6.5/reference/vcl.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
