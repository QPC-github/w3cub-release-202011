
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>decomposition.IncrementalPCA() - Scikit-learn - W3cubDocs</title>
  
  <meta name="description" content=" Incremental principal components analysis (IPCA). ">
  <meta name="keywords" content="sklearn, decomposition, incrementalpca, scikit-learn, scikit_learn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/scikit_learn/modules/generated/sklearn.decomposition.incrementalpca.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/scikit_learn.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_learn/" class="_nav-link" title="" style="margin-left:0;">scikit-learn</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="sklearn-decomposition-incrementalpca">sklearn.decomposition.IncrementalPCA</h1> <dl class="class"> <dt id="sklearn.decomposition.IncrementalPCA">
<code>class sklearn.decomposition.IncrementalPCA(n_components=None, whiten=False, copy=True, batch_size=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/decomposition/incremental_pca.py#L16"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Incremental principal components analysis (IPCA).</p> <p>Linear dimensionality reduction using Singular Value Decomposition of centered data, keeping only the most significant singular vectors to project the data to a lower dimensional space.</p> <p>Depending on the size of the input data, this algorithm can be much more memory efficient than a PCA.</p> <p>This algorithm has constant memory complexity, on the order of <code>batch_size</code>, enabling use of np.memmap files without loading the entire file into memory.</p> <p>The computational overhead of each SVD is <code>O(batch_size * n_features ** 2)</code>, but only 2 * batch_size samples remain in memory at a time. There will be <code>n_samples / batch_size</code> SVD computations to get the principal components, versus 1 large SVD of complexity <code>O(n_samples * n_features ** 2)</code> for PCA.</p> <p>Read more in the <a class="reference internal" href="../decomposition#incrementalpca"><span class="std std-ref">User Guide</span></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>n_components : int or None, (default=None)</code> </dt> <dd>
<p class="first last">Number of components to keep. If <code>n_components `` is ``None</code>, then <code>n_components</code> is set to <code>min(n_samples, n_features)</code>.</p> </dd> <dt>
<code>whiten : bool, optional</code> </dt> <dd>
<p class="first">When True (False by default) the <code>components_</code> vectors are divided by <code>n_samples</code> times <code>components_</code> to ensure uncorrelated outputs with unit component-wise variances.</p> <p class="last">Whitening will remove some information from the transformed signal (the relative variance scales of the components) but can sometimes improve the predictive accuracy of the downstream estimators by making data respect some hard-wired assumptions.</p> </dd> <dt>
<code>copy : bool, (default=True)</code> </dt> <dd>
<p class="first last">If False, X will be overwritten. <code>copy=False</code> can be used to save memory but is unsafe for general use.</p> </dd> <dt>
<code>batch_size : int or None, (default=None)</code> </dt> <dd>
<p class="first last">The number of samples to use for each batch. Only used when calling <code>fit</code>. If <code>batch_size</code> is <code>None</code>, then <code>batch_size</code> is inferred from the data and set to <code>5 * n_features</code>, to provide a balance between approximation accuracy and memory consumption.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>components_ : array, shape (n_components, n_features)</code> </dt> <dd>
<p class="first last">Components with maximum variance.</p> </dd> <dt>
<code>explained_variance_ : array, shape (n_components,)</code> </dt> <dd>
<p class="first last">Variance explained by each of the selected components.</p> </dd> <dt>
<code>explained_variance_ratio_ : array, shape (n_components,)</code> </dt> <dd>
<p class="first last">Percentage of variance explained by each of the selected components. If all components are stored, the sum of explained variances is equal to 1.0.</p> </dd> <dt>
<code>singular_values_ : array, shape (n_components,)</code> </dt> <dd>
<p class="first last">The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the <code>n_components</code> variables in the lower-dimensional space.</p> </dd> <dt>
<code>mean_ : array, shape (n_features,)</code> </dt> <dd>
<p class="first last">Per-feature empirical mean, aggregate over calls to <code>partial_fit</code>.</p> </dd> <dt>
<code>var_ : array, shape (n_features,)</code> </dt> <dd>
<p class="first last">Per-feature empirical variance, aggregate over calls to <code>partial_fit</code>.</p> </dd> <dt>
<code>noise_variance_ : float</code> </dt> <dd>
<p class="first last">The estimated noise covariance following the Probabilistic PCA model from Tipping and Bishop 1999. See “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or <a class="reference external" href="http://www.miketipping.com/papers/met-mppca.pdf">http://www.miketipping.com/papers/met-mppca.pdf</a>.</p> </dd> <dt>
<code>n_components_ : int</code> </dt> <dd>
<p class="first last">The estimated number of components. Relevant when <code>n_components=None</code>.</p> </dd> <dt>
<code>n_samples_seen_ : int</code> </dt> <dd>
<p class="first last">The number of samples processed by the estimator. Will be reset on new calls to fit, but increments across <code>partial_fit</code> calls.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="sklearn.decomposition.pca#sklearn.decomposition.PCA" title="sklearn.decomposition.PCA"><code>PCA</code></a>, <a class="reference internal" href="sklearn.decomposition.kernelpca#sklearn.decomposition.KernelPCA" title="sklearn.decomposition.KernelPCA"><code>KernelPCA</code></a>, <a class="reference internal" href="sklearn.decomposition.sparsepca#sklearn.decomposition.SparsePCA" title="sklearn.decomposition.SparsePCA"><code>SparsePCA</code></a>, <a class="reference internal" href="sklearn.decomposition.truncatedsvd#sklearn.decomposition.TruncatedSVD" title="sklearn.decomposition.TruncatedSVD"><code>TruncatedSVD</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>Implements the incremental PCA model from: <code>D. Ross, J. Lim, R. Lin, M. Yang, Incremental Learning for Robust Visual Tracking, International Journal of Computer Vision, Volume 77, Issue 1-3, pp. 125-141, May 2008.</code> See <a class="reference external" href="http://www.cs.toronto.edu/~dross/ivt/RossLimLinYang_ijcv.pdf">http://www.cs.toronto.edu/~dross/ivt/RossLimLinYang_ijcv.pdf</a></p> <p>This model is an extension of the Sequential Karhunen-Loeve Transform from: <code>A. Levy and M. Lindenbaum, Sequential Karhunen-Loeve Basis Extraction and its Application to Images, IEEE Transactions on Image Processing, Volume 9, Number 8, pp. 1371-1374, August 2000.</code> See <a class="reference external" href="http://www.cs.technion.ac.il/~mic/doc/skl-ip.pdf">http://www.cs.technion.ac.il/~mic/doc/skl-ip.pdf</a></p> <p>We have specifically abstained from an optimization used by authors of both papers, a QR decomposition used in specific situations to reduce the algorithmic complexity of the SVD. The source for this technique is <code>Matrix Computations, Third Edition, G. Holub and C. Van Loan, Chapter 5, section 5.4.4, pp 252-253.</code>. This technique has been omitted because it is advantageous only when decomposing a matrix with <code>n_samples</code> (rows) &gt;= 5/3 * <code>n_features</code> (columns), and hurts the readability of the implemented algorithm. This would be a good opportunity for future optimization, if it is deemed necessary.</p> <h4 class="rubric">References</h4> <ol class="upperalpha simple" start="4"> <li>
<dl class="first docutils"> <dt>Ross, J. Lim, R. Lin, M. Yang. Incremental Learning for Robust Visual</dt> <dd>Tracking, International Journal of Computer Vision, Volume 77, Issue 1-3, pp. 125-141, May 2008.</dd> </dl> </li> </ol> <ol class="upperalpha simple" start="7"> <li>
<dl class="first docutils"> <dt>Golub and C. Van Loan. Matrix Computations, Third Edition, Chapter 5,</dt> <dd>Section 5.4.4, pp. 252-253.</dd> </dl> </li> </ol> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import load_digits
&gt;&gt;&gt; from sklearn.decomposition import IncrementalPCA
&gt;&gt;&gt; X, _ = load_digits(return_X_y=True)
&gt;&gt;&gt; transformer = IncrementalPCA(n_components=7, batch_size=200)
&gt;&gt;&gt; # either partially fit on smaller batches of data
&gt;&gt;&gt; transformer.partial_fit(X[:100, :])
IncrementalPCA(batch_size=200, copy=True, n_components=7, whiten=False)
&gt;&gt;&gt; # or let the fit function itself divide the data into batches
&gt;&gt;&gt; X_transformed = transformer.fit_transform(X)
&gt;&gt;&gt; X_transformed.shape
(1797, 7)
</pre> <h4 class="rubric">Methods</h4> <table class="longtable docutils">   <tr>
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.fit" title="sklearn.decomposition.IncrementalPCA.fit"><code>fit</code></a>(X[, y])</td> <td>Fit the model with X, using minibatches of size batch_size.</td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.fit_transform" title="sklearn.decomposition.IncrementalPCA.fit_transform"><code>fit_transform</code></a>(X[, y])</td> <td>Fit to data, then transform it.</td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.get_covariance" title="sklearn.decomposition.IncrementalPCA.get_covariance"><code>get_covariance</code></a>()</td> <td>Compute data covariance with the generative model.</td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.get_params" title="sklearn.decomposition.IncrementalPCA.get_params"><code>get_params</code></a>([deep])</td> <td>Get parameters for this estimator.</td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.get_precision" title="sklearn.decomposition.IncrementalPCA.get_precision"><code>get_precision</code></a>()</td> <td>Compute data precision matrix with the generative model.</td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.inverse_transform" title="sklearn.decomposition.IncrementalPCA.inverse_transform"><code>inverse_transform</code></a>(X)</td> <td>Transform data back to its original space.</td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.partial_fit" title="sklearn.decomposition.IncrementalPCA.partial_fit"><code>partial_fit</code></a>(X[, y, check_input])</td> <td>Incremental fit with X.</td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.set_params" title="sklearn.decomposition.IncrementalPCA.set_params"><code>set_params</code></a>(**params)</td> <td>Set the parameters of this estimator.</td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.decomposition.IncrementalPCA.transform" title="sklearn.decomposition.IncrementalPCA.transform"><code>transform</code></a>(X)</td> <td>Apply dimensionality reduction to X.</td> </tr>  </table> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.__init__">
<code>__init__(n_components=None, whiten=False, copy=True, batch_size=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/decomposition/incremental_pca.py#L158"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.fit">
<code>fit(X, y=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/decomposition/incremental_pca.py#L165"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit the model with X, using minibatches of size batch_size.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>X : array-like, shape (n_samples, n_features)</code> </dt> <dd>
<p class="first last">Training data, where n_samples is the number of samples and n_features is the number of features.</p> </dd> <dt>
<code>y : Ignored</code> </dt>  </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>self : object</code> </dt> <dd>
<p class="first last">Returns the instance itself.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.fit_transform">
<code>fit_transform(X, y=None, **fit_params)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/base.py#L438"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit to data, then transform it.</p> <p>Fits transformer to X and y with optional parameters fit_params and returns a transformed version of X.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>X : numpy array of shape [n_samples, n_features]</code> </dt> <dd>
<p class="first last">Training set.</p> </dd> <dt>
<code>y : numpy array of shape [n_samples]</code> </dt> <dd>
<p class="first last">Target values.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>X_new : numpy array of shape [n_samples, n_features_new]</code> </dt> <dd>
<p class="first last">Transformed array.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.get_covariance">
<code>get_covariance()</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/decomposition/base.py#L27"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute data covariance with the generative model.</p> <p><code>cov = components_.T * S**2 * components_ + sigma2 * eye(n_features)</code> where S**2 contains the explained variances, and sigma2 contains the noise variances.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>cov : array, shape=(n_features, n_features)</code> </dt> <dd>
<p class="first last">Estimated covariance of data.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.get_params">
<code>get_params(deep=True)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/base.py#L166"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>deep : boolean, optional</code> </dt> <dd>
<p class="first last">If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>params : mapping of string to any</code> </dt> <dd>
<p class="first last">Parameter names mapped to their values.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.get_precision">
<code>get_precision()</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/decomposition/base.py#L48"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute data precision matrix with the generative model.</p> <p>Equals the inverse of the covariance but computed with the matrix inversion lemma for efficiency.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>precision : array, shape=(n_features, n_features)</code> </dt> <dd>
<p class="first last">Estimated precision of data.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.inverse_transform">
<code>inverse_transform(X)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/decomposition/base.py#L136"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform data back to its original space.</p> <p>In other words, return an input X_original whose transform would be X.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>X : array-like, shape (n_samples, n_components)</code> </dt> <dd>
<p class="first last">New data, where n_samples is the number of samples and n_components is the number of components.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt><strong>X_original array-like, shape (n_samples, n_features)</strong></dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If whitening is enabled, inverse_transform will compute the exact inverse operation, which includes reversing whitening.</p> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.partial_fit">
<code>partial_fit(X, y=None, check_input=True)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/decomposition/incremental_pca.py#L204"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Incremental fit with X. All of X is processed as a single batch.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>X : array-like, shape (n_samples, n_features)</code> </dt> <dd>
<p class="first last">Training data, where n_samples is the number of samples and n_features is the number of features.</p> </dd> <dt>
<code>check_input : bool</code> </dt> <dd>
<p class="first last">Run check_array on X.</p> </dd> <dt>
<code>y : Ignored</code> </dt>  </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>self : object</code> </dt> <dd>
<p class="first last">Returns the instance itself.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.set_params">
<code>set_params(**params)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/base.py#L189"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as pipelines). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt><strong>self</strong></dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.decomposition.IncrementalPCA.transform">
<code>transform(X)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/decomposition/base.py#L99"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply dimensionality reduction to X.</p> <p>X is projected on the first principal components previously extracted from a training set.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>X : array-like, shape (n_samples, n_features)</code> </dt> <dd>
<p class="first last">New data, where n_samples is the number of samples and n_features is the number of features.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>X_new : array-like, shape (n_samples, n_components)</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.decomposition import IncrementalPCA
&gt;&gt;&gt; X = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])
&gt;&gt;&gt; ipca = IncrementalPCA(n_components=2, batch_size=3)
&gt;&gt;&gt; ipca.fit(X)
IncrementalPCA(batch_size=3, copy=True, n_components=2, whiten=False)
&gt;&gt;&gt; ipca.transform(X) 
</pre> </dd>
</dl> </dd>
</dl>  <h2 id="examples-using-sklearn-decomposition-incrementalpca">Examples using <code>sklearn.decomposition.IncrementalPCA</code>
</h2> <div class="sphx-glr-thumbcontainer" tooltip="Incremental principal component analysis (IPCA) is typically used as a replacement for principa...">
<div class="figure" id="id1"> <img alt="../../_images/sphx_glr_plot_incremental_pca_thumb.png" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../auto_examples/decomposition/plot_incremental_pca#sphx-glr-auto-examples-decomposition-plot-incremental-pca-py"><span class="std std-ref">Incremental PCA</span></a></span></p> </div> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2018 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.IncrementalPCA.html" class="_attribution-link">http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.IncrementalPCA.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
