
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>linear_model.SGDRegressor() - Scikit-learn - W3cubDocs</title>
  
  <meta name="description" content=" Linear model fitted by minimizing a regularized empirical loss with SGD ">
  <meta name="keywords" content="sklearn, linear, model, sgdregressor, scikit-learn, scikit_learn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/scikit_learn/modules/generated/sklearn.linear_model.sgdregressor.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/scikit_learn.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_learn/" class="_nav-link" title="" style="margin-left:0;">scikit-learn</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="sklearn-linear-model-sgdregressor">sklearn.linear_model.SGDRegressor</h1> <dl class="class"> <dt id="sklearn.linear_model.SGDRegressor">
<code>class sklearn.linear_model.SGDRegressor(loss=’squared_loss’, penalty=’l2’, alpha=0.0001, l1_ratio=0.15, fit_intercept=True, max_iter=None, tol=None, shuffle=True, verbose=0, epsilon=0.1, random_state=None, learning_rate=’invscaling’, eta0=0.01, power_t=0.25, early_stopping=False, validation_fraction=0.1, n_iter_no_change=5, warm_start=False, average=False, n_iter=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/linear_model/stochastic_gradient.py#L1357"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Linear model fitted by minimizing a regularized empirical loss with SGD</p> <p>SGD stands for Stochastic Gradient Descent: the gradient of the loss is estimated each sample at a time and the model is updated along the way with a decreasing strength schedule (aka learning rate).</p> <p>The regularizer is a penalty added to the loss function that shrinks model parameters towards the zero vector using either the squared euclidean norm L2 or the absolute norm L1 or a combination of both (Elastic Net). If the parameter update crosses the 0.0 value because of the regularizer, the update is truncated to 0.0 to allow for learning sparse models and achieve online feature selection.</p> <p>This implementation works with data represented as dense numpy arrays of floating point values for the features.</p> <p>Read more in the <a class="reference internal" href="../sgd#sgd"><span class="std std-ref">User Guide</span></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>loss : str, default: ‘squared_loss’</code> </dt> <dd>
<p class="first">The loss function to be used. The possible values are ‘squared_loss’, ‘huber’, ‘epsilon_insensitive’, or ‘squared_epsilon_insensitive’</p> <p class="last">The ‘squared_loss’ refers to the ordinary least squares fit. ‘huber’ modifies ‘squared_loss’ to focus less on getting outliers correct by switching from squared to linear loss past a distance of epsilon. ‘epsilon_insensitive’ ignores errors less than epsilon and is linear past that; this is the loss function used in SVR. ‘squared_epsilon_insensitive’ is the same but becomes squared loss past a tolerance of epsilon.</p> </dd> <dt>
<code>penalty : str, ‘none’, ‘l2’, ‘l1’, or ‘elasticnet’</code> </dt> <dd>
<p class="first last">The penalty (aka regularization term) to be used. Defaults to ‘l2’ which is the standard regularizer for linear SVM models. ‘l1’ and ‘elasticnet’ might bring sparsity to the model (feature selection) not achievable with ‘l2’.</p> </dd> <dt>
<code>alpha : float</code> </dt> <dd>
<p class="first last">Constant that multiplies the regularization term. Defaults to 0.0001 Also used to compute learning_rate when set to ‘optimal’.</p> </dd> <dt>
<code>l1_ratio : float</code> </dt> <dd>
<p class="first last">The Elastic Net mixing parameter, with 0 &lt;= l1_ratio &lt;= 1. l1_ratio=0 corresponds to L2 penalty, l1_ratio=1 to L1. Defaults to 0.15.</p> </dd> <dt>
<code>fit_intercept : bool</code> </dt> <dd>
<p class="first last">Whether the intercept should be estimated or not. If False, the data is assumed to be already centered. Defaults to True.</p> </dd> <dt>
<code>max_iter : int, optional</code> </dt> <dd>
<p class="first">The maximum number of passes over the training data (aka epochs). It only impacts the behavior in the <code>fit</code> method, and not the <code>partial_fit</code>. Defaults to 5. Defaults to 1000 from 0.21, or if tol is not None.</p> <div class="last versionadded"> <p><span class="versionmodified">New in version 0.19.</span></p> </div> </dd> <dt>
<code>tol : float or None, optional</code> </dt> <dd>
<p class="first">The stopping criterion. If it is not None, the iterations will stop when (loss &gt; previous_loss - tol). Defaults to None. Defaults to 1e-3 from 0.21.</p> <div class="last versionadded"> <p><span class="versionmodified">New in version 0.19.</span></p> </div> </dd> <dt>
<code>shuffle : bool, optional</code> </dt> <dd>
<p class="first last">Whether or not the training data should be shuffled after each epoch. Defaults to True.</p> </dd> <dt>
<code>verbose : integer, optional</code> </dt> <dd>
<p class="first last">The verbosity level.</p> </dd> <dt>
<code>epsilon : float</code> </dt> <dd>
<p class="first last">Epsilon in the epsilon-insensitive loss functions; only if <code>loss</code> is ‘huber’, ‘epsilon_insensitive’, or ‘squared_epsilon_insensitive’. For ‘huber’, determines the threshold at which it becomes less important to get the prediction exactly right. For epsilon-insensitive, any differences between the current prediction and the correct label are ignored if they are less than this threshold.</p> </dd> <dt>
<code>random_state : int, RandomState instance or None, optional (default=None)</code> </dt> <dd>
<p class="first last">The seed of the pseudo random number generator to use when shuffling the data. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by <code>np.random</code>.</p> </dd> <dt>
<code>learning_rate : string, optional</code> </dt> <dd>
<p class="first">The learning rate schedule:</p> <dl class="last docutils"> <dt>‘constant’:</dt> <dd>
<p class="first last">eta = eta0</p> </dd> <dt>‘optimal’:</dt> <dd>
<p class="first last">eta = 1.0 / (alpha * (t + t0)) where t0 is chosen by a heuristic proposed by Leon Bottou.</p> </dd> <dt>‘invscaling’: [default]</dt> <dd>
<p class="first last">eta = eta0 / pow(t, power_t)</p> </dd> <dt>‘adaptive’:</dt> <dd>
<p class="first last">eta = eta0, as long as the training keeps decreasing. Each time n_iter_no_change consecutive epochs fail to decrease the training loss by tol or fail to increase validation score by tol if early_stopping is True, the current learning rate is divided by 5.</p> </dd> </dl> </dd> <dt>
<code>eta0 : double</code> </dt> <dd>
<p class="first last">The initial learning rate for the ‘constant’, ‘invscaling’ or ‘adaptive’ schedules. The default value is 0.0 as eta0 is not used by the default schedule ‘optimal’.</p> </dd> <dt>
<code>power_t : double</code> </dt> <dd>
<p class="first last">The exponent for inverse scaling learning rate [default 0.5].</p> </dd> <dt>
<code>early_stopping : bool, default=False</code> </dt> <dd>
<p class="first">Whether to use early stopping to terminate training when validation score is not improving. If set to True, it will automatically set aside a fraction of training data as validation and terminate training when validation score is not improving by at least tol for n_iter_no_change consecutive epochs.</p> <div class="last versionadded"> <p><span class="versionmodified">New in version 0.20.</span></p> </div> </dd> <dt>
<code>validation_fraction : float, default=0.1</code> </dt> <dd>
<p class="first">The proportion of training data to set aside as validation set for early stopping. Must be between 0 and 1. Only used if early_stopping is True.</p> <div class="last versionadded"> <p><span class="versionmodified">New in version 0.20.</span></p> </div> </dd> <dt>
<code>n_iter_no_change : int, default=5</code> </dt> <dd>
<p class="first">Number of iterations with no improvement to wait before early stopping.</p> <div class="last versionadded"> <p><span class="versionmodified">New in version 0.20.</span></p> </div> </dd> <dt>
<code>warm_start : bool, optional</code> </dt> <dd>
<p class="first">When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. See <a class="reference internal" href="http://scikit-learn.org/stable/glossary.html#term-warm-start"><span class="xref std std-term">the Glossary</span></a>.</p> <p class="last">Repeatedly calling fit or partial_fit when warm_start is True can result in a different solution than when calling fit a single time because of the way the data is shuffled. If a dynamic learning rate is used, the learning rate is adapted depending on the number of samples already seen. Calling <code>fit</code> resets this counter, while <code>partial_fit</code> will result in increasing the existing counter.</p> </dd> <dt>
<code>average : bool or int, optional</code> </dt> <dd>
<p class="first last">When set to True, computes the averaged SGD weights and stores the result in the <code>coef_</code> attribute. If set to an int greater than 1, averaging will begin once the total number of samples seen reaches average. So <code>average=10</code> will begin averaging after seeing 10 samples.</p> </dd> <dt>
<code>n_iter : int, optional</code> </dt> <dd>
<p class="first">The number of passes over the training data (aka epochs). Defaults to None. Deprecated, will be removed in 0.21.</p> <div class="last versionchanged"> <p><span class="versionmodified">Changed in version 0.19: </span>Deprecated</p> </div> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>coef_ : array, shape (n_features,)</code> </dt> <dd>
<p class="first last">Weights assigned to the features.</p> </dd> <dt>
<code>intercept_ : array, shape (1,)</code> </dt> <dd>
<p class="first last">The intercept term.</p> </dd> <dt>
<code>average_coef_ : array, shape (n_features,)</code> </dt> <dd>
<p class="first last">Averaged weights assigned to the features.</p> </dd> <dt>
<code>average_intercept_ : array, shape (1,)</code> </dt> <dd>
<p class="first last">The averaged intercept term.</p> </dd> <dt>
<code>n_iter_ : int</code> </dt> <dd>
<p class="first last">The actual number of iterations to reach the stopping criterion.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="sklearn.linear_model.ridge#sklearn.linear_model.Ridge" title="sklearn.linear_model.Ridge"><code>Ridge</code></a>, <a class="reference internal" href="sklearn.linear_model.elasticnet#sklearn.linear_model.ElasticNet" title="sklearn.linear_model.ElasticNet"><code>ElasticNet</code></a>, <a class="reference internal" href="sklearn.linear_model.lasso#sklearn.linear_model.Lasso" title="sklearn.linear_model.Lasso"><code>Lasso</code></a>, <a class="reference internal" href="sklearn.svm.svr#sklearn.svm.SVR" title="sklearn.svm.SVR"><code>sklearn.svm.SVR</code></a></p> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn import linear_model
&gt;&gt;&gt; n_samples, n_features = 10, 5
&gt;&gt;&gt; np.random.seed(0)
&gt;&gt;&gt; y = np.random.randn(n_samples)
&gt;&gt;&gt; X = np.random.randn(n_samples, n_features)
&gt;&gt;&gt; clf = linear_model.SGDRegressor(max_iter=1000)
&gt;&gt;&gt; clf.fit(X, y)
... 
SGDRegressor(alpha=0.0001, average=False, early_stopping=False,
       epsilon=0.1, eta0=0.01, fit_intercept=True, l1_ratio=0.15,
       learning_rate='invscaling', loss='squared_loss', max_iter=1000,
       n_iter=None, n_iter_no_change=5, penalty='l2', power_t=0.25,
       random_state=None, shuffle=True, tol=None, validation_fraction=0.1,
       verbose=0, warm_start=False)
</pre> <h4 class="rubric">Methods</h4> <table class="longtable docutils">   <tr>
<td>
<a class="reference internal" href="#sklearn.linear_model.SGDRegressor.densify" title="sklearn.linear_model.SGDRegressor.densify"><code>densify</code></a>()</td> <td>Convert coefficient matrix to dense array format.</td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.linear_model.SGDRegressor.fit" title="sklearn.linear_model.SGDRegressor.fit"><code>fit</code></a>(X, y[, coef_init, intercept_init, …])</td> <td>Fit linear model with Stochastic Gradient Descent.</td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.linear_model.SGDRegressor.get_params" title="sklearn.linear_model.SGDRegressor.get_params"><code>get_params</code></a>([deep])</td> <td>Get parameters for this estimator.</td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.linear_model.SGDRegressor.partial_fit" title="sklearn.linear_model.SGDRegressor.partial_fit"><code>partial_fit</code></a>(X, y[, sample_weight])</td> <td>Fit linear model with Stochastic Gradient Descent.</td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.linear_model.SGDRegressor.predict" title="sklearn.linear_model.SGDRegressor.predict"><code>predict</code></a>(X)</td> <td>Predict using the linear model</td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.linear_model.SGDRegressor.score" title="sklearn.linear_model.SGDRegressor.score"><code>score</code></a>(X, y[, sample_weight])</td> <td>Returns the coefficient of determination R^2 of the prediction.</td> </tr> <tr>
<td>
<code>set_params</code>(*args, **kwargs)</td> <td></td> </tr> <tr>
<td>
<a class="reference internal" href="#sklearn.linear_model.SGDRegressor.sparsify" title="sklearn.linear_model.SGDRegressor.sparsify"><code>sparsify</code></a>()</td> <td>Convert coefficient matrix to sparse format.</td> </tr>  </table> <dl class="method"> <dt id="sklearn.linear_model.SGDRegressor.__init__">
<code>__init__(loss=’squared_loss’, penalty=’l2’, alpha=0.0001, l1_ratio=0.15, fit_intercept=True, max_iter=None, tol=None, shuffle=True, verbose=0, epsilon=0.1, random_state=None, learning_rate=’invscaling’, eta0=0.01, power_t=0.25, early_stopping=False, validation_fraction=0.1, n_iter_no_change=5, warm_start=False, average=False, n_iter=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/linear_model/stochastic_gradient.py#L1558"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="sklearn.linear_model.SGDRegressor.densify">
<code>densify()</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/linear_model/base.py#L314"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert coefficient matrix to dense array format.</p> <p>Converts the <code>coef_</code> member (back) to a numpy.ndarray. This is the default format of <code>coef_</code> and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>self : estimator</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.SGDRegressor.fit">
<code>fit(X, y, coef_init=None, intercept_init=None, sample_weight=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/linear_model/stochastic_gradient.py#L1208"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit linear model with Stochastic Gradient Descent.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>X : {array-like, sparse matrix}, shape (n_samples, n_features)</code> </dt> <dd>
<p class="first last">Training data</p> </dd> <dt>
<code>y : numpy array, shape (n_samples,)</code> </dt> <dd>
<p class="first last">Target values</p> </dd> <dt>
<code>coef_init : array, shape (n_features,)</code> </dt> <dd>
<p class="first last">The initial coefficients to warm-start the optimization.</p> </dd> <dt>
<code>intercept_init : array, shape (1,)</code> </dt> <dd>
<p class="first last">The initial intercept to warm-start the optimization.</p> </dd> <dt>
<code>sample_weight : array-like, shape (n_samples,), optional</code> </dt> <dd>
<p class="first last">Weights applied to individual samples (1. for unweighted).</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>self : returns an instance of self.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.SGDRegressor.get_params">
<code>get_params(deep=True)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/base.py#L166"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>deep : boolean, optional</code> </dt> <dd>
<p class="first last">If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>params : mapping of string to any</code> </dt> <dd>
<p class="first last">Parameter names mapped to their values.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.SGDRegressor.partial_fit">
<code>partial_fit(X, y, sample_weight=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/linear_model/stochastic_gradient.py#L1148"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit linear model with Stochastic Gradient Descent.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>X : {array-like, sparse matrix}, shape (n_samples, n_features)</code> </dt> <dd>
<p class="first last">Subset of training data</p> </dd> <dt>
<code>y : numpy array of shape (n_samples,)</code> </dt> <dd>
<p class="first last">Subset of target values</p> </dd> <dt>
<code>sample_weight : array-like, shape (n_samples,), optional</code> </dt> <dd>
<p class="first last">Weights applied to individual samples. If not provided, uniform weights are assumed.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>self : returns an instance of self.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.SGDRegressor.predict">
<code>predict(X)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/linear_model/stochastic_gradient.py#L1259"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict using the linear model</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>X : {array-like, sparse matrix}, shape (n_samples, n_features)</code> </dt>  </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt><strong>array, shape (n_samples,)</strong></dt> <dd>
<p class="first last">Predicted target values per element in X.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.SGDRegressor.score">
<code>score(X, y, sample_weight=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/base.py#L296"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the coefficient of determination R^2 of the prediction.</p> <p>The coefficient R^2 is defined as (1 - u/v), where u is the residual sum of squares ((y_true - y_pred) ** 2).sum() and v is the total sum of squares ((y_true - y_true.mean()) ** 2).sum(). The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of y, disregarding the input features, would get a R^2 score of 0.0.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>X : array-like, shape = (n_samples, n_features)</code> </dt> <dd>
<p class="first last">Test samples. For some estimators this may be a precomputed kernel matrix instead, shape = (n_samples, n_samples_fitted], where n_samples_fitted is the number of samples used in the fitting for the estimator.</p> </dd> <dt>
<code>y : array-like, shape = (n_samples) or (n_samples, n_outputs)</code> </dt> <dd>
<p class="first last">True values for X.</p> </dd> <dt>
<code>sample_weight : array-like, shape = [n_samples], optional</code> </dt> <dd>
<p class="first last">Sample weights.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>score : float</code> </dt> <dd>
<p class="first last">R^2 of self.predict(X) wrt. y.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="sklearn.linear_model.SGDRegressor.sparsify">
<code>sparsify()</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/bac89c2/sklearn/linear_model/base.py#L332"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert coefficient matrix to sparse format.</p> <p>Converts the <code>coef_</code> member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.</p> <p>The <code>intercept_</code> member is not converted.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>self : estimator</code> </dt>  </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>For non-sparse models, i.e. when there are not many zeros in <code>coef_</code>, this may actually <em>increase</em> memory usage, so use this method with care. A rule of thumb is that the number of zero elements, which can be computed with <code>(coef_ == 0).sum()</code>, must be more than 50% for this to provide significant benefits.</p> <p>After calling this method, further fitting with the partial_fit method (if any) will not work until you call densify.</p> </dd>
</dl> </dd>
</dl>  <h2 id="examples-using-sklearn-linear-model-sgdregressor">Examples using <code>sklearn.linear_model.SGDRegressor</code>
</h2> <div class="sphx-glr-thumbcontainer" tooltip="This is an example showing the prediction latency of various scikit-learn estimators.">
<div class="figure" id="id1"> <img alt="../../_images/sphx_glr_plot_prediction_latency_thumb.png" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../auto_examples/applications/plot_prediction_latency#sphx-glr-auto-examples-applications-plot-prediction-latency-py"><span class="std std-ref">Prediction Latency</span></a></span></p> </div> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2018 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDRegressor.html" class="_attribution-link">http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.SGDRegressor.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
