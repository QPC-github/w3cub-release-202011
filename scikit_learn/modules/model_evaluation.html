
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>3.3. Model Evaluation - Scikit-learn - W3cubDocs</title>
  
  <meta name="description" content=" There are 3 different APIs for evaluating the quality of a model’s predictions&#58; ">
  <meta name="keywords" content="model, evaluation, quantifying, quality, predictions, scikit-learn, scikit_learn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/scikit_learn/modules/model_evaluation.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/scikit_learn.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_learn/" class="_nav-link" title="" style="margin-left:0;">scikit-learn</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="model-evaluation">3.3. Model evaluation: quantifying the quality of predictions</h1> <p id="model-evaluation-quantifying-the-quality-of-predictions">There are 3 different APIs for evaluating the quality of a model’s predictions:</p> <ul class="simple"> <li>
<strong>Estimator score method</strong>: Estimators have a <code>score</code> method providing a default evaluation criterion for the problem they are designed to solve. This is not discussed on this page, but in each estimator’s documentation.</li> <li>
<strong>Scoring parameter</strong>: Model-evaluation tools using <a class="reference internal" href="cross_validation#cross-validation"><span class="std std-ref">cross-validation</span></a> (such as <a class="reference internal" href="generated/sklearn.model_selection.cross_val_score#sklearn.model_selection.cross_val_score" title="sklearn.model_selection.cross_val_score"><code>model_selection.cross_val_score</code></a> and <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>model_selection.GridSearchCV</code></a>) rely on an internal <em>scoring</em> strategy. This is discussed in the section <a class="reference internal" href="#scoring-parameter"><span class="std std-ref">The scoring parameter: defining model evaluation rules</span></a>.</li> <li>
<strong>Metric functions</strong>: The <code>metrics</code> module implements functions assessing prediction error for specific purposes. These metrics are detailed in sections on <a class="reference internal" href="#classification-metrics"><span class="std std-ref">Classification metrics</span></a>, <a class="reference internal" href="#multilabel-ranking-metrics"><span class="std std-ref">Multilabel ranking metrics</span></a>, <a class="reference internal" href="#regression-metrics"><span class="std std-ref">Regression metrics</span></a> and <a class="reference internal" href="#clustering-metrics"><span class="std std-ref">Clustering metrics</span></a>.</li> </ul> <p>Finally, <a class="reference internal" href="#dummy-estimators"><span class="std std-ref">Dummy estimators</span></a> are useful to get a baseline value of those metrics for random predictions.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last">For “pairwise” metrics, between <em>samples</em> and not estimators or predictions, see the <a class="reference internal" href="metrics#metrics"><span class="std std-ref">Pairwise metrics, Affinities and Kernels</span></a> section.</p> </div>  <h2 id="scoring-parameter">3.3.1. The <code>scoring</code> parameter: defining model evaluation rules</h2> <p id="the-scoring-parameter-defining-model-evaluation-rules">Model selection and evaluation using tools, such as <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>model_selection.GridSearchCV</code></a> and <a class="reference internal" href="generated/sklearn.model_selection.cross_val_score#sklearn.model_selection.cross_val_score" title="sklearn.model_selection.cross_val_score"><code>model_selection.cross_val_score</code></a>, take a <code>scoring</code> parameter that controls what metric they apply to the estimators evaluated.</p>  <h3 id="common-cases-predefined-values">3.3.1.1. Common cases: predefined values</h3> <p>For the most common use cases, you can designate a scorer object with the <code>scoring</code> parameter; the table below shows all possible values. All scorer objects follow the convention that <strong>higher return values are better than lower return values</strong>. Thus metrics which measure the distance between the model and the data, like <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code>metrics.mean_squared_error</code></a>, are available as neg_mean_squared_error which return the negated value of the metric.</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Scoring</th> <th class="head">Function</th> <th class="head">Comment</th> </tr> </thead>  <tr>
<td><strong>Classification</strong></td> <td> </td> <td> </td> </tr> <tr>
<td>‘accuracy’</td> <td><a class="reference internal" href="generated/sklearn.metrics.accuracy_score#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code>metrics.accuracy_score</code></a></td> <td> </td> </tr> <tr>
<td>‘balanced_accuracy’</td> <td><a class="reference internal" href="generated/sklearn.metrics.balanced_accuracy_score#sklearn.metrics.balanced_accuracy_score" title="sklearn.metrics.balanced_accuracy_score"><code>metrics.balanced_accuracy_score</code></a></td> <td>for binary targets</td> </tr> <tr>
<td>‘average_precision’</td> <td><a class="reference internal" href="generated/sklearn.metrics.average_precision_score#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>metrics.average_precision_score</code></a></td> <td> </td> </tr> <tr>
<td>‘brier_score_loss’</td> <td><a class="reference internal" href="generated/sklearn.metrics.brier_score_loss#sklearn.metrics.brier_score_loss" title="sklearn.metrics.brier_score_loss"><code>metrics.brier_score_loss</code></a></td> <td> </td> </tr> <tr>
<td>‘f1’</td> <td><a class="reference internal" href="generated/sklearn.metrics.f1_score#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>metrics.f1_score</code></a></td> <td>for binary targets</td> </tr> <tr>
<td>‘f1_micro’</td> <td><a class="reference internal" href="generated/sklearn.metrics.f1_score#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>metrics.f1_score</code></a></td> <td>micro-averaged</td> </tr> <tr>
<td>‘f1_macro’</td> <td><a class="reference internal" href="generated/sklearn.metrics.f1_score#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>metrics.f1_score</code></a></td> <td>macro-averaged</td> </tr> <tr>
<td>‘f1_weighted’</td> <td><a class="reference internal" href="generated/sklearn.metrics.f1_score#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>metrics.f1_score</code></a></td> <td>weighted average</td> </tr> <tr>
<td>‘f1_samples’</td> <td><a class="reference internal" href="generated/sklearn.metrics.f1_score#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>metrics.f1_score</code></a></td> <td>by multilabel sample</td> </tr> <tr>
<td>‘neg_log_loss’</td> <td><a class="reference internal" href="generated/sklearn.metrics.log_loss#sklearn.metrics.log_loss" title="sklearn.metrics.log_loss"><code>metrics.log_loss</code></a></td> <td>requires <code>predict_proba</code> support</td> </tr> <tr>
<td>‘precision’ etc.</td> <td><a class="reference internal" href="generated/sklearn.metrics.precision_score#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code>metrics.precision_score</code></a></td> <td>suffixes apply as with ‘f1’</td> </tr> <tr>
<td>‘recall’ etc.</td> <td><a class="reference internal" href="generated/sklearn.metrics.recall_score#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code>metrics.recall_score</code></a></td> <td>suffixes apply as with ‘f1’</td> </tr> <tr>
<td>‘roc_auc’</td> <td><a class="reference internal" href="generated/sklearn.metrics.roc_auc_score#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>metrics.roc_auc_score</code></a></td> <td> </td> </tr> <tr>
<td><strong>Clustering</strong></td> <td> </td> <td> </td> </tr> <tr>
<td>‘adjusted_mutual_info_score’</td> <td><a class="reference internal" href="generated/sklearn.metrics.adjusted_mutual_info_score#sklearn.metrics.adjusted_mutual_info_score" title="sklearn.metrics.adjusted_mutual_info_score"><code>metrics.adjusted_mutual_info_score</code></a></td> <td> </td> </tr> <tr>
<td>‘adjusted_rand_score’</td> <td><a class="reference internal" href="generated/sklearn.metrics.adjusted_rand_score#sklearn.metrics.adjusted_rand_score" title="sklearn.metrics.adjusted_rand_score"><code>metrics.adjusted_rand_score</code></a></td> <td> </td> </tr> <tr>
<td>‘completeness_score’</td> <td><a class="reference internal" href="generated/sklearn.metrics.completeness_score#sklearn.metrics.completeness_score" title="sklearn.metrics.completeness_score"><code>metrics.completeness_score</code></a></td> <td> </td> </tr> <tr>
<td>‘fowlkes_mallows_score’</td> <td><a class="reference internal" href="generated/sklearn.metrics.fowlkes_mallows_score#sklearn.metrics.fowlkes_mallows_score" title="sklearn.metrics.fowlkes_mallows_score"><code>metrics.fowlkes_mallows_score</code></a></td> <td> </td> </tr> <tr>
<td>‘homogeneity_score’</td> <td><a class="reference internal" href="generated/sklearn.metrics.homogeneity_score#sklearn.metrics.homogeneity_score" title="sklearn.metrics.homogeneity_score"><code>metrics.homogeneity_score</code></a></td> <td> </td> </tr> <tr>
<td>‘mutual_info_score’</td> <td><a class="reference internal" href="generated/sklearn.metrics.mutual_info_score#sklearn.metrics.mutual_info_score" title="sklearn.metrics.mutual_info_score"><code>metrics.mutual_info_score</code></a></td> <td> </td> </tr> <tr>
<td>‘normalized_mutual_info_score’</td> <td><a class="reference internal" href="generated/sklearn.metrics.normalized_mutual_info_score#sklearn.metrics.normalized_mutual_info_score" title="sklearn.metrics.normalized_mutual_info_score"><code>metrics.normalized_mutual_info_score</code></a></td> <td> </td> </tr> <tr>
<td>‘v_measure_score’</td> <td><a class="reference internal" href="generated/sklearn.metrics.v_measure_score#sklearn.metrics.v_measure_score" title="sklearn.metrics.v_measure_score"><code>metrics.v_measure_score</code></a></td> <td> </td> </tr> <tr>
<td><strong>Regression</strong></td> <td> </td> <td> </td> </tr> <tr>
<td>‘explained_variance’</td> <td><a class="reference internal" href="generated/sklearn.metrics.explained_variance_score#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code>metrics.explained_variance_score</code></a></td> <td> </td> </tr> <tr>
<td>‘neg_mean_absolute_error’</td> <td><a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><code>metrics.mean_absolute_error</code></a></td> <td> </td> </tr> <tr>
<td>‘neg_mean_squared_error’</td> <td><a class="reference internal" href="generated/sklearn.metrics.mean_squared_error#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code>metrics.mean_squared_error</code></a></td> <td> </td> </tr> <tr>
<td>‘neg_mean_squared_log_error’</td> <td><a class="reference internal" href="generated/sklearn.metrics.mean_squared_log_error#sklearn.metrics.mean_squared_log_error" title="sklearn.metrics.mean_squared_log_error"><code>metrics.mean_squared_log_error</code></a></td> <td> </td> </tr> <tr>
<td>‘neg_median_absolute_error’</td> <td><a class="reference internal" href="generated/sklearn.metrics.median_absolute_error#sklearn.metrics.median_absolute_error" title="sklearn.metrics.median_absolute_error"><code>metrics.median_absolute_error</code></a></td> <td> </td> </tr> <tr>
<td>‘r2’</td> <td><a class="reference internal" href="generated/sklearn.metrics.r2_score#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>metrics.r2_score</code></a></td> <td> </td> </tr>  </table> <p>Usage examples:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import svm, datasets
&gt;&gt;&gt; from sklearn.model_selection import cross_val_score
&gt;&gt;&gt; iris = datasets.load_iris()
&gt;&gt;&gt; X, y = iris.data, iris.target
&gt;&gt;&gt; clf = svm.SVC(gamma='scale', random_state=0)
&gt;&gt;&gt; cross_val_score(clf, X, y, scoring='recall_macro',
...                 cv=5)  
array([0.96..., 1.  ..., 0.96..., 0.96..., 1.        ])
&gt;&gt;&gt; model = svm.SVC()
&gt;&gt;&gt; cross_val_score(model, X, y, cv=5, scoring='wrong_choice')
Traceback (most recent call last):
ValueError: 'wrong_choice' is not a valid scoring value. Use sorted(sklearn.metrics.SCORERS.keys()) to get valid options.
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The values listed by the ValueError exception correspond to the functions measuring prediction accuracy described in the following sections. The scorer objects for those functions are stored in the dictionary <code>sklearn.metrics.SCORERS</code>.</p> </div>   <h3 id="scoring">3.3.1.2. Defining your scoring strategy from metric functions</h3> <p id="defining-your-scoring-strategy-from-metric-functions">The module <a class="reference internal" href="classes#module-sklearn.metrics" title="sklearn.metrics"><code>sklearn.metrics</code></a> also exposes a set of simple functions measuring a prediction error given ground truth and prediction:</p> <ul class="simple"> <li>functions ending with <code>_score</code> return a value to maximize, the higher the better.</li> <li>functions ending with <code>_error</code> or <code>_loss</code> return a value to minimize, the lower the better. When converting into a scorer object using <a class="reference internal" href="generated/sklearn.metrics.make_scorer#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><code>make_scorer</code></a>, set the <code>greater_is_better</code> parameter to False (True by default; see the parameter description below).</li> </ul> <p>Metrics available for various machine learning tasks are detailed in sections below.</p> <p>Many metrics are not given names to be used as <code>scoring</code> values, sometimes because they require additional parameters, such as <a class="reference internal" href="generated/sklearn.metrics.fbeta_score#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code>fbeta_score</code></a>. In such cases, you need to generate an appropriate scoring object. The simplest way to generate a callable object for scoring is by using <a class="reference internal" href="generated/sklearn.metrics.make_scorer#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><code>make_scorer</code></a>. That function converts metrics into callables that can be used for model evaluation.</p> <p>One typical use case is to wrap an existing metric function from the library with non-default values for its parameters, such as the <code>beta</code> parameter for the <a class="reference internal" href="generated/sklearn.metrics.fbeta_score#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code>fbeta_score</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import fbeta_score, make_scorer
&gt;&gt;&gt; ftwo_scorer = make_scorer(fbeta_score, beta=2)
&gt;&gt;&gt; from sklearn.model_selection import GridSearchCV
&gt;&gt;&gt; from sklearn.svm import LinearSVC
&gt;&gt;&gt; grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]},
...                     scoring=ftwo_scorer, cv=5)
</pre> <p>The second use case is to build a completely custom scorer object from a simple python function using <a class="reference internal" href="generated/sklearn.metrics.make_scorer#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><code>make_scorer</code></a>, which can take several parameters:</p> <ul class="simple"> <li>the python function you want to use (<code>my_custom_loss_func</code> in the example below)</li> <li>whether the python function returns a score (<code>greater_is_better=True</code>, the default) or a loss (<code>greater_is_better=False</code>). If a loss, the output of the python function is negated by the scorer object, conforming to the cross validation convention that scorers return higher values for better models.</li> <li>for classification metrics only: whether the python function you provided requires continuous decision certainties (<code>needs_threshold=True</code>). The default value is False.</li> <li>any additional parameters, such as <code>beta</code> or <code>labels</code> in <a class="reference internal" href="generated/sklearn.metrics.f1_score#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>f1_score</code></a>.</li> </ul> <p>Here is an example of building custom scorers, and of using the <code>greater_is_better</code> parameter:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; def my_custom_loss_func(y_true, y_pred):
...     diff = np.abs(y_true - y_pred).max()
...     return np.log1p(diff)
...
&gt;&gt;&gt; # score will negate the return value of my_custom_loss_func,
&gt;&gt;&gt; # which will be np.log(2), 0.693, given the values for X
&gt;&gt;&gt; # and y defined below.
&gt;&gt;&gt; score = make_scorer(my_custom_loss_func, greater_is_better=False)
&gt;&gt;&gt; X = [[1], [1]]
&gt;&gt;&gt; y  = [0, 1]
&gt;&gt;&gt; from sklearn.dummy import DummyClassifier
&gt;&gt;&gt; clf = DummyClassifier(strategy='most_frequent', random_state=0)
&gt;&gt;&gt; clf = clf.fit(X, y)
&gt;&gt;&gt; my_custom_loss_func(clf.predict(X), y) 
0.69...
&gt;&gt;&gt; score(clf, X, y) 
-0.69...
</pre>   <h3 id="diy-scoring">3.3.1.3. Implementing your own scoring object</h3> <p id="implementing-your-own-scoring-object">You can generate even more flexible model scorers by constructing your own scoring object from scratch, without using the <a class="reference internal" href="generated/sklearn.metrics.make_scorer#sklearn.metrics.make_scorer" title="sklearn.metrics.make_scorer"><code>make_scorer</code></a> factory. For a callable to be a scorer, it needs to meet the protocol specified by the following two rules:</p> <ul class="simple"> <li>It can be called with parameters <code>(estimator, X, y)</code>, where <code>estimator</code> is the model that should be evaluated, <code>X</code> is validation data, and <code>y</code> is the ground truth target for <code>X</code> (in the supervised case) or <code>None</code> (in the unsupervised case).</li> <li>It returns a floating point number that quantifies the <code>estimator</code> prediction quality on <code>X</code>, with reference to <code>y</code>. Again, by convention higher numbers are better, so if your scorer returns loss, that value should be negated.</li> </ul>   <h3 id="multimetric-scoring">3.3.1.4. Using multiple metric evaluation</h3> <p id="using-multiple-metric-evaluation">Scikit-learn also permits evaluation of multiple metrics in <code>GridSearchCV</code>, <code>RandomizedSearchCV</code> and <code>cross_validate</code>.</p> <p>There are two ways to specify multiple scoring metrics for the <code>scoring</code> parameter:</p> <ul> <li>
<dl class="first docutils"> <dt>As an iterable of string metrics::</dt> <dd>
<pre data-language="python">&gt;&gt;&gt; scoring = ['accuracy', 'precision']
</pre> </dd> </dl> </li> <li>
<dl class="first docutils"> <dt>
<code>As a dict mapping the scorer name to the scoring function::</code> </dt> <dd>
<pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import accuracy_score
&gt;&gt;&gt; from sklearn.metrics import make_scorer
&gt;&gt;&gt; scoring = {'accuracy': make_scorer(accuracy_score),
...            'prec': 'precision'}
</pre> </dd> </dl> </li> </ul> <p>Note that the dict values can either be scorer functions or one of the predefined metric strings.</p> <p>Currently only those scorer functions that return a single score can be passed inside the dict. Scorer functions that return multiple values are not permitted and will require a wrapper to return a single metric:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import cross_validate
&gt;&gt;&gt; from sklearn.metrics import confusion_matrix
&gt;&gt;&gt; # A sample toy binary classification dataset
&gt;&gt;&gt; X, y = datasets.make_classification(n_classes=2, random_state=0)
&gt;&gt;&gt; svm = LinearSVC(random_state=0)
&gt;&gt;&gt; def tn(y_true, y_pred): return confusion_matrix(y_true, y_pred)[0, 0]
&gt;&gt;&gt; def fp(y_true, y_pred): return confusion_matrix(y_true, y_pred)[0, 1]
&gt;&gt;&gt; def fn(y_true, y_pred): return confusion_matrix(y_true, y_pred)[1, 0]
&gt;&gt;&gt; def tp(y_true, y_pred): return confusion_matrix(y_true, y_pred)[1, 1]
&gt;&gt;&gt; scoring = {'tp' : make_scorer(tp), 'tn' : make_scorer(tn),
...            'fp' : make_scorer(fp), 'fn' : make_scorer(fn)}
&gt;&gt;&gt; cv_results = cross_validate(svm.fit(X, y), X, y,
...                             scoring=scoring, cv=5)
&gt;&gt;&gt; # Getting the test set true positive scores
&gt;&gt;&gt; print(cv_results['test_tp'])  
[10  9  8  7  8]
&gt;&gt;&gt; # Getting the test set false negative scores
&gt;&gt;&gt; print(cv_results['test_fn'])  
[0 1 2 3 2]
</pre>    <h2 id="id1">3.3.2. Classification metrics</h2> <p id="classification-metrics">The <a class="reference internal" href="classes#module-sklearn.metrics" title="sklearn.metrics"><code>sklearn.metrics</code></a> module implements several loss, score, and utility functions to measure classification performance. Some metrics might require probability estimates of the positive class, confidence values, or binary decisions values. Most implementations allow each sample to provide a weighted contribution to the overall score, through the <code>sample_weight</code> parameter.</p> <p>Some of these are restricted to the binary classification case:</p> <table class="longtable docutils">   <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code>precision_recall_curve</code></a>(y_true, probas_pred)</td> <td>Compute precision-recall pairs for different probability thresholds</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.roc_curve#sklearn.metrics.roc_curve" title="sklearn.metrics.roc_curve"><code>roc_curve</code></a>(y_true, y_score[, pos_label, …])</td> <td>Compute Receiver operating characteristic (ROC)</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.balanced_accuracy_score#sklearn.metrics.balanced_accuracy_score" title="sklearn.metrics.balanced_accuracy_score"><code>balanced_accuracy_score</code></a>(y_true, y_pred[, …])</td> <td>Compute the balanced accuracy</td> </tr>  </table> <p>Others also work in the multiclass case:</p> <table class="longtable docutils">   <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.cohen_kappa_score#sklearn.metrics.cohen_kappa_score" title="sklearn.metrics.cohen_kappa_score"><code>cohen_kappa_score</code></a>(y1, y2[, labels, weights, …])</td> <td>Cohen’s kappa: a statistic that measures inter-annotator agreement.</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.confusion_matrix#sklearn.metrics.confusion_matrix" title="sklearn.metrics.confusion_matrix"><code>confusion_matrix</code></a>(y_true, y_pred[, labels, …])</td> <td>Compute confusion matrix to evaluate the accuracy of a classification</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.hinge_loss#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code>hinge_loss</code></a>(y_true, pred_decision[, labels, …])</td> <td>Average hinge loss (non-regularized)</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.matthews_corrcoef#sklearn.metrics.matthews_corrcoef" title="sklearn.metrics.matthews_corrcoef"><code>matthews_corrcoef</code></a>(y_true, y_pred[, …])</td> <td>Compute the Matthews correlation coefficient (MCC)</td> </tr>  </table> <p>Some also work in the multilabel case:</p> <table class="longtable docutils">   <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.accuracy_score#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code>accuracy_score</code></a>(y_true, y_pred[, normalize, …])</td> <td>Accuracy classification score.</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.classification_report#sklearn.metrics.classification_report" title="sklearn.metrics.classification_report"><code>classification_report</code></a>(y_true, y_pred[, …])</td> <td>Build a text report showing the main classification metrics</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.f1_score#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>f1_score</code></a>(y_true, y_pred[, labels, …])</td> <td>Compute the F1 score, also known as balanced F-score or F-measure</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.fbeta_score#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code>fbeta_score</code></a>(y_true, y_pred, beta[, labels, …])</td> <td>Compute the F-beta score</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.hamming_loss#sklearn.metrics.hamming_loss" title="sklearn.metrics.hamming_loss"><code>hamming_loss</code></a>(y_true, y_pred[, labels, …])</td> <td>Compute the average Hamming loss.</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.jaccard_similarity_score#sklearn.metrics.jaccard_similarity_score" title="sklearn.metrics.jaccard_similarity_score"><code>jaccard_similarity_score</code></a>(y_true, y_pred[, …])</td> <td>Jaccard similarity coefficient score</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.log_loss#sklearn.metrics.log_loss" title="sklearn.metrics.log_loss"><code>log_loss</code></a>(y_true, y_pred[, eps, normalize, …])</td> <td>Log loss, aka logistic loss or cross-entropy loss.</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><code>precision_recall_fscore_support</code></a>(y_true, y_pred)</td> <td>Compute precision, recall, F-measure and support for each class</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.precision_score#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code>precision_score</code></a>(y_true, y_pred[, labels, …])</td> <td>Compute the precision</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.recall_score#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code>recall_score</code></a>(y_true, y_pred[, labels, …])</td> <td>Compute the recall</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.zero_one_loss#sklearn.metrics.zero_one_loss" title="sklearn.metrics.zero_one_loss"><code>zero_one_loss</code></a>(y_true, y_pred[, normalize, …])</td> <td>Zero-one classification loss.</td> </tr>  </table> <p>And some work with binary and multilabel (but not multiclass) problems:</p> <table class="longtable docutils">   <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.average_precision_score#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a>(y_true, y_score[, …])</td> <td>Compute average precision (AP) from prediction scores</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.roc_auc_score#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a>(y_true, y_score[, average, …])</td> <td>Compute Area Under the Receiver Operating Characteristic Curve (ROC AUC) from prediction scores.</td> </tr>  </table> <p>In the following sub-sections, we will describe each of those functions, preceded by some notes on common API and metric definition.</p>  <h3 id="from-binary-to-multiclass-and-multilabel">3.3.2.1. From binary to multiclass and multilabel</h3> <p>Some metrics are essentially defined for binary classification tasks (e.g. <a class="reference internal" href="generated/sklearn.metrics.f1_score#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>f1_score</code></a>, <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a>). In these cases, by default only the positive label is evaluated, assuming by default that the positive class is labelled <code>1</code> (though this may be configurable through the <code>pos_label</code> parameter).</p> <p id="average">In extending a binary metric to multiclass or multilabel problems, the data is treated as a collection of binary problems, one for each class. There are then a number of ways to average binary metric calculations across the set of classes, each of which may be useful in some scenario. Where available, you should select among these using the <code>average</code> parameter.</p> <ul class="simple"> <li>
<code>"macro"</code> simply calculates the mean of the binary metrics, giving equal weight to each class. In problems where infrequent classes are nonetheless important, macro-averaging may be a means of highlighting their performance. On the other hand, the assumption that all classes are equally important is often untrue, such that macro-averaging will over-emphasize the typically low performance on an infrequent class.</li> <li>
<code>"weighted"</code> accounts for class imbalance by computing the average of binary metrics in which each class’s score is weighted by its presence in the true data sample.</li> <li>
<code>"micro"</code> gives each sample-class pair an equal contribution to the overall metric (except as a result of sample-weight). Rather than summing the metric per class, this sums the dividends and divisors that make up the per-class metrics to calculate an overall quotient. Micro-averaging may be preferred in multilabel settings, including multiclass classification where a majority class is to be ignored.</li> <li>
<code>"samples"</code> applies only to multilabel problems. It does not calculate a per-class measure, instead calculating the metric over the true and predicted classes for each sample in the evaluation data, and returning their (<code>sample_weight</code>-weighted) average.</li> <li>Selecting <code>average=None</code> will return an array with the score for each class.</li> </ul> <p>While multiclass data is provided to the metric, like binary targets, as an array of class labels, multilabel data is specified as an indicator matrix, in which cell <code>[i, j]</code> has value 1 if sample <code>i</code> has label <code>j</code> and value 0 otherwise.</p>   <h3 id="id2">3.3.2.2. Accuracy score</h3> <p id="accuracy-score">The <a class="reference internal" href="generated/sklearn.metrics.accuracy_score#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code>accuracy_score</code></a> function computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Accuracy_and_precision">accuracy</a>, either the fraction (default) or the count (normalize=False) of correct predictions.</p> <p>In multilabel classification, the function returns the subset accuracy. If the entire set of predicted labels for a sample strictly match with the true set of labels, then the subset accuracy is 1.0; otherwise it is 0.0.</p> <p>If <span class="math">\(\hat{y}_i\)</span> is the predicted value of the <span class="math">\(i\)</span>-th sample and <span class="math">\(y_i\)</span> is the corresponding true value, then the fraction of correct predictions over <span class="math">\(n_\text{samples}\)</span> is defined as</p> <div class="math"> \[\texttt{accuracy}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples}-1} 1(\hat{y}_i = y_i)\]</div> <p>where <span class="math">\(1(x)\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">indicator function</a>.</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import accuracy_score
&gt;&gt;&gt; y_pred = [0, 2, 1, 3]
&gt;&gt;&gt; y_true = [0, 1, 2, 3]
&gt;&gt;&gt; accuracy_score(y_true, y_pred)
0.5
&gt;&gt;&gt; accuracy_score(y_true, y_pred, normalize=False)
2
</pre> <p>In the multilabel case with binary label indicators:</p> <pre data-language="python">&gt;&gt;&gt; accuracy_score(np.array([[0, 1], [1, 1]]), np.ones((2, 2)))
0.5
</pre> <div class="topic"> <p class="topic-title first">Example:</p> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/feature_selection/plot_permutation_test_for_classification#sphx-glr-auto-examples-feature-selection-plot-permutation-test-for-classification-py"><span class="std std-ref">Test with permutations the significance of a classification score</span></a> for an example of accuracy score usage using permutations of the dataset.</li> </ul> </div>   <h3 id="id3">3.3.2.3. Balanced accuracy score</h3> <p id="balanced-accuracy-score">The <a class="reference internal" href="generated/sklearn.metrics.balanced_accuracy_score#sklearn.metrics.balanced_accuracy_score" title="sklearn.metrics.balanced_accuracy_score"><code>balanced_accuracy_score</code></a> function computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Accuracy_and_precision">balanced accuracy</a>, which avoids inflated performance estimates on imbalanced datasets. It is the macro-average of recall scores per class or, equivalently, raw accuracy where each sample is weighted according to the inverse prevalence of its true class. Thus for balanced datasets, the score is equal to accuracy.</p> <p>In the binary case, balanced accuracy is equal to the arithmetic mean of <a class="reference external" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">sensitivity</a> (true positive rate) and <a class="reference external" href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity">specificity</a> (true negative rate), or the area under the ROC curve with binary predictions rather than scores.</p> <p>If the classifier performs equally well on either class, this term reduces to the conventional accuracy (i.e., the number of correct predictions divided by the total number of predictions).</p> <p>In contrast, if the conventional accuracy is above chance only because the classifier takes advantage of an imbalanced test set, then the balanced accuracy, as appropriate, will drop to <span class="math">\(\frac{1}{\text{n\_classes}}\)</span>.</p> <p>The score ranges from 0 to 1, or when <code>adjusted=True</code> is used, it rescaled to the range <span class="math">\(\frac{1}{1 - \text{n\_classes}}\)</span> to 1, inclusive, with performance at random scoring 0.</p> <p>If <span class="math">\(y_i\)</span> is the true value of the <span class="math">\(i\)</span>-th sample, and <span class="math">\(w_i\)</span> is the corresponding sample weight, then we adjust the sample weight to:</p> <div class="math"> \[\hat{w}_i = \frac{w_i}{\sum_j{1(y_j = y_i) w_j}}\]</div> <p>where <span class="math">\(1(x)\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">indicator function</a>. Given predicted <span class="math">\(\hat{y}_i\)</span> for sample <span class="math">\(i\)</span>, balanced accuracy is defined as:</p> <div class="math"> \[\texttt{balanced-accuracy}(y, \hat{y}, w) = \frac{1}{\sum{\hat{w}_i}} \sum_i 1(\hat{y}_i = y_i) \hat{w}_i\]</div> <p>With <code>adjusted=True</code>, balanced accuracy reports the relative increase from <span class="math">\(\texttt{balanced-accuracy}(y, \mathbf{0}, w) = \frac{1}{\text{n\_classes}}\)</span>. In the binary case, this is also known as <a class="reference external" href="https://en.wikipedia.org/wiki/Youden%27s_J_statistic">*Youden’s J statistic*</a>, or <em>informedness</em>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>The multiclass definition here seems the most reasonable extension of the metric used in binary classification, though there is no certain consensus in the literature:</p> <ul class="last simple"> <li>Our definition: <a class="reference internal" href="#mosley2013" id="id5">[Mosley2013]</a>, <a class="reference internal" href="#kelleher2015" id="id6">[Kelleher2015]</a> and <a class="reference internal" href="#guyon2015" id="id7">[Guyon2015]</a>, where <a class="reference internal" href="#guyon2015" id="id8">[Guyon2015]</a> adopt the adjusted version to ensure that random predictions have a score of <span class="math">\(0\)</span> and perfect predictions have a score of <span class="math">\(1\)</span>..</li> <li>Class balanced accuracy as described in <a class="reference internal" href="#mosley2013" id="id9">[Mosley2013]</a>: the minimum between the precision and the recall for each class is computed. Those values are then averaged over the total number of classes to get the balanced accuracy.</li> <li>Balanced Accuracy as described in <a class="reference internal" href="#urbanowicz2015" id="id10">[Urbanowicz2015]</a>: the average of sensitivity and specificity is computed for each class and then averaged over total number of classes.</li> </ul> </div> <div class="topic"> <p class="topic-title first">References:</p> <table class="docutils citation" frame="void" id="guyon2015" rules="none">   <tr>
<td class="label">[Guyon2015]</td>
<td>
<em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id8">2</a>)</em> I. Guyon, K. Bennett, G. Cawley, H.J. Escalante, S. Escalera, T.K. Ho, N. Macià, B. Ray, M. Saeed, A.R. Statnikov, E. Viegas, <a class="reference external" href="http://ieeexplore.ieee.org/document/7280767/">Design of the 2015 ChaLearn AutoML Challenge</a>, IJCNN 2015.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="mosley2013" rules="none">   <tr>
<td class="label">[Mosley2013]</td>
<td>
<em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id9">2</a>)</em> L. Mosley, <a class="reference external" href="http://lib.dr.iastate.edu/etd/13537/">A balanced approach to the multi-class imbalance problem</a>, IJCV 2010.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="kelleher2015" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id6">[Kelleher2015]</a></td>
<td>John. D. Kelleher, Brian Mac Namee, Aoife D’Arcy, <a class="reference external" href="https://mitpress.mit.edu/books/fundamentals-machine-learning-predictive-data-analytics">Fundamentals of Machine Learning for Predictive Data Analytics: Algorithms, Worked Examples, and Case Studies</a>, 2015.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="urbanowicz2015" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id10">[Urbanowicz2015]</a></td>
<td>Urbanowicz R.J., Moore, J.H. <a class="reference external" href="https://doi.org/10.1007/s12065-015-0128-8">ExSTraCS 2.0: description and evaluation of a scalable learning classifier system</a>, Evol. Intel. (2015) 8: 89.</td>
</tr>  </table> </div>   <h3 id="cohen-kappa">3.3.2.4. Cohen’s kappa</h3> <p id="cohen-s-kappa">The function <a class="reference internal" href="generated/sklearn.metrics.cohen_kappa_score#sklearn.metrics.cohen_kappa_score" title="sklearn.metrics.cohen_kappa_score"><code>cohen_kappa_score</code></a> computes <a class="reference external" href="https://en.wikipedia.org/wiki/Cohen%27s_kappa">Cohen’s kappa</a> statistic. This measure is intended to compare labelings by different human annotators, not a classifier versus a ground truth.</p> <p>The kappa score (see docstring) is a number between -1 and 1. Scores above .8 are generally considered good agreement; zero or lower means no agreement (practically random labels).</p> <p>Kappa scores can be computed for binary or multiclass problems, but not for multilabel problems (except by manually computing a per-label score) and not for more than two annotators.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import cohen_kappa_score
&gt;&gt;&gt; y_true = [2, 0, 2, 2, 0, 1]
&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 0, 2]
&gt;&gt;&gt; cohen_kappa_score(y_true, y_pred)
0.4285714285714286
</pre>   <h3 id="id12">3.3.2.5. Confusion matrix</h3> <p id="confusion-matrix">The <a class="reference internal" href="generated/sklearn.metrics.confusion_matrix#sklearn.metrics.confusion_matrix" title="sklearn.metrics.confusion_matrix"><code>confusion_matrix</code></a> function evaluates classification accuracy by computing the confusion matrix with each row corresponding to the true class &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Confusion_matrix">https://en.wikipedia.org/wiki/Confusion_matrix</a>&gt;`_. (Wikipedia and other references may use different convention for axes.)</p> <p>By definition, entry <span class="math">\(i, j\)</span> in a confusion matrix is the number of observations actually in group <span class="math">\(i\)</span>, but predicted to be in group <span class="math">\(j\)</span>. Here is an example:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import confusion_matrix
&gt;&gt;&gt; y_true = [2, 0, 2, 2, 0, 1]
&gt;&gt;&gt; y_pred = [0, 0, 2, 2, 0, 2]
&gt;&gt;&gt; confusion_matrix(y_true, y_pred)
array([[2, 0, 0],
       [0, 0, 1],
       [1, 0, 2]])
</pre> <p>Here is a visual representation of such a confusion matrix (this figure comes from the <a class="reference internal" href="../auto_examples/model_selection/plot_confusion_matrix#sphx-glr-auto-examples-model-selection-plot-confusion-matrix-py"><span class="std std-ref">Confusion matrix</span></a> example):</p> <a class="reference external image-reference" href="../auto_examples/model_selection/plot_confusion_matrix"><img alt="../_images/sphx_glr_plot_confusion_matrix_0011.png" class="align-center" src="data:image/png;base64,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" style="width: 480.0px; height: 360.0px;"></a> <p>For binary problems, we can get counts of true negatives, false positives, false negatives and true positives as follows:</p> <pre data-language="python">&gt;&gt;&gt; y_true = [0, 0, 0, 1, 1, 1, 1, 1]
&gt;&gt;&gt; y_pred = [0, 1, 0, 1, 0, 1, 0, 1]
&gt;&gt;&gt; tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()
&gt;&gt;&gt; tn, fp, fn, tp
(2, 1, 2, 3)
</pre> <div class="topic"> <p class="topic-title first">Example:</p> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_confusion_matrix#sphx-glr-auto-examples-model-selection-plot-confusion-matrix-py"><span class="std std-ref">Confusion matrix</span></a> for an example of using a confusion matrix to evaluate classifier output quality.</li> <li>See <a class="reference internal" href="../auto_examples/classification/plot_digits_classification#sphx-glr-auto-examples-classification-plot-digits-classification-py"><span class="std std-ref">Recognizing hand-written digits</span></a> for an example of using a confusion matrix to classify hand-written digits.</li> <li>See <a class="reference internal" href="../auto_examples/text/plot_document_classification_20newsgroups#sphx-glr-auto-examples-text-plot-document-classification-20newsgroups-py"><span class="std std-ref">Classification of text documents using sparse features</span></a> for an example of using a confusion matrix to classify text documents.</li> </ul> </div>   <h3 id="id13">3.3.2.6. Classification report</h3> <p id="classification-report">The <a class="reference internal" href="generated/sklearn.metrics.classification_report#sklearn.metrics.classification_report" title="sklearn.metrics.classification_report"><code>classification_report</code></a> function builds a text report showing the main classification metrics. Here is a small example with custom <code>target_names</code> and inferred labels:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import classification_report
&gt;&gt;&gt; y_true = [0, 1, 2, 2, 0]
&gt;&gt;&gt; y_pred = [0, 0, 2, 1, 0]
&gt;&gt;&gt; target_names = ['class 0', 'class 1', 'class 2']
&gt;&gt;&gt; print(classification_report(y_true, y_pred, target_names=target_names))
              precision    recall  f1-score   support

     class 0       0.67      1.00      0.80         2
     class 1       0.00      0.00      0.00         1
     class 2       1.00      0.50      0.67         2

   micro avg       0.60      0.60      0.60         5
   macro avg       0.56      0.50      0.49         5
weighted avg       0.67      0.60      0.59         5
</pre> <div class="topic"> <p class="topic-title first">Example:</p> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/classification/plot_digits_classification#sphx-glr-auto-examples-classification-plot-digits-classification-py"><span class="std std-ref">Recognizing hand-written digits</span></a> for an example of classification report usage for hand-written digits.</li> <li>See <a class="reference internal" href="../auto_examples/text/plot_document_classification_20newsgroups#sphx-glr-auto-examples-text-plot-document-classification-20newsgroups-py"><span class="std std-ref">Classification of text documents using sparse features</span></a> for an example of classification report usage for text documents.</li> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_grid_search_digits#sphx-glr-auto-examples-model-selection-plot-grid-search-digits-py"><span class="std std-ref">Parameter estimation using grid search with cross-validation</span></a> for an example of classification report usage for grid search with nested cross-validation.</li> </ul> </div>   <h3 id="id14">3.3.2.7. Hamming loss</h3> <p id="hamming-loss">The <a class="reference internal" href="generated/sklearn.metrics.hamming_loss#sklearn.metrics.hamming_loss" title="sklearn.metrics.hamming_loss"><code>hamming_loss</code></a> computes the average Hamming loss or <a class="reference external" href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a> between two sets of samples.</p> <p>If <span class="math">\(\hat{y}_j\)</span> is the predicted value for the <span class="math">\(j\)</span>-th label of a given sample, <span class="math">\(y_j\)</span> is the corresponding true value, and <span class="math">\(n_\text{labels}\)</span> is the number of classes or labels, then the Hamming loss <span class="math">\(L_{Hamming}\)</span> between two samples is defined as:</p> <div class="math"> \[L_{Hamming}(y, \hat{y}) = \frac{1}{n_\text{labels}} \sum_{j=0}^{n_\text{labels} - 1} 1(\hat{y}_j \not= y_j)\]</div> <p>where <span class="math">\(1(x)\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">indicator function</a>.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import hamming_loss
&gt;&gt;&gt; y_pred = [1, 2, 3, 4]
&gt;&gt;&gt; y_true = [2, 2, 3, 4]
&gt;&gt;&gt; hamming_loss(y_true, y_pred)
0.25
</pre> <p>In the multilabel case with binary label indicators:</p> <pre data-language="python">&gt;&gt;&gt; hamming_loss(np.array([[0, 1], [1, 1]]), np.zeros((2, 2)))
0.75
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">In multiclass classification, the Hamming loss corresponds to the Hamming distance between <code>y_true</code> and <code>y_pred</code> which is similar to the <a class="reference internal" href="#zero-one-loss"><span class="std std-ref">Zero one loss</span></a> function. However, while zero-one loss penalizes prediction sets that do not strictly match true sets, the Hamming loss penalizes individual labels. Thus the Hamming loss, upper bounded by the zero-one loss, is always between zero and one, inclusive; and predicting a proper subset or superset of the true labels will give a Hamming loss between zero and one, exclusive.</p> </div>   <h3 id="jaccard-similarity-score">3.3.2.8. Jaccard similarity coefficient score</h3> <p id="jaccard-similarity-coefficient-score">The <a class="reference internal" href="generated/sklearn.metrics.jaccard_similarity_score#sklearn.metrics.jaccard_similarity_score" title="sklearn.metrics.jaccard_similarity_score"><code>jaccard_similarity_score</code></a> function computes the average (default) or sum of <a class="reference external" href="https://en.wikipedia.org/wiki/Jaccard_index">Jaccard similarity coefficients</a>, also called the Jaccard index, between pairs of label sets.</p> <p>The Jaccard similarity coefficient of the <span class="math">\(i\)</span>-th samples, with a ground truth label set <span class="math">\(y_i\)</span> and predicted label set <span class="math">\(\hat{y}_i\)</span>, is defined as</p> <div class="math"> \[J(y_i, \hat{y}_i) = \frac{|y_i \cap \hat{y}_i|}{|y_i \cup \hat{y}_i|}.\]</div> <p>In binary and multiclass classification, the Jaccard similarity coefficient score is equal to the classification accuracy.</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import jaccard_similarity_score
&gt;&gt;&gt; y_pred = [0, 2, 1, 3]
&gt;&gt;&gt; y_true = [0, 1, 2, 3]
&gt;&gt;&gt; jaccard_similarity_score(y_true, y_pred)
0.5
&gt;&gt;&gt; jaccard_similarity_score(y_true, y_pred, normalize=False)
2
</pre> <p>In the multilabel case with binary label indicators:</p> <pre data-language="python">&gt;&gt;&gt; jaccard_similarity_score(np.array([[0, 1], [1, 1]]), np.ones((2, 2)))
0.75
</pre>   <h3 id="precision-recall-f-measure-metrics">3.3.2.9. Precision, recall and F-measures</h3> <p id="precision-recall-and-f-measures">Intuitively, <a class="reference external" href="https://en.wikipedia.org/wiki/Precision_and_recall#Precision">precision</a> is the ability of the classifier not to label as positive a sample that is negative, and <a class="reference external" href="https://en.wikipedia.org/wiki/Precision_and_recall#Recall">recall</a> is the ability of the classifier to find all the positive samples.</p> <p>The <a class="reference external" href="https://en.wikipedia.org/wiki/F1_score">F-measure</a> (<span class="math">\(F_\beta\)</span> and <span class="math">\(F_1\)</span> measures) can be interpreted as a weighted harmonic mean of the precision and recall. A <span class="math">\(F_\beta\)</span> measure reaches its best value at 1 and its worst score at 0. With <span class="math">\(\beta = 1\)</span>, <span class="math">\(F_\beta\)</span> and <span class="math">\(F_1\)</span> are equivalent, and the recall and the precision are equally important.</p> <p>The <a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code>precision_recall_curve</code></a> computes a precision-recall curve from the ground truth label and a score given by the classifier by varying a decision threshold.</p> <p>The <a class="reference internal" href="generated/sklearn.metrics.average_precision_score#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a> function computes the <a class="reference external" href="http://en.wikipedia.org/w/index.php?title=Information_retrieval&amp;oldid=793358396#Average_precision">average precision</a> (AP) from prediction scores. The value is between 0 and 1 and higher is better. AP is defined as</p> <div class="math"> \[\text{AP} = \sum_n (R_n - R_{n-1}) P_n\]</div> <p>where <span class="math">\(P_n\)</span> and <span class="math">\(R_n\)</span> are the precision and recall at the nth threshold. With random predictions, the AP is the fraction of positive samples.</p> <p>References <a class="reference internal" href="#manning2008" id="id16">[Manning2008]</a> and <a class="reference internal" href="#everingham2010" id="id17">[Everingham2010]</a> present alternative variants of AP that interpolate the precision-recall curve. Currently, <a class="reference internal" href="generated/sklearn.metrics.average_precision_score#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a> does not implement any interpolated variant. References <a class="reference internal" href="#davis2006" id="id18">[Davis2006]</a> and <a class="reference internal" href="#flach2015" id="id19">[Flach2015]</a> describe why a linear interpolation of points on the precision-recall curve provides an overly-optimistic measure of classifier performance. This linear interpolation is used when computing area under the curve with the trapezoidal rule in <a class="reference internal" href="generated/sklearn.metrics.auc#sklearn.metrics.auc" title="sklearn.metrics.auc"><code>auc</code></a>.</p> <p>Several functions allow you to analyze the precision, recall and F-measures score:</p> <table class="longtable docutils">   <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.average_precision_score#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a>(y_true, y_score[, …])</td> <td>Compute average precision (AP) from prediction scores</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.f1_score#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>f1_score</code></a>(y_true, y_pred[, labels, …])</td> <td>Compute the F1 score, also known as balanced F-score or F-measure</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.fbeta_score#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code>fbeta_score</code></a>(y_true, y_pred, beta[, labels, …])</td> <td>Compute the F-beta score</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code>precision_recall_curve</code></a>(y_true, probas_pred)</td> <td>Compute precision-recall pairs for different probability thresholds</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><code>precision_recall_fscore_support</code></a>(y_true, y_pred)</td> <td>Compute precision, recall, F-measure and support for each class</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.precision_score#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code>precision_score</code></a>(y_true, y_pred[, labels, …])</td> <td>Compute the precision</td> </tr> <tr>
<td>
<a class="reference internal" href="generated/sklearn.metrics.recall_score#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code>recall_score</code></a>(y_true, y_pred[, labels, …])</td> <td>Compute the recall</td> </tr>  </table> <p>Note that the <a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code>precision_recall_curve</code></a> function is restricted to the binary case. The <a class="reference internal" href="generated/sklearn.metrics.average_precision_score#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a> function works only in binary classification and multilabel indicator format.</p> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/text/plot_document_classification_20newsgroups#sphx-glr-auto-examples-text-plot-document-classification-20newsgroups-py"><span class="std std-ref">Classification of text documents using sparse features</span></a> for an example of <a class="reference internal" href="generated/sklearn.metrics.f1_score#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>f1_score</code></a> usage to classify text documents.</li> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_grid_search_digits#sphx-glr-auto-examples-model-selection-plot-grid-search-digits-py"><span class="std std-ref">Parameter estimation using grid search with cross-validation</span></a> for an example of <a class="reference internal" href="generated/sklearn.metrics.precision_score#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code>precision_score</code></a> and <a class="reference internal" href="generated/sklearn.metrics.recall_score#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code>recall_score</code></a> usage to estimate parameters using grid search with nested cross-validation.</li> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_precision_recall#sphx-glr-auto-examples-model-selection-plot-precision-recall-py"><span class="std std-ref">Precision-Recall</span></a> for an example of <a class="reference internal" href="generated/sklearn.metrics.precision_recall_curve#sklearn.metrics.precision_recall_curve" title="sklearn.metrics.precision_recall_curve"><code>precision_recall_curve</code></a> usage to evaluate classifier output quality.</li> </ul> </div> <div class="topic"> <p class="topic-title first">References:</p> <table class="docutils citation" frame="void" id="manning2008" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id16">[Manning2008]</a></td>
<td>C.D. Manning, P. Raghavan, H. Schütze, <a class="reference external" href="http://nlp.stanford.edu/IR-book/html/htmledition/evaluation-of-ranked-retrieval-results-1.html">Introduction to Information Retrieval</a>, 2008.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="everingham2010" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id17">[Everingham2010]</a></td>
<td>M. Everingham, L. Van Gool, C.K.I. Williams, J. Winn, A. Zisserman, <a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.157.5766&amp;rep=rep1&amp;type=pdf">The Pascal Visual Object Classes (VOC) Challenge</a>, IJCV 2010.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="davis2006" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id18">[Davis2006]</a></td>
<td>J. Davis, M. Goadrich, <a class="reference external" href="http://www.machinelearning.org/proceedings/icml2006/030_The_Relationship_Bet.pdf">The Relationship Between Precision-Recall and ROC Curves</a>, ICML 2006.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="flach2015" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id19">[Flach2015]</a></td>
<td>P.A. Flach, M. Kull, <a class="reference external" href="http://papers.nips.cc/paper/5867-precision-recall-gain-curves-pr-analysis-done-right.pdf">Precision-Recall-Gain Curves: PR Analysis Done Right</a>, NIPS 2015.</td>
</tr>  </table> </div>  <h4 id="binary-classification">3.3.2.9.1. Binary classification</h4> <p>In a binary classification task, the terms ‘’positive’’ and ‘’negative’’ refer to the classifier’s prediction, and the terms ‘’true’’ and ‘’false’’ refer to whether that prediction corresponds to the external judgment (sometimes known as the ‘’observation’‘). Given these definitions, we can formulate the following table:</p> <table class="docutils">   <tr>
<td> </td> <td colspan="2">Actual class (observation)</td> </tr> <tr>
<td rowspan="2">Predicted class (expectation)</td> <td>tp (true positive) Correct result</td> <td>fp (false positive) Unexpected result</td> </tr> <tr>
<td>fn (false negative) Missing result</td> <td>tn (true negative) Correct absence of result</td> </tr>  </table> <p>In this context, we can define the notions of precision, recall and F-measure:</p> <div class="math"> \[\text{precision} = \frac{tp}{tp + fp},\]</div> <div class="math"> \[\text{recall} = \frac{tp}{tp + fn},\]</div> <div class="math"> \[F_\beta = (1 + \beta^2) \frac{\text{precision} \times \text{recall}}{\beta^2 \text{precision} + \text{recall}}.\]</div> <p>Here are some small examples in binary classification:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import metrics
&gt;&gt;&gt; y_pred = [0, 1, 0, 0]
&gt;&gt;&gt; y_true = [0, 1, 0, 1]
&gt;&gt;&gt; metrics.precision_score(y_true, y_pred)
1.0
&gt;&gt;&gt; metrics.recall_score(y_true, y_pred)
0.5
&gt;&gt;&gt; metrics.f1_score(y_true, y_pred)  
0.66...
&gt;&gt;&gt; metrics.fbeta_score(y_true, y_pred, beta=0.5)  
0.83...
&gt;&gt;&gt; metrics.fbeta_score(y_true, y_pred, beta=1)  
0.66...
&gt;&gt;&gt; metrics.fbeta_score(y_true, y_pred, beta=2) 
0.55...
&gt;&gt;&gt; metrics.precision_recall_fscore_support(y_true, y_pred, beta=0.5)  
(array([0.66..., 1.        ]), array([1. , 0.5]), array([0.71..., 0.83...]), array([2, 2]))


&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import precision_recall_curve
&gt;&gt;&gt; from sklearn.metrics import average_precision_score
&gt;&gt;&gt; y_true = np.array([0, 0, 1, 1])
&gt;&gt;&gt; y_scores = np.array([0.1, 0.4, 0.35, 0.8])
&gt;&gt;&gt; precision, recall, threshold = precision_recall_curve(y_true, y_scores)
&gt;&gt;&gt; precision  
array([0.66..., 0.5       , 1.        , 1.        ])
&gt;&gt;&gt; recall
array([1. , 0.5, 0.5, 0. ])
&gt;&gt;&gt; threshold
array([0.35, 0.4 , 0.8 ])
&gt;&gt;&gt; average_precision_score(y_true, y_scores)  
0.83...
</pre>   <h4 id="multiclass-and-multilabel-classification">3.3.2.9.2. Multiclass and multilabel classification</h4> <p>In multiclass and multilabel classification task, the notions of precision, recall, and F-measures can be applied to each label independently. There are a few ways to combine results across labels, specified by the <code>average</code> argument to the <a class="reference internal" href="generated/sklearn.metrics.average_precision_score#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a> (multilabel only), <a class="reference internal" href="generated/sklearn.metrics.f1_score#sklearn.metrics.f1_score" title="sklearn.metrics.f1_score"><code>f1_score</code></a>, <a class="reference internal" href="generated/sklearn.metrics.fbeta_score#sklearn.metrics.fbeta_score" title="sklearn.metrics.fbeta_score"><code>fbeta_score</code></a>, <a class="reference internal" href="generated/sklearn.metrics.precision_recall_fscore_support#sklearn.metrics.precision_recall_fscore_support" title="sklearn.metrics.precision_recall_fscore_support"><code>precision_recall_fscore_support</code></a>, <a class="reference internal" href="generated/sklearn.metrics.precision_score#sklearn.metrics.precision_score" title="sklearn.metrics.precision_score"><code>precision_score</code></a> and <a class="reference internal" href="generated/sklearn.metrics.recall_score#sklearn.metrics.recall_score" title="sklearn.metrics.recall_score"><code>recall_score</code></a> functions, as described <a class="reference internal" href="#average"><span class="std std-ref">above</span></a>. Note that if all labels are included, “micro”-averaging in a multiclass setting will produce precision, recall and <span class="math">\(F\)</span> that are all identical to accuracy. Also note that “weighted” averaging may produce an F-score that is not between precision and recall.</p> <p>To make this more explicit, consider the following notation:</p> <ul class="simple"> <li>
<span class="math">\(y\)</span> the set of <em>predicted</em> <span class="math">\((sample, label)\)</span> pairs</li> <li>
<span class="math">\(\hat{y}\)</span> the set of <em>true</em> <span class="math">\((sample, label)\)</span> pairs</li> <li>
<span class="math">\(L\)</span> the set of labels</li> <li>
<span class="math">\(S\)</span> the set of samples</li> <li>
<span class="math">\(y_s\)</span> the subset of <span class="math">\(y\)</span> with sample <span class="math">\(s\)</span>, i.e. <span class="math">\(y_s := \left\{(s', l) \in y | s' = s\right\}\)</span>
</li> <li>
<span class="math">\(y_l\)</span> the subset of <span class="math">\(y\)</span> with label <span class="math">\(l\)</span>
</li> <li>similarly, <span class="math">\(\hat{y}_s\)</span> and <span class="math">\(\hat{y}_l\)</span> are subsets of <span class="math">\(\hat{y}\)</span>
</li> <li><span class="math">\(P(A, B) := \frac{\left| A \cap B \right|}{\left|A\right|}\)</span></li> <li>
<span class="math">\(R(A, B) := \frac{\left| A \cap B \right|}{\left|B\right|}\)</span> (Conventions vary on handling <span class="math">\(B = \emptyset\)</span>; this implementation uses <span class="math">\(R(A, B):=0\)</span>, and similar for <span class="math">\(P\)</span>.)</li> <li><span class="math">\(F_\beta(A, B) := \left(1 + \beta^2\right) \frac{P(A, B) \times R(A, B)}{\beta^2 P(A, B) + R(A, B)}\)</span></li> </ul> <p>Then the metrics are defined as:</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head"><code>average</code></th> <th class="head">Precision</th> <th class="head">Recall</th> <th class="head">F_beta</th> </tr> </thead>  <tr>
<td><code>"micro"</code></td> <td><span class="math">\(P(y, \hat{y})\)</span></td> <td><span class="math">\(R(y, \hat{y})\)</span></td> <td><span class="math">\(F_\beta(y, \hat{y})\)</span></td> </tr> <tr>
<td><code>"samples"</code></td> <td><span class="math">\(\frac{1}{\left|S\right|} \sum_{s \in S} P(y_s, \hat{y}_s)\)</span></td> <td><span class="math">\(\frac{1}{\left|S\right|} \sum_{s \in S} R(y_s, \hat{y}_s)\)</span></td> <td><span class="math">\(\frac{1}{\left|S\right|} \sum_{s \in S} F_\beta(y_s, \hat{y}_s)\)</span></td> </tr> <tr>
<td><code>"macro"</code></td> <td><span class="math">\(\frac{1}{\left|L\right|} \sum_{l \in L} P(y_l, \hat{y}_l)\)</span></td> <td><span class="math">\(\frac{1}{\left|L\right|} \sum_{l \in L} R(y_l, \hat{y}_l)\)</span></td> <td><span class="math">\(\frac{1}{\left|L\right|} \sum_{l \in L} F_\beta(y_l, \hat{y}_l)\)</span></td> </tr> <tr>
<td><code>"weighted"</code></td> <td><span class="math">\(\frac{1}{\sum_{l \in L} \left|\hat{y}_l\right|} \sum_{l \in L} \left|\hat{y}_l\right| P(y_l, \hat{y}_l)\)</span></td> <td><span class="math">\(\frac{1}{\sum_{l \in L} \left|\hat{y}_l\right|} \sum_{l \in L} \left|\hat{y}_l\right| R(y_l, \hat{y}_l)\)</span></td> <td><span class="math">\(\frac{1}{\sum_{l \in L} \left|\hat{y}_l\right|} \sum_{l \in L} \left|\hat{y}_l\right| F_\beta(y_l, \hat{y}_l)\)</span></td> </tr> <tr>
<td><code>None</code></td> <td><span class="math">\(\langle P(y_l, \hat{y}_l) | l \in L \rangle\)</span></td> <td><span class="math">\(\langle R(y_l, \hat{y}_l) | l \in L \rangle\)</span></td> <td><span class="math">\(\langle F_\beta(y_l, \hat{y}_l) | l \in L \rangle\)</span></td> </tr>  </table> <pre data-language="python">&gt;&gt;&gt; from sklearn import metrics
&gt;&gt;&gt; y_true = [0, 1, 2, 0, 1, 2]
&gt;&gt;&gt; y_pred = [0, 2, 1, 0, 0, 1]
&gt;&gt;&gt; metrics.precision_score(y_true, y_pred, average='macro')  
0.22...
&gt;&gt;&gt; metrics.recall_score(y_true, y_pred, average='micro')
... 
0.33...
&gt;&gt;&gt; metrics.f1_score(y_true, y_pred, average='weighted')  
0.26...
&gt;&gt;&gt; metrics.fbeta_score(y_true, y_pred, average='macro', beta=0.5)  
0.23...
&gt;&gt;&gt; metrics.precision_recall_fscore_support(y_true, y_pred, beta=0.5, average=None)
... 
(array([0.66..., 0.        , 0.        ]), array([1., 0., 0.]), array([0.71..., 0.        , 0.        ]), array([2, 2, 2]...))
</pre> <p>For multiclass classification with a “negative class”, it is possible to exclude some labels:</p> <pre data-language="python">&gt;&gt;&gt; metrics.recall_score(y_true, y_pred, labels=[1, 2], average='micro')
... # excluding 0, no labels were correctly recalled
0.0
</pre> <p>Similarly, labels not present in the data sample may be accounted for in macro-averaging.</p> <pre data-language="python">&gt;&gt;&gt; metrics.precision_score(y_true, y_pred, labels=[0, 1, 2, 3], average='macro')
... 
0.166...
</pre>    <h3 id="id20">3.3.2.10. Hinge loss</h3> <p id="hinge-loss">The <a class="reference internal" href="generated/sklearn.metrics.hinge_loss#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code>hinge_loss</code></a> function computes the average distance between the model and the data using <a class="reference external" href="https://en.wikipedia.org/wiki/Hinge_loss">hinge loss</a>, a one-sided metric that considers only prediction errors. (Hinge loss is used in maximal margin classifiers such as support vector machines.)</p> <p>If the labels are encoded with +1 and -1, <span class="math">\(y\)</span>: is the true value, and <span class="math">\(w\)</span> is the predicted decisions as output by <code>decision_function</code>, then the hinge loss is defined as:</p> <div class="math"> \[L_\text{Hinge}(y, w) = \max\left\{1 - wy, 0\right\} = \left|1 - wy\right|_+\]</div> <p>If there are more than two labels, <a class="reference internal" href="generated/sklearn.metrics.hinge_loss#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code>hinge_loss</code></a> uses a multiclass variant due to Crammer &amp; Singer. <a class="reference external" href="http://jmlr.csail.mit.edu/papers/volume2/crammer01a/crammer01a.pdf">Here</a> is the paper describing it.</p> <p>If <span class="math">\(y_w\)</span> is the predicted decision for true label and <span class="math">\(y_t\)</span> is the maximum of the predicted decisions for all other labels, where predicted decisions are output by decision function, then multiclass hinge loss is defined by:</p> <div class="math"> \[L_\text{Hinge}(y_w, y_t) = \max\left\{1 + y_t - y_w, 0\right\}\]</div> <p>Here a small example demonstrating the use of the <a class="reference internal" href="generated/sklearn.metrics.hinge_loss#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code>hinge_loss</code></a> function with a svm classifier in a binary class problem:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn import svm
&gt;&gt;&gt; from sklearn.metrics import hinge_loss
&gt;&gt;&gt; X = [[0], [1]]
&gt;&gt;&gt; y = [-1, 1]
&gt;&gt;&gt; est = svm.LinearSVC(random_state=0)
&gt;&gt;&gt; est.fit(X, y)
LinearSVC(C=1.0, class_weight=None, dual=True, fit_intercept=True,
     intercept_scaling=1, loss='squared_hinge', max_iter=1000,
     multi_class='ovr', penalty='l2', random_state=0, tol=0.0001,
     verbose=0)
&gt;&gt;&gt; pred_decision = est.decision_function([[-2], [3], [0.5]])
&gt;&gt;&gt; pred_decision  
array([-2.18...,  2.36...,  0.09...])
&gt;&gt;&gt; hinge_loss([-1, 1, 1], pred_decision)  
0.3...
</pre> <p>Here is an example demonstrating the use of the <a class="reference internal" href="generated/sklearn.metrics.hinge_loss#sklearn.metrics.hinge_loss" title="sklearn.metrics.hinge_loss"><code>hinge_loss</code></a> function with a svm classifier in a multiclass problem:</p> <pre data-language="python">&gt;&gt;&gt; X = np.array([[0], [1], [2], [3]])
&gt;&gt;&gt; Y = np.array([0, 1, 2, 3])
&gt;&gt;&gt; labels = np.array([0, 1, 2, 3])
&gt;&gt;&gt; est = svm.LinearSVC()
&gt;&gt;&gt; est.fit(X, Y)
LinearSVC(C=1.0, class_weight=None, dual=True, fit_intercept=True,
     intercept_scaling=1, loss='squared_hinge', max_iter=1000,
     multi_class='ovr', penalty='l2', random_state=None, tol=0.0001,
     verbose=0)
&gt;&gt;&gt; pred_decision = est.decision_function([[-1], [2], [3]])
&gt;&gt;&gt; y_true = [0, 2, 3]
&gt;&gt;&gt; hinge_loss(y_true, pred_decision, labels)  
0.56...
</pre>   <h3 id="id22">3.3.2.11. Log loss</h3> <p id="log-loss">Log loss, also called logistic regression loss or cross-entropy loss, is defined on probability estimates. It is commonly used in (multinomial) logistic regression and neural networks, as well as in some variants of expectation-maximization, and can be used to evaluate the probability outputs (<code>predict_proba</code>) of a classifier instead of its discrete predictions.</p> <p>For binary classification with a true label <span class="math">\(y \in \{0,1\}\)</span> and a probability estimate <span class="math">\(p = \operatorname{Pr}(y = 1)\)</span>, the log loss per sample is the negative log-likelihood of the classifier given the true label:</p> <div class="math"> \[L_{\log}(y, p) = -\log \operatorname{Pr}(y|p) = -(y \log (p) + (1 - y) \log (1 - p))\]</div> <p>This extends to the multiclass case as follows. Let the true labels for a set of samples be encoded as a 1-of-K binary indicator matrix <span class="math">\(Y\)</span>, i.e., <span class="math">\(y_{i,k} = 1\)</span> if sample <span class="math">\(i\)</span> has label <span class="math">\(k\)</span> taken from a set of <span class="math">\(K\)</span> labels. Let <span class="math">\(P\)</span> be a matrix of probability estimates, with <span class="math">\(p_{i,k} = \operatorname{Pr}(t_{i,k} = 1)\)</span>. Then the log loss of the whole set is</p> <div class="math"> \[L_{\log}(Y, P) = -\log \operatorname{Pr}(Y|P) = - \frac{1}{N} \sum_{i=0}^{N-1} \sum_{k=0}^{K-1} y_{i,k} \log p_{i,k}\]</div> <p>To see how this generalizes the binary log loss given above, note that in the binary case, <span class="math">\(p_{i,0} = 1 - p_{i,1}\)</span> and <span class="math">\(y_{i,0} = 1 - y_{i,1}\)</span>, so expanding the inner sum over <span class="math">\(y_{i,k} \in \{0,1\}\)</span> gives the binary log loss.</p> <p>The <a class="reference internal" href="generated/sklearn.metrics.log_loss#sklearn.metrics.log_loss" title="sklearn.metrics.log_loss"><code>log_loss</code></a> function computes log loss given a list of ground-truth labels and a probability matrix, as returned by an estimator’s <code>predict_proba</code> method.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import log_loss
&gt;&gt;&gt; y_true = [0, 0, 1, 1]
&gt;&gt;&gt; y_pred = [[.9, .1], [.8, .2], [.3, .7], [.01, .99]]
&gt;&gt;&gt; log_loss(y_true, y_pred)    
0.1738...
</pre> <p>The first <code>[.9, .1]</code> in <code>y_pred</code> denotes 90% probability that the first sample has label 0. The log loss is non-negative.</p>   <h3 id="matthews-corrcoef">3.3.2.12. Matthews correlation coefficient</h3> <p id="matthews-correlation-coefficient">The <a class="reference internal" href="generated/sklearn.metrics.matthews_corrcoef#sklearn.metrics.matthews_corrcoef" title="sklearn.metrics.matthews_corrcoef"><code>matthews_corrcoef</code></a> function computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Matthews_correlation_coefficient">Matthew’s correlation coefficient (MCC)</a> for binary classes. Quoting Wikipedia:</p>  “The Matthews correlation coefficient is used in machine learning as a measure of the quality of binary (two-class) classifications. It takes into account true and false positives and negatives and is generally regarded as a balanced measure which can be used even if the classes are of very different sizes. The MCC is in essence a correlation coefficient value between -1 and +1. A coefficient of +1 represents a perfect prediction, 0 an average random prediction and -1 an inverse prediction. The statistic is also known as the phi coefficient.” <p>In the binary (two-class) case, <span class="math">\(tp\)</span>, <span class="math">\(tn\)</span>, <span class="math">\(fp\)</span> and <span class="math">\(fn\)</span> are respectively the number of true positives, true negatives, false positives and false negatives, the MCC is defined as</p> <div class="math"> \[MCC = \frac{tp \times tn - fp \times fn}{\sqrt{(tp + fp)(tp + fn)(tn + fp)(tn + fn)}}.\]</div> <p>In the multiclass case, the Matthews correlation coefficient can be <a class="reference external" href="http://rk.kvl.dk/introduction/index.html">defined</a> in terms of a <a class="reference internal" href="generated/sklearn.metrics.confusion_matrix#sklearn.metrics.confusion_matrix" title="sklearn.metrics.confusion_matrix"><code>confusion_matrix</code></a> <span class="math">\(C\)</span> for <span class="math">\(K\)</span> classes. To simplify the definition consider the following intermediate variables:</p> <ul class="simple"> <li>
<span class="math">\(t_k=\sum_{i}^{K} C_{ik}\)</span> the number of times class <span class="math">\(k\)</span> truly occurred,</li> <li>
<span class="math">\(p_k=\sum_{i}^{K} C_{ki}\)</span> the number of times class <span class="math">\(k\)</span> was predicted,</li> <li>
<span class="math">\(c=\sum_{k}^{K} C_{kk}\)</span> the total number of samples correctly predicted,</li> <li>
<span class="math">\(s=\sum_{i}^{K} \sum_{j}^{K} C_{ij}\)</span> the total number of samples.</li> </ul> <p>Then the multiclass MCC is defined as:</p> <div class="math"> \[MCC = \frac{ c \times s - \sum_{k}^{K} p_k \times t_k }{\sqrt{ (s^2 - \sum_{k}^{K} p_k^2) \times (s^2 - \sum_{k}^{K} t_k^2) }}\]</div> <p>When there are more than two labels, the value of the MCC will no longer range between -1 and +1. Instead the minimum value will be somewhere between -1 and 0 depending on the number and distribution of ground true labels. The maximum value is always +1.</p> <p>Here is a small example illustrating the usage of the <a class="reference internal" href="generated/sklearn.metrics.matthews_corrcoef#sklearn.metrics.matthews_corrcoef" title="sklearn.metrics.matthews_corrcoef"><code>matthews_corrcoef</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import matthews_corrcoef
&gt;&gt;&gt; y_true = [+1, +1, +1, -1]
&gt;&gt;&gt; y_pred = [+1, -1, +1, +1]
&gt;&gt;&gt; matthews_corrcoef(y_true, y_pred)  
-0.33...
</pre>   <h3 id="roc-metrics">3.3.2.13. Receiver operating characteristic (ROC)</h3> <p id="receiver-operating-characteristic-roc">The function <a class="reference internal" href="generated/sklearn.metrics.roc_curve#sklearn.metrics.roc_curve" title="sklearn.metrics.roc_curve"><code>roc_curve</code></a> computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">receiver operating characteristic curve, or ROC curve</a>. Quoting Wikipedia :</p>  “A receiver operating characteristic (ROC), or simply ROC curve, is a graphical plot which illustrates the performance of a binary classifier system as its discrimination threshold is varied. It is created by plotting the fraction of true positives out of the positives (TPR = true positive rate) vs. the fraction of false positives out of the negatives (FPR = false positive rate), at various threshold settings. TPR is also known as sensitivity, and FPR is one minus the specificity or true negative rate.” <p>This function requires the true binary value and the target scores, which can either be probability estimates of the positive class, confidence values, or binary decisions. Here is a small example of how to use the <a class="reference internal" href="generated/sklearn.metrics.roc_curve#sklearn.metrics.roc_curve" title="sklearn.metrics.roc_curve"><code>roc_curve</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import roc_curve
&gt;&gt;&gt; y = np.array([1, 1, 2, 2])
&gt;&gt;&gt; scores = np.array([0.1, 0.4, 0.35, 0.8])
&gt;&gt;&gt; fpr, tpr, thresholds = roc_curve(y, scores, pos_label=2)
&gt;&gt;&gt; fpr
array([0. , 0. , 0.5, 0.5, 1. ])
&gt;&gt;&gt; tpr
array([0. , 0.5, 0.5, 1. , 1. ])
&gt;&gt;&gt; thresholds
array([1.8 , 0.8 , 0.4 , 0.35, 0.1 ])
</pre> <p>This figure shows an example of such an ROC curve:</p> <a class="reference external image-reference" href="../auto_examples/model_selection/plot_roc"><img alt="../_images/sphx_glr_plot_roc_0011.png" class="align-center" src="data:image/png;base64,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" style="width: 480.0px; height: 360.0px;"></a> <p>The <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a> function computes the area under the receiver operating characteristic (ROC) curve, which is also denoted by AUC or AUROC. By computing the area under the roc curve, the curve information is summarized in one number. For more information see the <a class="reference external" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve">Wikipedia article on AUC</a>.</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import roc_auc_score
&gt;&gt;&gt; y_true = np.array([0, 0, 1, 1])
&gt;&gt;&gt; y_scores = np.array([0.1, 0.4, 0.35, 0.8])
&gt;&gt;&gt; roc_auc_score(y_true, y_scores)
0.75
</pre> <p>In multi-label classification, the <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a> function is extended by averaging over the labels as <a class="reference internal" href="#average"><span class="std std-ref">above</span></a>.</p> <p>Compared to metrics such as the subset accuracy, the Hamming loss, or the F1 score, ROC doesn’t require optimizing a threshold for each label. The <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a> function can also be used in multi-class classification, if the predicted outputs have been binarized.</p> <p>In applications where a high false positive rate is not tolerable the parameter <code>max_fpr</code> of <a class="reference internal" href="generated/sklearn.metrics.roc_auc_score#sklearn.metrics.roc_auc_score" title="sklearn.metrics.roc_auc_score"><code>roc_auc_score</code></a> can be used to summarize the ROC curve up to the given limit.</p> <a class="reference external image-reference" href="../auto_examples/model_selection/plot_roc"><img alt="../_images/sphx_glr_plot_roc_0021.png" class="align-center" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAMAAAACDyzWAAAAOXRFWHRTb2Z0d2FyZQBtYXRwbG90bGliIHZlcnNpb24gMi4yLjMsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy8jFEQFAAAACXBIWXMAAA9hAAAPYQGoP6dpAAACUlBMVEX///90oO7/FJNkle3/mBsb///W1tbx8fEAAAD39/f/jAAAAIAA////SKofHx8LCwv+/v7c3NxcoO4HBwcCAgJfX1/9/f0oKCgFBQU/Pz8ODg5/f3/w8PD7+/skJCQaGhoWFhZPT0+/v7+vr6/k5ORaWlp6enri4uISEhLn5+e8vLzLy8uPj49UVFRKSkpubm5jY2MrKyvPz88vLy+fn5/Jycn5+fmMjIxoaGicnJze3t64uLj09PQQEBD29vfExMSZmZlGRkZCQkIyMjI4ODjT09Pg4OBra2vGxsaWlpY7Ozv/wOKJiYmTk5Nzc3Onp6fZ2dmtra01NTWFhYU9PT3t7e2pqal3d3eysrLCwsLS0tLq6ur/nihwcHD/Z7l8pvClpaVylda1tbWBgYFSUak4OJyrq6vV1dX/gREFBYJ0ieVxldZrjMqEhIRZne1ZhOH/XrWNjcYYGIxsbLa6ut3FxeKWlsso///g4PD/y+f/8/rU1NT/2avY1+vu7vcODoc/P6D/5fNllu3/fMJfYLAN5PKAgMD/jsvn5/POzub/UrD/l8/M3Pn/IJijo6P/h8cwMZr69vr/1+z/rtpZoO51dbojI5H/LJ6Dg4P/otT/b73/O6VymOur//+hoaEV8PehodArK5Wdnc50lNO0tNlHR6NijOSsrNanp9OwsNf/dcCVqeLnfwv/t94mBYSqqtS1r9f9kBflEZFjHZF2DYqSCovfPqKlpdIz///AGZKULZq7dr10T6lkn+5Wpe87TW8z2/m2M3ktO1UbKEDWjBhXcaMlznl9AAAgAElEQVR42uxZS1MiyxKulRabbo0GugFpWhTEhkaQtw2jPK4CoSAwKmgYQWCEruYXnP/g2pW/9VZVP6gWHZ1zrudu8ls4DVRlZX/5VWZWDUIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPAZStuConUG/9hOr/j5mIDwRWNXhoa3rccQxliSX8qfzongb2DnOLLFnAh9bXgo/0fW55n3vxcCX3Lho+kfgtrdjRx+xNa3MPgZFv7WMD4cxP6xofwXYrR5+EVj98pz99KOqdrtTrdx7tM5e91voKeCj+g/T0/fIsDsBxvycPNLLmSFvyHANC5+xNb/RYA/1Sj9J/ivCPDLaMnemEZVxffPLNb/3lA7+l/FhwLc+PF1Af54dw/8gX6/IsB/rYZ8qpuO+xg8lxUtsMd47HYkoYgWbSlv0p8uE5oiXyzp7BWkhkG26WXYIB91fxIJpFJiQsj6QFBiBzSG+OxVlgpT8nSXiympvm6XYN8NGXFGy4qQNduSXFsW3mpMEZI+dERt4TgfUwPvI9548KIghTvU+LAjis1Dm75tge2kcZvzkViYdSTDXmPakcRWlw0/3A6HE3eItxEQb5tiB5nbMUmt3tFBlie0/h3hSkUQOyxznKiKPOcaijkxUKjRpUp9SZgQJ3yDQrjR2UGMiJ6s9FBk3Ai3axvc8BCzjlD5RVZSgTvGyKgg3TChBF9UKZzPeFxAvgdZSoWOl80Jne7Q5m4Cb/AsN5m4iN04mxTxiM1shSV5Yo8ZNjVJvqEcbxoxRWsRWvRQShKM+vcIMIcPSnZ/VcVn5okmECJCKblmZvFDfrjoSLsk/Yfzr+bAH3EnKQNzLmtEE0OcQftaKIoO1Xa3e4jqhVRGz4RbhGcsjK8XIYVIoKmdxHciQ4uLjaYSMStimxAmxIhZA89sq76CWDEjShb5um1Sd9d5AY4bJFFzxgM4NzUnpAea4Nxi1BGfLPqmmMgcreEL3sdQSriI24vMcXPnuq3M6HBhYGbEdpm3EVCEiW6i3mQ6ey3IZbR3gEfUE0uAQnNnJ98gW+cEG4u5KgjL1GE8mpkIXUo90c/wK0Jbgec4oeyVCjBWmMf/QoGarr9ID9zwp77W7XZRsCk+6LVY/gdlRC3GS0yAE39Ep4N4F6ItZbCYJofWqvZ0lzZHgG+C5xXgehEnu909XoA1HJrrvTN7zEtmET8RWuRJVp9no0EcHUnNnfg8sPU9ArzqY6z0J3UatjN6JsFJurfS5Bc/df+QBrMZo2o4k66sOV1coV0E2apEtUq3RaNsl+CJn8xEj3hBeNfIpH0/2VniPXcIMfE5ebrGJ4QP6ZTILlW1fz3B1+TvOTY9pSyUj0b3I3Q4Z3xGvWStjHJAi6ZmWPRFtQT5eKNc8T6GmCqtJB/LB+nwPh1+zwT5zNsIuPVpI3qKp279swSYj1J+hiio0bJxqjgCPPInHGdxiVLRtD5Fo7k2FWD4ylk++pDa4IZbNXSIR4iWxh5hxH/plMpswVuCqQuvuLZagjnabB+8wfMK0CnBSwHWw/0NbwneiM7wLbrC9hnnER9+axFOnxspTPJej5GHZEJuiJ1JYpTmMh4gn3IQJVhQWVEk8R393BnTtNWW/OayB+wX6C91TOKOGc0akVer8dItOwK8wbTWbIgk3AIr/x07XMgQKRF3dC4vQFYzkl7jSVaR2e5N0+8MzaZvIG2haMzw+BhquMbWmPpR1V8nw6mao0qOtxHALO/eVWN+suj5GwHSDecj364xcaOQ4O4cp6MPafRvgnaw132Rnt+pAK3zvN4K0zfZ54ZbCko0ynR9ugGEtturPeCquf5GgAkpuCpAjjbLB2/wfiPAIF2WZIQ53wNuJjTq5hBtqLHKIV1vUxkXN7+3ESzfE09f8B7r/1Un/kLW6mDQLrbx6pRtC6rFT5s7hKj2Tzk20X7nuwMBi4F9i4ucwoarLWcB936hxewhIgmPANV06bGAhx7jOb+9aX/ZX/lt+p5IqmQbhfORMzYjCY+WGbxLhu+yDbLN2wiILFEVtIt4qUQ6Ja8AmezIt7YVwxHgL4s5t1+grznCxk43ncPIIaLkb10fp5PE3nK4paCWvb7LCCMtWmljpZX2uGAz5BUgRxvngxu83wgwwtr2Z7cHot/VY2ptlh7RQac5DacOyCaYZUWsZr5VgVs468mA3neo+wNpBruU3OBj9vGWPP9HGluBsQTYyVsjj3gB0np1ITa9GTCxIsAPMiB9vNK0Om/czYAn+NH6zikg4w4yYlGPj5yxdzMgZ8MS4C2L0eaHAvxNBnQFuC3Ql0ksBXgv+VjxOFrNgClr+UuPAGlUHtVU/c8z4BsBVllWPntHgLuMH28GnLLDn263IpcvftYgRUsJPPwe6e3bXV0OXeIDtwd88w6tguce+Jh1HVYDIcv1M4Uqtz1myUB07ww8AiQR0ZweMMP6itqKAE9YL1ShHdtbAaIinvDGZ9g+EB0p595LhB6eSUmvj5yxYKywsdIDcjYcAVKyB3SNC7y2KsDVHjCwIkCDluF9cSnAgUg4/CEQNS2HG0wbz9bOX1K+JC2Dn3gX3vSA1nSOtncFOPGTGJdVR4C3tNf09oA/N3gBdtmlg9MLF8ZOihp8jwDz2V5cr8TEW3oKvqen4KvVd3hqjIvxaablTKqKg2l8XiVvkhD/QuW2QE5IAWlYukX1dqyimzWjxAlwq12ZxitSYnkK1u1TsFeAvkI4o1vHuRUBBvOpdd54AFen5jlpsSdKdSd+PYg4lG5JMXzp9ZG/nJvj7PR6zJ2C6dZa2rAEWFaFuXmmUgHGcbWbXn8jwPdOwSP9IsILsIirelFVlwLUsWEO2ypNZ+7wCO6V0iiaTT2YejEw8ggwe/M4exWEMu8COQXfmIvI0F2WTudoe1eAR0poMQoJjgDrUj+e3vWeglvD+Il9Cr5qFEbThEoEePvzwtST/iTqGcX4wnAPOf9jXCdUURECa+weUFVSib133gEd5WKK1v/lzip2REkNpInvrFiFSZt92gzTe8B6UlbC+ft9ToC+aiEsyZE6fw9Y3UIrAuQutFYESBq7B954MJNXrHvAnVZYEgzd3dMJ3Pf66L0d3qH3gMcseult0b4HdG1YAkRrzXDD2GNZNkmOI/G3AqT3gGpxu+1afR1LYrvICxCdC5JciywFiIqypE5qrJ46w6+MBr3Ii1YKkihXNz0CrPRTipA79biAfBESolbX/Q/Lxrv3gG+CtyhI6oXbA6KhrLy5B1yERDF/bjPY7Yha7pDE9S4gi2IhE0XdbUFK/Ze9s3+K4kjjeDu+MLAMjAEXBBY8X4IaUQ8DFw23nsGD6J4aopQadX25xbhl5Q4WWBcNLwLFi0RdIWApFQtIOGJVLMuzopWrq+Sqru7/uukeZ3YHdtl53e2Zfb4/4DzsMjtuf+rpfrqf7mfzOVi1NlflZCxqZNy8ZT98i6CMALiruWXrswNFd+BbBGUEwNa9W0rLjtTBlwgCgUAgEAgEAoFATpK7uiIHlD2qqHbTBWA1C8ouVdMFYAVbDW4hi1TNVtAFYA6bA+OQLBJ17Q0AAoDwQCAAEAQAwgOBAEAQAAgAggBAEAAIAIIAQBAACACCbN3e5/dWsdskY2tjUcExABAATKOuvd8iA3iocN+Gg6XXAUC7a64TSzZHsBVGPn8PtvoE49+vf+E4jrzYLZivX7/huKGMtbcM4Fl8msRHRwFAm8gjn5fSFRiIzoQikhlwCQrK75vB5qKPYXyCwUew5fqZYRjyYpiY/2SYe5kH8Aw+G6alVPxv5ZL0HFoA/O7Weqr0n1/fy6z+hvWtZH1LzNiLgzcFXZV08+Yq5k3ZvPnbbxkGsPI0wof6iMcViSfD0gLgrXy69Otax+nv/81UeycGkC4PuD4/nyoP+N7atVb7uOVeLbUZs25+/702D3j16v8K2YwDqOiC6RoDrs9fT9Xwa83aNZbc91G3fNlBBmfKcd2M/Go/Nocla5y8d07+05/yfgr2Cxcc1sR8UFCAYx4/ZoTAI4It17+kICRMzDfcmzK2ahsEIVkNoLtruD84JlkLBKpxyRzGVr/83hA2A5IVCc23LQa65OhkXd46csFgDYm/5NpfMAyX/NPP1bRmor0bamvZPbVN6OwmPA1zidZpmGwAsItAFZbMJQKg7BE7icnLPC4Ghqfnkt0qEYCjHl8SAD17WjPX3mLZiE1oEz59bmtjKaUT0dkAoDg/0ibzSMznkvnj8PRIx5zKbZOJAERIANCf4M1NZ9gans5pNwDQUgD5SEdnINovO7k2xagvMtKxsNTVp/22/tnZG3k3VgLIv5sJXKYrZSxLyl8AgNkB4KPeiNLJLUmmOCfcYfTZOIaRABSDEOmFHv9K/ip24JPyzyMAMCsA5IejobjgtVdBHN8XdIU6u3kTAUyp87jC2o4KBABmiQckq2IDkuUlAMYWbTu6PCY82+g9tQDWlxezbNkDCtsbALQIwAHlbJ5yMsWQ7hKRS9UAtgju7/ghBABmD4BkNi8ox7JRV6gtsGLQ9/XFdan16gbRK8kWzXeXeXmvVI0Iaoq/8iAA0OkAeuTJZTRCOl3ZHktYRfhinnFdTPVQ5JNb6yhtbwDQTADD/SMSaG+jgc6Ol97V378uLy+lA7xxI7kHFHTx6xTPtLvqHM3tDQAi9M3lNck1qAHAPmGkF3qr4eQ9aRp51SHf5ORkzyzDPJF+MYGn/PwqPyH3JMvu3AUAUg3g5dWzly6rvtG0S5E4YA6AvNCztzPLAfSp+4ANjbg2JwAoSlWuaX76AVyzdnAVF3j5G5W34SNBAuAPpgHo83MPyXQLnmV+If12iuP86vjjjxWxbOkf3NAFi1KZa3rLLoHuihEg4W8RmQWgT/B07Qae58Jewf2V1NLd46XzgdTlmt76zq4Aom68xttrGoB+YwAexvXQm70IAKQ1wDUdQMS/nOlEpgHIYQBHdT9MUxm75Rr1Y34A0NyMq0d95gK4WmJpKp3auwsBgFkGoDZZBaD7TznvAmgAEADUDWD7Y0F6BoHbj7CbKGhvAJBOAOMWgPNUzANqV8tOIfqoBQABwMS6qGklV7Ma9gv4VX0MHjCrAIzlPqvpd2MLwIlXcoWh3/379/Q9SV2lwN/vWhEAmE0A8gPB6T71AKbqdxnd0YfndCnLFh7kEQCYVQA+d7lcobAn8wCeEtzf559R0t4AYLoA9Mxo2WSUGsCnWvJdlK74SPH79QgApBfARKlXg0YB7CLZp6EGUwH0aX0KAt6u8/S0NwCYQJcNZlwllNuLD3BZMG0MOKo63yVOhyt3U9beAGDC7nbQQMZVUg27XFG3aQDqEN72VtUKANoAQNMSD3pHolKqCf+Dy9WFMgjgxqN421s1ALhq0mm+gwCMdOLA46UchoRGUOYA5D8sZFnltresBfAWXbmmlgE45lJu9I3NAqbcamn6+ltrjeD+Kuuo6/Ey8kCrJp2mP9fUui44Svb9Jph9vmhkJ6XPz3GcxhTAT6sE/vY3IACQlnGeZQD2/Tgsd3Pivt9woh421VbL5DspcRI+c9/X0zOpZfxXyP7xOo1jfgDQVAAjHQPBuGMk8Vm5wUC3uUM8P/NOmpZBDn6yHQGAjgdQPGFtWjLd88Mv+xKlfBoB0Dcl6L76ZRD+Ge55eTcCAJ0PoIecFj5vdZBL9gCrXAa5sJf9KMPtDQBaDOBYbJQXUB5mbxGAeA+wymWQa3jb258BQCcD+LbfpTzMfqbbYgBVy7tPwC/ptjcA0AkAejvja3KMBQc6enlECYC1vxf4S77tDQCkS3ISjJbMl96ocrLZq+qv0gKge08pyxad4BEAaA8AL+vJfHlOBn39Gg/T1QSgz/9UurwtxB4PHz5R93dXBPd34EsK2hsAVNvzDurIfOlUVpAxH8D4gjK3tUwAejazJ3MRAGgjANX2vO7epREp7vC0CQ7wLbIOQL8eAIlHrt5NR3sDgOYC2B3FR6zJmVWR/vleZCGAnECcZzQewNQz0HUlhylqbwDQFADlbRTjyzZ3jHuRxQDOtnPxAKaaAcTb3gpyAEAHAegNL4bkSNer9YxT7QA+IUWNbksAyr3ubTUz0E1n8La3agDQMQD2dYQU9TxmFGUErQDwIfF0KwFUFfziam+qtr0BgDYBcEw8Vlfuacl6Wz+fJgCfYmf4VO2dFdXeAECHdMHDymrR4cDIUq8bpQlATapTVHsDAB0CoFhGcM68j7IMwDtFbNkV2tobANQHIB/LpRc63Whnt94b+/x3ZbJwf9ouA3iPi8+un5SN+CBEm07EV3sDAG0MoDc8PxCbaRno0j/k8zGMnD1PEvkeywDivFJGHt/1CMbU1JRP38fw1/GyB+9BAKADAIxM98eP+gzJrwVA3Sc+t9awJyltbwBQO4Adxuf6ZHECgNJShhoAdZ04tBtve/sSALQLgKnOH+ojufXBMX13v0uGcFMxAHukpQw1AOrognG1N3ZnC3hA2wCY8vyhTi2Hqa0AkIA0EQNwVupXUwYhOk4cQmjDAVztbTsCAG0DYJLzh3jFzEt0rt4MAEcnVgzsTE1ITV7tDQCkGMAEc378UjQWdgQC3boDXyWA6MmKgZ2pAD5LWu0NALQTgPzzaHxuvRGHkgBAn3UA1h9lmxsQAGh3AKeV6216hE9tGVoRhKAXKwZ2pgFInPTGa3S3NwCoCsDny86y0sEf9nuqKieYBWBt4wc2aG8AUBWA9f1GXaA/zQDibW8lDc4C8FhBUaOUy7OnsqjqUq6zAexbiB0aiXNeZsIGlrJI5h6TNgC3H8Hb3pocBeCp0oMb9hWK/6cHRVcOfVx1ycEA9s0tBuOO7+tSX8aDBgC34Wpvhra9UQjg5/gcm5Kz5Lr5E+HHyePOBfCt2OfKB9d73iab9iMxhRzU9hCzRzIniEm64NnZtAEoVnvbbeV3lAEA64vxas6+M6I3LKtDG0tOOxdAMex1LaZ+N/FsQ4pYIzavMqTa75kIYC2u9lbTihwG4HYW7+Y7XSlaJ0pL5ZO9cnNycqqd1gV3z6hc8FUAyNMA4Aelaqq92RDAT4WfX5UQY+uWg1+0FPxVfKWcxXJaEOLFTjA6rg1AKjwg+ouaam/27oKPnySRiNu5HlAIQ4ZHelehbnbWT6EHvIaHqp565EAAFUFII/7nSpHHrmPARBlXy1OvvKncHqclCEkLgBU72PL0wJCpaZhLhU1okwBfedmpQx9X1tg2CEmccaX+ACwD2ckWAni4gGWLP3MsgOhYQSmeiN68SXDy5ZVFBc0VtgUwYcaVhtJv93RnJ1sHIK72xpY9cK4HTM8DpQvAZPvMFwLhpLkud4lkAH1UAShWezuEAEA7A4hX3AZ6U3e8Q/qyk60DUHu1NwCQRgBJ+aJghzv9Iz+DAH6oudobAEgPgG454BVPV3O1JXaC9+kFMPeA1mpvACAlALqfD4di5YtCBMD5xMU8JiwMPQwAyOMfd67bs72zHsDxNkX5ImEQOD/dnaQLnrAw9NAP4Iajd2zc3lkOIN8rnq72huM4nC3Kdy8Izq8dzx4/lPyLmEP/QricsjD00Asg3vZ2IBcANPpAcqH0/PR6QF6sn/UzrnIqv/oYe7p2yZoksceTtH2VmgC8sBdve2sCAI0+0K30VkWPdcERkvj32qYAkmpvzQ0IADT6QLFC6Wmpih4XhIRdrtDrX2wJoLfZQLU3ADADQz8FgD4ytpt0D0x7nzJ2BPALQ9XeAMD0AxjLgcEJL1MErB68yxyXOOViW9YUQQiKBSGUAXi42Ei1NwAw/QDG58D8QwYwZZyZ5q9SfRdc/n/27sWniWyPA/ixGhmdtJ2mLVSgpbK8sTwEysNSEGqxiyIKCAhWwqIbTDYFAYN3Beu6UdSrokaNLjFqhOveZCHZ6G6yuX/cnTPTF7SFFnpmfqedXzZdwa4Zth9n5pwzv/Ot+5HWzzszAQaegVlZ8/l8y7OJAkQQARbiVV/7IaQApAvgvsCwA3f5UgzQUcOcofvzzmSA3d51QeD/xEEIhQAbLAxj6lUA0gmwW6X6JpwB5xDM2gkgTnsj3/amACQFEG/Sss7euf8c1P+/26MHgnV4e4Bi2lsv5Z935gHkFiY2BIB4j4xvXxeBnfZGD0fU6DZvTFnamwJQUoALEyz7MQQw2U5JKa67h0OnwNHb8d9Xn7K0NwWglADFnTbWIANMbPLPkZOqtDcFoJQAPwkAfRjgv4SiFSCqfJoWn3emATSvhwDSOfTlS9ehS5/PO+PuAf/BzUZrFAPEbW8uuwKQVoDq9cmvf16nF+CADbe9tSgA6QLIhZo73v31l0pFL0Ah7a3GgRSAVAF0TgibPIeewvqFUoBC2lvrtXT6vDMC4Pwyy35Bm57CukIjQDJpbwpA0gDncI/v5MPInYh23nUIIsAKImlv4AFmu81UAxRDVdkbS/F3IpK7El0A7iGR9gYc4KEuk0GHLjdSfAYUJ5/vzMEFmMAC8GkOfxgOlHEAe+oqtDr0XSfN94AzgU02eIAQFz8SWAB2VjNnYf7dIQ5Q04Z4gL25NAM0r7Kr+KmXffuvS7GpUMrnXtDxWobR6zIToL4FA7xENUC0KO6zRilAnPYmX9ub3AC/92CAlzuoBhhoaKMToJj29iNCmQlwWHtZP1ilb6APoP3+1u3teYDPqAN4nnTaG/RpmEqbRWOrRNQBXLrKTmRvBbiPOoD1xNPeoAOU+IBSBXABzz7fjwXQSxXALA3ptDfog5AR/DqgpwzggrjD6UYMgN1UAURtMre9yQ2QEQCW0wZwQ9zj+YZ4G/hCpfrt5ctuHuBbL0B/cQC6j7oR+CIMsL3d0Nje3u6x1dJ2Cf6Cdzx9Hdhj/Ja4rT3YlZCYAMdymSPmTAdotTJWvjT9w2QOKLQfaqhStjHqxiTrD/ZcUggwvxi3vbkzHSBCrgGSBxSxH2rKN0b9z2poGkYE6KUIIE57g9H2lt6j4PB+qKHa48aoS+HJv/DNuwiwmxqAkqa9QQdY3pxXwhcpgCld91j85Gc/hL988I6vB3gQoha2tacFoLRpb8ABFuZaTDnaXBcFAJ0TeOCxGv6GekugES0AhyRNe4N+DziItLr8qmYazoAfhamXJeoBoiYp096AA8zVodaf0XENDQCnBYDTVAM8ju9cHQ6kAAxOxBxEOUPokhYuQHNo2DEvBgxSDPBQD9OMqCriAI82o8s5ja4jUAEuvLoRPuX5WXZ5OnwJfvSEr0cUAcRtb1q3AjCyeitRltFSpYMJ8G8/Xu8Izbds3F/YbjN74ABx2hu8tjfZp2GIHtBeAa4KF93wHrsct927YQMU096OI6QAjK6RHpgAxWcOfk3w3XIBjOi6jF24F1O2tDfYAHXN7x0of1BrgQnQLvT83oneZ7fbq1ZPQQG4qesydo3Wy5b2BhrgCT1jyGmzuq5lQwL4Jfyg6QzLTk7MRh1dNx7/voECMLLrMnaN3h4okCvtDTTA75tG+hjLCVj3gJ/ZO6Er1cOPEaPecHmBAUxg19MKD4cUgFurtRfZDUPABiH8yPdTeNgR8y2x938GCrComMZTnzQA8fPQWl3KD2hPsehLwmTz9kulNAE8X8ac5BSAcQCe7u3VVvTyldID2lMsupDw9nlj2/c8m5qiBKCjBre9uRWAcQAaDAaGf2EMKT2gPcWi+4Wpl/ld/DQAAeK0N9htb/IC7A1VigHufvZlcXLzgi/NAEGkvYEGGLs8Gn1nsEkkv8uqzxmXECBauumPfOSFYoAw0t7oA3jO1HywOrBmbr9Q1eYePi4lQA4bnE8HgBdBpL3RB/BCE/+SMyieDC12iS/Beyhwl2AjhLQ36gDaDef51+p+4Yuq4hprbV9gTuRQVlZWacYB3HGlN+a2u8KFNysfKQCTriKmjX/tE1eHc/Q1lefKfhB/J4/BRQrg/MQ8SIAJrPRGbbtrzzOcQ2lR5AFmD9c70IgzEuBp/vWnHOELi4Y/+zVaJTgDbtxhr5ohAtx5pTdq213c9pZbpABMpErr8CblXV1xLsH9eOfKccZO+h7Q8SsbvdtV3PrjzRPvixd3pQJ4ILn/AKe90dP2JjdAm82p1aFCS5xBSIkmG6FjBaQHIY5lYfZ5ci6xt79VqWJthQoDoJj21oCQAjCRKjuIF4Nb9FumYS5r3cjIGyzVdvWOW38iDfCmuNkV66cfYCG0tDfgAHMFgG3WyO95NCY8EX3EyP/6tEtv6TOTBvj7zK++NZ9vbV9itXJdqK3f/gUAwHpwaW/QL8FdSNviPGlM6QHtYhASkfO2h7oiO8DyMqajFCkAEy63ptN0xGoplxtgOOctbvHnvBW+gmfAleh3EImIS/ISPERZ25vs0zAOT43xbBaSH+BOl8+7qth3fqQrYYAjxgGUdkUcoJ3EAZEE6IUKcNzK2DgFYNKDkJpCugB2wwTorMZtb6UKwGRrrMqkGbwkL0DnBy4RgGpxF8AUV0JNvTsWTnujs+1N9ntANODpN9SekQ+gc/oGO7sNwHuP+LpH7McfTX6lN6pAp72BB8jXqTqDXACfT+PEj6tcfIBqskOPRJp6d/gjYKe9gQdoHrJprdVyAXSKiTOfZQR4YK9/RD3otDfgAIebynKNJ7KRXAADu05epRkgZ4Oc9gYcoKnqnFPWUbB4CvTTClDoXBgYQArA3Q5BSBxQUoMQ/hTon93mHtD7G19emADNfaYhlNZFFqCd/ydQ8gF8PjHLybi3314A4ra3snIF4K7LMCK0puOSD6BYNAIcy02DtjdZAZ4woxOBkhrgwix+/feVbR6leoxnntVgAYppb8MIKQD3UiOb/iUZQPPHyQ9o80NYUY9S3Yu5AxEUgMO0pL0BB2gQA6ulvgT/jjtAuMiHsKIfpQIN8D01aW/AAYqB1TrGlpoAACAASURBVKVaiQEKPUgz5m3v/EADLG2lJe0NNMCSEkN1SUnJYL9LWoBmce/n5/QCRBfTpO1NXoAuF9Ppcrn6jQelBTgrLH/MBMe+3V714+Bv3RKGHrcAD0IGuvJRxhTxS3BxFoED2hngVTH/QwSItxwPPe7SLfFTf0kDLCxgjApA2AeUwDTM0k3/jewAQG8EQA44QHsPbnsrUgCm6vRXHCipAfL1PDj9jFd7//uAijPgwU7eX0cpUgCmAUAUCTD4uAHoMyCVaW/KJTjOGBePMK5HAYwYhIADSGfaG3CA+DGEIs+w9AAfYXUxAEpdSQBspzLtDTjAk2dRVoHV1CwnQFkrCYBcFY1pb8ABlp1CzbXmsVoF4PYlPHQ1Uo4UgCkufSmy5SG3pEtxwjMwwvZC+6UEGLsBM6Guy+xj+gqUkUUcYK1npLUNVVolAviSH2D84yO8nVCcGt1t16XQ9lYwoAAkUWMmQz9CZ05KBPAxf91d5wGurRDcTijuxfbwrroucdpb+ra9yT4N4z5tRmj4lHQA/2R9+33sBOjhRmSJaW8ZegWWZB5wZCDVB7QtwG8CwE+0AKQ+7Q04QO5MmcFgPcMRBtjtVf8RALiOAU4uUgLwKfVpb8AB5pUda2hoLMsjCxCvr70NDEK+8veAvlVECUCdlva0N+AAC3AmA7pWQBagNwhQmNNY2e/7mxaAqD7N297kBqgX/nr36skCxIttj4PPu+BHEOwUAMwfdKCML+IAO3vwa88F8gDDq70y9QAnCXBYwzQpAIkDrNDXdXXVJT7PnykA7Xm47a1cAUh8Gqalp6qqx40UgJvHHi6GyYy2N9kBkjigKIB3X7yIyHYDDzCt0t5AAzzUY9EY88kD5EIvNABMr7Q30ABL9MamVht5gMGaW6IB4LG0SnsDDdDyFKE2U7ZUAM2vJ18twgdoPpJOaW+gAZpwf5e+VCqAOBTzzrQTMkBh0beoSJEnDUBhZxhti0QAAxuSf4ELkPNohxV0UgI8WlxcbDpKti3z2RRfz/hf3Bf8LWeDBYjb3jT5ijrpANqKJegLDk0CzoiJDGDvAcetuO3NqaiTDiChA4oDEC1MsKyfAwrQ2YXT3sYVc+kLkOPQnH8O6Cg4bdPeFIBRfecQAY7htDcPp4hLQ4BTb/iaAg7wZ326pr0pAKNqrwB3TFjdTe6qJ0Pb3hSAyVcCCavJdAA7flDoyQjwYofGjc6O0wRw54TVZHJXGyxMjwJNNoDNrSV6HWruoAvggZT9/OY+3PamDH5lA1h7DWl16FIZYYAP/TeXIALEaW+Z3fYmN0C9GwMk1pT0QK0WepFe4UjWm05oADMh7Q04wJwhDNBTRwjgO5VK9eTJI+41yy77fPFz4WQBmBlpb8ABtmu+055vzH1PEKBK9X/2zvUpjSwL4HeztXBZYtNdjdKiIGBAkIcCYlREAyjGNz6ICmNiGTWVrZrJJFnHTKzZpGYnGVOzm3zITjYzm5jsl63aL7tVs7OV2tr94/beSwONovJopAl9PiR29+3uW90/zrnn9j3nND1DClC8nFhiAXi5Iaq9Sd0LnjVBaJrN2zVJsdGcXpiH5koBvP59GsCT68LVBEDDmH5DRqzWAALQFaPztue5QUWPJhMoF+tYrhjA6ffbGECxvn+IASBZcT8kh71JAcCjsojjsXUrvJaYGmyuAEDkhDRdxzUXHtz9m4QApPvsThkuaTghvOT29Gtxupie5fRWmxlkAVQplcqusucBK/R9Bd/ffl0pgDjsTSdHHUkCwBkkr92hm7k9l+Ao+nfJSDZGO1I5ANsglhoB+ElpWXVPE0uHHPYmMRPs6hUCeBX9+ynRiUpqE1SmAZ/RIgEo/P52dlbdUyRd7U0Oe5MUgIy+sAn2Qa1WC6GWKWMMOH29qenb9+oPogEojuubrvYmh71JTANShZ0Q1TgSc2S8v3QAcU7Kz7+6rb73O0kBON9w1d4kDuAYFko7e2QaZl0TA828I1yeF3z9woU/T2+p1ervJQWgk2u0am8SB3AFic2VzNs3SXF4Irq1uRIA8UL8/5AwOH4YKBETPDMhex8SAtAwnxKvQ2/3fpWWizyA/yAAfiMRDThyGY8kaBkqSWlANiZeh/YuZmUPTL98+ZefMX+PDqQBoM8LbTJQkgNweVW8DmHNh+TJk3d7b8kOGgcCP5XEGLDFhReepmSipAbggnHQF0ciDoB4+g95Hy+yu+jdrREpAIirvclhb1IEEH/b0GqhVjwA0eDvhSGbET835KolgI1c7U3iAMZ5ERfAzwvUP68dgI1d7U3SADYrxexQFsAL/5YUgEsNXe1N0gBqU1UB8Gf1v6QEoMrfyNXeJA0grAqAP91Wq99LBEBVepwhk9Q4AD58eFetVt9+RksBwA3TuAyRlAEMZUQ8AIHhFZ5/vndQewBx2Jtf9n2lDKCrjxcRAfwn+QD3uPYmeJTCYW9KmaLGMsHgt9vpTLw1BjBd7e25zFCjecFIdrduv2qpMYBytbeG1YBYHuzW2Avekau91QOA4nYIAfhjE5IfCx49XwBHtXK1t0YE8Fg+6JqZ4DY57K1BAMwuQ8WrsY4D+IcbpaYkKpyBt/hgYNUktry0DE+DAChYhnpx7ziAN0pOSfRJSQl2j4hBtR+mXCpZKhRD/QDIL0PFsvf2OIC/+OXXJaYkOiEDbzHBwLRDEQgiGVfIUqE46PoBUJAG4bgTUvrQr4JlB479fafTmUzIGqxCGUkoHHUJILj/xUGlvkf5ABqcWGLy5IsIklAY6hHAA5KK96A2AI7YNp1On5xxUhQZUajqEcAvyHfgu7UB8CYVdMblhM/iiKo+AXxMAHxQGwCHI8FL8uxLQwN4QPjbrsEYkCi+ZLL8tVcWWD+2ezBcFeQoZ90D+Gz7qAU+JwAXqHjuoZUl/Y4qKk8IocZPlrwZXF5WHx4ld5zxs/apvtLHDKqOcjP77+g43QL/dzPJ9ugFYNKr14/hUlmuSP2bYPDg7naeBT4XAHHY22J/ZQAWVKlFCn2W3w37HMwSDKKW7tDgkK+X60Q3aA3N+piNqK/kPmwYy+zsVe2SYonjP5G3OxyOLnsbAKub8biN20eOL6eofwCxHT7vaZiAEYe9KbMPDc9FNn2XOfol2fyywHmtEz0h05XhZo1xkzfBo8tsKJxAB9btyyBm1ujdmSJegYhdv4xMlNWN37e9D9AzFOvfwecFo5yFMZs0izjw0+FhqQ3Khd5vr0kfycAFEXDAPodLDpBMFG77MJjRkqP9/Cdr/tb4VOBHWMBJs8bWMYm2nJDJv5p5TtAh0rAN3PJoTNYUAMEpvd3DnPCg3Nh0h625HZ0wk5klNIgfSFvdA/iQyLkCmK72RsLe+IdGMvP/PnN8Op2ovxCA+tfx11rPlfgA4gED6GMHfPuzKdCqmYsr6OiUMxBt5dt2P1coek1KsMoiYFZZJbDpgkwfa0Hn+YNMwnclGbfhPDsRf8DZyroAPWV2xufsiSyAhmtwBbHDZz5GO/x5A7nMrXMAmgaZ2NwU2pobO3K10LygQ+mGDrtN4QsjE7qzEPeZvfxizCUNL7zJJhcX5oL08H0wzHM4a8RKa90DWOhTXHUBFFZ7KxVA9HoNmmaktuBVAqB1ij+AC0cFtV0A3IKCNV0G/SpSfodEDQ6zOJFxrxWd15k57p0FCoiUEgNdoFuPu2K8wgPIarTQjhSTLp3qLgFnANsj7Evm1jkA1zGWSEO1IDWYd7V2uCboULphGyapC6YfQwrykVgJhhc+PQq3gQ04l72pQ3uN+G4arZ6USxWyKQNYnHQKq70VApA+BcAJ/MZnUBtkGDGAOt4EtfZm30boMIY0yBJIDRj1Gogs4kAYDGs6QQBizcItovNwut/hOZ1eo50DnRxWPiEXMrD4uJbP8QknGYsfV6M6EcDMrXMAkmAC3RKwcKn8qznIjyLbIdLQw+EGcBMwVkqP/y8oBMDnubqAS3by4PoZ54oda8Arpo8GwOwirDIKw5UEYLew2lupGrAn88aRFsMARtsEB9IA6g8NSIMkgGdxc5+xu/BK19Rz9N4C0IJVSxc/fTNgXEgy/h4BgB1E9aRyY0BGc+sUExwVAuht44eN4FMv6PWA/Kv1Y28m1yHSMOwmDYaBLtyt2M8o5TNMMG1cz94/gvMyz3g/GgBvVFAYrjQTPCeo9laqE3IUwOYpwQHeBPNzY5pDbOJQW5qa9aCXpWQPhfOH3ptIC+p7ciY4qBWGoxAicKbZjWNOiCHthGRuvTiHr50FcAg68Ygv/2pel7BDpKFNZ+BVK2JtLQPgURPs9uQ5IRaYC5qO4HS4VutHA2BuEVbpheGKBbC/D2sbw/G5q2LlGIBxbiCpmEylD9DRZYET4g8rAsssbmvzclih2Ox9jG+2jwfQ7Pf5zAhAEIkGfBHihPiDQ6M2pwDAJIKTNocGh5IDeBpGtYynYa7x0zCZW6+Y1saxV8sDCKb8GkRP/tXm3MIOkYaXTO4AE2w2tNitTPdibliaL6PaGcUMnoZZIdmXrWNkr21tKGnTYq1KHdY1gH+/v9vywwskP1S2/r5IAJkx/PvPn6GtEEBgmWJD4fb0gfxpGN8ia9whbW9BCnvctEvHmcJrPIBDEZaaxaeRaRgT8haUPR0cZe0SAAjCSAEZLuOJaGISVUtePBHN/4L4WyvdeqrPnwNwEhJW8q6mYNsFHUo3jJtDrG6dBt061m85CcDsRHQz/l21s2mnppfiTBHM39XQSF0DuKVW37u/S5fpepQIIN2ngVCTqAjAakkXrHIqOPdS9S9bfwAO38af4f4KzgVAXO3teNibBADsXh0anaKqvCQnNluNq6pej9Q1gB/IQoSn5wJgd+FqbxIAMOhlTeYYqH+pPwC3CIBfnQOAqpOqvUnEBH8UUn8AfvMI8feKLhPAUqqx4qqdkS4gAygDmOeE9P9369H/Xk6XB2Ap1ViV1AnV3mQAGxpAPAn4E/8drmQAi63GSsAL+E59aLI0LoAXygewqMm/TV3s7IcmSyMBOPIuB+AfqwzgyASEywYZQBlAgUl8/OTiO/7vb6erC6DPi7wPj1IGUAYQS3rBy9d3PvvTZ2/4z75vfoOkvDUwZwNIqr2xs7RsgtNircrnkJT9Ur0AKFzwUkBuiAxgMdXeJA2gBfXfHiHhSIkeijM1k9GsY4LiOjxlfLpLhsokg27rYFv3+Q2KRCZNoH5YTZoonlpd760XAMmClzd3sAa88yarAd+UuQbmLAA3i6n2JjqA/SK2tcC4I+nWpxB/Ru9mbG3ZxAAw1OHdie9f1p3Cywlj3t6BIhselRn9wri7g3+LKYfD0Q0tAEQWA8xrvEAsySbqBkBkZT88Uj+5+ORp5dc9C8DVYqq98Q9tG0s2NnSXbO4WaJ4XlGTopVgjWV4z6OVME5lgH8siZ1rJvNrnURL503IsVqjNP0hBOhsQNOpno50Q7c+ECqUBbMdLsv7P3rn/tm1dcfwiaSR66Ugp1IOmrKctW7L1tiXrGUmWY1uu/Lb8EjwYypAMG7IUa9r9EGw/zStWYP5lGZAWmz2sWIH9MAztBqxb/7ndcy8pUg79kC2llsP7g2My5OW19OE5vIfne88OQmkOcmweussIRdzkfaKc0kgvnYVThxgfFTyVGNCqTbOmtt5shaYyIEkZhXYqPOvAg52Oc+70Getzmjw1/EGJJWVP1GWi6YUoAMokNtNPAKKHn2AAH/YeQJS+RLU36UMj7wT/KO98QTZfaAGoFiWlHMnsEbeFUJUPrSZDkthnhJs3DAdksVimaV6YjSD0hlbIwZUTeyZZEGQM+J82XZiillRIBjC/z+QwO9R4bTD1OtP2ICddWgUgCJ4qUGcb/2jrLcEEVQOiB+bEKXOOxYMN+bLjdtlCluW0aLpphs6R16pY7gCMoRyp21Y4uHvC1r4CEOKAJ6inADq3YOKRMqErAWg6B0C1KIm0+TBCbqmuOhH7jNrxZauc6r1Lksm/qRVyCPJq7yAIqgbw7gz+otukQj6G4ximksJXo3mMa0wyyaypByRdWgUgJPaFXAitMk/bexu2mFQDogduAklHbrp7KyA/PMtp0XSzSDQsMUUPsGWBHUNlRhAhKRDtD/YdgBAH/PQL3D7tBYBzm0yms9ABIe6jS1hAtSgJVSsBEBk14ImIAHgkWwrM2xERViS8LIbo6ZtaIQeResiCoH2wUnuYopZUiAKYWF1hH6F2ANWpo/KlVQACG0HLAvbxqL23A2LQ5AHRAzke/z8PPM64yb9arUhMpwpASJPFt976eMIh7sE9t96XAJ6zOvn1ADwQGUYc6hzAy1hAdUb0Fl9NmNOT+A+UARxWABwzgrAiH/DvGnJAx2mtEPCBWoKg6Aw5KaFIhVrPgFOuAeyCY9ouWL70HFyiQQAkf/hMFLmmUXtvOQZPeloDogfyNXKAbY7fX1jNyGvdXOCC5yzDZC/Mi4kyKR3RAVQaVHtTyd66PAlRAzgP1MxgkNhRFYDUBYvUBU8wY9jFwRd4WitEAGwJglouWJYKKQDaYJ6jmoSU2yYh0qUfgpXLKQBOeRbATbb11oBhtAZED1yUIihPQJr3WgbwlAsmk5CUMglxeJzEXsNMpwwdLI7qALbaLqn2dullq66jCQmJudVREYM0hWcCE0uy2Ec9CWkIy+YdF7Egp7RCBMCWIMgYsBpydnycLBVSAERLnjxquOLNMSkM44k/WTWEpDCMfOnZzae76wqARn4S7o623lBlSTUgemBOcLw0rIxi4xsyH7vPWu0LwjB+CMPMQF61jSVi45RrM2meBvDz/K4OoDw/I9XeDi7fyXUAHLCKhfQ2gFSyC+6oLPZpC8McsPzsDgHwlFaIuuCWIKg4KVQOYLYgS4UUAPMFbIAapwLRXsnry5c2zPKTKguIwgxZWUvdGyrNqgYkHZhb5MV1bNtCbr58fBaAJoeH3wQ9JsyXsaGlk5rVsIcj0vkDO+orAD/4EU1G+Oz3uH3WXQBHO632dpPehBwJD3va/wC70JN+1w/6B8Cv/uP84M6dw9OrY3UNwLq7w2pvNwXA493ssNvf44v4dnrRa6Nm6h8An9//xf++6RGA5GPY7bDa200BsMby7H6fVwr7PgGssnxFmniWFguFmaQmgHcxgPfv//vOYS8C0eOV4NU/NL31N4ArQsYQ5Wjmsb+aMFjFEQ0AU88JgN/0AkCQvZVtOoDvKIDrEI60b7e2neKxBoB/IQD+604PADRUQPZm1AF8NwFMWeD9ZHRTYY7f0QDwd18BgN99+OFJlwE0VXmGOUP2pgP4DgA4wkDS5IayEPa8S/paB4xG45hqEvKnj/5m0lgjWqtpl2DVqsbaiGDzZ09c50PTW58DCAGmZ60cyVphT/rNQdJntQPRF7SzSrC+IQbOeSBDN490AHUXTNu02CpfctoCdgDgGSVY36zGusUwnuY1PzS93aJJSE1sD7i3BvTnB3cfyHXSO46ynNOskSDqbwCLccGr3u6sBtO43daLQS1H+ysMs8/NIStmsCY8CQaDeQ0Af/nq7iu5Tnp3ALQRyzdgQm8LQCvDWNg0SbQuRgp8fJq8dvFFArx9eeQaN7B/bKgTAOt+UVQSLirHV7ysr8KzVXlja5KHREcU9LsYgl6Dy/YNgKjKChCIHrTKqimHBoD3Xt39+eHh4QnUSe8KgCNl5qA7buPSAJaDYznyymxNiCWymUIYw1+yWH3Z3dj+Oc8oF3QbmDpFxgUAluMLC/GIbD7FgQ4vJ7UsFzVkBGnJsKZQNTc9S3hv9HiS2r7wdv8AeF5TA/jTyyfAXAzgWoBhCsa3CyB4yuUAJHbCqstoh1lBYwJFT2JmKObh4zs02wWWl7d6N9zsNllbGZayn7LzdtnqDEQ9/GISZeGOpQgOLLsFV4YAWPe7+TjcX0/ifGAmj3zrnLhIY/0GqLqwICWloCiMpFV3iX1tFa1oJFwIeLOq4khabRtmjWm66jOt5xRyE2dC1xtGU6wO4DkNqr1dQvbWfQDNcQ8kx9MHXZcXhRj1I6htNp4z7zRVAHLWl48eMWaEXmJkSu617Jps8KLu5lNroe4MiqEgTYQJs2vm8RUC4Mh0wrxkSaKgEMruVfNOcdlsmKIAZkT4KUq9TILjbNVdYsVpsznviu0Z/PaUUhwJ2pGc6HxEtzejxJJTexkGs15isioADczcbQLQ+euuAjhBqr3VUVcA/PbeOe1bNYAWjmdAoFGTnKTXjtKiusOchRomBUAPfMOTj6l0ggWb9ppanTxUgUm5awpLq9JS0S0XHFlGExSDupz3j+SIq0vKzVfeOsWxB2XBRmcgKzvFE8UQLY5Evgg50VkChHRQlG6fEjduW7XT20oC0Ki65C0A8MX9w1d3n/+3OwCqqr11A8B775/T1DN264x5L1p2AoCUfW/8FIA1yW8pABJVZM2OTGwINRiiAvKQQ/YIWqC1kAHcsqRaADqfxQOcEEbOGTFcwhez8pFQUAtAAYpnyXWXEPsMb80T6RNTVYojabU2AE3bvKXgoGXGJABTTPM2Afh3AuB3n3/+jy4AOKpUe3u7FhDsy+AouOCitgtekgB8PCnRSE5BY8xE0RJEQeYITBCdXiYogDEFwB0VgLXAUcIcwSebio64B5+R2JjlFjRcsLuElLpLNF07vU4s3ZBSHOlCF4xv6pFUk2moAAwyE7cJwH8SAD++9GnnAhj0MKNdWVf+KpMQHz9y9iTEJ7ngqgebZ38LQDS4nAZdo/ux6imWuuBphaWsygVHYiBIoic74SDcZqPKJCQpT0IisFOuu0QBLMlzs1ZxJC0X3DYJoX8e3ZAAHO8wQ/uGA/hXAPBnX7932Xbmus/E7+Z2uzO4qwCIKvN4bmqJ7UlhmCoT880V08v0kMF4LtvMYUhq5qWCAmDJHQDDk+FDq3tT0/IkJAeTEAVAZGWHs74tAuA+WzTERC9KbkzMbQnN7PbCXC4gOdPypCoMs1RBqrpLBMC8a3A364uOqao1aYZh9mkYZgk/JTSqhkSUBw+cSFT8CVjSyTFzq2bBnwCAX/6gg6a97nNxsd7FwV0JwANhDKHdsihIgejxcoG3L0uOuG4N8PEmhEY564YC4BDPkeD8waRQ2FyTwzABCMOoABzYdwsuWsyr7uU8o/hkQ9nDu5ZQ0OsWWIdNIxBd51dVdZcIgCiIB+GKGVXVmrQD0QIJRDvwMBuzHEfziEkcFx4kXCu3CsCPf3sCAF7aAmqv+wyyN6/pewPwRrbldE+6bdqdtwpAEgf88r3r9WWeBdmbUQdQ3YY2nL3odiuJbheAfwAL+PV1eiLV3jqUvb0DAN6UdtMB/CE8A/7kGh1pV3vTAdQBvBhAZxcA9GlXe9MB1AG8CMBf/ebHXQBwSrvamw6gDuBFANIcrJP3rwegKTwzgnQAdQA7B/BEeqt6ZQBN5K143oZ0AHUAr2YBwQTee3DFMEwjcmZFeR1AHcCLAfx/e2fXlMaSxvFOJQXNxYJTDQFFZsADCioIqKi8GF+iCMfXo0TBTY7BquQmqTq3W9lPsFuV61O1W7k5VecqX2K39oNt97wxREXQaWYYn/9Fgm2PzfT85qV7nn8///tO9eLFi/cPA7AdxTjpBgABwIcC+F19t/bH8z/+OvDm6wv4Mba3kQDwcaak4yiXIz5KpqT7APyuxCC8f/7+74NurWR7SyF7AGgTU9Ln18QQhJi+fmCzrTMiXY/psww5wpKd6KUjZUrqDeAnOSXSvwdPB9dPtrfhAmgPU1J4/rAD4ExoZsDmtAMTTeycTKiROWhFuhK+XBhLnWNK+vOh6eDkwNN7sr0NF0BbmJLY5aoD4ApLkqDXHq++TZ7p+Zh0r9JtqjE73aniQ0INMvtjqXNMSX8+e6YkxRw0HRyaqdyb7W3oAFpvSuoGMMaCYbTaaNx3eOzS8zHpXiWmphYRfWo4m/KKDwm9Id+CUnrGWOocU9IneUXyf0QekJXmYpbvl1M6rec6SMZxkz1MSd0ALuqPgLQ2Gmft6vmYZDGvkjyc0yKi1YBKOcVCXD2TTkPB0t5WsGAodY4pSQXwt4GWxJ/bnBzCl1M67UWvuFjjzJE9TEndAIrMlqnVRuOMHz0fk+5Vuk2bq0YAcYmOO/wlQ6lzTEmfBs/JwGxviaEB2P8V0BampG4A5TQxem3Zz6HnY9K9SvfegpdYBhsU3TCUOseUNDiAu2fM9uYeFoCDDUIsNyV1A1hldfTaMoB6Pibdq3TbLbhWKTBWxzp3/wa9AnZKnWNKogC++xfVu343Ydne/ObY3jgAaL0paTd/7cvn1ci0C5Y5S6utAKjnY9K9SrdpUptwOQnKDxOvdjK5QqfUQaakT4NtMFi2NwsAtNyUFJCNQ+oQISLRpzettmqp1PIx6V6luyaio2E234LZJtlKMjZjKHWQKWkwAF8Nlu1tqADaUrVNLn/WQaakwQA8GCzbGwAY+czliDvIlDQYgGOZehEBgKMnBwA4Jp907ggCAAFAMwHscwqmkcYlazoNBAAqtjepDAACgJYAWDjEPGxvACAA2BeASra3OAIAAUAuAPZ+C/KIbG8AIADYD4A/96wz/fBsbwAgAHgvgH9515s/JPhwdR09WQBtmSkpveIcAO+vdNS29KztV/YwJRWzXiKG9VgNUzIlKWklfXQweC2SRTYb1hrUCjuiALZiZQu/3EiakkqBknAR1cJMzcmUVE5R5QIInUttoUbY49B27QkAyGxvqyMEoF1MSZ3Qa5MyJTHlcRMhiQXwx9g5Fj5zPoDxTWZ7K48UgLYwJdFx27b6wZxMSUxVln8kuYaUSFrUJh6nAPi3O37Fsr1xtr311Wm/Pusho5XUNqYkJEysqZ/MyZTE+qLCUE7kjl+WSAhpnhVnjIJv/YU52d7MAPDZ8x4ymultY0qKi1ntozmZkhCLs2UfL2N+v1gl8ungcjSAyyzbW6yBbABg/1dAm5iSkKneDwAABq9JREFU4mJAn3oxK1MS2lKngjzxsfMcO0BK3iTHArhvTra34Q9CrDclxcVEJ2TNrExJRXyhD6NF5rRbk5CjAXy5ZUq2t+EDaLkpKS5uxVMp7bprTqYk+ogqyVAvnwjNLS87mwJZ5wLYkp+rC2g0AbTalLQkTxpjdRtzMiWhl9K0UhgkyQCbVPdM7DkGwB9GwZMJf9MmXw4yJd2pg03kGAC7C5pejL1lANAsccqUtHHsTABZtrch2t6eAIDIXn1pcwCVbG9FBAACgBYAyCHbGwAIAPYP4LT52d4e22nrQI5JWh8BAF3E9Gxvj1PE1QByTFLDFbH/M+DSB5v1WsrVWPeAHq/1hiuF7AygK2HLp62xlAtkjlJjtgXwn7Lt7a097xwRuHqZooh+vG34Ku4yQ0cfuTICOV+WAFjzkm3t7dqHYCh40g3gf6KUvyqMNwFATjoKrbkWfEr87J7/1HUaWjZ+of/yzPYGAgDRL+x1eFDJ7JRm77A3E8YvxDXbGwgALPjZLXdBMVHJwT/zalywx+12z7BFNybdoCeiGTw5bADjcnz6qSj/wMJ80VVI+Y1idwY9LQnDB5CFLn4OdgD8SjpXwF08w/+kc0ITDtkNC66Ad9+Ch/RM4IwmoKfMGYRkbgxCoFsBQP7TMG99uyhAGXzl33ftd0/DQLcCgNwnokNsIno8cMtEtCfM/SWwM5qAngKBQCAQCAQCgUCgUVavGC3zm9ioVypby3z3AqEjHOPbxGQ1SoJtvm3Mi0R6a/pQtZmR8E/aD8blp61Szxgt85tI1PKuwEScZxMI7UpnMa4dVfgl82q3mefaxldyVSxJpsent6dPdAC7lp+2Sj1jtMxvgiky8Y1rE5H6WiDGtaNqYoH7waiyxbAO6xxa0QG8sfy0Ber9gtj8Jpjc5IJrE+EYMh/AriYyiWw0Z/5aL11tHE0sIyF4yhPAG8tPW6C7Y7T4NCGf26KHZxOvpEsOAHY1ESTZuaPkNdc20EGIU2oCHcAfV/+1BsC7YrT4NEG1X2nx3Au3t424AGjYC9FLr34rUa5tTEXXWifea6cDOPxb8MrEHNe9yGO/34+xX+C4F2fs+ayNCzx7qn4oXw1ecgTQDrfg3jFaHEYI+4Ou6DloE54dqtjWToHjXkx7KRfzEteDsc3+uyIRjgDaYRDSO0bL/Cb2Qx9SqVSZZxNMgRjXjprxVY/b0c9c2whPHBVLYtrsJsr5PJ7P76LzgGH5aUvVK0bL/Ca8sh0hzHUv+ADY1cTeayLyWPHU0EYkLBJv1fS4+Sn5AARQYBx1lp8GgUAgEAgEAoFAIBAIBAKBQCBQ/xLwzgPr1w+h90ADK/DDSk93ASjQWpWzm9kXI6kImsXs3WDjrqUCEhiHut9JrCWh40EqgJspqkgfAE6l8hk9ar9LCoB3KpFJzZSkBAAIug1A9a1vuz6RzAgKgI1EkogsC3l6IhnbNYC5i9fQejVJzuaQVomWs4sjzrJbsBIBz/KarwVJcEMDkEUELETpP/s5IlXLFFiq35HnUPK9bsIhAACZ3pwI+cziSxm01e254mwblcVs62M6F+kAeIlrqCqVviSSk1olWh55g4WUmwGYx0UWUCigmnRS/FD52gFQCLLgq/mp4qy4gAorSRbRk643hX0iwDF42gD6fT6fGrSUwi4ZtExW/nEjR//xkFkdwHI29NEdekMLo/NaJVau3ILZICR3itDha4QkWgmF1RjahN9HMD5QG7yKqrfgYz8LJR4PwzF42gBuCYJASRASXp8Pl2SgLsj2+R5Cq4xNH95QQSM+LF2hOcw8oZQ+tVI3gKc5NCYdUJIJ3ZKoEaeJTaFVzbAL6eyWRFn0KABeYfbnQwk4BnALphIzs64WvlBvtUsJco6ydYFpUgWwLbCMhyqAq1qlbgCLuDUVukRxfMS2LBqeAev0Slckh8vHG7SyDODX0LGgwA8CAFPMzzOlAUh1UEG1pBvdGB3Lt+BCdF6rxMqb8nrJ8jxg/TybQWgsarRDygDO+lLoiPm1whTAbxX6wYX3oPtBKoCRSkCY3VYBnL4QdjJ1OgjZahanqqnu6Rk6CPnIBiFqJVa+i79elhUAa97kEfvPd3DcWps3AIgWF+jV80BYkiiATTx1uY7S3pPi8mkJjgEASFUKkkXtChgOkmSM3j/jgSQRV93dALJpmPoc0irJ5eGoMg2DUCPkk+cEvy2GkuM/GQH8RuJoJUoySxTAsWwS/44K096QlP4CxwAEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBDo8fo/k0Kl4YgmmqQAAAAASUVORK5CYII=" style="width: 480.0px; height: 360.0px;"></a> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_roc#sphx-glr-auto-examples-model-selection-plot-roc-py"><span class="std std-ref">Receiver Operating Characteristic (ROC)</span></a> for an example of using ROC to evaluate the quality of the output of a classifier.</li> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_roc_crossval#sphx-glr-auto-examples-model-selection-plot-roc-crossval-py"><span class="std std-ref">Receiver Operating Characteristic (ROC) with cross validation</span></a> for an example of using ROC to evaluate classifier output quality, using cross-validation.</li> <li>See <a class="reference internal" href="../auto_examples/applications/plot_species_distribution_modeling#sphx-glr-auto-examples-applications-plot-species-distribution-modeling-py"><span class="std std-ref">Species distribution modeling</span></a> for an example of using ROC to model species distribution.</li> </ul> </div>   <h3 id="id23">3.3.2.14. Zero one loss</h3> <p id="zero-one-loss">The <a class="reference internal" href="generated/sklearn.metrics.zero_one_loss#sklearn.metrics.zero_one_loss" title="sklearn.metrics.zero_one_loss"><code>zero_one_loss</code></a> function computes the sum or the average of the 0-1 classification loss (<span class="math">\(L_{0-1}\)</span>) over <span class="math">\(n_{\text{samples}}\)</span>. By default, the function normalizes over the sample. To get the sum of the <span class="math">\(L_{0-1}\)</span>, set <code>normalize</code> to <code>False</code>.</p> <p>In multilabel classification, the <a class="reference internal" href="generated/sklearn.metrics.zero_one_loss#sklearn.metrics.zero_one_loss" title="sklearn.metrics.zero_one_loss"><code>zero_one_loss</code></a> scores a subset as one if its labels strictly match the predictions, and as a zero if there are any errors. By default, the function returns the percentage of imperfectly predicted subsets. To get the count of such subsets instead, set <code>normalize</code> to <code>False</code></p> <p>If <span class="math">\(\hat{y}_i\)</span> is the predicted value of the <span class="math">\(i\)</span>-th sample and <span class="math">\(y_i\)</span> is the corresponding true value, then the 0-1 loss <span class="math">\(L_{0-1}\)</span> is defined as:</p> <div class="math"> \[L_{0-1}(y_i, \hat{y}_i) = 1(\hat{y}_i \not= y_i)\]</div> <p>where <span class="math">\(1(x)\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Indicator_function">indicator function</a>.</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import zero_one_loss
&gt;&gt;&gt; y_pred = [1, 2, 3, 4]
&gt;&gt;&gt; y_true = [2, 2, 3, 4]
&gt;&gt;&gt; zero_one_loss(y_true, y_pred)
0.25
&gt;&gt;&gt; zero_one_loss(y_true, y_pred, normalize=False)
1
</pre> <p>In the multilabel case with binary label indicators, where the first label set [0,1] has an error:</p> <pre data-language="python">&gt;&gt;&gt; zero_one_loss(np.array([[0, 1], [1, 1]]), np.ones((2, 2)))
0.5

&gt;&gt;&gt; zero_one_loss(np.array([[0, 1], [1, 1]]), np.ones((2, 2)),  normalize=False)
1
</pre> <div class="topic"> <p class="topic-title first">Example:</p> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/feature_selection/plot_rfe_with_cross_validation#sphx-glr-auto-examples-feature-selection-plot-rfe-with-cross-validation-py"><span class="std std-ref">Recursive feature elimination with cross-validation</span></a> for an example of zero one loss usage to perform recursive feature elimination with cross-validation.</li> </ul> </div>   <h3 id="id25">3.3.2.15. Brier score loss</h3> <p id="brier-score-loss">The <a class="reference internal" href="generated/sklearn.metrics.brier_score_loss#sklearn.metrics.brier_score_loss" title="sklearn.metrics.brier_score_loss"><code>brier_score_loss</code></a> function computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Brier_score">Brier score</a> for binary classes. Quoting Wikipedia:</p>  “The Brier score is a proper score function that measures the accuracy of probabilistic predictions. It is applicable to tasks in which predictions must assign probabilities to a set of mutually exclusive discrete outcomes.” <p>This function returns a score of the mean square difference between the actual outcome and the predicted probability of the possible outcome. The actual outcome has to be 1 or 0 (true or false), while the predicted probability of the actual outcome can be a value between 0 and 1.</p> <p>The brier score loss is also between 0 to 1 and the lower the score (the mean square difference is smaller), the more accurate the prediction is. It can be thought of as a measure of the “calibration” of a set of probabilistic predictions.</p> <div class="math"> \[BS = \frac{1}{N} \sum_{t=1}^{N}(f_t - o_t)^2\]</div> <p>where : <span class="math">\(N\)</span> is the total number of predictions, <span class="math">\(f_t\)</span> is the predicted probability of the actual outcome <span class="math">\(o_t\)</span>.</p> <p>Here is a small example of usage of this function::</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import brier_score_loss
&gt;&gt;&gt; y_true = np.array([0, 1, 1, 0])
&gt;&gt;&gt; y_true_categorical = np.array(["spam", "ham", "ham", "spam"])
&gt;&gt;&gt; y_prob = np.array([0.1, 0.9, 0.8, 0.4])
&gt;&gt;&gt; y_pred = np.array([0, 1, 1, 0])
&gt;&gt;&gt; brier_score_loss(y_true, y_prob)
0.055
&gt;&gt;&gt; brier_score_loss(y_true, 1-y_prob, pos_label=0)
0.055
&gt;&gt;&gt; brier_score_loss(y_true_categorical, y_prob, pos_label="ham")
0.055
&gt;&gt;&gt; brier_score_loss(y_true, y_prob &gt; 0.5)
0.0
</pre> <div class="topic"> <p class="topic-title first">Example:</p> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/calibration/plot_calibration#sphx-glr-auto-examples-calibration-plot-calibration-py"><span class="std std-ref">Probability calibration of classifiers</span></a> for an example of Brier score loss usage to perform probability calibration of classifiers.</li> </ul> </div> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>G. Brier, <a class="reference external" href="ftp://ftp.library.noaa.gov/docs.lib/htdocs/rescue/mwr/078/mwr-078-01-0001.pdf">Verification of forecasts expressed in terms of probability</a>, Monthly weather review 78.1 (1950)</li> </ul> </div>    <h2 id="id26">3.3.3. Multilabel ranking metrics</h2> <p id="multilabel-ranking-metrics">In multilabel learning, each sample can have any number of ground truth labels associated with it. The goal is to give high scores and better rank to the ground truth labels.</p>  <h3 id="id27">3.3.3.1. Coverage error</h3> <p id="coverage-error">The <a class="reference internal" href="generated/sklearn.metrics.coverage_error#sklearn.metrics.coverage_error" title="sklearn.metrics.coverage_error"><code>coverage_error</code></a> function computes the average number of labels that have to be included in the final prediction such that all true labels are predicted. This is useful if you want to know how many top-scored-labels you have to predict in average without missing any true one. The best value of this metrics is thus the average number of true labels.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Our implementation’s score is 1 greater than the one given in Tsoumakas et al., 2010. This extends it to handle the degenerate case in which an instance has 0 true labels.</p> </div> <p>Formally, given a binary indicator matrix of the ground truth labels <span class="math">\(y \in \left\{0, 1\right\}^{n_\text{samples} \times n_\text{labels}}\)</span> and the score associated with each label <span class="math">\(\hat{f} \in \mathbb{R}^{n_\text{samples} \times n_\text{labels}}\)</span>, the coverage is defined as</p> <div class="math"> \[coverage(y, \hat{f}) = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}} - 1} \max_{j:y_{ij} = 1} \text{rank}_{ij}\]</div> <p>with <span class="math">\(\text{rank}_{ij} = \left|\left\{k: \hat{f}_{ik} \geq \hat{f}_{ij} \right\}\right|\)</span>. Given the rank definition, ties in <code>y_scores</code> are broken by giving the maximal rank that would have been assigned to all tied values.</p> <p>Here is a small example of usage of this function:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import coverage_error
&gt;&gt;&gt; y_true = np.array([[1, 0, 0], [0, 0, 1]])
&gt;&gt;&gt; y_score = np.array([[0.75, 0.5, 1], [1, 0.2, 0.1]])
&gt;&gt;&gt; coverage_error(y_true, y_score)
2.5
</pre>   <h3 id="id28">3.3.3.2. Label ranking average precision</h3> <p id="label-ranking-average-precision">The <a class="reference internal" href="generated/sklearn.metrics.label_ranking_average_precision_score#sklearn.metrics.label_ranking_average_precision_score" title="sklearn.metrics.label_ranking_average_precision_score"><code>label_ranking_average_precision_score</code></a> function implements label ranking average precision (LRAP). This metric is linked to the <a class="reference internal" href="generated/sklearn.metrics.average_precision_score#sklearn.metrics.average_precision_score" title="sklearn.metrics.average_precision_score"><code>average_precision_score</code></a> function, but is based on the notion of label ranking instead of precision and recall.</p> <p>Label ranking average precision (LRAP) averages over the samples the answer to the following question: for each ground truth label, what fraction of higher-ranked labels were true labels? This performance measure will be higher if you are able to give better rank to the labels associated with each sample. The obtained score is always strictly greater than 0, and the best value is 1. If there is exactly one relevant label per sample, label ranking average precision is equivalent to the <a class="reference external" href="https://en.wikipedia.org/wiki/Mean_reciprocal_rank">mean reciprocal rank</a>.</p> <p>Formally, given a binary indicator matrix of the ground truth labels <span class="math">\(y \in \left\{0, 1\right\}^{n_\text{samples} \times n_\text{labels}}\)</span> and the score associated with each label <span class="math">\(\hat{f} \in \mathbb{R}^{n_\text{samples} \times n_\text{labels}}\)</span>, the average precision is defined as</p> <div class="math"> \[LRAP(y, \hat{f}) = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}} - 1} \frac{1}{||y_i||_0} \sum_{j:y_{ij} = 1} \frac{|\mathcal{L}_{ij}|}{\text{rank}_{ij}}\]</div> <p>where <span class="math">\(\mathcal{L}_{ij} = \left\{k: y_{ik} = 1, \hat{f}_{ik} \geq \hat{f}_{ij} \right\}\)</span>, <span class="math">\(\text{rank}_{ij} = \left|\left\{k: \hat{f}_{ik} \geq \hat{f}_{ij} \right\}\right|\)</span>, <span class="math">\(|\cdot|\)</span> computes the cardinality of the set (i.e., the number of elements in the set), and <span class="math">\(||\cdot||_0\)</span> is the <span class="math">\(\ell_0\)</span> “norm” (which computes the number of nonzero elements in a vector).</p> <p>Here is a small example of usage of this function:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import label_ranking_average_precision_score
&gt;&gt;&gt; y_true = np.array([[1, 0, 0], [0, 0, 1]])
&gt;&gt;&gt; y_score = np.array([[0.75, 0.5, 1], [1, 0.2, 0.1]])
&gt;&gt;&gt; label_ranking_average_precision_score(y_true, y_score) 
0.416...
</pre>   <h3 id="label-ranking-loss">3.3.3.3. Ranking loss</h3> <p id="ranking-loss">The <a class="reference internal" href="generated/sklearn.metrics.label_ranking_loss#sklearn.metrics.label_ranking_loss" title="sklearn.metrics.label_ranking_loss"><code>label_ranking_loss</code></a> function computes the ranking loss which averages over the samples the number of label pairs that are incorrectly ordered, i.e. true labels have a lower score than false labels, weighted by the inverse of the number of ordered pairs of false and true labels. The lowest achievable ranking loss is zero.</p> <p>Formally, given a binary indicator matrix of the ground truth labels <span class="math">\(y \in \left\{0, 1\right\}^{n_\text{samples} \times n_\text{labels}}\)</span> and the score associated with each label <span class="math">\(\hat{f} \in \mathbb{R}^{n_\text{samples} \times n_\text{labels}}\)</span>, the ranking loss is defined as</p> <div class="math"> \[\text{ranking\_loss}(y, \hat{f}) = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}} - 1} \frac{1}{||y_i||_0(n_\text{labels} - ||y_i||_0)} \left|\left\{(k, l): \hat{f}_{ik} \leq \hat{f}_{il}, y_{ik} = 1, y_{il} = 0 \right\}\right|\]</div> <p>where <span class="math">\(|\cdot|\)</span> computes the cardinality of the set (i.e., the number of elements in the set) and <span class="math">\(||\cdot||_0\)</span> is the <span class="math">\(\ell_0\)</span> “norm” (which computes the number of nonzero elements in a vector).</p> <p>Here is a small example of usage of this function:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from sklearn.metrics import label_ranking_loss
&gt;&gt;&gt; y_true = np.array([[1, 0, 0], [0, 0, 1]])
&gt;&gt;&gt; y_score = np.array([[0.75, 0.5, 1], [1, 0.2, 0.1]])
&gt;&gt;&gt; label_ranking_loss(y_true, y_score) 
0.75...
&gt;&gt;&gt; # With the following prediction, we have perfect and minimal loss
&gt;&gt;&gt; y_score = np.array([[1.0, 0.1, 0.2], [0.1, 0.2, 0.9]])
&gt;&gt;&gt; label_ranking_loss(y_true, y_score)
0.0
</pre> <div class="topic"> <p class="topic-title first">References:</p> <ul class="simple"> <li>Tsoumakas, G., Katakis, I., &amp; Vlahavas, I. (2010). Mining multi-label data. In Data mining and knowledge discovery handbook (pp. 667-685). Springer US.</li> </ul> </div>    <h2 id="id29">3.3.4. Regression metrics</h2> <p id="regression-metrics">The <a class="reference internal" href="classes#module-sklearn.metrics" title="sklearn.metrics"><code>sklearn.metrics</code></a> module implements several loss, score, and utility functions to measure regression performance. Some of those have been enhanced to handle the multioutput case: <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code>mean_squared_error</code></a>, <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><code>mean_absolute_error</code></a>, <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code>explained_variance_score</code></a> and <a class="reference internal" href="generated/sklearn.metrics.r2_score#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a>.</p> <p>These functions have an <code>multioutput</code> keyword argument which specifies the way the scores or losses for each individual target should be averaged. The default is <code>'uniform_average'</code>, which specifies a uniformly weighted mean over outputs. If an <code>ndarray</code> of shape <code>(n_outputs,)</code> is passed, then its entries are interpreted as weights and an according weighted average is returned. If <code>multioutput</code> is <code>'raw_values'</code> is specified, then all unaltered individual scores or losses will be returned in an array of shape <code>(n_outputs,)</code>.</p> <p>The <a class="reference internal" href="generated/sklearn.metrics.r2_score#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a> and <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code>explained_variance_score</code></a> accept an additional value <code>'variance_weighted'</code> for the <code>multioutput</code> parameter. This option leads to a weighting of each individual score by the variance of the corresponding target variable. This setting quantifies the globally captured unscaled variance. If the target variables are of different scale, then this score puts more importance on well explaining the higher variance variables. <code>multioutput='variance_weighted'</code> is the default value for <a class="reference internal" href="generated/sklearn.metrics.r2_score#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a> for backward compatibility. This will be changed to <code>uniform_average</code> in the future.</p>  <h3 id="id30">3.3.4.1. Explained variance score</h3> <p id="explained-variance-score">The <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code>explained_variance_score</code></a> computes the <a class="reference external" href="https://en.wikipedia.org/wiki/Explained_variation">explained variance regression score</a>.</p> <p>If <span class="math">\(\hat{y}\)</span> is the estimated target output, <span class="math">\(y\)</span> the corresponding (correct) target output, and <span class="math">\(Var\)</span> is <a class="reference external" href="https://en.wikipedia.org/wiki/Variance">Variance</a>, the square of the standard deviation, then the explained variance is estimated as follow:</p> <div class="math"> \[\texttt{explained\_{}variance}(y, \hat{y}) = 1 - \frac{Var\{ y - \hat{y}\}}{Var\{y\}}\]</div> <p>The best possible score is 1.0, lower values are worse.</p> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.explained_variance_score#sklearn.metrics.explained_variance_score" title="sklearn.metrics.explained_variance_score"><code>explained_variance_score</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import explained_variance_score
&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]
&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]
&gt;&gt;&gt; explained_variance_score(y_true, y_pred)  
0.957...
&gt;&gt;&gt; y_true = [[0.5, 1], [-1, 1], [7, -6]]
&gt;&gt;&gt; y_pred = [[0, 2], [-1, 2], [8, -5]]
&gt;&gt;&gt; explained_variance_score(y_true, y_pred, multioutput='raw_values')
... 
array([0.967..., 1.        ])
&gt;&gt;&gt; explained_variance_score(y_true, y_pred, multioutput=[0.3, 0.7])
... 
0.990...
</pre>   <h3 id="id31">3.3.4.2. Mean absolute error</h3> <p id="mean-absolute-error">The <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><code>mean_absolute_error</code></a> function computes <a class="reference external" href="https://en.wikipedia.org/wiki/Mean_absolute_error">mean absolute error</a>, a risk metric corresponding to the expected value of the absolute error loss or <span class="math">\(l1\)</span>-norm loss.</p> <p>If <span class="math">\(\hat{y}_i\)</span> is the predicted value of the <span class="math">\(i\)</span>-th sample, and <span class="math">\(y_i\)</span> is the corresponding true value, then the mean absolute error (MAE) estimated over <span class="math">\(n_{\text{samples}}\)</span> is defined as</p> <div class="math"> \[\text{MAE}(y, \hat{y}) = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}}-1} \left| y_i - \hat{y}_i \right|.\]</div> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.mean_absolute_error#sklearn.metrics.mean_absolute_error" title="sklearn.metrics.mean_absolute_error"><code>mean_absolute_error</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import mean_absolute_error
&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]
&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]
&gt;&gt;&gt; mean_absolute_error(y_true, y_pred)
0.5
&gt;&gt;&gt; y_true = [[0.5, 1], [-1, 1], [7, -6]]
&gt;&gt;&gt; y_pred = [[0, 2], [-1, 2], [8, -5]]
&gt;&gt;&gt; mean_absolute_error(y_true, y_pred)
0.75
&gt;&gt;&gt; mean_absolute_error(y_true, y_pred, multioutput='raw_values')
array([0.5, 1. ])
&gt;&gt;&gt; mean_absolute_error(y_true, y_pred, multioutput=[0.3, 0.7])
... 
0.85...
</pre>   <h3 id="id33">3.3.4.3. Mean squared error</h3> <p id="mean-squared-error">The <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code>mean_squared_error</code></a> function computes <a class="reference external" href="https://en.wikipedia.org/wiki/Mean_squared_error">mean square error</a>, a risk metric corresponding to the expected value of the squared (quadratic) error or loss.</p> <p>If <span class="math">\(\hat{y}_i\)</span> is the predicted value of the <span class="math">\(i\)</span>-th sample, and <span class="math">\(y_i\)</span> is the corresponding true value, then the mean squared error (MSE) estimated over <span class="math">\(n_{\text{samples}}\)</span> is defined as</p> <div class="math"> \[\text{MSE}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples} - 1} (y_i - \hat{y}_i)^2.\]</div> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.mean_squared_error#sklearn.metrics.mean_squared_error" title="sklearn.metrics.mean_squared_error"><code>mean_squared_error</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import mean_squared_error
&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]
&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]
&gt;&gt;&gt; mean_squared_error(y_true, y_pred)
0.375
&gt;&gt;&gt; y_true = [[0.5, 1], [-1, 1], [7, -6]]
&gt;&gt;&gt; y_pred = [[0, 2], [-1, 2], [8, -5]]
&gt;&gt;&gt; mean_squared_error(y_true, y_pred)  
0.7083...
</pre> <div class="topic"> <p class="topic-title first">Examples:</p> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/ensemble/plot_gradient_boosting_regression#sphx-glr-auto-examples-ensemble-plot-gradient-boosting-regression-py"><span class="std std-ref">Gradient Boosting regression</span></a> for an example of mean squared error usage to evaluate gradient boosting regression.</li> </ul> </div>   <h3 id="mean-squared-log-error">3.3.4.4. Mean squared logarithmic error</h3> <p id="mean-squared-logarithmic-error">The <a class="reference internal" href="generated/sklearn.metrics.mean_squared_log_error#sklearn.metrics.mean_squared_log_error" title="sklearn.metrics.mean_squared_log_error"><code>mean_squared_log_error</code></a> function computes a risk metric corresponding to the expected value of the squared logarithmic (quadratic) error or loss.</p> <p>If <span class="math">\(\hat{y}_i\)</span> is the predicted value of the <span class="math">\(i\)</span>-th sample, and <span class="math">\(y_i\)</span> is the corresponding true value, then the mean squared logarithmic error (MSLE) estimated over <span class="math">\(n_{\text{samples}}\)</span> is defined as</p> <div class="math"> \[\text{MSLE}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples} - 1} (\log_e (1 + y_i) - \log_e (1 + \hat{y}_i) )^2.\]</div> <p>Where <span class="math">\(\log_e (x)\)</span> means the natural logarithm of <span class="math">\(x\)</span>. This metric is best to use when targets having exponential growth, such as population counts, average sales of a commodity over a span of years etc. Note that this metric penalizes an under-predicted estimate greater than an over-predicted estimate.</p> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.mean_squared_log_error#sklearn.metrics.mean_squared_log_error" title="sklearn.metrics.mean_squared_log_error"><code>mean_squared_log_error</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import mean_squared_log_error
&gt;&gt;&gt; y_true = [3, 5, 2.5, 7]
&gt;&gt;&gt; y_pred = [2.5, 5, 4, 8]
&gt;&gt;&gt; mean_squared_log_error(y_true, y_pred)  
0.039...
&gt;&gt;&gt; y_true = [[0.5, 1], [1, 2], [7, 6]]
&gt;&gt;&gt; y_pred = [[0.5, 2], [1, 2.5], [8, 8]]
&gt;&gt;&gt; mean_squared_log_error(y_true, y_pred)  
0.044...
</pre>   <h3 id="id34">3.3.4.5. Median absolute error</h3> <p id="median-absolute-error">The <a class="reference internal" href="generated/sklearn.metrics.median_absolute_error#sklearn.metrics.median_absolute_error" title="sklearn.metrics.median_absolute_error"><code>median_absolute_error</code></a> is particularly interesting because it is robust to outliers. The loss is calculated by taking the median of all absolute differences between the target and the prediction.</p> <p>If <span class="math">\(\hat{y}_i\)</span> is the predicted value of the <span class="math">\(i\)</span>-th sample and <span class="math">\(y_i\)</span> is the corresponding true value, then the median absolute error (MedAE) estimated over <span class="math">\(n_{\text{samples}}\)</span> is defined as</p> <div class="math"> \[\text{MedAE}(y, \hat{y}) = \text{median}(\mid y_1 - \hat{y}_1 \mid, \ldots, \mid y_n - \hat{y}_n \mid).\]</div> <p>The <a class="reference internal" href="generated/sklearn.metrics.median_absolute_error#sklearn.metrics.median_absolute_error" title="sklearn.metrics.median_absolute_error"><code>median_absolute_error</code></a> does not support multioutput.</p> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.median_absolute_error#sklearn.metrics.median_absolute_error" title="sklearn.metrics.median_absolute_error"><code>median_absolute_error</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import median_absolute_error
&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]
&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]
&gt;&gt;&gt; median_absolute_error(y_true, y_pred)
0.5
</pre>   <h3 id="r2-score">3.3.4.6. R² score, the coefficient of determination</h3> <p id="r2-score-the-coefficient-of-determination">The <a class="reference internal" href="generated/sklearn.metrics.r2_score#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a> function computes R², the <a class="reference external" href="https://en.wikipedia.org/wiki/Coefficient_of_determination">coefficient of determination</a>. It provides a measure of how well future samples are likely to be predicted by the model. Best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of y, disregarding the input features, would get a R^2 score of 0.0.</p> <p>If <span class="math">\(\hat{y}_i\)</span> is the predicted value of the <span class="math">\(i\)</span>-th sample and <span class="math">\(y_i\)</span> is the corresponding true value, then the score R² estimated over <span class="math">\(n_{\text{samples}}\)</span> is defined as</p> <div class="math"> \[R^2(y, \hat{y}) = 1 - \frac{\sum_{i=0}^{n_{\text{samples}} - 1} (y_i - \hat{y}_i)^2}{\sum_{i=0}^{n_\text{samples} - 1} (y_i - \bar{y})^2}\]</div> <p>where <span class="math">\(\bar{y} = \frac{1}{n_{\text{samples}}} \sum_{i=0}^{n_{\text{samples}} - 1} y_i\)</span>.</p> <p>Here is a small example of usage of the <a class="reference internal" href="generated/sklearn.metrics.r2_score#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.metrics import r2_score
&gt;&gt;&gt; y_true = [3, -0.5, 2, 7]
&gt;&gt;&gt; y_pred = [2.5, 0.0, 2, 8]
&gt;&gt;&gt; r2_score(y_true, y_pred)  
0.948...
&gt;&gt;&gt; y_true = [[0.5, 1], [-1, 1], [7, -6]]
&gt;&gt;&gt; y_pred = [[0, 2], [-1, 2], [8, -5]]
&gt;&gt;&gt; r2_score(y_true, y_pred, multioutput='variance_weighted')
... 
0.938...
&gt;&gt;&gt; y_true = [[0.5, 1], [-1, 1], [7, -6]]
&gt;&gt;&gt; y_pred = [[0, 2], [-1, 2], [8, -5]]
&gt;&gt;&gt; r2_score(y_true, y_pred, multioutput='uniform_average')
... 
0.936...
&gt;&gt;&gt; r2_score(y_true, y_pred, multioutput='raw_values')
... 
array([0.965..., 0.908...])
&gt;&gt;&gt; r2_score(y_true, y_pred, multioutput=[0.3, 0.7])
... 
0.925...
</pre> <div class="topic"> <p class="topic-title first">Example:</p> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/linear_model/plot_lasso_and_elasticnet#sphx-glr-auto-examples-linear-model-plot-lasso-and-elasticnet-py"><span class="std std-ref">Lasso and Elastic Net for Sparse Signals</span></a> for an example of R² score usage to evaluate Lasso and Elastic Net on sparse signals.</li> </ul> </div>    <h2 id="id35">3.3.5. Clustering metrics</h2> <p id="clustering-metrics">The <a class="reference internal" href="classes#module-sklearn.metrics" title="sklearn.metrics"><code>sklearn.metrics</code></a> module implements several loss, score, and utility functions. For more information see the <a class="reference internal" href="clustering#clustering-evaluation"><span class="std std-ref">Clustering performance evaluation</span></a> section for instance clustering, and <a class="reference internal" href="biclustering#biclustering-evaluation"><span class="std std-ref">Biclustering evaluation</span></a> for biclustering.</p>   <h2 id="id36">3.3.6. Dummy estimators</h2> <p id="dummy-estimators">When doing supervised learning, a simple sanity check consists of comparing one’s estimator against simple rules of thumb. <a class="reference internal" href="generated/sklearn.dummy.dummyclassifier#sklearn.dummy.DummyClassifier" title="sklearn.dummy.DummyClassifier"><code>DummyClassifier</code></a> implements several such simple strategies for classification:</p> <ul class="simple"> <li>
<code>stratified</code> generates random predictions by respecting the training set class distribution.</li> <li>
<code>most_frequent</code> always predicts the most frequent label in the training set.</li> <li>
<code>prior</code> always predicts the class that maximizes the class prior (like <code>most_frequent</code>) and <code>predict_proba</code> returns the class prior.</li> <li>
<code>uniform</code> generates predictions uniformly at random.</li> <li>
<dl class="first docutils"> <dt>
<code>constant always predicts a constant label that is provided by the user.</code> </dt> <dd>A major motivation of this method is F1-scoring, when the positive class is in the minority.</dd> </dl> </li> </ul> <p>Note that with all these strategies, the <code>predict</code> method completely ignores the input data!</p> <p>To illustrate <a class="reference internal" href="generated/sklearn.dummy.dummyclassifier#sklearn.dummy.DummyClassifier" title="sklearn.dummy.DummyClassifier"><code>DummyClassifier</code></a>, first let’s create an imbalanced dataset:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import load_iris
&gt;&gt;&gt; from sklearn.model_selection import train_test_split
&gt;&gt;&gt; iris = load_iris()
&gt;&gt;&gt; X, y = iris.data, iris.target
&gt;&gt;&gt; y[y != 1] = -1
&gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)
</pre> <p>Next, let’s compare the accuracy of <code>SVC</code> and <code>most_frequent</code>:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.dummy import DummyClassifier
&gt;&gt;&gt; from sklearn.svm import SVC
&gt;&gt;&gt; clf = SVC(kernel='linear', C=1).fit(X_train, y_train)
&gt;&gt;&gt; clf.score(X_test, y_test) 
0.63...
&gt;&gt;&gt; clf = DummyClassifier(strategy='most_frequent',random_state=0)
&gt;&gt;&gt; clf.fit(X_train, y_train)
DummyClassifier(constant=None, random_state=0, strategy='most_frequent')
&gt;&gt;&gt; clf.score(X_test, y_test)  
0.57...
</pre> <p>We see that <code>SVC</code> doesn’t do much better than a dummy classifier. Now, let’s change the kernel:</p> <pre data-language="python">&gt;&gt;&gt; clf = SVC(gamma='scale', kernel='rbf', C=1).fit(X_train, y_train)
&gt;&gt;&gt; clf.score(X_test, y_test)  
0.97...
</pre> <p>We see that the accuracy was boosted to almost 100%. A cross validation strategy is recommended for a better estimate of the accuracy, if it is not too CPU costly. For more information see the <a class="reference internal" href="cross_validation#cross-validation"><span class="std std-ref">Cross-validation: evaluating estimator performance</span></a> section. Moreover if you want to optimize over the parameter space, it is highly recommended to use an appropriate methodology; see the <a class="reference internal" href="grid_search#grid-search"><span class="std std-ref">Tuning the hyper-parameters of an estimator</span></a> section for details.</p> <p>More generally, when the accuracy of a classifier is too close to random, it probably means that something went wrong: features are not helpful, a hyperparameter is not correctly tuned, the classifier is suffering from class imbalance, etc…</p> <p><a class="reference internal" href="generated/sklearn.dummy.dummyregressor#sklearn.dummy.DummyRegressor" title="sklearn.dummy.DummyRegressor"><code>DummyRegressor</code></a> also implements four simple rules of thumb for regression:</p> <ul class="simple"> <li>
<code>mean</code> always predicts the mean of the training targets.</li> <li>
<code>median</code> always predicts the median of the training targets.</li> <li>
<code>quantile</code> always predicts a user provided quantile of the training targets.</li> <li>
<code>constant</code> always predicts a constant value that is provided by the user.</li> </ul> <p>In all these strategies, the <code>predict</code> method completely ignores the input data.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2007–2018 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="http://scikit-learn.org/stable/modules/model_evaluation.html" class="_attribution-link">http://scikit-learn.org/stable/modules/model_evaluation.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
