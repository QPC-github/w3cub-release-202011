
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Control.Exception - Haskell 7 - W3cubDocs</title>
  
  <meta name="description" content=" This module provides support for raising and catching both built-in and user-defined exceptions. ">
  <meta name="keywords" content="control, exception, haskell, haskell~7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~7/libraries/base-4.8.2.0/control-exception.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/haskell~7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~7/" class="_nav-link" title="" style="margin-left:0;">Haskell 7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 class="caption">Control.Exception</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th>Copyright</th>
<td>(c) The University of Glasgow 2001</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style (see the file libraries/base/LICENSE)</td>
</tr>
<tr>
<th>Maintainer</th>
<td>libraries@haskell.org</td>
</tr>
<tr>
<th>Stability</th>
<td>experimental</td>
</tr>
<tr>
<th>Portability</th>
<td>non-portable (extended exceptions)</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Trustworthy</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="table-of-contents">
<h4 class="caption">Contents</h4>
<ul>
<li><a href="#g:1">The Exception type</a></li>
<li><a href="#g:2">Throwing exceptions</a></li>
<li>
<a href="#g:3">Catching Exceptions</a><ul>
<li><a href="#g:4">Catching all exceptions</a></li>
<li><a href="#g:5">The <code>catch</code> functions</a></li>
<li><a href="#g:6">The <code>handle</code> functions</a></li>
<li><a href="#g:7">The <code>try</code> functions</a></li>
<li><a href="#g:8">The <code>evaluate</code> function</a></li>
<li><a href="#g:9">The <code>mapException</code> function</a></li>
</ul>
</li>
<li>
<a href="#g:10">Asynchronous Exceptions</a><ul><li>
<a href="#g:11">Asynchronous exception control</a><ul>
<li><a href="#g:12">Applying <code>mask</code> to an exception handler</a></li>
<li><a href="#g:13">Interruptible operations</a></li>
</ul>
</li></ul>
</li>
<li><a href="#g:14">Assertions</a></li>
<li><a href="#g:15">Utilities</a></li>
</ul>
</div>
<div id="description">
<h4 class="caption">Description</h4>
<p>This module provides support for raising and catching both built-in and user-defined exceptions.</p>
<p>In addition to exceptions thrown by <code><a href="system-io#t:IO">IO</a></code> operations, exceptions may be thrown by pure code (imprecise exceptions) or by external events (asynchronous exceptions), but may only be caught in the <code><a href="system-io#t:IO">IO</a></code> monad. For more details, see:</p>
<ul>
<li>
<em>A semantics for imprecise exceptions</em>, by Simon Peyton Jones, Alastair Reid, Tony Hoare, Simon Marlow, Fergus Henderson, in <em>PLDI'99</em>.</li>
<li>
<em>Asynchronous exceptions in Haskell</em>, by Simon Marlow, Simon Peyton Jones, Andy Moran and John Reppy, in <em>PLDI'01</em>.</li>
<li>
<em>An Extensible Dynamically-Typed Hierarchy of Exceptions</em>, by Simon Marlow, in <em>Haskell '06</em>.</li>
</ul>
</div>
<h2 id="g:1">The Exception type</h2>
<p class="src">data <a class="def" id="t:SomeException">SomeException</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-Exception.html#SomeException" class="link">Source</a></p>
<p>The <code>SomeException</code> type is the root of the exception type hierarchy. When an exception of type <code>e</code> is thrown, behind the scenes it is encapsulated in a <code>SomeException</code>.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">forall e . <a href="control-exception#t:Exception">Exception</a> e =&gt; <a class="def" id="v:SomeException">SomeException</a> e</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:SomeException" class="caption collapser" onclick="toggleSection('i:SomeException')">Instances</h4>
<div id="section.i:SomeException" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:SomeException">SomeException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:SomeException">SomeException</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">class (<a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/Data-Typeable-Internal.html#t:Typeable">Typeable</a> e, <a href="text-show#t:Show">Show</a> e) =&gt; <a class="def" id="t:Exception">Exception</a> e where <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-Exception.html#Exception" class="link">Source</a></p>
<p>Any type that you wish to throw or catch as an exception must be an instance of the <code>Exception</code> class. The simplest case is a new exception type directly below the root:</p>
<pre>data MyException = ThisException | ThatException
    deriving (Show, Typeable)

instance Exception MyException</pre>
<p>The default method definitions in the <code>Exception</code> class do what we need in this case. You can now throw and catch <code>ThisException</code> and <code>ThatException</code> as exceptions:</p>
<pre>*Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
Caught ThisException
</pre>
<p>In more complicated examples, you may wish to define a whole hierarchy of exceptions:</p>
<pre>---------------------------------------------------------------------
-- Make the root exception type for all the exceptions in a compiler

data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
    deriving Typeable

instance Show SomeCompilerException where
    show (SomeCompilerException e) = show e

instance Exception SomeCompilerException

compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
compilerExceptionToException = toException . SomeCompilerException

compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
compilerExceptionFromException x = do
    SomeCompilerException a &lt;- fromException x
    cast a

---------------------------------------------------------------------
-- Make a subhierarchy for exceptions in the frontend of the compiler

data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
    deriving Typeable

instance Show SomeFrontendException where
    show (SomeFrontendException e) = show e

instance Exception SomeFrontendException where
    toException = compilerExceptionToException
    fromException = compilerExceptionFromException

frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
frontendExceptionToException = toException . SomeFrontendException

frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
frontendExceptionFromException x = do
    SomeFrontendException a &lt;- fromException x
    cast a

---------------------------------------------------------------------
-- Make an exception type for a particular frontend compiler exception

data MismatchedParentheses = MismatchedParentheses
    deriving (Typeable, Show)

instance Exception MismatchedParentheses where
    toException   = frontendExceptionToException
    fromException = frontendExceptionFromException</pre>
<p>We can now catch a <code>MismatchedParentheses</code> exception as <code>MismatchedParentheses</code>, <code>SomeFrontendException</code> or <code>SomeCompilerException</code>, but not other types, e.g. <code>IOException</code>:</p>
<pre>*Main&gt; throw MismatchedParentheses <code>catch</code> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
Caught MismatchedParentheses
*Main&gt; throw MismatchedParentheses <code>catch</code> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
Caught MismatchedParentheses
*Main&gt; throw MismatchedParentheses <code>catch</code> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
Caught MismatchedParentheses
*Main&gt; throw MismatchedParentheses <code>catch</code> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
*** Exception: MismatchedParentheses
</pre>
<div class="subs minimal">
<h4 class="caption">Minimal complete definition</h4>
<p class="src">Nothing</p>
</div>
<div class="subs methods">
<h4 class="caption">Methods</h4>
<p class="src"><a class="def" id="v:toException">toException</a> :: e -&gt; <a href="control-exception#t:SomeException">SomeException</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-Exception.html#toException" class="link">Source</a></p>
<p class="src"><a class="def" id="v:fromException">fromException</a> :: <a href="control-exception#t:SomeException">SomeException</a> -&gt; <a href="data-maybe#t:Maybe">Maybe</a> e <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-Exception.html#fromException" class="link">Source</a></p>
<p class="src"><a class="def" id="v:displayException">displayException</a> :: e -&gt; <a href="data-string#t:String">String</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-Exception.html#displayException" class="link">Source</a></p>
<p>Render this exception value in a human-friendly manner.</p>
<p>Default implementation: <code><a href="text-show#v:show">show</a></code>.</p>
<p><span class="version">Since: 4.8.0.0</span></p>
</div>
<div class="subs instances">
<h4 id="control.i:Exception" class="caption collapser" onclick="toggleSection('i:Exception')">Instances</h4>
<div id="section.i:Exception" class="show"><table>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:SomeException">SomeException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:ArithException">ArithException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:ErrorCall">ErrorCall</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:IOException">IOException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="data-dynamic#t:Dynamic">Dynamic</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="system-exit#t:ExitCode">ExitCode</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:ArrayException">ArrayException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:AsyncException">AsyncException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:SomeAsyncException">SomeAsyncException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:AssertionFailed">AssertionFailed</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:AllocationLimitExceeded">AllocationLimitExceeded</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:Deadlock">Deadlock</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:BlockedIndefinitelyOnSTM">BlockedIndefinitelyOnSTM</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:BlockedIndefinitelyOnMVar">BlockedIndefinitelyOnMVar</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:NestedAtomically">NestedAtomically</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:NonTermination">NonTermination</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:NoMethodError">NoMethodError</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:RecUpdError">RecUpdError</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:RecConError">RecConError</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:RecSelError">RecSelError</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:PatternMatchFail">PatternMatchFail</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="data-void#t:Void">Void</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:IOException">IOException</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO-Exception.html#IOException" class="link">Source</a></p>
<p>Exceptions that occur in the <code>IO</code> monad. An <code>IOException</code> records a more specific error type, a descriptive string and maybe the handle that was used when the error was flagged.</p>
<div class="subs instances">
<h4 id="control.i:IOException" class="caption collapser" onclick="toggleSection('i:IOException')">Instances</h4>
<div id="section.i:IOException" class="show"><table>
<tr>
<td class="src clearfix">
<a href="data-eq#t:Eq">Eq</a> <a href="control-exception#t:IOException">IOException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:IOException">IOException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:IOException">IOException</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:ArithException">ArithException</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-Exception.html#ArithException" class="link">Source</a></p>
<p>Arithmetic exceptions.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table>
<tr>
<td class="src"><a class="def" id="v:Overflow">Overflow</a></td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src"><a class="def" id="v:Underflow">Underflow</a></td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src"><a class="def" id="v:LossOfPrecision">LossOfPrecision</a></td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src"><a class="def" id="v:DivideByZero">DivideByZero</a></td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src"><a class="def" id="v:Denormal">Denormal</a></td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src"><a class="def" id="v:RatioZeroDenominator">RatioZeroDenominator</a></td>
<td class="doc"><p><span class="version">Since: 4.6.0.0</span></p></td>
</tr>
</table>
</div>
<div class="subs instances">
<h4 id="control.i:ArithException" class="caption collapser" onclick="toggleSection('i:ArithException')">Instances</h4>
<div id="section.i:ArithException" class="show"><table>
<tr>
<td class="src clearfix">
<a href="data-eq#t:Eq">Eq</a> <a href="control-exception#t:ArithException">ArithException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="data-ord#t:Ord">Ord</a> <a href="control-exception#t:ArithException">ArithException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:ArithException">ArithException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:ArithException">ArithException</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:ArrayException">ArrayException</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO-Exception.html#ArrayException" class="link">Source</a></p>
<p>Exceptions generated by array operations</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table>
<tr>
<td class="src">
<a class="def" id="v:IndexOutOfBounds">IndexOutOfBounds</a> <a href="data-string#t:String">String</a>
</td>
<td class="doc"><p>An attempt was made to index an array outside its declared bounds.</p></td>
</tr>
<tr>
<td class="src">
<a class="def" id="v:UndefinedElement">UndefinedElement</a> <a href="data-string#t:String">String</a>
</td>
<td class="doc"><p>An attempt was made to evaluate an element of an array that had not been initialized.</p></td>
</tr>
</table>
</div>
<div class="subs instances">
<h4 id="control.i:ArrayException" class="caption collapser" onclick="toggleSection('i:ArrayException')">Instances</h4>
<div id="section.i:ArrayException" class="show"><table>
<tr>
<td class="src clearfix">
<a href="data-eq#t:Eq">Eq</a> <a href="control-exception#t:ArrayException">ArrayException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="data-ord#t:Ord">Ord</a> <a href="control-exception#t:ArrayException">ArrayException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:ArrayException">ArrayException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:ArrayException">ArrayException</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:AssertionFailed">AssertionFailed</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO-Exception.html#AssertionFailed" class="link">Source</a></p>
<p><code><a href="control-exception#v:assert">assert</a></code> was applied to <code><a href="data-bool#v:False">False</a></code>.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">
<a class="def" id="v:AssertionFailed">AssertionFailed</a> <a href="data-string#t:String">String</a>
</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:AssertionFailed" class="caption collapser" onclick="toggleSection('i:AssertionFailed')">Instances</h4>
<div id="section.i:AssertionFailed" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:AssertionFailed">AssertionFailed</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:AssertionFailed">AssertionFailed</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:SomeAsyncException">SomeAsyncException</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO-Exception.html#SomeAsyncException" class="link">Source</a></p>
<p>Superclass for asynchronous exceptions.</p>
<p><span class="version">Since: 4.7.0.0</span></p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">forall e . <a href="control-exception#t:Exception">Exception</a> e =&gt; <a class="def" id="v:SomeAsyncException">SomeAsyncException</a> e</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:SomeAsyncException" class="caption collapser" onclick="toggleSection('i:SomeAsyncException')">Instances</h4>
<div id="section.i:SomeAsyncException" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:SomeAsyncException">SomeAsyncException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:SomeAsyncException">SomeAsyncException</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:AsyncException">AsyncException</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO-Exception.html#AsyncException" class="link">Source</a></p>
<p>Asynchronous exceptions.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table>
<tr>
<td class="src"><a class="def" id="v:StackOverflow">StackOverflow</a></td>
<td class="doc"><p>The current thread's stack exceeded its limit. Since an exception has been raised, the thread's stack will certainly be below its limit again, but the programmer should take remedial action immediately.</p></td>
</tr>
<tr>
<td class="src"><a class="def" id="v:HeapOverflow">HeapOverflow</a></td>
<td class="doc">
<p>The program's heap is reaching its limit, and the program should take action to reduce the amount of live data it has. Notes:</p>
<ul>
<li>It is undefined which thread receives this exception.</li>
<li>GHC currently does not throw <code><a href="control-exception#v:HeapOverflow">HeapOverflow</a></code> exceptions.</li>
</ul>
</td>
</tr>
<tr>
<td class="src"><a class="def" id="v:ThreadKilled">ThreadKilled</a></td>
<td class="doc"><p>This exception is raised by another thread calling <code><a href="control-concurrent#v:killThread">killThread</a></code>, or by the system if it needs to terminate the thread for some reason.</p></td>
</tr>
<tr>
<td class="src"><a class="def" id="v:UserInterrupt">UserInterrupt</a></td>
<td class="doc"><p>This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism(s) (e.g. Control-C in the console).</p></td>
</tr>
</table>
</div>
<div class="subs instances">
<h4 id="control.i:AsyncException" class="caption collapser" onclick="toggleSection('i:AsyncException')">Instances</h4>
<div id="section.i:AsyncException" class="show"><table>
<tr>
<td class="src clearfix">
<a href="data-eq#t:Eq">Eq</a> <a href="control-exception#t:AsyncException">AsyncException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="data-ord#t:Ord">Ord</a> <a href="control-exception#t:AsyncException">AsyncException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:AsyncException">AsyncException</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:AsyncException">AsyncException</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src"><a class="def" id="v:asyncExceptionToException">asyncExceptionToException</a> :: <a href="control-exception#t:Exception">Exception</a> e =&gt; e -&gt; <a href="control-exception#t:SomeException">SomeException</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO-Exception.html#asyncExceptionToException" class="link">Source</a></p>
<p><span class="version">Since: 4.7.0.0</span></p>
<p class="src"><a class="def" id="v:asyncExceptionFromException">asyncExceptionFromException</a> :: <a href="control-exception#t:Exception">Exception</a> e =&gt; <a href="control-exception#t:SomeException">SomeException</a> -&gt; <a href="data-maybe#t:Maybe">Maybe</a> e <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO-Exception.html#asyncExceptionFromException" class="link">Source</a></p>
<p><span class="version">Since: 4.7.0.0</span></p>
<p class="src">data <a class="def" id="t:NonTermination">NonTermination</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#NonTermination" class="link">Source</a></p>
<p>Thrown when the runtime system detects that the computation is guaranteed not to terminate. Note that there is no guarantee that the runtime system will notice whether any given computation is guaranteed to terminate or not.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src"><a class="def" id="v:NonTermination">NonTermination</a></td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:NonTermination" class="caption collapser" onclick="toggleSection('i:NonTermination')">Instances</h4>
<div id="section.i:NonTermination" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:NonTermination">NonTermination</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:NonTermination">NonTermination</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:NestedAtomically">NestedAtomically</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#NestedAtomically" class="link">Source</a></p>
<p>Thrown when the program attempts to call <code>atomically</code>, from the <code>stm</code> package, inside another call to <code>atomically</code>.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src"><a class="def" id="v:NestedAtomically">NestedAtomically</a></td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:NestedAtomically" class="caption collapser" onclick="toggleSection('i:NestedAtomically')">Instances</h4>
<div id="section.i:NestedAtomically" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:NestedAtomically">NestedAtomically</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:NestedAtomically">NestedAtomically</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:BlockedIndefinitelyOnMVar">BlockedIndefinitelyOnMVar</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO-Exception.html#BlockedIndefinitelyOnMVar" class="link">Source</a></p>
<p>The thread is blocked on an <code>MVar</code>, but there are no other references to the <code>MVar</code> so it can't ever continue.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src"><a class="def" id="v:BlockedIndefinitelyOnMVar">BlockedIndefinitelyOnMVar</a></td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:BlockedIndefinitelyOnMVar" class="caption collapser" onclick="toggleSection('i:BlockedIndefinitelyOnMVar')">Instances</h4>
<div id="section.i:BlockedIndefinitelyOnMVar" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:BlockedIndefinitelyOnMVar">BlockedIndefinitelyOnMVar</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:BlockedIndefinitelyOnMVar">BlockedIndefinitelyOnMVar</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:BlockedIndefinitelyOnSTM">BlockedIndefinitelyOnSTM</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO-Exception.html#BlockedIndefinitelyOnSTM" class="link">Source</a></p>
<p>The thread is waiting to retry an STM transaction, but there are no other references to any <code>TVar</code>s involved, so it can't ever continue.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src"><a class="def" id="v:BlockedIndefinitelyOnSTM">BlockedIndefinitelyOnSTM</a></td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:BlockedIndefinitelyOnSTM" class="caption collapser" onclick="toggleSection('i:BlockedIndefinitelyOnSTM')">Instances</h4>
<div id="section.i:BlockedIndefinitelyOnSTM" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:BlockedIndefinitelyOnSTM">BlockedIndefinitelyOnSTM</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:BlockedIndefinitelyOnSTM">BlockedIndefinitelyOnSTM</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:AllocationLimitExceeded">AllocationLimitExceeded</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO-Exception.html#AllocationLimitExceeded" class="link">Source</a></p>
<p>This thread has exceeded its allocation limit. See <code><a href="ghc-conc#v:setAllocationCounter">setAllocationCounter</a></code> and <code><a href="ghc-conc#v:enableAllocationLimit">enableAllocationLimit</a></code>.</p>
<p><span class="version">Since: 4.8.0.0</span></p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src"><a class="def" id="v:AllocationLimitExceeded">AllocationLimitExceeded</a></td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:AllocationLimitExceeded" class="caption collapser" onclick="toggleSection('i:AllocationLimitExceeded')">Instances</h4>
<div id="section.i:AllocationLimitExceeded" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:AllocationLimitExceeded">AllocationLimitExceeded</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:AllocationLimitExceeded">AllocationLimitExceeded</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:Deadlock">Deadlock</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO-Exception.html#Deadlock" class="link">Source</a></p>
<p>There are no runnable threads, so the program is deadlocked. The <code>Deadlock</code> exception is raised in the main thread only.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src"><a class="def" id="v:Deadlock">Deadlock</a></td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:Deadlock" class="caption collapser" onclick="toggleSection('i:Deadlock')">Instances</h4>
<div id="section.i:Deadlock" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:Deadlock">Deadlock</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:Deadlock">Deadlock</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:NoMethodError">NoMethodError</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#NoMethodError" class="link">Source</a></p>
<p>A class method without a definition (neither a default definition, nor a definition in the appropriate instance) was called. The <code>String</code> gives information about which method it was.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">
<a class="def" id="v:NoMethodError">NoMethodError</a> <a href="data-string#t:String">String</a>
</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:NoMethodError" class="caption collapser" onclick="toggleSection('i:NoMethodError')">Instances</h4>
<div id="section.i:NoMethodError" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:NoMethodError">NoMethodError</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:NoMethodError">NoMethodError</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:PatternMatchFail">PatternMatchFail</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#PatternMatchFail" class="link">Source</a></p>
<p>A pattern match failed. The <code>String</code> gives information about the source location of the pattern.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">
<a class="def" id="v:PatternMatchFail">PatternMatchFail</a> <a href="data-string#t:String">String</a>
</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:PatternMatchFail" class="caption collapser" onclick="toggleSection('i:PatternMatchFail')">Instances</h4>
<div id="section.i:PatternMatchFail" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:PatternMatchFail">PatternMatchFail</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:PatternMatchFail">PatternMatchFail</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:RecConError">RecConError</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#RecConError" class="link">Source</a></p>
<p>An uninitialised record field was used. The <code>String</code> gives information about the source location where the record was constructed.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">
<a class="def" id="v:RecConError">RecConError</a> <a href="data-string#t:String">String</a>
</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:RecConError" class="caption collapser" onclick="toggleSection('i:RecConError')">Instances</h4>
<div id="section.i:RecConError" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:RecConError">RecConError</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:RecConError">RecConError</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:RecSelError">RecSelError</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#RecSelError" class="link">Source</a></p>
<p>A record selector was applied to a constructor without the appropriate field. This can only happen with a datatype with multiple constructors, where some fields are in one constructor but not another. The <code>String</code> gives information about the source location of the record selector.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">
<a class="def" id="v:RecSelError">RecSelError</a> <a href="data-string#t:String">String</a>
</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:RecSelError" class="caption collapser" onclick="toggleSection('i:RecSelError')">Instances</h4>
<div id="section.i:RecSelError" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:RecSelError">RecSelError</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:RecSelError">RecSelError</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">data <a class="def" id="t:RecUpdError">RecUpdError</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#RecUpdError" class="link">Source</a></p>
<p>A record update was performed on a constructor without the appropriate field. This can only happen with a datatype with multiple constructors, where some fields are in one constructor but not another. The <code>String</code> gives information about the source location of the record update.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">
<a class="def" id="v:RecUpdError">RecUpdError</a> <a href="data-string#t:String">String</a>
</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:RecUpdError" class="caption collapser" onclick="toggleSection('i:RecUpdError')">Instances</h4>
<div id="section.i:RecUpdError" class="show"><table>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:RecUpdError">RecUpdError</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:RecUpdError">RecUpdError</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src">newtype <a class="def" id="t:ErrorCall">ErrorCall</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-Exception.html#ErrorCall" class="link">Source</a></p>
<p>This is thrown when the user calls <code><a href="prelude#v:error">error</a></code>. The <code>String</code> is the argument given to <code><a href="prelude#v:error">error</a></code>.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">
<a class="def" id="v:ErrorCall">ErrorCall</a> <a href="data-string#t:String">String</a>
</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:ErrorCall" class="caption collapser" onclick="toggleSection('i:ErrorCall')">Instances</h4>
<div id="section.i:ErrorCall" class="show"><table>
<tr>
<td class="src clearfix">
<a href="data-eq#t:Eq">Eq</a> <a href="control-exception#t:ErrorCall">ErrorCall</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="data-ord#t:Ord">Ord</a> <a href="control-exception#t:ErrorCall">ErrorCall</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:ErrorCall">ErrorCall</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="control-exception#t:Exception">Exception</a> <a href="control-exception#t:ErrorCall">ErrorCall</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<h2 id="g:2">Throwing exceptions</h2>
<p class="src"><a class="def" id="v:throw">throw</a> :: <a href="control-exception#t:Exception">Exception</a> e =&gt; e -&gt; a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-Exception.html#throw" class="link">Source</a></p>
<p>Throw an exception. Exceptions may be thrown from purely functional code, but may only be caught within the <code><a href="system-io#t:IO">IO</a></code> monad.</p>
<p class="src"><a class="def" id="v:throwIO">throwIO</a> :: <a href="control-exception#t:Exception">Exception</a> e =&gt; e -&gt; <a href="system-io#t:IO">IO</a> a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO.html#throwIO" class="link">Source</a></p>
<p>A variant of <code><a href="control-exception#v:throw">throw</a></code> that can only be used within the <code><a href="system-io#t:IO">IO</a></code> monad.</p>
<p>Although <code><a href="control-exception#v:throwIO">throwIO</a></code> has a type that is an instance of the type of <code><a href="control-exception#v:throw">throw</a></code>, the two functions are subtly different:</p>
<pre>throw e   `seq` x  ===&gt; throw e
throwIO e `seq` x  ===&gt; x</pre>
<p>The first example will cause the exception <code>e</code> to be raised, whereas the second one won't. In fact, <code><a href="control-exception#v:throwIO">throwIO</a></code> will only cause an exception to be raised when it is used within the <code><a href="system-io#t:IO">IO</a></code> monad. The <code><a href="control-exception#v:throwIO">throwIO</a></code> variant should be used in preference to <code><a href="control-exception#v:throw">throw</a></code> to raise an exception within the <code><a href="system-io#t:IO">IO</a></code> monad because it guarantees ordering with respect to other <code><a href="system-io#t:IO">IO</a></code> operations, whereas <code><a href="control-exception#v:throw">throw</a></code> does not.</p>
<p class="src"><a class="def" id="v:ioError">ioError</a> :: <a href="system-io-error#t:IOError">IOError</a> -&gt; <a href="system-io#t:IO">IO</a> a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO-Exception.html#ioError" class="link">Source</a></p>
<p>Raise an <code><a href="system-io-error#t:IOError">IOError</a></code> in the <code><a href="system-io#t:IO">IO</a></code> monad.</p>
<p class="src"><a class="def" id="v:throwTo">throwTo</a> :: <a href="control-exception#t:Exception">Exception</a> e =&gt; <a href="control-concurrent#t:ThreadId">ThreadId</a> -&gt; e -&gt; <a href="system-io#t:IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-Conc-Sync.html#throwTo" class="link">Source</a></p>
<p><code><a href="control-exception#v:throwTo">throwTo</a></code> raises an arbitrary exception in the target thread (GHC only).</p>
<p>Exception delivery synchronizes between the source and target thread: <code><a href="control-exception#v:throwTo">throwTo</a></code> does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</p>
<p>Whatever work the target thread was doing when the exception was raised is not lost: the computation is suspended until required by another thread.</p>
<p>If the target thread is currently making a foreign call, then the exception will not be raised (and hence <code><a href="control-exception#v:throwTo">throwTo</a></code> will not return) until the call has completed. This is the case regardless of whether the call is inside a <code><a href="control-exception#v:mask">mask</a></code> or not. However, in GHC a foreign call can be annotated as <code>interruptible</code>, in which case a <code><a href="control-exception#v:throwTo">throwTo</a></code> will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</p>
<p>Important note: the behaviour of <code><a href="control-exception#v:throwTo">throwTo</a></code> differs from that described in the paper "Asynchronous exceptions in Haskell" (<a href="http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm">http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>). In the paper, <code><a href="control-exception#v:throwTo">throwTo</a></code> is non-blocking; but the library implementation adopts a more synchronous design in which <code><a href="control-exception#v:throwTo">throwTo</a></code> does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, <code><a href="control-exception#v:throwTo">throwTo</a></code> is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, <code><a href="control-exception#v:throwTo">throwTo</a></code> is <em>always</em> interruptible, even if it does not actually block.</p>
<p>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a <em>safe point</em>, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a <code><a href="control-exception#v:throwTo">throwTo</a></code>.</p>
<p>If the target of <code><a href="control-exception#v:throwTo">throwTo</a></code> is the calling thread, then the behaviour is the same as <code><a href="control-exception#v:throwIO">throwIO</a></code>, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside <code><a href="system-io-unsafe#v:unsafePerformIO">unsafePerformIO</a></code> or <code><a href="system-io-unsafe#v:unsafeInterleaveIO">unsafeInterleaveIO</a></code>, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</p>
<p>Note that if <code><a href="control-exception#v:throwTo">throwTo</a></code> is called with the current thread as the target, the exception will be thrown even if the thread is currently inside <code><a href="control-exception#v:mask">mask</a></code> or <code><a href="control-exception#v:uninterruptibleMask">uninterruptibleMask</a></code>.</p>
<h2 id="g:3">Catching Exceptions</h2>
<p>There are several functions for catching and examining exceptions; all of them may only be used from within the <code><a href="system-io#t:IO">IO</a></code> monad.</p>
<p>Here's a rule of thumb for deciding which catch-style function to use:</p>
<ul>
<li>If you want to do some cleanup in the event that an exception is raised, use <code><a href="control-exception#v:finally">finally</a></code>, <code><a href="control-exception#v:bracket">bracket</a></code> or <code><a href="control-exception#v:onException">onException</a></code>.</li>
<li>To recover after an exception and do something else, the best choice is to use one of the <code><a href="control-exception#v:try">try</a></code> family.</li>
<li>... unless you are recovering from an asynchronous exception, in which case use <code><a href="control-exception#v:catch">catch</a></code> or <code><a href="control-exception#v:catchJust">catchJust</a></code>.</li>
</ul>
<p>The difference between using <code><a href="control-exception#v:try">try</a></code> and <code><a href="control-exception#v:catch">catch</a></code> for recovery is that in <code><a href="control-exception#v:catch">catch</a></code> the handler is inside an implicit <code><a href="control-exception#v:mask">mask</a></code> (see "Asynchronous Exceptions") which is important when catching asynchronous exceptions, but when catching other kinds of exception it is unnecessary. Furthermore it is possible to accidentally stay inside the implicit <code><a href="control-exception#v:mask">mask</a></code> by tail-calling rather than returning from the handler, which is why we recommend using <code><a href="control-exception#v:try">try</a></code> rather than <code><a href="control-exception#v:catch">catch</a></code> for ordinary exception recovery.</p>
<p>A typical use of <code><a href="control-exception#v:tryJust">tryJust</a></code> for recovery looks like this:</p>
<pre> do r &lt;- tryJust (guard . isDoesNotExistError) $ getEnv "HOME"
    case r of
      Left  e    -&gt; ...
      Right home -&gt; ...</pre>
<h3 id="g:4">Catching all exceptions</h3>
<p>It is possible to catch all exceptions, by using the type <code><a href="control-exception#t:SomeException">SomeException</a></code>:</p>
<pre>catch f (\e -&gt; ... (e :: SomeException) ...)</pre>
<p>HOWEVER, this is normally not what you want to do!</p>
<p>For example, suppose you want to read a file, but if it doesn't exist then continue as if it contained "". You might be tempted to just catch all exceptions and return "" in the handler. However, this has all sorts of undesirable consequences. For example, if the user presses control-C at just the right moment then the <code><a href="control-exception#v:UserInterrupt">UserInterrupt</a></code> exception will be caught, and the program will continue running under the belief that the file contains "". Similarly, if another thread tries to kill the thread reading the file then the <code><a href="control-exception#v:ThreadKilled">ThreadKilled</a></code> exception will be ignored.</p>
<p>Instead, you should only catch exactly the exceptions that you really want. In this case, this would likely be more specific than even "any IO exception"; a permissions error would likely also want to be handled differently. Instead, you would probably want something like:</p>
<pre>e &lt;- tryJust (guard . isDoesNotExistError) (readFile f)
let str = either (const "") id e</pre>
<p>There are occassions when you really do need to catch any sort of exception. However, in most cases this is just so you can do some cleaning up; you aren't actually interested in the exception itself. For example, if you open a file then you want to close it again, whether processing the file executes normally or throws an exception. However, in these cases you can use functions like <code><a href="control-exception#v:bracket">bracket</a></code>, <code><a href="control-exception#v:finally">finally</a></code> and <code><a href="control-exception#v:onException">onException</a></code>, which never actually pass you the exception, but just call the cleanup functions at the appropriate points.</p>
<p>But sometimes you really do need to catch any exception, and actually see what the exception is. One example is at the very top-level of a program, you may wish to catch any exception, print it to a logfile or the screen, and then exit gracefully. For these cases, you can use <code><a href="control-exception#v:catch">catch</a></code> (or one of the other exception-catching functions) with the <code><a href="control-exception#t:SomeException">SomeException</a></code> type.</p>
<h3 id="g:5">The <code>catch</code> functions</h3>
<p class="src"><a class="def" id="v:catch">catch</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#catch" class="link">Source</a></p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: <a href="control-exception#t:Exception">Exception</a> e</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src">=&gt; <a href="system-io#t:IO">IO</a> a</td>
<td class="doc"><p>The computation to run</p></td>
</tr>
<tr>
<td class="src">-&gt; (e -&gt; <a href="system-io#t:IO">IO</a> a)</td>
<td class="doc"><p>Handler to invoke if an exception is raised</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="system-io#t:IO">IO</a> a</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p>This is the simplest of the exception-catching functions. It takes a single argument, runs it, and if an exception is raised the "handler" is executed, with the value of the exception passed as an argument. Otherwise, the result is returned as normal. For example:</p>
<pre>  catch (readFile f)
        (\e -&gt; do let err = show (e :: IOException)
                  hPutStr stderr ("Warning: Couldn't open " ++ f ++ ": " ++ err)
                  return "")</pre>
<p>Note that we have to give a type signature to <code>e</code>, or the program will not typecheck as the type is ambiguous. While it is possible to catch exceptions of any type, see the section "Catching all exceptions" (in <a href="control-exception">Control.Exception</a>) for an explanation of the problems with doing so.</p>
<p>For catching exceptions in pure (non-<code><a href="system-io#t:IO">IO</a></code>) expressions, see the function <code><a href="control-exception#v:evaluate">evaluate</a></code>.</p>
<p>Note that due to Haskell's unspecified evaluation order, an expression may throw one of several possible exceptions: consider the expression <code>(error "urk") + (1 `div` 0)</code>. Does the expression throw <code>ErrorCall "urk"</code>, or <code>DivideByZero</code>?</p>
<p>The answer is "it might throw either"; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling <code>catch</code> with type <code>IO Int -&gt; (ArithException -&gt; IO Int) -&gt; IO Int</code> then the handler may get run with <code>DivideByZero</code> as an argument, or an <code>ErrorCall "urk"</code> exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because <code><a href="control-exception#v:catch">catch</a></code> is an <code><a href="system-io#t:IO">IO</a></code> computation.</p>
<p class="src"><a class="def" id="v:catches">catches</a> :: <a href="system-io#t:IO">IO</a> a -&gt; [<a href="control-exception#t:Handler">Handler</a> a] -&gt; <a href="system-io#t:IO">IO</a> a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception.html#catches" class="link">Source</a></p>
<p>Sometimes you want to catch two different sorts of exception. You could do something like</p>
<pre>f = expr `catch` \ (ex :: ArithException) -&gt; handleArith ex
         `catch` \ (ex :: IOException)    -&gt; handleIO    ex</pre>
<p>However, there are a couple of problems with this approach. The first is that having two exception handlers is inefficient. However, the more serious issue is that the second exception handler will catch exceptions in the first, e.g. in the example above, if <code>handleArith</code> throws an <code>IOException</code> then the second exception handler will catch it.</p>
<p>Instead, we provide a function <code><a href="control-exception#v:catches">catches</a></code>, which would be used thus:</p>
<pre>f = expr `catches` [Handler (\ (ex :: ArithException) -&gt; handleArith ex),
                    Handler (\ (ex :: IOException)    -&gt; handleIO    ex)]</pre>
<p class="src">data <a class="def" id="t:Handler">Handler</a> a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception.html#Handler" class="link">Source</a></p>
<p>You need this when using <code><a href="control-exception#v:catches">catches</a></code>.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table><tr>
<td class="src">forall e . <a href="control-exception#t:Exception">Exception</a> e =&gt; <a class="def" id="v:Handler">Handler</a> (e -&gt; <a href="system-io#t:IO">IO</a> a)</td>
<td class="doc empty"> </td>
</tr></table>
</div>
<div class="subs instances">
<h4 id="control.i:Handler" class="caption collapser" onclick="toggleSection('i:Handler')">Instances</h4>
<div id="section.i:Handler" class="show"><table><tr>
<td class="src clearfix">
<a href="data-functor#t:Functor">Functor</a> <a href="control-exception#t:Handler">Handler</a>
</td>
<td class="doc empty"> </td>
</tr></table></div>
</div>
<p class="src"><a class="def" id="v:catchJust">catchJust</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#catchJust" class="link">Source</a></p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: <a href="control-exception#t:Exception">Exception</a> e</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src">=&gt; (e -&gt; <a href="data-maybe#t:Maybe">Maybe</a> b)</td>
<td class="doc"><p>Predicate to select exceptions</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="system-io#t:IO">IO</a> a</td>
<td class="doc"><p>Computation to run</p></td>
</tr>
<tr>
<td class="src">-&gt; (b -&gt; <a href="system-io#t:IO">IO</a> a)</td>
<td class="doc"><p>Handler</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="system-io#t:IO">IO</a> a</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p>The function <code><a href="control-exception#v:catchJust">catchJust</a></code> is like <code><a href="control-exception#v:catch">catch</a></code>, but it takes an extra argument which is an <em>exception predicate</em>, a function which selects which type of exceptions we're interested in.</p>
<pre>catchJust (\e -&gt; if isDoesNotExistErrorType (ioeGetErrorType e) then Just () else Nothing)
          (readFile f)
          (\_ -&gt; do hPutStrLn stderr ("No such file: " ++ show f)
                    return "")</pre>
<p>Any other exceptions which are not matched by the predicate are re-raised, and may be caught by an enclosing <code><a href="control-exception#v:catch">catch</a></code>, <code><a href="control-exception#v:catchJust">catchJust</a></code>, etc.</p>
<h3 id="g:6">The <code>handle</code> functions</h3>
<p class="src"><a class="def" id="v:handle">handle</a> :: <a href="control-exception#t:Exception">Exception</a> e =&gt; (e -&gt; <a href="system-io#t:IO">IO</a> a) -&gt; <a href="system-io#t:IO">IO</a> a -&gt; <a href="system-io#t:IO">IO</a> a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#handle" class="link">Source</a></p>
<p>A version of <code><a href="control-exception#v:catch">catch</a></code> with the arguments swapped around; useful in situations where the code for the handler is shorter. For example:</p>
<pre>  do handle (\NonTermination -&gt; exitWith (ExitFailure 1)) $
     ...</pre>
<p class="src"><a class="def" id="v:handleJust">handleJust</a> :: <a href="control-exception#t:Exception">Exception</a> e =&gt; (e -&gt; <a href="data-maybe#t:Maybe">Maybe</a> b) -&gt; (b -&gt; <a href="system-io#t:IO">IO</a> a) -&gt; <a href="system-io#t:IO">IO</a> a -&gt; <a href="system-io#t:IO">IO</a> a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#handleJust" class="link">Source</a></p>
<p>A version of <code><a href="control-exception#v:catchJust">catchJust</a></code> with the arguments swapped around (see <code><a href="control-exception#v:handle">handle</a></code>).</p>
<h3 id="g:7">The <code>try</code> functions</h3>
<p class="src"><a class="def" id="v:try">try</a> :: <a href="control-exception#t:Exception">Exception</a> e =&gt; <a href="system-io#t:IO">IO</a> a -&gt; <a href="system-io#t:IO">IO</a> (<a href="data-either#t:Either">Either</a> e a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#try" class="link">Source</a></p>
<p>Similar to <code><a href="control-exception#v:catch">catch</a></code>, but returns an <code><a href="data-either#t:Either">Either</a></code> result which is <code>(<a href="data-either#v:Right">Right</a> a)</code> if no exception of type <code>e</code> was raised, or <code>(<a href="data-either#v:Left">Left</a> ex)</code> if an exception of type <code>e</code> was raised and its value is <code>ex</code>. If any other type of exception is raised than it will be propogated up to the next enclosing exception handler.</p>
<pre> try a = catch (Right `liftM` a) (return . Left)</pre>
<p class="src"><a class="def" id="v:tryJust">tryJust</a> :: <a href="control-exception#t:Exception">Exception</a> e =&gt; (e -&gt; <a href="data-maybe#t:Maybe">Maybe</a> b) -&gt; <a href="system-io#t:IO">IO</a> a -&gt; <a href="system-io#t:IO">IO</a> (<a href="data-either#t:Either">Either</a> b a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#tryJust" class="link">Source</a></p>
<p>A variant of <code><a href="control-exception#v:try">try</a></code> that takes an exception predicate to select which exceptions are caught (c.f. <code><a href="control-exception#v:catchJust">catchJust</a></code>). If the exception does not match the predicate, it is re-thrown.</p>
<h3 id="g:8">The <code>evaluate</code> function</h3>
<p class="src"><a class="def" id="v:evaluate">evaluate</a> :: a -&gt; <a href="system-io#t:IO">IO</a> a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO.html#evaluate" class="link">Source</a></p>
<p>Forces its argument to be evaluated to weak head normal form when the resultant <code><a href="system-io#t:IO">IO</a></code> action is executed. It can be used to order evaluation with respect to other <code><a href="system-io#t:IO">IO</a></code> operations; its semantics are given by</p>
<pre>  evaluate x `seq` y    ==&gt;  y
  evaluate x `catch` f  ==&gt;  (return $! x) `catch` f
  evaluate x &gt;&gt;= f      ==&gt;  (return $! x) &gt;&gt;= f</pre>
<p><em>Note:</em> the first equation implies that <code>(evaluate x)</code> is <em>not</em> the same as <code>(return $! x)</code>. A correct definition is</p>
<pre>  evaluate x = (return $! x) &gt;&gt;= return</pre>
<h3 id="g:9">The <code>mapException</code> function</h3>
<p class="src"><a class="def" id="v:mapException">mapException</a> :: (<a href="control-exception#t:Exception">Exception</a> e1, <a href="control-exception#t:Exception">Exception</a> e2) =&gt; (e1 -&gt; e2) -&gt; a -&gt; a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#mapException" class="link">Source</a></p>
<p>This function maps one exception into another as proposed in the paper "A semantics for imprecise exceptions".</p>
<h2 id="g:10">Asynchronous Exceptions</h2>
<p> Asynchronous exceptions are so-called because they arise due to external influences, and can be raised at any point during execution. <code><a href="control-exception#v:StackOverflow">StackOverflow</a></code> and <code><a href="control-exception#v:HeapOverflow">HeapOverflow</a></code> are two examples of system-generated asynchronous exceptions.</p>
<p>The primary source of asynchronous exceptions, however, is <code><a href="control-exception#v:throwTo">throwTo</a></code>:</p>
<pre> throwTo :: ThreadId -&gt; Exception -&gt; IO ()</pre>
<p><code><a href="control-exception#v:throwTo">throwTo</a></code> (also <code><a href="control-concurrent#v:killThread">killThread</a></code>) allows one running thread to raise an arbitrary exception in another thread. The exception is therefore asynchronous with respect to the target thread, which could be doing anything at the time it receives the exception. Great care should be taken with asynchronous exceptions; it is all too easy to introduce race conditions by the over zealous use of <code><a href="control-exception#v:throwTo">throwTo</a></code>.</p>
<h3 id="g:11">Asynchronous exception control</h3>
<p>The following functions allow a thread to control delivery of asynchronous exceptions during a critical region.</p>
<p class="src"><a class="def" id="v:mask">mask</a> :: ((forall a. <a href="system-io#t:IO">IO</a> a -&gt; <a href="system-io#t:IO">IO</a> a) -&gt; <a href="system-io#t:IO">IO</a> b) -&gt; <a href="system-io#t:IO">IO</a> b <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO.html#mask" class="link">Source</a></p>
<p>Executes an IO computation with asynchronous exceptions <em>masked</em>. That is, any thread which attempts to raise an exception in the current thread with <code><a href="control-exception#v:throwTo">throwTo</a></code> will be blocked until asynchronous exceptions are unmasked again.</p>
<p>The argument passed to <code><a href="control-exception#v:mask">mask</a></code> is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use <code><a href="control-exception#v:mask">mask</a></code> is to protect the acquisition of a resource:</p>
<pre>mask $ \restore -&gt; do
    x &lt;- acquire
    restore (do_something_with x) `onException` release
    release</pre>
<p>This code guarantees that <code>acquire</code> is paired with <code>release</code>, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use <code><a href="control-exception#v:bracket">bracket</a></code> which abstracts the general pattern).</p>
<p>Note that the <code>restore</code> action passed to the argument to <code><a href="control-exception#v:mask">mask</a></code> does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, <code><a href="control-exception#v:mask">mask</a></code> cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see <code><a href="control-concurrent#v:forkIOWithUnmask">forkIOWithUnmask</a></code>.</p>
<p>Asynchronous exceptions may still be received while in the masked state if the masked thread <em>blocks</em> in certain ways; see <a href="control-exception#interruptible">Control.Exception</a>.</p>
<p>Threads created by <code><a href="control-concurrent#v:forkIO">forkIO</a></code> inherit the <code><a href="control-exception#t:MaskingState">MaskingState</a></code> from the parent; that is, to start a thread in the <code><a href="control-exception#v:MaskedInterruptible">MaskedInterruptible</a></code> state, use <code>mask_ $ forkIO ...</code>. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a a new thread in an unmasked state use <code><a href="control-concurrent#v:forkIOUnmasked">forkIOUnmasked</a></code>.</p>
<p class="src"><a class="def" id="v:mask_">mask_</a> :: <a href="system-io#t:IO">IO</a> a -&gt; <a href="system-io#t:IO">IO</a> a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO.html#mask_" class="link">Source</a></p>
<p>Like <code><a href="control-exception#v:mask">mask</a></code>, but does not pass a <code>restore</code> action to the argument.</p>
<p class="src"><a class="def" id="v:uninterruptibleMask">uninterruptibleMask</a> :: ((forall a. <a href="system-io#t:IO">IO</a> a -&gt; <a href="system-io#t:IO">IO</a> a) -&gt; <a href="system-io#t:IO">IO</a> b) -&gt; <a href="system-io#t:IO">IO</a> b <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO.html#uninterruptibleMask" class="link">Source</a></p>
<p>Like <code><a href="control-exception#v:mask">mask</a></code>, but the masked computation is not interruptible (see <a href="control-exception#interruptible">Control.Exception</a>). THIS SHOULD BE USED WITH GREAT CARE, because if a thread executing in <code><a href="control-exception#v:uninterruptibleMask">uninterruptibleMask</a></code> blocks for any reason, then the thread (and possibly the program, if this is the main thread) will be unresponsive and unkillable. This function should only be necessary if you need to mask exceptions around an interruptible operation, and you can guarantee that the interruptible operation will only block for a short period of time.</p>
<p class="src"><a class="def" id="v:uninterruptibleMask_">uninterruptibleMask_</a> :: <a href="system-io#t:IO">IO</a> a -&gt; <a href="system-io#t:IO">IO</a> a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO.html#uninterruptibleMask_" class="link">Source</a></p>
<p>Like <code><a href="control-exception#v:uninterruptibleMask">uninterruptibleMask</a></code>, but does not pass a <code>restore</code> action to the argument.</p>
<p class="src">data <a class="def" id="t:MaskingState">MaskingState</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO.html#MaskingState" class="link">Source</a></p>
<p>Describes the behaviour of a thread when an asynchronous exception is received.</p>
<div class="subs constructors">
<h4 class="caption">Constructors</h4>
<table>
<tr>
<td class="src"><a class="def" id="v:Unmasked">Unmasked</a></td>
<td class="doc"><p>asynchronous exceptions are unmasked (the normal state)</p></td>
</tr>
<tr>
<td class="src"><a class="def" id="v:MaskedInterruptible">MaskedInterruptible</a></td>
<td class="doc"><p>the state during <code><a href="control-exception#v:mask">mask</a></code>: asynchronous exceptions are masked, but blocking operations may still be interrupted</p></td>
</tr>
<tr>
<td class="src"><a class="def" id="v:MaskedUninterruptible">MaskedUninterruptible</a></td>
<td class="doc"><p>the state during <code><a href="control-exception#v:uninterruptibleMask">uninterruptibleMask</a></code>: asynchronous exceptions are masked, and blocking operations may not be interrupted</p></td>
</tr>
</table>
</div>
<div class="subs instances">
<h4 id="control.i:MaskingState" class="caption collapser" onclick="toggleSection('i:MaskingState')">Instances</h4>
<div id="section.i:MaskingState" class="show"><table>
<tr>
<td class="src clearfix">
<a href="data-eq#t:Eq">Eq</a> <a href="control-exception#t:MaskingState">MaskingState</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="text-show#t:Show">Show</a> <a href="control-exception#t:MaskingState">MaskingState</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<p class="src"><a class="def" id="v:getMaskingState">getMaskingState</a> :: <a href="system-io#t:IO">IO</a> <a href="control-exception#t:MaskingState">MaskingState</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-IO.html#getMaskingState" class="link">Source</a></p>
<p>Returns the <code><a href="control-exception#t:MaskingState">MaskingState</a></code> for the current thread.</p>
<p class="src"><a class="def" id="v:allowInterrupt">allowInterrupt</a> :: <a href="system-io#t:IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception.html#allowInterrupt" class="link">Source</a></p>
<p>When invoked inside <code><a href="control-exception#v:mask">mask</a></code>, this function allows a masked asynchronous exception to be raised, if one exists. It is equivalent to performing an interruptible operation (see ), but does not involve any actual blocking.</p>
<p>When called outside <code><a href="control-exception#v:mask">mask</a></code>, or inside <code><a href="control-exception#v:uninterruptibleMask">uninterruptibleMask</a></code>, this function has no effect.</p>
<p><span class="version">Since: 4.4.0.0</span></p>
<h4 id="g:12">Applying <code>mask</code> to an exception handler</h4>
<p>There's an implied <code><a href="control-exception#v:mask">mask</a></code> around every exception handler in a call to one of the <code><a href="control-exception#v:catch">catch</a></code> family of functions. This is because that is what you want most of the time - it eliminates a common race condition in starting an exception handler, because there may be no exception handler on the stack to handle another exception if one arrives immediately. If asynchronous exceptions are masked on entering the handler, though, we have time to install a new exception handler before being interrupted. If this weren't the default, one would have to write something like</p>
<pre>     mask $ \restore -&gt;
          catch (restore (...))
                (\e -&gt; handler)</pre>
<p>If you need to unmask asynchronous exceptions again in the exception handler, <code>restore</code> can be used there too.</p>
<p>Note that <code><a href="control-exception#v:try">try</a></code> and friends <em>do not</em> have a similar default, because there is no exception handler in this case. Don't use <code><a href="control-exception#v:try">try</a></code> for recovering from an asynchronous exception.</p>
<h4 id="g:13">Interruptible operations</h4>
<p> Some operations are <em>interruptible</em>, which means that they can receive asynchronous exceptions even in the scope of a <code><a href="control-exception#v:mask">mask</a></code>. Any function which may itself block is defined as interruptible; this includes <code><a href="control-concurrent-mvar#v:takeMVar">takeMVar</a></code> (but not <code><a href="control-concurrent-mvar#v:tryTakeMVar">tryTakeMVar</a></code>), and most operations which perform some I/O with the outside world. The reason for having interruptible operations is so that we can write things like</p>
<pre>     mask $ \restore -&gt; do
        a &lt;- takeMVar m
        catch (restore (...))
              (\e -&gt; ...)</pre>
<p>if the <code><a href="control-concurrent-mvar#v:takeMVar">takeMVar</a></code> was not interruptible, then this particular combination could lead to deadlock, because the thread itself would be blocked in a state where it can't receive any asynchronous exceptions. With <code><a href="control-concurrent-mvar#v:takeMVar">takeMVar</a></code> interruptible, however, we can be safe in the knowledge that the thread can receive exceptions right up until the point when the <code><a href="control-concurrent-mvar#v:takeMVar">takeMVar</a></code> succeeds. Similar arguments apply for other interruptible operations like <code><a href="system-io#v:openFile">openFile</a></code>.</p>
<p>It is useful to think of <code><a href="control-exception#v:mask">mask</a></code> not as a way to completely prevent asynchronous exceptions, but as a way to switch from asynchronous mode to polling mode. The main difficulty with asynchronous exceptions is that they normally can occur anywhere, but within a <code><a href="control-exception#v:mask">mask</a></code> an asynchronous exception is only raised by operations that are interruptible (or call other interruptible operations). In many cases these operations may themselves raise exceptions, such as I/O errors, so the caller will usually be prepared to handle exceptions arising from the operation anyway. To perfom an explicit poll for asynchronous exceptions inside <code><a href="control-exception#v:mask">mask</a></code>, use <code><a href="control-exception#v:allowInterrupt">allowInterrupt</a></code>.</p>
<p>Sometimes it is too onerous to handle exceptions in the middle of a critical piece of stateful code. There are three ways to handle this kind of situation:</p>
<ul>
<li>Use STM. Since a transaction is always either completely executed or not at all, transactions are a good way to maintain invariants over state in the presence of asynchronous (and indeed synchronous) exceptions.</li>
<li>Use <code><a href="control-exception#v:mask">mask</a></code>, and avoid interruptible operations. In order to do this, we have to know which operations are interruptible. It is impossible to know for any given library function whether it might invoke an interruptible operation internally; so instead we give a list of guaranteed-not-to-be-interruptible operations below.</li>
<li>Use <code><a href="control-exception#v:uninterruptibleMask">uninterruptibleMask</a></code>. This is generally not recommended, unless you can guarantee that any interruptible operations invoked during the scope of <code><a href="control-exception#v:uninterruptibleMask">uninterruptibleMask</a></code> can only ever block for a short time. Otherwise, <code><a href="control-exception#v:uninterruptibleMask">uninterruptibleMask</a></code> is a good way to make your program deadlock and be unresponsive to user interrupts.</li>
</ul>
<p>The following operations are guaranteed not to be interruptible:</p>
<ul>
<li>operations on <code>IORef</code> from <a href="data-ioref">Data.IORef</a>
</li>
<li>STM transactions that do not use <code>retry</code>
</li>
<li>everything from the <code>Foreign</code> modules</li>
<li>everything from <code>Control.Exception</code> except for <code><a href="control-exception#v:throwTo">throwTo</a></code>
</li>
<li>
<code>tryTakeMVar</code>, <code>tryPutMVar</code>, <code>isEmptyMVar</code>
</li>
<li>
<code>takeMVar</code> if the <code>MVar</code> is definitely full, and conversely <code>putMVar</code> if the <code>MVar</code> is definitely empty</li>
<li>
<code>newEmptyMVar</code>, <code>newMVar</code>
</li>
<li>
<code>forkIO</code>, <code>forkIOUnmasked</code>, <code>myThreadId</code>
</li>
</ul>
<h2 id="g:14">Assertions</h2>
<p class="src"><a class="def" id="v:assert">assert</a> :: <a href="data-bool#t:Bool">Bool</a> -&gt; a -&gt; a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/GHC-Base.html#assert" class="link">Source</a></p>
<p>If the first argument evaluates to <code><a href="data-bool#v:True">True</a></code>, then the result is the second argument. Otherwise an <code>AssertionFailed</code> exception is raised, containing a <code><a href="data-string#t:String">String</a></code> with the source file and line number of the call to <code><a href="control-exception#v:assert">assert</a></code>.</p>
<p>Assertions can normally be turned on or off with a compiler flag (for GHC, assertions are normally on unless optimisation is turned on with <code>-O</code> or the <code>-fignore-asserts</code> option is given). When assertions are turned off, the first argument to <code><a href="control-exception#v:assert">assert</a></code> is ignored, and the second argument is returned as the result.</p>
<h2 id="g:15">Utilities</h2>
<p class="src"><a class="def" id="v:bracket">bracket</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#bracket" class="link">Source</a></p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: <a href="system-io#t:IO">IO</a> a</td>
<td class="doc"><p>computation to run first ("acquire resource")</p></td>
</tr>
<tr>
<td class="src">-&gt; (a -&gt; <a href="system-io#t:IO">IO</a> b)</td>
<td class="doc"><p>computation to run last ("release resource")</p></td>
</tr>
<tr>
<td class="src">-&gt; (a -&gt; <a href="system-io#t:IO">IO</a> c)</td>
<td class="doc"><p>computation to run in-between</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="system-io#t:IO">IO</a> c</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use <code><a href="control-exception#v:bracket">bracket</a></code>, because <code><a href="control-exception#v:bracket">bracket</a></code> will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then <code><a href="control-exception#v:bracket">bracket</a></code> will re-raise the exception (after performing the release).</p>
<p>A common example is opening a file:</p>
<pre>bracket
  (openFile "filename" ReadMode)
  (hClose)
  (\fileHandle -&gt; do { ... })</pre>
<p>The arguments to <code><a href="control-exception#v:bracket">bracket</a></code> are in this order so that we can partially apply it, e.g.:</p>
<pre>withFile name mode = bracket (openFile name mode) hClose</pre>
<p class="src"><a class="def" id="v:bracket_">bracket_</a> :: <a href="system-io#t:IO">IO</a> a -&gt; <a href="system-io#t:IO">IO</a> b -&gt; <a href="system-io#t:IO">IO</a> c -&gt; <a href="system-io#t:IO">IO</a> c <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#bracket_" class="link">Source</a></p>
<p>A variant of <code><a href="control-exception#v:bracket">bracket</a></code> where the return value from the first computation is not required.</p>
<p class="src"><a class="def" id="v:bracketOnError">bracketOnError</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#bracketOnError" class="link">Source</a></p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: <a href="system-io#t:IO">IO</a> a</td>
<td class="doc"><p>computation to run first ("acquire resource")</p></td>
</tr>
<tr>
<td class="src">-&gt; (a -&gt; <a href="system-io#t:IO">IO</a> b)</td>
<td class="doc"><p>computation to run last ("release resource")</p></td>
</tr>
<tr>
<td class="src">-&gt; (a -&gt; <a href="system-io#t:IO">IO</a> c)</td>
<td class="doc"><p>computation to run in-between</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="system-io#t:IO">IO</a> c</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p>Like <code><a href="control-exception#v:bracket">bracket</a></code>, but only performs the final action if there was an exception raised by the in-between computation.</p>
<p class="src"><a class="def" id="v:finally">finally</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#finally" class="link">Source</a></p>
<div class="subs arguments">
<h4 class="caption">Arguments</h4>
<table>
<tr>
<td class="src">:: <a href="system-io#t:IO">IO</a> a</td>
<td class="doc"><p>computation to run first</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="system-io#t:IO">IO</a> b</td>
<td class="doc"><p>computation to run afterward (even if an exception was raised)</p></td>
</tr>
<tr>
<td class="src">-&gt; <a href="system-io#t:IO">IO</a> a</td>
<td class="doc empty"> </td>
</tr>
</table>
</div>
<p>A specialised variant of <code><a href="control-exception#v:bracket">bracket</a></code> with just a computation to run afterward.</p>
<p class="src"><a class="def" id="v:onException">onException</a> :: <a href="system-io#t:IO">IO</a> a -&gt; <a href="system-io#t:IO">IO</a> b -&gt; <a href="system-io#t:IO">IO</a> a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/src/Control-Exception-Base.html#onException" class="link">Source</a></p>
<p>Like <code><a href="control-exception#v:finally">finally</a></code>, but only performs the final action if there was an exception raised by the computation.</p>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    © The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/Control-Exception.html" class="_attribution-link">https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/Control-Exception.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
