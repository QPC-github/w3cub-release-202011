
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Data.ByteString.Lazy - Haskell 7 - W3cubDocs</title>
  
  <meta name="description" content="A time and space-efficient implementation of lazy byte vectors using lists of packed Word8 arrays, suitable for high performance use, both in terms &hellip;">
  <meta name="keywords" content="data, bytestring, lazy, haskell, haskell~7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~7/libraries/bytestring-0.10.6.0/data-bytestring-lazy.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/haskell~7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~7/" class="_nav-link" title="" style="margin-left:0;">Haskell 7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 class="caption">Data.ByteString.Lazy</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th>Copyright</th>
<td>(c) Don Stewart 2006 (c) Duncan Coutts 2006-2011</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style</td>
</tr>
<tr>
<th>Maintainer</th>
<td>dons00@gmail.com, duncan@community.haskell.org</td>
</tr>
<tr>
<th>Stability</th>
<td>stable</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Trustworthy</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell98</td>
</tr>
</table>
<div id="table-of-contents">
<h4 class="caption">Contents</h4>
<ul>
<li><a href="#g:1">The <code>ByteString</code> type</a></li>
<li><a href="#g:2">Introducing and eliminating <code>ByteString</code>s</a></li>
<li><a href="#g:3">Basic interface</a></li>
<li><a href="#g:4">Transforming ByteStrings</a></li>
<li>
<a href="#g:5">Reducing <code>ByteString</code>s (folds)</a><ul><li><a href="#g:6">Special folds</a></li></ul>
</li>
<li>
<a href="#g:7">Building ByteStrings</a><ul>
<li><a href="#g:8">Scans</a></li>
<li><a href="#g:9">Accumulating maps</a></li>
<li><a href="#g:10">Infinite ByteStrings</a></li>
<li><a href="#g:11">Unfolding ByteStrings</a></li>
</ul>
</li>
<li>
<a href="#g:12">Substrings</a><ul>
<li><a href="#g:13">Breaking strings</a></li>
<li><a href="#g:14">Breaking into many substrings</a></li>
</ul>
</li>
<li>
<a href="#g:15">Predicates</a><ul><li><a href="#g:16">Search for arbitrary substrings</a></li></ul>
</li>
<li>
<a href="#g:17">Searching ByteStrings</a><ul>
<li><a href="#g:18">Searching by equality</a></li>
<li><a href="#g:19">Searching with a predicate</a></li>
</ul>
</li>
<li><a href="#g:20">Indexing ByteStrings</a></li>
<li><a href="#g:21">Zipping and unzipping ByteStrings</a></li>
<li><a href="#g:22">Ordered ByteStrings</a></li>
<li>
<a href="#g:23">Low level conversions</a><ul><li><a href="#g:24">Copying ByteStrings</a></li></ul>
</li>
<li>
<a href="#g:25">I/O with <code>ByteString</code>s</a><ul>
<li><a href="#g:26">Standard input and output</a></li>
<li><a href="#g:27">Files</a></li>
<li><a href="#g:28">I/O with Handles</a></li>
</ul>
</li>
</ul>
</div>
<div id="description">
<h4 class="caption">Description</h4>
<p>A time and space-efficient implementation of lazy byte vectors using lists of packed <code><a href="../base-4.8.2.0/data-word#t:Word8">Word8</a></code> arrays, suitable for high performance use, both in terms of large data quantities, or high speed requirements. Lazy ByteStrings are encoded as lazy lists of strict chunks of bytes.</p>
<p>A key feature of lazy ByteStrings is the means to manipulate large or unbounded streams of data without requiring the entire sequence to be resident in memory. To take advantage of this you have to write your functions in a lazy streaming style, e.g. classic pipeline composition. The default I/O chunk size is 32k, which should be good in most circumstances.</p>
<p>Some operations, such as <code><a href="data-bytestring-lazy#v:concat">concat</a></code>, <code><a href="data-bytestring-lazy#v:append">append</a></code>, <code><a href="data-bytestring-lazy#v:reverse">reverse</a></code> and <code><a href="data-bytestring-lazy#v:cons">cons</a></code>, have better complexity than their <a href="data-bytestring">Data.ByteString</a> equivalents, due to optimisations resulting from the list spine structure. For other operations lazy ByteStrings are usually within a few percent of strict ones.</p>
<p>The recomended way to assemble lazy ByteStrings from smaller parts is to use the builder monoid from <a href="data-bytestring-builder">Data.ByteString.Builder</a>.</p>
<p>This module is intended to be imported <code>qualified</code>, to avoid name clashes with <a href="../base-4.8.2.0/prelude">Prelude</a> functions. eg.</p>
<pre>import qualified Data.ByteString.Lazy as B</pre>
<p>Original GHC implementation by Bryan O'Sullivan. Rewritten to use <code><a href="data-array-unboxed#v:UArray">UArray</a></code> by Simon Marlow. Rewritten to support slices and use <code><a href="../base-4.8.2.0/foreign-foreignptr#v:ForeignPtr">ForeignPtr</a></code> by David Roundy. Rewritten again and extended by Don Stewart and Duncan Coutts. Lazy variant by Duncan Coutts and Don Stewart.</p>
</div>
<h2 id="g:1">The ByteString type</h2>
<p class="src">data <a class="def" id="t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy-Internal.html#ByteString" class="link">Source</a></p>
<p>A space-efficient representation of a <code><a href="../base-4.8.2.0/data-word#t:Word8">Word8</a></code> vector, supporting many efficient operations.</p>
<p>A lazy <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> contains 8-bit bytes, or by using the operations from <a href="data-bytestring-lazy-char8">Data.ByteString.Lazy.Char8</a> it can be interpreted as containing 8-bit characters.</p>
<div class="subs instances">
<h4 id="control.i:ByteString" class="caption collapser" onclick="toggleSection('i:ByteString')">Instances</h4>
<div id="section.i:ByteString" class="show"><table>
<tr>
<td class="src clearfix">
<a href="../base-4.8.2.0/data-eq#t:Eq">Eq</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="../base-4.8.2.0/data-data#t:Data">Data</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="../base-4.8.2.0/text-read#t:Read">Read</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="../base-4.8.2.0/text-show#t:Show">Show</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="../base-4.8.2.0/data-string#t:IsString">IsString</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="../base-4.8.2.0/data-monoid#t:Monoid">Monoid</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a>
</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="../deepseq-1.4.1.1/control-deepseq#t:NFData">NFData</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a>
</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<h2 id="g:2">Introducing and eliminating <a href="data-bytestring-lazy#t:ByteString">ByteString</a>s</h2>
<p class="src"><a class="def" id="v:empty">empty</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#empty" class="link">Source</a></p>
<p><span class="complexity">O(1)</span> The empty <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code></p>
<p class="src"><a class="def" id="v:singleton">singleton</a> :: <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#singleton" class="link">Source</a></p>
<p><span class="complexity">O(1)</span> Convert a <code><a href="../base-4.8.2.0/data-word#t:Word8">Word8</a></code> into a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code></p>
<p class="src"><a class="def" id="v:pack">pack</a> :: [<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>] -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#pack" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> Convert a '[Word8]' into a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code>.</p>
<p class="src"><a class="def" id="v:unpack">unpack</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; [<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#unpack" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> Converts a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> to a '[Word8]'.</p>
<p class="src"><a class="def" id="v:fromStrict">fromStrict</a> :: <a href="data-bytestring#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#fromStrict" class="link">Source</a></p>
<p><span class="complexity">O(1)</span> Convert a strict <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> into a lazy <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code>.</p>
<p class="src"><a class="def" id="v:toStrict">toStrict</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#toStrict" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> Convert a lazy <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> into a strict <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code>.</p>
<p>Note that this is an <em>expensive</em> operation that forces the whole lazy ByteString into memory and then copies all the data. If possible, try to avoid converting back and forth between strict and lazy bytestrings.</p>
<p class="src"><a class="def" id="v:fromChunks">fromChunks</a> :: [<a href="data-bytestring#t:ByteString">ByteString</a>] -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#fromChunks" class="link">Source</a></p>
<p><span class="complexity">O(c)</span> Convert a list of strict <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> into a lazy <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code></p>
<p class="src"><a class="def" id="v:toChunks">toChunks</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; [<a href="data-bytestring#t:ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#toChunks" class="link">Source</a></p>
<p><span class="complexity">O(c)</span> Convert a lazy <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> into a list of strict <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code></p>
<p class="src"><a class="def" id="v:foldrChunks">foldrChunks</a> :: (<a href="data-bytestring#t:ByteString">ByteString</a> -&gt; a -&gt; a) -&gt; a -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy-Internal.html#foldrChunks" class="link">Source</a></p>
<p>Consume the chunks of a lazy ByteString with a natural right fold.</p>
<p class="src"><a class="def" id="v:foldlChunks">foldlChunks</a> :: (a -&gt; <a href="data-bytestring#t:ByteString">ByteString</a> -&gt; a) -&gt; a -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy-Internal.html#foldlChunks" class="link">Source</a></p>
<p>Consume the chunks of a lazy ByteString with a strict, tail-recursive, accumulating left fold.</p>
<h2 id="g:3">Basic interface</h2>
<p class="src"><a class="def" id="v:cons">cons</a> :: <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <span class="fixity">infixr 5</span> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#cons" class="link">Source</a></p>
<p><span class="complexity">O(1)</span> <code><a href="data-bytestring-lazy#v:cons">cons</a></code> is analogous to '(:)' for lists.</p>
<p class="src"><a class="def" id="v:cons-39-">cons'</a> :: <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <span class="fixity">infixr 5</span> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#cons%27" class="link">Source</a></p>
<p><span class="complexity">O(1)</span> Unlike <code><a href="data-bytestring-lazy#v:cons">cons</a></code>, 'cons\'' is strict in the ByteString that we are consing onto. More precisely, it forces the head and the first chunk. It does this because, for space efficiency, it may coalesce the new byte onto the first 'chunk' rather than starting a new 'chunk'.</p>
<p>So that means you can't use a lazy recursive contruction like this:</p>
<pre>let xs = cons\' c xs in xs</pre>
<p>You can however use <code><a href="data-bytestring-lazy#v:cons">cons</a></code>, as well as <code><a href="data-bytestring-lazy#v:repeat">repeat</a></code> and <code><a href="data-bytestring-lazy#v:cycle">cycle</a></code>, to build infinite lazy ByteStrings.</p>
<p class="src"><a class="def" id="v:snoc">snoc</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <span class="fixity">infixl 5</span> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#snoc" class="link">Source</a></p>
<p><span class="complexity">O(n/c)</span> Append a byte to the end of a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code></p>
<p class="src"><a class="def" id="v:append">append</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#append" class="link">Source</a></p>
<p><span class="complexity">O(n/c)</span> Append two ByteStrings</p>
<p class="src"><a class="def" id="v:head">head</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#head" class="link">Source</a></p>
<p><span class="complexity">O(1)</span> Extract the first element of a ByteString, which must be non-empty.</p>
<p class="src"><a class="def" id="v:uncons">uncons</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>, <a href="data-bytestring-lazy#t:ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#uncons" class="link">Source</a></p>
<p><span class="complexity">O(1)</span> Extract the head and tail of a ByteString, returning Nothing if it is empty.</p>
<p class="src"><a class="def" id="v:unsnoc">unsnoc</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> (<a href="data-bytestring-lazy#t:ByteString">ByteString</a>, <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#unsnoc" class="link">Source</a></p>
<p><span class="complexity">O(n/c)</span> Extract the <code><a href="data-bytestring-lazy#v:init">init</a></code> and <code><a href="data-bytestring-lazy#v:last">last</a></code> of a ByteString, returning Nothing if it is empty.</p>
<ul><li>It is no faster than using <code><a href="data-bytestring-lazy#v:init">init</a></code> and <code><a href="data-bytestring-lazy#v:last">last</a></code>
</li></ul>
<p class="src"><a class="def" id="v:last">last</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#last" class="link">Source</a></p>
<p><span class="complexity">O(n/c)</span> Extract the last element of a ByteString, which must be finite and non-empty.</p>
<p class="src"><a class="def" id="v:tail">tail</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#tail" class="link">Source</a></p>
<p><span class="complexity">O(1)</span> Extract the elements after the head of a ByteString, which must be non-empty.</p>
<p class="src"><a class="def" id="v:init">init</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#init" class="link">Source</a></p>
<p><span class="complexity">O(n/c)</span> Return all the elements of a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> except the last one.</p>
<p class="src"><a class="def" id="v:null">null</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#null" class="link">Source</a></p>
<p><span class="complexity">O(1)</span> Test whether a ByteString is empty.</p>
<p class="src"><a class="def" id="v:length">length</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-int#t:Int64">Int64</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#length" class="link">Source</a></p>
<p><span class="complexity">O(n/c)</span> <code><a href="data-bytestring-lazy#v:length">length</a></code> returns the length of a ByteString as an <code><a href="../base-4.8.2.0/data-int#t:Int64">Int64</a></code></p>
<h2 id="g:4">Transforming ByteStrings</h2>
<p class="src"><a class="def" id="v:map">map</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#map" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy#v:map">map</a></code> <code>f xs</code> is the ByteString obtained by applying <code>f</code> to each element of <code>xs</code>.</p>
<p class="src"><a class="def" id="v:reverse">reverse</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#reverse" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy#v:reverse">reverse</a></code> <code>xs</code> returns the elements of <code>xs</code> in reverse order.</p>
<p class="src"><a class="def" id="v:intersperse">intersperse</a> :: <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#intersperse" class="link">Source</a></p>
<p>The <code><a href="data-bytestring-lazy#v:intersperse">intersperse</a></code> function takes a <code><a href="../base-4.8.2.0/data-word#t:Word8">Word8</a></code> and a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> and `intersperses' that byte between the elements of the <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code>. It is analogous to the intersperse function on Lists.</p>
<p class="src"><a class="def" id="v:intercalate">intercalate</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; [<a href="data-bytestring-lazy#t:ByteString">ByteString</a>] -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#intercalate" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy#v:intercalate">intercalate</a></code> function takes a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> and a list of <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code>s and concatenates the list after interspersing the first argument between each element of the list.</p>
<p class="src"><a class="def" id="v:transpose">transpose</a> :: [<a href="data-bytestring-lazy#t:ByteString">ByteString</a>] -&gt; [<a href="data-bytestring-lazy#t:ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#transpose" class="link">Source</a></p>
<p>The <code><a href="data-bytestring-lazy#v:transpose">transpose</a></code> function transposes the rows and columns of its <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> argument.</p>
<h2 id="g:5">Reducing <a href="data-bytestring-lazy#t:ByteString">ByteString</a>s (folds)</h2>
<p class="src"><a class="def" id="v:foldl">foldl</a> :: (a -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; a) -&gt; a -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#foldl" class="link">Source</a></p>
<p><code><a href="data-bytestring-lazy#v:foldl">foldl</a></code>, applied to a binary operator, a starting value (typically the left-identity of the operator), and a ByteString, reduces the ByteString using the binary operator, from left to right.</p>
<p class="src"><a class="def" id="v:foldl-39-">foldl'</a> :: (a -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; a) -&gt; a -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#foldl%27" class="link">Source</a></p>
<p>'foldl\'' is like <code><a href="data-bytestring-lazy#v:foldl">foldl</a></code>, but strict in the accumulator.</p>
<p class="src"><a class="def" id="v:foldl1">foldl1</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#foldl1" class="link">Source</a></p>
<p><code><a href="data-bytestring-lazy#v:foldl1">foldl1</a></code> is a variant of <code><a href="data-bytestring-lazy#v:foldl">foldl</a></code> that has no starting value argument, and thus must be applied to non-empty <code>ByteStrings</code>.</p>
<p class="src"><a class="def" id="v:foldl1-39-">foldl1'</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#foldl1%27" class="link">Source</a></p>
<p>'foldl1\'' is like <code><a href="data-bytestring-lazy#v:foldl1">foldl1</a></code>, but strict in the accumulator.</p>
<p class="src"><a class="def" id="v:foldr">foldr</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; a -&gt; a) -&gt; a -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#foldr" class="link">Source</a></p>
<p><code><a href="data-bytestring-lazy#v:foldr">foldr</a></code>, applied to a binary operator, a starting value (typically the right-identity of the operator), and a ByteString, reduces the ByteString using the binary operator, from right to left.</p>
<p class="src"><a class="def" id="v:foldr1">foldr1</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#foldr1" class="link">Source</a></p>
<p><code><a href="data-bytestring-lazy#v:foldr1">foldr1</a></code> is a variant of <code><a href="data-bytestring-lazy#v:foldr">foldr</a></code> that has no starting value argument, and thus must be applied to non-empty <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code>s</p>
<h3 id="g:6">Special folds</h3>
<p class="src"><a class="def" id="v:concat">concat</a> :: [<a href="data-bytestring-lazy#t:ByteString">ByteString</a>] -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#concat" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> Concatenate a list of ByteStrings.</p>
<p class="src"><a class="def" id="v:concatMap">concatMap</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#concatMap" class="link">Source</a></p>
<p>Map a function over a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> and concatenate the results</p>
<p class="src"><a class="def" id="v:any">any</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#any" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> Applied to a predicate and a ByteString, <code><a href="data-bytestring-lazy#v:any">any</a></code> determines if any element of the <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> satisfies the predicate.</p>
<p class="src"><a class="def" id="v:all">all</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#all" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> Applied to a predicate and a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code>, <code><a href="data-bytestring-lazy#v:all">all</a></code> determines if all elements of the <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> satisfy the predicate.</p>
<p class="src"><a class="def" id="v:maximum">maximum</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#maximum" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy#v:maximum">maximum</a></code> returns the maximum value from a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code></p>
<p class="src"><a class="def" id="v:minimum">minimum</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#minimum" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy#v:minimum">minimum</a></code> returns the minimum value from a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code></p>
<h2 id="g:7">Building ByteStrings</h2>
<h3 id="g:8">Scans</h3>
<p class="src"><a class="def" id="v:scanl">scanl</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>) -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#scanl" class="link">Source</a></p>
<p><code><a href="data-bytestring-lazy#v:scanl">scanl</a></code> is similar to <code><a href="data-bytestring-lazy#v:foldl">foldl</a></code>, but returns a list of successive reduced values from the left. This function will fuse.</p>
<pre>scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]</pre>
<p>Note that</p>
<pre>last (scanl f z xs) == foldl f z xs.</pre>
<h3 id="g:9">Accumulating maps</h3>
<p class="src"><a class="def" id="v:mapAccumL">mapAccumL</a> :: (acc -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; (acc, <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>)) -&gt; acc -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; (acc, <a href="data-bytestring-lazy#t:ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#mapAccumL" class="link">Source</a></p>
<p>The <code><a href="data-bytestring-lazy#v:mapAccumL">mapAccumL</a></code> function behaves like a combination of <code><a href="data-bytestring-lazy#v:map">map</a></code> and <code><a href="data-bytestring-lazy#v:foldl">foldl</a></code>; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new ByteString.</p>
<p class="src"><a class="def" id="v:mapAccumR">mapAccumR</a> :: (acc -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; (acc, <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>)) -&gt; acc -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; (acc, <a href="data-bytestring-lazy#t:ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#mapAccumR" class="link">Source</a></p>
<p>The <code><a href="data-bytestring-lazy#v:mapAccumR">mapAccumR</a></code> function behaves like a combination of <code><a href="data-bytestring-lazy#v:map">map</a></code> and <code><a href="data-bytestring-lazy#v:foldr">foldr</a></code>; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</p>
<h3 id="g:10">Infinite ByteStrings</h3>
<p class="src"><a class="def" id="v:repeat">repeat</a> :: <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#repeat" class="link">Source</a></p>
<p><code><a href="data-bytestring-lazy#v:repeat">repeat</a> x</code> is an infinite ByteString, with <code>x</code> the value of every element.</p>
<p class="src"><a class="def" id="v:replicate">replicate</a> :: <a href="../base-4.8.2.0/data-int#t:Int64">Int64</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#replicate" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy#v:replicate">replicate</a> n x</code> is a ByteString of length <code>n</code> with <code>x</code> the value of every element.</p>
<p class="src"><a class="def" id="v:cycle">cycle</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#cycle" class="link">Source</a></p>
<p><code><a href="data-bytestring-lazy#v:cycle">cycle</a></code> ties a finite ByteString into a circular one, or equivalently, the infinite repetition of the original ByteString.</p>
<p class="src"><a class="def" id="v:iterate">iterate</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>) -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#iterate" class="link">Source</a></p>
<p><code><a href="data-bytestring-lazy#v:iterate">iterate</a> f x</code> returns an infinite ByteString of repeated applications of <code>f</code> to <code>x</code>:</p>
<pre>iterate f x == [x, f x, f (f x), ...]</pre>
<h3 id="g:11">Unfolding ByteStrings</h3>
<p class="src"><a class="def" id="v:unfoldr">unfoldr</a> :: (a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>, a)) -&gt; a -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#unfoldr" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy#v:unfoldr">unfoldr</a></code> function is analogous to the List 'unfoldr'. <code><a href="data-bytestring-lazy#v:unfoldr">unfoldr</a></code> builds a ByteString from a seed value. The function takes the element and returns <code><a href="../base-4.8.2.0/data-maybe#v:Nothing">Nothing</a></code> if it is done producing the ByteString or returns <code><a href="../base-4.8.2.0/data-maybe#v:Just">Just</a></code> <code>(a,b)</code>, in which case, <code>a</code> is a prepending to the ByteString and <code>b</code> is used as the next element in a recursive call.</p>
<h2 id="g:12">Substrings</h2>
<h3 id="g:13">Breaking strings</h3>
<p class="src"><a class="def" id="v:take">take</a> :: <a href="../base-4.8.2.0/data-int#t:Int64">Int64</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#take" class="link">Source</a></p>
<p><span class="complexity">O(n/c)</span> <code><a href="data-bytestring-lazy#v:take">take</a></code> <code>n</code>, applied to a ByteString <code>xs</code>, returns the prefix of <code>xs</code> of length <code>n</code>, or <code>xs</code> itself if <code>n &gt; <a href="data-bytestring-lazy#v:length">length</a> xs</code>.</p>
<p class="src"><a class="def" id="v:drop">drop</a> :: <a href="../base-4.8.2.0/data-int#t:Int64">Int64</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#drop" class="link">Source</a></p>
<p><span class="complexity">O(n/c)</span> <code><a href="data-bytestring-lazy#v:drop">drop</a></code> <code>n xs</code> returns the suffix of <code>xs</code> after the first <code>n</code> elements, or <code>[]</code> if <code>n &gt; <a href="data-bytestring-lazy#v:length">length</a> xs</code>.</p>
<p class="src"><a class="def" id="v:splitAt">splitAt</a> :: <a href="../base-4.8.2.0/data-int#t:Int64">Int64</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; (<a href="data-bytestring-lazy#t:ByteString">ByteString</a>, <a href="data-bytestring-lazy#t:ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#splitAt" class="link">Source</a></p>
<p><span class="complexity">O(n/c)</span> <code><a href="data-bytestring-lazy#v:splitAt">splitAt</a></code> <code>n xs</code> is equivalent to <code>(<a href="data-bytestring-lazy#v:take">take</a> n xs, <a href="data-bytestring-lazy#v:drop">drop</a> n xs)</code>.</p>
<p class="src"><a class="def" id="v:takeWhile">takeWhile</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#takeWhile" class="link">Source</a></p>
<p><code><a href="data-bytestring-lazy#v:takeWhile">takeWhile</a></code>, applied to a predicate <code>p</code> and a ByteString <code>xs</code>, returns the longest prefix (possibly empty) of <code>xs</code> of elements that satisfy <code>p</code>.</p>
<p class="src"><a class="def" id="v:dropWhile">dropWhile</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#dropWhile" class="link">Source</a></p>
<p><code><a href="data-bytestring-lazy#v:dropWhile">dropWhile</a></code> <code>p xs</code> returns the suffix remaining after <code><a href="data-bytestring-lazy#v:takeWhile">takeWhile</a></code> <code>p xs</code>.</p>
<p class="src"><a class="def" id="v:span">span</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; (<a href="data-bytestring-lazy#t:ByteString">ByteString</a>, <a href="data-bytestring-lazy#t:ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#span" class="link">Source</a></p>
<p><code><a href="data-bytestring-lazy#v:span">span</a></code> <code>p xs</code> breaks the ByteString into two segments. It is equivalent to <code>(<a href="data-bytestring-lazy#v:takeWhile">takeWhile</a> p xs, <a href="data-bytestring-lazy#v:dropWhile">dropWhile</a> p xs)</code></p>
<p class="src"><a class="def" id="v:break">break</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; (<a href="data-bytestring-lazy#t:ByteString">ByteString</a>, <a href="data-bytestring-lazy#t:ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#break" class="link">Source</a></p>
<p><code><a href="data-bytestring-lazy#v:break">break</a></code> <code>p</code> is equivalent to <code><a href="data-bytestring-lazy#v:span">span</a> (<a href="../base-4.8.2.0/data-bool#v:not">not</a> . p)</code>.</p>
<p class="src"><a class="def" id="v:group">group</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; [<a href="data-bytestring-lazy#t:ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#group" class="link">Source</a></p>
<p>The <code><a href="data-bytestring-lazy#v:group">group</a></code> function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</p>
<pre>group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]</pre>
<p>It is a special case of <code><a href="data-bytestring-lazy#v:groupBy">groupBy</a></code>, which allows the programmer to supply their own equality test.</p>
<p class="src"><a class="def" id="v:groupBy">groupBy</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; [<a href="data-bytestring-lazy#t:ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#groupBy" class="link">Source</a></p>
<p>The <code><a href="data-bytestring-lazy#v:groupBy">groupBy</a></code> function is the non-overloaded version of <code><a href="data-bytestring-lazy#v:group">group</a></code>.</p>
<p class="src"><a class="def" id="v:inits">inits</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; [<a href="data-bytestring-lazy#t:ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#inits" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> Return all initial segments of the given <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code>, shortest first.</p>
<p class="src"><a class="def" id="v:tails">tails</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; [<a href="data-bytestring-lazy#t:ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#tails" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> Return all final segments of the given <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code>, longest first.</p>
<h3 id="g:14">Breaking into many substrings</h3>
<p class="src"><a class="def" id="v:split">split</a> :: <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; [<a href="data-bytestring-lazy#t:ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#split" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> Break a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> into pieces separated by the byte argument, consuming the delimiter. I.e.</p>
<pre>split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
split 'a'  "aXaXaXa"    == ["","X","X","X",""]
split 'x'  "x"          == ["",""]</pre>
<p>and</p>
<pre>intercalate [c] . split c == id
split == splitWith . (==)</pre>
<p>As for all splitting functions in this library, this function does not copy the substrings, it just constructs new <code>ByteStrings</code> that are slices of the original.</p>
<p class="src"><a class="def" id="v:splitWith">splitWith</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; [<a href="data-bytestring-lazy#t:ByteString">ByteString</a>] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#splitWith" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> Splits a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> into components delimited by separators, where the predicate returns True for a separator element. The resulting components do not contain the separators. Two adjacent separators result in an empty component in the output. eg.</p>
<pre>splitWith (=='a') "aabbaca" == ["","","bb","c",""]
splitWith (=='a') []        == []</pre>
<h2 id="g:15">Predicates</h2>
<p class="src"><a class="def" id="v:isPrefixOf">isPrefixOf</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#isPrefixOf" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy#v:isPrefixOf">isPrefixOf</a></code> function takes two ByteStrings and returns <code><a href="../base-4.8.2.0/data-bool#v:True">True</a></code> iff the first is a prefix of the second.</p>
<p class="src"><a class="def" id="v:isSuffixOf">isSuffixOf</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#isSuffixOf" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy#v:isSuffixOf">isSuffixOf</a></code> function takes two ByteStrings and returns <code><a href="../base-4.8.2.0/data-bool#v:True">True</a></code> iff the first is a suffix of the second.</p>
<p>The following holds:</p>
<pre>isSuffixOf x y == reverse x `isPrefixOf` reverse y</pre>
<h3 id="g:16">Search for arbitrary substrings</h3>
<h2 id="g:17">Searching ByteStrings</h2>
<h3 id="g:18">Searching by equality</h3>
<p class="src"><a class="def" id="v:elem">elem</a> :: <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#elem" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy#v:elem">elem</a></code> is the <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> membership predicate.</p>
<p class="src"><a class="def" id="v:notElem">notElem</a> :: <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#notElem" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy#v:notElem">notElem</a></code> is the inverse of <code><a href="data-bytestring-lazy#v:elem">elem</a></code></p>
<h3 id="g:19">Searching with a predicate</h3>
<p class="src"><a class="def" id="v:find">find</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#find" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy#v:find">find</a></code> function takes a predicate and a ByteString, and returns the first element in matching the predicate, or <code><a href="../base-4.8.2.0/data-maybe#v:Nothing">Nothing</a></code> if there is no such element.</p>
<pre>find f p = case findIndex f p of Just n -&gt; Just (p ! n) ; _ -&gt; Nothing</pre>
<p class="src"><a class="def" id="v:filter">filter</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#filter" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy#v:filter">filter</a></code>, applied to a predicate and a ByteString, returns a ByteString containing those characters that satisfy the predicate.</p>
<p class="src"><a class="def" id="v:partition">partition</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; (<a href="data-bytestring-lazy#t:ByteString">ByteString</a>, <a href="data-bytestring-lazy#t:ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#partition" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy#v:partition">partition</a></code> function takes a predicate a ByteString and returns the pair of ByteStrings with elements which do and do not satisfy the predicate, respectively; i.e.,</p>
<pre>partition p bs == (filter p xs, filter (not . p) xs)</pre>
<h2 id="g:20">Indexing ByteStrings</h2>
<p class="src"><a class="def" id="v:index">index</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-int#t:Int64">Int64</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#index" class="link">Source</a></p>
<p><span class="complexity">O(c)</span> <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> index (subscript) operator, starting from 0.</p>
<p class="src"><a class="def" id="v:elemIndex">elemIndex</a> :: <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> <a href="../base-4.8.2.0/data-int#t:Int64">Int64</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#elemIndex" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy#v:elemIndex">elemIndex</a></code> function returns the index of the first element in the given <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> which is equal to the query element, or <code><a href="../base-4.8.2.0/data-maybe#v:Nothing">Nothing</a></code> if there is no such element. This implementation uses memchr(3).</p>
<p class="src"><a class="def" id="v:elemIndexEnd">elemIndexEnd</a> :: <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> <a href="../base-4.8.2.0/data-int#t:Int64">Int64</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#elemIndexEnd" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy#v:elemIndexEnd">elemIndexEnd</a></code> function returns the last index of the element in the given <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> which is equal to the query element, or <code><a href="../base-4.8.2.0/data-maybe#v:Nothing">Nothing</a></code> if there is no such element. The following holds:</p>
<pre>elemIndexEnd c xs ==
(-) (length xs - 1) `fmap` elemIndex c (reverse xs)</pre>
<p class="src"><a class="def" id="v:elemIndices">elemIndices</a> :: <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; [<a href="../base-4.8.2.0/data-int#t:Int64">Int64</a>] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#elemIndices" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> The <code><a href="data-bytestring-lazy#v:elemIndices">elemIndices</a></code> function extends <code><a href="data-bytestring-lazy#v:elemIndex">elemIndex</a></code>, by returning the indices of all elements equal to the query element, in ascending order. This implementation uses memchr(3).</p>
<p class="src"><a class="def" id="v:findIndex">findIndex</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> <a href="../base-4.8.2.0/data-int#t:Int64">Int64</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#findIndex" class="link">Source</a></p>
<p>The <code><a href="data-bytestring-lazy#v:findIndex">findIndex</a></code> function takes a predicate and a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> and returns the index of the first element in the ByteString satisfying the predicate.</p>
<p class="src"><a class="def" id="v:findIndices">findIndices</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; [<a href="../base-4.8.2.0/data-int#t:Int64">Int64</a>] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#findIndices" class="link">Source</a></p>
<p>The <code><a href="data-bytestring-lazy#v:findIndices">findIndices</a></code> function extends <code><a href="data-bytestring-lazy#v:findIndex">findIndex</a></code>, by returning the indices of all elements satisfying the predicate, in ascending order.</p>
<p class="src"><a class="def" id="v:count">count</a> :: <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/data-int#t:Int64">Int64</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#count" class="link">Source</a></p>
<p>count returns the number of times its argument appears in the ByteString</p>
<pre>count = length . elemIndices</pre>
<p>But more efficiently than using length on the intermediate list.</p>
<h2 id="g:21">Zipping and unzipping ByteStrings</h2>
<p class="src"><a class="def" id="v:zip">zip</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; [(<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>, <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>)] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#zip" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy#v:zip">zip</a></code> takes two ByteStrings and returns a list of corresponding pairs of bytes. If one input ByteString is short, excess elements of the longer ByteString are discarded. This is equivalent to a pair of <code><a href="data-bytestring-lazy#v:unpack">unpack</a></code> operations.</p>
<p class="src"><a class="def" id="v:zipWith">zipWith</a> :: (<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a> -&gt; a) -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; [a] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#zipWith" class="link">Source</a></p>
<p><code><a href="data-bytestring-lazy#v:zipWith">zipWith</a></code> generalises <code><a href="data-bytestring-lazy#v:zip">zip</a></code> by zipping with the function given as the first argument, instead of a tupling function. For example, <code><a href="data-bytestring-lazy#v:zipWith">zipWith</a> (+)</code> is applied to two ByteStrings to produce the list of corresponding sums.</p>
<p class="src"><a class="def" id="v:unzip">unzip</a> :: [(<a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>, <a href="../base-4.8.2.0/data-word#t:Word8">Word8</a>)] -&gt; (<a href="data-bytestring-lazy#t:ByteString">ByteString</a>, <a href="data-bytestring-lazy#t:ByteString">ByteString</a>) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#unzip" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> <code><a href="data-bytestring-lazy#v:unzip">unzip</a></code> transforms a list of pairs of bytes into a pair of ByteStrings. Note that this performs two <code><a href="data-bytestring-lazy#v:pack">pack</a></code> operations.</p>
<h2 id="g:22">Ordered ByteStrings</h2>
<h2 id="g:23">Low level conversions</h2>
<h3 id="g:24">Copying ByteStrings</h3>
<p class="src"><a class="def" id="v:copy">copy</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#copy" class="link">Source</a></p>
<p><span class="complexity">O(n)</span> Make a copy of the <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> with its own storage. This is mainly useful to allow the rest of the data pointed to by the <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> to be garbage collected, for example if a large string has been read in, and only a small part of it is needed in the rest of the program.</p>
<h2 id="g:25">I/O with <a href="data-bytestring-lazy#t:ByteString">ByteString</a>s</h2>
<h3 id="g:26">Standard input and output</h3>
<p class="src"><a class="def" id="v:getContents">getContents</a> :: <a href="../base-4.8.2.0/system-io#t:IO">IO</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#getContents" class="link">Source</a></p>
<p>getContents. Equivalent to hGetContents stdin. Will read <em>lazily</em></p>
<p class="src"><a class="def" id="v:putStr">putStr</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/system-io#t:IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#putStr" class="link">Source</a></p>
<p>Write a ByteString to stdout</p>
<p class="src"><a class="def" id="v:putStrLn">putStrLn</a> :: <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/system-io#t:IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#putStrLn" class="link">Source</a></p>
<div class="warning"><p>Deprecated: Use Data.ByteString.Lazy.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.ByteString.Lazy.Char8)</p></div>
<p>Write a ByteString to stdout, appending a newline byte</p>
<p class="src"><a class="def" id="v:interact">interact</a> :: (<a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a>) -&gt; <a href="../base-4.8.2.0/system-io#t:IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#interact" class="link">Source</a></p>
<p>The interact function takes a function of type <code>ByteString -&gt; ByteString</code> as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</p>
<h3 id="g:27">Files</h3>
<p class="src"><a class="def" id="v:readFile">readFile</a> :: <a href="../base-4.8.2.0/system-io#t:FilePath">FilePath</a> -&gt; <a href="../base-4.8.2.0/system-io#t:IO">IO</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#readFile" class="link">Source</a></p>
<p>Read an entire file <em>lazily</em> into a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code>. The Handle will be held open until EOF is encountered.</p>
<p class="src"><a class="def" id="v:writeFile">writeFile</a> :: <a href="../base-4.8.2.0/system-io#t:FilePath">FilePath</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/system-io#t:IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#writeFile" class="link">Source</a></p>
<p>Write a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> to a file.</p>
<p class="src"><a class="def" id="v:appendFile">appendFile</a> :: <a href="../base-4.8.2.0/system-io#t:FilePath">FilePath</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/system-io#t:IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#appendFile" class="link">Source</a></p>
<p>Append a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> to a file.</p>
<h3 id="g:28">I/O with Handles</h3>
<p class="src"><a class="def" id="v:hGetContents">hGetContents</a> :: <a href="../base-4.8.2.0/ghc-io-handle#t:Handle">Handle</a> -&gt; <a href="../base-4.8.2.0/system-io#t:IO">IO</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#hGetContents" class="link">Source</a></p>
<p>Read entire handle contents <em>lazily</em> into a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code>. Chunks are read on demand, using the default chunk size.</p>
<p>Once EOF is encountered, the Handle is closed.</p>
<p>Note: the <code><a href="../base-4.8.2.0/ghc-io-handle#t:Handle">Handle</a></code> should be placed in binary mode with <code><a href="../base-4.8.2.0/system-io#v:hSetBinaryMode">hSetBinaryMode</a></code> for <code><a href="data-bytestring-lazy#v:hGetContents">hGetContents</a></code> to work correctly.</p>
<p class="src"><a class="def" id="v:hGet">hGet</a> :: <a href="../base-4.8.2.0/ghc-io-handle#t:Handle">Handle</a> -&gt; <a href="../base-4.8.2.0/data-int#t:Int">Int</a> -&gt; <a href="../base-4.8.2.0/system-io#t:IO">IO</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#hGet" class="link">Source</a></p>
<p>Read <code>n</code> bytes into a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code>, directly from the specified <code><a href="../base-4.8.2.0/ghc-io-handle#t:Handle">Handle</a></code>.</p>
<p class="src"><a class="def" id="v:hGetNonBlocking">hGetNonBlocking</a> :: <a href="../base-4.8.2.0/ghc-io-handle#t:Handle">Handle</a> -&gt; <a href="../base-4.8.2.0/data-int#t:Int">Int</a> -&gt; <a href="../base-4.8.2.0/system-io#t:IO">IO</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#hGetNonBlocking" class="link">Source</a></p>
<p>hGetNonBlocking is similar to <code><a href="data-bytestring-lazy#v:hGet">hGet</a></code>, except that it will never block waiting for data to become available, instead it returns only whatever data is available. If there is no data available to be read, <code><a href="data-bytestring-lazy#v:hGetNonBlocking">hGetNonBlocking</a></code> returns <code><a href="data-bytestring-lazy#v:empty">empty</a></code>.</p>
<p>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to <code><a href="data-bytestring-lazy#v:hGet">hGet</a></code>.</p>
<p class="src"><a class="def" id="v:hPut">hPut</a> :: <a href="../base-4.8.2.0/ghc-io-handle#t:Handle">Handle</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/system-io#t:IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#hPut" class="link">Source</a></p>
<p>Outputs a <code><a href="data-bytestring-lazy#t:ByteString">ByteString</a></code> to the specified <code><a href="../base-4.8.2.0/ghc-io-handle#t:Handle">Handle</a></code>.</p>
<p class="src"><a class="def" id="v:hPutNonBlocking">hPutNonBlocking</a> :: <a href="../base-4.8.2.0/ghc-io-handle#t:Handle">Handle</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/system-io#t:IO">IO</a> <a href="data-bytestring-lazy#t:ByteString">ByteString</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#hPutNonBlocking" class="link">Source</a></p>
<p>Similar to <code><a href="data-bytestring-lazy#v:hPut">hPut</a></code> except that it will never block. Instead it returns any tail that did not get written. This tail may be <code><a href="data-bytestring-lazy#v:empty">empty</a></code> in the case that the whole string was written, or the whole original string if nothing was written. Partial writes are also possible.</p>
<p>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to <code><a href="data-bytestring-lazy#v:hPut">hPut</a></code>.</p>
<p class="src"><a class="def" id="v:hPutStr">hPutStr</a> :: <a href="../base-4.8.2.0/ghc-io-handle#t:Handle">Handle</a> -&gt; <a href="data-bytestring-lazy#t:ByteString">ByteString</a> -&gt; <a href="../base-4.8.2.0/system-io#t:IO">IO</a> () <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/src/Data-ByteString-Lazy.html#hPutStr" class="link">Source</a></p>
<p>A synonym for <code>hPut</code>, for compatibility</p>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    © The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/Data-ByteString-Lazy.html" class="_attribution-link">https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/bytestring-0.10.6.0/Data-ByteString-Lazy.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
