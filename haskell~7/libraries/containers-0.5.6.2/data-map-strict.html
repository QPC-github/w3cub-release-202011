
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Data.Map.Strict - Haskell 7 - W3cubDocs</title>
  
  <meta name="description" content=" An efficient implementation of ordered maps from keys to values (dictionaries). ">
  <meta name="keywords" content="data, map, strict, haskell, haskell~7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/haskell~7/libraries/containers-0.5.6.2/data-map-strict.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/haskell~7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/haskell~7/" class="_nav-link" title="" style="margin-left:0;">Haskell 7</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _haskell">
				
				
<h1 class="caption">Data.Map.Strict</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th>Copyright</th>
<td>(c) Daan Leijen 2002 (c) Andriy Palamarchuk 2008</td>
</tr>
<tr>
<th>License</th>
<td>BSD-style</td>
</tr>
<tr>
<th>Maintainer</th>
<td>libraries@haskell.org</td>
</tr>
<tr>
<th>Stability</th>
<td>provisional</td>
</tr>
<tr>
<th>Portability</th>
<td>portable</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Trustworthy</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell98</td>
</tr>
</table>
<div id="table-of-contents">
<h4 class="caption">Contents</h4>
<ul>
<li><a href="#g:1">Strictness properties</a></li>
<li><a href="#g:2">Map type</a></li>
<li><a href="#g:3">Operators</a></li>
<li><a href="#g:4">Query</a></li>
<li>
<a href="#g:5">Construction</a><ul>
<li><a href="#g:6">Insertion</a></li>
<li><a href="#g:7">Delete/Update</a></li>
</ul>
</li>
<li>
<a href="#g:8">Combine</a><ul>
<li><a href="#g:9">Union</a></li>
<li><a href="#g:10">Difference</a></li>
<li><a href="#g:11">Intersection</a></li>
<li><a href="#g:12">Universal combining function</a></li>
</ul>
</li>
<li>
<a href="#g:13">Traversal</a><ul><li><a href="#g:14">Map</a></li></ul>
</li>
<li>
<a href="#g:15">Folds</a><ul><li><a href="#g:16">Strict folds</a></li></ul>
</li>
<li>
<a href="#g:17">Conversion</a><ul>
<li><a href="#g:18">Lists</a></li>
<li><a href="#g:19">Ordered lists</a></li>
</ul>
</li>
<li><a href="#g:20">Filter</a></li>
<li><a href="#g:21">Submap</a></li>
<li><a href="#g:22">Indexed</a></li>
<li><a href="#g:23">Min/Max</a></li>
<li><a href="#g:24">Debugging</a></li>
</ul>
</div>
<div id="description">
<h4 class="caption">Description</h4>
<p>An efficient implementation of ordered maps from keys to values (dictionaries).</p>
<p>API of this module is strict in both the keys and the values. If you need value-lazy maps, use <a href="data-map-lazy">Data.Map.Lazy</a> instead. The <code><a href="data-map-strict#t:Map">Map</a></code> type is shared between the lazy and strict modules, meaning that the same <code><a href="data-map-strict#t:Map">Map</a></code> value can be passed to functions in both modules (although that is rarely needed).</p>
<p>These modules are intended to be imported qualified, to avoid name clashes with Prelude functions, e.g.</p>
<pre> import qualified Data.Map.Strict as Map</pre>
<p>The implementation of <code><a href="data-map-strict#t:Map">Map</a></code> is based on <em>size balanced</em> binary trees (or trees of <em>bounded balance</em>) as described by:</p>
<ul>
<li>Stephen Adams, "<em>Efficient sets: a balancing act</em>", Journal of Functional Programming 3(4):553-562, October 1993, <a href="http://www.swiss.ai.mit.edu/~adams/BB/">http://www.swiss.ai.mit.edu/~adams/BB/</a>.</li>
<li>J. Nievergelt and E.M. Reingold, "<em>Binary search trees of bounded balance</em>", SIAM journal of computing 2(1), March 1973.</li>
</ul>
<p>Note that the implementation is <em>left-biased</em> -- the elements of a first argument are always preferred to the second, for example in <code><a href="data-map-strict#v:union">union</a></code> or <code><a href="data-map-strict#v:insert">insert</a></code>.</p>
<p>Operation comments contain the operation time complexity in the Big-O notation (<a href="http://en.wikipedia.org/wiki/Big_O_notation">http://en.wikipedia.org/wiki/Big_O_notation</a>).</p>
<p>Be aware that the <code><a href="../base-4.8.2.0/data-functor#t:Functor">Functor</a></code>, <code><a href="../base-4.8.2.0/data-traversable#t:Traversable">Traversable</a></code> and <code>Data</code> instances are the same as for the <a href="data-map-lazy">Data.Map.Lazy</a> module, so if they are used on strict maps, the resulting maps will be lazy.</p>
</div>
<h2 id="g:1">Strictness properties</h2>
<p>This module satisfies the following strictness properties:</p>
<ol>
<li>Key arguments are evaluated to WHNF;</li>
<li>Keys and values are evaluated to WHNF before they are stored in the map.</li>
</ol>
<p>Here's an example illustrating the first property:</p>
<pre>delete undefined m  ==  undefined</pre>
<p>Here are some examples that illustrate the second property:</p>
<pre>map (\ v -&gt; undefined) m  ==  undefined      -- m is not empty
mapKeys (\ k -&gt; undefined) m  ==  undefined  -- m is not empty</pre>
<h2 id="g:2">Map type</h2>
<p class="src">data <a class="def" id="t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#Map" class="link">Source</a></p>
<p>A Map from keys <code>k</code> to values <code>a</code>.</p>
<div class="subs instances">
<h4 id="control.i:Map" class="caption collapser" onclick="toggleSection('i:Map')">Instances</h4>
<div id="section.i:Map" class="show"><table>
<tr>
<td class="src clearfix">
<a href="../base-4.8.2.0/data-functor#t:Functor">Functor</a> (<a href="data-map-strict#t:Map">Map</a> k)</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="../base-4.8.2.0/data-foldable#t:Foldable">Foldable</a> (<a href="data-map-strict#t:Map">Map</a> k)</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="../base-4.8.2.0/data-traversable#t:Traversable">Traversable</a> (<a href="data-map-strict#t:Map">Map</a> k)</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; <a href="../base-4.8.2.0/ghc-exts#t:IsList">IsList</a> (<a href="data-map-strict#t:Map">Map</a> k v)</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">(<a href="../base-4.8.2.0/data-eq#t:Eq">Eq</a> k, <a href="../base-4.8.2.0/data-eq#t:Eq">Eq</a> a) =&gt; <a href="../base-4.8.2.0/data-eq#t:Eq">Eq</a> (<a href="data-map-strict#t:Map">Map</a> k a)</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">(<a href="../base-4.8.2.0/data-data#t:Data">Data</a> k, <a href="../base-4.8.2.0/data-data#t:Data">Data</a> a, <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k) =&gt; <a href="../base-4.8.2.0/data-data#t:Data">Data</a> (<a href="data-map-strict#t:Map">Map</a> k a)</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">(<a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k, <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> v) =&gt; <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> (<a href="data-map-strict#t:Map">Map</a> k v)</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">(<a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k, <a href="../base-4.8.2.0/text-read#t:Read">Read</a> k, <a href="../base-4.8.2.0/text-read#t:Read">Read</a> e) =&gt; <a href="../base-4.8.2.0/text-read#t:Read">Read</a> (<a href="data-map-strict#t:Map">Map</a> k e)</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">(<a href="../base-4.8.2.0/text-show#t:Show">Show</a> k, <a href="../base-4.8.2.0/text-show#t:Show">Show</a> a) =&gt; <a href="../base-4.8.2.0/text-show#t:Show">Show</a> (<a href="data-map-strict#t:Map">Map</a> k a)</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">
<a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; <a href="../base-4.8.2.0/data-monoid#t:Monoid">Monoid</a> (<a href="data-map-strict#t:Map">Map</a> k v)</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">(<a href="../deepseq-1.4.1.1/control-deepseq#t:NFData">NFData</a> k, <a href="../deepseq-1.4.1.1/control-deepseq#t:NFData">NFData</a> a) =&gt; <a href="../deepseq-1.4.1.1/control-deepseq#t:NFData">NFData</a> (<a href="data-map-strict#t:Map">Map</a> k a)</td>
<td class="doc empty"> </td>
</tr>
<tr>
<td class="src clearfix">type <a href="../base-4.8.2.0/ghc-exts#t:Item">Item</a> (<a href="data-map-strict#t:Map">Map</a> k v) = (k, v)</td>
<td class="doc empty"> </td>
</tr>
</table></div>
</div>
<h2 id="g:3">Operators</h2>
<p class="src"><a class="def" id="v:-33-">(!)</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; k -&gt; a <span class="fixity">infixl 9</span> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#%21" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Find the value at a key. Calls <code><a href="../base-4.8.2.0/prelude#v:error">error</a></code> when the element can not be found.</p>
<pre>fromList [(5,'a'), (3,'b')] ! 1    Error: element not in the map
fromList [(5,'a'), (3,'b')] ! 5 == 'a'</pre>
<p class="src"><a class="def" id="v:-92--92-">(\\)</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; <a href="data-map-strict#t:Map">Map</a> k a <span class="fixity">infixl 9</span> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#%5C%5C" class="link">Source</a></p>
<p>Same as <code><a href="data-map-strict#v:difference">difference</a></code>.</p>
<h2 id="g:4">Query</h2>
<p class="src"><a class="def" id="v:null">null</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#null" class="link">Source</a></p>
<p><span class="complexity">O(1)</span>. Is the map empty?</p>
<pre>Data.Map.null (empty)           == True
Data.Map.null (singleton 1 'a') == False</pre>
<p class="src"><a class="def" id="v:size">size</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-int#t:Int">Int</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#size" class="link">Source</a></p>
<p><span class="complexity">O(1)</span>. The number of elements in the map.</p>
<pre>size empty                                   == 0
size (singleton 1 'a')                       == 1
size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3</pre>
<p class="src"><a class="def" id="v:member">member</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#member" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Is the key a member of the map? See also <code><a href="data-map-strict#v:notMember">notMember</a></code>.</p>
<pre>member 5 (fromList [(5,'a'), (3,'b')]) == True
member 1 (fromList [(5,'a'), (3,'b')]) == False</pre>
<p class="src"><a class="def" id="v:notMember">notMember</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#notMember" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Is the key not a member of the map? See also <code><a href="data-map-strict#v:member">member</a></code>.</p>
<pre>notMember 5 (fromList [(5,'a'), (3,'b')]) == False
notMember 1 (fromList [(5,'a'), (3,'b')]) == True</pre>
<p class="src"><a class="def" id="v:lookup">lookup</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#lookup" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Lookup the value at a key in the map.</p>
<p>The function will return the corresponding value as <code>(<a href="../base-4.8.2.0/data-maybe#v:Just">Just</a> value)</code>, or <code><a href="../base-4.8.2.0/data-maybe#v:Nothing">Nothing</a></code> if the key isn't in the map.</p>
<p>An example of using <code>lookup</code>:</p>
<pre>import Prelude hiding (lookup)
import Data.Map

employeeDept = fromList([("John","Sales"), ("Bob","IT")])
deptCountry = fromList([("IT","USA"), ("Sales","France")])
countryCurrency = fromList([("USA", "Dollar"), ("France", "Euro")])

employeeCurrency :: String -&gt; Maybe String
employeeCurrency name = do
    dept &lt;- lookup name employeeDept
    country &lt;- lookup dept deptCountry
    lookup country countryCurrency

main = do
    putStrLn $ "John's currency: " ++ (show (employeeCurrency "John"))
    putStrLn $ "Pete's currency: " ++ (show (employeeCurrency "Pete"))</pre>
<p>The output of this program:</p>
<pre>  John's currency: Just "Euro"
  Pete's currency: Nothing</pre>
<p class="src"><a class="def" id="v:findWithDefault">findWithDefault</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; a -&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#findWithDefault" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. The expression <code>(<a href="data-map-strict#v:findWithDefault">findWithDefault</a> def k map)</code> returns the value at key <code>k</code> or returns default value <code>def</code> when the key is not in the map.</p>
<pre>findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'
findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'</pre>
<p class="src"><a class="def" id="v:lookupLT">lookupLT</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k v -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> (k, v) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#lookupLT" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Find largest key smaller than the given one and return the corresponding (key, value) pair.</p>
<pre>lookupLT 3 (fromList [(3,'a'), (5,'b')]) == Nothing
lookupLT 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')</pre>
<p class="src"><a class="def" id="v:lookupGT">lookupGT</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k v -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> (k, v) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#lookupGT" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Find smallest key greater than the given one and return the corresponding (key, value) pair.</p>
<pre>lookupGT 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
lookupGT 5 (fromList [(3,'a'), (5,'b')]) == Nothing</pre>
<p class="src"><a class="def" id="v:lookupLE">lookupLE</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k v -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> (k, v) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#lookupLE" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Find largest key smaller or equal to the given one and return the corresponding (key, value) pair.</p>
<pre>lookupLE 2 (fromList [(3,'a'), (5,'b')]) == Nothing
lookupLE 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
lookupLE 5 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')</pre>
<p class="src"><a class="def" id="v:lookupGE">lookupGE</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k v -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> (k, v) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#lookupGE" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Find smallest key greater or equal to the given one and return the corresponding (key, value) pair.</p>
<pre>lookupGE 3 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')
lookupGE 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')
lookupGE 6 (fromList [(3,'a'), (5,'b')]) == Nothing</pre>
<h2 id="g:5">Construction</h2>
<p class="src"><a class="def" id="v:empty">empty</a> :: <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#empty" class="link">Source</a></p>
<p><span class="complexity">O(1)</span>. The empty map.</p>
<pre>empty      == fromList []
size empty == 0</pre>
<p class="src"><a class="def" id="v:singleton">singleton</a> :: k -&gt; a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#singleton" class="link">Source</a></p>
<p><span class="complexity">O(1)</span>. A map with a single element.</p>
<pre>singleton 1 'a'        == fromList [(1, 'a')]
size (singleton 1 'a') == 1</pre>
<h3 id="g:6">Insertion</h3>
<p class="src"><a class="def" id="v:insert">insert</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; k -&gt; a -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#insert" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Insert a new key and value in the map. If the key is already present in the map, the associated value is replaced with the supplied value. <code><a href="data-map-strict#v:insert">insert</a></code> is equivalent to <code><a href="data-map-strict#v:insertWith">insertWith</a> <a href="../base-4.8.2.0/data-function#v:const">const</a></code>.</p>
<pre>insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
insert 5 'x' empty                         == singleton 5 'x'</pre>
<p class="src"><a class="def" id="v:insertWith">insertWith</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#insertWith" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Insert with a function, combining new value and old value. <code><a href="data-map-strict#v:insertWith">insertWith</a> f key value mp</code> will insert the pair (key, value) into <code>mp</code> if key does not exist in the map. If the key does exist, the function will insert the pair <code>(key, f new_value old_value)</code>.</p>
<pre>insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"</pre>
<p class="src"><a class="def" id="v:insertWithKey">insertWithKey</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (k -&gt; a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#insertWithKey" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Insert with a function, combining key, new value and old value. <code><a href="data-map-strict#v:insertWithKey">insertWithKey</a> f key value mp</code> will insert the pair (key, value) into <code>mp</code> if key does not exist in the map. If the key does exist, the function will insert the pair <code>(key,f key new_value old_value)</code>. Note that the key passed to f is the same key passed to <code><a href="data-map-strict#v:insertWithKey">insertWithKey</a></code>.</p>
<pre>let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]
insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"</pre>
<p class="src"><a class="def" id="v:insertLookupWithKey">insertLookupWithKey</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (k -&gt; a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; (<a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a, <a href="data-map-strict#t:Map">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#insertLookupWithKey" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Combines insert operation with old value retrieval. The expression (<code><a href="data-map-strict#v:insertLookupWithKey">insertLookupWithKey</a> f k x map</code>) is a pair where the first element is equal to (<code><a href="data-map-strict#v:lookup">lookup</a> k map</code>) and the second element equal to (<code><a href="data-map-strict#v:insertWithKey">insertWithKey</a> f k x map</code>).</p>
<pre>let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])
insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])
insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")</pre>
<p>This is how to define <code>insertLookup</code> using <code>insertLookupWithKey</code>:</p>
<pre>let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
insertLookup 5 "x" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "x")])
insertLookup 7 "x" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "x")])</pre>
<h3 id="g:7">Delete/Update</h3>
<p class="src"><a class="def" id="v:delete">delete</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#delete" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Delete a key and its value from the map. When the key is not a member of the map, the original map is returned.</p>
<pre>delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
delete 5 empty                         == empty</pre>
<p class="src"><a class="def" id="v:adjust">adjust</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (a -&gt; a) -&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#adjust" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Update a value at a specific key with the result of the provided function. When the key is not a member of the map, the original map is returned.</p>
<pre>adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
adjust ("new " ++) 7 empty                         == empty</pre>
<p class="src"><a class="def" id="v:adjustWithKey">adjustWithKey</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (k -&gt; a -&gt; a) -&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#adjustWithKey" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Adjust a value at a specific key. When the key is not a member of the map, the original map is returned.</p>
<pre>let f key x = (show key) ++ ":new " ++ x
adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
adjustWithKey f 7 empty                         == empty</pre>
<p class="src"><a class="def" id="v:update">update</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a) -&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#update" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. The expression (<code><a href="data-map-strict#v:update">update</a> f k map</code>) updates the value <code>x</code> at <code>k</code> (if it is in the map). If (<code>f x</code>) is <code><a href="../base-4.8.2.0/data-maybe#v:Nothing">Nothing</a></code>, the element is deleted. If it is (<code><a href="../base-4.8.2.0/data-maybe#v:Just">Just</a> y</code>), the key <code>k</code> is bound to the new value <code>y</code>.</p>
<pre>let f x = if x == "a" then Just "new a" else Nothing
update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"</pre>
<p class="src"><a class="def" id="v:updateWithKey">updateWithKey</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (k -&gt; a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a) -&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#updateWithKey" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. The expression (<code><a href="data-map-strict#v:updateWithKey">updateWithKey</a> f k map</code>) updates the value <code>x</code> at <code>k</code> (if it is in the map). If (<code>f k x</code>) is <code><a href="../base-4.8.2.0/data-maybe#v:Nothing">Nothing</a></code>, the element is deleted. If it is (<code><a href="../base-4.8.2.0/data-maybe#v:Just">Just</a> y</code>), the key <code>k</code> is bound to the new value <code>y</code>.</p>
<pre>let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"</pre>
<p class="src"><a class="def" id="v:updateLookupWithKey">updateLookupWithKey</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (k -&gt; a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a) -&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; (<a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a, <a href="data-map-strict#t:Map">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#updateLookupWithKey" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Lookup and update. See also <code><a href="data-map-strict#v:updateWithKey">updateWithKey</a></code>. The function returns changed value, if it is updated. Returns the original key value if the map entry is deleted.</p>
<pre>let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
updateLookupWithKey f 5 (fromList [(5,"a"), (3,"b")]) == (Just "5:new a", fromList [(3, "b"), (5, "5:new a")])
updateLookupWithKey f 7 (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a")])
updateLookupWithKey f 3 (fromList [(5,"a"), (3,"b")]) == (Just "b", singleton 5 "a")</pre>
<p class="src"><a class="def" id="v:alter">alter</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (<a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a) -&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#alter" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. The expression (<code><a href="data-map-strict#v:alter">alter</a> f k map</code>) alters the value <code>x</code> at <code>k</code>, or absence thereof. <code><a href="data-map-strict#v:alter">alter</a></code> can be used to insert, delete, or update a value in a <code><a href="data-map-strict#t:Map">Map</a></code>. In short : <code><a href="data-map-strict#v:lookup">lookup</a> k (<a href="data-map-strict#v:alter">alter</a> f k m) = f (<a href="data-map-strict#v:lookup">lookup</a> k m)</code>.</p>
<pre>let f _ = Nothing
alter f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
alter f 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"

let f _ = Just "c"
alter f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "c")]
alter f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "c")]</pre>
<h2 id="g:8">Combine</h2>
<h3 id="g:9">Union</h3>
<p class="src"><a class="def" id="v:union">union</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#union" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. The expression (<code><a href="data-map-strict#v:union">union</a> t1 t2</code>) takes the left-biased union of <code>t1</code> and <code>t2</code>. It prefers <code>t1</code> when duplicate keys are encountered, i.e. (<code><a href="data-map-strict#v:union">union</a> == <a href="data-map-lazy#v:unionWith">unionWith</a> <a href="../base-4.8.2.0/data-function#v:const">const</a></code>). The implementation uses the efficient <em>hedge-union</em> algorithm.</p>
<pre>union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]</pre>
<p class="src"><a class="def" id="v:unionWith">unionWith</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (a -&gt; a -&gt; a) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#unionWith" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. Union with a combining function. The implementation uses the efficient <em>hedge-union</em> algorithm.</p>
<pre>unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]</pre>
<p class="src"><a class="def" id="v:unionWithKey">unionWithKey</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (k -&gt; a -&gt; a -&gt; a) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#unionWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. Union with a combining function. The implementation uses the efficient <em>hedge-union</em> algorithm.</p>
<pre>let f key left_value right_value = (show key) ++ ":" ++ left_value ++ "|" ++ right_value
unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]</pre>
<p class="src"><a class="def" id="v:unions">unions</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; [<a href="data-map-strict#t:Map">Map</a> k a] -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#unions" class="link">Source</a></p>
<p>The union of a list of maps: (<code><a href="data-map-strict#v:unions">unions</a> == <a href="../base-4.8.2.0/prelude#v:foldl">foldl</a> <a href="data-map-strict#v:union">union</a> <a href="data-map-strict#v:empty">empty</a></code>).</p>
<pre>unions [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
    == fromList [(3, "b"), (5, "a"), (7, "C")]
unions [(fromList [(5, "A3"), (3, "B3")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "a"), (3, "b")])]
    == fromList [(3, "B3"), (5, "A3"), (7, "C")]</pre>
<p class="src"><a class="def" id="v:unionsWith">unionsWith</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (a -&gt; a -&gt; a) -&gt; [<a href="data-map-strict#t:Map">Map</a> k a] -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#unionsWith" class="link">Source</a></p>
<p>The union of a list of maps, with a combining operation: (<code><a href="data-map-strict#v:unionsWith">unionsWith</a> f == <a href="../base-4.8.2.0/prelude#v:foldl">foldl</a> (<a href="data-map-strict#v:unionWith">unionWith</a> f) <a href="data-map-strict#v:empty">empty</a></code>).</p>
<pre>unionsWith (++) [(fromList [(5, "a"), (3, "b")]), (fromList [(5, "A"), (7, "C")]), (fromList [(5, "A3"), (3, "B3")])]
    == fromList [(3, "bB3"), (5, "aAA3"), (7, "C")]</pre>
<h3 id="g:10">Difference</h3>
<p class="src"><a class="def" id="v:difference">difference</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#difference" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. Difference of two maps. Return elements of the first map not existing in the second map. The implementation uses an efficient <em>hedge</em> algorithm comparable with <em>hedge-union</em>.</p>
<pre>difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"</pre>
<p class="src"><a class="def" id="v:differenceWith">differenceWith</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (a -&gt; b -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#differenceWith" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. Difference with a combining function. When two equal keys are encountered, the combining function is applied to the values of these keys. If it returns <code><a href="../base-4.8.2.0/data-maybe#v:Nothing">Nothing</a></code>, the element is discarded (proper set difference). If it returns (<code><a href="../base-4.8.2.0/data-maybe#v:Just">Just</a> y</code>), the element is updated with a new value <code>y</code>. The implementation uses an efficient <em>hedge</em> algorithm comparable with <em>hedge-union</em>.</p>
<pre>let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])
    == singleton 3 "b:B"</pre>
<p class="src"><a class="def" id="v:differenceWithKey">differenceWithKey</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (k -&gt; a -&gt; b -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#differenceWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. Difference with a combining function. When two equal keys are encountered, the combining function is applied to the key and both values. If it returns <code><a href="../base-4.8.2.0/data-maybe#v:Nothing">Nothing</a></code>, the element is discarded (proper set difference). If it returns (<code><a href="../base-4.8.2.0/data-maybe#v:Just">Just</a> y</code>), the element is updated with a new value <code>y</code>. The implementation uses an efficient <em>hedge</em> algorithm comparable with <em>hedge-union</em>.</p>
<pre>let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])
    == singleton 3 "3:b|B"</pre>
<h3 id="g:11">Intersection</h3>
<p class="src"><a class="def" id="v:intersection">intersection</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#intersection" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. Intersection of two maps. Return data in the first map for the keys existing in both maps. (<code><a href="data-map-strict#v:intersection">intersection</a> m1 m2 == <a href="data-map-lazy#v:intersectionWith">intersectionWith</a> <a href="../base-4.8.2.0/data-function#v:const">const</a> m1 m2</code>). The implementation uses an efficient <em>hedge</em> algorithm comparable with <em>hedge-union</em>.</p>
<pre>intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"</pre>
<p class="src"><a class="def" id="v:intersectionWith">intersectionWith</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (a -&gt; b -&gt; c) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; <a href="data-map-strict#t:Map">Map</a> k c <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#intersectionWith" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. Intersection with a combining function. The implementation uses an efficient <em>hedge</em> algorithm comparable with <em>hedge-union</em>.</p>
<pre>intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"</pre>
<p class="src"><a class="def" id="v:intersectionWithKey">intersectionWithKey</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (k -&gt; a -&gt; b -&gt; c) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; <a href="data-map-strict#t:Map">Map</a> k c <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#intersectionWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. Intersection with a combining function. The implementation uses an efficient <em>hedge</em> algorithm comparable with <em>hedge-union</em>.</p>
<pre>let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"</pre>
<h3 id="g:12">Universal combining function</h3>
<p class="src"><a class="def" id="v:mergeWithKey">mergeWithKey</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (k -&gt; a -&gt; b -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> c) -&gt; (<a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k c) -&gt; (<a href="data-map-strict#t:Map">Map</a> k b -&gt; <a href="data-map-strict#t:Map">Map</a> k c) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; <a href="data-map-strict#t:Map">Map</a> k c <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#mergeWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. A high-performance universal combining function. This function is used to define <code><a href="data-map-strict#v:unionWith">unionWith</a></code>, <code><a href="data-map-strict#v:unionWithKey">unionWithKey</a></code>, <code><a href="data-map-strict#v:differenceWith">differenceWith</a></code>, <code><a href="data-map-strict#v:differenceWithKey">differenceWithKey</a></code>, <code><a href="data-map-strict#v:intersectionWith">intersectionWith</a></code>, <code><a href="data-map-strict#v:intersectionWithKey">intersectionWithKey</a></code> and can be used to define other custom combine functions.</p>
<p>Please make sure you know what is going on when using <code><a href="data-map-strict#v:mergeWithKey">mergeWithKey</a></code>, otherwise you can be surprised by unexpected code growth or even corruption of the data structure.</p>
<p>When <code><a href="data-map-strict#v:mergeWithKey">mergeWithKey</a></code> is given three arguments, it is inlined to the call site. You should therefore use <code><a href="data-map-strict#v:mergeWithKey">mergeWithKey</a></code> only to define your custom combining functions. For example, you could define <code><a href="data-map-strict#v:unionWithKey">unionWithKey</a></code>, <code><a href="data-map-strict#v:differenceWithKey">differenceWithKey</a></code> and <code><a href="data-map-strict#v:intersectionWithKey">intersectionWithKey</a></code> as</p>
<pre>myUnionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) id id m1 m2
myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2
myIntersectionWithKey f m1 m2 = mergeWithKey (\k x1 x2 -&gt; Just (f k x1 x2)) (const empty) (const empty) m1 m2</pre>
<p>When calling <code><a href="data-map-strict#v:mergeWithKey">mergeWithKey</a> combine only1 only2</code>, a function combining two <code>IntMap</code>s is created, such that</p>
<ul>
<li>if a key is present in both maps, it is passed with both corresponding values to the <code>combine</code> function. Depending on the result, the key is either present in the result with specified value, or is left out;</li>
<li>a nonempty subtree present only in the first map is passed to <code>only1</code> and the output is added to the result;</li>
<li>a nonempty subtree present only in the second map is passed to <code>only2</code> and the output is added to the result.</li>
</ul>
<p>The <code>only1</code> and <code>only2</code> methods <em>must return a map with a subset (possibly empty) of the keys of the given map</em>. The values can be modified arbitrarily. Most common variants of <code>only1</code> and <code>only2</code> are <code><a href="../base-4.8.2.0/data-function#v:id">id</a></code> and <code><a href="../base-4.8.2.0/data-function#v:const">const</a> <a href="data-map-strict#v:empty">empty</a></code>, but for example <code><a href="data-map-strict#v:map">map</a> f</code> or <code><a href="data-map-strict#v:filterWithKey">filterWithKey</a> f</code> could be used for any <code>f</code>.</p>
<h2 id="g:13">Traversal</h2>
<h3 id="g:14">Map</h3>
<p class="src"><a class="def" id="v:map">map</a> :: (a -&gt; b) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#map" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Map a function over all values in the map.</p>
<pre>map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]</pre>
<p class="src"><a class="def" id="v:mapWithKey">mapWithKey</a> :: (k -&gt; a -&gt; b) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#mapWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Map a function over all values in the map.</p>
<pre>let f key x = (show key) ++ ":" ++ x
mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]</pre>
<p class="src"><a class="def" id="v:traverseWithKey">traverseWithKey</a> :: <a href="../base-4.8.2.0/control-applicative#t:Applicative">Applicative</a> t =&gt; (k -&gt; a -&gt; t b) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; t (<a href="data-map-strict#t:Map">Map</a> k b) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#traverseWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. <code><a href="data-map-strict#v:traverseWithKey">traverseWithKey</a> f s == <a href="data-map-lazy#v:fromList">fromList</a> <a href="%24">$</a> <a href="../base-4.8.2.0/data-traversable#v:traverse">traverse</a> ((k, v) -&gt; (,) k <a href="%24">$</a> f k v) (<a href="data-map-strict#v:toList">toList</a> m)</code> That is, behaves exactly like a regular <code><a href="../base-4.8.2.0/data-traversable#v:traverse">traverse</a></code> except that the traversing function also has access to the key associated with a value.</p>
<pre>traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])
traverseWithKey (\k v -&gt; if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing</pre>
<p class="src"><a class="def" id="v:mapAccum">mapAccum</a> :: (a -&gt; b -&gt; (a, c)) -&gt; a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; (a, <a href="data-map-strict#t:Map">Map</a> k c) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#mapAccum" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. The function <code><a href="data-map-strict#v:mapAccum">mapAccum</a></code> threads an accumulating argument through the map in ascending order of keys.</p>
<pre>let f a b = (a ++ b, b ++ "X")
mapAccum f "Everything: " (fromList [(5,"a"), (3,"b")]) == ("Everything: ba", fromList [(3, "bX"), (5, "aX")])</pre>
<p class="src"><a class="def" id="v:mapAccumWithKey">mapAccumWithKey</a> :: (a -&gt; k -&gt; b -&gt; (a, c)) -&gt; a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; (a, <a href="data-map-strict#t:Map">Map</a> k c) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#mapAccumWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. The function <code><a href="data-map-strict#v:mapAccumWithKey">mapAccumWithKey</a></code> threads an accumulating argument through the map in ascending order of keys.</p>
<pre>let f a k b = (a ++ " " ++ (show k) ++ "-" ++ b, b ++ "X")
mapAccumWithKey f "Everything:" (fromList [(5,"a"), (3,"b")]) == ("Everything: 3-b 5-a", fromList [(3, "bX"), (5, "aX")])</pre>
<p class="src"><a class="def" id="v:mapAccumRWithKey">mapAccumRWithKey</a> :: (a -&gt; k -&gt; b -&gt; (a, c)) -&gt; a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; (a, <a href="data-map-strict#t:Map">Map</a> k c) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#mapAccumRWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. The function <code>mapAccumR</code> threads an accumulating argument through the map in descending order of keys.</p>
<p class="src"><a class="def" id="v:mapKeys">mapKeys</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k2 =&gt; (k1 -&gt; k2) -&gt; <a href="data-map-strict#t:Map">Map</a> k1 a -&gt; <a href="data-map-strict#t:Map">Map</a> k2 a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#mapKeys" class="link">Source</a></p>
<p><span class="complexity">O(n*log n)</span>. <code><a href="data-map-strict#v:mapKeys">mapKeys</a> f s</code> is the map obtained by applying <code>f</code> to each key of <code>s</code>.</p>
<p>The size of the result may be smaller if <code>f</code> maps two or more distinct keys to the same new key. In this case the value at the greatest of the original keys is retained.</p>
<pre>mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]
mapKeys (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"
mapKeys (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"</pre>
<p class="src"><a class="def" id="v:mapKeysWith">mapKeysWith</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k2 =&gt; (a -&gt; a -&gt; a) -&gt; (k1 -&gt; k2) -&gt; <a href="data-map-strict#t:Map">Map</a> k1 a -&gt; <a href="data-map-strict#t:Map">Map</a> k2 a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#mapKeysWith" class="link">Source</a></p>
<p><span class="complexity">O(n*log n)</span>. <code><a href="data-map-strict#v:mapKeysWith">mapKeysWith</a> c f s</code> is the map obtained by applying <code>f</code> to each key of <code>s</code>.</p>
<p>The size of the result may be smaller if <code>f</code> maps two or more distinct keys to the same new key. In this case the associated values will be combined using <code>c</code>.</p>
<pre>mapKeysWith (++) (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"
mapKeysWith (++) (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"</pre>
<p class="src"><a class="def" id="v:mapKeysMonotonic">mapKeysMonotonic</a> :: (k1 -&gt; k2) -&gt; <a href="data-map-strict#t:Map">Map</a> k1 a -&gt; <a href="data-map-strict#t:Map">Map</a> k2 a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#mapKeysMonotonic" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. <code><a href="data-map-strict#v:mapKeysMonotonic">mapKeysMonotonic</a> f s == <a href="data-map-strict#v:mapKeys">mapKeys</a> f s</code>, but works only when <code>f</code> is strictly monotonic. That is, for any values <code>x</code> and <code>y</code>, if <code>x</code> &lt; <code>y</code> then <code>f x</code> &lt; <code>f y</code>. <em>The precondition is not checked.</em> Semi-formally, we have:</p>
<pre>and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
                    ==&gt; mapKeysMonotonic f s == mapKeys f s
    where ls = keys s</pre>
<p>This means that <code>f</code> maps distinct original keys to distinct resulting keys. This function has better performance than <code><a href="data-map-strict#v:mapKeys">mapKeys</a></code>.</p>
<pre>mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
valid (mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")])) == True
valid (mapKeysMonotonic (\ _ -&gt; 1)     (fromList [(5,"a"), (3,"b")])) == False</pre>
<h2 id="g:15">Folds</h2>
<p class="src"><a class="def" id="v:foldr">foldr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; b <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#foldr" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Fold the values in the map using the given right-associative binary operator, such that <code><a href="data-map-strict#v:foldr">foldr</a> f z == <a href="../base-4.8.2.0/prelude#v:foldr">foldr</a> f z . <a href="data-map-strict#v:elems">elems</a></code>.</p>
<p>For example,</p>
<pre>elems map = foldr (:) [] map</pre>
<pre>let f a len = len + (length a)
foldr f 0 (fromList [(5,"a"), (3,"bbb")]) == 4</pre>
<p class="src"><a class="def" id="v:foldl">foldl</a> :: (a -&gt; b -&gt; a) -&gt; a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#foldl" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Fold the values in the map using the given left-associative binary operator, such that <code><a href="data-map-strict#v:foldl">foldl</a> f z == <a href="../base-4.8.2.0/prelude#v:foldl">foldl</a> f z . <a href="data-map-strict#v:elems">elems</a></code>.</p>
<p>For example,</p>
<pre>elems = reverse . foldl (flip (:)) []</pre>
<pre>let f len a = len + (length a)
foldl f 0 (fromList [(5,"a"), (3,"bbb")]) == 4</pre>
<p class="src"><a class="def" id="v:foldrWithKey">foldrWithKey</a> :: (k -&gt; a -&gt; b -&gt; b) -&gt; b -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; b <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#foldrWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Fold the keys and values in the map using the given right-associative binary operator, such that <code><a href="data-map-strict#v:foldrWithKey">foldrWithKey</a> f z == <a href="../base-4.8.2.0/prelude#v:foldr">foldr</a> (<a href="../base-4.8.2.0/data-tuple#v:uncurry">uncurry</a> f) z . <a href="data-map-strict#v:toAscList">toAscList</a></code>.</p>
<p>For example,</p>
<pre>keys map = foldrWithKey (\k x ks -&gt; k:ks) [] map</pre>
<pre>let f k a result = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
foldrWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (5:a)(3:b)"</pre>
<p class="src"><a class="def" id="v:foldlWithKey">foldlWithKey</a> :: (a -&gt; k -&gt; b -&gt; a) -&gt; a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#foldlWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Fold the keys and values in the map using the given left-associative binary operator, such that <code><a href="data-map-strict#v:foldlWithKey">foldlWithKey</a> f z == <a href="../base-4.8.2.0/prelude#v:foldl">foldl</a> (\z' (kx, x) -&gt; f z' kx x) z . <a href="data-map-strict#v:toAscList">toAscList</a></code>.</p>
<p>For example,</p>
<pre>keys = reverse . foldlWithKey (\ks k x -&gt; k:ks) []</pre>
<pre>let f result k a = result ++ "(" ++ (show k) ++ ":" ++ a ++ ")"
foldlWithKey f "Map: " (fromList [(5,"a"), (3,"b")]) == "Map: (3:b)(5:a)"</pre>
<p class="src"><a class="def" id="v:foldMapWithKey">foldMapWithKey</a> :: <a href="../base-4.8.2.0/data-monoid#t:Monoid">Monoid</a> m =&gt; (k -&gt; a -&gt; m) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; m <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#foldMapWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Fold the keys and values in the map using the given monoid, such that</p>
<pre><code><a href="data-map-strict#v:foldMapWithKey">foldMapWithKey</a></code> f = <code><a href="../base-4.8.2.0/prelude#v:fold">fold</a></code> . <code><a href="data-map-lazy#v:mapWithKey">mapWithKey</a></code> f</pre>
<p>This can be an asymptotically faster than <code><a href="data-map-strict#v:foldrWithKey">foldrWithKey</a></code> or <code><a href="data-map-strict#v:foldlWithKey">foldlWithKey</a></code> for some monoids.</p>
<h3 id="g:16">Strict folds</h3>
<p class="src"><a class="def" id="v:foldr-39-">foldr'</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; b <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#foldr%27" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. A strict version of <code><a href="data-map-strict#v:foldr">foldr</a></code>. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</p>
<p class="src"><a class="def" id="v:foldl-39-">foldl'</a> :: (a -&gt; b -&gt; a) -&gt; a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#foldl%27" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. A strict version of <code><a href="data-map-strict#v:foldl">foldl</a></code>. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</p>
<p class="src"><a class="def" id="v:foldrWithKey-39-">foldrWithKey'</a> :: (k -&gt; a -&gt; b -&gt; b) -&gt; b -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; b <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#foldrWithKey%27" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. A strict version of <code><a href="data-map-strict#v:foldrWithKey">foldrWithKey</a></code>. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</p>
<p class="src"><a class="def" id="v:foldlWithKey-39-">foldlWithKey'</a> :: (a -&gt; k -&gt; b -&gt; a) -&gt; a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#foldlWithKey%27" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. A strict version of <code><a href="data-map-strict#v:foldlWithKey">foldlWithKey</a></code>. Each application of the operator is evaluated before using the result in the next application. This function is strict in the starting value.</p>
<h2 id="g:17">Conversion</h2>
<p class="src"><a class="def" id="v:elems">elems</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#elems" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Return all elements of the map in the ascending order of their keys. Subject to list fusion.</p>
<pre>elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]
elems empty == []</pre>
<p class="src"><a class="def" id="v:keys">keys</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; [k] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#keys" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Return all keys of the map in ascending order. Subject to list fusion.</p>
<pre>keys (fromList [(5,"a"), (3,"b")]) == [3,5]
keys empty == []</pre>
<p class="src"><a class="def" id="v:assocs">assocs</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; [(k, a)] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#assocs" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. An alias for <code><a href="data-map-strict#v:toAscList">toAscList</a></code>. Return all key/value pairs in the map in ascending key order. Subject to list fusion.</p>
<pre>assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
assocs empty == []</pre>
<p class="src"><a class="def" id="v:keysSet">keysSet</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-set#t:Set">Set</a> k <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#keysSet" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. The set of all keys of the map.</p>
<pre>keysSet (fromList [(5,"a"), (3,"b")]) == Data.Set.fromList [3,5]
keysSet empty == Data.Set.empty</pre>
<p class="src"><a class="def" id="v:fromSet">fromSet</a> :: (k -&gt; a) -&gt; <a href="data-set#t:Set">Set</a> k -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#fromSet" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Build a map from a set of keys and a function which for each key computes its value.</p>
<pre>fromSet (\k -&gt; replicate k 'a') (Data.Set.fromList [3, 5]) == fromList [(5,"aaaaa"), (3,"aaa")]
fromSet undefined Data.Set.empty == empty</pre>
<h3 id="g:18">Lists</h3>
<p class="src"><a class="def" id="v:toList">toList</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; [(k, a)] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#toList" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Convert the map to a list of key/value pairs. Subject to list fusion.</p>
<pre>toList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
toList empty == []</pre>
<p class="src"><a class="def" id="v:fromList">fromList</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; [(k, a)] -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#fromList" class="link">Source</a></p>
<p><span class="complexity">O(n*log n)</span>. Build a map from a list of key/value pairs. See also <code><a href="data-map-strict#v:fromAscList">fromAscList</a></code>. If the list contains more than one value for the same key, the last value for the key is retained.</p>
<p>If the keys of the list are ordered, linear-time implementation is used, with the performance equal to <code><a href="data-map-strict#v:fromDistinctAscList">fromDistinctAscList</a></code>.</p>
<pre>fromList [] == empty
fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]
fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]</pre>
<p class="src"><a class="def" id="v:fromListWith">fromListWith</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#fromListWith" class="link">Source</a></p>
<p><span class="complexity">O(n*log n)</span>. Build a map from a list of key/value pairs with a combining function. See also <code><a href="data-map-strict#v:fromAscListWith">fromAscListWith</a></code>.</p>
<pre>fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] == fromList [(3, "ab"), (5, "aba")]
fromListWith (++) [] == empty</pre>
<p class="src"><a class="def" id="v:fromListWithKey">fromListWithKey</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (k -&gt; a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#fromListWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n*log n)</span>. Build a map from a list of key/value pairs with a combining function. See also <code><a href="data-map-strict#v:fromAscListWithKey">fromAscListWithKey</a></code>.</p>
<pre>let f k a1 a2 = (show k) ++ a1 ++ a2
fromListWithKey f [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] == fromList [(3, "3ab"), (5, "5a5ba")]
fromListWithKey f [] == empty</pre>
<h3 id="g:19">Ordered lists</h3>
<p class="src"><a class="def" id="v:toAscList">toAscList</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; [(k, a)] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#toAscList" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Convert the map to a list of key/value pairs where the keys are in ascending order. Subject to list fusion.</p>
<pre>toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]</pre>
<p class="src"><a class="def" id="v:toDescList">toDescList</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; [(k, a)] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#toDescList" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Convert the map to a list of key/value pairs where the keys are in descending order. Subject to list fusion.</p>
<pre>toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]</pre>
<p class="src"><a class="def" id="v:fromAscList">fromAscList</a> :: <a href="../base-4.8.2.0/data-eq#t:Eq">Eq</a> k =&gt; [(k, a)] -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#fromAscList" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Build a map from an ascending list in linear time. <em>The precondition (input list is ascending) is not checked.</em></p>
<pre>fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
valid (fromAscList [(3,"b"), (5,"a"), (5,"b")]) == True
valid (fromAscList [(5,"a"), (3,"b"), (5,"b")]) == False</pre>
<p class="src"><a class="def" id="v:fromAscListWith">fromAscListWith</a> :: <a href="../base-4.8.2.0/data-eq#t:Eq">Eq</a> k =&gt; (a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#fromAscListWith" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Build a map from an ascending list in linear time with a combining function for equal keys. <em>The precondition (input list is ascending) is not checked.</em></p>
<pre>fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
valid (fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")]) == True
valid (fromAscListWith (++) [(5,"a"), (3,"b"), (5,"b")]) == False</pre>
<p class="src"><a class="def" id="v:fromAscListWithKey">fromAscListWithKey</a> :: <a href="../base-4.8.2.0/data-eq#t:Eq">Eq</a> k =&gt; (k -&gt; a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#fromAscListWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Build a map from an ascending list in linear time with a combining function for equal keys. <em>The precondition (input list is ascending) is not checked.</em></p>
<pre>let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2
fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")] == fromList [(3, "b"), (5, "5:b5:ba")]
valid (fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")]) == True
valid (fromAscListWithKey f [(5,"a"), (3,"b"), (5,"b"), (5,"b")]) == False</pre>
<p class="src"><a class="def" id="v:fromDistinctAscList">fromDistinctAscList</a> :: [(k, a)] -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#fromDistinctAscList" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Build a map from an ascending list of distinct elements in linear time. <em>The precondition is not checked.</em></p>
<pre>fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]
valid (fromDistinctAscList [(3,"b"), (5,"a")])          == True
valid (fromDistinctAscList [(3,"b"), (5,"a"), (5,"b")]) == False</pre>
<h2 id="g:20">Filter</h2>
<p class="src"><a class="def" id="v:filter">filter</a> :: (a -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#filter" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Filter all values that satisfy the predicate.</p>
<pre>filter (&gt; "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
filter (&gt; "x") (fromList [(5,"a"), (3,"b")]) == empty
filter (&lt; "a") (fromList [(5,"a"), (3,"b")]) == empty</pre>
<p class="src"><a class="def" id="v:filterWithKey">filterWithKey</a> :: (k -&gt; a -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#filterWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Filter all keys/values that satisfy the predicate.</p>
<pre>filterWithKey (\k _ -&gt; k &gt; 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"</pre>
<p class="src"><a class="def" id="v:partition">partition</a> :: (a -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; (<a href="data-map-strict#t:Map">Map</a> k a, <a href="data-map-strict#t:Map">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#partition" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Partition the map according to a predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also <code><a href="data-map-strict#v:split">split</a></code>.</p>
<pre>partition (&gt; "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
partition (&lt; "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
partition (&gt; "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])</pre>
<p class="src"><a class="def" id="v:partitionWithKey">partitionWithKey</a> :: (k -&gt; a -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; (<a href="data-map-strict#t:Map">Map</a> k a, <a href="data-map-strict#t:Map">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#partitionWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Partition the map according to a predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also <code><a href="data-map-strict#v:split">split</a></code>.</p>
<pre>partitionWithKey (\ k _ -&gt; k &gt; 3) (fromList [(5,"a"), (3,"b")]) == (singleton 5 "a", singleton 3 "b")
partitionWithKey (\ k _ -&gt; k &lt; 7) (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
partitionWithKey (\ k _ -&gt; k &gt; 7) (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])</pre>
<p class="src"><a class="def" id="v:mapMaybe">mapMaybe</a> :: (a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> b) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#mapMaybe" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Map values and collect the <code><a href="../base-4.8.2.0/data-maybe#v:Just">Just</a></code> results.</p>
<pre>let f x = if x == "a" then Just "new a" else Nothing
mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"</pre>
<p class="src"><a class="def" id="v:mapMaybeWithKey">mapMaybeWithKey</a> :: (k -&gt; a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> b) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#mapMaybeWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Map keys/values and collect the <code><a href="../base-4.8.2.0/data-maybe#v:Just">Just</a></code> results.</p>
<pre>let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"</pre>
<p class="src"><a class="def" id="v:mapEither">mapEither</a> :: (a -&gt; <a href="../base-4.8.2.0/data-either#t:Either">Either</a> b c) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; (<a href="data-map-strict#t:Map">Map</a> k b, <a href="data-map-strict#t:Map">Map</a> k c) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#mapEither" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Map values and separate the <code><a href="../base-4.8.2.0/data-either#v:Left">Left</a></code> and <code><a href="../base-4.8.2.0/data-either#v:Right">Right</a></code> results.</p>
<pre>let f a = if a &lt; "c" then Left a else Right a
mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
    == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])

mapEither (\ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
    == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])</pre>
<p class="src"><a class="def" id="v:mapEitherWithKey">mapEitherWithKey</a> :: (k -&gt; a -&gt; <a href="../base-4.8.2.0/data-either#t:Either">Either</a> b c) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; (<a href="data-map-strict#t:Map">Map</a> k b, <a href="data-map-strict#t:Map">Map</a> k c) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#mapEitherWithKey" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Map keys/values and separate the <code><a href="../base-4.8.2.0/data-either#v:Left">Left</a></code> and <code><a href="../base-4.8.2.0/data-either#v:Right">Right</a></code> results.</p>
<pre>let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
    == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])

mapEitherWithKey (\_ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
    == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])</pre>
<p class="src"><a class="def" id="v:split">split</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; (<a href="data-map-strict#t:Map">Map</a> k a, <a href="data-map-strict#t:Map">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#split" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. The expression (<code><a href="data-map-strict#v:split">split</a> k map</code>) is a pair <code>(map1,map2)</code> where the keys in <code>map1</code> are smaller than <code>k</code> and the keys in <code>map2</code> larger than <code>k</code>. Any key equal to <code>k</code> is found in neither <code>map1</code> nor <code>map2</code>.</p>
<pre>split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])
split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")
split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)
split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)</pre>
<p class="src"><a class="def" id="v:splitLookup">splitLookup</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; (<a href="data-map-strict#t:Map">Map</a> k a, <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a, <a href="data-map-strict#t:Map">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#splitLookup" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. The expression (<code><a href="data-map-strict#v:splitLookup">splitLookup</a> k map</code>) splits a map just like <code><a href="data-map-strict#v:split">split</a></code> but also returns <code><a href="data-map-strict#v:lookup">lookup</a> k map</code>.</p>
<pre>splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])
splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")
splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")
splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)
splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)</pre>
<p class="src"><a class="def" id="v:splitRoot">splitRoot</a> :: <a href="data-map-strict#t:Map">Map</a> k b -&gt; [<a href="data-map-strict#t:Map">Map</a> k b] <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#splitRoot" class="link">Source</a></p>
<p><span class="complexity">O(1)</span>. Decompose a map into pieces based on the structure of the underlying tree. This function is useful for consuming a map in parallel.</p>
<p>No guarantee is made as to the sizes of the pieces; an internal, but deterministic process determines this. However, it is guaranteed that the pieces returned will be in ascending order (all elements in the first submap less than all elements in the second, and so on).</p>
<p>Examples:</p>
<pre>splitRoot (fromList (zip [1..6] ['a'..])) ==
  [fromList [(1,'a'),(2,'b'),(3,'c')],fromList [(4,'d')],fromList [(5,'e'),(6,'f')]]</pre>
<pre>splitRoot empty == []</pre>
<p>Note that the current implementation does not return more than three submaps, but you should not depend on this behaviour because it can change in the future without notice.</p>
<h2 id="g:21">Submap</h2>
<p class="src"><a class="def" id="v:isSubmapOf">isSubmapOf</a> :: (<a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k, <a href="../base-4.8.2.0/data-eq#t:Eq">Eq</a> a) =&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#isSubmapOf" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. This function is defined as (<code><a href="data-map-strict#v:isSubmapOf">isSubmapOf</a> = <a href="data-map-strict#v:isSubmapOfBy">isSubmapOfBy</a> (==)</code>).</p>
<p class="src"><a class="def" id="v:isSubmapOfBy">isSubmapOfBy</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (a -&gt; b -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#isSubmapOfBy" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. The expression (<code><a href="data-map-strict#v:isSubmapOfBy">isSubmapOfBy</a> f t1 t2</code>) returns <code><a href="../base-4.8.2.0/data-bool#v:True">True</a></code> if all keys in <code>t1</code> are in tree <code>t2</code>, and when <code>f</code> returns <code><a href="../base-4.8.2.0/data-bool#v:True">True</a></code> when applied to their respective values. For example, the following expressions are all <code><a href="../base-4.8.2.0/data-bool#v:True">True</a></code>:</p>
<pre>isSubmapOfBy (==) (fromList [('a',1)]) (fromList [('a',1),('b',2)])
isSubmapOfBy (&lt;=) (fromList [('a',1)]) (fromList [('a',1),('b',2)])
isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1),('b',2)])</pre>
<p>But the following are all <code><a href="../base-4.8.2.0/data-bool#v:False">False</a></code>:</p>
<pre>isSubmapOfBy (==) (fromList [('a',2)]) (fromList [('a',1),('b',2)])
isSubmapOfBy (&lt;)  (fromList [('a',1)]) (fromList [('a',1),('b',2)])
isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1)])</pre>
<p class="src"><a class="def" id="v:isProperSubmapOf">isProperSubmapOf</a> :: (<a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k, <a href="../base-4.8.2.0/data-eq#t:Eq">Eq</a> a) =&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#isProperSubmapOf" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. Is this a proper submap? (ie. a submap but not equal). Defined as (<code><a href="data-map-strict#v:isProperSubmapOf">isProperSubmapOf</a> = <a href="data-map-strict#v:isProperSubmapOfBy">isProperSubmapOfBy</a> (==)</code>).</p>
<p class="src"><a class="def" id="v:isProperSubmapOfBy">isProperSubmapOfBy</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; (a -&gt; b -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a>) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k b -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#isProperSubmapOfBy" class="link">Source</a></p>
<p><span class="complexity">O(n+m)</span>. Is this a proper submap? (ie. a submap but not equal). The expression (<code><a href="data-map-strict#v:isProperSubmapOfBy">isProperSubmapOfBy</a> f m1 m2</code>) returns <code><a href="../base-4.8.2.0/data-bool#v:True">True</a></code> when <code>m1</code> and <code>m2</code> are not equal, all keys in <code>m1</code> are in <code>m2</code>, and when <code>f</code> returns <code><a href="../base-4.8.2.0/data-bool#v:True">True</a></code> when applied to their respective values. For example, the following expressions are all <code><a href="../base-4.8.2.0/data-bool#v:True">True</a></code>:</p>
<pre>isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
isProperSubmapOfBy (&lt;=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])</pre>
<p>But the following are all <code><a href="../base-4.8.2.0/data-bool#v:False">False</a></code>:</p>
<pre>isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
isProperSubmapOfBy (&lt;)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])</pre>
<h2 id="g:22">Indexed</h2>
<p class="src"><a class="def" id="v:lookupIndex">lookupIndex</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> <a href="../base-4.8.2.0/data-int#t:Int">Int</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#lookupIndex" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Lookup the <em>index</em> of a key, which is its zero-based index in the sequence sorted by keys. The index is a number from <em>0</em> up to, but not including, the <code><a href="data-map-strict#v:size">size</a></code> of the map.</p>
<pre>isJust (lookupIndex 2 (fromList [(5,"a"), (3,"b")]))   == False
fromJust (lookupIndex 3 (fromList [(5,"a"), (3,"b")])) == 0
fromJust (lookupIndex 5 (fromList [(5,"a"), (3,"b")])) == 1
isJust (lookupIndex 6 (fromList [(5,"a"), (3,"b")]))   == False</pre>
<p class="src"><a class="def" id="v:findIndex">findIndex</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; k -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-int#t:Int">Int</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#findIndex" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Return the <em>index</em> of a key, which is its zero-based index in the sequence sorted by keys. The index is a number from <em>0</em> up to, but not including, the <code><a href="data-map-strict#v:size">size</a></code> of the map. Calls <code><a href="../base-4.8.2.0/prelude#v:error">error</a></code> when the key is not a <code><a href="data-map-strict#v:member">member</a></code> of the map.</p>
<pre>findIndex 2 (fromList [(5,"a"), (3,"b")])    Error: element is not in the map
findIndex 3 (fromList [(5,"a"), (3,"b")]) == 0
findIndex 5 (fromList [(5,"a"), (3,"b")]) == 1
findIndex 6 (fromList [(5,"a"), (3,"b")])    Error: element is not in the map</pre>
<p class="src"><a class="def" id="v:elemAt">elemAt</a> :: <a href="../base-4.8.2.0/data-int#t:Int">Int</a> -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; (k, a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#elemAt" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Retrieve an element by its <em>index</em>, i.e. by its zero-based index in the sequence sorted by keys. If the <em>index</em> is out of range (less than zero, greater or equal to <code><a href="data-map-strict#v:size">size</a></code> of the map), <code><a href="../base-4.8.2.0/prelude#v:error">error</a></code> is called.</p>
<pre>elemAt 0 (fromList [(5,"a"), (3,"b")]) == (3,"b")
elemAt 1 (fromList [(5,"a"), (3,"b")]) == (5, "a")
elemAt 2 (fromList [(5,"a"), (3,"b")])    Error: index out of range</pre>
<p class="src"><a class="def" id="v:updateAt">updateAt</a> :: (k -&gt; a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a) -&gt; <a href="../base-4.8.2.0/data-int#t:Int">Int</a> -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#updateAt" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Update the element at <em>index</em>. Calls <code><a href="../base-4.8.2.0/prelude#v:error">error</a></code> when an invalid index is used.</p>
<pre>updateAt (\ _ _ -&gt; Just "x") 0    (fromList [(5,"a"), (3,"b")]) == fromList [(3, "x"), (5, "a")]
updateAt (\ _ _ -&gt; Just "x") 1    (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "x")]
updateAt (\ _ _ -&gt; Just "x") 2    (fromList [(5,"a"), (3,"b")])    Error: index out of range
updateAt (\ _ _ -&gt; Just "x") (-1) (fromList [(5,"a"), (3,"b")])    Error: index out of range
updateAt (\_ _  -&gt; Nothing)  0    (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
updateAt (\_ _  -&gt; Nothing)  1    (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
updateAt (\_ _  -&gt; Nothing)  2    (fromList [(5,"a"), (3,"b")])    Error: index out of range
updateAt (\_ _  -&gt; Nothing)  (-1) (fromList [(5,"a"), (3,"b")])    Error: index out of range</pre>
<p class="src"><a class="def" id="v:deleteAt">deleteAt</a> :: <a href="../base-4.8.2.0/data-int#t:Int">Int</a> -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#deleteAt" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Delete the element at <em>index</em>, i.e. by its zero-based index in the sequence sorted by keys. If the <em>index</em> is out of range (less than zero, greater or equal to <code><a href="data-map-strict#v:size">size</a></code> of the map), <code><a href="../base-4.8.2.0/prelude#v:error">error</a></code> is called.</p>
<pre>deleteAt 0  (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
deleteAt 1  (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
deleteAt 2 (fromList [(5,"a"), (3,"b")])     Error: index out of range
deleteAt (-1) (fromList [(5,"a"), (3,"b")])  Error: index out of range</pre>
<h2 id="g:23">Min/Max</h2>
<p class="src"><a class="def" id="v:findMin">findMin</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; (k, a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#findMin" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. The minimal key of the map. Calls <code><a href="../base-4.8.2.0/prelude#v:error">error</a></code> if the map is empty.</p>
<pre>findMin (fromList [(5,"a"), (3,"b")]) == (3,"b")
findMin empty                            Error: empty map has no minimal element</pre>
<p class="src"><a class="def" id="v:findMax">findMax</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; (k, a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#findMax" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. The maximal key of the map. Calls <code><a href="../base-4.8.2.0/prelude#v:error">error</a></code> if the map is empty.</p>
<pre>findMax (fromList [(5,"a"), (3,"b")]) == (5,"a")
findMax empty                            Error: empty map has no maximal element</pre>
<p class="src"><a class="def" id="v:deleteMin">deleteMin</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#deleteMin" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Delete the minimal key. Returns an empty map if the map is empty.</p>
<pre>deleteMin (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(5,"a"), (7,"c")]
deleteMin empty == empty</pre>
<p class="src"><a class="def" id="v:deleteMax">deleteMax</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#deleteMax" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Delete the maximal key. Returns an empty map if the map is empty.</p>
<pre>deleteMax (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(3,"b"), (5,"a")]
deleteMax empty == empty</pre>
<p class="src"><a class="def" id="v:deleteFindMin">deleteFindMin</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; ((k, a), <a href="data-map-strict#t:Map">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#deleteFindMin" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Delete and find the minimal element.</p>
<pre>deleteFindMin (fromList [(5,"a"), (3,"b"), (10,"c")]) == ((3,"b"), fromList[(5,"a"), (10,"c")])
deleteFindMin                                            Error: can not return the minimal element of an empty map</pre>
<p class="src"><a class="def" id="v:deleteFindMax">deleteFindMax</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; ((k, a), <a href="data-map-strict#t:Map">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#deleteFindMax" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Delete and find the maximal element.</p>
<pre>deleteFindMax (fromList [(5,"a"), (3,"b"), (10,"c")]) == ((10,"c"), fromList [(3,"b"), (5,"a")])
deleteFindMax empty                                      Error: can not return the maximal element of an empty map</pre>
<p class="src"><a class="def" id="v:updateMin">updateMin</a> :: (a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#updateMin" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Update the value at the minimal key.</p>
<pre>updateMin (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]
updateMin (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"</pre>
<p class="src"><a class="def" id="v:updateMax">updateMax</a> :: (a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#updateMax" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Update the value at the maximal key.</p>
<pre>updateMax (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]
updateMax (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"</pre>
<p class="src"><a class="def" id="v:updateMinWithKey">updateMinWithKey</a> :: (k -&gt; a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#updateMinWithKey" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Update the value at the minimal key.</p>
<pre>updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]
updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"</pre>
<p class="src"><a class="def" id="v:updateMaxWithKey">updateMaxWithKey</a> :: (k -&gt; a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> a) -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="data-map-strict#t:Map">Map</a> k a <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Strict.html#updateMaxWithKey" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Update the value at the maximal key.</p>
<pre>updateMaxWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]
updateMaxWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"</pre>
<p class="src"><a class="def" id="v:minView">minView</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> (a, <a href="data-map-strict#t:Map">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#minView" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Retrieves the value associated with minimal key of the map, and the map stripped of that element, or <code><a href="../base-4.8.2.0/data-maybe#v:Nothing">Nothing</a></code> if passed an empty map.</p>
<pre>minView (fromList [(5,"a"), (3,"b")]) == Just ("b", singleton 5 "a")
minView empty == Nothing</pre>
<p class="src"><a class="def" id="v:maxView">maxView</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> (a, <a href="data-map-strict#t:Map">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#maxView" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Retrieves the value associated with maximal key of the map, and the map stripped of that element, or <code><a href="../base-4.8.2.0/data-maybe#v:Nothing">Nothing</a></code> if passed an empty map.</p>
<pre>maxView (fromList [(5,"a"), (3,"b")]) == Just ("a", singleton 3 "b")
maxView empty == Nothing</pre>
<p class="src"><a class="def" id="v:minViewWithKey">minViewWithKey</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> ((k, a), <a href="data-map-strict#t:Map">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#minViewWithKey" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Retrieves the minimal (key,value) pair of the map, and the map stripped of that element, or <code><a href="../base-4.8.2.0/data-maybe#v:Nothing">Nothing</a></code> if passed an empty map.</p>
<pre>minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")
minViewWithKey empty == Nothing</pre>
<p class="src"><a class="def" id="v:maxViewWithKey">maxViewWithKey</a> :: <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-maybe#t:Maybe">Maybe</a> ((k, a), <a href="data-map-strict#t:Map">Map</a> k a) <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#maxViewWithKey" class="link">Source</a></p>
<p><span class="complexity">O(log n)</span>. Retrieves the maximal (key,value) pair of the map, and the map stripped of that element, or <code><a href="../base-4.8.2.0/data-maybe#v:Nothing">Nothing</a></code> if passed an empty map.</p>
<pre>maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")
maxViewWithKey empty == Nothing</pre>
<h2 id="g:24">Debugging</h2>
<p class="src"><a class="def" id="v:showTree">showTree</a> :: (<a href="../base-4.8.2.0/text-show#t:Show">Show</a> k, <a href="../base-4.8.2.0/text-show#t:Show">Show</a> a) =&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-string#t:String">String</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#showTree" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Show the tree that implements the map. The tree is shown in a compressed, hanging format. See <code><a href="data-map-strict#v:showTreeWith">showTreeWith</a></code>.</p>
<p class="src"><a class="def" id="v:showTreeWith">showTreeWith</a> :: (k -&gt; a -&gt; <a href="../base-4.8.2.0/data-string#t:String">String</a>) -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> -&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-string#t:String">String</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#showTreeWith" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. The expression (<code><a href="data-map-strict#v:showTreeWith">showTreeWith</a> showelem hang wide map</code>) shows the tree that implements the map. Elements are shown using the <code>showElem</code> function. If <code>hang</code> is <code><a href="../base-4.8.2.0/data-bool#v:True">True</a></code>, a <em>hanging</em> tree is shown otherwise a rotated tree is shown. If <code>wide</code> is <code><a href="../base-4.8.2.0/data-bool#v:True">True</a></code>, an extra wide version is shown.</p>
<pre> Map&gt; let t = fromDistinctAscList [(x,()) | x &lt;- [1..5]]
 Map&gt; putStrLn $ showTreeWith (\k x -&gt; show (k,x)) True False t
 (4,())
 +--(2,())
 |  +--(1,())
 |  +--(3,())
 +--(5,())

 Map&gt; putStrLn $ showTreeWith (\k x -&gt; show (k,x)) True True t
 (4,())
 |
 +--(2,())
 |  |
 |  +--(1,())
 |  |
 |  +--(3,())
 |
 +--(5,())

 Map&gt; putStrLn $ showTreeWith (\k x -&gt; show (k,x)) False True t
 +--(5,())
 |
 (4,())
 |
 |  +--(3,())
 |  |
 +--(2,())
    |
    +--(1,())</pre>
<p class="src"><a class="def" id="v:valid">valid</a> :: <a href="../base-4.8.2.0/data-ord#t:Ord">Ord</a> k =&gt; <a href="data-map-strict#t:Map">Map</a> k a -&gt; <a href="../base-4.8.2.0/data-bool#t:Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/src/Data-Map-Base.html#valid" class="link">Source</a></p>
<p><span class="complexity">O(n)</span>. Test if the internal map structure is valid.</p>
<pre>valid (fromAscList [(3,"b"), (5,"a")]) == True
valid (fromAscList [(5,"a"), (3,"b")]) == False</pre>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    © The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/Data-Map-Strict.html" class="_attribution-link">https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/containers-0.5.6.2/Data-Map-Strict.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
