
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>tf.distribute.OneDeviceStrategy - TensorFlow 2.3 - W3cubDocs</title>
  
  <meta name="description" content=" A distribution strategy for running on a single device. ">
  <meta name="keywords" content="tf, distribute, onedevicestrategy, tensorflow, tensorflow~2.3">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/tensorflow~2.3/distribute/onedevicestrategy.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/tensorflow~2.3.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/tensorflow~2.3/" class="_nav-link" title="" style="margin-left:0;">TensorFlow 2.3</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _tensorflow">
				
				
<h1 class="devsite-page-title">tf.distribute.OneDeviceStrategy</h1>      <table class="tfo-notebook-buttons tfo-api" align="left">  <td> <a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/distribute/one_device_strategy.py#L41-L233">  View source on GitHub </a> </td> </table> <p>A distribution strategy for running on a single device.</p> <p>Inherits From: <a href="strategy"><code translate="no" dir="ltr">Strategy</code></a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.distribute.OneDeviceStrategy(
    device
)
</pre>  <p>Using this strategy will place any variables created in its scope on the specified device. Input distributed through this strategy will be prefetched to the specified device. Moreover, any functions called via <code translate="no" dir="ltr">strategy.run</code> will also be placed on the specified device as well.</p> <p>Typical usage of this strategy could be testing your code with the tf.distribute.Strategy API before switching to other strategies which actually distribute to multiple devices/machines.</p> <h4 id="for_example" data-text="For example:" tabindex="0">For example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">strategy = tf.distribute.OneDeviceStrategy(device="/gpu:0")

with strategy.scope():
  v = tf.Variable(1.0)
  print(v.device)  # /job:localhost/replica:0/task:0/device:GPU:0

def step_fn(x):
  return x * 2

result = 0
for i in range(10):
  result += strategy.run(step_fn, args=(i,))
print(result)  # 90
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">device</code> </td> <td> Device string identifier for the device on which the variables should be placed. See class docs for more details on how the device is used. Examples: "/cpu:0", "/gpu:0", "/device:CPU:0", "/device:GPU:0" </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Attributes</th></tr> 
<tr> <td> <code translate="no" dir="ltr">cluster_resolver</code> </td> <td> Returns the cluster resolver associated with this strategy. <p>In general, when using a multi-worker <a href="../distribute"><code translate="no" dir="ltr">tf.distribute</code></a> strategy such as <a href="experimental/multiworkermirroredstrategy"><code translate="no" dir="ltr">tf.distribute.experimental.MultiWorkerMirroredStrategy</code></a> or <a href="experimental/tpustrategy"><code translate="no" dir="ltr">tf.distribute.experimental.TPUStrategy()</code></a>, there is a <a href="cluster_resolver/clusterresolver"><code translate="no" dir="ltr">tf.distribute.cluster_resolver.ClusterResolver</code></a> associated with the strategy used, and such an instance is returned by this property.</p> <p>Strategies that intend to have an associated <a href="cluster_resolver/clusterresolver"><code translate="no" dir="ltr">tf.distribute.cluster_resolver.ClusterResolver</code></a> must set the relevant attribute, or override this property; otherwise, <code translate="no" dir="ltr">None</code> is returned by default. Those strategies should also provide information regarding what is returned by this property.</p> <p>Single-worker strategies usually do not have a <a href="cluster_resolver/clusterresolver"><code translate="no" dir="ltr">tf.distribute.cluster_resolver.ClusterResolver</code></a>, and in those cases this property will return <code translate="no" dir="ltr">None</code>.</p> <p>The <a href="cluster_resolver/clusterresolver"><code translate="no" dir="ltr">tf.distribute.cluster_resolver.ClusterResolver</code></a> may be useful when the user needs to access information such as the cluster spec, task type or task id. For example,</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">
os.environ['TF_CONFIG'] = json.dumps({
'cluster': {
'worker': ["localhost:12345", "localhost:23456"],
'ps': ["localhost:34567"]
},
'task': {'type': 'worker', 'index': 0}
})

# This implicitly uses TF_CONFIG for the cluster and current task info.
strategy = tf.distribute.experimental.MultiWorkerMirroredStrategy()

...

if strategy.cluster_resolver.task_type == 'worker':
# Perform something that's only applicable on workers. Since we set this
# as a worker above, this block will run on this particular instance.
elif strategy.cluster_resolver.task_type == 'ps':
# Perform something that's only applicable on parameter servers. Since we
# set this as a worker above, this block will not run on this particular
# instance.
</pre> <p>For more information, please see <a href="cluster_resolver/clusterresolver"><code translate="no" dir="ltr">tf.distribute.cluster_resolver.ClusterResolver</code></a>'s API docstring. </p>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">extended</code> </td> <td> <a href="strategyextended"><code translate="no" dir="ltr">tf.distribute.StrategyExtended</code></a> with additional methods. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">num_replicas_in_sync</code> </td> <td> Returns number of replicas over which gradients are aggregated. </td> </tr> </table> <h2 id="methods" data-text="Methods" tabindex="0">Methods</h2> <h3 id="experimental_assign_to_logical_device" data-text="experimental_assign_to_logical_device" tabindex="0"><code translate="no" dir="ltr">experimental_assign_to_logical_device</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/distribute/distribute_lib.py#L1507-L1554">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
experimental_assign_to_logical_device(
    tensor, logical_device_id
)
</pre> <p>Adds annotation that <code translate="no" dir="ltr">tensor</code> will be assigned to a logical device.</p> <blockquote class="note">
<strong>Note:</strong><span> This API is only supported in TPUStrategy for now. This adds an annotation to <code translate="no" dir="ltr">tensor</code> specifying that operations on <code translate="no" dir="ltr">tensor</code> will be invoked on logical core device id <code translate="no" dir="ltr">logical_device_id</code>. When model parallelism is used, the default behavior is that all ops are placed on zero-th logical device.</span>
</blockquote>
<pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python">
# Initializing TPU system with 2 logical devices and 4 replicas.
resolver = tf.distribute.cluster_resolver.TPUClusterResolver(tpu='')
tf.config.experimental_connect_to_cluster(resolver)
topology = tf.tpu.experimental.initialize_tpu_system(resolver)
device_assignment = tf.tpu.experimental.DeviceAssignment.build(
    topology,
    computation_shape=[1, 1, 1, 2],
    num_replicas=4)
strategy = tf.distribute.TPUStrategy(
    resolver, experimental_device_assignment=device_assignment)
iterator = iter(inputs)

@tf.function()
def step_fn(inputs):
  output = tf.add(inputs, inputs)

  # Add operation will be executed on logical device 0.
  output = strategy.experimental_assign_to_logical_device(output, 0)
  return output

strategy.run(step_fn, args=(next(iterator),))
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">tensor</code> </td> <td> Input tensor to annotate. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">logical_device_id</code> </td> <td> Id of the logical core to which the tensor will be assigned. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> The logical device id presented is not consistent with total number of partitions specified by the device assignment. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> Annotated tensor with idential value as <code translate="no" dir="ltr">tensor</code>. </td> </tr> 
</table> <h3 id="experimental_distribute_dataset" data-text="experimental_distribute_dataset" tabindex="0"><code translate="no" dir="ltr">experimental_distribute_dataset</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/distribute/one_device_strategy.py#L84-L110">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
experimental_distribute_dataset(
    dataset
)
</pre> <p>Distributes a tf.data.Dataset instance provided via dataset.</p> <p>In this case, there is only one device, so this is only a thin wrapper around the input dataset. It will, however, prefetch the input data to the specified device. The returned distributed dataset can be iterated over similar to how regular datasets can.</p> <blockquote class="note">
<strong>Note:</strong><span> Currently, the user cannot add any more transformations to a distributed dataset.</span>
</blockquote> <h4 id="example" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">strategy = tf.distribute.OneDeviceStrategy()
dataset = tf.data.Dataset.range(10).batch(2)
dist_dataset = strategy.experimental_distribute_dataset(dataset)
for x in dist_dataset:
  print(x)  # [0, 1], [2, 3],...
</pre> <p>Args: dataset: <a href="../data/dataset"><code translate="no" dir="ltr">tf.data.Dataset</code></a> to be prefetched to device.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A "distributed <code translate="no" dir="ltr">Dataset</code>" that the caller can iterate over. </td> </tr> 
</table> <h3 id="experimental_distribute_datasets_from_function" data-text="experimental_distribute_datasets_from_function" tabindex="0"><code translate="no" dir="ltr">experimental_distribute_datasets_from_function</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/distribute/one_device_strategy.py#L112-L150">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
experimental_distribute_datasets_from_function(
    dataset_fn
)
</pre> <p>Distributes <a href="../data/dataset"><code translate="no" dir="ltr">tf.data.Dataset</code></a> instances created by calls to <code translate="no" dir="ltr">dataset_fn</code>.</p> <p><code translate="no" dir="ltr">dataset_fn</code> will be called once for each worker in the strategy. In this case, we only have one worker and one device so <code translate="no" dir="ltr">dataset_fn</code> is called once.</p> <p>The <code translate="no" dir="ltr">dataset_fn</code> should take an <a href="inputcontext"><code translate="no" dir="ltr">tf.distribute.InputContext</code></a> instance where information about batching and input replication can be accessed:</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">def dataset_fn(input_context):
  batch_size = input_context.get_per_replica_batch_size(global_batch_size)
  d = tf.data.Dataset.from_tensors([[1.]]).repeat().batch(batch_size)
  return d.shard(
      input_context.num_input_pipelines, input_context.input_pipeline_id)

inputs = strategy.experimental_distribute_datasets_from_function(dataset_fn)

for batch in inputs:
  replica_results = strategy.run(replica_fn, args=(batch,))
</pre>
<aside class="key-point"><strong>Key Point:</strong><span> The <a href="../data/dataset"><code translate="no" dir="ltr">tf.data.Dataset</code></a> returned by <code translate="no" dir="ltr">dataset_fn</code> should have a per-replica batch size, unlike <code translate="no" dir="ltr">experimental_distribute_dataset</code>, which uses the global batch size. This may be computed using <code translate="no" dir="ltr">input_context.get_per_replica_batch_size</code>.</span></aside>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">dataset_fn</code> </td> <td> A function taking a <a href="inputcontext"><code translate="no" dir="ltr">tf.distribute.InputContext</code></a> instance and returning a <a href="../data/dataset"><code translate="no" dir="ltr">tf.data.Dataset</code></a>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A "distributed <code translate="no" dir="ltr">Dataset</code>", which the caller can iterate over like regular datasets. </td> </tr> 
</table> <h3 id="experimental_distribute_values_from_function" data-text="experimental_distribute_values_from_function" tabindex="0"><code translate="no" dir="ltr">experimental_distribute_values_from_function</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/distribute/distribute_lib.py#L1668-L1741">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
experimental_distribute_values_from_function(
    value_fn
)
</pre> <p>Generates <a href="distributedvalues"><code translate="no" dir="ltr">tf.distribute.DistributedValues</code></a> from <code translate="no" dir="ltr">value_fn</code>.</p> <p>This function is to generate <a href="distributedvalues"><code translate="no" dir="ltr">tf.distribute.DistributedValues</code></a> to pass into <code translate="no" dir="ltr">run</code>, <code translate="no" dir="ltr">reduce</code>, or other methods that take distributed values when not using datasets.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">value_fn</code> </td> <td> The function to run to generate values. It is called for each replica with <code translate="no" dir="ltr">tf.distribute.ValueContext</code> as the sole argument. It must return a Tensor or a type that can be converted to a Tensor. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <a href="distributedvalues"><code translate="no" dir="ltr">tf.distribute.DistributedValues</code></a> containing a value for each replica. </td> </tr> 
</table> <h4 id="example_usage" data-text="Example usage:" tabindex="0">Example usage:</h4> <ol> <li>Return constant value per replica:</li> </ol> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
strategy = tf.distribute.MirroredStrategy()
def value_fn(ctx):
  return tf.constant(1.)
distributed_values = (
     strategy.experimental_distribute_values_from_function(
       value_fn))
local_result = strategy.experimental_local_results(distributed_values)
local_result
(&lt;tf.Tensor: shape=(), dtype=float32, numpy=1.0&gt;,)
</pre> <ol> <li>Distribute values in array based on replica_id:</li> </ol> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
strategy = tf.distribute.MirroredStrategy()
array_value = np.array([3., 2., 1.])
def value_fn(ctx):
  return array_value[ctx.replica_id_in_sync_group]
distributed_values = (
     strategy.experimental_distribute_values_from_function(
       value_fn))
local_result = strategy.experimental_local_results(distributed_values)
local_result
(3.0,)
</pre> <ol> <li>Specify values using num_replicas_in_sync:</li> </ol> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
strategy = tf.distribute.MirroredStrategy()
def value_fn(ctx):
  return ctx.num_replicas_in_sync
distributed_values = (
     strategy.experimental_distribute_values_from_function(
       value_fn))
local_result = strategy.experimental_local_results(distributed_values)
local_result
(1,)
</pre> <ol> <li>Place values on devices and distribute:</li> </ol> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">strategy = tf.distribute.TPUStrategy()
worker_devices = strategy.extended.worker_devices
multiple_values = []
for i in range(strategy.num_replicas_in_sync):
  with tf.device(worker_devices[i]):
    multiple_values.append(tf.constant(1.0))

def value_fn(ctx):
  return multiple_values[ctx.replica_id_in_sync_group]

distributed_values = strategy.
  experimental_distribute_values_from_function(
  value_fn)
</pre> <h3 id="experimental_local_results" data-text="experimental_local_results" tabindex="0"><code translate="no" dir="ltr">experimental_local_results</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/distribute/one_device_strategy.py#L152-L166">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
experimental_local_results(
    value
)
</pre> <p>Returns the list of all local per-replica values contained in <code translate="no" dir="ltr">value</code>.</p> <p>In <code translate="no" dir="ltr">OneDeviceStrategy</code>, the <code translate="no" dir="ltr">value</code> is always expected to be a single value, so the result is just the value in a tuple.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">value</code> </td> <td> A value returned by <code translate="no" dir="ltr">experimental_run()</code>, <code translate="no" dir="ltr">run()</code>, <code translate="no" dir="ltr">extended.call_for_each_replica()</code>, or a variable created in <code translate="no" dir="ltr">scope</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A tuple of values contained in <code translate="no" dir="ltr">value</code>. If <code translate="no" dir="ltr">value</code> represents a single value, this returns <code translate="no" dir="ltr">(value,).</code> </td> </tr> 
</table> <h3 id="experimental_make_numpy_dataset" data-text="experimental_make_numpy_dataset" tabindex="0"><code translate="no" dir="ltr">experimental_make_numpy_dataset</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/distribute/distribute_lib.py#L903-L934">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
experimental_make_numpy_dataset(
    numpy_input
)
</pre> <p>Makes a <a href="../data/dataset"><code translate="no" dir="ltr">tf.data.Dataset</code></a> from a numpy array. (deprecated)</p> <aside class="warning"><strong>Warning:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed after 2020-09-30. Instructions for updating: Please use tf.data.Dataset.from_tensor_slices instead</span></aside> <p>This avoids adding <code translate="no" dir="ltr">numpy_input</code> as a large constant in the graph, and copies the data to the machine or machines that will be processing the input.</p> <p>Note that you will likely need to use <code translate="no" dir="ltr">experimental_distribute_dataset</code> with the returned dataset to further distribute it with the strategy.</p> <h4 id="example_2" data-text="Example:" tabindex="0">Example:</h4> <pre class="devsite-click-to-copy prettyprint lang-py" translate="no" dir="ltr" data-language="cpp">
strategy = tf.distribute.MirroredStrategy()
numpy_input = np.ones([10], dtype=np.float32)
dataset = strategy.experimental_make_numpy_dataset(numpy_input)
dataset
&lt;TensorSliceDataset shapes: (), types: tf.float32&gt;
dataset = dataset.batch(2)
dist_dataset = strategy.experimental_distribute_dataset(dataset)
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">numpy_input</code> </td> <td> a nest of NumPy input arrays that will be converted into a dataset. Note that the NumPy arrays are stacked, as that is normal <a href="../data/dataset"><code translate="no" dir="ltr">tf.data.Dataset</code></a> behavior. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <a href="../data/dataset"><code translate="no" dir="ltr">tf.data.Dataset</code></a> representing <code translate="no" dir="ltr">numpy_input</code>. </td> </tr> 
</table> <h3 id="experimental_replicate_to_logical_devices" data-text="experimental_replicate_to_logical_devices" tabindex="0"><code translate="no" dir="ltr">experimental_replicate_to_logical_devices</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/distribute/distribute_lib.py#L1619-L1666">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
experimental_replicate_to_logical_devices(
    tensor
)
</pre> <p>Adds annotation that <code translate="no" dir="ltr">tensor</code> will be replicated to all logical devices.</p> <blockquote class="note">
<strong>Note:</strong><span> This API is only supported in TPUStrategy for now. This adds an annotation to tensor <code translate="no" dir="ltr">tensor</code> specifying that operations on <code translate="no" dir="ltr">tensor</code> will be invoked on all logical devices.</span>
</blockquote>
<pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># Initializing TPU system with 2 logical devices and 4 replicas.
resolver = tf.distribute.cluster_resolver.TPUClusterResolver(tpu='')
tf.config.experimental_connect_to_cluster(resolver)
topology = tf.tpu.experimental.initialize_tpu_system(resolver)
device_assignment = tf.tpu.experimental.DeviceAssignment.build(
    topology,
    computation_shape=[1, 1, 1, 2],
    num_replicas=4)
strategy = tf.distribute.TPUStrategy(
    resolver, experimental_device_assignment=device_assignment)

iterator = iter(inputs)

@tf.function()
def step_fn(inputs):
  images, labels = inputs
  images = strategy.experimental_split_to_logical_devices(
    inputs, [1, 2, 4, 1])

  # model() function will be executed on 8 logical devices with `inputs`
  # split 2 * 4  ways.
  output = model(inputs)

  # For loss calculation, all logical devices share the same logits
  # and labels.
  labels = strategy.experimental_replicate_to_logical_devices(labels)
  output = strategy.experimental_replicate_to_logical_devices(output)
  loss = loss_fn(labels, output)

  return loss

strategy.run(step_fn, args=(next(iterator),))
</pre> <p>Args: tensor: Input tensor to annotate.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> Annotated tensor with idential value as <code translate="no" dir="ltr">tensor</code>. </td> </tr> 
</table> <h3 id="experimental_split_to_logical_devices" data-text="experimental_split_to_logical_devices" tabindex="0"><code translate="no" dir="ltr">experimental_split_to_logical_devices</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/distribute/distribute_lib.py#L1556-L1617">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
experimental_split_to_logical_devices(
    tensor, partition_dimensions
)
</pre> <p>Adds annotation that <code translate="no" dir="ltr">tensor</code> will be split across logical devices.</p> <blockquote class="note">
<strong>Note:</strong><span> This API is only supported in TPUStrategy for now. This adds an annotation to tensor <code translate="no" dir="ltr">tensor</code> specifying that operations on <code translate="no" dir="ltr">tensor</code> will be be split among multiple logical devices. Tensor <code translate="no" dir="ltr">tensor</code> will be split across dimensions specified by <code translate="no" dir="ltr">partition_dimensions</code>. The dimensions of <code translate="no" dir="ltr">tensor</code> must be divisible by corresponding value in <code translate="no" dir="ltr">partition_dimensions</code>.</span>
</blockquote> <p>For example, for system with 8 logical devices, if <code translate="no" dir="ltr">tensor</code> is an image tensor with shape (batch_size, width, height, channel) and <code translate="no" dir="ltr">partition_dimensions</code> is [1, 2, 4, 1], then <code translate="no" dir="ltr">tensor</code> will be split 2 in width dimension and 4 way in height dimension and the split tensor values will be fed into 8 logical devices.</p> <pre class="prettyprint lang-python" translate="no" dir="ltr" data-language="python"># Initializing TPU system with 8 logical devices and 1 replica.
resolver = tf.distribute.cluster_resolver.TPUClusterResolver(tpu='')
tf.config.experimental_connect_to_cluster(resolver)
topology = tf.tpu.experimental.initialize_tpu_system(resolver)
device_assignment = tf.tpu.experimental.DeviceAssignment.build(
    topology,
    computation_shape=[1, 2, 2, 2],
    num_replicas=1)
strategy = tf.distribute.TPUStrategy(
    resolver, experimental_device_assignment=device_assignment)

iterator = iter(inputs)

@tf.function()
def step_fn(inputs):
  inputs = strategy.experimental_split_to_logical_devices(
    inputs, [1, 2, 4, 1])

  # model() function will be executed on 8 logical devices with `inputs`
  # split 2 * 4  ways.
  output = model(inputs)
  return output

strategy.run(step_fn, args=(next(iterator),))
</pre> <p>Args: tensor: Input tensor to annotate. partition_dimensions: An unnested list of integers with the size equal to rank of <code translate="no" dir="ltr">tensor</code> specifying how <code translate="no" dir="ltr">tensor</code> will be partitioned. The product of all elements in <code translate="no" dir="ltr">partition_dimensions</code> must be equal to the total number of logical devices per replica.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> <p>1) If the size of partition_dimensions does not equal to rank of <code translate="no" dir="ltr">tensor</code> or 2) if product of elements of <code translate="no" dir="ltr">partition_dimensions</code> does not match the number of logical devices per replica defined by the implementing DistributionStrategy's device specification or 3) if a known size of <code translate="no" dir="ltr">tensor</code> is not divisible by corresponding value in <code translate="no" dir="ltr">partition_dimensions</code>. </p>
</td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> Annotated tensor with idential value as <code translate="no" dir="ltr">tensor</code>. </td> </tr> 
</table> <h3 id="reduce" data-text="reduce" tabindex="0"><code translate="no" dir="ltr">reduce</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/distribute/one_device_strategy.py#L186-L217">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
reduce(
    reduce_op, value, axis
)
</pre> <p>Reduce <code translate="no" dir="ltr">value</code> across replicas.</p> <p>In <code translate="no" dir="ltr">OneDeviceStrategy</code>, there is only one replica, so if axis=None, value is simply returned. If axis is specified as something other than None, such as axis=0, value is reduced along that axis and returned.</p> <h4 id="example_3" data-text="Example:" tabindex="0">Example:</h4> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">t = tf.range(10)

result = strategy.reduce(tf.distribute.ReduceOp.SUM, t, axis=None).numpy()
# result: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

result = strategy.reduce(tf.distribute.ReduceOp.SUM, t, axis=0).numpy()
# result: 45
</pre>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">reduce_op</code> </td> <td> A <a href="reduceop"><code translate="no" dir="ltr">tf.distribute.ReduceOp</code></a> value specifying how values should be combined. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">value</code> </td> <td> A "per replica" value, e.g. returned by <code translate="no" dir="ltr">run</code> to be combined into a single tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">axis</code> </td> <td> Specifies the dimension to reduce along within each replica's tensor. Should typically be set to the batch dimension, or <code translate="no" dir="ltr">None</code> to only reduce across replicas (e.g. if the tensor has no batch dimension). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. </td> </tr> 
</table> <h3 id="run" data-text="run" tabindex="0"><code translate="no" dir="ltr">run</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/distribute/one_device_strategy.py#L168-L184">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
run(
    fn, args=(), kwargs=None, options=None
)
</pre> <p>Run <code translate="no" dir="ltr">fn</code> on each replica, with the given arguments.</p> <p>In <code translate="no" dir="ltr">OneDeviceStrategy</code>, <code translate="no" dir="ltr">fn</code> is simply called within a device scope for the given device, with the provided arguments.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">fn</code> </td> <td> The function to run. The output must be a <a href="../nest"><code translate="no" dir="ltr">tf.nest</code></a> of <code translate="no" dir="ltr">Tensor</code>s. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">args</code> </td> <td> (Optional) Positional arguments to <code translate="no" dir="ltr">fn</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">kwargs</code> </td> <td> (Optional) Keyword arguments to <code translate="no" dir="ltr">fn</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">options</code> </td> <td> (Optional) An instance of <a href="runoptions"><code translate="no" dir="ltr">tf.distribute.RunOptions</code></a> specifying the options to run <code translate="no" dir="ltr">fn</code>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> Return value from running <code translate="no" dir="ltr">fn</code>. </td> </tr> 
</table> <h3 id="scope" data-text="scope" tabindex="0"><code translate="no" dir="ltr">scope</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/distribute/one_device_strategy.py#L219-L233">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
scope()
</pre> <p>Returns a context manager selecting this Strategy as current.</p> <p>Inside a <code translate="no" dir="ltr">with strategy.scope():</code> code block, this thread will use a variable creator set by <code translate="no" dir="ltr">strategy</code>, and will enter its "cross-replica context".</p> <p>In <code translate="no" dir="ltr">OneDeviceStrategy</code>, all variables created inside <code translate="no" dir="ltr">strategy.scope()</code> will be on <code translate="no" dir="ltr">device</code> specified at strategy construction time. See example in the docs for this class.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A context manager to use for creating variables with this strategy. </td> </tr> 
</table>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    © 2020 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.3/api_docs/python/tf/distribute/OneDeviceStrategy" class="_attribution-link">https://www.tensorflow.org/versions/r2.3/api_docs/python/tf/distribute/OneDeviceStrategy</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
