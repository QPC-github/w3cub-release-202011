
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>backends.backend_ps - Matplotlib 3.1 - W3cubDocs</title>
  
  <meta name="description" content=" A PostScript backend, which can produce both PostScript .ps and .eps. ">
  <meta name="keywords" content="matplotlib, backends, backend, ps, matplotlib~3.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/matplotlib~3.1/backend_ps_api.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-01fda2ddb8339756caccf7add5ad4cf849ab52d069bd799015c7f04f93164f64753bff0d15a49d8060b1e66e41002bb301ccadc2350937df079cea3cd52d3cca.css">
  <script src="/assets/application-d9be6f56a823612443fc15b2e027a630e02c4ad2685bb750d13fa4fae28d46c3e7f7ebb69bd4bafddf116f218f9372e9be44021d4247dc20424e2fd1ff8cef81.js" type="text/javascript"></script>
  <script src="/json/matplotlib~3.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~3.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 3.1</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="matplotlib-backends-backend-ps">matplotlib.backends.backend_ps</h1> <p id="module-matplotlib.backends.backend_ps">A PostScript backend, which can produce both PostScript .ps and .eps.</p> <dl class="attribute"> <dt id="matplotlib.backends.backend_ps.FigureCanvas">
<code>matplotlib.backends.backend_ps.FigureCanvas</code> </dt> <dd>
<p>alias of <a class="reference internal" href="#matplotlib.backends.backend_ps.FigureCanvasPS" title="matplotlib.backends.backend_ps.FigureCanvasPS"><code>matplotlib.backends.backend_ps.FigureCanvasPS</code></a></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_ps.FigureCanvasPS">
<code>class matplotlib.backends.backend_ps.FigureCanvasPS(figure)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#FigureCanvasPS"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.FigureCanvasBase" title="matplotlib.backend_bases.FigureCanvasBase"><code>matplotlib.backend_bases.FigureCanvasBase</code></a></p> <dl class="method"> <dt id="matplotlib.backends.backend_ps.FigureCanvasPS.draw">
<code>draw(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#FigureCanvasPS.draw"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Render the <a class="reference internal" href="_as_gen/matplotlib.figure.figure#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code>Figure</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_ps.FigureCanvasPS.filetypes">
<code>filetypes = {'eps': 'Encapsulated Postscript', 'ps': 'Postscript'}</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_ps.FigureCanvasPS.fixed_dpi">
<code>fixed_dpi = 72</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.FigureCanvasPS.get_default_filetype">
<code>get_default_filetype(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#FigureCanvasPS.get_default_filetype"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the default savefig file format as specified in rcParam <code>savefig.format</code>. Returned string excludes period. Overridden in backends that only support a single file type.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.FigureCanvasPS.print_eps">
<code>print_eps(self, outfile, *args, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#FigureCanvasPS.print_eps"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.FigureCanvasPS.print_ps">
<code>print_ps(self, outfile, *args, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#FigureCanvasPS.print_ps"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_ps.GraphicsContextPS">
<code>class matplotlib.backends.backend_ps.GraphicsContextPS</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#GraphicsContextPS"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="backend_bases_api#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><code>matplotlib.backend_bases.GraphicsContextBase</code></a></p> <dl class="method"> <dt id="matplotlib.backends.backend_ps.GraphicsContextPS.get_capstyle">
<code>get_capstyle(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#GraphicsContextPS.get_capstyle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the capstyle as a string in ('butt', 'round', 'projecting').</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.GraphicsContextPS.get_joinstyle">
<code>get_joinstyle(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#GraphicsContextPS.get_joinstyle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the line join style as one of ('miter', 'round', 'bevel').</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.GraphicsContextPS.shouldstroke">
<code>shouldstroke(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#GraphicsContextPS.shouldstroke"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>[<em>Deprecated</em>]</p> <h4 class="rubric">Notes</h4> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.1: </span></p> </div> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_ps.PsBackendHelper">
<code>class matplotlib.backends.backend_ps.PsBackendHelper</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#PsBackendHelper"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <dl class="attribute"> <dt id="matplotlib.backends.backend_ps.PsBackendHelper.gs_exe">
<code>gs_exe</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_ps.PsBackendHelper.gs_version">
<code>gs_version</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.backends.backend_ps.PsBackendHelper.supports_ps2write">
<code>supports_ps2write</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.backends.backend_ps.RendererPS">
<code>class matplotlib.backends.backend_ps.RendererPS(width, height, pswriter, imagedpi=72)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>matplotlib.backends._backend_pdf_ps.RendererPDFPSBase</code></p> <p>The renderer handles all the drawing primitives using a graphics context instance that controls the colors/styles.</p> <dl class="attribute"> <dt id="matplotlib.backends.backend_ps.RendererPS.afmfontd">
<code>afmfontd</code> </dt> <dd>
<p>[<em>Deprecated</em>]</p> <h4 class="rubric">Notes</h4> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.1: </span></p> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.create_hatch">
<code>create_hatch(self, hatch)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.create_hatch"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangle">
<code>draw_gouraud_triangle(self, gc, points, colors, trans)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.draw_gouraud_triangle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw a Gouraud-shaded triangle.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>points : array_like, shape=(3, 2)</code> </dt> <dd>
<p class="first last">Array of (x, y) points for the triangle.</p> </dd> <dt>
<code>colors : array_like, shape=(3, 4)</code> </dt> <dd>
<p class="first last">RGBA colors for each point of the triangle.</p> </dd> <dt>
<code>transform : matplotlib.transforms.Transform</code> </dt> <dd>
<p class="first last">An affine transform to apply to the points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.draw_gouraud_triangles">
<code>draw_gouraud_triangles(self, gc, points, colors, trans)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.draw_gouraud_triangles"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draws a series of Gouraud triangles.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>points : array_like, shape=(N, 3, 2)</code> </dt> <dd>
<p class="first last">Array of <em>N</em> (x, y) points for the triangles.</p> </dd> <dt>
<code>colors : array_like, shape=(N, 3, 4)</code> </dt> <dd>
<p class="first last">Array of <em>N</em> RGBA colors for each point of the triangles.</p> </dd> <dt>
<code>transform : matplotlib.transforms.Transform</code> </dt> <dd>
<p class="first last">An affine transform to apply to the points.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.draw_image">
<code>draw_image(self, gc, x, y, im, transform=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.draw_image"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw an RGBA image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gc : GraphicsContextBase</code> </dt> <dd>
<p class="first last">a graphics context with clipping information.</p> </dd> <dt>
<code>x : scalar</code> </dt> <dd>
<p class="first last">the distance in physical units (i.e., dots or pixels) from the left hand side of the canvas.</p> </dd> <dt>
<code>y : scalar</code> </dt> <dd>
<p class="first last">the distance in physical units (i.e., dots or pixels) from the bottom side of the canvas.</p> </dd> <dt>
<code>im : array_like, shape=(N, M, 4), dtype=np.uint8</code> </dt> <dd>
<p class="first last">An array of RGBA pixels.</p> </dd> <dt>
<code>transform : matplotlib.transforms.Affine2DBase</code> </dt> <dd>
<p class="first last">If and only if the concrete backend is written such that <code>option_scale_image()</code> returns <code>True</code>, an affine transformation <em>may</em> be passed to <a class="reference internal" href="#matplotlib.backends.backend_ps.RendererPS.draw_image" title="matplotlib.backends.backend_ps.RendererPS.draw_image"><code>draw_image()</code></a>. It takes the form of a <a class="reference internal" href="transformations#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a> instance. The translation vector of the transformation is given in physical units (i.e., dots or pixels). Note that the transformation does not override <code>x</code> and <code>y</code>, and has to be applied <em>before</em> translating the result by <code>x</code> and <code>y</code> (this can be accomplished by adding <code>x</code> and <code>y</code> to the translation vector defined by <code>transform</code>).</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.draw_markers">
<code>draw_markers(self, gc, marker_path, marker_trans, path, trans, rgbFace=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.draw_markers"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draws a marker at each of the vertices in path. This includes all vertices, including control points on curves. To avoid that behavior, those vertices should be removed before calling this function.</p> <p>This provides a fallback implementation of draw_markers that makes multiple calls to <a class="reference internal" href="#matplotlib.backends.backend_ps.RendererPS.draw_path" title="matplotlib.backends.backend_ps.RendererPS.draw_path"><code>draw_path()</code></a>. Some backends may want to override this method in order to draw the marker only once and reuse it multiple times.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gc : GraphicsContextBase</code> </dt> <dd>
<p class="first last">The graphics context</p> </dd> <dt>
<code>marker_trans : matplotlib.transforms.Transform</code> </dt> <dd>
<p class="first last">An affine transform applied to the marker.</p> </dd> <dt>
<code>trans : matplotlib.transforms.Transform</code> </dt> <dd>
<p class="first last">An affine transform applied to the path.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.draw_mathtext">
<code>draw_mathtext(self, gc, x, y, s, prop, angle)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.draw_mathtext"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw the math text using matplotlib.mathtext.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.draw_path">
<code>draw_path(self, gc, path, transform, rgbFace=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.draw_path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draws a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance using the given affine transform.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.draw_path_collection">
<code>draw_path_collection(self, gc, master_transform, paths, all_transforms, offsets, offsetTrans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.draw_path_collection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draws a collection of paths selecting drawing properties from the lists <em>facecolors</em>, <em>edgecolors</em>, <em>linewidths</em>, <em>linestyles</em> and <em>antialiaseds</em>. <em>offsets</em> is a list of offsets to apply to each of the paths. The offsets in <em>offsets</em> are first transformed by <em>offsetTrans</em> before being applied. <em>offset_position</em> may be either "screen" or "data" depending on the space that the offsets are in.</p> <p>This provides a fallback implementation of <a class="reference internal" href="#matplotlib.backends.backend_ps.RendererPS.draw_path_collection" title="matplotlib.backends.backend_ps.RendererPS.draw_path_collection"><code>draw_path_collection()</code></a> that makes multiple calls to <a class="reference internal" href="#matplotlib.backends.backend_ps.RendererPS.draw_path" title="matplotlib.backends.backend_ps.RendererPS.draw_path"><code>draw_path()</code></a>. Some backends may want to override this in order to render each set of path data only once, and then reference that path multiple times with the different offsets, colors, styles etc. The generator methods <code>_iter_collection_raw_paths()</code> and <code>_iter_collection()</code> are provided to help with (and standardize) the implementation across backends. It is highly recommended to use those generators, so that changes to the behavior of <a class="reference internal" href="#matplotlib.backends.backend_ps.RendererPS.draw_path_collection" title="matplotlib.backends.backend_ps.RendererPS.draw_path_collection"><code>draw_path_collection()</code></a> can be made globally.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.draw_tex">
<code>draw_tex(self, gc, x, y, s, prop, angle, ismath='TeX!', mtext=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.draw_tex"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.draw_text">
<code>draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.draw_text"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw the text instance.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>gc : GraphicsContextBase</code> </dt> <dd>
<p class="first last">The graphics context.</p> </dd> <dt>
<code>x : scalar</code> </dt> <dd>
<p class="first last">The x location of the text in display coords.</p> </dd> <dt>
<code>y : scalar</code> </dt> <dd>
<p class="first last">The y location of the text baseline in display coords.</p> </dd> <dt>
<code>s : str</code> </dt> <dd>
<p class="first last">The text string.</p> </dd> <dt>
<code>prop : matplotlib.font_manager.FontProperties</code> </dt> <dd>
<p class="first last">The font properties.</p> </dd> <dt>
<code>angle : scalar</code> </dt> <dd>
<p class="first last">The rotation angle in degrees.</p> </dd> <dt>
<code>mtext : matplotlib.text.Text</code> </dt> <dd>
<p class="first last">The original text object to be rendered.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p><strong>backend implementers note</strong></p> <p>When you are trying to determine if you have gotten your bounding box right (which is what enables the text layout/alignment to work properly), it helps to change the line in text.py:</p> <pre data-language="python">if 0: bbox_artist(self, renderer)
</pre> <p>to if 1, and then the actual bounding box will be plotted along with your text.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.get_image_magnification">
<code>get_image_magnification(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.get_image_magnification"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the factor by which to magnify images passed to draw_image. Allows a backend to have images at a different resolution to other artists.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.merge_used_characters">
<code>merge_used_characters(self, other)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.merge_used_characters"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.new_gc">
<code>new_gc(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.new_gc"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return an instance of a <code>GraphicsContextBase</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.set_color">
<code>set_color(self, r, g, b, store=1)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.set_color"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.set_font">
<code>set_font(self, fontname, fontsize, store=1)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.set_font"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.set_linecap">
<code>set_linecap(self, linecap, store=1)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.set_linecap"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.set_linedash">
<code>set_linedash(self, offset, seq, store=1)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.set_linedash"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.set_linejoin">
<code>set_linejoin(self, linejoin, store=1)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.set_linejoin"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.set_linewidth">
<code>set_linewidth(self, linewidth, store=1)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.set_linewidth"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.backends.backend_ps.RendererPS.track_characters">
<code>track_characters(self, font, s)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#RendererPS.track_characters"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Keeps track of which characters are required from each font.</p> </dd>
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backends.backend_ps.convert_psfrags">
<code>matplotlib.backends.backend_ps.convert_psfrags(tmpfile, psfrags, font_preamble, custom_preamble, paperWidth, paperHeight, orientation)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#convert_psfrags"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>When we want to use the LaTeX backend with postscript, we write PSFrag tags to a temporary postscript file, each one marking a position for LaTeX to render some text. convert_psfrags generates a LaTeX document containing the commands to convert those tags to text. LaTeX/dvips produces the postscript file that includes the actual text.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backends.backend_ps.get_bbox">
<code>matplotlib.backends.backend_ps.get_bbox(tmpfile, bbox)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#get_bbox"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>[<em>Deprecated</em>] Use ghostscript's bbox device to find the center of the bounding box. Return an appropriately sized bbox centered around that point. A bit of a hack.</p> <h4 class="rubric">Notes</h4> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.0.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backends.backend_ps.get_bbox_header">
<code>matplotlib.backends.backend_ps.get_bbox_header(lbrt, rotated=False)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#get_bbox_header"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>return a postscript header string for the given bbox lbrt=(l, b, r, t). Optionally, return rotate command.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backends.backend_ps.gs_distill">
<code>matplotlib.backends.backend_ps.gs_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#gs_distill"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Use ghostscript's pswrite or epswrite device to distill a file. This yields smaller files without illegal encapsulated postscript operators. The output is low-level, converting text to outlines.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backends.backend_ps.pstoeps">
<code>matplotlib.backends.backend_ps.pstoeps(tmpfile, bbox=None, rotated=False)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#pstoeps"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert the postscript to encapsulated postscript. The bbox of the eps file will be replaced with the given <em>bbox</em> argument. If None, original bbox will be used.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backends.backend_ps.quote_ps_string">
<code>matplotlib.backends.backend_ps.quote_ps_string(s)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#quote_ps_string"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Quote dangerous characters of S for use in a PostScript string constant.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.backends.backend_ps.xpdf_distill">
<code>matplotlib.backends.backend_ps.xpdf_distill(tmpfile, eps=False, ptype='letter', bbox=None, rotated=False)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/backends/backend_ps.html#xpdf_distill"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Use ghostscript's ps2pdf and xpdf's/poppler's pdftops to distill a file. This yields smaller files without illegal encapsulated postscript operators. This distiller is preferred, generating high-level postscript output that treats text as text.</p> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2018 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/3.1.1/api/backend_ps_api.html" class="_attribution-link">https://matplotlib.org/3.1.1/api/backend_ps_api.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
