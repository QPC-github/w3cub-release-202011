
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Tri - Matplotlib 3.1 - W3cubDocs</title>
  
  <meta name="description" content=" Unstructured triangular grid functions. ">
  <meta name="keywords" content="matplotlib, tri, matplotlib~3.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/matplotlib~3.1/tri_api.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/matplotlib~3.1.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~3.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 3.1</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="matplotlib-tri">matplotlib.tri</h1> <p id="module-matplotlib.tri">Unstructured triangular grid functions.</p> <dl class="class"> <dt id="matplotlib.tri.Triangulation">
<code>class matplotlib.tri.Triangulation(x, y, triangles=None, mask=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/triangulation.html#Triangulation"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>An unstructured triangular grid consisting of npoints points and ntri triangles. The triangles can either be specified by the user or automatically generated using a Delaunay triangulation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>x, y : array-like of shape (npoints)</code> </dt> <dd>
<p class="first last">Coordinates of grid points.</p> </dd> <dt>
<code>triangles : integer array_like of shape (ntri, 3), optional</code> </dt> <dd>
<p class="first last">For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If not specified, the Delaunay triangulation is calculated.</p> </dd> <dt>
<code>mask : boolean array-like of shape (ntri), optional</code> </dt> <dd>
<p class="first last">Which triangles are masked out.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>For a Triangulation to be valid it must not have duplicate points, triangles formed from colinear points, or overlapping triangles.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>edges : int array of shape (nedges, 2)</code> </dt> <dd>
<p class="first last">Return integer array of shape (nedges, 2) containing all edges of non-masked triangles.</p> </dd> <dt>
<code>neighbors : int array of shape (ntri, 3)</code> </dt> <dd>
<p class="first last">Return integer array of shape (ntri, 3) containing neighbor triangles.</p> </dd> <dt>
<code>mask : bool array of shape (ntri, 3)</code> </dt> <dd>
<p class="first last">Masked out triangles.</p> </dd> <dt>
<code>is_delaunay : bool</code> </dt> <dd>
<p class="first last">Whether the Triangulation is a calculated Delaunay triangulation (where <code>triangles</code> was not specified) or not.</p> </dd> </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.tri.Triangulation.calculate_plane_coefficients">
<code>calculate_plane_coefficients(self, z)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/triangulation.html#Triangulation.calculate_plane_coefficients"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate plane equation coefficients for all unmasked triangles from the point (x, y) coordinates and specified z-array of shape (npoints). The returned array has shape (npoints, 3) and allows z-value at (x, y) position in triangle tri to be calculated using <code>z = array[tri, 0] * xÂ  + array[tri, 1] * y + array[tri, 2]</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.tri.Triangulation.edges">
<code>edges</code> </dt> <dd>
<p>Return integer array of shape (nedges, 2) containing all edges of non-masked triangles.</p> <p>Each row defines an edge by it's start point index and end point index. Each edge appears only once, i.e. for an edge between points <em>i</em> and <em>j</em>, there will only be either <em>(i, j)</em> or <em>(j, i)</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.tri.Triangulation.get_cpp_triangulation">
<code>get_cpp_triangulation(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/triangulation.html#Triangulation.get_cpp_triangulation"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the underlying C++ Triangulation object, creating it if necessary.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.tri.Triangulation.get_from_args_and_kwargs">
<code>static get_from_args_and_kwargs(*args, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/triangulation.html#Triangulation.get_from_args_and_kwargs"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a Triangulation object from the args and kwargs, and the remaining args and kwargs with the consumed values removed.</p> <p>There are two alternatives: either the first argument is a Triangulation object, in which case it is returned, or the args and kwargs are sufficient to create a new Triangulation to return. In the latter case, see Triangulation.__init__ for the possible args and kwargs.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.tri.Triangulation.get_masked_triangles">
<code>get_masked_triangles(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/triangulation.html#Triangulation.get_masked_triangles"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return an array of triangles that are not masked.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.tri.Triangulation.get_trifinder">
<code>get_trifinder(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/triangulation.html#Triangulation.get_trifinder"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the default <a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code>matplotlib.tri.TriFinder</code></a> of this triangulation, creating it if necessary. This allows the same TriFinder object to be easily shared.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.tri.Triangulation.neighbors">
<code>neighbors</code> </dt> <dd>
<p>Return integer array of shape (ntri, 3) containing neighbor triangles.</p> <p>For each triangle, the indices of the three triangles that share the same edges, or -1 if there is no such neighboring triangle. neighbors[i,j] is the triangle that is the neighbor to the edge from point index triangles[i,j] to point index triangles[i,(j+1)%3].</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.tri.Triangulation.set_mask">
<code>set_mask(self, mask)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/triangulation.html#Triangulation.set_mask"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set or clear the mask array. This is either None, or a boolean array of shape (ntri).</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.tri.TriFinder">
<code>class matplotlib.tri.TriFinder(triangulation)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/trifinder.html#TriFinder"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Abstract base class for classes used to find the triangles of a Triangulation in which (x,y) points lie.</p> <p>Rather than instantiate an object of a class derived from TriFinder, it is usually better to use the function <a class="reference internal" href="#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><code>matplotlib.tri.Triangulation.get_trifinder()</code></a>.</p> <p>Derived classes implement __call__(x,y) where x,y are array_like point coordinates of the same shape.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.tri.TrapezoidMapTriFinder">
<code>class matplotlib.tri.TrapezoidMapTriFinder(triangulation)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/trifinder.html#TrapezoidMapTriFinder"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>matplotlib.tri.trifinder.TriFinder</code></p> <p><a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code>TriFinder</code></a> class implemented using the trapezoid map algorithm from the book "Computational Geometry, Algorithms and Applications", second edition, by M. de Berg, M. van Kreveld, M. Overmars and O. Schwarzkopf.</p> <p>The triangulation must be valid, i.e. it must not have duplicate points, triangles formed from colinear points, or overlapping triangles. The algorithm has some tolerance to triangles formed from colinear points, but this should not be relied upon.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.tri.TriInterpolator">
<code>class matplotlib.tri.TriInterpolator(triangulation, z, trifinder=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/triinterpolate.html#TriInterpolator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Abstract base class for classes used to perform interpolation on triangular grids.</p> <p>Derived classes implement the following methods:</p>  <ul class="simple"> <li>
<code>__call__(x, y)</code> , where x, y are array_like point coordinates of the same shape, and that returns a masked array of the same shape containing the interpolated z-values.</li> <li>
<code>gradient(x, y)</code> , where x, y are array_like point coordinates of the same shape, and that returns a list of 2 masked arrays of the same shape containing the 2 derivatives of the interpolator (derivatives of interpolated z values with respect to x and y).</li> </ul>  </dd>
</dl> <dl class="class"> <dt id="matplotlib.tri.LinearTriInterpolator">
<code>class matplotlib.tri.LinearTriInterpolator(triangulation, z, trifinder=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/triinterpolate.html#LinearTriInterpolator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>matplotlib.tri.triinterpolate.TriInterpolator</code></p> <p>A LinearTriInterpolator performs linear interpolation on a triangular grid.</p> <p>Each triangle is represented by a plane so that an interpolated value at point (x,y) lies on the plane of the triangle containing (x,y). Interpolated values are therefore continuous across the triangulation, but their first derivatives are discontinuous at edges between triangles.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>triangulation : Triangulation object</code> </dt> <dd>
<p class="first last">The triangulation to interpolate over.</p> </dd> <dt>
<code>z : array_like of shape (npoints,)</code> </dt> <dd>
<p class="first last">Array of values, defined at grid points, to interpolate between.</p> </dd> <dt>
<code>trifinder : TriFinder object, optional</code> </dt> <dd>
<p class="first last">If this is not specified, the Triangulation's default TriFinder will be used by calling <a class="reference internal" href="#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><code>matplotlib.tri.Triangulation.get_trifinder()</code></a>.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Methods</h4> <table class="docutils">   <tr>
<td><strong>`__call__` (x, y)</strong></td> <td>( Returns interpolated values at x,y points)</td> </tr> <tr>
<td><strong>`gradient` (x, y)</strong></td> <td>(Returns interpolated derivatives at x,y points)</td> </tr>  </table> <dl class="method"> <dt id="matplotlib.tri.LinearTriInterpolator.gradient">
<code>gradient(self, x, y)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/triinterpolate.html#LinearTriInterpolator.gradient"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a list of 2 masked arrays containing interpolated derivatives at the specified x,y points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>x, y : array-like</code> </dt> <dd>
<p class="first last">x and y coordinates of the same shape and any number of dimensions.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>dzdx, dzdy : np.ma.array</code> </dt> <dd>
<p class="first last">2 masked arrays of the same shape as <em>x</em> and <em>y</em>; values corresponding to (x,y) points outside of the triangulation are masked out. The first returned array contains the values of <span class="math notranslate nohighlight">\(\frac{\partial z}{\partial x}\)</span> and the second those of <span class="math notranslate nohighlight">\(\frac{\partial z}{\partial y}\)</span>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.tri.CubicTriInterpolator">
<code>class matplotlib.tri.CubicTriInterpolator(triangulation, z, kind='min_E', trifinder=None, dz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/triinterpolate.html#CubicTriInterpolator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>matplotlib.tri.triinterpolate.TriInterpolator</code></p> <p>A CubicTriInterpolator performs cubic interpolation on triangular grids.</p> <p>In one-dimension - on a segment - a cubic interpolating function is defined by the values of the function and its derivative at both ends. This is almost the same in 2-d inside a triangle, except that the values of the function and its 2 derivatives have to be defined at each triangle node.</p> <p>The CubicTriInterpolator takes the value of the function at each node - provided by the user - and internally computes the value of the derivatives, resulting in a smooth interpolation. (As a special feature, the user can also impose the value of the derivatives at each node, but this is not supposed to be the common usage.)</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>triangulation : Triangulation object</code> </dt> <dd>
<p class="first last">The triangulation to interpolate over.</p> </dd> <dt>
<code>z : array_like of shape (npoints,)</code> </dt> <dd>
<p class="first last">Array of values, defined at grid points, to interpolate between.</p> </dd> <dt>
<code>kind : {'min_E', 'geom', 'user'}, optional</code> </dt> <dd>
<p class="first">Choice of the smoothing algorithm, in order to compute the interpolant derivatives (defaults to 'min_E'):</p>  <ul class="simple"> <li>if 'min_E': (default) The derivatives at each node is computed to minimize a bending energy.</li> <li>if 'geom': The derivatives at each node is computed as a weighted average of relevant triangle normals. To be used for speed optimization (large grids).</li> <li>if 'user': The user provides the argument <code>dz</code>, no computation is hence needed.</li> </ul>  </dd> <dt>
<code>trifinder : TriFinder object, optional</code> </dt> <dd>
<p class="first last">If not specified, the Triangulation's default TriFinder will be used by calling <a class="reference internal" href="#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><code>matplotlib.tri.Triangulation.get_trifinder()</code></a>.</p> </dd> <dt>
<code>dz : tuple of array_likes (dzdx, dzdy), optional</code> </dt> <dd>
<p class="first last">Used only if <em>kind</em> ='user'. In this case <em>dz</em> must be provided as (dzdx, dzdy) where dzdx, dzdy are arrays of the same shape as <em>z</em> and are the interpolant first derivatives at the <em>triangulation</em> points.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>This note is a bit technical and details the way a <a class="reference internal" href="#matplotlib.tri.CubicTriInterpolator" title="matplotlib.tri.CubicTriInterpolator"><code>CubicTriInterpolator</code></a> computes a cubic interpolation.</p> <p>The interpolation is based on a Clough-Tocher subdivision scheme of the <em>triangulation</em> mesh (to make it clearer, each triangle of the grid will be divided in 3 child-triangles, and on each child triangle the interpolated function is a cubic polynomial of the 2 coordinates). This technique originates from FEM (Finite Element Method) analysis; the element used is a reduced Hsieh-Clough-Tocher (HCT) element. Its shape functions are described in <a class="reference internal" href="#r0be0c58fd53f-1" id="id1">[R0be0c58fd53f-1]</a>. The assembled function is guaranteed to be C1-smooth, i.e. it is continuous and its first derivatives are also continuous (this is easy to show inside the triangles but is also true when crossing the edges).</p> <p>In the default case (<em>kind</em> ='min_E'), the interpolant minimizes a curvature energy on the functional space generated by the HCT element shape functions - with imposed values but arbitrary derivatives at each node. The minimized functional is the integral of the so-called total curvature (implementation based on an algorithm from <a class="reference internal" href="#r0be0c58fd53f-2" id="id2">[R0be0c58fd53f-2]</a> - PCG sparse solver):</p>  <div class="math notranslate nohighlight"> \[E(z) = \frac{1}{2} \int_{\Omega} \left( \left( \frac{\partial^2{z}}{\partial{x}^2} \right)^2 + \left( \frac{\partial^2{z}}{\partial{y}^2} \right)^2 + 2\left( \frac{\partial^2{z}}{\partial{y}\partial{x}} \right)^2 \right) dx\,dy\]</div>  <p>If the case <em>kind</em> ='geom' is chosen by the user, a simple geometric approximation is used (weighted average of the triangle normal vectors), which could improve speed on very large grids.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r0be0c58fd53f-1" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id1">[R0be0c58fd53f-1]</a></td>
<td>Michel Bernadou, Kamal Hassan, "Basis functions for general Hsieh-Clough-Tocher triangles, complete or reduced.", International Journal for Numerical Methods in Engineering, 17(5):784 - 789. 2.01.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r0be0c58fd53f-2" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id2">[R0be0c58fd53f-2]</a></td>
<td>C.T. Kelley, "Iterative Methods for Optimization".</td>
</tr>  </table> <h4 class="rubric">Methods</h4> <table class="docutils">   <tr>
<td><strong>`__call__` (x, y)</strong></td> <td>( Returns interpolated values at x,y points)</td> </tr> <tr>
<td><strong>`gradient` (x, y)</strong></td> <td>(Returns interpolated derivatives at x,y points)</td> </tr>  </table> <dl class="method"> <dt id="matplotlib.tri.CubicTriInterpolator.gradient">
<code>gradient(self, x, y)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/triinterpolate.html#CubicTriInterpolator.gradient"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a list of 2 masked arrays containing interpolated derivatives at the specified x,y points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>x, y : array-like</code> </dt> <dd>
<p class="first last">x and y coordinates of the same shape and any number of dimensions.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>dzdx, dzdy : np.ma.array</code> </dt> <dd>
<p class="first last">2 masked arrays of the same shape as <em>x</em> and <em>y</em>; values corresponding to (x,y) points outside of the triangulation are masked out. The first returned array contains the values of <span class="math notranslate nohighlight">\(\frac{\partial z}{\partial x}\)</span> and the second those of <span class="math notranslate nohighlight">\(\frac{\partial z}{\partial y}\)</span>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.tri.TriRefiner">
<code>class matplotlib.tri.TriRefiner(triangulation)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/trirefine.html#TriRefiner"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Abstract base class for classes implementing mesh refinement.</p> <p>A TriRefiner encapsulates a Triangulation object and provides tools for mesh refinement and interpolation.</p> <p>Derived classes must implements:</p>  <ul> <li>
<p class="first"><code>refine_triangulation(return_tri_index=False, **kwargs)</code> , where the optional keyword arguments <em>kwargs</em> are defined in each TriRefiner concrete implementation, and which returns:</p>  <ul class="simple"> <li>a refined triangulation</li> <li>optionally (depending on <em>return_tri_index</em>), for each point of the refined triangulation: the index of the initial triangulation triangle to which it belongs.</li> </ul>  </li> <li>
<p class="first"><code>refine_field(z, triinterpolator=None, **kwargs)</code> , where:</p>  <ul class="simple"> <li>
<em>z</em> array of field values (to refine) defined at the base triangulation nodes</li> <li>
<em>triinterpolator</em> is a <a class="reference internal" href="#matplotlib.tri.TriInterpolator" title="matplotlib.tri.TriInterpolator"><code>TriInterpolator</code></a> (optional)</li> <li>the other optional keyword arguments <em>kwargs</em> are defined in each TriRefiner concrete implementation</li> </ul>  <p>and which returns (as a tuple) a refined triangular mesh and the interpolated values of the field at the refined triangulation nodes.</p> </li> </ul>  </dd>
</dl> <dl class="class"> <dt id="matplotlib.tri.UniformTriRefiner">
<code>class matplotlib.tri.UniformTriRefiner(triangulation)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/trirefine.html#UniformTriRefiner"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>matplotlib.tri.trirefine.TriRefiner</code></p> <p>Uniform mesh refinement by recursive subdivisions.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>triangulation : Triangulation</code> </dt> <dd>
<p class="first last">The encapsulated triangulation (to be refined)</p> </dd> </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.tri.UniformTriRefiner.refine_field">
<code>refine_field(self, z, triinterpolator=None, subdiv=3)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/trirefine.html#UniformTriRefiner.refine_field"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Refines a field defined on the encapsulated triangulation.</p> <p>Returns <em>refi_tri</em> (refined triangulation), <em>refi_z</em> (interpolated values of the field at the node of the refined triangulation).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>z : 1d-array-like of length n_points</code> </dt> <dd>
<p class="first last">Values of the field to refine, defined at the nodes of the encapsulated triangulation. (<code>n_points</code> is the number of points in the initial triangulation)</p> </dd> <dt>
<code>triinterpolator : TriInterpolator, optional</code> </dt> <dd>
<p class="first last">Interpolator used for field interpolation. If not specified, a <a class="reference internal" href="#matplotlib.tri.CubicTriInterpolator" title="matplotlib.tri.CubicTriInterpolator"><code>CubicTriInterpolator</code></a> will be used.</p> </dd> <dt>
<code>subdiv : integer, optional</code> </dt> <dd>
<p class="first last">Recursion level for the subdivision. Defaults to 3. Each triangle will be divided into <code>4**subdiv</code> child triangles.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>refi_tri : Triangulation object</code> </dt> <dd>
<p class="first last">The returned refined triangulation</p> </dd> <dt>
<code>refi_z : 1d array of length: refi_tri node count.</code> </dt> <dd>
<p class="first last">The returned interpolated field (at <em>refi_tri</em> nodes)</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.tri.UniformTriRefiner.refine_triangulation">
<code>refine_triangulation(self, return_tri_index=False, subdiv=3)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/trirefine.html#UniformTriRefiner.refine_triangulation"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Computes an uniformly refined triangulation <em>refi_triangulation</em> of the encapsulated <code>triangulation</code>.</p> <p>This function refines the encapsulated triangulation by splitting each father triangle into 4 child sub-triangles built on the edges midside nodes, recursively (level of recursion <em>subdiv</em>). In the end, each triangle is hence divided into <code>4**subdiv</code> child triangles. The default value for <em>subdiv</em> is 3 resulting in 64 refined subtriangles for each triangle of the initial triangulation.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>return_tri_index : boolean, optional</code> </dt> <dd>
<p class="first last">Boolean indicating whether an index table indicating the father triangle index of each point will be returned. Default value False.</p> </dd> <dt>
<code>subdiv : integer, optional</code> </dt> <dd>
<p class="first last">Recursion level for the subdivision. Defaults value 3. Each triangle will be divided into <code>4**subdiv</code> child triangles.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>refi_triangulation : Triangulation</code> </dt> <dd>
<p class="first last">The returned refined triangulation</p> </dd> <dt>
<code>found_index : array-like of integers</code> </dt> <dd>
<p class="first last">Index of the initial triangulation containing triangle, for each point of <em>refi_triangulation</em>. Returned only if <em>return_tri_index</em> is set to True.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.tri.TriAnalyzer">
<code>class matplotlib.tri.TriAnalyzer(triangulation)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/tritools.html#TriAnalyzer"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Define basic tools for triangular mesh analysis and improvement.</p> <p>A TriAnalyzer encapsulates a <a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code>Triangulation</code></a> object and provides basic tools for mesh analysis and mesh improvement.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>triangulation : Triangulation object</code> </dt> <dd>
<p class="first last">The encapsulated triangulation to analyze.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt><strong>`scale_factors`</strong></dt>  </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.tri.TriAnalyzer.circle_ratios">
<code>circle_ratios(self, rescale=True)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/tritools.html#TriAnalyzer.circle_ratios"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a measure of the triangulation triangles flatness.</p> <p>The ratio of the incircle radius over the circumcircle radius is a widely used indicator of a triangle flatness. It is always <code>&lt;= 0.5</code> and <code>== 0.5</code> only for equilateral triangles. Circle ratios below 0.01 denote very flat triangles.</p> <p>To avoid unduly low values due to a difference of scale between the 2 axis, the triangular mesh can first be rescaled to fit inside a unit square with <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code>scale_factors</code></a> (Only if <em>rescale</em> is True, which is its default value).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>rescale : boolean, optional</code> </dt> <dd>
<p class="first last">If True, a rescaling will be internally performed (based on <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code>scale_factors</code></a>, so that the (unmasked) triangles fit exactly inside a unit square mesh. Default is True.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>circle_ratios : masked array</code> </dt> <dd>
<p class="first last">Ratio of the incircle radius over the circumcircle radius, for each 'rescaled' triangle of the encapsulated triangulation. Values corresponding to masked triangles are masked out.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.tri.TriAnalyzer.get_flat_tri_mask">
<code>get_flat_tri_mask(self, min_circle_ratio=0.01, rescale=True)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/tri/tritools.html#TriAnalyzer.get_flat_tri_mask"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Eliminates excessively flat border triangles from the triangulation.</p> <p>Returns a mask <em>new_mask</em> which allows to clean the encapsulated triangulation from its border-located flat triangles (according to their <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.circle_ratios" title="matplotlib.tri.TriAnalyzer.circle_ratios"><code>circle_ratios()</code></a>). This mask is meant to be subsequently applied to the triangulation using <a class="reference internal" href="#matplotlib.tri.Triangulation.set_mask" title="matplotlib.tri.Triangulation.set_mask"><code>matplotlib.tri.Triangulation.set_mask()</code></a>. <em>new_mask</em> is an extension of the initial triangulation mask in the sense that an initially masked triangle will remain masked.</p> <p>The <em>new_mask</em> array is computed recursively; at each step flat triangles are removed only if they share a side with the current mesh border. Thus no new holes in the triangulated domain will be created.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>min_circle_ratio : float, optional</code> </dt> <dd>
<p class="first last">Border triangles with incircle/circumcircle radii ratio r/R will be removed if r/R &lt; <em>min_circle_ratio</em>. Default value: 0.01</p> </dd> <dt>
<code>rescale : boolean, optional</code> </dt> <dd>
<p class="first last">If True, a rescaling will first be internally performed (based on <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code>scale_factors</code></a> ), so that the (unmasked) triangles fit exactly inside a unit square mesh. This rescaling accounts for the difference of scale which might exist between the 2 axis. Default (and recommended) value is True.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>new_mask : array-like of booleans</code> </dt> <dd>
<p class="first last">Mask to apply to encapsulated triangulation. All the initially masked triangles remain masked in the <em>new_mask</em>.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The rationale behind this function is that a Delaunay triangulation - of an unstructured set of points - sometimes contains almost flat triangles at its border, leading to artifacts in plots (especially for high-resolution contouring). Masked with computed <em>new_mask</em>, the encapsulated triangulation would contain no more unmasked border triangles with a circle ratio below <em>min_circle_ratio</em>, thus improving the mesh quality for subsequent plots or interpolation.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.tri.TriAnalyzer.scale_factors">
<code>scale_factors</code> </dt> <dd>
<p>Factors to rescale the triangulation into a unit square.</p> <p>Returns <em>k</em>, tuple of 2 scale factors.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>k : tuple of 2 floats (kx, ky)</code> </dt> <dd>
<p class="first last">Tuple of floats that would rescale the triangulation : <code>[triangulation.x * kx, triangulation.y * ky]</code> fits exactly inside a unit square.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2012â2018 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/3.1.1/api/tri_api.html" class="_attribution-link">https://matplotlib.org/3.1.1/api/tri_api.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
