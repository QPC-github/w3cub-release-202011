
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Transforms - Matplotlib 3.1 - W3cubDocs</title>
  
  <meta name="description" content="matplotlib includes a framework for arbitrary geometric transformations that is used determine the final position of all elements drawn on the &hellip;">
  <meta name="keywords" content="matplotlib, transforms, matplotlib~3.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/matplotlib~3.1/transformations.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/matplotlib~3.1.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~3.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 3.1</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="matplotlib-transforms">matplotlib.transforms</h1> <div class="graphviz"><img src="data:image/png;base64,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" alt="Inheritance diagram of matplotlib.transforms, matplotlib.path" usemap="#inheritancedbde0cb62f" class="inheritance graphviz"></div> <map id="inheritancedbde0cb62f" name="inheritancedbde0cb62f"> <area shape="rect" id="node1" href="#matplotlib.transforms.Affine2D" target="_top" title="A mutable 2D affine transformation." alt="" coords="531,4,583,20"> <area shape="rect" id="node2" href="#matplotlib.transforms.Affine2DBase" target="_top" title="The base class of all 2D affine transformations." alt="" coords="402,118,475,135"> <area shape="rect" id="node8" href="#matplotlib.transforms.BboxTransform" target="_top" title=":class:`BboxTransform` linearly transforms points from one" alt="" coords="517,36,596,53"> <area shape="rect" id="node9" href="#matplotlib.transforms.BboxTransformFrom" target="_top" title=":class:`BboxTransformFrom` linearly transforms points from a given" alt="" coords="506,69,607,85"> <area shape="rect" id="node10" href="#matplotlib.transforms.BboxTransformTo" target="_top" title=":class:`BboxTransformTo` is a transformation that linearly" alt="" coords="512,101,601,118"> <area shape="rect" id="node12" href="#matplotlib.transforms.BlendedAffine2D" target="_top" title='A "blended" transform uses one transform for the *x*-direction, and' alt="" coords="513,134,600,151"> <area shape="rect" id="node14" href="#matplotlib.transforms.CompositeAffine2D" target="_top" title="A composite transform formed by applying transform *a* then transform *b*." alt="" coords="508,166,606,183"> <area shape="rect" id="node16" href="#matplotlib.transforms.IdentityTransform" target="_top" title="A special class that does one thing, the identity transform, in a" alt="" coords="511,199,602,216"> <area shape="rect" id="node19" href="#matplotlib.transforms.ScaledTranslation" target="_top" title="A transformation that translates by *xt* and *yt*, after *xt* and *yt*" alt="" coords="512,232,602,248"> <area shape="rect" id="node3" href="#matplotlib.transforms.AffineBase" target="_top" title="The base class of all affine transformations of any number of" alt="" coords="271,118,332,135"> <area shape="rect" id="node4" href="#matplotlib.transforms.Transform" target="_top" title="The base class of all :class:`TransformNode` instances that" alt="" coords="130,183,187,200"> <area shape="rect" id="node13" href="#matplotlib.transforms.BlendedGenericTransform" target="_top" title='A "blended" transform uses one transform for the *x*-direction, and' alt="" coords="239,151,365,167"> <area shape="rect" id="node15" href="#matplotlib.transforms.CompositeGenericTransform" target="_top" title="A composite transform formed by applying transform *a* then" alt="" coords="233,183,370,200"> <area shape="rect" id="node20" href="#matplotlib.transforms.TransformWrapper" target="_top" title="A helper class that holds a single child transform and acts" alt="" coords="255,216,348,233"> <area shape="rect" id="node5" href="#matplotlib.transforms.Bbox" target="_top" title="A mutable bounding box." alt="" coords="278,248,325,265"> <area shape="rect" id="node6" href="#matplotlib.transforms.BboxBase" target="_top" title="This is the base class of all bounding boxes, and provides" alt="" coords="130,281,187,298"> <area shape="rect" id="node17" href="#matplotlib.transforms.LockableBbox" target="_top" title="A :class:`Bbox` where some elements may be locked at certain values." alt="" coords="264,281,339,298"> <area shape="rect" id="node21" href="#matplotlib.transforms.TransformedBbox" target="_top" title="A :class:`Bbox` that is automatically transformed by a given" alt="" coords="257,314,347,330"> <area shape="rect" id="node7" href="#matplotlib.transforms.TransformNode" target="_top" title=":class:`TransformNode` is the base class for anything that" alt="" coords="4,281,84,298"> <area shape="rect" id="node23" href="#matplotlib.transforms.TransformedPath" target="_top" title="A :class:`TransformedPath` caches a non-affine transformed copy of" alt="" coords="115,329,202,346"> <area shape="rect" id="node11" href="#matplotlib.transforms.BboxTransformToMaxOnly" target="_top" title=":class:`BboxTransformTo` is a transformation that linearly" alt="" coords="639,101,764,118"> <area shape="rect" id="node18" href="path_api.html#matplotlib.path.Path" target="_top" title=":class:`Path` represents a series of possibly disconnected," alt="" coords="20,248,67,265"> <area shape="rect" id="node22" href="#matplotlib.transforms.TransformedPatchPath" target="_top" title="A :class:`TransformedPatchPath` caches a non-affine transformed copy of" alt="" coords="247,346,357,363"> </map><p id="module-matplotlib.transforms">matplotlib includes a framework for arbitrary geometric transformations that is used determine the final position of all elements drawn on the canvas.</p> <p>Transforms are composed into trees of <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a> objects whose actual value depends on their children. When the contents of children change, their parents are automatically invalidated. The next time an invalidated transform is accessed, it is recomputed to reflect those changes. This invalidation/caching approach prevents unnecessary recomputations of transforms, and contributes to better interactive performance.</p> <p>For example, here is a graph of the transform tree used to plot data to the graph:</p> <img alt="../_images/transforms.png" src="data:image/png;base64,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"> <p>The framework can be used for both affine and non-affine transformations. However, for speed, we want use the backend renderers to perform affine transformations whenever possible. Therefore, it is possible to perform just the affine or non-affine part of a transformation on a set of data. The affine is always assumed to occur after the non-affine. For any transform:</p> <pre data-language="python">full transform == non-affine part + affine part
</pre> <p>The backends are not expected to handle non-affine transformations themselves.</p> <dl class="class"> <dt id="matplotlib.transforms.Affine2D">
<code>class matplotlib.transforms.Affine2D(matrix=None, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A mutable 2D affine transformation.</p> <p>Initialize an Affine transform from a 3x3 numpy float array:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>If <em>matrix</em> is None, initialize with the identity transform.</p> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.clear">
<code>clear(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.clear"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Reset the underlying matrix to the identity transform.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Affine2D.from_values">
<code>static from_values(a, b, c, d, e, f)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.from_values"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>(staticmethod) Create a new Affine2D instance from the given values:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.get_matrix">
<code>get_matrix(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.get_matrix"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the underlying transformation matrix as a 3x3 numpy array:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Affine2D.identity">
<code>static identity()</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.identity"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>(staticmethod) Return a new <a class="reference internal" href="#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code>Affine2D</code></a> object that is the identity transform.</p> <p>Unless this transform will be mutated later on, consider using the faster <a class="reference internal" href="#matplotlib.transforms.IdentityTransform" title="matplotlib.transforms.IdentityTransform"><code>IdentityTransform</code></a> class instead.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.rotate">
<code>rotate(self, theta)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.rotate"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a rotation (in radians) to this transform in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.rotate_around">
<code>rotate_around(self, x, y, theta)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.rotate_around"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a rotation (in radians) around the point (x, y) in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.rotate_deg">
<code>rotate_deg(self, degrees)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.rotate_deg"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a rotation (in degrees) to this transform in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.rotate_deg_around">
<code>rotate_deg_around(self, x, y, degrees)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.rotate_deg_around"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add a rotation (in degrees) around the point (x, y) in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.scale">
<code>scale(self, sx, sy=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.scale"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Adds a scale in place.</p> <p>If <em>sy</em> is None, the same scale is applied in both the <em>x</em>- and <em>y</em>-directions.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.set">
<code>set(self, other)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.set"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set this transformation from the frozen copy of another <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a> object.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.set_matrix">
<code>set_matrix(self, mtx)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.set_matrix"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the underlying transformation matrix from a 3x3 numpy array:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.skew">
<code>skew(self, xShear, yShear)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.skew"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Adds a skew in place.</p> <p><em>xShear</em> and <em>yShear</em> are the shear angles along the <em>x</em>- and <em>y</em>-axes, respectively, in radians.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.skew_deg">
<code>skew_deg(self, xShear, yShear)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.skew_deg"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Adds a skew in place.</p> <p><em>xShear</em> and <em>yShear</em> are the shear angles along the <em>x</em>- and <em>y</em>-axes, respectively, in degrees.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2D.translate">
<code>translate(self, tx, ty)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2D.translate"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Adds a translation in place.</p> <p>Returns <em>self</em>, so this method can easily be chained with more calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code>rotate()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code>rotate_deg()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code>translate()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code>scale()</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.Affine2DBase">
<code>class matplotlib.transforms.Affine2DBase(*args, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2DBase"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.AffineBase" title="matplotlib.transforms.AffineBase"><code>matplotlib.transforms.AffineBase</code></a></p> <p>The base class of all 2D affine transformations.</p> <p>2D affine transformations are performed using a 3x3 numpy array:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> <p>This class provides the read-only interface. For a mutable 2D affine transformation, use <a class="reference internal" href="#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code>Affine2D</code></a>.</p> <p>Subclasses of this class will generally only need to override a constructor and <code>get_matrix()</code> that generates a custom 3x3 matrix.</p> <dl class="method"> <dt id="matplotlib.transforms.Affine2DBase.frozen">
<code>frozen(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2DBase.frozen"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a frozen copy of this transform node. The frozen copy will not update when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Affine2DBase.has_inverse">
<code>has_inverse = True</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Affine2DBase.input_dims">
<code>input_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2DBase.inverted">
<code>inverted(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2DBase.inverted"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Affine2DBase.is_separable">
<code>is_separable</code> </dt> <dd>
<p>bool(x) -&gt; bool</p> <p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Affine2DBase.matrix_from_values">
<code>static matrix_from_values(a, b, c, d, e, f)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2DBase.matrix_from_values"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>(staticmethod) Create a new transformation matrix as a 3x3 numpy array of the form:</p> <pre data-language="python">a c e
b d f
0 0 1
</pre> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Affine2DBase.output_dims">
<code>output_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2DBase.to_values">
<code>to_values(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2DBase.to_values"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the values of the matrix as an <code>(a, b, c, d, e, f)</code> tuple.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2DBase.transform_affine">
<code>transform_affine(self, points)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2DBase.transform_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.input_dims" title="matplotlib.transforms.Affine2DBase.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.output_dims" title="matplotlib.transforms.Affine2DBase.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.input_dims" title="matplotlib.transforms.Affine2DBase.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.output_dims" title="matplotlib.transforms.Affine2DBase.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Affine2DBase.transform_point">
<code>transform_point(self, point)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Affine2DBase.transform_point"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A convenience function that returns the transformed copy of a single point.</p> <p>The point is given as a sequence of length <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.input_dims" title="matplotlib.transforms.Affine2DBase.input_dims"><code>input_dims</code></a>. The transformed point is returned as a sequence of length <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.output_dims" title="matplotlib.transforms.Affine2DBase.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.AffineBase">
<code>class matplotlib.transforms.AffineBase(*args, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#AffineBase"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>The base class of all affine transformations of any number of dimensions.</p> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.get_affine">
<code>get_affine(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#AffineBase.get_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.AffineBase.is_affine">
<code>is_affine = True</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.transform">
<code>transform(self, values)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#AffineBase.transform"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs the transformation on the given array of values.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.transform_affine">
<code>transform_affine(self, values)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#AffineBase.transform_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.transform_non_affine">
<code>transform_non_affine(self, points)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#AffineBase.transform_non_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.transform_path">
<code>transform_path(self, path)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#AffineBase.transform_path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a transformed path.</p> <p><em>path</em>: a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p>In some cases, this transform may insert curves into the path that began as line segments.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.transform_path_affine">
<code>transform_path_affine(self, path)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#AffineBase.transform_path_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a path, transformed only by the affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.AffineBase.transform_path_non_affine">
<code>transform_path_non_affine(self, path)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#AffineBase.transform_path_non_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a path, transformed only by the non-affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.Bbox">
<code>class matplotlib.transforms.Bbox(points, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code>matplotlib.transforms.BboxBase</code></a></p> <p>A mutable bounding box.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>points : ndarray</code> </dt> <dd>
<p class="first last">A 2x2 numpy array of the form <code>[[x0, y0], [x1, y1]]</code>.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If you need to create a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> object from another form of data, consider the static methods <a class="reference internal" href="#matplotlib.transforms.Bbox.unit" title="matplotlib.transforms.Bbox.unit"><code>unit()</code></a>, <a class="reference internal" href="#matplotlib.transforms.Bbox.from_bounds" title="matplotlib.transforms.Bbox.from_bounds"><code>from_bounds()</code></a> and <a class="reference internal" href="#matplotlib.transforms.Bbox.from_extents" title="matplotlib.transforms.Bbox.from_extents"><code>from_extents()</code></a>.</p> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.bounds">
<code>bounds</code> </dt> <dd>
<p>Return (<a class="reference internal" href="#matplotlib.transforms.Bbox.x0" title="matplotlib.transforms.Bbox.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.Bbox.y0" title="matplotlib.transforms.Bbox.y0"><code>y0</code></a>, <code>width</code>, <code>height</code>).</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Bbox.from_bounds">
<code>static from_bounds(x0, y0, width, height)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox.from_bounds"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>(staticmethod) Create a new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> from <em>x0</em>, <em>y0</em>, <em>width</em> and <em>height</em>.</p> <p><em>width</em> and <em>height</em> may be negative.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Bbox.from_extents">
<code>static from_extents(*args)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox.from_extents"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>(staticmethod) Create a new Bbox from <em>left</em>, <em>bottom</em>, <em>right</em> and <em>top</em>.</p> <p>The <em>y</em>-axis increases upwards.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.get_points">
<code>get_points(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox.get_points"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the points of the bounding box directly as a numpy array of the form: <code>[[x0, y0], [x1, y1]]</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.ignore">
<code>ignore(self, value)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox.ignore"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set whether the existing bounds of the box should be ignored by subsequent calls to <a class="reference internal" href="#matplotlib.transforms.Bbox.update_from_data_xy" title="matplotlib.transforms.Bbox.update_from_data_xy"><code>update_from_data_xy()</code></a>.</p> <dl class="docutils"> <dt>
<code>value : bool</code> </dt> <dd>
<ul class="first last simple"> <li>When <code>True</code>, subsequent calls to <a class="reference internal" href="#matplotlib.transforms.Bbox.update_from_data_xy" title="matplotlib.transforms.Bbox.update_from_data_xy"><code>update_from_data_xy()</code></a> will ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>When <code>False</code>, subsequent calls to <a class="reference internal" href="#matplotlib.transforms.Bbox.update_from_data_xy" title="matplotlib.transforms.Bbox.update_from_data_xy"><code>update_from_data_xy()</code></a> will include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.intervalx">
<code>intervalx</code> </dt> <dd>
<p>The pair of <em>x</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be sorted from left to right.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.intervaly">
<code>intervaly</code> </dt> <dd>
<p>The pair of <em>y</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be sorted from bottom to top.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.minpos">
<code>minpos</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.minposx">
<code>minposx</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.minposy">
<code>minposy</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.mutated">
<code>mutated(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox.mutated"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the bbox has changed since init.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.mutatedx">
<code>mutatedx(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox.mutatedx"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the x-limits have changed since init.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.mutatedy">
<code>mutatedy(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox.mutatedy"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the y-limits have changed since init.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Bbox.null">
<code>static null()</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox.null"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>(staticmethod) Create a new null <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> from (inf, inf) to (-inf, -inf).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.p0">
<code>p0</code> </dt> <dd>
<p>The first pair of (<em>x</em>, <em>y</em>) coordinates that define the bounding box.</p> <p>This is not guaranteed to be the bottom-left corner (for that, use <code>min</code>).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.p1">
<code>p1</code> </dt> <dd>
<p>The second pair of (<em>x</em>, <em>y</em>) coordinates that define the bounding box.</p> <p>This is not guaranteed to be the top-right corner (for that, use <code>max</code>).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.set">
<code>set(self, other)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox.set"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set this bounding box from the "frozen" bounds of another <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.set_points">
<code>set_points(self, points)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox.set_points"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the points of the bounding box directly from a numpy array of the form: <code>[[x0, y0], [x1, y1]]</code>. No error checking is performed, as this method is mainly for internal use.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.Bbox.unit">
<code>static unit()</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox.unit"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>(staticmethod) Create a new unit <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> from (0, 0) to (1, 1).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.update_from_data_xy">
<code>update_from_data_xy(self, xy, ignore=None, updatex=True, updatey=True)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox.update_from_data_xy"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Update the bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> based on the passed in data. After updating, the bounds will have positive <em>width</em> and <em>height</em>; <em>x0</em> and <em>y0</em> will be the minimal values.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>xy : ndarray</code> </dt> <dd>
<p class="first last">A numpy array of 2D points.</p> </dd> <dt>
<code>ignore : bool, optional</code> </dt> <dd>
<ul class="first last simple"> <li>When <code>True</code>, ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>When <code>False</code>, include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>When <code>None</code>, use the last value passed to <a class="reference internal" href="#matplotlib.transforms.Bbox.ignore" title="matplotlib.transforms.Bbox.ignore"><code>ignore()</code></a>.</li> </ul> </dd> <dt>
<code>updatex, updatey : bool, optional</code> </dt> <dd>
<p class="first last">When <code>True</code>, update the x/y values.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Bbox.update_from_path">
<code>update_from_path(self, path, ignore=None, updatex=True, updatey=True)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Bbox.update_from_path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Update the bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> based on the passed in data. After updating, the bounds will have positive <em>width</em> and <em>height</em>; <em>x0</em> and <em>y0</em> will be the minimal values.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>path : Path</code> </dt>  <dt>
<code>ignore : bool, optional</code> </dt> <dd>
<ul class="first last simple"> <li>when <code>True</code>, ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>when <code>False</code>, include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</li> <li>when <code>None</code>, use the last value passed to <a class="reference internal" href="#matplotlib.transforms.Bbox.ignore" title="matplotlib.transforms.Bbox.ignore"><code>ignore()</code></a>.</li> </ul> </dd> <dt>
<code>updatex, updatey : bool, optional</code> </dt> <dd>
<p class="first last">When <code>True</code>, update the x/y values.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.x0">
<code>x0</code> </dt> <dd>
<p>The first of the pair of <em>x</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be less than <a class="reference internal" href="#matplotlib.transforms.Bbox.x1" title="matplotlib.transforms.Bbox.x1"><code>x1</code></a> (for that, use <code>xmin</code>).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.x1">
<code>x1</code> </dt> <dd>
<p>The second of the pair of <em>x</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be greater than <a class="reference internal" href="#matplotlib.transforms.Bbox.x0" title="matplotlib.transforms.Bbox.x0"><code>x0</code></a> (for that, use <code>xmax</code>).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.y0">
<code>y0</code> </dt> <dd>
<p>The first of the pair of <em>y</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be less than <a class="reference internal" href="#matplotlib.transforms.Bbox.y1" title="matplotlib.transforms.Bbox.y1"><code>y1</code></a> (for that, use <code>ymin</code>).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Bbox.y1">
<code>y1</code> </dt> <dd>
<p>The second of the pair of <em>y</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be greater than <a class="reference internal" href="#matplotlib.transforms.Bbox.y0" title="matplotlib.transforms.Bbox.y0"><code>y0</code></a> (for that, use <code>ymax</code>).</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BboxBase">
<code>class matplotlib.transforms.BboxBase(shorthand_name=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>matplotlib.transforms.TransformNode</code></a></p> <p>This is the base class of all bounding boxes, and provides read-only access to its data. A mutable bounding box is provided by the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> class.</p> <p>The canonical representation is as two points, with no restrictions on their ordering. Convenience properties are provided to get the left, bottom, right and top edges and width and height, but these are not stored explicitly.</p> <p>Creates a new <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>shorthand_name : str</code> </dt> <dd>
<p class="first last">A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.anchored">
<code>anchored(self, c, container=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.anchored"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>, shifted to position <em>c</em> within a container.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>c : (float, float) or str</code> </dt> <dd>
<p class="first">May be either:</p> <ul class="last simple"> <li>A sequence (<em>cx</em>, <em>cy</em>) where <em>cx</em> and <em>cy</em> range from 0 to 1, where 0 is left or bottom and 1 is right or top</li> <li>a string: - 'C' for centered - 'S' for bottom-center - 'SE' for bottom-left - 'E' for left - etc.</li> </ul> </dd> <dt>
<code>container : Bbox, optional</code> </dt> <dd>
<p class="first last">The box within which the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> is positioned; it defaults to the initial <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.bounds">
<code>bounds</code> </dt> <dd>
<p>Return (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.width" title="matplotlib.transforms.BboxBase.width"><code>width</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.height" title="matplotlib.transforms.BboxBase.height"><code>height</code></a>).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.coefs">
<code>coefs = {'C': (0.5, 0.5), 'E': (1.0, 0.5), 'N': (0.5, 1.0), 'NE': (1.0, 1.0), 'NW': (0, 1.0), 'S': (0.5, 0), 'SE': (1.0, 0), 'SW': (0, 0), 'W': (0, 0.5)}</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.contains">
<code>contains(self, x, y)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.contains"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether <code>(x, y)</code> is in the bounding box or on its edge.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.containsx">
<code>containsx(self, x)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.containsx"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether <em>x</em> is in the closed (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a>) interval.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.containsy">
<code>containsy(self, y)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.containsy"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether <em>y</em> is in the closed (<a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a>) interval.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.corners">
<code>corners(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.corners"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the corners of this rectangle as an array of points.</p> <p>Specifically, this returns the array <code>[[x0, y0], [x0, y1], [x1, y0], [x1, y1]]</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.count_contains">
<code>count_contains(self, vertices)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.count_contains"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Count the number of vertices contained in the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>. Any vertices with a non-finite x or y value are ignored.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>vertices : Nx2 Numpy array.</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.count_overlaps">
<code>count_overlaps(self, bboxes)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.count_overlaps"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Count the number of bounding boxes that overlap this one.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bboxes : sequence of BboxBase objects</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.expanded">
<code>expanded(self, sw, sh)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.expanded"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Construct a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> by expanding this one around its center by the factors <em>sw</em> and <em>sh</em>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.extents">
<code>extents</code> </dt> <dd>
<p>Return (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a>).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.frozen">
<code>frozen(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.frozen"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a> is the base class for anything that participates in the transform tree and needs to invalidate its parents or be invalidated. This includes classes that are not really transforms, such as bounding boxes, since some transforms depend on bounding boxes to compute their values.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.fully_contains">
<code>fully_contains(self, x, y)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.fully_contains"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether <code>x, y</code> is in the bounding box, but not on its edge.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.fully_containsx">
<code>fully_containsx(self, x)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.fully_containsx"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether <em>x</em> is in the open (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a>) interval.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.fully_containsy">
<code>fully_containsy(self, y)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.fully_containsy"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether <em>y</em> is in the open (<a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a>) interval.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.fully_overlaps">
<code>fully_overlaps(self, other)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.fully_overlaps"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether this bounding box overlaps with the other bounding box, not including the edges.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>other : BboxBase</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.get_points">
<code>get_points(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.get_points"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.height">
<code>height</code> </dt> <dd>
<p>The (signed) height of the bounding box.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.BboxBase.intersection">
<code>static intersection(bbox1, bbox2)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.intersection"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the intersection of <em>bbox1</em> and <em>bbox2</em> if they intersect, or None if they don't.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.intervalx">
<code>intervalx</code> </dt> <dd>
<p>The pair of <em>x</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be sorted from left to right.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.intervaly">
<code>intervaly</code> </dt> <dd>
<p>The pair of <em>y</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be sorted from bottom to top.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.inverse_transformed">
<code>inverse_transformed(self, transform)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.inverse_transformed"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Construct a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> by statically transforming this one by the inverse of <em>transform</em>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.is_affine">
<code>is_affine = True</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.is_bbox">
<code>is_bbox = True</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.is_unit">
<code>is_unit(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.is_unit"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether this is the unit box (from (0, 0) to (1, 1)).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.max">
<code>max</code> </dt> <dd>
<p>The top-right corner of the bounding box.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.min">
<code>min</code> </dt> <dd>
<p>The bottom-left corner of the bounding box.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.overlaps">
<code>overlaps(self, other)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.overlaps"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether this bounding box overlaps with the other bounding box.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>other : BboxBase</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.p0">
<code>p0</code> </dt> <dd>
<p>The first pair of (<em>x</em>, <em>y</em>) coordinates that define the bounding box.</p> <p>This is not guaranteed to be the bottom-left corner (for that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.min" title="matplotlib.transforms.BboxBase.min"><code>min</code></a>).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.p1">
<code>p1</code> </dt> <dd>
<p>The second pair of (<em>x</em>, <em>y</em>) coordinates that define the bounding box.</p> <p>This is not guaranteed to be the top-right corner (for that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.max" title="matplotlib.transforms.BboxBase.max"><code>max</code></a>).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.padded">
<code>padded(self, p)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.padded"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Construct a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> by padding this one on all four sides by <em>p</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.rotated">
<code>rotated(self, radians)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.rotated"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a new bounding box that bounds a rotated version of this bounding box by the given radians. The new bounding box is still aligned with the axes, of course.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.shrunk">
<code>shrunk(self, mx, my)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.shrunk"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>, shrunk by the factor <em>mx</em> in the <em>x</em> direction and the factor <em>my</em> in the <em>y</em> direction. The lower left corner of the box remains unchanged. Normally <em>mx</em> and <em>my</em> will be less than 1, but this is not enforced.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.shrunk_to_aspect">
<code>shrunk_to_aspect(self, box_aspect, container=None, fig_aspect=1.0)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.shrunk_to_aspect"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>, shrunk so that it is as large as it can be while having the desired aspect ratio, <em>box_aspect</em>. If the box coordinates are relative---that is, fractions of a larger box such as a figure---then the physical aspect ratio of that figure is specified with <em>fig_aspect</em>, so that <em>box_aspect</em> can also be given as a ratio of the absolute dimensions, not the relative dimensions.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.size">
<code>size</code> </dt> <dd>
<p>The (signed) width and height of the bounding box.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.splitx">
<code>splitx(self, *args)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.splitx"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a list of new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> objects formed by splitting the original one with vertical lines at fractional positions given by <em>args</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.splity">
<code>splity(self, *args)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.splity"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a list of new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> objects formed by splitting the original one with horizontal lines at fractional positions given by <em>args</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.transformed">
<code>transformed(self, transform)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.transformed"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Construct a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> by statically transforming this one by <em>transform</em>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BboxBase.translated">
<code>translated(self, tx, ty)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.translated"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Construct a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> by translating this one by <em>tx</em> and <em>ty</em>.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.transforms.BboxBase.union">
<code>static union(bboxes)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxBase.union"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> that contains all of the given <em>bboxes</em>.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.width">
<code>width</code> </dt> <dd>
<p>The (signed) width of the bounding box.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.x0">
<code>x0</code> </dt> <dd>
<p>The first of the pair of <em>x</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be less than <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code>x1</code></a> (for that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.xmin" title="matplotlib.transforms.BboxBase.xmin"><code>xmin</code></a>).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.x1">
<code>x1</code> </dt> <dd>
<p>The second of the pair of <em>x</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be greater than <a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code>x0</code></a> (for that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.xmax" title="matplotlib.transforms.BboxBase.xmax"><code>xmax</code></a>).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.xmax">
<code>xmax</code> </dt> <dd>
<p>The right edge of the bounding box.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.xmin">
<code>xmin</code> </dt> <dd>
<p>The left edge of the bounding box.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.y0">
<code>y0</code> </dt> <dd>
<p>The first of the pair of <em>y</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be less than <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code>y1</code></a> (for that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.ymin" title="matplotlib.transforms.BboxBase.ymin"><code>ymin</code></a>).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.y1">
<code>y1</code> </dt> <dd>
<p>The second of the pair of <em>y</em> coordinates that define the bounding box.</p> <p>This is not guaranteed to be greater than <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code>y0</code></a> (for that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.ymax" title="matplotlib.transforms.BboxBase.ymax"><code>ymax</code></a>).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.ymax">
<code>ymax</code> </dt> <dd>
<p>The top edge of the bounding box.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxBase.ymin">
<code>ymin</code> </dt> <dd>
<p>The bottom edge of the bounding box.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BboxTransform">
<code>class matplotlib.transforms.BboxTransform(boxin, boxout, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxTransform"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.BboxTransform" title="matplotlib.transforms.BboxTransform"><code>BboxTransform</code></a> linearly transforms points from one <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> to another <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransform" title="matplotlib.transforms.BboxTransform"><code>BboxTransform</code></a> that linearly transforms points from <em>boxin</em> to <em>boxout</em>.</p> <dl class="method"> <dt id="matplotlib.transforms.BboxTransform.get_matrix">
<code>get_matrix(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxTransform.get_matrix"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxTransform.is_separable">
<code>is_separable = True</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BboxTransformFrom">
<code>class matplotlib.transforms.BboxTransformFrom(boxin, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxTransformFrom"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.BboxTransformFrom" title="matplotlib.transforms.BboxTransformFrom"><code>BboxTransformFrom</code></a> linearly transforms points from a given <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> to the unit bounding box.</p> <dl class="method"> <dt id="matplotlib.transforms.BboxTransformFrom.get_matrix">
<code>get_matrix(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxTransformFrom.get_matrix"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxTransformFrom.is_separable">
<code>is_separable = True</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BboxTransformTo">
<code>class matplotlib.transforms.BboxTransformTo(boxout, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxTransformTo"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>BboxTransformTo</code></a> is a transformation that linearly transforms points from the unit bounding box to a given <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>BboxTransformTo</code></a> that linearly transforms points from the unit bounding box to <em>boxout</em>.</p> <dl class="method"> <dt id="matplotlib.transforms.BboxTransformTo.get_matrix">
<code>get_matrix(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxTransformTo.get_matrix"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BboxTransformTo.is_separable">
<code>is_separable = True</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BboxTransformToMaxOnly">
<code>class matplotlib.transforms.BboxTransformToMaxOnly(boxout, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxTransformToMaxOnly"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>matplotlib.transforms.BboxTransformTo</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>BboxTransformTo</code></a> is a transformation that linearly transforms points from the unit bounding box to a given <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> with a fixed upper left of (0, 0).</p> <p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code>BboxTransformTo</code></a> that linearly transforms points from the unit bounding box to <em>boxout</em>.</p> <dl class="method"> <dt id="matplotlib.transforms.BboxTransformToMaxOnly.get_matrix">
<code>get_matrix(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BboxTransformToMaxOnly.get_matrix"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BlendedAffine2D">
<code>class matplotlib.transforms.BlendedAffine2D(x_transform, y_transform, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BlendedAffine2D"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A "blended" transform uses one transform for the <em>x</em>-direction, and another transform for the <em>y</em>-direction.</p> <p>This version is an optimization for the case where both child transforms are of type <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a>.</p> <p>Create a new "blended" transform using <em>x_transform</em> to transform the <em>x</em>-axis and <em>y_transform</em> to transform the <em>y</em>-axis.</p> <p>Both <em>x_transform</em> and <em>y_transform</em> must be 2D affine transforms.</p> <p>You will generally not call this constructor directly but use the <a class="reference internal" href="#matplotlib.transforms.blended_transform_factory" title="matplotlib.transforms.blended_transform_factory"><code>blended_transform_factory()</code></a> function instead, which can determine automatically which kind of blended transform to create.</p> <dl class="method"> <dt id="matplotlib.transforms.BlendedAffine2D.contains_branch_seperately">
<code>contains_branch_seperately(self, transform)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BlendedAffine2D.contains_branch_seperately"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns whether the given branch is a sub-tree of this transform on each separate dimension.</p> <p>A common use for this method is to identify if a transform is a blended transform containing an axes' data transform. e.g.:</p> <pre data-language="python">x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)
</pre> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BlendedAffine2D.get_matrix">
<code>get_matrix(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BlendedAffine2D.get_matrix"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedAffine2D.is_separable">
<code>is_separable = True</code> </dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.BlendedGenericTransform">
<code>class matplotlib.transforms.BlendedGenericTransform(x_transform, y_transform, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BlendedGenericTransform"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>A "blended" transform uses one transform for the <em>x</em>-direction, and another transform for the <em>y</em>-direction.</p> <p>This "generic" version can handle any given child transform in the <em>x</em>- and <em>y</em>-directions.</p> <p>Create a new "blended" transform using <em>x_transform</em> to transform the <em>x</em>-axis and <em>y_transform</em> to transform the <em>y</em>-axis.</p> <p>You will generally not call this constructor directly but use the <a class="reference internal" href="#matplotlib.transforms.blended_transform_factory" title="matplotlib.transforms.blended_transform_factory"><code>blended_transform_factory()</code></a> function instead, which can determine automatically which kind of blended transform to create.</p> <dl class="method"> <dt id="matplotlib.transforms.BlendedGenericTransform.contains_branch">
<code>contains_branch(self, other)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BlendedGenericTransform.contains_branch"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the given transform is a sub-tree of this transform.</p> <p>This routine uses transform equality to identify sub-trees, therefore in many situations it is object id which will be used.</p> <p>For the case where the given transform represents the whole of this transform, returns True.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BlendedGenericTransform.contains_branch_seperately">
<code>contains_branch_seperately(self, transform)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BlendedGenericTransform.contains_branch_seperately"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns whether the given branch is a sub-tree of this transform on each separate dimension.</p> <p>A common use for this method is to identify if a transform is a blended transform containing an axes' data transform. e.g.:</p> <pre data-language="python">x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)
</pre> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.depth">
<code>depth</code> </dt> <dd>
<p>Returns the number of transforms which have been chained together to form this Transform instance.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">For the special case of a Composite transform, the maximum depth of the two is returned.</p> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BlendedGenericTransform.frozen">
<code>frozen(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BlendedGenericTransform.frozen"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a frozen copy of this transform node. The frozen copy will not update when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.BlendedGenericTransform.get_affine">
<code>get_affine(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BlendedGenericTransform.get_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.has_inverse">
<code>has_inverse</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.input_dims">
<code>input_dims = 2</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.BlendedGenericTransform.inverted">
<code>inverted(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BlendedGenericTransform.inverted"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.is_affine">
<code>is_affine</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.is_separable">
<code>is_separable = True</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.output_dims">
<code>output_dims = 2</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.BlendedGenericTransform.pass_through">
<code>pass_through = True</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.BlendedGenericTransform.transform_non_affine">
<code>transform_non_affine(self, points)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#BlendedGenericTransform.transform_non_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.input_dims" title="matplotlib.transforms.BlendedGenericTransform.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.output_dims" title="matplotlib.transforms.BlendedGenericTransform.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.input_dims" title="matplotlib.transforms.BlendedGenericTransform.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.output_dims" title="matplotlib.transforms.BlendedGenericTransform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.CompositeAffine2D">
<code>class matplotlib.transforms.CompositeAffine2D(a, b, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#CompositeAffine2D"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A composite transform formed by applying transform <em>a</em> then transform <em>b</em>.</p> <p>This version is an optimization that handles the case where both <em>a</em> and <em>b</em> are 2D affines.</p> <p>Create a new composite transform that is the result of applying transform <em>a</em> then transform <em>b</em>.</p> <p>Both <em>a</em> and <em>b</em> must be instances of <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>Affine2DBase</code></a>.</p> <p>You will generally not call this constructor directly but use the <a class="reference internal" href="#matplotlib.transforms.composite_transform_factory" title="matplotlib.transforms.composite_transform_factory"><code>composite_transform_factory()</code></a> function instead, which can automatically choose the best kind of composite transform instance to create.</p> <dl class="attribute"> <dt id="matplotlib.transforms.CompositeAffine2D.depth">
<code>depth</code> </dt> <dd>
<p>Returns the number of transforms which have been chained together to form this Transform instance.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">For the special case of a Composite transform, the maximum depth of the two is returned.</p> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeAffine2D.get_matrix">
<code>get_matrix(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#CompositeAffine2D.get_matrix"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.CompositeGenericTransform">
<code>class matplotlib.transforms.CompositeGenericTransform(a, b, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#CompositeGenericTransform"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>A composite transform formed by applying transform <em>a</em> then transform <em>b</em>.</p> <p>This "generic" version can handle any two arbitrary transformations.</p> <p>Create a new composite transform that is the result of applying transform <em>a</em> then transform <em>b</em>.</p> <p>You will generally not call this constructor directly but use the <a class="reference internal" href="#matplotlib.transforms.composite_transform_factory" title="matplotlib.transforms.composite_transform_factory"><code>composite_transform_factory()</code></a> function instead, which can automatically choose the best kind of composite transform instance to create.</p> <dl class="attribute"> <dt id="matplotlib.transforms.CompositeGenericTransform.depth">
<code>depth</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeGenericTransform.frozen">
<code>frozen(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#CompositeGenericTransform.frozen"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a frozen copy of this transform node. The frozen copy will not update when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeGenericTransform.get_affine">
<code>get_affine(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#CompositeGenericTransform.get_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.CompositeGenericTransform.has_inverse">
<code>has_inverse</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeGenericTransform.inverted">
<code>inverted(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#CompositeGenericTransform.inverted"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.CompositeGenericTransform.is_affine">
<code>is_affine</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.CompositeGenericTransform.is_separable">
<code>is_separable</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.CompositeGenericTransform.pass_through">
<code>pass_through = True</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeGenericTransform.transform_affine">
<code>transform_affine(self, points)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#CompositeGenericTransform.transform_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeGenericTransform.transform_non_affine">
<code>transform_non_affine(self, points)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#CompositeGenericTransform.transform_non_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.CompositeGenericTransform.transform_path_non_affine">
<code>transform_path_non_affine(self, path)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#CompositeGenericTransform.transform_path_non_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a path, transformed only by the non-affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.IdentityTransform">
<code>class matplotlib.transforms.IdentityTransform(*args, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#IdentityTransform"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A special class that does one thing, the identity transform, in a fast way.</p> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.frozen">
<code>frozen(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#IdentityTransform.frozen"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a frozen copy of this transform node. The frozen copy will not update when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.get_affine">
<code>get_affine(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#IdentityTransform.get_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.get_matrix">
<code>get_matrix(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#IdentityTransform.get_matrix"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.inverted">
<code>inverted(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#IdentityTransform.inverted"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.transform">
<code>transform(self, points)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#IdentityTransform.transform"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs the transformation on the given array of values.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.transform_affine">
<code>transform_affine(self, points)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#IdentityTransform.transform_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.transform_non_affine">
<code>transform_non_affine(self, points)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#IdentityTransform.transform_non_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <code>input_dims</code>) and returns a numpy array of shape (N x <code>output_dims</code>).</p> <p>Alternatively, accepts a numpy array of length <code>input_dims</code> and returns a numpy array of length <code>output_dims</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.transform_path">
<code>transform_path(self, path)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#IdentityTransform.transform_path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a transformed path.</p> <p><em>path</em>: a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p>In some cases, this transform may insert curves into the path that began as line segments.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.transform_path_affine">
<code>transform_path_affine(self, path)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#IdentityTransform.transform_path_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a path, transformed only by the affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.IdentityTransform.transform_path_non_affine">
<code>transform_path_non_affine(self, path)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#IdentityTransform.transform_path_non_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a path, transformed only by the non-affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.LockableBbox">
<code>class matplotlib.transforms.LockableBbox(bbox, x0=None, y0=None, x1=None, y1=None, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#LockableBbox"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code>matplotlib.transforms.BboxBase</code></a></p> <p>A <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> where some elements may be locked at certain values.</p> <p>When the child bounding box changes, the bounds of this bbox will update accordingly with the exception of the locked elements.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : Bbox</code> </dt> <dd>
<p class="first last">The child bounding box to wrap.</p> </dd> <dt>
<code>x0 : float or None</code> </dt> <dd>
<p class="first last">The locked value for x0, or None to leave unlocked.</p> </dd> <dt>
<code>y0 : float or None</code> </dt> <dd>
<p class="first last">The locked value for y0, or None to leave unlocked.</p> </dd> <dt>
<code>x1 : float or None</code> </dt> <dd>
<p class="first last">The locked value for x1, or None to leave unlocked.</p> </dd> <dt>
<code>y1 : float or None</code> </dt> <dd>
<p class="first last">The locked value for y1, or None to leave unlocked.</p> </dd> </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.transforms.LockableBbox.get_points">
<code>get_points(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#LockableBbox.get_points"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.LockableBbox.locked_x0">
<code>locked_x0</code> </dt> <dd>
<p>float or None: The value used for the locked x0.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.LockableBbox.locked_x1">
<code>locked_x1</code> </dt> <dd>
<p>float or None: The value used for the locked x1.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.LockableBbox.locked_y0">
<code>locked_y0</code> </dt> <dd>
<p>float or None: The value used for the locked y0.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.LockableBbox.locked_y1">
<code>locked_y1</code> </dt> <dd>
<p>float or None: The value used for the locked y1.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.ScaledTranslation">
<code>class matplotlib.transforms.ScaledTranslation(xt, yt, scale_trans, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#ScaledTranslation"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code>matplotlib.transforms.Affine2DBase</code></a></p> <p>A transformation that translates by <em>xt</em> and <em>yt</em>, after <em>xt</em> and <em>yt</em> have been transformed by <em>scale_trans</em>.</p> <dl class="method"> <dt id="matplotlib.transforms.ScaledTranslation.get_matrix">
<code>get_matrix(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#ScaledTranslation.get_matrix"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.Transform">
<code>class matplotlib.transforms.Transform(shorthand_name=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>matplotlib.transforms.TransformNode</code></a></p> <p>The base class of all <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a> instances that actually perform a transformation.</p> <p>All non-affine transformations should be subclasses of this class. New affine transformations should be subclasses of <a class="reference internal" href="#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code>Affine2D</code></a>.</p> <p>Subclasses of this class should override the following members (at minimum):</p>  <ul class="simple"> <li><a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a></li> <li><a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a></li> <li><a class="reference internal" href="#matplotlib.transforms.Transform.transform" title="matplotlib.transforms.Transform.transform"><code>transform()</code></a></li> <li><a class="reference internal" href="#matplotlib.transforms.Transform.is_separable" title="matplotlib.transforms.Transform.is_separable"><code>is_separable</code></a></li> <li><a class="reference internal" href="#matplotlib.transforms.Transform.has_inverse" title="matplotlib.transforms.Transform.has_inverse"><code>has_inverse</code></a></li> <li>
<a class="reference internal" href="#matplotlib.transforms.Transform.inverted" title="matplotlib.transforms.Transform.inverted"><code>inverted()</code></a> (if <a class="reference internal" href="#matplotlib.transforms.Transform.has_inverse" title="matplotlib.transforms.Transform.has_inverse"><code>has_inverse</code></a> is True)</li> </ul>  <p>If the transform needs to do something non-standard with <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>matplotlib.path.Path</code></a> objects, such as adding curves where there were once line segments, it should override:</p>  <ul class="simple"> <li><a class="reference internal" href="#matplotlib.transforms.Transform.transform_path" title="matplotlib.transforms.Transform.transform_path"><code>transform_path()</code></a></li> </ul>  <p>Creates a new <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>shorthand_name : str</code> </dt> <dd>
<p class="first last">A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.transforms.Transform.contains_branch">
<code>contains_branch(self, other)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.contains_branch"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return whether the given transform is a sub-tree of this transform.</p> <p>This routine uses transform equality to identify sub-trees, therefore in many situations it is object id which will be used.</p> <p>For the case where the given transform represents the whole of this transform, returns True.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.contains_branch_seperately">
<code>contains_branch_seperately(self, other_transform)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.contains_branch_seperately"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns whether the given branch is a sub-tree of this transform on each separate dimension.</p> <p>A common use for this method is to identify if a transform is a blended transform containing an axes' data transform. e.g.:</p> <pre data-language="python">x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)
</pre> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Transform.depth">
<code>depth</code> </dt> <dd>
<p>Returns the number of transforms which have been chained together to form this Transform instance.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">For the special case of a Composite transform, the maximum depth of the two is returned.</p> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.get_affine">
<code>get_affine(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.get_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the affine part of this transform.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.get_matrix">
<code>get_matrix(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.get_matrix"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the Affine transformation array for the affine part of this transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Transform.has_inverse">
<code>has_inverse = False</code> </dt> <dd>
<p>True if this transform has a corresponding inverse transform.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Transform.input_dims">
<code>input_dims = None</code> </dt> <dd>
<p>The number of input dimensions of this transform. Must be overridden (with integers) in the subclass.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.inverted">
<code>inverted(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.inverted"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the corresponding inverse transformation.</p> <p>The return value of this method should be treated as temporary. An update to <em>self</em> does not cause a corresponding update to its inverted copy.</p> <p><code>x === self.inverted().transform(self.transform(x))</code></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Transform.is_separable">
<code>is_separable = False</code> </dt> <dd>
<p>True if this transform is separable in the x- and y- dimensions.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.Transform.output_dims">
<code>output_dims = None</code> </dt> <dd>
<p>The number of output dimensions of this transform. Must be overridden (with integers) in the subclass.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform">
<code>transform(self, values)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.transform"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs the transformation on the given array of values.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_affine">
<code>transform_affine(self, values)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.transform_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs only the affine part of this transformation on the given array of values.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally a no-op. In affine transformations, this is equivalent to <code>transform(values)</code>.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_angles">
<code>transform_angles(self, angles, pts, radians=False, pushoff=1e-05)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.transform_angles"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transforms a set of angles anchored at specific locations.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>angles : (N,) array-like</code> </dt> <dd>
<p class="first last">The angles to transform.</p> </dd> <dt>
<code>pts : (N, 2) array-like</code> </dt> <dd>
<p class="first last">The points where the angles are anchored.</p> </dd> <dt>
<code>radians : bool, default: False</code> </dt> <dd>
<p class="first last">Whether <em>angles</em> are radians or degrees.</p> </dd> <dt>
<code>pushoff : float</code> </dt> <dd>
<p class="first last">For each point in <em>pts</em> and angle in <em>angles</em>, the transformed angle is computed by transforming a segment of length <em>pushoff</em> starting at that point and making that angle relative to the horizontal axis, and measuring the angle between the horizontal axis and the transformed segment.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>transformed_angles : (N,) array</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_bbox">
<code>transform_bbox(self, bbox)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.transform_bbox"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transform the given bounding box.</p> <p>Note, for smarter transforms including caching (a common requirement for matplotlib figures), see <a class="reference internal" href="#matplotlib.transforms.TransformedBbox" title="matplotlib.transforms.TransformedBbox"><code>TransformedBbox</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_non_affine">
<code>transform_non_affine(self, values)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.transform_non_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Performs only the non-affine part of the transformation.</p> <p><code>transform(values)</code> is always equivalent to <code>transform_affine(transform_non_affine(values))</code>.</p> <p>In non-affine transformations, this is generally equivalent to <code>transform(values)</code>. In affine transformations, this is always a no-op.</p> <p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a>) and returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>).</p> <p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a> and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_path">
<code>transform_path(self, path)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.transform_path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a transformed path.</p> <p><em>path</em>: a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p>In some cases, this transform may insert curves into the path that began as line segments.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_path_affine">
<code>transform_path_affine(self, path)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.transform_path_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a path, transformed only by the affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_path_non_affine">
<code>transform_path_non_affine(self, path)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.transform_path_non_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a path, transformed only by the non-affine part of this transform.</p> <p><em>path</em>: a <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance.</p> <p><code>transform_path(path)</code> is equivalent to <code>transform_path_affine(transform_path_non_affine(values))</code>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.Transform.transform_point">
<code>transform_point(self, point)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#Transform.transform_point"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A convenience function that returns the transformed copy of a single point.</p> <p>The point is given as a sequence of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code>input_dims</code></a>. The transformed point is returned as a sequence of length <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code>output_dims</code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.TransformNode">
<code>class matplotlib.transforms.TransformNode(shorthand_name=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformNode"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <p><a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a> is the base class for anything that participates in the transform tree and needs to invalidate its parents or be invalidated. This includes classes that are not really transforms, such as bounding boxes, since some transforms depend on bounding boxes to compute their values.</p> <p>Creates a new <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>shorthand_name : str</code> </dt> <dd>
<p class="first last">A string representing the "name" of the transform. The name carries no significance other than to improve the readability of <code>str(transform)</code> when DEBUG=True.</p> </dd> </dl> </td> </tr>  </table> <dl class="attribute"> <dt id="matplotlib.transforms.TransformNode.INVALID">
<code>INVALID = 3</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformNode.INVALID_AFFINE">
<code>INVALID_AFFINE = 2</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformNode.INVALID_NON_AFFINE">
<code>INVALID_NON_AFFINE = 1</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformNode.frozen">
<code>frozen(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformNode.frozen"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a frozen copy of this transform node. The frozen copy will not update when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformNode.invalidate">
<code>invalidate(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformNode.invalidate"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Invalidate this <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>TransformNode</code></a> and triggers an invalidation of its ancestors. Should be called any time the transform changes.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformNode.is_affine">
<code>is_affine = False</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformNode.is_bbox">
<code>is_bbox = False</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformNode.pass_through">
<code>pass_through = False</code> </dt> <dd>
<p>If pass_through is True, all ancestors will always be invalidated, even if 'self' is already invalid.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformNode.set_children">
<code>set_children(self, *children)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformNode.set_children"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the children of the transform, to let the invalidation system know which transforms can invalidate this transform. Should be called from the constructor of any transforms that depend on other transforms.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.TransformWrapper">
<code>class matplotlib.transforms.TransformWrapper(child)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformWrapper"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>matplotlib.transforms.Transform</code></a></p> <p>A helper class that holds a single child transform and acts equivalently to it.</p> <p>This is useful if a node of the transform tree must be replaced at run time with a transform of a different type. This class allows that replacement to correctly trigger invalidation.</p> <p>Note that <a class="reference internal" href="#matplotlib.transforms.TransformWrapper" title="matplotlib.transforms.TransformWrapper"><code>TransformWrapper</code></a> instances must have the same input and output dimensions during their entire lifetime, so the child transform may only be replaced with another child transform of the same dimensions.</p> <p><em>child</em>: A class:<a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> instance. This child may later be replaced with <a class="reference internal" href="#matplotlib.transforms.TransformWrapper.set" title="matplotlib.transforms.TransformWrapper.set"><code>set()</code></a>.</p> <dl class="method"> <dt id="matplotlib.transforms.TransformWrapper.frozen">
<code>frozen(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformWrapper.frozen"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a frozen copy of this transform node. The frozen copy will not update when its children change. Useful for storing a previously known state of a transform where <code>copy.deepcopy()</code> might normally be used.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformWrapper.has_inverse">
<code>has_inverse</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformWrapper.is_affine">
<code>is_affine</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformWrapper.is_separable">
<code>is_separable</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.transforms.TransformWrapper.pass_through">
<code>pass_through = True</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformWrapper.set">
<code>set(self, child)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformWrapper.set"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Replace the current child of this transform with another one.</p> <p>The new child must have the same number of input and output dimensions as the current child.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.TransformedBbox">
<code>class matplotlib.transforms.TransformedBbox(bbox, transform, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformedBbox"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code>matplotlib.transforms.BboxBase</code></a></p> <p>A <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a> that is automatically transformed by a given transform. When either the child bounding box or transform changes, the bounds of this bbox will update accordingly.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>bbox : Bbox</code> </dt>  <dt>
<code>transform : Transform</code> </dt>  </dl> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.transforms.TransformedBbox.get_points">
<code>get_points(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformedBbox.get_points"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.TransformedPatchPath">
<code>class matplotlib.transforms.TransformedPatchPath(patch)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformedPatchPath"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code>matplotlib.transforms.TransformedPath</code></a></p> <p>A <a class="reference internal" href="#matplotlib.transforms.TransformedPatchPath" title="matplotlib.transforms.TransformedPatchPath"><code>TransformedPatchPath</code></a> caches a non-affine transformed copy of the <code>Patch</code>. This cached copy is automatically updated when the non-affine part of the transform or the patch changes.</p> <p>Create a new <a class="reference internal" href="#matplotlib.transforms.TransformedPatchPath" title="matplotlib.transforms.TransformedPatchPath"><code>TransformedPatchPath</code></a> from the given <code>Patch</code>.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.transforms.TransformedPath">
<code>class matplotlib.transforms.TransformedPath(path, transform)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformedPath"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code>matplotlib.transforms.TransformNode</code></a></p> <p>A <a class="reference internal" href="#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code>TransformedPath</code></a> caches a non-affine transformed copy of the <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>. This cached copy is automatically updated when the non-affine part of the transform changes.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Paths are considered immutable by this class. Any update to the path's vertices/codes will not trigger a transform recomputation.</p> </div> <p>Create a new <a class="reference internal" href="#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code>TransformedPath</code></a> from the given <a class="reference internal" href="path_api#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> and <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>.</p> <dl class="method"> <dt id="matplotlib.transforms.TransformedPath.get_affine">
<code>get_affine(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformedPath.get_affine"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformedPath.get_fully_transformed_path">
<code>get_fully_transformed_path(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformedPath.get_fully_transformed_path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a fully-transformed copy of the child path.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformedPath.get_transformed_path_and_affine">
<code>get_transformed_path_and_affine(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformedPath.get_transformed_path_and_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a copy of the child path, with the non-affine part of the transform already applied, along with the affine part of the path necessary to complete the transformation.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.transforms.TransformedPath.get_transformed_points_and_affine">
<code>get_transformed_points_and_affine(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#TransformedPath.get_transformed_points_and_affine"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a copy of the child path, with the non-affine part of the transform already applied, along with the affine part of the path necessary to complete the transformation. Unlike <a class="reference internal" href="#matplotlib.transforms.TransformedPath.get_transformed_path_and_affine" title="matplotlib.transforms.TransformedPath.get_transformed_path_and_affine"><code>get_transformed_path_and_affine()</code></a>, no interpolation will be performed.</p> </dd>
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.transforms.blended_transform_factory">
<code>matplotlib.transforms.blended_transform_factory(x_transform, y_transform)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#blended_transform_factory"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new "blended" transform using <em>x_transform</em> to transform the <em>x</em>-axis and <em>y_transform</em> to transform the <em>y</em>-axis.</p> <p>A faster version of the blended transform is returned for the case where both child transforms are affine.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.transforms.composite_transform_factory">
<code>matplotlib.transforms.composite_transform_factory(a, b)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#composite_transform_factory"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a new composite transform that is the result of applying transform a then transform b.</p> <p>Shortcut versions of the blended transform are provided for the case where both child transforms are affine, or one or the other is the identity transform.</p> <p>Composite transforms may also be created using the '+' operator, e.g.:</p> <pre data-language="python">c = a + b
</pre> </dd>
</dl> <dl class="function"> <dt id="matplotlib.transforms.interval_contains">
<code>matplotlib.transforms.interval_contains(interval, val)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#interval_contains"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Check, inclusively, whether an interval includes a given value.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>interval : sequence of scalar</code> </dt> <dd>
<p class="first last">A 2-length sequence, endpoints that define the interval.</p> </dd> <dt>
<code>val : scalar</code> </dt> <dd>
<p class="first last">Value to check is within interval.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>bool</dt> <dd>
<p class="first last">Returns <em>True</em> if given <em>val</em> is within the <em>interval</em>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.transforms.interval_contains_open">
<code>matplotlib.transforms.interval_contains_open(interval, val)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#interval_contains_open"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Check, excluding endpoints, whether an interval includes a given value.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>interval : sequence of scalar</code> </dt> <dd>
<p class="first last">A 2-length sequence, endpoints that define the interval.</p> </dd> <dt>
<code>val : scalar</code> </dt> <dd>
<p class="first last">Value to check is within interval.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>bool</dt> <dd>
<p class="first last">Returns true if given val is within the interval.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.transforms.nonsingular">
<code>matplotlib.transforms.nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#nonsingular"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Modify the endpoints of a range as needed to avoid singularities.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>vmin, vmax : float</code> </dt> <dd>
<p class="first last">The initial endpoints.</p> </dd> <dt>
<code>expander : float, optional, default: 0.001</code> </dt> <dd>
<p class="first last">Fractional amount by which <em>vmin</em> and <em>vmax</em> are expanded if the original interval is too small, based on <em>tiny</em>.</p> </dd> <dt>
<code>tiny : float, optional, default: 1e-15</code> </dt> <dd>
<p class="first last">Threshold for the ratio of the interval to the maximum absolute value of its endpoints. If the interval is smaller than this, it will be expanded. This value should be around 1e-15 or larger; otherwise the interval will be approaching the double precision resolution limit.</p> </dd> <dt>
<code>increasing : bool, optional, default: True</code> </dt> <dd>
<p class="first last">If True, swap <em>vmin</em>, <em>vmax</em> if <em>vmin</em> &gt; <em>vmax</em>.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>vmin, vmax : float</code> </dt> <dd>
<p class="first last">Endpoints, expanded and/or swapped if necessary. If either input is inf or NaN, or if both inputs are 0 or very close to zero, it returns -<em>expander</em>, <em>expander</em>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.transforms.offset_copy">
<code>matplotlib.transforms.offset_copy(trans, fig=None, x=0.0, y=0.0, units='inches')</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/transforms.html#offset_copy"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a new transform with an added offset.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>trans : Transform instance</code> </dt> <dd>
<p class="first last">Any transform, to which offset will be applied.</p> </dd> <dt>
<code>fig : Figure, optional, default: None</code> </dt> <dd>
<p class="first last">Current figure. It can be None if <em>units</em> are 'dots'.</p> </dd> <dt>
<code>x, y : float, optional, default: 0.0</code> </dt> <dd>
<p class="first last">Specifies the offset to apply.</p> </dd> <dt>
<code>units : {'inches', 'points', 'dots'}, optional</code> </dt> <dd>
<p class="first last">Units of the offset.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>trans : Transform instance</code> </dt> <dd>
<p class="first last">Transform with applied offset.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2018 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/3.1.1/api/transformations.html" class="_attribution-link">https://matplotlib.org/3.1.1/api/transformations.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
