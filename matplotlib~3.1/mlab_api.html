
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Mlab - Matplotlib 3.1 - W3cubDocs</title>
  
  <meta name="description" content="Numerical python functions written for compatibility with MATLAB commands with the same names. Most numerical python functions can be found in the &hellip;">
  <meta name="keywords" content="matplotlib, mlab, matplotlib~3.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/matplotlib~3.1/mlab_api.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/matplotlib~3.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~3.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 3.1</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="matplotlib-mlab">matplotlib.mlab</h1> <p id="module-matplotlib.mlab">Numerical python functions written for compatibility with MATLAB commands with the same names. Most numerical python functions can be found in the <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/index.html#module-numpy" title="(in NumPy v1.16)"><code>numpy</code></a> and <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/index.html#module-scipy" title="(in SciPy v1.3.0)"><code>scipy</code></a> libraries. What remains here is code for performing spectral computations.</p>  <h2 id="spectral-functions">Spectral functions</h2> <dl class="docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><code>cohere</code></a>
</dt> <dd>Coherence (normalized cross spectral density)</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code>csd</code></a>
</dt> <dd>Cross spectral density using Welch's average periodogram</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend</code></a>
</dt> <dd>Remove the mean or best fit line from an array</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd</code></a>
</dt> <dd>Power spectral density using Welch's average periodogram</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a>
</dt> <dd>Spectrogram (spectrum over segments of time)</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>
</dt> <dd>Return the complex-valued frequency spectrum of a signal</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a>
</dt> <dd>Return the magnitude of the frequency spectrum of a signal</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum</code></a>
</dt> <dd>Return the angle (wrapped phase) of the frequency spectrum of a signal</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum</code></a>
</dt> <dd>Return the phase (unwrapped angle) of the frequency spectrum of a signal</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>
</dt> <dd>Remove the mean from a line.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>
</dt> <dd>Remove the best fit line from a line.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>
</dt> <dd>Return the original line.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.stride_windows" title="matplotlib.mlab.stride_windows"><code>stride_windows</code></a>
</dt> <dd>Get all windows in an array in a memory-efficient manner</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.stride_repeat" title="matplotlib.mlab.stride_repeat"><code>stride_repeat</code></a>
</dt> <dd>Repeat an array in a memory-efficient manner</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.apply_window" title="matplotlib.mlab.apply_window"><code>apply_window</code></a>
</dt> <dd>Apply a window along a given axis</dd> </dl> <dl class="class"> <dt id="matplotlib.mlab.GaussianKDE">
<code>class matplotlib.mlab.GaussianKDE(dataset, bw_method=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#GaussianKDE"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <p>Representation of a kernel-density estimate using Gaussian kernels.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>dataset : array_like</code> </dt> <dd>
<p class="first last">Datapoints to estimate from. In case of univariate data this is a 1-D array, otherwise a 2-D array with shape (# of dims, # of data).</p> </dd> <dt>
<code>bw_method : str, scalar or callable, optional</code> </dt> <dd>
<p class="first last">The method used to calculate the estimator bandwidth. This can be 'scott', 'silverman', a scalar constant or a callable. If a scalar, this will be used directly as <code>kde.factor</code>. If a callable, it should take a <a class="reference internal" href="#matplotlib.mlab.GaussianKDE" title="matplotlib.mlab.GaussianKDE"><code>GaussianKDE</code></a> instance as only parameter and return a scalar. If None (default), 'scott' is used.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Attributes:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>dataset : ndarray</code> </dt> <dd>
<p class="first last">The dataset with which <code>gaussian_kde</code> was initialized.</p> </dd> <dt>
<code>dim : int</code> </dt> <dd>
<p class="first last">Number of dimensions.</p> </dd> <dt>
<code>num_dp : int</code> </dt> <dd>
<p class="first last">Number of datapoints.</p> </dd> <dt>
<code>factor : float</code> </dt> <dd>
<p class="first last">The bandwidth factor, obtained from <code>kde.covariance_factor</code>, with which the covariance matrix is multiplied.</p> </dd> <dt>
<code>covariance : ndarray</code> </dt> <dd>
<p class="first last">The covariance matrix of <code>dataset</code>, scaled by the calculated bandwidth (<code>kde.factor</code>).</p> </dd> <dt>
<code>inv_cov : ndarray</code> </dt> <dd>
<p class="first last">The inverse of <code>covariance</code>.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Methods</h4> <table class="docutils">   <tr>
<td><strong>kde.evaluate(points)</strong></td> <td>(ndarray) Evaluate the estimated pdf on a provided set of points.</td> </tr> <tr>
<td><strong>kde(points)</strong></td> <td>(ndarray) Same as kde.evaluate(points)</td> </tr>  </table> <dl class="method"> <dt id="matplotlib.mlab.GaussianKDE.covariance_factor">
<code>covariance_factor(self)</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.mlab.GaussianKDE.evaluate">
<code>evaluate(self, points)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#GaussianKDE.evaluate"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Evaluate the estimated pdf on a set of points.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>points : (# of dimensions, # of points)-array</code> </dt> <dd>
<p class="first last">Alternatively, a (# of dimensions,) vector can be passed in and treated as a single point.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>values : (# of points,)-array</code> </dt> <dd>
<p class="first last">The values at each point.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Raises:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>ValueError : if the dimensionality of the input points is different</code> </dt> <dd>
<p class="first last">than the dimensionality of the KDE.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="matplotlib.mlab.GaussianKDE.scotts_factor">
<code>scotts_factor(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#GaussianKDE.scotts_factor"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.mlab.GaussianKDE.silverman_factor">
<code>silverman_factor(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#GaussianKDE.silverman_factor"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.angle_spectrum">
<code>matplotlib.mlab.angle_spectrum(x, Fs=None, window=None, pad_to=None, sides=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#angle_spectrum"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the angle of the frequency spectrum (wrapped phase spectrum) of <em>x</em>. Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is applied to the signal.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>x : 1-D array or sequence</code> </dt> <dd>
<p class="first last">Array or sequence containing the data</p> </dd> <dt>
<code>Fs : scalar</code> </dt> <dd>
<p class="first last">The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p> </dd> <dt>
<code>window : callable or ndarray</code> </dt> <dd>
<p class="first last">A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.3.0)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.3.0)"><code>scipy.signal.get_window</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<code>sides : {'default', 'onesided', 'twosided'}</code> </dt> <dd>
<p class="first last">Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<code>pad_to : int</code> </dt> <dd>
<p class="first last">The number of points to which the data segment is padded when performing the FFT. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to the length of the input signal (i.e. no padding).</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>spectrum : 1-D array</code> </dt> <dd>
<p class="first last">The values for the angle spectrum in radians (real valued)</p> </dd> <dt>
<code>freqs : 1-D array</code> </dt> <dd>
<p class="first last">The frequencies corresponding to the elements in <em>spectrum</em></p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>
</dt> <dd>This function returns the angle value of <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a>
</dt> <dd>Returns the magnitudes of the corresponding frequencies.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum</code></a>
</dt> <dd>Returns the phase (unwrapped angle) of the corresponding frequencies.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a>
</dt> <dd>Can return the complex spectrum of segments within the signal.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.apply_window">
<code>matplotlib.mlab.apply_window(x, window, axis=0, return_window=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#apply_window"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the given window to the given 1D or 2D array along the given axis.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>x : 1D or 2D array or sequence</code> </dt> <dd>
<p class="first last">Array or sequence containing the data.</p> </dd> <dt>
<code>window : function or array.</code> </dt> <dd>
<p class="first last">Either a function to generate a window or an array with length <em>x</em>.shape[<em>axis</em>]</p> </dd> <dt>
<code>axis : integer</code> </dt> <dd>
<p class="first last">The axis over which to do the repetition. Must be 0 or 1. The default is 0</p> </dd> <dt>
<code>return_window : bool</code> </dt> <dd>
<p class="first last">If true, also return the 1D values of the window that was applied</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.cohere">
<code>matplotlib.mlab.cohere(x, y, NFFT=256, Fs=2, detrend=&lt;function detrend_none at 0x7f8092177c80&gt;, window=&lt;function window_hanning at 0x7f8092177510&gt;, noverlap=0, pad_to=None, sides='default', scale_by_freq=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#cohere"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>The coherence between <em>x</em> and <em>y</em>. Coherence is the normalized cross spectral density:</p> <div class="math notranslate nohighlight"> \[C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}\]</div> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt><strong>x, y</strong></dt> <dd>
<p class="first last">Array or sequence containing the data</p> </dd> <dt>
<code>Fs : scalar</code> </dt> <dd>
<p class="first last">The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p> </dd> <dt>
<code>window : callable or ndarray</code> </dt> <dd>
<p class="first last">A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.3.0)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.3.0)"><code>scipy.signal.get_window</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<code>sides : {'default', 'onesided', 'twosided'}</code> </dt> <dd>
<p class="first last">Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<code>pad_to : int</code> </dt> <dd>
<p class="first last">The number of points to which the data segment is padded when performing the FFT. This can be different from <em>NFFT</em>, which specifies the number of data points used. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to <em>NFFT</em></p> </dd> <dt>
<code>NFFT : int</code> </dt> <dd>
<p class="first last">The number of data points used in each block for the FFT. A power 2 is most efficient. The default value is 256. This should <em>NOT</em> be used to get zero padding, or the scaling of the result will be incorrect. Use <em>pad_to</em> for this instead.</p> </dd> <dt>
<code>detrend : {'none', 'mean', 'linear'} or callable, default 'none'</code> </dt> <dd>
<p class="first last">The function applied to each segment before fft-ing, designed to remove the mean or linear trend. Unlike in MATLAB, where the <em>detrend</em> parameter is a vector, in Matplotlib is it a function. The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code>mlab</code></a> module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>, <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>, and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>, but you can use a custom function as well. You can also use a string to choose one of the functions: 'none' calls <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>. 'mean' calls <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>. 'linear' calls <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>.</p> </dd> <dt>
<code>scale_by_freq : bool, optional</code> </dt> <dd>
<p class="first last">Specifies whether the resulting density values should be scaled by the scaling frequency, which gives density in units of Hz^-1. This allows for integration over the returned frequency values. The default is True for MATLAB compatibility.</p> </dd> <dt>
<code>noverlap : integer</code> </dt> <dd>
<p class="first last">The number of points of overlap between blocks. The default value is 0 (no overlap).</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>The return value is the tuple (<em>Cxy</em>, <em>f</em>), where <em>f</em> are the</dt>  <dt>frequencies of the coherence vector. For cohere, scaling the</dt>  <dt>individual densities by the sampling frequency has no effect,</dt>  <dt>since the factors cancel out.</dt>  </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>psd(),</code> <a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code>csd()</code></a>
</dt> <dd>For information about the methods used to compute <span class="math notranslate nohighlight">\(P_{xy}\)</span>, <span class="math notranslate nohighlight">\(P_{xx}\)</span> and <span class="math notranslate nohighlight">\(P_{yy}\)</span>.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.complex_spectrum">
<code>matplotlib.mlab.complex_spectrum(x, Fs=None, window=None, pad_to=None, sides=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#complex_spectrum"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the complex-valued frequency spectrum of <em>x</em>. Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is applied to the signal.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>x : 1-D array or sequence</code> </dt> <dd>
<p class="first last">Array or sequence containing the data</p> </dd> <dt>
<code>Fs : scalar</code> </dt> <dd>
<p class="first last">The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p> </dd> <dt>
<code>window : callable or ndarray</code> </dt> <dd>
<p class="first last">A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.3.0)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.3.0)"><code>scipy.signal.get_window</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<code>sides : {'default', 'onesided', 'twosided'}</code> </dt> <dd>
<p class="first last">Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<code>pad_to : int</code> </dt> <dd>
<p class="first last">The number of points to which the data segment is padded when performing the FFT. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to the length of the input signal (i.e. no padding).</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>spectrum : 1-D array</code> </dt> <dd>
<p class="first last">The values for the complex spectrum (complex valued)</p> </dd> <dt>
<code>freqs : 1-D array</code> </dt> <dd>
<p class="first last">The frequencies corresponding to the elements in <em>spectrum</em></p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a>
</dt> <dd>Returns the absolute value of this function.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum</code></a>
</dt> <dd>Returns the angle of this function.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum</code></a>
</dt> <dd>Returns the phase (unwrapped angle) of this function.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a>
</dt> <dd>Can return the complex spectrum of segments within the signal.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.csd">
<code>matplotlib.mlab.csd(x, y, NFFT=None, Fs=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#csd"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the cross-spectral density.</p> <p>The cross spectral density <span class="math notranslate nohighlight">\(P_{xy}\)</span> by Welch's average periodogram method. The vectors <em>x</em> and <em>y</em> are divided into <em>NFFT</em> length segments. Each segment is detrended by function <em>detrend</em> and windowed by function <em>window</em>. <em>noverlap</em> gives the length of the overlap between segments. The product of the direct FFTs of <em>x</em> and <em>y</em> are averaged over each segment to compute <span class="math notranslate nohighlight">\(P_{xy}\)</span>, with a scaling to correct for power loss due to windowing.</p> <p>If len(<em>x</em>) &lt; <em>NFFT</em> or len(<em>y</em>) &lt; <em>NFFT</em>, they will be zero padded to <em>NFFT</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>x, y : 1-D arrays or sequences</code> </dt> <dd>
<p class="first last">Arrays or sequences containing the data</p> </dd> <dt>
<code>Fs : scalar</code> </dt> <dd>
<p class="first last">The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p> </dd> <dt>
<code>window : callable or ndarray</code> </dt> <dd>
<p class="first last">A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.3.0)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.3.0)"><code>scipy.signal.get_window</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<code>sides : {'default', 'onesided', 'twosided'}</code> </dt> <dd>
<p class="first last">Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<code>pad_to : int</code> </dt> <dd>
<p class="first last">The number of points to which the data segment is padded when performing the FFT. This can be different from <em>NFFT</em>, which specifies the number of data points used. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to <em>NFFT</em></p> </dd> <dt>
<code>NFFT : int</code> </dt> <dd>
<p class="first last">The number of data points used in each block for the FFT. A power 2 is most efficient. The default value is 256. This should <em>NOT</em> be used to get zero padding, or the scaling of the result will be incorrect. Use <em>pad_to</em> for this instead.</p> </dd> <dt>
<code>detrend : {'none', 'mean', 'linear'} or callable, default 'none'</code> </dt> <dd>
<p class="first last">The function applied to each segment before fft-ing, designed to remove the mean or linear trend. Unlike in MATLAB, where the <em>detrend</em> parameter is a vector, in Matplotlib is it a function. The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code>mlab</code></a> module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>, <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>, and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>, but you can use a custom function as well. You can also use a string to choose one of the functions: 'none' calls <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>. 'mean' calls <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>. 'linear' calls <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>.</p> </dd> <dt>
<code>scale_by_freq : bool, optional</code> </dt> <dd>
<p class="first last">Specifies whether the resulting density values should be scaled by the scaling frequency, which gives density in units of Hz^-1. This allows for integration over the returned frequency values. The default is True for MATLAB compatibility.</p> </dd> <dt>
<code>noverlap : integer</code> </dt> <dd>
<p class="first last">The number of points of overlap between segments. The default value is 0 (no overlap).</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>Pxy : 1-D array</code> </dt> <dd>
<p class="first last">The values for the cross spectrum <code>P_{xy}</code> before scaling (real valued)</p> </dd> <dt>
<code>freqs : 1-D array</code> </dt> <dd>
<p class="first last">The frequencies corresponding to the elements in <em>Pxy</em></p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd</code></a>
</dt> <dd>equivalent to setting <code>y = x</code>.</dd> </dl> </div> <h4 class="rubric">References</h4> <p>Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John Wiley &amp; Sons (1986)</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.demean">
<code>matplotlib.mlab.demean(x, axis=0)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#demean"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>[<em>Deprecated</em>] Return x minus its mean along the specified axis.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>x : array or sequence</code> </dt> <dd>
<p class="first last">Array or sequence containing the data Can have any dimensionality</p> </dd> <dt>
<code>axis : integer</code> </dt> <dd>
<p class="first last">The axis along which to take the mean. See numpy.mean for a description of this argument.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>
</dt> <dd>Same as <a class="reference internal" href="#matplotlib.mlab.demean" title="matplotlib.mlab.demean"><code>demean</code></a> except for the default <em>axis</em>.</dd> </dl> </div> <h4 class="rubric">Notes</h4> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.1.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.detrend">
<code>matplotlib.mlab.detrend(x, key=None, axis=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#detrend"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return x with its trend removed.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>x : array or sequence</code> </dt> <dd>
<p class="first last">Array or sequence containing the data.</p> </dd> <dt>
<code>key : [ 'default' | 'constant' | 'mean' | 'linear' | 'none'] or function</code> </dt> <dd>
<p class="first last">Specifies the detrend algorithm to use. 'default' is 'mean', which is the same as <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>. 'constant' is the same. 'linear' is the same as <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>. 'none' is the same as <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>. The default is 'mean'. See the corresponding functions for more details regarding the algorithms. Can also be a function that carries out the detrend operation.</p> </dd> <dt>
<code>axis : integer</code> </dt> <dd>
<p class="first last">The axis along which to do the detrending.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>
</dt> <dd>Implementation of the 'mean' algorithm.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>
</dt> <dd>Implementation of the 'linear' algorithm.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>
</dt> <dd>Implementation of the 'none' algorithm.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.detrend_linear">
<code>matplotlib.mlab.detrend_linear(y)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#detrend_linear"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return x minus best fit line; 'linear' detrending.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>y : 0-D or 1-D array or sequence</code> </dt> <dd>
<p class="first last">Array or sequence containing the data</p> </dd> <dt>
<code>axis : integer</code> </dt> <dd>
<p class="first last">The axis along which to take the mean. See numpy.mean for a description of this argument.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>
</dt> <dd>Another detrend algorithm.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>
</dt> <dd>Another detrend algorithm.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend</code></a>
</dt> <dd>A wrapper around all the detrend algorithms.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.detrend_mean">
<code>matplotlib.mlab.detrend_mean(x, axis=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#detrend_mean"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return x minus the mean(x).</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>x : array or sequence</code> </dt> <dd>
<p class="first last">Array or sequence containing the data Can have any dimensionality</p> </dd> <dt>
<code>axis : integer</code> </dt> <dd>
<p class="first last">The axis along which to take the mean. See numpy.mean for a description of this argument.</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>
</dt> <dd>Another detrend algorithm.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>
</dt> <dd>Another detrend algorithm.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend</code></a>
</dt> <dd>A wrapper around all the detrend algorithms.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.detrend_none">
<code>matplotlib.mlab.detrend_none(x, axis=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#detrend_none"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return x: no detrending.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>x : any object</code> </dt> <dd>
<p class="first last">An object containing the data</p> </dd> <dt>
<code>axis : integer</code> </dt> <dd>
<p class="first last">This parameter is ignored. It is included for compatibility with detrend_mean</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>
</dt> <dd>Another detrend algorithm.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>
</dt> <dd>Another detrend algorithm.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code>detrend</code></a>
</dt> <dd>A wrapper around all the detrend algorithms.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.magnitude_spectrum">
<code>matplotlib.mlab.magnitude_spectrum(x, Fs=None, window=None, pad_to=None, sides=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#magnitude_spectrum"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the magnitude (absolute value) of the frequency spectrum of <em>x</em>. Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is applied to the signal.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>x : 1-D array or sequence</code> </dt> <dd>
<p class="first last">Array or sequence containing the data</p> </dd> <dt>
<code>Fs : scalar</code> </dt> <dd>
<p class="first last">The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p> </dd> <dt>
<code>window : callable or ndarray</code> </dt> <dd>
<p class="first last">A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.3.0)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.3.0)"><code>scipy.signal.get_window</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<code>sides : {'default', 'onesided', 'twosided'}</code> </dt> <dd>
<p class="first last">Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<code>pad_to : int</code> </dt> <dd>
<p class="first last">The number of points to which the data segment is padded when performing the FFT. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to the length of the input signal (i.e. no padding).</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>spectrum : 1-D array</code> </dt> <dd>
<p class="first last">The values for the magnitude spectrum (real valued)</p> </dd> <dt>
<code>freqs : 1-D array</code> </dt> <dd>
<p class="first last">The frequencies corresponding to the elements in <em>spectrum</em></p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd</code></a>
</dt> <dd>Returns the power spectral density.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>
</dt> <dd>This function returns the absolute value of <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum</code></a>
</dt> <dd>Returns the angles of the corresponding frequencies.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum</code></a>
</dt> <dd>Returns the phase (unwrapped angle) of the corresponding frequencies.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a>
</dt> <dd>Can return the complex spectrum of segments within the signal.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.phase_spectrum">
<code>matplotlib.mlab.phase_spectrum(x, Fs=None, window=None, pad_to=None, sides=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#phase_spectrum"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the phase of the frequency spectrum (unwrapped angle spectrum) of <em>x</em>. Data is padded to a length of <em>pad_to</em> and the windowing function <em>window</em> is applied to the signal.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>x : 1-D array or sequence</code> </dt> <dd>
<p class="first last">Array or sequence containing the data</p> </dd> <dt>
<code>Fs : scalar</code> </dt> <dd>
<p class="first last">The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p> </dd> <dt>
<code>window : callable or ndarray</code> </dt> <dd>
<p class="first last">A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.3.0)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.3.0)"><code>scipy.signal.get_window</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<code>sides : {'default', 'onesided', 'twosided'}</code> </dt> <dd>
<p class="first last">Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<code>pad_to : int</code> </dt> <dd>
<p class="first last">The number of points to which the data segment is padded when performing the FFT. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to the length of the input signal (i.e. no padding).</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>spectrum : 1-D array</code> </dt> <dd>
<p class="first last">The values for the phase spectrum in radians (real valued)</p> </dd> <dt>
<code>freqs : 1-D array</code> </dt> <dd>
<p class="first last">The frequencies corresponding to the elements in <em>spectrum</em></p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>
</dt> <dd>This function returns the phase value of <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a>
</dt> <dd>Returns the magnitudes of the corresponding frequencies.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum</code></a>
</dt> <dd>Returns the angle (wrapped phase) of the corresponding frequencies.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a>
</dt> <dd>Can return the complex spectrum of segments within the signal.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.psd">
<code>matplotlib.mlab.psd(x, NFFT=None, Fs=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#psd"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the power spectral density.</p> <p>The power spectral density <span class="math notranslate nohighlight">\(P_{xx}\)</span> by Welch's average periodogram method. The vector <em>x</em> is divided into <em>NFFT</em> length segments. Each segment is detrended by function <em>detrend</em> and windowed by function <em>window</em>. <em>noverlap</em> gives the length of the overlap between segments. The <span class="math notranslate nohighlight">\(|\mathrm{fft}(i)|^2\)</span> of each segment <span class="math notranslate nohighlight">\(i\)</span> are averaged to compute <span class="math notranslate nohighlight">\(P_{xx}\)</span>.</p> <p>If len(<em>x</em>) &lt; <em>NFFT</em>, it will be zero padded to <em>NFFT</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>x : 1-D array or sequence</code> </dt> <dd>
<p class="first last">Array or sequence containing the data</p> </dd> <dt>
<code>Fs : scalar</code> </dt> <dd>
<p class="first last">The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p> </dd> <dt>
<code>window : callable or ndarray</code> </dt> <dd>
<p class="first last">A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.3.0)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.3.0)"><code>scipy.signal.get_window</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<code>sides : {'default', 'onesided', 'twosided'}</code> </dt> <dd>
<p class="first last">Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<code>pad_to : int</code> </dt> <dd>
<p class="first last">The number of points to which the data segment is padded when performing the FFT. This can be different from <em>NFFT</em>, which specifies the number of data points used. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to <em>NFFT</em></p> </dd> <dt>
<code>NFFT : int</code> </dt> <dd>
<p class="first last">The number of data points used in each block for the FFT. A power 2 is most efficient. The default value is 256. This should <em>NOT</em> be used to get zero padding, or the scaling of the result will be incorrect. Use <em>pad_to</em> for this instead.</p> </dd> <dt>
<code>detrend : {'none', 'mean', 'linear'} or callable, default 'none'</code> </dt> <dd>
<p class="first last">The function applied to each segment before fft-ing, designed to remove the mean or linear trend. Unlike in MATLAB, where the <em>detrend</em> parameter is a vector, in Matplotlib is it a function. The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code>mlab</code></a> module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>, <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>, and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>, but you can use a custom function as well. You can also use a string to choose one of the functions: 'none' calls <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>. 'mean' calls <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>. 'linear' calls <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>.</p> </dd> <dt>
<code>scale_by_freq : bool, optional</code> </dt> <dd>
<p class="first last">Specifies whether the resulting density values should be scaled by the scaling frequency, which gives density in units of Hz^-1. This allows for integration over the returned frequency values. The default is True for MATLAB compatibility.</p> </dd> <dt>
<code>noverlap : integer</code> </dt> <dd>
<p class="first last">The number of points of overlap between segments. The default value is 0 (no overlap).</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>Pxx : 1-D array</code> </dt> <dd>
<p class="first last">The values for the power spectrum <code>P_{xx}</code> (real valued)</p> </dd> <dt>
<code>freqs : 1-D array</code> </dt> <dd>
<p class="first last">The frequencies corresponding to the elements in <em>Pxx</em></p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a>
</dt> <dd>
<a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code>specgram</code></a> differs in the default overlap; in not returning the mean of the segment periodograms; and in returning the times of the segments.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a>
</dt> <dd>returns the magnitude spectrum.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code>csd</code></a>
</dt> <dd>returns the spectral density between two signals.</dd> </dl> </div> <h4 class="rubric">References</h4> <p>Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John Wiley &amp; Sons (1986)</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.specgram">
<code>matplotlib.mlab.specgram(x, NFFT=None, Fs=None, detrend=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None, mode=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#specgram"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute a spectrogram.</p> <p>Compute and plot a spectrogram of data in x. Data are split into NFFT length segments and the spectrum of each section is computed. The windowing function window is applied to each segment, and the amount of overlap of each segment is specified with noverlap.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>x : array_like</code> </dt> <dd>
<p class="first last">1-D array or sequence.</p> </dd> <dt>
<code>Fs : scalar</code> </dt> <dd>
<p class="first last">The sampling frequency (samples per time unit). It is used to calculate the Fourier frequencies, freqs, in cycles per time unit. The default value is 2.</p> </dd> <dt>
<code>window : callable or ndarray</code> </dt> <dd>
<p class="first last">A function or a vector of length <em>NFFT</em>. To create window vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code>numpy.blackman</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code>numpy.hamming</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code>numpy.bartlett</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal" title="(in SciPy v1.3.0)"><code>scipy.signal</code></a>, <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.3.0)"><code>scipy.signal.get_window</code></a>, etc. The default is <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>. If a function is passed as the argument, it must take a data segment as an argument and return the windowed version of the segment.</p> </dd> <dt>
<code>sides : {'default', 'onesided', 'twosided'}</code> </dt> <dd>
<p class="first last">Specifies which sides of the spectrum to return. Default gives the default behavior, which returns one-sided for real data and both for complex data. 'onesided' forces the return of a one-sided spectrum, while 'twosided' forces two-sided.</p> </dd> <dt>
<code>pad_to : int</code> </dt> <dd>
<p class="first last">The number of points to which the data segment is padded when performing the FFT. This can be different from <em>NFFT</em>, which specifies the number of data points used. While not increasing the actual resolution of the spectrum (the minimum distance between resolvable peaks), this can give more points in the plot, allowing for more detail. This corresponds to the <em>n</em> parameter in the call to fft(). The default is None, which sets <em>pad_to</em> equal to <em>NFFT</em></p> </dd> <dt>
<code>NFFT : int</code> </dt> <dd>
<p class="first last">The number of data points used in each block for the FFT. A power 2 is most efficient. The default value is 256. This should <em>NOT</em> be used to get zero padding, or the scaling of the result will be incorrect. Use <em>pad_to</em> for this instead.</p> </dd> <dt>
<code>detrend : {'none', 'mean', 'linear'} or callable, default 'none'</code> </dt> <dd>
<p class="first last">The function applied to each segment before fft-ing, designed to remove the mean or linear trend. Unlike in MATLAB, where the <em>detrend</em> parameter is a vector, in Matplotlib is it a function. The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code>mlab</code></a> module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>, <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>, and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>, but you can use a custom function as well. You can also use a string to choose one of the functions: 'none' calls <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code>detrend_none</code></a>. 'mean' calls <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code>detrend_mean</code></a>. 'linear' calls <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code>detrend_linear</code></a>.</p> </dd> <dt>
<code>scale_by_freq : bool, optional</code> </dt> <dd>
<p class="first last">Specifies whether the resulting density values should be scaled by the scaling frequency, which gives density in units of Hz^-1. This allows for integration over the returned frequency values. The default is True for MATLAB compatibility.</p> </dd> <dt>
<code>noverlap : int, optional</code> </dt> <dd>
<p class="first last">The number of points of overlap between blocks. The default value is 128.</p> </dd> <dt>
<code>mode : str, optional</code> </dt> <dd>
<dl class="first last docutils"> <dt>What sort of spectrum to use, default is 'psd'.</dt> <dd>
<dl class="first last docutils"> <dt>'psd'</dt> <dd>
<p class="first last">Returns the power spectral density.</p> </dd> <dt>'complex'</dt> <dd>
<p class="first last">Returns the complex-valued frequency spectrum.</p> </dd> <dt>'magnitude'</dt> <dd>
<p class="first last">Returns the magnitude spectrum.</p> </dd> <dt>'angle'</dt> <dd>
<p class="first last">Returns the phase spectrum without unwrapping.</p> </dd> <dt>'phase'</dt> <dd>
<p class="first last">Returns the phase spectrum with unwrapping.</p> </dd> </dl> </dd> </dl> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>spectrum : array_like</code> </dt> <dd>
<p class="first last">2-D array, columns are the periodograms of successive segments.</p> </dd> <dt>
<code>freqs : array_like</code> </dt> <dd>
<p class="first last">1-D array, frequencies corresponding to the rows in <em>spectrum</em>.</p> </dd> <dt>
<code>t : array_like</code> </dt> <dd>
<p class="first last">1-D array, the times corresponding to midpoints of segments (i.e the columns in <em>spectrum</em>).</p> </dd> </dl> </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code>psd</code></a>
</dt> <dd>differs in the overlap and in the return values.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code>complex_spectrum</code></a>
</dt> <dd>similar, but with complex valued frequencies.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code>magnitude_spectrum</code></a>
</dt> <dd>similar single segment when mode is 'magnitude'.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code>angle_spectrum</code></a>
</dt> <dd>similar to single segment when mode is 'angle'.</dd> <dt>
 <a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code>phase_spectrum</code></a>
</dt> <dd>similar to single segment when mode is 'phase'.</dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>detrend and scale_by_freq only apply when <em>mode</em> is set to 'psd'.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.stride_repeat">
<code>matplotlib.mlab.stride_repeat(x, n, axis=0)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#stride_repeat"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Repeat the values in an array in a memory-efficient manner. Array x is stacked vertically n times.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">It is not safe to write to the output array. Multiple elements may point to the same piece of memory, so modifying one value may change others.</p> </div> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>x : 1D array or sequence</code> </dt> <dd>
<p class="first last">Array or sequence containing the data.</p> </dd> <dt>
<code>n : integer</code> </dt> <dd>
<p class="first last">The number of time to repeat the array.</p> </dd> <dt>
<code>axis : integer</code> </dt> <dd>
<p class="first last">The axis along which the data will run.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">References</h4> <p><a class="reference external" href="http://stackoverflow.com/a/5568169">stackoverflow: Repeat NumPy array without replicating data?</a></p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.stride_windows">
<code>matplotlib.mlab.stride_windows(x, n, noverlap=None, axis=0)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#stride_windows"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get all windows of x with length n as a single array, using strides to avoid data duplication.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">It is not safe to write to the output array. Multiple elements may point to the same piece of memory, so modifying one value may change others.</p> </div> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>x : 1D array or sequence</code> </dt> <dd>
<p class="first last">Array or sequence containing the data.</p> </dd> <dt>
<code>n : integer</code> </dt> <dd>
<p class="first last">The number of data points in each window.</p> </dd> <dt>
<code>noverlap : integer</code> </dt> <dd>
<p class="first last">The overlap between adjacent windows. Default is 0 (no overlap)</p> </dd> <dt>
<code>axis : integer</code> </dt> <dd>
<p class="first last">The axis along which the windows will run.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">References</h4> <p><a class="reference external" href="http://stackoverflow.com/a/6811241">stackoverflow: Rolling window for 1D arrays in Numpy?</a> <a class="reference external" href="http://stackoverflow.com/a/4947453">stackoverflow: Using strides for an efficient moving average filter</a></p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.window_hanning">
<code>matplotlib.mlab.window_hanning(x)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#window_hanning"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return x times the hanning window of len(x).</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code>window_none</code></a>
</dt> <dd>Another window algorithm.</dd> </dl> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.mlab.window_none">
<code>matplotlib.mlab.window_none(x)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/mlab.html#window_none"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>No window function; simply return x.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code>window_hanning</code></a>
</dt> <dd>Another window algorithm.</dd> </dl> </div> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2018 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/3.1.1/api/mlab_api.html" class="_attribution-link">https://matplotlib.org/3.1.1/api/mlab_api.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
