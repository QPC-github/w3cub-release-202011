
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Dates - Matplotlib 3.1 - W3cubDocs</title>
  
  <meta name="description" content=" Matplotlib provides sophisticated date plotting capabilities, standing on the shoulders of python datetime and the add-on module dateutil. ">
  <meta name="keywords" content="matplotlib, dates, matplotlib~3.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/matplotlib~3.1/dates_api.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e498cd0ebe8746846fec95b1a53ab3bb0fb7f47f794f0a38f44c98a1f0d03b21d777ae2c583732e44a5a890f6eacb79a5333545db9d5f3616091ba21ca17d916.css">
  <script src="/assets/application-79c555f6b25481fffac2cac30a7f3e54e608ca09e9e8e42bb1790095ba6d0fcace47d6bc624ddce952c70370892f2d46864f89e6943d4f7f7ff16c8a3231a91a.js" type="text/javascript"></script>
  <script src="/json/matplotlib~3.1.js"></script>
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R3WC07G3GB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-R3WC07G3GB');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2572770204602497"
     crossorigin="anonymous"></script>
<script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body class="docs">
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">

  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~3.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 3.1</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		
		<form class="_search">
		  <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
		  <a class="_search-clear"></a>
		  <div class="_search-tag"></div>
		</form>
		
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="matplotlib-dates">matplotlib.dates</h1> <div class="graphviz"><img src="data:image/png;base64,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" alt="Inheritance diagram of matplotlib.dates" usemap="#inheritance1bda3e63b5" class="inheritance graphviz"></div> <map id="inheritance1bda3e63b5" name="inheritance1bda3e63b5"> <area shape="rect" id="node1" href="#matplotlib.dates.AutoDateFormatter" target="_top" title="This class attempts to figure out the best format to use.  This is" alt="" coords="326,126,446,146"> <area shape="rect" id="node2" href="ticker_api.html#matplotlib.ticker.Formatter" target="_top" title="Create a string based on a tick value and location." alt="" coords="188,206,259,227"> <area shape="rect" id="node7" href="#matplotlib.dates.ConciseDateFormatter" target="_top" title="This class attempts to figure out the best format to use for the" alt="" coords="317,166,454,187"> <area shape="rect" id="node9" href="#matplotlib.dates.DateFormatter" target="_top" title="Format a tick (in seconds since the epoch) with a `strftime` format string." alt="" coords="338,206,434,227"> <area shape="rect" id="node15" href="#matplotlib.dates.IndexDateFormatter" target="_top" title="Use with :class:`~matplotlib.ticker.IndexLocator` to cycle format" alt="" coords="323,247,448,268"> <area shape="rect" id="node3" href="#matplotlib.dates.AutoDateLocator" target="_top" title="On autoscale, this class picks the best" alt="" coords="502,226,609,247"> <area shape="rect" id="node4" href="#matplotlib.dates.DateLocator" target="_top" title="Determines the tick locations when plotting dates." alt="" coords="344,287,427,308"> <area shape="rect" id="node12" href="#matplotlib.dates.RRuleLocator" target="_top" title="RRuleLocator" alt="" coords="512,267,599,287"> <area shape="rect" id="node16" href="#matplotlib.dates.MicrosecondLocator" target="_top" title="Make ticks on regular intervals of one or more microsecond(s)." alt="" coords="494,307,617,328"> <area shape="rect" id="node21" href="#matplotlib.dates.YearLocator" target="_top" title="Make ticks on a given day of each year that is a multiple of base." alt="" coords="516,347,595,368"> <area shape="rect" id="node8" href="units_api.html#matplotlib.units.ConversionInterface" target="_top" title="The minimal interface for a converter to take custom data types (or" alt="" coords="4,85,130,106"> <area shape="rect" id="node10" href="ticker_api.html#matplotlib.ticker.Locator" target="_top" title="Determine the tick locations;" alt="" coords="194,268,253,288"> <area shape="rect" id="node11" href="#matplotlib.dates.DayLocator" target="_top" title="Make ticks on occurrences of each day of the month.  For example," alt="" coords="671,165,749,186"> <area shape="rect" id="node14" href="#matplotlib.dates.HourLocator" target="_top" title="Make ticks on occurrences of each hour." alt="" coords="669,205,752,226"> <area shape="rect" id="node17" href="#matplotlib.dates.MinuteLocator" target="_top" title="Make ticks on occurrences of each minute." alt="" coords="663,246,757,267"> <area shape="rect" id="node18" href="#matplotlib.dates.MonthLocator" target="_top" title="Make ticks on occurrences of each month, e.g., 1, 3, 12." alt="" coords="665,286,755,307"> <area shape="rect" id="node19" href="#matplotlib.dates.SecondLocator" target="_top" title="Make ticks on occurrences of each second." alt="" coords="662,327,758,347"> <area shape="rect" id="node20" href="#matplotlib.dates.WeekdayLocator" target="_top" title="Make ticks on occurrences of each weekday." alt="" coords="657,367,764,388"> <area shape="rect" id="node13" href="ticker_api.html#matplotlib.ticker.TickHelper" target="_top" title="TickHelper" alt="" coords="29,227,105,248"> </map><p id="module-matplotlib.dates">Matplotlib provides sophisticated date plotting capabilities, standing on the shoulders of python <a class="reference external" href="https://docs.python.org/3/library/datetime.html#module-datetime" title="(in Python v3.7)"><code>datetime</code></a> and the add-on module <code>dateutil</code>.</p>  <h2 id="date-format">Matplotlib date format</h2> <p id="matplotlib-date-format">Matplotlib represents dates using floating point numbers specifying the number of days since 0001-01-01 UTC, plus 1. For example, 0001-01-01, 06:00 is 1.25, not 0.25. Values &lt; 1, i.e. dates before 0001-01-01 UTC are not supported.</p> <p>There are a number of helper functions to convert between <a class="reference external" href="https://docs.python.org/3/library/datetime.html#module-datetime" title="(in Python v3.7)"><code>datetime</code></a> objects and Matplotlib dates:</p> <table class="longtable docutils">   <tr>
<td><a class="reference internal" href="#matplotlib.dates.datestr2num" title="matplotlib.dates.datestr2num"><code>datestr2num</code></a></td> <td>Convert a date string to a datenum using <code>dateutil.parser.parse()</code>.</td> </tr> <tr>
<td><a class="reference internal" href="#matplotlib.dates.date2num" title="matplotlib.dates.date2num"><code>date2num</code></a></td> <td>Convert datetime objects to Matplotlib dates.</td> </tr> <tr>
<td><a class="reference internal" href="#matplotlib.dates.num2date" title="matplotlib.dates.num2date"><code>num2date</code></a></td> <td>Convert Matplotlib dates to <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.7)"><code>datetime</code></a> objects.</td> </tr> <tr>
<td><a class="reference internal" href="#matplotlib.dates.num2timedelta" title="matplotlib.dates.num2timedelta"><code>num2timedelta</code></a></td> <td>Convert number of days to a <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(in Python v3.7)"><code>timedelta</code></a> object.</td> </tr> <tr>
<td><a class="reference internal" href="#matplotlib.dates.epoch2num" title="matplotlib.dates.epoch2num"><code>epoch2num</code></a></td> <td>Convert an epoch or sequence of epochs to the new date format, that is days since 0001.</td> </tr> <tr>
<td><a class="reference internal" href="#matplotlib.dates.num2epoch" title="matplotlib.dates.num2epoch"><code>num2epoch</code></a></td> <td>Convert days since 0001 to epoch.</td> </tr> <tr>
<td><a class="reference internal" href="#matplotlib.dates.mx2num" title="matplotlib.dates.mx2num"><code>mx2num</code></a></td> <td>Convert mx <code>datetime</code> instance (or sequence of mx instances) to the new date format.</td> </tr> <tr>
<td><a class="reference internal" href="#matplotlib.dates.drange" title="matplotlib.dates.drange"><code>drange</code></a></td> <td>Return a sequence of equally spaced Matplotlib dates.</td> </tr>  </table> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Like Python's datetime, mpl uses the Gregorian calendar for all conversions between dates and floating point numbers. This practice is not universal, and calendar differences can cause confusing differences between what Python and mpl give as the number of days since 0001-01-01 and what other software and databases yield. For example, the US Naval Observatory uses a calendar that switches from Julian to Gregorian in October, 1582. Hence, using their calculator, the number of days between 0001-01-01 and 2006-04-01 is 732403, whereas using the Gregorian calendar via the datetime module we find:</p> <pre data-language="python">In [1]: date(2006, 4, 1).toordinal() - date(1, 1, 1).toordinal()
Out[1]: 732401
</pre> </div> <p>All the Matplotlib date converters, tickers and formatters are timezone aware. If no explicit timezone is provided, the rcParam <code>timezone</code> is assumed. If you want to use a custom time zone, pass a <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.tzinfo" title="(in Python v3.7)"><code>datetime.tzinfo</code></a> instance with the tz keyword argument to <a class="reference internal" href="#matplotlib.dates.num2date" title="matplotlib.dates.num2date"><code>num2date()</code></a>, <a class="reference internal" href="_as_gen/matplotlib.pyplot.plot_date#matplotlib.pyplot.plot_date" title="matplotlib.pyplot.plot_date"><code>plot_date()</code></a>, and any custom date tickers or locators you create.</p> <p>A wide range of specific and general purpose date tick locators and formatters are provided in this module. See <a class="reference internal" href="ticker_api#module-matplotlib.ticker" title="matplotlib.ticker"><code>matplotlib.ticker</code></a> for general information on tick locators and formatters. These are described below.</p> <p>The <a class="reference external" href="https://dateutil.readthedocs.io">dateutil</a> module provides additional code to handle date ticking, making it easy to place ticks on any kinds of dates. See examples below.</p>   <h2 id="date-tickers">Date tickers</h2> <p>Most of the date tickers can locate single or multiple values. For example:</p> <pre data-language="python"># import constants for the days of the week
from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU

# tick on mondays every week
loc = WeekdayLocator(byweekday=MO, tz=tz)

# tick on mondays and saturdays
loc = WeekdayLocator(byweekday=(MO, SA))
</pre> <p>In addition, most of the constructors take an interval argument:</p> <pre data-language="python"># tick on mondays every second week
loc = WeekdayLocator(byweekday=MO, interval=2)
</pre> <p>The rrule locator allows completely general date ticking:</p> <pre data-language="python"># tick every 5th easter
rule = rrulewrapper(YEARLY, byeaster=1, interval=5)
loc = RRuleLocator(rule)
</pre> <p>Here are all the date tickers:</p>  <ul class="simple"> <li>
<a class="reference internal" href="#matplotlib.dates.MicrosecondLocator" title="matplotlib.dates.MicrosecondLocator"><code>MicrosecondLocator</code></a>: locate microseconds</li> <li>
<a class="reference internal" href="#matplotlib.dates.SecondLocator" title="matplotlib.dates.SecondLocator"><code>SecondLocator</code></a>: locate seconds</li> <li>
<a class="reference internal" href="#matplotlib.dates.MinuteLocator" title="matplotlib.dates.MinuteLocator"><code>MinuteLocator</code></a>: locate minutes</li> <li>
<a class="reference internal" href="#matplotlib.dates.HourLocator" title="matplotlib.dates.HourLocator"><code>HourLocator</code></a>: locate hours</li> <li>
<a class="reference internal" href="#matplotlib.dates.DayLocator" title="matplotlib.dates.DayLocator"><code>DayLocator</code></a>: locate specified days of the month</li> <li>
<a class="reference internal" href="#matplotlib.dates.WeekdayLocator" title="matplotlib.dates.WeekdayLocator"><code>WeekdayLocator</code></a>: Locate days of the week, e.g., MO, TU</li> <li>
<a class="reference internal" href="#matplotlib.dates.MonthLocator" title="matplotlib.dates.MonthLocator"><code>MonthLocator</code></a>: locate months, e.g., 7 for july</li> <li>
<a class="reference internal" href="#matplotlib.dates.YearLocator" title="matplotlib.dates.YearLocator"><code>YearLocator</code></a>: locate years that are multiples of base</li> <li>
<a class="reference internal" href="#matplotlib.dates.RRuleLocator" title="matplotlib.dates.RRuleLocator"><code>RRuleLocator</code></a>: locate using a <code>matplotlib.dates.rrulewrapper</code>. <code>rrulewrapper</code> is a simple wrapper around <a class="reference external" href="https://dateutil.readthedocs.io">dateutil</a>'s <a class="reference external" href="https://dateutil.readthedocs.io/en/stable/rrule.html#module-dateutil.rrule" title="(in dateutil v2.8.0)"><code>dateutil.rrule</code></a> which allow almost arbitrary date tick specifications. See <a class="reference internal" href="https://matplotlib.org/3.1.1/gallery/ticks_and_spines/date_demo_rrule.html"><span class="doc">rrule example</span></a>.</li> <li>
<a class="reference internal" href="#matplotlib.dates.AutoDateLocator" title="matplotlib.dates.AutoDateLocator"><code>AutoDateLocator</code></a>: On autoscale, this class picks the best <a class="reference internal" href="#matplotlib.dates.DateLocator" title="matplotlib.dates.DateLocator"><code>DateLocator</code></a> (e.g., <a class="reference internal" href="#matplotlib.dates.RRuleLocator" title="matplotlib.dates.RRuleLocator"><code>RRuleLocator</code></a>) to set the view limits and the tick locations. If called with <code>interval_multiples=True</code> it will make ticks line up with sensible multiples of the tick intervals. E.g. if the interval is 4 hours, it will pick hours 0, 4, 8, etc as ticks. This behaviour is not guaranteed by default.</li> </ul>    <h2 id="date-formatters">Date formatters</h2> <p>Here all all the date formatters:</p>  <ul class="simple"> <li>
<a class="reference internal" href="#matplotlib.dates.AutoDateFormatter" title="matplotlib.dates.AutoDateFormatter"><code>AutoDateFormatter</code></a>: attempts to figure out the best format to use. This is most useful when used with the <a class="reference internal" href="#matplotlib.dates.AutoDateLocator" title="matplotlib.dates.AutoDateLocator"><code>AutoDateLocator</code></a>.</li> <li>
<a class="reference internal" href="#matplotlib.dates.ConciseDateFormatter" title="matplotlib.dates.ConciseDateFormatter"><code>ConciseDateFormatter</code></a>: also attempts to figure out the best format to use, and to make the format as compact as possible while still having complete date information. This is most useful when used with the <a class="reference internal" href="#matplotlib.dates.AutoDateLocator" title="matplotlib.dates.AutoDateLocator"><code>AutoDateLocator</code></a>.</li> <li>
<a class="reference internal" href="#matplotlib.dates.DateFormatter" title="matplotlib.dates.DateFormatter"><code>DateFormatter</code></a>: use <code>strftime()</code> format strings</li> <li>
<a class="reference internal" href="#matplotlib.dates.IndexDateFormatter" title="matplotlib.dates.IndexDateFormatter"><code>IndexDateFormatter</code></a>: date plots with implicit <em>x</em> indexing.</li> </ul>  <dl class="function"> <dt id="matplotlib.dates.datestr2num">
<code>matplotlib.dates.datestr2num(d, default=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#datestr2num"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert a date string to a datenum using <code>dateutil.parser.parse()</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>d : string or sequence of strings</code> </dt> <dd>
<p class="first last">The dates to convert.</p> </dd> <dt>
<code>default : datetime instance, optional</code> </dt> <dd>
<p class="first last">The default date to use when fields are missing in <em>d</em>.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.dates.date2num">
<code>matplotlib.dates.date2num(d)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#date2num"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert datetime objects to Matplotlib dates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>d : datetime.datetime or numpy.datetime64 or sequences of these</code> </dt>  </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>float or sequence of floats</dt> <dd>
<p class="first last">Number of days (fraction part represents hours, minutes, seconds, ms) since 0001-01-01 00:00:00 UTC, plus one.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The addition of one here is a historical artifact. Also, note that the Gregorian calendar is assumed; this is not universal practice. For details see the module docstring.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.dates.num2date">
<code>matplotlib.dates.num2date(x, tz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#num2date"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert Matplotlib dates to <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.7)"><code>datetime</code></a> objects.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>x : float or sequence of floats</code> </dt> <dd>
<p class="first last">Number of days (fraction part represents hours, minutes, seconds) since 0001-01-01 00:00:00 UTC, plus one.</p> </dd> <dt>
<code>tz : string, optional</code> </dt> <dd>
<p class="first last">Timezone of <em>x</em> (defaults to rcparams <code>timezone</code>).</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>datetime or sequence of</code> <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.7)"><code>datetime</code></a>
</dt> <dd>
<p class="first">Dates are returned in timezone <em>tz</em>.</p> <p class="last">If <em>x</em> is a sequence, a sequence of <code>datetime</code> objects will be returned.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The addition of one here is a historical artifact. Also, note that the Gregorian calendar is assumed; this is not universal practice. For details, see the module docstring.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.dates.num2timedelta">
<code>matplotlib.dates.num2timedelta(x)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#num2timedelta"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert number of days to a <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(in Python v3.7)"><code>timedelta</code></a> object.</p> <p>If <em>x</em> is a sequence, a sequence of <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(in Python v3.7)"><code>timedelta</code></a> objects will be returned.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>x : float, sequence of floats</code> </dt> <dd>
<p class="first last">Number of days. The fraction part represents hours, minutes, seconds.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>datetime.timedelta or list[datetime.timedelta]</code> </dt>  </dl> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.dates.drange">
<code>matplotlib.dates.drange(dstart, dend, delta)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#drange"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a sequence of equally spaced Matplotlib dates.</p> <p>The dates start at <em>dstart</em> and reach up to, but not including <em>dend</em>. They are spaced by <em>delta</em>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first docutils"> <dt>
<code>dstart, dend : datetime</code> </dt> <dd>
<p class="first last">The date limits.</p> </dd> <dt>
<code>delta : datetime.timedelta</code> </dt> <dd>
<p class="first last">Spacing of the dates.</p> </dd> </dl> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>drange : numpy.array</code> </dt> <dd>
<p class="first last">A list floats representing Matplotlib dates.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="function"> <dt id="matplotlib.dates.epoch2num">
<code>matplotlib.dates.epoch2num(e)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#epoch2num"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert an epoch or sequence of epochs to the new date format, that is days since 0001.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.dates.num2epoch">
<code>matplotlib.dates.num2epoch(d)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#num2epoch"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert days since 0001 to epoch. <em>d</em> can be a number or sequence.</p> </dd>
</dl> <dl class="function"> <dt id="matplotlib.dates.mx2num">
<code>matplotlib.dates.mx2num(mxdates)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#mx2num"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert mx <code>datetime</code> instance (or sequence of mx instances) to the new date format.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.DateFormatter">
<code>class matplotlib.dates.DateFormatter(fmt, tz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#DateFormatter"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="ticker_api#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Format a tick (in seconds since the epoch) with a <a class="reference internal" href="#matplotlib.dates.DateFormatter.strftime" title="matplotlib.dates.DateFormatter.strftime"><code>strftime</code></a> format string.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>fmt : str</code> </dt> <dd>
<p class="first last"><a class="reference internal" href="#matplotlib.dates.DateFormatter.strftime" title="matplotlib.dates.DateFormatter.strftime"><code>strftime</code></a> format string</p> </dd> <dt>
<code>tz : tzinfo</code> </dt>  </dl> </td> </tr>  </table> <dl class="attribute"> <dt id="matplotlib.dates.DateFormatter.illegal_s">
<code>illegal_s = re.compile('((^|[^%])(%%)*%s)')</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.dates.DateFormatter.set_tzinfo">
<code>set_tzinfo(self, tz)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#DateFormatter.set_tzinfo"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.dates.DateFormatter.strftime">
<code>strftime(self, dt, fmt=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#DateFormatter.strftime"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>[<em>Deprecated</em>] Refer to documentation for <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime.strftime" title="(in Python v3.7)"><code>datetime.datetime.strftime()</code></a></p> <p><em>fmt</em> is a <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime.strftime" title="(in Python v3.7)"><code>datetime.datetime.strftime()</code></a> format string.</p> <p>Warning: For years before 1900, depending upon the current locale it is possible that the year displayed with %x might be incorrect. For years before 100, %y and %Y will yield zero-padded strings.</p> <h4 class="rubric">Notes</h4> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.0.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.dates.DateFormatter.strftime_pre_1900">
<code>strftime_pre_1900(self, dt, fmt=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#DateFormatter.strftime_pre_1900"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>[<em>Deprecated</em>] Call time.strftime for years before 1900 by rolling forward a multiple of 28 years.</p> <p><em>fmt</em> is a <a class="reference internal" href="#matplotlib.dates.DateFormatter.strftime" title="matplotlib.dates.DateFormatter.strftime"><code>strftime()</code></a> format string.</p> <p>Dalke: I hope I did this math right. Every 28 years the calendar repeats, except through century leap years excepting the 400 year leap years. But only if you're using the Gregorian calendar.</p> <h4 class="rubric">Notes</h4> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.0.</span></p> </div> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.ConciseDateFormatter">
<code>class matplotlib.dates.ConciseDateFormatter(locator, tz=None, formats=None, offset_formats=None, zero_formats=None, show_offset=True)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#ConciseDateFormatter"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="ticker_api#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>This class attempts to figure out the best format to use for the date, and to make it as compact as possible, but still be complete. This is most useful when used with the <a class="reference internal" href="#matplotlib.dates.AutoDateLocator" title="matplotlib.dates.AutoDateLocator"><code>AutoDateLocator</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; locator = AutoDateLocator()
&gt;&gt;&gt; formatter = ConciseDateFormatter(locator)
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>locator : ticker.Locator</code> </dt> <dd>
<p class="first last">Locator that this axis is using.</p> </dd> <dt>
<code>tz : string, optional</code> </dt> <dd>
<p class="first last">Passed to <a class="reference internal" href="#matplotlib.dates.date2num" title="matplotlib.dates.date2num"><code>dates.date2num</code></a>.</p> </dd> <dt>
<code>formats : list of 6 strings, optional</code> </dt> <dd>
<p class="first last">Format strings for 6 levels of tick labelling: mostly years, months, days, hours, minutes, and seconds. Strings use the same format codes as <code>strftime</code>. Default is <code>['%Y', '%b', '%d', '%H:%M', '%H:%M', '%S.%f']</code></p> </dd> <dt>
<code>zero_formats : list of 6 strings, optional</code> </dt> <dd>
<p class="first last">Format strings for tick labels that are "zeros" for a given tick level. For instance, if most ticks are months, ticks around 1 Jan 2005 will be labeled "Dec", "2005", "Feb". The default is <code>['', '%Y', '%b', '%b-%d', '%H:%M', '%H:%M']</code></p> </dd> <dt>
<code>offset_formats : list of 6 strings, optional</code> </dt> <dd>
<p class="first">Format strings for the 6 levels that is applied to the "offset" string found on the right side of an x-axis, or top of a y-axis. Combined with the tick labels this should completely specify the date. The default is:</p> <pre data-language="python">['', '%Y', '%Y-%b', '%Y-%b-%d', '%Y-%b-%d', '%Y-%b-%d %H:%M']
</pre> </dd> <dt>
<code>show_offset : bool</code> </dt> <dd>
<p class="first last">Whether to show the offset or not. Default is <code>True</code>.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Examples</h4> <p>See <a class="reference internal" href="https://matplotlib.org/3.1.1/gallery/ticks_and_spines/date_concise_formatter.html"><span class="doc">Formatting date ticks using ConciseDateFormatter</span></a></p> <p>(<a class="reference external" href="dates_api-1.py">Source code</a>, <a class="reference external" href="dates_api-1.png">png</a>, <a class="reference external" href="dates_api-1.pdf">pdf</a>)</p> <div class="figure"> <img alt="../_images/dates_api-1.png" src="data:image/png;base64,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"> </div> <p>Autoformat the date labels. The default format is used to form an initial string, and then redundant elements are removed.</p> <dl class="method"> <dt id="matplotlib.dates.ConciseDateFormatter.format_data_short">
<code>format_data_short(self, value)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#ConciseDateFormatter.format_data_short"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a short string version of the tick value.</p> <p>Defaults to the position-independent long value.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.dates.ConciseDateFormatter.format_ticks">
<code>format_ticks(self, values)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#ConciseDateFormatter.format_ticks"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the tick labels for all the ticks at once.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.dates.ConciseDateFormatter.get_offset">
<code>get_offset(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#ConciseDateFormatter.get_offset"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.IndexDateFormatter">
<code>class matplotlib.dates.IndexDateFormatter(t, fmt, tz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#IndexDateFormatter"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="ticker_api#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>Use with <a class="reference internal" href="ticker_api#matplotlib.ticker.IndexLocator" title="matplotlib.ticker.IndexLocator"><code>IndexLocator</code></a> to cycle format strings by index.</p> <p><em>t</em> is a sequence of dates (floating point days). <em>fmt</em> is a <code>strftime()</code> format string.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.AutoDateFormatter">
<code>class matplotlib.dates.AutoDateFormatter(locator, tz=None, defaultfmt='%Y-%m-%d')</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#AutoDateFormatter"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="ticker_api#matplotlib.ticker.Formatter" title="matplotlib.ticker.Formatter"><code>matplotlib.ticker.Formatter</code></a></p> <p>This class attempts to figure out the best format to use. This is most useful when used with the <a class="reference internal" href="#matplotlib.dates.AutoDateLocator" title="matplotlib.dates.AutoDateLocator"><code>AutoDateLocator</code></a>.</p> <p>The AutoDateFormatter has a scale dictionary that maps the scale of the tick (the distance in days between one major tick) and a format string. The default looks like this:</p> <pre data-language="python">self.scaled = {
    DAYS_PER_YEAR: rcParams['date.autoformat.year'],
    DAYS_PER_MONTH: rcParams['date.autoformat.month'],
    1.0: rcParams['date.autoformat.day'],
    1. / HOURS_PER_DAY: rcParams['date.autoformat.hour'],
    1. / (MINUTES_PER_DAY): rcParams['date.autoformat.minute'],
    1. / (SEC_PER_DAY): rcParams['date.autoformat.second'],
    1. / (MUSECONDS_PER_DAY): rcParams['date.autoformat.microsecond'],
    }
</pre> <p>The algorithm picks the key in the dictionary that is &gt;= the current scale and uses that format string. You can customize this dictionary by doing:</p> <pre data-language="python">&gt;&gt;&gt; locator = AutoDateLocator()
&gt;&gt;&gt; formatter = AutoDateFormatter(locator)
&gt;&gt;&gt; formatter.scaled[1/(24.*60.)] = '%M:%S' # only show min and sec
</pre> <p>A custom <a class="reference internal" href="ticker_api#matplotlib.ticker.FuncFormatter" title="matplotlib.ticker.FuncFormatter"><code>FuncFormatter</code></a> can also be used. The following example shows how to use a custom format function to strip trailing zeros from decimal seconds and adds the date to the first ticklabel:</p> <pre data-language="python">&gt;&gt;&gt; def my_format_function(x, pos=None):
...     x = matplotlib.dates.num2date(x)
...     if pos == 0:
...         fmt = '%D %H:%M:%S.%f'
...     else:
...         fmt = '%H:%M:%S.%f'
...     label = x.strftime(fmt)
...     label = label.rstrip("0")
...     label = label.rstrip(".")
...     return label
&gt;&gt;&gt; from matplotlib.ticker import FuncFormatter
&gt;&gt;&gt; formatter.scaled[1/(24.*60.)] = FuncFormatter(my_format_function)
</pre> <p>Autoformat the date labels. The default format is the one to use if none of the values in <code>self.scaled</code> are greater than the unit returned by <code>locator._get_unit()</code>.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.DateLocator">
<code>class matplotlib.dates.DateLocator(tz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#DateLocator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="ticker_api#matplotlib.ticker.Locator" title="matplotlib.ticker.Locator"><code>matplotlib.ticker.Locator</code></a></p> <p>Determines the tick locations when plotting dates.</p> <p>This class is subclassed by other Locators and is not meant to be used on its own.</p> <p><em>tz</em> is a <code>tzinfo</code> instance.</p> <dl class="method"> <dt id="matplotlib.dates.DateLocator.datalim_to_dt">
<code>datalim_to_dt(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#DateLocator.datalim_to_dt"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert axis data interval to datetime objects.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.dates.DateLocator.hms0d">
<code>hms0d = {'byhour': 0, 'byminute': 0, 'bysecond': 0}</code> </dt> 
</dl> <dl class="method"> <dt id="matplotlib.dates.DateLocator.nonsingular">
<code>nonsingular(self, vmin, vmax)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#DateLocator.nonsingular"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Given the proposed upper and lower extent, adjust the range if it is too close to being singular (i.e. a range of ~0).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.dates.DateLocator.set_tzinfo">
<code>set_tzinfo(self, tz)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#DateLocator.set_tzinfo"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set time zone info.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.dates.DateLocator.viewlim_to_dt">
<code>viewlim_to_dt(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#DateLocator.viewlim_to_dt"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Converts the view interval to datetime objects.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.RRuleLocator">
<code>class matplotlib.dates.RRuleLocator(o, tz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#RRuleLocator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.dates.DateLocator" title="matplotlib.dates.DateLocator"><code>matplotlib.dates.DateLocator</code></a></p> <dl class="method"> <dt id="matplotlib.dates.RRuleLocator.autoscale">
<code>autoscale(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#RRuleLocator.autoscale"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the view limits to include the data range.</p> </dd>
</dl> <dl class="staticmethod"> <dt id="matplotlib.dates.RRuleLocator.get_unit_generic">
<code>static get_unit_generic(freq)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#RRuleLocator.get_unit_generic"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.dates.RRuleLocator.tick_values">
<code>tick_values(self, vmin, vmax)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#RRuleLocator.tick_values"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the values of the located ticks given <strong>vmin</strong> and <strong>vmax</strong>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>To get tick locations with the vmin and vmax values defined automatically for the associated <code>axis</code> simply call the Locator instance:</p> <pre data-language="python">&gt;&gt;&gt; print(type(loc))
&lt;type 'Locator'&gt;
&gt;&gt;&gt; print(loc())
[1, 2, 3, 4]
</pre> </div> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.AutoDateLocator">
<code>class matplotlib.dates.AutoDateLocator(tz=None, minticks=5, maxticks=None, interval_multiples=True)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#AutoDateLocator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.dates.DateLocator" title="matplotlib.dates.DateLocator"><code>matplotlib.dates.DateLocator</code></a></p> <p>On autoscale, this class picks the best <a class="reference internal" href="#matplotlib.dates.DateLocator" title="matplotlib.dates.DateLocator"><code>DateLocator</code></a> to set the view limits and the tick locations.</p> <p><em>minticks</em> is the minimum number of ticks desired, which is used to select the type of ticking (yearly, monthly, etc.).</p> <p><em>maxticks</em> is the maximum number of ticks desired, which controls any interval between ticks (ticking every other, every 3, etc.). For really fine-grained control, this can be a dictionary mapping individual rrule frequency constants (YEARLY, MONTHLY, etc.) to their own maximum number of ticks. This can be used to keep the number of ticks appropriate to the format chosen in <a class="reference internal" href="#matplotlib.dates.AutoDateFormatter" title="matplotlib.dates.AutoDateFormatter"><code>AutoDateFormatter</code></a>. Any frequency not specified in this dictionary is given a default value.</p> <p><em>tz</em> is a <code>tzinfo</code> instance.</p> <p><em>interval_multiples</em> is a boolean that indicates whether ticks should be chosen to be multiple of the interval. This will lock ticks to 'nicer' locations. For example, this will force the ticks to be at hours 0,6,12,18 when hourly ticking is done at 6 hour intervals.</p> <p>The AutoDateLocator has an interval dictionary that maps the frequency of the tick (a constant from dateutil.rrule) and a multiple allowed for that ticking. The default looks like this:</p> <pre data-language="python">self.intervald = {
  YEARLY  : [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500,
            1000, 2000, 4000, 5000, 10000],
  MONTHLY : [1, 2, 3, 4, 6],
  DAILY   : [1, 2, 3, 7, 14],
  HOURLY  : [1, 2, 3, 4, 6, 12],
  MINUTELY: [1, 5, 10, 15, 30],
  SECONDLY: [1, 5, 10, 15, 30],
  MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000,
                 5000, 10000, 20000, 50000, 100000, 200000, 500000,
                 1000000],
  }
</pre> <p>The interval is used to specify multiples that are appropriate for the frequency of ticking. For instance, every 7 days is sensible for daily ticks, but for minutes/seconds, 15 or 30 make sense. You can customize this dictionary by doing:</p> <pre data-language="python">locator = AutoDateLocator()
locator.intervald[HOURLY] = [3] # only show every 3 hours
</pre> <dl class="method"> <dt id="matplotlib.dates.AutoDateLocator.autoscale">
<code>autoscale(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#AutoDateLocator.autoscale"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Try to choose the view limits intelligently.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.dates.AutoDateLocator.get_locator">
<code>get_locator(self, dmin, dmax)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#AutoDateLocator.get_locator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Pick the best locator based on a distance.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.dates.AutoDateLocator.nonsingular">
<code>nonsingular(self, vmin, vmax)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#AutoDateLocator.nonsingular"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Given the proposed upper and lower extent, adjust the range if it is too close to being singular (i.e. a range of ~0).</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.dates.AutoDateLocator.refresh">
<code>refresh(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#AutoDateLocator.refresh"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Refresh internal information based on current limits.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.dates.AutoDateLocator.set_axis">
<code>set_axis(self, axis)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#AutoDateLocator.set_axis"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.dates.AutoDateLocator.tick_values">
<code>tick_values(self, vmin, vmax)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#AutoDateLocator.tick_values"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the values of the located ticks given <strong>vmin</strong> and <strong>vmax</strong>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>To get tick locations with the vmin and vmax values defined automatically for the associated <code>axis</code> simply call the Locator instance:</p> <pre data-language="python">&gt;&gt;&gt; print(type(loc))
&lt;type 'Locator'&gt;
&gt;&gt;&gt; print(loc())
[1, 2, 3, 4]
</pre> </div> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.YearLocator">
<code>class matplotlib.dates.YearLocator(base=1, month=1, day=1, tz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#YearLocator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.dates.DateLocator" title="matplotlib.dates.DateLocator"><code>matplotlib.dates.DateLocator</code></a></p> <p>Make ticks on a given day of each year that is a multiple of base.</p> <p>Examples:</p> <pre data-language="python"># Tick every year on Jan 1st
locator = YearLocator()

# Tick every 5 years on July 4th
locator = YearLocator(5, month=7, day=4)
</pre> <p>Mark years that are multiple of base on a given month and day (default jan 1).</p> <dl class="method"> <dt id="matplotlib.dates.YearLocator.autoscale">
<code>autoscale(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#YearLocator.autoscale"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the view limits to include the data range.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.dates.YearLocator.tick_values">
<code>tick_values(self, vmin, vmax)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#YearLocator.tick_values"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the values of the located ticks given <strong>vmin</strong> and <strong>vmax</strong>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>To get tick locations with the vmin and vmax values defined automatically for the associated <code>axis</code> simply call the Locator instance:</p> <pre data-language="python">&gt;&gt;&gt; print(type(loc))
&lt;type 'Locator'&gt;
&gt;&gt;&gt; print(loc())
[1, 2, 3, 4]
</pre> </div> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.MonthLocator">
<code>class matplotlib.dates.MonthLocator(bymonth=None, bymonthday=1, interval=1, tz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#MonthLocator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.dates.RRuleLocator" title="matplotlib.dates.RRuleLocator"><code>matplotlib.dates.RRuleLocator</code></a></p> <p>Make ticks on occurrences of each month, e.g., 1, 3, 12.</p> <p>Mark every month in <em>bymonth</em>; <em>bymonth</em> can be an int or sequence. Default is <code>range(1,13)</code>, i.e. every month.</p> <p><em>interval</em> is the interval between each iteration. For example, if <code>interval=2</code>, mark every second occurrence.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.WeekdayLocator">
<code>class matplotlib.dates.WeekdayLocator(byweekday=1, interval=1, tz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#WeekdayLocator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.dates.RRuleLocator" title="matplotlib.dates.RRuleLocator"><code>matplotlib.dates.RRuleLocator</code></a></p> <p>Make ticks on occurrences of each weekday.</p> <p>Mark every weekday in <em>byweekday</em>; <em>byweekday</em> can be a number or sequence.</p> <p>Elements of <em>byweekday</em> must be one of MO, TU, WE, TH, FR, SA, SU, the constants from <a class="reference external" href="https://dateutil.readthedocs.io/en/stable/rrule.html#module-dateutil.rrule" title="(in dateutil v2.8.0)"><code>dateutil.rrule</code></a>, which have been imported into the <a class="reference internal" href="#module-matplotlib.dates" title="matplotlib.dates"><code>matplotlib.dates</code></a> namespace.</p> <p><em>interval</em> specifies the number of weeks to skip. For example, <code>interval=2</code> plots every second week.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.DayLocator">
<code>class matplotlib.dates.DayLocator(bymonthday=None, interval=1, tz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#DayLocator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.dates.RRuleLocator" title="matplotlib.dates.RRuleLocator"><code>matplotlib.dates.RRuleLocator</code></a></p> <p>Make ticks on occurrences of each day of the month. For example, 1, 15, 30.</p> <p>Mark every day in <em>bymonthday</em>; <em>bymonthday</em> can be an int or sequence.</p> <p>Default is to tick every day of the month: <code>bymonthday=range(1,32)</code></p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.HourLocator">
<code>class matplotlib.dates.HourLocator(byhour=None, interval=1, tz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#HourLocator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.dates.RRuleLocator" title="matplotlib.dates.RRuleLocator"><code>matplotlib.dates.RRuleLocator</code></a></p> <p>Make ticks on occurrences of each hour.</p> <p>Mark every hour in <em>byhour</em>; <em>byhour</em> can be an int or sequence. Default is to tick every hour: <code>byhour=range(24)</code></p> <p><em>interval</em> is the interval between each iteration. For example, if <code>interval=2</code>, mark every second occurrence.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.MinuteLocator">
<code>class matplotlib.dates.MinuteLocator(byminute=None, interval=1, tz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#MinuteLocator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.dates.RRuleLocator" title="matplotlib.dates.RRuleLocator"><code>matplotlib.dates.RRuleLocator</code></a></p> <p>Make ticks on occurrences of each minute.</p> <p>Mark every minute in <em>byminute</em>; <em>byminute</em> can be an int or sequence. Default is to tick every minute: <code>byminute=range(60)</code></p> <p><em>interval</em> is the interval between each iteration. For example, if <code>interval=2</code>, mark every second occurrence.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.SecondLocator">
<code>class matplotlib.dates.SecondLocator(bysecond=None, interval=1, tz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#SecondLocator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.dates.RRuleLocator" title="matplotlib.dates.RRuleLocator"><code>matplotlib.dates.RRuleLocator</code></a></p> <p>Make ticks on occurrences of each second.</p> <p>Mark every second in <em>bysecond</em>; <em>bysecond</em> can be an int or sequence. Default is to tick every second: <code>bysecond = range(60)</code></p> <p><em>interval</em> is the interval between each iteration. For example, if <code>interval=2</code>, mark every second occurrence.</p> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.MicrosecondLocator">
<code>class matplotlib.dates.MicrosecondLocator(interval=1, tz=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#MicrosecondLocator"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.dates.DateLocator" title="matplotlib.dates.DateLocator"><code>matplotlib.dates.DateLocator</code></a></p> <p>Make ticks on regular intervals of one or more microsecond(s).</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Due to the floating point representation of time in days since 0001-01-01 UTC (plus 1), plotting data with microsecond time resolution does not work well with current dates.</p> <p>If you want microsecond resolution time plots, it is strongly recommended to use floating point seconds, not datetime-like time representation.</p> <p class="last">If you really must use datetime.datetime() or similar and still need microsecond precision, your only chance is to use very early years; using year 0001 is recommended.</p> </div> <p><em>interval</em> is the interval between each iteration. For example, if <code>interval=2</code>, mark every second microsecond.</p> <dl class="method"> <dt id="matplotlib.dates.MicrosecondLocator.set_axis">
<code>set_axis(self, axis)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#MicrosecondLocator.set_axis"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.dates.MicrosecondLocator.set_data_interval">
<code>set_data_interval(self, vmin, vmax)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#MicrosecondLocator.set_data_interval"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.dates.MicrosecondLocator.set_view_interval">
<code>set_view_interval(self, vmin, vmax)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#MicrosecondLocator.set_view_interval"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="matplotlib.dates.MicrosecondLocator.tick_values">
<code>tick_values(self, vmin, vmax)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#MicrosecondLocator.tick_values"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the values of the located ticks given <strong>vmin</strong> and <strong>vmax</strong>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>To get tick locations with the vmin and vmax values defined automatically for the associated <code>axis</code> simply call the Locator instance:</p> <pre data-language="python">&gt;&gt;&gt; print(type(loc))
&lt;type 'Locator'&gt;
&gt;&gt;&gt; print(loc())
[1, 2, 3, 4]
</pre> </div> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.rrule">
<code>class matplotlib.dates.rrule(freq, dtstart=None, interval=1, wkst=None, count=None, until=None, bysetpos=None, bymonth=None, bymonthday=None, byyearday=None, byeaster=None, byweekno=None, byweekday=None, byhour=None, byminute=None, bysecond=None, cache=False)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/dateutil/rrule.html#rrule"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>dateutil.rrule.rrulebase</code></p> <p>That's the base of the rrule operation. It accepts all the keywords defined in the RFC as its constructor parameters (except byday, which was renamed to byweekday) and more. The constructor prototype is:</p> <pre data-language="python">rrule(freq)
</pre> <p>Where freq must be one of YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, or SECONDLY.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Per RFC section 3.3.10, recurrence instances falling on invalid dates and times are ignored rather than coerced:</p>  Recurrence rules may generate recurrence instances with an invalid date (e.g., February 30) or nonexistent local time (e.g., 1:30 AM on a day where the local time is moved forward by an hour at 1:00 AM). Such recurrence instances MUST be ignored and MUST NOT be counted as part of the recurrence set. <p>This can lead to possibly surprising behavior when, for example, the start date occurs at the end of the month:</p> <pre data-language="python">&gt;&gt;&gt; from dateutil.rrule import rrule, MONTHLY
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; start_date = datetime(2014, 12, 31)
&gt;&gt;&gt; list(rrule(freq=MONTHLY, count=4, dtstart=start_date))
... # doctest: +NORMALIZE_WHITESPACE
[datetime.datetime(2014, 12, 31, 0, 0),
 datetime.datetime(2015, 1, 31, 0, 0),
 datetime.datetime(2015, 3, 31, 0, 0),
 datetime.datetime(2015, 5, 31, 0, 0)]
</pre> </div> <p>Additionally, it supports the following keyword arguments:</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>dtstart</strong> -- The recurrence start. Besides being the base for the recurrence, missing parameters in the final recurrence instances will also be extracted from this date. If not given, datetime.now() will be used instead.</li> <li>
<strong>interval</strong> -- The interval between each freq iteration. For example, when using YEARLY, an interval of 2 means once every two years, but with HOURLY, it means once every two hours. The default interval is 1.</li> <li>
<strong>wkst</strong> -- The week start day. Must be one of the MO, TU, WE constants, or an integer, specifying the first day of the week. This will affect recurrences based on weekly periods. The default week start is got from calendar.firstweekday(), and may be modified by calendar.setfirstweekday().</li> <li>
<strong>count</strong> -- <p>If given, this determines how many occurrences will be generated.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">As of version 2.5.0, the use of the keyword <code>until</code> in conjunction with <code>count</code> is deprecated, to make sure <code>dateutil</code> is fully compliant with <a class="reference external" href="https://tools.ietf.org/html/rfc5545#section-3.3.10">RFC-5545 Sec. 3.3.10</a>. Therefore, <code>until</code> and <code>count</code> <strong>must not</strong> occur in the same call to <code>rrule</code>.</p> </div> </li> <li>
<strong>until</strong> -- <p>If given, this must be a datetime instance specifying the upper-bound limit of the recurrence. The last recurrence in the rule is the greatest datetime that is less than or equal to the value specified in the <code>until</code> parameter.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">As of version 2.5.0, the use of the keyword <code>until</code> in conjunction with <code>count</code> is deprecated, to make sure <code>dateutil</code> is fully compliant with <a class="reference external" href="https://tools.ietf.org/html/rfc5545#section-3.3.10">RFC-5545 Sec. 3.3.10</a>. Therefore, <code>until</code> and <code>count</code> <strong>must not</strong> occur in the same call to <code>rrule</code>.</p> </div> </li> <li>
<strong>bysetpos</strong> -- If given, it must be either an integer, or a sequence of integers, positive or negative. Each given integer will specify an occurrence number, corresponding to the nth occurrence of the rule inside the frequency period. For example, a bysetpos of -1 if combined with a MONTHLY frequency, and a byweekday of (MO, TU, WE, TH, FR), will result in the last work day of every month.</li> <li>
<strong>bymonth</strong> -- If given, it must be either an integer, or a sequence of integers, meaning the months to apply the recurrence to.</li> <li>
<strong>bymonthday</strong> -- If given, it must be either an integer, or a sequence of integers, meaning the month days to apply the recurrence to.</li> <li>
<strong>byyearday</strong> -- If given, it must be either an integer, or a sequence of integers, meaning the year days to apply the recurrence to.</li> <li>
<strong>byeaster</strong> -- If given, it must be either an integer, or a sequence of integers, positive or negative. Each integer will define an offset from the Easter Sunday. Passing the offset 0 to byeaster will yield the Easter Sunday itself. This is an extension to the RFC specification.</li> <li>
<strong>byweekno</strong> -- If given, it must be either an integer, or a sequence of integers, meaning the week numbers to apply the recurrence to. Week numbers have the meaning described in ISO8601, that is, the first week of the year is that containing at least four days of the new year.</li> <li>
<strong>byweekday</strong> -- If given, it must be either an integer (0 == MO), a sequence of integers, one of the weekday constants (MO, TU, etc), or a sequence of these constants. When given, these variables will define the weekdays where the recurrence will be applied. It's also possible to use an argument n for the weekday instances, which will mean the nth occurrence of this weekday in the period. For example, with MONTHLY, or with YEARLY and BYMONTH, using FR(+1) in byweekday will specify the first friday of the month where the recurrence happens. Notice that in the RFC documentation, this is specified as BYDAY, but was renamed to avoid the ambiguity of that keyword.</li> <li>
<strong>byhour</strong> -- If given, it must be either an integer, or a sequence of integers, meaning the hours to apply the recurrence to.</li> <li>
<strong>byminute</strong> -- If given, it must be either an integer, or a sequence of integers, meaning the minutes to apply the recurrence to.</li> <li>
<strong>bysecond</strong> -- If given, it must be either an integer, or a sequence of integers, meaning the seconds to apply the recurrence to.</li> <li>
<strong>cache</strong> -- If given, it must be a boolean value specifying to enable or disable caching of results. If you will use the same rrule instance multiple times, enabling caching will improve the performance considerably.</li> </ul> </td> </tr>  </table> <dl class="method"> <dt id="matplotlib.dates.rrule.replace">
<code>replace(self, **kwargs)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/dateutil/rrule.html#rrule.replace"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return new rrule with same attributes except for those attributes given new values by whichever keyword arguments are specified.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="matplotlib.dates.relativedelta">
<code>class matplotlib.dates.relativedelta(dt1=None, dt2=None, years=0, months=0, days=0, leapdays=0, weeks=0, hours=0, minutes=0, seconds=0, microseconds=0, year=None, month=None, day=None, weekday=None, yearday=None, nlyearday=None, hour=None, minute=None, second=None, microsecond=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/dateutil/relativedelta.html#relativedelta"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <p>The relativedelta type is designed to be applied to an existing datetime and can replace specific components of that datetime, or represents an interval of time.</p> <p>It is based on the specification of the excellent work done by M.-A. Lemburg in his <a class="reference external" href="https://www.egenix.com/products/python/mxBase/mxDateTime/">mx.DateTime</a> extension. However, notice that this type does <em>NOT</em> implement the same algorithm as his work. Do <em>NOT</em> expect it to behave like mx.DateTime's counterpart.</p> <p>There are two different ways to build a relativedelta instance. The first one is passing it two date/datetime classes:</p> <pre data-language="python">relativedelta(datetime1, datetime2)
</pre> <p>The second one is passing it any number of the following keyword arguments:</p> <pre data-language="python">relativedelta(arg1=x,arg2=y,arg3=z...)

year, month, day, hour, minute, second, microsecond:
    Absolute information (argument is singular); adding or subtracting a
    relativedelta with absolute information does not perform an arithmetic
    operation, but rather REPLACES the corresponding value in the
    original datetime with the value(s) in relativedelta.

years, months, weeks, days, hours, minutes, seconds, microseconds:
    Relative information, may be negative (argument is plural); adding
    or subtracting a relativedelta with relative information performs
    the corresponding aritmetic operation on the original datetime value
    with the information in the relativedelta.

weekday: 
    One of the weekday instances (MO, TU, etc) available in the
    relativedelta module. These instances may receive a parameter N,
    specifying the Nth weekday, which could be positive or negative
    (like MO(+1) or MO(-2)). Not specifying it is the same as specifying
    +1. You can also use an integer, where 0=MO. This argument is always
    relative e.g. if the calculated date is already Monday, using MO(1)
    or MO(-1) won't change the day. To effectively make it absolute, use
    it in combination with the day argument (e.g. day=1, MO(1) for first
    Monday of the month).

leapdays:
    Will add given days to the date found, if year is a leap
    year, and the date found is post 28 of february.

yearday, nlyearday:
    Set the yearday or the non-leap year day (jump leap days).
    These are converted to day/month/leapdays information.
</pre> <p>There are relative and absolute forms of the keyword arguments. The plural is relative, and the singular is absolute. For each argument in the order below, the absolute form is applied first (by setting each attribute to that value) and then the relative form (by adding the value to the attribute).</p> <p>The order of attributes considered when this relativedelta is added to a datetime is:</p> <ol class="arabic simple"> <li>Year</li> <li>Month</li> <li>Day</li> <li>Hours</li> <li>Minutes</li> <li>Seconds</li> <li>Microseconds</li> </ol> <p>Finally, weekday is applied, using the rule described above.</p> <p>For example</p> <pre data-language="python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; from dateutil.relativedelta import relativedelta, MO
&gt;&gt;&gt; dt = datetime(2018, 4, 9, 13, 37, 0)
&gt;&gt;&gt; delta = relativedelta(hours=25, day=1, weekday=MO(1))
&gt;&gt;&gt; dt + delta
datetime.datetime(2018, 4, 2, 14, 37)
</pre> <p>First, the day is set to 1 (the first of the month), then 25 hours are added, to get to the 2nd day and 14th hour, finally the weekday is applied, but since the 2nd is already a Monday there is no effect.</p> <dl class="method"> <dt id="matplotlib.dates.relativedelta.normalized">
<code>normalized(self)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/dateutil/relativedelta.html#relativedelta.normalized"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a version of this object represented entirely using integer values for the relative attributes.</p> <pre data-language="python">&gt;&gt;&gt; relativedelta(days=1.5, hours=2).normalized()
relativedelta(days=+1, hours=+14)
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">Returns a <a class="reference external" href="https://dateutil.readthedocs.io/en/stable/relativedelta.html#dateutil.relativedelta.relativedelta" title="(in dateutil v2.8.0)"><code>dateutil.relativedelta.relativedelta</code></a> object.</td> </tr>  </table> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.dates.relativedelta.weeks">
<code>weeks</code> </dt> 
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.dates.seconds">
<code>matplotlib.dates.seconds(s)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#seconds"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>[<em>Deprecated</em>] Return seconds as days.</p> <h4 class="rubric">Notes</h4> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.1.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.dates.minutes">
<code>matplotlib.dates.minutes(m)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#minutes"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>[<em>Deprecated</em>] Return minutes as days.</p> <h4 class="rubric">Notes</h4> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.1.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.dates.hours">
<code>matplotlib.dates.hours(h)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#hours"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>[<em>Deprecated</em>] Return hours as days.</p> <h4 class="rubric">Notes</h4> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.1.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="matplotlib.dates.weeks">
<code>matplotlib.dates.weeks(w)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/dates.html#weeks"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>[<em>Deprecated</em>] Return weeks as days.</p> <h4 class="rubric">Notes</h4> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.1.</span></p> </div> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2018 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/3.1.1/api/dates_api.html" class="_attribution-link">https://matplotlib.org/3.1.1/api/dates_api.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
