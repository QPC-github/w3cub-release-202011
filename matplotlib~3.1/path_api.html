
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Path - Matplotlib 3.1 - W3cubDocs</title>
  
  <meta name="description" content=" A module for dealing with the polylines used throughout Matplotlib. ">
  <meta name="keywords" content="matplotlib, path, matplotlib~3.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="https://docs.w3cub.com/matplotlib~3.1/path_api.html">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-e4ebd3a2a5652ff55173659804c4390a004917f3bdd17b5bb3ba78ea5c9c46fe181cadaac34517ccd815f5bdc982bbfe67179d6f4ac2f084ef2265e2a3dc8dc5.css" integrity="sha512-5OvToqVlL/VRc2WYBMQ5CgBJF/O90Xtbs7p46lycRv4YHK2qw0UXzNgV9b3Jgrv+Zxedb0rC8ITvImXio9yNxQ==" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha512-EpkDeu98lN/jPKijllzVWdRg/dUSSMCaldYZNFz6bcNoBvpWRNz0HSTRQJ3ENmQc5Cuj1zDW1vHd7b0DzpOgyA==" crossorigin="anonymous" src="/assets/application-1299037aef7c94dfe33ca8a3965cd559d460fdd51248c09a95d619345cfa6dc36806fa5644dcf41d24d1409dc436641ce42ba3d730d6d6f1ddedbd03ce93a0c8.js"></script>
  <script src="/json/matplotlib~3.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script data-ad-client="ca-pub-2572770204602497" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
	</amp-auto-ads>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/matplotlib~3.1/" class="_nav-link" title="" style="margin-left:0;">Matplotlib 3.1</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list-wrap">
			<div class="_list">
			
			</div>
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _sphinx">
				
				
<h1 id="matplotlib-path">matplotlib.path</h1> <p id="module-matplotlib.path">A module for dealing with the polylines used throughout Matplotlib.</p> <p>The primary class for polyline handling in Matplotlib is <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>. Almost all vector drawing makes use of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>s somewhere in the drawing pipeline.</p> <p>Whilst a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance itself cannot be drawn, some <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a> subclasses, such as <a class="reference internal" href="_as_gen/matplotlib.patches.pathpatch#matplotlib.patches.PathPatch" title="matplotlib.patches.PathPatch"><code>PathPatch</code></a> and <a class="reference internal" href="collections_api#matplotlib.collections.PathCollection" title="matplotlib.collections.PathCollection"><code>PathCollection</code></a>, can be used for convenient <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> visualisation.</p> <dl class="class"> <dt id="matplotlib.path.Path">
<code>class matplotlib.path.Path(vertices, codes=None, _interpolation_steps=1, closed=False, readonly=False)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code>object</code></a></p> <p><a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> represents a series of possibly disconnected, possibly closed, line and curve segments.</p> <dl class="docutils"> <dt>The underlying storage is made up of two parallel numpy arrays:</dt> <dd>
<ul class="first last simple"> <li>
<em>vertices</em>: an Nx2 float array of vertices</li> <li>
<em>codes</em>: an N-length uint8 array of vertex types</li> </ul> </dd> </dl> <p>These two arrays always have the same length in the first dimension. For example, to represent a cubic curve, you must provide three vertices as well as three codes <code>CURVE3</code>.</p> <p>The code types are:</p>  <ul class="simple"> <li>
<dl class="first docutils"> <dt>
<code>STOP : 1 vertex (ignored)</code> </dt> <dd>A marker for the end of the entire path (currently not required and ignored)</dd> </dl> </li> <li>
<dl class="first docutils"> <dt>
<code>MOVETO : 1 vertex</code> </dt> <dd>Pick up the pen and move to the given vertex.</dd> </dl> </li> <li>
<dl class="first docutils"> <dt>
<code>LINETO : 1 vertex</code> </dt> <dd>Draw a line from the current position to the given vertex.</dd> </dl> </li> <li>
<dl class="first docutils"> <dt>
<code>CURVE3 : 1 control point, 1 endpoint</code> </dt> <dd>Draw a quadratic Bezier curve from the current position, with the given control point, to the given end point.</dd> </dl> </li> <li>
<dl class="first docutils"> <dt>
<code>CURVE4 : 2 control points, 1 endpoint</code> </dt> <dd>Draw a cubic Bezier curve from the current position, with the given control points, to the given end point.</dd> </dl> </li> <li>
<dl class="first docutils"> <dt>
<code>CLOSEPOLY : 1 vertex (ignored)</code> </dt> <dd>Draw a line segment to the start point of the current polyline.</dd> </dl> </li> </ul>  <p>Users of Path objects should not access the vertices and codes arrays directly. Instead, they should use <a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><code>iter_segments()</code></a> or <a class="reference internal" href="#matplotlib.path.Path.cleaned" title="matplotlib.path.Path.cleaned"><code>cleaned()</code></a> to get the vertex/code pairs. This is important, since many <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> objects, as an optimization, do not store a <em>codes</em> at all, but have a default one provided for them by <a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><code>iter_segments()</code></a>.</p> <p>Some behavior of Path objects can be controlled by rcParams. See the rcParams whose keys contain 'path.'.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The vertices and codes arrays should be treated as immutable -- there are a number of optimizations and assumptions made up front in the constructor that will not change when the data changes.</p> </div> <p>Create a new path with the given vertices and codes.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>vertices : array_like</code> </dt> <dd>
<p class="first">The <code>(n, 2)</code> float array, masked array or sequence of pairs representing the vertices of the path.</p> <p class="last">If <em>vertices</em> contains masked values, they will be converted to NaNs which are then handled correctly by the Agg PathIterator and other consumers of path data, such as <a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><code>iter_segments()</code></a>.</p> </dd> <dt>
<code>codes : {None, array_like}, optional</code> </dt> <dd>
<p class="first last">n-length array integers representing the codes of the path. If not None, codes must be the same length as vertices. If None, <em>vertices</em> will be treated as a series of line segments.</p> </dd> <dt>
<code>_interpolation_steps : int, optional</code> </dt> <dd>
<p class="first last">Used as a hint to certain projections, such as Polar, that this path should be linearly interpolated immediately before drawing. This attribute is primarily an implementation detail and is not intended for public use.</p> </dd> <dt>
<code>closed : bool, optional</code> </dt> <dd>
<p class="first last">If <em>codes</em> is None and closed is True, vertices will be treated as line segments of a closed polygon.</p> </dd> <dt>
<code>readonly : bool, optional</code> </dt> <dd>
<p class="first last">Makes the path behave in an immutable way and sets the vertices and codes as read-only arrays.</p> </dd> </dl> </td> </tr>  </table> <dl class="attribute"> <dt id="matplotlib.path.Path.CLOSEPOLY">
<code>CLOSEPOLY = 79</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.CURVE3">
<code>CURVE3 = 3</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.CURVE4">
<code>CURVE4 = 4</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.LINETO">
<code>LINETO = 2</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.MOVETO">
<code>MOVETO = 1</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.NUM_VERTICES_FOR_CODE">
<code>NUM_VERTICES_FOR_CODE = {0: 1, 1: 1, 2: 1, 3: 2, 4: 3, 79: 1}</code> </dt> <dd>
<p>A dictionary mapping Path codes to the number of vertices that the code expects.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.STOP">
<code>STOP = 0</code> </dt> 
</dl> <dl class="classmethod"> <dt id="matplotlib.path.Path.arc">
<code>classmethod arc(theta1, theta2, n=None, is_wedge=False)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.arc"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the unit circle arc from angles <em>theta1</em> to <em>theta2</em> (in degrees).</p> <p><em>theta2</em> is unwrapped to produce the shortest arc within 360 degrees. That is, if <em>theta2</em> &gt; <em>theta1</em> + 360, the arc will be from <em>theta1</em> to <em>theta2</em> - 360 and not a full circle plus some extra overlap.</p> <p>If <em>n</em> is provided, it is the number of spline segments to make. If <em>n</em> is not provided, the number of spline segments is determined based on the delta between <em>theta1</em> and <em>theta2</em>.</p>  Masionobe, L. 2003. <a class="reference external" href="http://www.spaceroots.org/documents/ellipse/index.html">Drawing an elliptical arc using polylines, quadratic or cubic Bezier curves</a>. </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.path.Path.circle">
<code>classmethod circle(center=(0.0, 0.0), radius=1.0, readonly=False)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.circle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> representing a circle of a given radius and center.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>center : pair of floats</code> </dt> <dd>
<p class="first last">The center of the circle. Default <code>(0, 0)</code>.</p> </dd> <dt>
<code>radius : float</code> </dt> <dd>
<p class="first last">The radius of the circle. Default is 1.</p> </dd> <dt>
<code>readonly : bool</code> </dt> <dd>
<p class="first last">Whether the created path should have the "readonly" argument set when creating the Path instance.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The circle is approximated using 8 cubic Bezier curves, as described in</p>  Lancaster, Don. <a class="reference external" href="http://www.tinaja.com/glib/ellipse4.pdf">Approximating a Circle or an Ellipse Using Four Bezier Cubic Splines</a>. </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.cleaned">
<code>cleaned(self, transform=None, remove_nans=False, clip=None, quantize=False, simplify=False, curves=False, stroke_width=1.0, snap=False, sketch=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.cleaned"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a new Path with vertices and codes cleaned according to the parameters.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><code>Path.iter_segments</code></a>
</dt> <dd>for details of the keyword arguments.</dd> </dl> </div> </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.clip_to_bbox">
<code>clip_to_bbox(self, bbox, inside=True)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.clip_to_bbox"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Clip the path to the given bounding box.</p> <p>The path must be made up of one or more closed polygons. This algorithm will not behave correctly for unclosed paths.</p> <p>If <em>inside</em> is <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.7)"><code>True</code></a>, clip to the inside of the box, otherwise to the outside of the box.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.code_type">
<code>code_type</code> </dt> <dd>
<p>alias of <code>numpy.uint8</code></p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.codes">
<code>codes</code> </dt> <dd>
<p>The list of codes in the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> as a 1-D numpy array. Each code is one of <a class="reference internal" href="#matplotlib.path.Path.STOP" title="matplotlib.path.Path.STOP"><code>STOP</code></a>, <a class="reference internal" href="#matplotlib.path.Path.MOVETO" title="matplotlib.path.Path.MOVETO"><code>MOVETO</code></a>, <a class="reference internal" href="#matplotlib.path.Path.LINETO" title="matplotlib.path.Path.LINETO"><code>LINETO</code></a>, <a class="reference internal" href="#matplotlib.path.Path.CURVE3" title="matplotlib.path.Path.CURVE3"><code>CURVE3</code></a>, <a class="reference internal" href="#matplotlib.path.Path.CURVE4" title="matplotlib.path.Path.CURVE4"><code>CURVE4</code></a> or <a class="reference internal" href="#matplotlib.path.Path.CLOSEPOLY" title="matplotlib.path.Path.CLOSEPOLY"><code>CLOSEPOLY</code></a>. For codes that correspond to more than one vertex (<a class="reference internal" href="#matplotlib.path.Path.CURVE3" title="matplotlib.path.Path.CURVE3"><code>CURVE3</code></a> and <a class="reference internal" href="#matplotlib.path.Path.CURVE4" title="matplotlib.path.Path.CURVE4"><code>CURVE4</code></a>), that code will be repeated so that the length of <code>self.vertices</code> and <code>self.codes</code> is always the same.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.contains_path">
<code>contains_path(self, path, transform=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.contains_path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns whether this (closed) path completely contains the given path.</p> <p>If <em>transform</em> is not <code>None</code>, the path will be transformed before performing the test.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.contains_point">
<code>contains_point(self, point, transform=None, radius=0.0)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.contains_point"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns whether the (closed) path contains the given point.</p> <p>If <em>transform</em> is not <code>None</code>, the path will be transformed before performing the test.</p> <p><em>radius</em> allows the path to be made slightly larger or smaller.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.contains_points">
<code>contains_points(self, points, transform=None, radius=0.0)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.contains_points"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a bool array which is <code>True</code> if the (closed) path contains the corresponding point.</p> <p>If <em>transform</em> is not <code>None</code>, the path will be transformed before performing the test.</p> <p><em>radius</em> allows the path to be made slightly larger or smaller.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.copy">
<code>copy(self)</code> </dt> <dd>
<p>Returns a shallow copy of the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>, which will share the vertices and codes with the source <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.deepcopy">
<code>deepcopy(self, memo=None)</code> </dt> <dd>
<p>Returns a deepcopy of the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>. The <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> will not be readonly, even if the source <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> is.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.get_extents">
<code>get_extents(self, transform=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.get_extents"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the extents (<em>xmin</em>, <em>ymin</em>, <em>xmax</em>, <em>ymax</em>) of the path.</p> <p>Unlike computing the extents on the <em>vertices</em> alone, this algorithm will take into account the curves and deal with control points appropriately.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.has_nonfinite">
<code>has_nonfinite</code> </dt> 
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.hatch">
<code>hatch(hatchpattern, density=6)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.hatch"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Given a hatch specifier, <em>hatchpattern</em>, generates a Path that can be used in a repeated hatching pattern. <em>density</em> is the number of lines per unit square.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.interpolated">
<code>interpolated(self, steps)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.interpolated"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a new path resampled to length N x steps. Does not currently handle interpolating curves.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.intersects_bbox">
<code>intersects_bbox(self, bbox, filled=True)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.intersects_bbox"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns <em>True</em> if this path intersects a given <a class="reference internal" href="transformations#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code>Bbox</code></a>.</p> <p><em>filled</em>, when True, treats the path as if it was filled. That is, if the path completely encloses the bounding box, <a class="reference internal" href="#matplotlib.path.Path.intersects_bbox" title="matplotlib.path.Path.intersects_bbox"><code>intersects_bbox()</code></a> will return True.</p> <p>The bounding box is always considered filled.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.intersects_path">
<code>intersects_path(self, other, filled=True)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.intersects_path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns <em>True</em> if this path intersects another given path.</p> <p><em>filled</em>, when True, treats the paths as if they were filled. That is, if one path completely encloses the other, <a class="reference internal" href="#matplotlib.path.Path.intersects_path" title="matplotlib.path.Path.intersects_path"><code>intersects_path()</code></a> will return True.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.iter_segments">
<code>iter_segments(self, transform=None, remove_nans=True, clip=None, snap=False, stroke_width=1.0, simplify=None, curves=True, sketch=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.iter_segments"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Iterates over all of the curve segments in the path. Each iteration returns a 2-tuple <code>(vertices, code)</code>, where <code>vertices</code> is a sequence of 1-3 coordinate pairs, and <code>code</code> is a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> code.</p> <p>Additionally, this method can provide a number of standard cleanups and conversions to the path.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>transform : None or Transform</code> </dt> <dd>
<p class="first last">If not None, the given affine transformation will be applied to the path.</p> </dd> <dt>
<code>remove_nans : bool, optional</code> </dt> <dd>
<p class="first last">Whether to remove all NaNs from the path and skip over them using MOVETO commands.</p> </dd> <dt>
<code>clip : None or (float, float, float, float), optional</code> </dt> <dd>
<p class="first last">If not None, must be a four-tuple (x1, y1, x2, y2) defining a rectangle in which to clip the path.</p> </dd> <dt>
<code>snap : None or bool, optional</code> </dt> <dd>
<p class="first last">If True, snap all nodes to pixels; if False, don't snap them. If None, perform snapping if the path contains only segments parallel to the x or y axes, and no more than 1024 of them.</p> </dd> <dt>
<code>stroke_width : float, optional</code> </dt> <dd>
<p class="first last">The width of the stroke being drawn (used for path snapping).</p> </dd> <dt>
<code>simplify : None or bool, optional</code> </dt> <dd>
<p class="first last">Whether to simplify the path by removing vertices that do not affect its appearance. If None, use the <a class="reference internal" href="#matplotlib.path.Path.should_simplify" title="matplotlib.path.Path.should_simplify"><code>should_simplify</code></a> attribute. See also <code><a class="reference external" href="https://matplotlib.org/3.1.1/tutorials/introductory/customizing.html#matplotlib-rcparams">rcParams["path.simplify"]</a></code> and <code><a class="reference external" href="https://matplotlib.org/3.1.1/tutorials/introductory/customizing.html#matplotlib-rcparams">rcParams["path.simplify_threshold"]</a></code>.</p> </dd> <dt>
<code>curves : bool, optional</code> </dt> <dd>
<p class="first last">If True, curve segments will be returned as curve segments. If False, all curves will be converted to line segments.</p> </dd> <dt>
<code>sketch : None or sequence, optional</code> </dt> <dd>
<p class="first last">If not None, must be a 3-tuple of the form (scale, length, randomness), representing the sketch parameters.</p> </dd> </dl> </td> </tr>  </table> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.path.Path.make_compound_path">
<code>classmethod make_compound_path(*args)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.make_compound_path"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Make a compound path from a list of Path objects.</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.path.Path.make_compound_path_from_polys">
<code>classmethod make_compound_path_from_polys(XY)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.make_compound_path_from_polys"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Make a compound path object to draw a number of polygons with equal numbers of sides XY is a (numpolys x numsides x 2) numpy array of vertices. Return object is a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a></p> <p>(<a class="reference external" href="https://matplotlib.org/3.1.1/gallery/misc/histogram_path.py">Source code</a>, <a class="reference external" href="https://matplotlib.org/3.1.1/gallery/misc/histogram_path_00_00.png">png</a>, <a class="reference external" href="https://matplotlib.org/3.1.1/gallery/misc/histogram_path_00_00.pdf">pdf</a>)</p> <div class="figure"> <img alt="../_images/histogram_path_00_00.png" src="data:image/png;base64,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"> </div> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.readonly">
<code>readonly</code> </dt> <dd>
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.7)"><code>True</code></a> if the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> is read-only.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.should_simplify">
<code>should_simplify</code> </dt> <dd>
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.7)"><code>True</code></a> if the vertices array should be simplified.</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.simplify_threshold">
<code>simplify_threshold</code> </dt> <dd>
<p>The fraction of a pixel difference below which vertices will be simplified out.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.to_polygons">
<code>to_polygons(self, transform=None, width=0, height=0, closed_only=True)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.to_polygons"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Convert this path to a list of polygons or polylines. Each polygon/polyline is an Nx2 array of vertices. In other words, each polygon has no <code>MOVETO</code> instructions or curves. This is useful for displaying in backends that do not support compound paths or Bezier curves.</p> <p>If <em>width</em> and <em>height</em> are both non-zero then the lines will be simplified so that vertices outside of (0, 0), (width, height) will be clipped.</p> <p>If <em>closed_only</em> is <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.7)"><code>True</code></a> (default), only closed polygons, with the last point being the same as the first point, will be returned. Any unclosed polylines in the path will be explicitly closed. If <em>closed_only</em> is <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.7)"><code>False</code></a>, any unclosed polygons in the path will be returned as unclosed polygons, and the closed polygons will be returned explicitly closed by setting the last point to the same as the first point.</p> </dd>
</dl> <dl class="method"> <dt id="matplotlib.path.Path.transformed">
<code>transformed(self, transform)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.transformed"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a transformed copy of the path.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
 <a class="reference internal" href="transformations#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code>matplotlib.transforms.TransformedPath</code></a>
</dt> <dd>A specialized path class that will cache the transformed result and automatically update when the transform changes.</dd> </dl> </div> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.path.Path.unit_circle">
<code>classmethod unit_circle()</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.unit_circle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the readonly <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> of the unit circle.</p> <p>For most cases, <a class="reference internal" href="#matplotlib.path.Path.circle" title="matplotlib.path.Path.circle"><code>Path.circle()</code></a> will be what you want.</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.path.Path.unit_circle_righthalf">
<code>classmethod unit_circle_righthalf()</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.unit_circle_righthalf"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> of the right half of a unit circle.</p> <p>See <a class="reference internal" href="#matplotlib.path.Path.circle" title="matplotlib.path.Path.circle"><code>Path.circle</code></a> for the reference on the approximation used.</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.path.Path.unit_rectangle">
<code>classmethod unit_rectangle()</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.unit_rectangle"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance of the unit rectangle from (0, 0) to (1, 1).</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.path.Path.unit_regular_asterisk">
<code>classmethod unit_regular_asterisk(numVertices)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.unit_regular_asterisk"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> for a unit regular asterisk with the given numVertices and radius of 1.0, centered at (0, 0).</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.path.Path.unit_regular_polygon">
<code>classmethod unit_regular_polygon(numVertices)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.unit_regular_polygon"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instance for a unit regular polygon with the given <em>numVertices</em> and radius of 1.0, centered at (0, 0).</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.path.Path.unit_regular_star">
<code>classmethod unit_regular_star(numVertices, innerCircle=0.5)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.unit_regular_star"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> for a unit regular star with the given numVertices and radius of 1.0, centered at (0, 0).</p> </dd>
</dl> <dl class="attribute"> <dt id="matplotlib.path.Path.vertices">
<code>vertices</code> </dt> <dd>
<p>The list of vertices in the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> as an Nx2 numpy array.</p> </dd>
</dl> <dl class="classmethod"> <dt id="matplotlib.path.Path.wedge">
<code>classmethod wedge(theta1, theta2, n=None)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#Path.wedge"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the unit circle wedge from angles <em>theta1</em> to <em>theta2</em> (in degrees).</p> <p><em>theta2</em> is unwrapped to produce the shortest wedge within 360 degrees. That is, if <em>theta2</em> &gt; <em>theta1</em> + 360, the wedge will be from <em>theta1</em> to <em>theta2</em> - 360 and not a full circle plus some extra overlap.</p> <p>If <em>n</em> is provided, it is the number of spline segments to make. If <em>n</em> is not provided, the number of spline segments is determined based on the delta between <em>theta1</em> and <em>theta2</em>.</p> <p>See <a class="reference internal" href="#matplotlib.path.Path.arc" title="matplotlib.path.Path.arc"><code>Path.arc</code></a> for the reference on the approximation used.</p> </dd>
</dl> </dd>
</dl> <dl class="function"> <dt id="matplotlib.path.get_path_collection_extents">
<code>matplotlib.path.get_path_collection_extents(master_transform, paths, transforms, offsets, offset_transform)</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#get_path_collection_extents"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Given a sequence of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a>s, <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a>s objects, and offsets, as found in a <a class="reference internal" href="collections_api#matplotlib.collections.PathCollection" title="matplotlib.collections.PathCollection"><code>PathCollection</code></a>, returns the bounding box that encapsulates all of them.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<dl class="first last docutils"> <dt>
<code>master_transform : Transform</code> </dt> <dd>
<p class="first last">Global transformation applied to all paths.</p> </dd> <dt>
<code>paths : list of Path</code> </dt>  <dt>
<code>transform : list of Affine2D</code> </dt>  <dt>
<code>offsets : (N, 2) array-like</code> </dt>  <dt>
<code>offset_transform : Affine2D</code> </dt> <dd>
<p class="first last">Transform applied to the offsets before offsetting the path.</p> </dd> </dl> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The way that <em>paths</em>, <em>transforms</em> and <em>offsets</em> are combined follows the same method as for collections: Each is iterated over independently, so if you have 3 paths, 2 transforms and 1 offset, their combinations are as follows:</p>  (A, A, A), (B, B, A), (C, A, A) </dd>
</dl> <dl class="function"> <dt id="matplotlib.path.get_paths_extents">
<code>matplotlib.path.get_paths_extents(paths, transforms=[])</code> <a class="reference internal" href="https://matplotlib.org/3.1.1/_modules/matplotlib/path.html#get_paths_extents"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>[<em>Deprecated</em>] Given a sequence of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> objects and optional <a class="reference internal" href="transformations#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code>Transform</code></a> objects, returns the bounding box that encapsulates all of them.</p> <p><em>paths</em> is a sequence of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><code>Path</code></a> instances.</p> <p><em>transforms</em> is an optional sequence of <a class="reference internal" href="transformations#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code>Affine2D</code></a> instances to apply to each path.</p> <h4 class="rubric">Notes</h4> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.1.</span></p> </div> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012–2018 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/3.1.1/api/path_api.html" class="_attribution-link">https://matplotlib.org/3.1.1/api/path_api.html</a>
  </p>
</div>

				
			</div>
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
